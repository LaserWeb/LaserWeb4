{"version":3,"sources":["webpack:///webpack/bootstrap bf318332cf852a19e2ee","webpack:///./lib/workers/cam-raster.js","webpack:///../~/lw.raster-to-gcode/dist/lw.raster-to-gcode.js"],"names":["self","onmessage","event","data","cmd","start","rasterToGcode","settings","Object","assign","properties","on","postMessage","run","abort"],"mappings":";AAAA;AACA;AACA;AACA,mCAA2B;AAC3B;AACA,YAAI;AACJ;AACA,WAAG;AACH;AACA;;AAEA;AACA,sDAA8C;AAC9C;AACA,qCAA6B;;AAE7B,+CAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAM;AACN,aAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAS;AACT;AACA;AACA;AACA;AACA,eAAO;AACP,cAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;AACA;AACA;AACA;AACA,aAAK;AACL,YAAI;AACJ;AACA;AACA;AACA;;AAEA,8CAAsC;AACtC;AACA;AACA,qCAA6B;AAC7B,qCAA6B;AAC7B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAAoB,gBAAgB;AACpC;AACA;AACA;AACA,aAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,4BAAoB,gBAAgB;AACpC;AACA,aAAK;AACL;AACA;AACA,aAAK;AACL;AACA;AACA,aAAK;AACL;AACA;AACA;AACA,aAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;AACA,aAAK;AACL;AACA;AACA;AACA,aAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,yBAAiB,8BAA8B;AAC/C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0BAAkB,qBAAqB;AACvC;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,YAAI;AACJ;;AAEA,4DAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAI;AACJ;AACA;AACA;AACA,YAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAAmB,2BAA2B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,0BAAkB,cAAc;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yBAAiB,4BAA4B;AAC7C;AACA;AACA;AACA;AACA;AACA,cAAM;AACN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,0BAAkB,4BAA4B;AAC9C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,0BAAkB,4BAA4B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,2BAAmB,uCAAuC;AAC1D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAAmB,uCAAuC;AAC1D;AACA;AACA;AACA;AACA;AACA,2BAAmB,sBAAsB;AACzC;AACA;AACA;AACA,eAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAiB,wCAAwC;AACzD;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;AACA;AACA,eAAO;AACP;AACA;AACA;AACA,cAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,8CAAsC,uBAAuB;;AAE7D;AACA;;;;;;;;;;;AC3gBA;;AAEA;AACAA,MAAKC,SAAL,GAAiB,UAAUC,KAAV,EAAiB;AAC9B,SAAIA,MAAMC,IAAN,CAAWC,GAAX,KAAmB,OAAvB,EAAgC;AAC5BC,eAAMH,MAAMC,IAAZ;AACH;AACJ,EAJD;;AAQA;AACA,UAASE,KAAT,CAAeF,IAAf,EAAqB;;AAEjB;AACA,SAAIG,gBAAgB,sBAAkBH,KAAKI,QAAvB,CAApB;AACIC,YAAOC,MAAP,CAAeH,aAAf,EAA8BH,KAAKO,UAAnC;AACJ;AACIJ,mBAAcK,EAAd,CAAiB,UAAjB,EAA6B,UAAUT,KAAV,EAAiB;AAC1CF,cAAKY,WAAL,YAAmBV,OAAO,YAA1B,IAA2CA,KAA3C;AACH,MAFD,EAEGS,EAFH,CAEM,MAFN,EAEc,UAAUT,KAAV,EAAiB;AAC3BF,cAAKY,WAAL,YAAmBV,OAAO,QAA1B,IAAuCA,KAAvC;AACH,MAJD,EAIGS,EAJH,CAIM,OAJN,EAIe,YAAY;AACvBX,cAAKY,WAAL,CAAiB,EAAEV,OAAO,SAAT,EAAjB;AACH,MAND;;AASJF,UAAKY,WAAL,CAAiB,EAAEV,OAAO,OAAT,EAAjB;AACAI,mBAAcO,GAAd;AAEH;;AAED;AACA,UAASC,KAAT,GAAiB;AACbR,mBAAcQ,KAAd;AACH,E;;;;;;ACnCD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD,qCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAU;AACV;AACA;AACA;AACA;;AAEA;;;AAGA,QAAO;AACP;AACA;;AAEA;;AAEA;AACA;AACA,GAAE;AACF;;AAEA,sGAAqG,mBAAmB,EAAE,mBAAmB,8HAA8H;;AAE3Q,kCAAiC,2CAA2C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD,2DAA2D,EAAE,EAAE,yDAAyD,qEAAqE,6DAA6D,oBAAoB,GAAG,EAAE;;AAEljB,uDAAsD,kDAAkD,8DAA8D,0BAA0B,4CAA4C,uBAAuB,kBAAkB,EAAE,OAAO,wCAAwC,EAAE,EAAE,4BAA4B,mBAAmB,EAAE,OAAO,uBAAuB,4BAA4B,kBAAkB,EAAE,8BAA8B,EAAE;;AAEze;;AAEA;;AAEA,wCAAuC,uCAAuC,gBAAgB;;AAE9F,mDAAkD,0CAA0C,0DAA0D,EAAE;;AAExJ,mDAAkD,aAAa,uFAAuF,EAAE,uFAAuF;;AAE/O,4CAA2C,+DAA+D,qGAAqG,EAAE,yEAAyE,eAAe,yEAAyE,EAAE,EAAE,uHAAuH;;AAE7e;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,oBAAmB,iBAAiB;;AAEpC;AACA;AACA;AACA;;AAEA,0BAAyB,iBAAiB;AAC1C,0BAAyB,mBAAmB;;AAE5C;AACA;AACA;AACA;AACA;;AAEA,wBAAuB,aAAa;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA,0BAAyB,mBAAmB;;AAE5C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAc;;AAEd;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAU,gBAAgB;;AAE1B;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,2BAA0B;AAC1B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA6B;;AAE7B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,OAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,OAAM;AACN;AACA;AACA;AACA;;AAEA;;AAEA,OAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA,gCAA+B,mDAAmD,oFAAoF,2DAA2D,2DAA2D,+CAA+C,0DAA0D;;AAErY;AACA,oCAAmC,gCAAgC,mCAAmC;AACtG,eAAc;AACd,oCAAmC,sEAAsE;AACzG;;AAEA;AACA;;AAEA,8CAA6C,QAAQ;AACrD;AACA;AACA;AACA;;AAEA;AACA,oCAAmC;AACnC;;AAEA;AACA;AACA;;AAEA;;AAEA,OAAM;AACN;AACA;AACA,0CAAyC,2BAA2B;AACpE;AACA;;AAEA;;AAEA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uDAAsD,QAAQ;AAC9D;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,OAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,OAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAkB;AAClB;AACA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,mBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,OAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,4DAA2D,QAAQ;AACnE;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,OAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,gCAA+B;AAC/B,+BAA8B;;AAE9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,OAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,OAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAsB;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,6BAA4B,kBAAkB;AAC9C;;AAEA;AACA;AACA;;AAEA;AACA;AACA,mBAAkB;AAClB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,OAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,OAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,6BAA4B,QAAQ;AACpC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,+BAA8B;;AAE9B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,0CAAyC,iCAAiC;AAC1E;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,uBAAsB;AACtB;AACA;AACA,mBAAkB;AAClB;AACA;AACA;AACA,2BAA0B;AAC1B;;AAEA,sCAAqC,sBAAsB;AAC3D;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,OAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,+BAA8B;;AAE9B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,0CAAyC,iCAAiC;AAC1E;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,8BAA6B;;AAE7B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAsB;AACtB;AACA;AACA,mBAAkB;AAClB,sCAAqC,sBAAsB;AAC3D;AACA;AACA;;AAEA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,OAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,6BAA4B,OAAO;AACnC;AACA;;AAEA;AACA;;AAEA;AACA,2EAA0E,kBAAkB;AAC5F,0CAAyC,mCAAmC;AAC5E;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,uBAAsB;AACtB;AACA;AACA,mBAAkB;AAClB,mEAAkE,YAAY;AAC9E,sCAAqC,uBAAuB;AAC5D;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,OAAM;;AAEN;AACA,GAAE;;AAEF;;;AAGA;AACA;;AAEA,QAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;AACF,sCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;;AAEA;;;AAGA,SAAQ;AACR;AACA;;AAEA;;AAEA;AACA;AACA,IAAG;AACH;;AAEA,mCAAkC,2CAA2C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD,2DAA2D,EAAE,EAAE,yDAAyD,qEAAqE,6DAA6D,oBAAoB,GAAG,EAAE;;AAEnjB;;AAEA;;AAEA,yCAAwC,uCAAuC,gBAAgB;;AAE/F,oDAAmD,0CAA0C,0DAA0D,EAAE;;AAEzJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,8BAA6B;AAC7B;;AAEA,6CAA4C;;AAE5C;AACA,kCAAiC;AACjC;;AAEA,wBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,QAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,QAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,gBAAe;AACf;;AAEA;;AAEA,QAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,gBAAe;AACf;;AAEA;;AAEA,QAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,gBAAe;AACf;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,4BAA2B;;AAE3B;AACA;AACA;AACA;AACA;;AAEA,4BAA2B;AAC3B,4BAA2B;AAC3B,6BAA4B;AAC5B,6BAA4B;AAC5B,6BAA4B;AAC5B,6BAA4B;;AAE5B;AACA,0BAAyB,oBAAoB;AAC7C;AACA;AACA;;AAEA;AACA,8BAA6B,oBAAoB;AACjD;AACA;;AAEA;AACA;AACA;AACA,wBAAuB;AACvB;AACA;AACA;;AAEA;AACA;AACA,wBAAuB;AACvB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,gBAAe;AACf;AACA;;AAEA;AACA;AACA;;AAEA;AACA,2BAA0B,qEAAqE;AAC/F;AACA,0BAAyB,qBAAqB;AAC9C,4BAA2B;AAC3B;AACA;AACA,QAAO;;AAEP;AACA,IAAG;;AAEH;;;AAGA;AACA;;AAEA,SAAQ;AACR;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH,uCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;;;AAGA,UAAS;AACT;AACA;;AAEA;;AAEA;AACA;AACA,KAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAQ,gBAAgB;;AAExB;AACA;;AAEA;AACA;AACA;AACA,SAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,yCAAwC,QAAQ;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA,GAAE;AACF;AACA;;AAEA;AACA;AACA,EAAC;AACD;AACA,+C","file":"bf318332cf852a19e2ee.worker.js","sourcesContent":[" \t// Copied from https://github.com/facebook/react/blob/bef45b0/src/shared/utils/canDefineProperty.js\r\n \tvar canDefineProperty = false;\r\n \ttry {\r\n \t\tObject.defineProperty({}, \"x\", {\r\n \t\t\tget: function() {}\r\n \t\t});\r\n \t\tcanDefineProperty = true;\r\n \t} catch(x) {\r\n \t\t// IE will fail on defineProperty\r\n \t}\r\n \t\r\n \tvar hotApplyOnUpdate = true;\r\n \tvar hotCurrentHash = \"bf318332cf852a19e2ee\"; // eslint-disable-line no-unused-vars\r\n \tvar hotCurrentModuleData = {};\r\n \tvar hotCurrentParents = []; // eslint-disable-line no-unused-vars\r\n \t\r\n \tfunction hotCreateRequire(moduleId) { // eslint-disable-line no-unused-vars\r\n \t\tvar me = installedModules[moduleId];\r\n \t\tif(!me) return __webpack_require__;\r\n \t\tvar fn = function(request) {\r\n \t\t\tif(me.hot.active) {\r\n \t\t\t\tif(installedModules[request]) {\r\n \t\t\t\t\tif(installedModules[request].parents.indexOf(moduleId) < 0)\r\n \t\t\t\t\t\tinstalledModules[request].parents.push(moduleId);\r\n \t\t\t\t\tif(me.children.indexOf(request) < 0)\r\n \t\t\t\t\t\tme.children.push(request);\r\n \t\t\t\t} else hotCurrentParents = [moduleId];\r\n \t\t\t} else {\r\n \t\t\t\tconsole.warn(\"[HMR] unexpected require(\" + request + \") from disposed module \" + moduleId);\r\n \t\t\t\thotCurrentParents = [];\r\n \t\t\t}\r\n \t\t\treturn __webpack_require__(request);\r\n \t\t};\r\n \t\tfor(var name in __webpack_require__) {\r\n \t\t\tif(Object.prototype.hasOwnProperty.call(__webpack_require__, name)) {\r\n \t\t\t\tif(canDefineProperty) {\r\n \t\t\t\t\tObject.defineProperty(fn, name, (function(name) {\r\n \t\t\t\t\t\treturn {\r\n \t\t\t\t\t\t\tconfigurable: true,\r\n \t\t\t\t\t\t\tenumerable: true,\r\n \t\t\t\t\t\t\tget: function() {\r\n \t\t\t\t\t\t\t\treturn __webpack_require__[name];\r\n \t\t\t\t\t\t\t},\r\n \t\t\t\t\t\t\tset: function(value) {\r\n \t\t\t\t\t\t\t\t__webpack_require__[name] = value;\r\n \t\t\t\t\t\t\t}\r\n \t\t\t\t\t\t};\r\n \t\t\t\t\t}(name)));\r\n \t\t\t\t} else {\r\n \t\t\t\t\tfn[name] = __webpack_require__[name];\r\n \t\t\t\t}\r\n \t\t\t}\r\n \t\t}\r\n \t\r\n \t\tfunction ensure(chunkId, callback) {\r\n \t\t\tif(hotStatus === \"ready\")\r\n \t\t\t\thotSetStatus(\"prepare\");\r\n \t\t\thotChunksLoading++;\r\n \t\t\t__webpack_require__.e(chunkId, function() {\r\n \t\t\t\ttry {\r\n \t\t\t\t\tcallback.call(null, fn);\r\n \t\t\t\t} finally {\r\n \t\t\t\t\tfinishChunkLoading();\r\n \t\t\t\t}\r\n \t\r\n \t\t\t\tfunction finishChunkLoading() {\r\n \t\t\t\t\thotChunksLoading--;\r\n \t\t\t\t\tif(hotStatus === \"prepare\") {\r\n \t\t\t\t\t\tif(!hotWaitingFilesMap[chunkId]) {\r\n \t\t\t\t\t\t\thotEnsureUpdateChunk(chunkId);\r\n \t\t\t\t\t\t}\r\n \t\t\t\t\t\tif(hotChunksLoading === 0 && hotWaitingFiles === 0) {\r\n \t\t\t\t\t\t\thotUpdateDownloaded();\r\n \t\t\t\t\t\t}\r\n \t\t\t\t\t}\r\n \t\t\t\t}\r\n \t\t\t});\r\n \t\t}\r\n \t\tif(canDefineProperty) {\r\n \t\t\tObject.defineProperty(fn, \"e\", {\r\n \t\t\t\tenumerable: true,\r\n \t\t\t\tvalue: ensure\r\n \t\t\t});\r\n \t\t} else {\r\n \t\t\tfn.e = ensure;\r\n \t\t}\r\n \t\treturn fn;\r\n \t}\r\n \t\r\n \tfunction hotCreateModule(moduleId) { // eslint-disable-line no-unused-vars\r\n \t\tvar hot = {\r\n \t\t\t// private stuff\r\n \t\t\t_acceptedDependencies: {},\r\n \t\t\t_declinedDependencies: {},\r\n \t\t\t_selfAccepted: false,\r\n \t\t\t_selfDeclined: false,\r\n \t\t\t_disposeHandlers: [],\r\n \t\r\n \t\t\t// Module API\r\n \t\t\tactive: true,\r\n \t\t\taccept: function(dep, callback) {\r\n \t\t\t\tif(typeof dep === \"undefined\")\r\n \t\t\t\t\thot._selfAccepted = true;\r\n \t\t\t\telse if(typeof dep === \"function\")\r\n \t\t\t\t\thot._selfAccepted = dep;\r\n \t\t\t\telse if(typeof dep === \"object\")\r\n \t\t\t\t\tfor(var i = 0; i < dep.length; i++)\r\n \t\t\t\t\t\thot._acceptedDependencies[dep[i]] = callback;\r\n \t\t\t\telse\r\n \t\t\t\t\thot._acceptedDependencies[dep] = callback;\r\n \t\t\t},\r\n \t\t\tdecline: function(dep) {\r\n \t\t\t\tif(typeof dep === \"undefined\")\r\n \t\t\t\t\thot._selfDeclined = true;\r\n \t\t\t\telse if(typeof dep === \"number\")\r\n \t\t\t\t\thot._declinedDependencies[dep] = true;\r\n \t\t\t\telse\r\n \t\t\t\t\tfor(var i = 0; i < dep.length; i++)\r\n \t\t\t\t\t\thot._declinedDependencies[dep[i]] = true;\r\n \t\t\t},\r\n \t\t\tdispose: function(callback) {\r\n \t\t\t\thot._disposeHandlers.push(callback);\r\n \t\t\t},\r\n \t\t\taddDisposeHandler: function(callback) {\r\n \t\t\t\thot._disposeHandlers.push(callback);\r\n \t\t\t},\r\n \t\t\tremoveDisposeHandler: function(callback) {\r\n \t\t\t\tvar idx = hot._disposeHandlers.indexOf(callback);\r\n \t\t\t\tif(idx >= 0) hot._disposeHandlers.splice(idx, 1);\r\n \t\t\t},\r\n \t\r\n \t\t\t// Management API\r\n \t\t\tcheck: hotCheck,\r\n \t\t\tapply: hotApply,\r\n \t\t\tstatus: function(l) {\r\n \t\t\t\tif(!l) return hotStatus;\r\n \t\t\t\thotStatusHandlers.push(l);\r\n \t\t\t},\r\n \t\t\taddStatusHandler: function(l) {\r\n \t\t\t\thotStatusHandlers.push(l);\r\n \t\t\t},\r\n \t\t\tremoveStatusHandler: function(l) {\r\n \t\t\t\tvar idx = hotStatusHandlers.indexOf(l);\r\n \t\t\t\tif(idx >= 0) hotStatusHandlers.splice(idx, 1);\r\n \t\t\t},\r\n \t\r\n \t\t\t//inherit from previous dispose call\r\n \t\t\tdata: hotCurrentModuleData[moduleId]\r\n \t\t};\r\n \t\treturn hot;\r\n \t}\r\n \t\r\n \tvar hotStatusHandlers = [];\r\n \tvar hotStatus = \"idle\";\r\n \t\r\n \tfunction hotSetStatus(newStatus) {\r\n \t\thotStatus = newStatus;\r\n \t\tfor(var i = 0; i < hotStatusHandlers.length; i++)\r\n \t\t\thotStatusHandlers[i].call(null, newStatus);\r\n \t}\r\n \t\r\n \t// while downloading\r\n \tvar hotWaitingFiles = 0;\r\n \tvar hotChunksLoading = 0;\r\n \tvar hotWaitingFilesMap = {};\r\n \tvar hotRequestedFilesMap = {};\r\n \tvar hotAvailibleFilesMap = {};\r\n \tvar hotCallback;\r\n \t\r\n \t// The update info\r\n \tvar hotUpdate, hotUpdateNewHash;\r\n \t\r\n \tfunction toModuleId(id) {\r\n \t\tvar isNumber = (+id) + \"\" === id;\r\n \t\treturn isNumber ? +id : id;\r\n \t}\r\n \t\r\n \tfunction hotCheck(apply, callback) {\r\n \t\tif(hotStatus !== \"idle\") throw new Error(\"check() is only allowed in idle status\");\r\n \t\tif(typeof apply === \"function\") {\r\n \t\t\thotApplyOnUpdate = false;\r\n \t\t\tcallback = apply;\r\n \t\t} else {\r\n \t\t\thotApplyOnUpdate = apply;\r\n \t\t\tcallback = callback || function(err) {\r\n \t\t\t\tif(err) throw err;\r\n \t\t\t};\r\n \t\t}\r\n \t\thotSetStatus(\"check\");\r\n \t\thotDownloadManifest(function(err, update) {\r\n \t\t\tif(err) return callback(err);\r\n \t\t\tif(!update) {\r\n \t\t\t\thotSetStatus(\"idle\");\r\n \t\t\t\tcallback(null, null);\r\n \t\t\t\treturn;\r\n \t\t\t}\r\n \t\r\n \t\t\thotRequestedFilesMap = {};\r\n \t\t\thotAvailibleFilesMap = {};\r\n \t\t\thotWaitingFilesMap = {};\r\n \t\t\tfor(var i = 0; i < update.c.length; i++)\r\n \t\t\t\thotAvailibleFilesMap[update.c[i]] = true;\r\n \t\t\thotUpdateNewHash = update.h;\r\n \t\r\n \t\t\thotSetStatus(\"prepare\");\r\n \t\t\thotCallback = callback;\r\n \t\t\thotUpdate = {};\r\n \t\t\tvar chunkId = 0;\r\n \t\t\t{ // eslint-disable-line no-lone-blocks\r\n \t\t\t\t/*globals chunkId */\r\n \t\t\t\thotEnsureUpdateChunk(chunkId);\r\n \t\t\t}\r\n \t\t\tif(hotStatus === \"prepare\" && hotChunksLoading === 0 && hotWaitingFiles === 0) {\r\n \t\t\t\thotUpdateDownloaded();\r\n \t\t\t}\r\n \t\t});\r\n \t}\r\n \t\r\n \tfunction hotAddUpdateChunk(chunkId, moreModules) { // eslint-disable-line no-unused-vars\r\n \t\tif(!hotAvailibleFilesMap[chunkId] || !hotRequestedFilesMap[chunkId])\r\n \t\t\treturn;\r\n \t\thotRequestedFilesMap[chunkId] = false;\r\n \t\tfor(var moduleId in moreModules) {\r\n \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\r\n \t\t\t\thotUpdate[moduleId] = moreModules[moduleId];\r\n \t\t\t}\r\n \t\t}\r\n \t\tif(--hotWaitingFiles === 0 && hotChunksLoading === 0) {\r\n \t\t\thotUpdateDownloaded();\r\n \t\t}\r\n \t}\r\n \t\r\n \tfunction hotEnsureUpdateChunk(chunkId) {\r\n \t\tif(!hotAvailibleFilesMap[chunkId]) {\r\n \t\t\thotWaitingFilesMap[chunkId] = true;\r\n \t\t} else {\r\n \t\t\thotRequestedFilesMap[chunkId] = true;\r\n \t\t\thotWaitingFiles++;\r\n \t\t\thotDownloadUpdateChunk(chunkId);\r\n \t\t}\r\n \t}\r\n \t\r\n \tfunction hotUpdateDownloaded() {\r\n \t\thotSetStatus(\"ready\");\r\n \t\tvar callback = hotCallback;\r\n \t\thotCallback = null;\r\n \t\tif(!callback) return;\r\n \t\tif(hotApplyOnUpdate) {\r\n \t\t\thotApply(hotApplyOnUpdate, callback);\r\n \t\t} else {\r\n \t\t\tvar outdatedModules = [];\r\n \t\t\tfor(var id in hotUpdate) {\r\n \t\t\t\tif(Object.prototype.hasOwnProperty.call(hotUpdate, id)) {\r\n \t\t\t\t\toutdatedModules.push(toModuleId(id));\r\n \t\t\t\t}\r\n \t\t\t}\r\n \t\t\tcallback(null, outdatedModules);\r\n \t\t}\r\n \t}\r\n \t\r\n \tfunction hotApply(options, callback) {\r\n \t\tif(hotStatus !== \"ready\") throw new Error(\"apply() is only allowed in ready status\");\r\n \t\tif(typeof options === \"function\") {\r\n \t\t\tcallback = options;\r\n \t\t\toptions = {};\r\n \t\t} else if(options && typeof options === \"object\") {\r\n \t\t\tcallback = callback || function(err) {\r\n \t\t\t\tif(err) throw err;\r\n \t\t\t};\r\n \t\t} else {\r\n \t\t\toptions = {};\r\n \t\t\tcallback = callback || function(err) {\r\n \t\t\t\tif(err) throw err;\r\n \t\t\t};\r\n \t\t}\r\n \t\r\n \t\tfunction getAffectedStuff(module) {\r\n \t\t\tvar outdatedModules = [module];\r\n \t\t\tvar outdatedDependencies = {};\r\n \t\r\n \t\t\tvar queue = outdatedModules.slice();\r\n \t\t\twhile(queue.length > 0) {\r\n \t\t\t\tvar moduleId = queue.pop();\r\n \t\t\t\tvar module = installedModules[moduleId];\r\n \t\t\t\tif(!module || module.hot._selfAccepted)\r\n \t\t\t\t\tcontinue;\r\n \t\t\t\tif(module.hot._selfDeclined) {\r\n \t\t\t\t\treturn new Error(\"Aborted because of self decline: \" + moduleId);\r\n \t\t\t\t}\r\n \t\t\t\tif(moduleId === 0) {\r\n \t\t\t\t\treturn;\r\n \t\t\t\t}\r\n \t\t\t\tfor(var i = 0; i < module.parents.length; i++) {\r\n \t\t\t\t\tvar parentId = module.parents[i];\r\n \t\t\t\t\tvar parent = installedModules[parentId];\r\n \t\t\t\t\tif(parent.hot._declinedDependencies[moduleId]) {\r\n \t\t\t\t\t\treturn new Error(\"Aborted because of declined dependency: \" + moduleId + \" in \" + parentId);\r\n \t\t\t\t\t}\r\n \t\t\t\t\tif(outdatedModules.indexOf(parentId) >= 0) continue;\r\n \t\t\t\t\tif(parent.hot._acceptedDependencies[moduleId]) {\r\n \t\t\t\t\t\tif(!outdatedDependencies[parentId])\r\n \t\t\t\t\t\t\toutdatedDependencies[parentId] = [];\r\n \t\t\t\t\t\taddAllToSet(outdatedDependencies[parentId], [moduleId]);\r\n \t\t\t\t\t\tcontinue;\r\n \t\t\t\t\t}\r\n \t\t\t\t\tdelete outdatedDependencies[parentId];\r\n \t\t\t\t\toutdatedModules.push(parentId);\r\n \t\t\t\t\tqueue.push(parentId);\r\n \t\t\t\t}\r\n \t\t\t}\r\n \t\r\n \t\t\treturn [outdatedModules, outdatedDependencies];\r\n \t\t}\r\n \t\r\n \t\tfunction addAllToSet(a, b) {\r\n \t\t\tfor(var i = 0; i < b.length; i++) {\r\n \t\t\t\tvar item = b[i];\r\n \t\t\t\tif(a.indexOf(item) < 0)\r\n \t\t\t\t\ta.push(item);\r\n \t\t\t}\r\n \t\t}\r\n \t\r\n \t\t// at begin all updates modules are outdated\r\n \t\t// the \"outdated\" status can propagate to parents if they don't accept the children\r\n \t\tvar outdatedDependencies = {};\r\n \t\tvar outdatedModules = [];\r\n \t\tvar appliedUpdate = {};\r\n \t\tfor(var id in hotUpdate) {\r\n \t\t\tif(Object.prototype.hasOwnProperty.call(hotUpdate, id)) {\r\n \t\t\t\tvar moduleId = toModuleId(id);\r\n \t\t\t\tvar result = getAffectedStuff(moduleId);\r\n \t\t\t\tif(!result) {\r\n \t\t\t\t\tif(options.ignoreUnaccepted)\r\n \t\t\t\t\t\tcontinue;\r\n \t\t\t\t\thotSetStatus(\"abort\");\r\n \t\t\t\t\treturn callback(new Error(\"Aborted because \" + moduleId + \" is not accepted\"));\r\n \t\t\t\t}\r\n \t\t\t\tif(result instanceof Error) {\r\n \t\t\t\t\thotSetStatus(\"abort\");\r\n \t\t\t\t\treturn callback(result);\r\n \t\t\t\t}\r\n \t\t\t\tappliedUpdate[moduleId] = hotUpdate[moduleId];\r\n \t\t\t\taddAllToSet(outdatedModules, result[0]);\r\n \t\t\t\tfor(var moduleId in result[1]) {\r\n \t\t\t\t\tif(Object.prototype.hasOwnProperty.call(result[1], moduleId)) {\r\n \t\t\t\t\t\tif(!outdatedDependencies[moduleId])\r\n \t\t\t\t\t\t\toutdatedDependencies[moduleId] = [];\r\n \t\t\t\t\t\taddAllToSet(outdatedDependencies[moduleId], result[1][moduleId]);\r\n \t\t\t\t\t}\r\n \t\t\t\t}\r\n \t\t\t}\r\n \t\t}\r\n \t\r\n \t\t// Store self accepted outdated modules to require them later by the module system\r\n \t\tvar outdatedSelfAcceptedModules = [];\r\n \t\tfor(var i = 0; i < outdatedModules.length; i++) {\r\n \t\t\tvar moduleId = outdatedModules[i];\r\n \t\t\tif(installedModules[moduleId] && installedModules[moduleId].hot._selfAccepted)\r\n \t\t\t\toutdatedSelfAcceptedModules.push({\r\n \t\t\t\t\tmodule: moduleId,\r\n \t\t\t\t\terrorHandler: installedModules[moduleId].hot._selfAccepted\r\n \t\t\t\t});\r\n \t\t}\r\n \t\r\n \t\t// Now in \"dispose\" phase\r\n \t\thotSetStatus(\"dispose\");\r\n \t\tvar queue = outdatedModules.slice();\r\n \t\twhile(queue.length > 0) {\r\n \t\t\tvar moduleId = queue.pop();\r\n \t\t\tvar module = installedModules[moduleId];\r\n \t\t\tif(!module) continue;\r\n \t\r\n \t\t\tvar data = {};\r\n \t\r\n \t\t\t// Call dispose handlers\r\n \t\t\tvar disposeHandlers = module.hot._disposeHandlers;\r\n \t\t\tfor(var j = 0; j < disposeHandlers.length; j++) {\r\n \t\t\t\tvar cb = disposeHandlers[j];\r\n \t\t\t\tcb(data);\r\n \t\t\t}\r\n \t\t\thotCurrentModuleData[moduleId] = data;\r\n \t\r\n \t\t\t// disable module (this disables requires from this module)\r\n \t\t\tmodule.hot.active = false;\r\n \t\r\n \t\t\t// remove module from cache\r\n \t\t\tdelete installedModules[moduleId];\r\n \t\r\n \t\t\t// remove \"parents\" references from all children\r\n \t\t\tfor(var j = 0; j < module.children.length; j++) {\r\n \t\t\t\tvar child = installedModules[module.children[j]];\r\n \t\t\t\tif(!child) continue;\r\n \t\t\t\tvar idx = child.parents.indexOf(moduleId);\r\n \t\t\t\tif(idx >= 0) {\r\n \t\t\t\t\tchild.parents.splice(idx, 1);\r\n \t\t\t\t}\r\n \t\t\t}\r\n \t\t}\r\n \t\r\n \t\t// remove outdated dependency from module children\r\n \t\tfor(var moduleId in outdatedDependencies) {\r\n \t\t\tif(Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) {\r\n \t\t\t\tvar module = installedModules[moduleId];\r\n \t\t\t\tvar moduleOutdatedDependencies = outdatedDependencies[moduleId];\r\n \t\t\t\tfor(var j = 0; j < moduleOutdatedDependencies.length; j++) {\r\n \t\t\t\t\tvar dependency = moduleOutdatedDependencies[j];\r\n \t\t\t\t\tvar idx = module.children.indexOf(dependency);\r\n \t\t\t\t\tif(idx >= 0) module.children.splice(idx, 1);\r\n \t\t\t\t}\r\n \t\t\t}\r\n \t\t}\r\n \t\r\n \t\t// Not in \"apply\" phase\r\n \t\thotSetStatus(\"apply\");\r\n \t\r\n \t\thotCurrentHash = hotUpdateNewHash;\r\n \t\r\n \t\t// insert new code\r\n \t\tfor(var moduleId in appliedUpdate) {\r\n \t\t\tif(Object.prototype.hasOwnProperty.call(appliedUpdate, moduleId)) {\r\n \t\t\t\tmodules[moduleId] = appliedUpdate[moduleId];\r\n \t\t\t}\r\n \t\t}\r\n \t\r\n \t\t// call accept handlers\r\n \t\tvar error = null;\r\n \t\tfor(var moduleId in outdatedDependencies) {\r\n \t\t\tif(Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) {\r\n \t\t\t\tvar module = installedModules[moduleId];\r\n \t\t\t\tvar moduleOutdatedDependencies = outdatedDependencies[moduleId];\r\n \t\t\t\tvar callbacks = [];\r\n \t\t\t\tfor(var i = 0; i < moduleOutdatedDependencies.length; i++) {\r\n \t\t\t\t\tvar dependency = moduleOutdatedDependencies[i];\r\n \t\t\t\t\tvar cb = module.hot._acceptedDependencies[dependency];\r\n \t\t\t\t\tif(callbacks.indexOf(cb) >= 0) continue;\r\n \t\t\t\t\tcallbacks.push(cb);\r\n \t\t\t\t}\r\n \t\t\t\tfor(var i = 0; i < callbacks.length; i++) {\r\n \t\t\t\t\tvar cb = callbacks[i];\r\n \t\t\t\t\ttry {\r\n \t\t\t\t\t\tcb(outdatedDependencies);\r\n \t\t\t\t\t} catch(err) {\r\n \t\t\t\t\t\tif(!error)\r\n \t\t\t\t\t\t\terror = err;\r\n \t\t\t\t\t}\r\n \t\t\t\t}\r\n \t\t\t}\r\n \t\t}\r\n \t\r\n \t\t// Load self accepted modules\r\n \t\tfor(var i = 0; i < outdatedSelfAcceptedModules.length; i++) {\r\n \t\t\tvar item = outdatedSelfAcceptedModules[i];\r\n \t\t\tvar moduleId = item.module;\r\n \t\t\thotCurrentParents = [moduleId];\r\n \t\t\ttry {\r\n \t\t\t\t__webpack_require__(moduleId);\r\n \t\t\t} catch(err) {\r\n \t\t\t\tif(typeof item.errorHandler === \"function\") {\r\n \t\t\t\t\ttry {\r\n \t\t\t\t\t\titem.errorHandler(err);\r\n \t\t\t\t\t} catch(err) {\r\n \t\t\t\t\t\tif(!error)\r\n \t\t\t\t\t\t\terror = err;\r\n \t\t\t\t\t}\r\n \t\t\t\t} else if(!error)\r\n \t\t\t\t\terror = err;\r\n \t\t\t}\r\n \t\t}\r\n \t\r\n \t\t// handle errors in accept handlers and self accepted module load\r\n \t\tif(error) {\r\n \t\t\thotSetStatus(\"fail\");\r\n \t\t\treturn callback(error);\r\n \t\t}\r\n \t\r\n \t\thotSetStatus(\"idle\");\r\n \t\tcallback(null, outdatedModules);\r\n \t}\r\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false,\n \t\t\thot: hotCreateModule(moduleId),\n \t\t\tparents: hotCurrentParents,\n \t\t\tchildren: []\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, hotCreateRequire(moduleId));\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// __webpack_hash__\n \t__webpack_require__.h = function() { return hotCurrentHash; };\n\n \t// Load entry module and return exports\n \treturn hotCreateRequire(0)(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap bf318332cf852a19e2ee","import { RasterToGcode } from 'lw.raster-to-gcode'\n\n// On messsage received\nself.onmessage = function (event) {\n    if (event.data.cmd === 'start') {\n        start(event.data);\n    }\n}\n\n\n\n// Start job\nfunction start(data) {\n\n    // Create RasterToGcode object\n    var rasterToGcode = new RasterToGcode(data.settings);\n        Object.assign( rasterToGcode, data.properties );\n    // Register events callbacks\n        rasterToGcode.on('progress', function (event) {\n            self.postMessage({ event: 'onProgress', ...event });\n        }).on('done', function (event) {\n            self.postMessage({ event: 'onDone', ...event });\n        }).on('abort', function () {\n            self.postMessage({ event: 'onAbort' });\n        });\n\n    \n    self.postMessage({ event: 'start' });\n    rasterToGcode.run();\n\n}\n\n// Abort job\nfunction abort() {\n    rasterToGcode.abort();\n}\n\n\n// WEBPACK FOOTER //\n// ./lib/workers/cam-raster.js","(function webpackUniversalModuleDefinition(root, factory) {\r\n\tif(typeof exports === 'object' && typeof module === 'object')\r\n\t\tmodule.exports = factory();\r\n\telse if(typeof define === 'function' && define.amd)\r\n\t\tdefine(\"RasterToGcode\", [], factory);\r\n\telse if(typeof exports === 'object')\r\n\t\texports[\"RasterToGcode\"] = factory();\r\n\telse\r\n\t\troot[\"RasterToGcode\"] = factory();\r\n})(this, function() {\r\nreturn /******/ (function(modules) { // webpackBootstrap\r\n/******/ \t// The module cache\r\n/******/ \tvar installedModules = {};\r\n/******/\r\n/******/ \t// The require function\r\n/******/ \tfunction __webpack_require__(moduleId) {\r\n/******/\r\n/******/ \t\t// Check if module is in cache\r\n/******/ \t\tif(installedModules[moduleId])\r\n/******/ \t\t\treturn installedModules[moduleId].exports;\r\n/******/\r\n/******/ \t\t// Create a new module (and put it into the cache)\r\n/******/ \t\tvar module = installedModules[moduleId] = {\r\n/******/ \t\t\texports: {},\r\n/******/ \t\t\tid: moduleId,\r\n/******/ \t\t\tloaded: false\r\n/******/ \t\t};\r\n/******/\r\n/******/ \t\t// Execute the module function\r\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\r\n/******/\r\n/******/ \t\t// Flag the module as loaded\r\n/******/ \t\tmodule.loaded = true;\r\n/******/\r\n/******/ \t\t// Return the exports of the module\r\n/******/ \t\treturn module.exports;\r\n/******/ \t}\r\n/******/\r\n/******/\r\n/******/ \t// expose the modules object (__webpack_modules__)\r\n/******/ \t__webpack_require__.m = modules;\r\n/******/\r\n/******/ \t// expose the module cache\r\n/******/ \t__webpack_require__.c = installedModules;\r\n/******/\r\n/******/ \t// __webpack_public_path__\r\n/******/ \t__webpack_require__.p = \"\";\r\n/******/\r\n/******/ \t// Load entry module and return exports\r\n/******/ \treturn __webpack_require__(0);\r\n/******/ })\r\n/************************************************************************/\r\n/******/ ([\r\n/* 0 */\r\n/***/ function(module, exports, __webpack_require__) {\r\n\r\n\tmodule.exports = __webpack_require__(1);\r\n\r\n\r\n/***/ },\r\n/* 1 */\r\n/***/ function(module, exports, __webpack_require__) {\r\n\r\n\t'use strict';\r\n\t\r\n\tObject.defineProperty(exports, \"__esModule\", {\r\n\t    value: true\r\n\t});\r\n\texports.RasterToGcode = undefined;\r\n\t\r\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\r\n\t\r\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\r\n\t\r\n\tvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\r\n\t\r\n\tvar _lw = __webpack_require__(2);\r\n\t\r\n\tvar _lw2 = _interopRequireDefault(_lw);\r\n\t\r\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\t\r\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\r\n\t\r\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\r\n\t\r\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\r\n\t\r\n\t// RasterToGcode class\r\n\tvar RasterToGcode = function (_CanvasGrid) {\r\n\t    _inherits(RasterToGcode, _CanvasGrid);\r\n\t\r\n\t    // Class constructor...\r\n\t    function RasterToGcode(settings) {\r\n\t        _classCallCheck(this, RasterToGcode);\r\n\t\r\n\t        // Defaults settings\r\n\t        settings = Object.assign({\r\n\t            ppi: { x: 254, y: 254 }, // Pixel Per Inch (25.4 ppi == 1 ppm)\r\n\t\r\n\t            toolDiameter: 0.1, // Tool diameter in millimeters\r\n\t            rapidRate: 1500, // Rapid rate in mm/min (G0 F value)\r\n\t            feedRate: 500, // Feed rate in mm/min (G1 F value)\r\n\t            rateUnit: 'mm/min', // Rapid/Feed rate unit [mm/min, mm/sec]\r\n\t\r\n\t            beamRange: { min: 0, max: 1 }, // Beam power range (Firmware value)\r\n\t            beamPower: { min: 0, max: 100 }, // Beam power (S value) as percentage of beamRange\r\n\t\r\n\t            milling: false, // EXPERIMENTAL\r\n\t            zSafe: 5, // Safe Z for fast move\r\n\t            zSurface: 0, // Usinable surface (white pixels)\r\n\t            zDepth: -10, // Z depth (black pixels)\r\n\t            passDepth: 1, // Pass depth in millimeters\r\n\t\r\n\t            offsets: { X: 0, Y: 0 }, // Global coordinates offsets\r\n\t            trimLine: true, // Trim trailing white pixels\r\n\t            joinPixel: true, // Join consecutive pixels with same intensity\r\n\t            burnWhite: true, // [true = G1 S0 | false = G0] on inner white pixels\r\n\t            verboseG: false, // Output verbose GCode (print each commands)\r\n\t            diagonal: false, // Go diagonally (increase the distance between points)\r\n\t            overscan: 0, // Add some extra white space (in millimeters) before and after each line\r\n\t\r\n\t            precision: { X: 2, Y: 2, S: 4 }, // Number of decimals for each commands\r\n\t\r\n\t            nonBlocking: true, // Use setTimeout to avoid blocking the UI\r\n\t\r\n\t            filters: {\r\n\t                smoothing: 0, // Smoothing the input image ?\r\n\t                brightness: 0, // Image brightness [-255 to +255]\r\n\t                contrast: 0, // Image contrast [-255 to +255]\r\n\t                gamma: 0, // Image gamma correction [0.01 to 7.99]\r\n\t                grayscale: 'none', // Graysale algorithm [average, luma, luma-601, luma-709, luma-240, desaturation, decomposition-[min|max], [red|green|blue]-chanel]\r\n\t                shadesOfGray: 256, // Number of shades of gray [2-256]\r\n\t                invertColor: false // Invert color...\r\n\t            },\r\n\t\r\n\t            onProgress: null, // On progress callbacks\r\n\t            onProgressContext: null, // On progress callback context\r\n\t\r\n\t            onDone: null, // On done callback\r\n\t            onDoneContext: null, // On done callback context\r\n\t\r\n\t            onAbort: null, // On abort callback\r\n\t            onAbortContext: null // On abort callback context\r\n\t        }, settings || {});\r\n\t\r\n\t        // Init properties\r\n\t\r\n\t        // Milling settings\r\n\t        var _this = _possibleConstructorReturn(this, (RasterToGcode.__proto__ || Object.getPrototypeOf(RasterToGcode)).call(this, settings));\r\n\t\r\n\t        if (_this.milling) {\r\n\t            if (_this.zSafe < _this.zSurface) {\r\n\t                throw new Error('\"zSafe\" must be greater to \"zSurface\"');\r\n\t            }\r\n\t\r\n\t            _this.passes = Math.abs(Math.floor(_this.zDepth / _this.passDepth));\r\n\t        }\r\n\t\r\n\t        // Negative beam size ?\r\n\t        if (_this.toolDiameter <= 0) {\r\n\t            throw new Error('\"toolDiameter\" must be positive');\r\n\t        }\r\n\t\r\n\t        // Uniforme ppi\r\n\t        if (!_this.ppi.x) {\r\n\t            _this.ppi = { x: _this.ppi, y: _this.ppi };\r\n\t        }\r\n\t\r\n\t        // Calculate PPM = Pixel Per Millimeters\r\n\t        _this.ppm = {\r\n\t            x: parseFloat((2540 / (_this.ppi.x * 100)).toFixed(10)),\r\n\t            y: parseFloat((2540 / (_this.ppi.y * 100)).toFixed(10))\r\n\t        };\r\n\t\r\n\t        // Calculate scale ratio\r\n\t        _this.scaleRatio = {\r\n\t            x: _this.ppm.x / _this.toolDiameter,\r\n\t            y: _this.ppm.y / _this.toolDiameter\r\n\t        };\r\n\t\r\n\t        // State...\r\n\t        _this.running = false;\r\n\t        _this.gcode = null;\r\n\t        _this.gcodes = null;\r\n\t        _this.currentLine = null;\r\n\t        _this.lastCommands = null;\r\n\t\r\n\t        // Output size in millimeters\r\n\t        _this.outputSize = { width: 0, height: 0 };\r\n\t\r\n\t        // G0 command\r\n\t        _this.G1 = ['G', 1];\r\n\t        _this.G0 = ['G', _this.burnWhite ? 1 : 0];\r\n\t\r\n\t        // Calculate beam offset\r\n\t        _this.beamOffset = _this.toolDiameter * 1000 / 2000;\r\n\t\r\n\t        // Calculate real beam range\r\n\t        _this.realBeamRange = {\r\n\t            min: _this.beamRange.max / 100 * _this.beamPower.min,\r\n\t            max: _this.beamRange.max / 100 * _this.beamPower.max\r\n\t        };\r\n\t\r\n\t        // Adjuste feed rate to mm/min\r\n\t        if (_this.rateUnit === 'mm/sec') {\r\n\t            _this.feedRate *= 60;\r\n\t            _this.rapidRate *= 60;\r\n\t        }\r\n\t\r\n\t        // Register user callbacks\r\n\t        _this._registerUserCallbacks(_this);\r\n\t        return _this;\r\n\t    }\r\n\t\r\n\t    // Register user callbacks\r\n\t\r\n\t\r\n\t    _createClass(RasterToGcode, [{\r\n\t        key: '_registerUserCallbacks',\r\n\t        value: function _registerUserCallbacks(callbacks) {\r\n\t            // Register user callbacks\r\n\t            callbacks.onProgress && this.on('progress', callbacks.onProgress, callbacks.onProgressContext);\r\n\t            callbacks.onAbort && this.on('abort', callbacks.onAbort, callbacks.onAbortContext);\r\n\t            callbacks.onDone && this.on('done', callbacks.onDone, callbacks.onDoneContext);\r\n\t        }\r\n\t\r\n\t        // Process image\r\n\t\r\n\t    }, {\r\n\t        key: '_processImage',\r\n\t        value: function _processImage() {\r\n\t            // Call parent method\r\n\t            _get(RasterToGcode.prototype.__proto__ || Object.getPrototypeOf(RasterToGcode.prototype), '_processImage', this).call(this);\r\n\t\r\n\t            // Calculate output size\r\n\t            this.outputSize = {\r\n\t                width: this.size.width * (this.toolDiameter * 1000) / 1000,\r\n\t                height: this.size.height * (this.toolDiameter * 1000) / 1000\r\n\t            };\r\n\t        }\r\n\t\r\n\t        // Abort job\r\n\t\r\n\t    }, {\r\n\t        key: 'abort',\r\n\t        value: function abort() {\r\n\t            this.running = false;\r\n\t        }\r\n\t\r\n\t        // Process image and return gcode string\r\n\t\r\n\t    }, {\r\n\t        key: 'run',\r\n\t        value: function run(settings) {\r\n\t            if (this.running) {\r\n\t                return;\r\n\t            }\r\n\t\r\n\t            // Reset state\r\n\t            this.running = true;\r\n\t            this.gcode = [];\r\n\t            this.gcodes = [];\r\n\t            this.lastCommands = {};\r\n\t            this.currentLine = null;\r\n\t\r\n\t            // Defaults settings\r\n\t            settings = settings || {};\r\n\t\r\n\t            // Register user callbacks\r\n\t            this._registerUserCallbacks(settings);\r\n\t\r\n\t            // Non blocking mode ?\r\n\t            var nonBlocking = this.nonBlocking;\r\n\t\r\n\t            if (settings.nonBlocking !== undefined) {\r\n\t                nonBlocking = settings.nonBlocking;\r\n\t            }\r\n\t\r\n\t            // Add gcode header\r\n\t            this._addHeader();\r\n\t\r\n\t            // Scan type ?\r\n\t            if (this.diagonal) {\r\n\t                this._scanDiagonally(nonBlocking);\r\n\t            } else {\r\n\t                this._scanHorizontally(nonBlocking);\r\n\t            }\r\n\t\r\n\t            if (!nonBlocking) {\r\n\t                return this.gcode;\r\n\t            }\r\n\t        }\r\n\t    }, {\r\n\t        key: '_addHeader',\r\n\t        value: function _addHeader() {\r\n\t            // Base headers\r\n\t            this.gcode.push('; Generated by LaserWeb (lw.raster-to-gcode.js)', '; Size       : ' + this.outputSize.width + ' x ' + this.outputSize.height + ' mm', '; PPI        : x: ' + this.ppi.x + ' - y: ' + this.ppi.y, '; PPM        : x: ' + this.ppm.x + ' - y: ' + this.ppm.y, '; Tool diam. : ' + this.toolDiameter + ' mm', '; Rapid rate : ' + this.rapidRate + ' ' + this.rateUnit, '; Feed rate  : ' + this.feedRate + ' ' + this.rateUnit);\r\n\t\r\n\t            if (this.milling) {\r\n\t                this.gcode.push('; Z safe     : ' + this.zSafe, '; Z surface  : ' + this.zSurface, '; Z depth    : ' + this.zDepth);\r\n\t            } else {\r\n\t                this.gcode.push('; Beam range : ' + this.beamRange.min + ' to ' + this.beamRange.max, '; Beam power : ' + this.beamPower.min + ' to ' + this.beamPower.max + ' %');\r\n\t            }\r\n\t\r\n\t            // Print activated options\r\n\t            var options = ['smoothing', 'trimLine', 'joinPixel', 'burnWhite', 'verboseG', 'diagonal'];\r\n\t\r\n\t            for (var i = options.length - 1; i >= 0; i--) {\r\n\t                if (!this[options[i]]) {\r\n\t                    options.splice(i, 1);\r\n\t                }\r\n\t            }\r\n\t\r\n\t            if (options.length) {\r\n\t                this.gcode.push('; Options    : ' + options.join(', '));\r\n\t            }\r\n\t\r\n\t            // Set feed rates\r\n\t            this.gcode.push('', 'G0 F' + this.rapidRate, 'G1 F' + this.feedRate, '');\r\n\t        }\r\n\t\r\n\t        // Map S value to pixel power\r\n\t\r\n\t    }, {\r\n\t        key: '_mapPixelPower',\r\n\t        value: function _mapPixelPower(value) {\r\n\t            var range = this.milling ? { min: 0, max: this.zDepth } : this.realBeamRange;\r\n\t            return value * (range.max - range.min) / 255 + range.min;\r\n\t        }\r\n\t\r\n\t        // Compute and return a command, return null if not changed\r\n\t\r\n\t    }, {\r\n\t        key: '_command',\r\n\t        value: function _command(name, value) {\r\n\t            // If the value argument is an object\r\n\t            if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {\r\n\t                // Computed commands line\r\n\t                var commands = Array.prototype.slice.call(arguments);\r\n\t                var command = void 0,\r\n\t                    line = [];\r\n\t\r\n\t                // for each command\r\n\t                for (var i = 0, il = commands.length; i < il; i++) {\r\n\t                    command = this._command.apply(this, commands[i]);\r\n\t                    command && line.push(command);\r\n\t                }\r\n\t\r\n\t                // Return the line if not empty\r\n\t                return line.length ? line.join(' ') : null;\r\n\t            }\r\n\t\r\n\t            // Format the value\r\n\t            value = value.toFixed(this.precision[name] || 0);\r\n\t\r\n\t            // If the value was changed or if verbose mode on\r\n\t            if (this.verboseG || value !== this.lastCommands[name]) {\r\n\t                this.lastCommands[name] = value;\r\n\t                return name + value;\r\n\t            }\r\n\t\r\n\t            // No change\r\n\t            return null;\r\n\t        }\r\n\t\r\n\t        // Get a pixel power value from the canvas data grid\r\n\t\r\n\t    }, {\r\n\t        key: '_getPixelPower',\r\n\t        value: function _getPixelPower(x, y, defaultValue) {\r\n\t            try {\r\n\t                // Reverse Y value since canvas as top/left origin\r\n\t                y = this.size.height - y - 1;\r\n\t\r\n\t                // Get pixel info\r\n\t                var pixel = this.getPixel(x, y);\r\n\t\r\n\t                // Reversed gray value [ 0 = white | 255 = black ]\r\n\t                return 255 - pixel.gray;\r\n\t            } catch (error) {\r\n\t                if (arguments.length === 3) {\r\n\t                    return defaultValue;\r\n\t                }\r\n\t                throw error;\r\n\t            }\r\n\t        }\r\n\t\r\n\t        // Get a point from the current line with real world coordinates\r\n\t\r\n\t    }, {\r\n\t        key: '_getPoint',\r\n\t        value: function _getPoint(index) {\r\n\t            // Get the point object from the current line\r\n\t            var point = this.currentLine[index];\r\n\t\r\n\t            // No point\r\n\t            if (!point) {\r\n\t                return null;\r\n\t            }\r\n\t\r\n\t            // Commands\r\n\t            point.G = point.s ? ['G', 1] : this.G0;\r\n\t            point.X = point.x * this.toolDiameter + this.offsets.X;\r\n\t            point.Y = point.y * this.toolDiameter + this.offsets.Y;\r\n\t            point.S = this._mapPixelPower(point.s);\r\n\t\r\n\t            // Offsets\r\n\t            if (this.diagonal) {\r\n\t                // Vertical offset\r\n\t                point.Y += this.toolDiameter;\r\n\t\r\n\t                // Horizontal offset\r\n\t                if (point.first || point.lastWhite) {\r\n\t                    point.X += this.beamOffset;\r\n\t                    point.Y -= this.beamOffset;\r\n\t                } else if (point.last || point.lastColored) {\r\n\t                    point.X -= this.beamOffset;\r\n\t                    point.Y += this.beamOffset;\r\n\t                }\r\n\t            } else {\r\n\t                // Vertical offset\r\n\t                point.Y += this.beamOffset;\r\n\t\r\n\t                // Horizontal offset\r\n\t                if (point.first || point.lastWhite) {\r\n\t                    point.X += this.beamOffset;\r\n\t                } else if (point.last || point.lastColored) {\r\n\t                    point.X -= this.beamOffset;\r\n\t                }\r\n\t            }\r\n\t\r\n\t            // Return the point\r\n\t            return point;\r\n\t        }\r\n\t\r\n\t        // Remove all trailing white spaces from the current line\r\n\t\r\n\t    }, {\r\n\t        key: '_trimCurrentLine',\r\n\t        value: function _trimCurrentLine() {\r\n\t            // Remove white spaces from the left\r\n\t            var point = this.currentLine[0];\r\n\t\r\n\t            while (point && !point.p) {\r\n\t                this.currentLine.shift();\r\n\t                point = this.currentLine[0];\r\n\t            }\r\n\t\r\n\t            // Remove white spaces from the right\r\n\t            point = this.currentLine[this.currentLine.length - 2];\r\n\t\r\n\t            while (point && !point.p) {\r\n\t                this.currentLine.pop();\r\n\t                point = this.currentLine[this.currentLine.length - 2];\r\n\t            }\r\n\t\r\n\t            // Return the new line length\r\n\t            return this.currentLine.length;\r\n\t        }\r\n\t\r\n\t        // Join pixel with same power\r\n\t\r\n\t    }, {\r\n\t        key: '_reduceCurrentLine',\r\n\t        value: function _reduceCurrentLine() {\r\n\t            // Line too short to be reduced\r\n\t            if (this.currentLine.length < 3) {\r\n\t                return this.currentLine.length;\r\n\t            }\r\n\t\r\n\t            // Extract all points exept the first one\r\n\t            var points = this.currentLine.splice(1);\r\n\t\r\n\t            // Get current power\r\n\t            var power = this.currentLine[0].p;\r\n\t\r\n\t            // For each extracted point\r\n\t            for (var point, i = 0, il = points.length - 1; i < il; i++) {\r\n\t                // Current point\r\n\t                point = points[i];\r\n\t\r\n\t                // On power change\r\n\t                if (power !== point.p) {\r\n\t                    this.currentLine.push(point);\r\n\t                }\r\n\t\r\n\t                // Update power\r\n\t                power = point.p;\r\n\t            }\r\n\t\r\n\t            // Add last point\r\n\t            this.currentLine.push(points[i]);\r\n\t        }\r\n\t\r\n\t        // Add extra white pixels at the ends\r\n\t\r\n\t    }, {\r\n\t        key: '_overscanCurrentLine',\r\n\t        value: function _overscanCurrentLine(reversed) {\r\n\t            // Number of pixels to add on each side\r\n\t            var pixels = this.overscan / this.ppm.x;\r\n\t\r\n\t            // Get first/last point\r\n\t            var firstPoint = this.currentLine[0];\r\n\t            var lastPoint = this.currentLine[this.currentLine.length - 1];\r\n\t\r\n\t            // Is last white/colored point ?\r\n\t            firstPoint.s && (firstPoint.lastWhite = true);\r\n\t            lastPoint.s && (lastPoint.lastColored = true);\r\n\t\r\n\t            // Reversed line ?\r\n\t            reversed ? lastPoint.s = 0 : firstPoint.s = 0;\r\n\t\r\n\t            // Create left/right points\r\n\t            var rightPoint = { x: lastPoint.x + pixels, y: lastPoint.y, s: 0, p: 0 };\r\n\t            var leftPoint = { x: firstPoint.x - pixels, y: firstPoint.y, s: 0, p: 0 };\r\n\t\r\n\t            if (this.diagonal) {\r\n\t                leftPoint.y += pixels;\r\n\t                rightPoint.y -= pixels;\r\n\t            }\r\n\t\r\n\t            // Add left/right points to current line\r\n\t            this.currentLine.unshift(leftPoint);\r\n\t            this.currentLine.push(rightPoint);\r\n\t        }\r\n\t\r\n\t        // Process current line and return an array of GCode text lines\r\n\t\r\n\t    }, {\r\n\t        key: '_processCurrentLine',\r\n\t        value: function _processCurrentLine(reversed) {\r\n\t            if (this.milling) {\r\n\t                return this._processMillingLine(reversed);\r\n\t            }\r\n\t\r\n\t            return this._processLaserLine(reversed);\r\n\t        }\r\n\t\r\n\t        // Process current line and return an array of GCode text lines\r\n\t\r\n\t    }, {\r\n\t        key: '_processMillingLine',\r\n\t        value: function _processMillingLine(reversed) {\r\n\t            var _this2 = this;\r\n\t\r\n\t            // Skip empty line\r\n\t            if (!this._trimCurrentLine()) {\r\n\t                return null;\r\n\t            }\r\n\t\r\n\t            // Join pixel with same power\r\n\t            if (this.joinPixel) {\r\n\t                this._reduceCurrentLine();\r\n\t            }\r\n\t\r\n\t            // Mark first and last point on the current line\r\n\t            this.currentLine[0].first = true;\r\n\t            this.currentLine[this.currentLine.length - 1].last = true;\r\n\t\r\n\t            // Reversed line ?\r\n\t            if (reversed) {\r\n\t                this.currentLine = this.currentLine.reverse();\r\n\t            }\r\n\t\r\n\t            // Point index\r\n\t            var point = void 0,\r\n\t                index = 0;\r\n\t\r\n\t            // Init loop vars...\r\n\t            var command = void 0,\r\n\t                gcode = [];\r\n\t\r\n\t            var addCommand = function addCommand() {\r\n\t                command = _this2._command.apply(_this2, arguments);\r\n\t                command && gcode.push(command);\r\n\t            };\r\n\t\r\n\t            // Get first point\r\n\t            point = this._getPoint(index);\r\n\t\r\n\t            var plung = false;\r\n\t            var Z = void 0,\r\n\t                zMax = void 0;\r\n\t\r\n\t            var pass = function pass(passNum) {\r\n\t                // Move to start of the line\r\n\t                addCommand(['G', 0], ['Z', _this2.zSafe]);\r\n\t                addCommand(['G', 0], ['X', point.X], ['Y', point.Y]);\r\n\t                addCommand(['G', 0], ['Z', _this2.zSurface]);\r\n\t\r\n\t                // For each point on the line\r\n\t                while (point) {\r\n\t                    if (point.S) {\r\n\t                        if (plung) {\r\n\t                            addCommand(['G', 0], ['Z', _this2.zSurface]);\r\n\t                            plung = false;\r\n\t                        }\r\n\t\r\n\t                        Z = point.S;\r\n\t                        zMax = _this2.passDepth * passNum;\r\n\t\r\n\t                        // Last pass\r\n\t                        if (passNum < _this2.passes) {\r\n\t                            Z = Math.max(Z, -zMax);\r\n\t                        }\r\n\t\r\n\t                        addCommand(['G', 1], ['Z', _this2.zSurface + Z]);\r\n\t                        addCommand(['G', 1], ['X', point.X], ['Y', point.Y]);\r\n\t                    } else {\r\n\t                        if (plung) {\r\n\t                            addCommand(['G', 1], ['Z', _this2.zSurface]);\r\n\t                            plung = false;\r\n\t                        }\r\n\t\r\n\t                        addCommand(['G', 0], ['Z', _this2.zSafe]);\r\n\t                        addCommand(['G', 0], ['X', point.X], ['Y', point.Y]);\r\n\t                    }\r\n\t\r\n\t                    if (point.lastWhite || point.lastColored) {\r\n\t                        plung = true;\r\n\t                    }\r\n\t\r\n\t                    // Get next point\r\n\t                    point = _this2._getPoint(++index);\r\n\t                }\r\n\t\r\n\t                // Move to Z safe\r\n\t                addCommand(['G', 1], ['Z', _this2.zSurface]);\r\n\t                addCommand(['G', 0], ['Z', _this2.zSafe]);\r\n\t            };\r\n\t\r\n\t            for (var i = 1; i <= this.passes; i++) {\r\n\t                pass(i);\r\n\t\r\n\t                if (!gcode.length) {\r\n\t                    break;\r\n\t                }\r\n\t\r\n\t                if (this.gcodes.length < i) {\r\n\t                    this.gcodes.push([]);\r\n\t                } else {\r\n\t                    this.gcodes[i - 1].push.apply(this.gcodes[i - 1], gcode);\r\n\t                }\r\n\t\r\n\t                index = 0;\r\n\t                gcode = [];\r\n\t                point = this._getPoint(index);\r\n\t\r\n\t                this.lastCommands = {};\r\n\t            }\r\n\t\r\n\t            // Not sure what to return...\r\n\t            return null;\r\n\t        }\r\n\t\r\n\t        // Process current line and return an array of GCode text lines\r\n\t\r\n\t    }, {\r\n\t        key: '_processLaserLine',\r\n\t        value: function _processLaserLine(reversed) {\r\n\t            var _this3 = this;\r\n\t\r\n\t            // Trim trailing white spaces ?\r\n\t            if (this.trimLine && !this._trimCurrentLine()) {\r\n\t                // Skip empty line\r\n\t                return null;\r\n\t            }\r\n\t\r\n\t            // Join pixel with same power\r\n\t            if (this.joinPixel) {\r\n\t                this._reduceCurrentLine();\r\n\t            }\r\n\t\r\n\t            // Overscan ?\r\n\t            if (this.overscan) {\r\n\t                this._overscanCurrentLine(reversed);\r\n\t            }\r\n\t\r\n\t            // Mark first and last point on the current line\r\n\t            this.currentLine[0].first = true;\r\n\t            this.currentLine[this.currentLine.length - 1].last = true;\r\n\t\r\n\t            // Reversed line ?\r\n\t            if (reversed) {\r\n\t                this.currentLine = this.currentLine.reverse();\r\n\t            }\r\n\t\r\n\t            // Point index\r\n\t            var point = void 0,\r\n\t                index = 0;\r\n\t\r\n\t            // Init loop vars...\r\n\t            var command = void 0,\r\n\t                gcode = [];\r\n\t\r\n\t            var addCommand = function addCommand() {\r\n\t                command = _this3._command.apply(_this3, arguments);\r\n\t                command && gcode.push(command);\r\n\t            };\r\n\t\r\n\t            // Get first point\r\n\t            point = this._getPoint(index);\r\n\t\r\n\t            // Move to start of the line\r\n\t            addCommand(this.G0, ['X', point.X], ['Y', point.Y], ['S', 0]);\r\n\t\r\n\t            // For each point on the line\r\n\t            while (point) {\r\n\t                // Burn to next point\r\n\t                addCommand(point.G, ['X', point.X], ['Y', point.Y], ['S', point.S]);\r\n\t\r\n\t                // Get next point\r\n\t                point = this._getPoint(++index);\r\n\t            }\r\n\t\r\n\t            // Return gcode commands array\r\n\t            if (gcode.length) {\r\n\t                return gcode;\r\n\t            }\r\n\t\r\n\t            // Empty line\r\n\t            return null;\r\n\t        }\r\n\t\r\n\t        // Parse horizontally\r\n\t\r\n\t    }, {\r\n\t        key: '_scanHorizontally',\r\n\t        value: function _scanHorizontally(nonBlocking) {\r\n\t            var _this4 = this;\r\n\t\r\n\t            // Init loop vars\r\n\t            var x = 0,\r\n\t                y = 0;\r\n\t            var s = void 0,\r\n\t                p = void 0,\r\n\t                point = void 0,\r\n\t                gcode = void 0;\r\n\t            var w = this.size.width;\r\n\t            var h = this.size.height;\r\n\t\r\n\t            var reversed = false;\r\n\t            var lastWhite = false;\r\n\t            var lastColored = false;\r\n\t\r\n\t            var computeCurrentLine = function computeCurrentLine() {\r\n\t                // Reset current line\r\n\t                _this4.currentLine = [];\r\n\t\r\n\t                // Reset point object\r\n\t                point = null;\r\n\t\r\n\t                // For each pixel on the line\r\n\t                for (x = 0; x <= w; x++) {\r\n\t                    // Get pixel power\r\n\t                    s = p = _this4._getPixelPower(x, y, p);\r\n\t\r\n\t                    // Is last white/colored pixel\r\n\t                    lastWhite = point && !point.p && p;\r\n\t                    lastColored = point && point.p && !p;\r\n\t\r\n\t                    // Pixel color from last one on normal line\r\n\t                    if (!reversed && point) {\r\n\t                        s = point.p;\r\n\t                    }\r\n\t\r\n\t                    // Create point object\r\n\t                    point = { x: x, y: y, s: s, p: p };\r\n\t\r\n\t                    // Set last white/colored pixel\r\n\t                    lastWhite && (point.lastWhite = true);\r\n\t                    lastColored && (point.lastColored = true);\r\n\t\r\n\t                    // Add point to current line\r\n\t                    _this4.currentLine.push(point);\r\n\t                }\r\n\t            };\r\n\t\r\n\t            var percent = 0;\r\n\t            var lastPercent = 0;\r\n\t\r\n\t            var processCurrentLine = function processCurrentLine() {\r\n\t                // Process pixels line\r\n\t                gcode = _this4._processCurrentLine(reversed);\r\n\t\r\n\t                // Call progress callback\r\n\t                percent = Math.round(y / h * 100);\r\n\t\r\n\t                if (percent > lastPercent) {\r\n\t                    _this4._onProgress({ gcode: gcode, percent: percent });\r\n\t                }\r\n\t\r\n\t                lastPercent = percent;\r\n\t\r\n\t                // Skip empty gcode line\r\n\t                if (!gcode) {\r\n\t                    return;\r\n\t                }\r\n\t\r\n\t                // Toggle line state\r\n\t                reversed = !reversed;\r\n\t\r\n\t                // Concat line\r\n\t                _this4.gcode.push.apply(_this4.gcode, gcode);\r\n\t            };\r\n\t\r\n\t            var processNextLine = function processNextLine() {\r\n\t                // Aborted ?\r\n\t                if (!_this4.running) {\r\n\t                    return _this4._onAbort();\r\n\t                }\r\n\t\r\n\t                // Process line...\r\n\t                computeCurrentLine();\r\n\t                processCurrentLine();\r\n\t\r\n\t                y++;\r\n\t\r\n\t                if (y < h) {\r\n\t                    if (nonBlocking) {\r\n\t                        setTimeout(processNextLine, 0);\r\n\t                    } else {\r\n\t                        processNextLine();\r\n\t                    }\r\n\t                } else {\r\n\t                    if (_this4.milling) {\r\n\t                        _this4.gcodes.forEach(function (gcode) {\r\n\t                            _this4.gcode.push.apply(_this4.gcode, gcode);\r\n\t                        });\r\n\t                    }\r\n\t\r\n\t                    _this4._onDone({ gcode: _this4.gcode });\r\n\t                    _this4.running = false;\r\n\t                }\r\n\t            };\r\n\t\r\n\t            processNextLine();\r\n\t        }\r\n\t\r\n\t        // Parse diagonally\r\n\t\r\n\t    }, {\r\n\t        key: '_scanDiagonally',\r\n\t        value: function _scanDiagonally(nonBlocking) {\r\n\t            var _this5 = this;\r\n\t\r\n\t            // Init loop vars\r\n\t            var x = 0,\r\n\t                y = 0;\r\n\t            var s = void 0,\r\n\t                p = void 0,\r\n\t                point = void 0,\r\n\t                gcode = void 0;\r\n\t            var w = this.size.width;\r\n\t            var h = this.size.height;\r\n\t\r\n\t            var totalLines = w + h - 1;\r\n\t            var lineNum = 0;\r\n\t            var reversed = false;\r\n\t            var lastWhite = false;\r\n\t            var lastColored = false;\r\n\t\r\n\t            var computeCurrentLine = function computeCurrentLine(x, y) {\r\n\t                // Reset current line\r\n\t                _this5.currentLine = [];\r\n\t\r\n\t                // Reset point object\r\n\t                point = null;\r\n\t\r\n\t                // Increment line num\r\n\t                lineNum++;\r\n\t\r\n\t                while (true) {\r\n\t                    // Y limit reached !\r\n\t                    if (y < -1 || y == h) {\r\n\t                        break;\r\n\t                    }\r\n\t\r\n\t                    // X limit reached !\r\n\t                    if (x < 0 || x > w) {\r\n\t                        break;\r\n\t                    }\r\n\t\r\n\t                    // Get pixel power\r\n\t                    s = p = _this5._getPixelPower(x, y, p);\r\n\t\r\n\t                    // Is last white/colored pixel\r\n\t                    lastWhite = point && !point.p && p;\r\n\t                    lastColored = point && point.p && !p;\r\n\t\r\n\t                    // Pixel color from last one on normal line\r\n\t                    if (!reversed && point) {\r\n\t                        s = point.p;\r\n\t                    }\r\n\t\r\n\t                    // Create point object\r\n\t                    point = { x: x, y: y, s: s, p: p };\r\n\t\r\n\t                    // Set last white/colored pixel\r\n\t                    lastWhite && (point.lastWhite = true);\r\n\t                    lastColored && (point.lastColored = true);\r\n\t\r\n\t                    // Add the new point\r\n\t                    _this5.currentLine.push(point);\r\n\t\r\n\t                    // Next coords\r\n\t                    x++;\r\n\t                    y--;\r\n\t                }\r\n\t            };\r\n\t\r\n\t            var percent = 0;\r\n\t            var lastPercent = 0;\r\n\t\r\n\t            var processCurrentLine = function processCurrentLine() {\r\n\t                // Process pixels line\r\n\t                gcode = _this5._processCurrentLine(reversed);\r\n\t\r\n\t                // Call progress callback\r\n\t                percent = Math.round(lineNum / totalLines * 100);\r\n\t\r\n\t                if (percent > lastPercent) {\r\n\t                    _this5._onProgress({ gcode: gcode, percent: percent });\r\n\t                }\r\n\t\r\n\t                lastPercent = percent;\r\n\t\r\n\t                // Skip empty gcode line\r\n\t                if (!gcode) {\r\n\t                    return;\r\n\t                }\r\n\t\r\n\t                // Toggle line state\r\n\t                reversed = !reversed;\r\n\t\r\n\t                // Concat line\r\n\t                _this5.gcode.push.apply(_this5.gcode, gcode);\r\n\t            };\r\n\t\r\n\t            var processNextLine = function processNextLine() {\r\n\t                // Aborted ?\r\n\t                if (!_this5.running) {\r\n\t                    return _this5._onAbort();\r\n\t                }\r\n\t\r\n\t                // Process line...\r\n\t                computeCurrentLine(x, y);\r\n\t                processCurrentLine();\r\n\t\r\n\t                if (!x) y++;else x++;\r\n\t\r\n\t                if (y === h) {\r\n\t                    x++;\r\n\t                    y--;\r\n\t                }\r\n\t\r\n\t                if (y < h && x < w) {\r\n\t                    if (nonBlocking) {\r\n\t                        setTimeout(processNextLine, 0);\r\n\t                    } else {\r\n\t                        processNextLine();\r\n\t                    }\r\n\t                } else {\r\n\t                    _this5._onDone({ gcode: _this5.gcode });\r\n\t                    _this5.running = false;\r\n\t                }\r\n\t            };\r\n\t\r\n\t            processNextLine();\r\n\t        }\r\n\t    }, {\r\n\t        key: '_onProgress',\r\n\t        value: function _onProgress(event) {\r\n\t            //console.log('progress:', event.percent)\r\n\t        }\r\n\t    }, {\r\n\t        key: '_onDone',\r\n\t        value: function _onDone(event) {\r\n\t            //console.log('done:', event.gcode.length)\r\n\t        }\r\n\t    }, {\r\n\t        key: '_onAbort',\r\n\t        value: function _onAbort() {\r\n\t            //console.log('abort')\r\n\t        }\r\n\t    }, {\r\n\t        key: 'on',\r\n\t        value: function on(event, callback, context) {\r\n\t            var _this6 = this;\r\n\t\r\n\t            var method = '_on' + event[0].toUpperCase() + event.slice(1);\r\n\t\r\n\t            if (!this[method] || typeof this[method] !== 'function') {\r\n\t                throw new Error('Undefined event: ' + event);\r\n\t            }\r\n\t\r\n\t            this[method] = function (event) {\r\n\t                return callback.call(context || _this6, event);\r\n\t            };\r\n\t\r\n\t            return this;\r\n\t        }\r\n\t\r\n\t        // Return the bitmap height-map\r\n\t\r\n\t    }, {\r\n\t        key: 'getHeightMap',\r\n\t        value: function getHeightMap(settings) {\r\n\t            var _this7 = this;\r\n\t\r\n\t            if (this.running) {\r\n\t                return;\r\n\t            }\r\n\t\r\n\t            // Init loop vars\r\n\t            this.running = true;\r\n\t            var heightMap = [];\r\n\t\r\n\t            var x = 0;\r\n\t            var y = 0;\r\n\t            var w = this.size.width;\r\n\t            var h = this.size.height;\r\n\t\r\n\t            var percent = 0;\r\n\t            var lastPercent = 0;\r\n\t\r\n\t            // Defaults settings\r\n\t            settings = settings || {};\r\n\t\r\n\t            // Register user callbacks\r\n\t            this._registerUserCallbacks(settings);\r\n\t\r\n\t            // Non blocking mode ?\r\n\t            var nonBlocking = this.nonBlocking;\r\n\t\r\n\t            if (settings.nonBlocking !== undefined) {\r\n\t                nonBlocking = settings.nonBlocking;\r\n\t            }\r\n\t\r\n\t            var computeCurrentLine = function computeCurrentLine() {\r\n\t                // Reset current line\r\n\t                var pixels = [];\r\n\t\r\n\t                // For each pixel on the line\r\n\t                for (x = 0; x < w; x++) {\r\n\t                    pixels.push(_this7._mapPixelPower(_this7._getPixelPower(x, y)));\r\n\t                }\r\n\t\r\n\t                // Call progress callback\r\n\t                percent = Math.round(y / h * 100);\r\n\t\r\n\t                if (percent > lastPercent) {\r\n\t                    //onProgress.call(settings.progressContext || this, { pixels, percent })\r\n\t                    _this7._onProgress({ pixels: pixels, percent: percent });\r\n\t                }\r\n\t\r\n\t                lastPercent = percent;\r\n\t\r\n\t                // Add pixels line\r\n\t                heightMap.push(pixels);\r\n\t            };\r\n\t\r\n\t            var processNextLine = function processNextLine() {\r\n\t                // Aborted ?\r\n\t                if (!_this7.running) {\r\n\t                    return _this7._onAbort();\r\n\t                }\r\n\t\r\n\t                // Process line...\r\n\t                computeCurrentLine();\r\n\t\r\n\t                y++;\r\n\t\r\n\t                if (y < h) {\r\n\t                    if (nonBlocking) {\r\n\t                        setTimeout(processNextLine, 0);\r\n\t                    } else {\r\n\t                        processNextLine();\r\n\t                    }\r\n\t                } else {\r\n\t                    //onDone.call(settings.doneContext || this, { heightMap })\r\n\t                    _this7._onDone({ heightMap: heightMap });\r\n\t                    _this7.running = false;\r\n\t                }\r\n\t            };\r\n\t\r\n\t            processNextLine();\r\n\t\r\n\t            if (!nonBlocking) {\r\n\t                return heightMap;\r\n\t            }\r\n\t        }\r\n\t    }]);\r\n\t\r\n\t    return RasterToGcode;\r\n\t}(_lw2.default);\r\n\t\r\n\t// Exports\r\n\t\r\n\t\r\n\texports.RasterToGcode = RasterToGcode;\r\n\texports.default = RasterToGcode;\r\n\r\n/***/ },\r\n/* 2 */\r\n/***/ function(module, exports, __webpack_require__) {\r\n\r\n\t(function webpackUniversalModuleDefinition(root, factory) {\r\n\t\tif(true)\r\n\t\t\tmodule.exports = factory();\r\n\t\telse if(typeof define === 'function' && define.amd)\r\n\t\t\tdefine(\"CanvasGrid\", [], factory);\r\n\t\telse if(typeof exports === 'object')\r\n\t\t\texports[\"CanvasGrid\"] = factory();\r\n\t\telse\r\n\t\t\troot[\"CanvasGrid\"] = factory();\r\n\t})(this, function() {\r\n\treturn /******/ (function(modules) { // webpackBootstrap\r\n\t/******/ \t// The module cache\r\n\t/******/ \tvar installedModules = {};\r\n\t/******/\r\n\t/******/ \t// The require function\r\n\t/******/ \tfunction __webpack_require__(moduleId) {\r\n\t/******/\r\n\t/******/ \t\t// Check if module is in cache\r\n\t/******/ \t\tif(installedModules[moduleId])\r\n\t/******/ \t\t\treturn installedModules[moduleId].exports;\r\n\t/******/\r\n\t/******/ \t\t// Create a new module (and put it into the cache)\r\n\t/******/ \t\tvar module = installedModules[moduleId] = {\r\n\t/******/ \t\t\texports: {},\r\n\t/******/ \t\t\tid: moduleId,\r\n\t/******/ \t\t\tloaded: false\r\n\t/******/ \t\t};\r\n\t/******/\r\n\t/******/ \t\t// Execute the module function\r\n\t/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\r\n\t/******/\r\n\t/******/ \t\t// Flag the module as loaded\r\n\t/******/ \t\tmodule.loaded = true;\r\n\t/******/\r\n\t/******/ \t\t// Return the exports of the module\r\n\t/******/ \t\treturn module.exports;\r\n\t/******/ \t}\r\n\t/******/\r\n\t/******/\r\n\t/******/ \t// expose the modules object (__webpack_modules__)\r\n\t/******/ \t__webpack_require__.m = modules;\r\n\t/******/\r\n\t/******/ \t// expose the module cache\r\n\t/******/ \t__webpack_require__.c = installedModules;\r\n\t/******/\r\n\t/******/ \t// __webpack_public_path__\r\n\t/******/ \t__webpack_require__.p = \"\";\r\n\t/******/\r\n\t/******/ \t// Load entry module and return exports\r\n\t/******/ \treturn __webpack_require__(0);\r\n\t/******/ })\r\n\t/************************************************************************/\r\n\t/******/ ([\r\n\t/* 0 */\r\n\t/***/ function(module, exports, __webpack_require__) {\r\n\t\r\n\t\tmodule.exports = __webpack_require__(1);\r\n\t\r\n\t\r\n\t/***/ },\r\n\t/* 1 */\r\n\t/***/ function(module, exports, __webpack_require__) {\r\n\t\r\n\t\t'use strict';\r\n\t\t\r\n\t\tObject.defineProperty(exports, \"__esModule\", {\r\n\t\t    value: true\r\n\t\t});\r\n\t\texports.CanvasGrid = undefined;\r\n\t\t\r\n\t\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\r\n\t\t\r\n\t\tvar _lw = __webpack_require__(2);\r\n\t\t\r\n\t\tvar _lw2 = _interopRequireDefault(_lw);\r\n\t\t\r\n\t\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\t\t\r\n\t\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\r\n\t\t\r\n\t\t// CanvasGrid class\r\n\t\tvar CanvasGrid = function () {\r\n\t\t    // Class constructor...\r\n\t\t    function CanvasGrid(settings) {\r\n\t\t        _classCallCheck(this, CanvasGrid);\r\n\t\t\r\n\t\t        // Init properties\r\n\t\t        this.cellSize = 1024;\r\n\t\t        this.scaleRatio = { x: 1, y: 1 };\r\n\t\t        this.filters = {};\r\n\t\t\r\n\t\t        Object.assign(this, settings || {});\r\n\t\t\r\n\t\t        if (!this.scaleRatio.x) {\r\n\t\t            this.scaleRatio = { x: this.scaleRatio, y: this.scaleRatio };\r\n\t\t        }\r\n\t\t\r\n\t\t        this.size = { width: 0, height: 0, cols: 0, rows: 0 };\r\n\t\t        this.file = null;\r\n\t\t        this.image = null;\r\n\t\t        this.url = null;\r\n\t\t        this.canvas = [];\r\n\t\t        this.pixels = [];\r\n\t\t    }\r\n\t\t\r\n\t\t    // <input> can be Image, File, URL object or URL string (http://* or data:image/*)\r\n\t\t\r\n\t\t\r\n\t\t    _createClass(CanvasGrid, [{\r\n\t\t        key: 'load',\r\n\t\t        value: function load(input) {\r\n\t\t            // Load File object\r\n\t\t            if (input instanceof File) {\r\n\t\t                return this.loadFromFile(input);\r\n\t\t            }\r\n\t\t\r\n\t\t            // Load Image object\r\n\t\t            if (input instanceof Image) {\r\n\t\t                return this.loadFromImage(input);\r\n\t\t            }\r\n\t\t\r\n\t\t            // Load URL object\r\n\t\t            if (typeof input === 'string' || input instanceof URL) {\r\n\t\t                return this.loadFromURL(input.trim());\r\n\t\t            }\r\n\t\t\r\n\t\t            // Return rejected promise with an Error object\r\n\t\t            return Promise.reject(new Error('Unsupported input format.'));\r\n\t\t        }\r\n\t\t\r\n\t\t        // Load image\r\n\t\t\r\n\t\t    }, {\r\n\t\t        key: '_loadImage',\r\n\t\t        value: function _loadImage(src, reject, resolve) {\r\n\t\t            var _this = this;\r\n\t\t\r\n\t\t            // Create Image object\r\n\t\t            var image = new Image();\r\n\t\t\r\n\t\t            // Register for load and error events\r\n\t\t            image.onload = function (event) {\r\n\t\t                _this.loadFromImage(image).then(resolve).catch(reject);\r\n\t\t            };\r\n\t\t\r\n\t\t            image.onerror = function (event) {\r\n\t\t                reject(new Error('An error occurred while loading the image : ' + src));\r\n\t\t            };\r\n\t\t\r\n\t\t            // Load the image from File url\r\n\t\t            image.src = src;\r\n\t\t        }\r\n\t\t\r\n\t\t        // Load from File object\r\n\t\t\r\n\t\t    }, {\r\n\t\t        key: 'loadFromFile',\r\n\t\t        value: function loadFromFile(input) {\r\n\t\t            var _this2 = this;\r\n\t\t\r\n\t\t            return new Promise(function (resolve, reject) {\r\n\t\t                // Bad input type\r\n\t\t                if (!(input instanceof File)) {\r\n\t\t                    reject(new Error('Input param must be a File object.'));\r\n\t\t                }\r\n\t\t\r\n\t\t                // Set input file\r\n\t\t                _this2.file = input;\r\n\t\t\r\n\t\t                // Load image\r\n\t\t                _this2._loadImage(URL.createObjectURL(input), reject, resolve);\r\n\t\t            });\r\n\t\t        }\r\n\t\t\r\n\t\t        // Load from URL object or string\r\n\t\t\r\n\t\t    }, {\r\n\t\t        key: 'loadFromURL',\r\n\t\t        value: function loadFromURL(input) {\r\n\t\t            var _this3 = this;\r\n\t\t\r\n\t\t            return new Promise(function (resolve, reject) {\r\n\t\t                // Bad input type\r\n\t\t                if (!(input instanceof URL) && typeof input !== 'string') {\r\n\t\t                    reject(new Error('Input param must be a URL string or object.'));\r\n\t\t                }\r\n\t\t\r\n\t\t                // Create url object\r\n\t\t                var url = input instanceof URL ? input : new URL(input);\r\n\t\t\r\n\t\t                // Set url\r\n\t\t                _this3.url = url;\r\n\t\t\r\n\t\t                // Load image\r\n\t\t                _this3._loadImage(url, reject, resolve);\r\n\t\t            });\r\n\t\t        }\r\n\t\t\r\n\t\t        // Load from Image object\r\n\t\t\r\n\t\t    }, {\r\n\t\t        key: 'loadFromImage',\r\n\t\t        value: function loadFromImage(input) {\r\n\t\t            var _this4 = this;\r\n\t\t\r\n\t\t            return new Promise(function (resolve, reject) {\r\n\t\t                // Bad input type\r\n\t\t                if (!(input instanceof Image)) {\r\n\t\t                    reject(new Error('Input param must be a Image object.'));\r\n\t\t                }\r\n\t\t\r\n\t\t                // Set input image\r\n\t\t                _this4.image = input;\r\n\t\t\r\n\t\t                // Process image\r\n\t\t                _this4._processImage();\r\n\t\t\r\n\t\t                // Resolve the promise\r\n\t\t                resolve(_this4);\r\n\t\t            });\r\n\t\t        }\r\n\t\t    }, {\r\n\t\t        key: '_processImage',\r\n\t\t        value: function _processImage() {\r\n\t\t            // Reset canvas grid\r\n\t\t            this.canvas = [];\r\n\t\t            this.pixels = [];\r\n\t\t\r\n\t\t            // Calculate grid size\r\n\t\t            var width = Math.round(this.image.width * this.scaleRatio.x);\r\n\t\t            var height = Math.round(this.image.height * this.scaleRatio.y);\r\n\t\t            var cols = Math.ceil(width / this.cellSize);\r\n\t\t            var rows = Math.ceil(height / this.cellSize);\r\n\t\t\r\n\t\t            this.size = { width: width, height: height, cols: cols, rows: rows };\r\n\t\t\r\n\t\t            // Create canvas grid\r\n\t\t            var line = null;\r\n\t\t            var canvas = null;\r\n\t\t            var pixels = null;\r\n\t\t            var context = null;\r\n\t\t\r\n\t\t            var x = null; // cols\r\n\t\t            var y = null; // rows\r\n\t\t            var sx = null; // scaled cols\r\n\t\t            var sy = null; // scaled rows\r\n\t\t            var sw = null; // scaled width\r\n\t\t            var sh = null; // scaled height\r\n\t\t\r\n\t\t            // For each line\r\n\t\t            for (y = 0; y < this.size.rows; y++) {\r\n\t\t                // Reset current line\r\n\t\t                line = [];\r\n\t\t                pixels = [];\r\n\t\t\r\n\t\t                // For each column\r\n\t\t                for (x = 0; x < this.size.cols; x++) {\r\n\t\t                    // Create canvas element\r\n\t\t                    canvas = document.createElement('canvas');\r\n\t\t\r\n\t\t                    // Set canvas size\r\n\t\t                    if (x === 0 || x < this.size.cols - 1) {\r\n\t\t                        canvas.width = this.size.width < this.cellSize ? this.size.width : this.cellSize;\r\n\t\t                    } else {\r\n\t\t                        // Get the rest for the last item (except the first one)\r\n\t\t                        canvas.width = this.size.width % this.cellSize;\r\n\t\t                    }\r\n\t\t\r\n\t\t                    if (y === 0 || y < this.size.rows - 1) {\r\n\t\t                        canvas.height = this.size.height < this.cellSize ? this.size.height : this.cellSize;\r\n\t\t                    } else {\r\n\t\t                        // Get the rest for the last item (except the first one)\r\n\t\t                        canvas.height = this.size.height % this.cellSize;\r\n\t\t                    }\r\n\t\t\r\n\t\t                    // Get canvas 2d context\r\n\t\t                    context = canvas.getContext('2d');\r\n\t\t\r\n\t\t                    // Fill withe background (avoid alpha chanel calculation)\r\n\t\t                    context.fillStyle = 'white';\r\n\t\t                    context.fillRect(0, 0, canvas.width, canvas.height);\r\n\t\t\r\n\t\t                    // Draw the part of image in the canvas (scale)\r\n\t\t                    sw = canvas.width / this.scaleRatio.x;\r\n\t\t                    sh = canvas.height / this.scaleRatio.y;\r\n\t\t                    sx = x * this.cellSize / this.scaleRatio.x;\r\n\t\t                    sy = y * this.cellSize / this.scaleRatio.y;\r\n\t\t\r\n\t\t                    context.drawImage(this.image, sx, sy, sw, sh, 0, 0, canvas.width, canvas.height);\r\n\t\t\r\n\t\t                    // Apply image filters\r\n\t\t                    (0, _lw2.default)(canvas, this.filters);\r\n\t\t\r\n\t\t                    // Add the canvas to current line\r\n\t\t                    line.push(canvas);\r\n\t\t\r\n\t\t                    // Add the canvas image data to current line\r\n\t\t                    pixels.push(context.getImageData(0, 0, canvas.width, canvas.height).data);\r\n\t\t                }\r\n\t\t\r\n\t\t                // Add the line to canvas grid\r\n\t\t                this.pixels.push(pixels);\r\n\t\t                this.canvas.push(line);\r\n\t\t            }\r\n\t\t        }\r\n\t\t    }, {\r\n\t\t        key: 'getPixel',\r\n\t\t        value: function getPixel(x, y) {\r\n\t\t            // Test coords validity\r\n\t\t            x = parseInt(x);\r\n\t\t            y = parseInt(y);\r\n\t\t\r\n\t\t            if (isNaN(x) || isNaN(y)) {\r\n\t\t                throw new Error('[x, y] params must be Integer.');\r\n\t\t            }\r\n\t\t\r\n\t\t            // Test coords range\r\n\t\t            if (x < 0 || x >= this.size.width) {\r\n\t\t                throw new Error('Out of range: x = ' + x + ', max: ' + this.size.width);\r\n\t\t            }\r\n\t\t\r\n\t\t            if (y < 0 || y >= this.size.height) {\r\n\t\t                throw new Error('Out of range: y = ' + y + ', max: ' + this.size.height);\r\n\t\t            }\r\n\t\t\r\n\t\t            // Calculate target canvas coords\r\n\t\t            var col = parseInt(x / this.cellSize);\r\n\t\t            var row = parseInt(y / this.cellSize);\r\n\t\t\r\n\t\t            // Adjuste x/y values relative to canvas origin\r\n\t\t            col && (x -= this.cellSize * col);\r\n\t\t            row && (y -= this.cellSize * row);\r\n\t\t\r\n\t\t            // Get pixel data\r\n\t\t            var cellSize = this.cellSize;\r\n\t\t\r\n\t\t            if (this.size.width < cellSize) {\r\n\t\t                cellSize = this.size.width;\r\n\t\t            } else if (this.size.width < cellSize * (col + 1)) {\r\n\t\t                cellSize = this.size.width % cellSize;\r\n\t\t            }\r\n\t\t\r\n\t\t            var i = y * (cellSize * 4) + x * 4;\r\n\t\t            var pixels = this.pixels[row][col];\r\n\t\t            var pixelData = pixels.slice(i, i + 4);\r\n\t\t\r\n\t\t            return {\r\n\t\t                color: { r: pixelData[0], g: pixelData[1], b: pixelData[2], a: pixelData[3] },\r\n\t\t                gray: (pixelData[0] + pixelData[1] + pixelData[2]) / 3,\r\n\t\t                grid: { col: col, row: row },\r\n\t\t                coords: { x: x, y: y }\r\n\t\t            };\r\n\t\t        }\r\n\t\t    }]);\r\n\t\t\r\n\t\t    return CanvasGrid;\r\n\t\t}();\r\n\t\t\r\n\t\t// Exports\r\n\t\t\r\n\t\t\r\n\t\texports.CanvasGrid = CanvasGrid;\r\n\t\texports.default = CanvasGrid;\r\n\t\r\n\t/***/ },\r\n\t/* 2 */\r\n\t/***/ function(module, exports, __webpack_require__) {\r\n\t\r\n\t\t(function webpackUniversalModuleDefinition(root, factory) {\r\n\t\t\tif(true)\r\n\t\t\t\tmodule.exports = factory();\r\n\t\t\telse if(typeof define === 'function' && define.amd)\r\n\t\t\t\tdefine(\"CanvasFilter\", [], factory);\r\n\t\t\telse if(typeof exports === 'object')\r\n\t\t\t\texports[\"CanvasFilter\"] = factory();\r\n\t\t\telse\r\n\t\t\t\troot[\"CanvasFilter\"] = factory();\r\n\t\t})(this, function() {\r\n\t\treturn /******/ (function(modules) { // webpackBootstrap\r\n\t\t/******/ \t// The module cache\r\n\t\t/******/ \tvar installedModules = {};\r\n\t\t/******/\r\n\t\t/******/ \t// The require function\r\n\t\t/******/ \tfunction __webpack_require__(moduleId) {\r\n\t\t/******/\r\n\t\t/******/ \t\t// Check if module is in cache\r\n\t\t/******/ \t\tif(installedModules[moduleId])\r\n\t\t/******/ \t\t\treturn installedModules[moduleId].exports;\r\n\t\t/******/\r\n\t\t/******/ \t\t// Create a new module (and put it into the cache)\r\n\t\t/******/ \t\tvar module = installedModules[moduleId] = {\r\n\t\t/******/ \t\t\texports: {},\r\n\t\t/******/ \t\t\tid: moduleId,\r\n\t\t/******/ \t\t\tloaded: false\r\n\t\t/******/ \t\t};\r\n\t\t/******/\r\n\t\t/******/ \t\t// Execute the module function\r\n\t\t/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\r\n\t\t/******/\r\n\t\t/******/ \t\t// Flag the module as loaded\r\n\t\t/******/ \t\tmodule.loaded = true;\r\n\t\t/******/\r\n\t\t/******/ \t\t// Return the exports of the module\r\n\t\t/******/ \t\treturn module.exports;\r\n\t\t/******/ \t}\r\n\t\t/******/\r\n\t\t/******/\r\n\t\t/******/ \t// expose the modules object (__webpack_modules__)\r\n\t\t/******/ \t__webpack_require__.m = modules;\r\n\t\t/******/\r\n\t\t/******/ \t// expose the module cache\r\n\t\t/******/ \t__webpack_require__.c = installedModules;\r\n\t\t/******/\r\n\t\t/******/ \t// __webpack_public_path__\r\n\t\t/******/ \t__webpack_require__.p = \"\";\r\n\t\t/******/\r\n\t\t/******/ \t// Load entry module and return exports\r\n\t\t/******/ \treturn __webpack_require__(0);\r\n\t\t/******/ })\r\n\t\t/************************************************************************/\r\n\t\t/******/ ([\r\n\t\t/* 0 */\r\n\t\t/***/ function(module, exports, __webpack_require__) {\r\n\t\t\r\n\t\t\tmodule.exports = __webpack_require__(1);\r\n\t\t\r\n\t\t\r\n\t\t/***/ },\r\n\t\t/* 1 */\r\n\t\t/***/ function(module, exports) {\r\n\t\t\r\n\t\t\t'use strict';\r\n\t\t\t\r\n\t\t\tObject.defineProperty(exports, \"__esModule\", {\r\n\t\t\t    value: true\r\n\t\t\t});\r\n\t\t\t// Grayscale algorithms\r\n\t\t\tvar grayscaleAlgorithms = ['none', 'average', 'desaturation', 'decomposition-min', 'decomposition-max', 'luma', 'luma-601', 'luma-709', 'luma-240', 'red-chanel', 'green-chanel', 'blue-chanel'];\r\n\t\t\t\r\n\t\t\t// Trucate color value in the 0-255 range\r\n\t\t\tfunction color(color) {\r\n\t\t\t    return color < 0 ? 0 : color > 255 ? 255 : color;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// Filters ...\r\n\t\t\tfunction invertColor(data, i, value) {\r\n\t\t\t    if (value) {\r\n\t\t\t        data[i] = color(255 - data[i]);\r\n\t\t\t        data[i + 1] = color(255 - data[i + 1]);\r\n\t\t\t        data[i + 2] = color(255 - data[i + 2]);\r\n\t\t\t    }\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tfunction brightness(data, i, value) {\r\n\t\t\t    if (value !== undefined) {\r\n\t\t\t        data[i] = color(data[i] + value);\r\n\t\t\t        data[i + 1] = color(data[i + 1] + value);\r\n\t\t\t        data[i + 2] = color(data[i + 2] + value);\r\n\t\t\t    }\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tfunction contrast(data, i, value) {\r\n\t\t\t    if (value !== undefined) {\r\n\t\t\t        data[i] = color(value * (data[i] - 128) + 128);\r\n\t\t\t        data[i + 1] = color(value * (data[i + 1] - 128) + 128);\r\n\t\t\t        data[i + 2] = color(value * (data[i + 2] - 128) + 128);\r\n\t\t\t    }\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tfunction gamma(data, i, value) {\r\n\t\t\t    if (value !== undefined) {\r\n\t\t\t        data[i] = color(Math.exp(Math.log(255 * (data[i] / 255)) * value));\r\n\t\t\t        data[i + 1] = color(Math.exp(Math.log(255 * (data[i + 1] / 255)) * value));\r\n\t\t\t        data[i + 2] = color(Math.exp(Math.log(255 * (data[i + 2] / 255)) * value));\r\n\t\t\t    }\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tfunction grayscale(data, i, algorithm, shades) {\r\n\t\t\t    // Graysale\r\n\t\t\t    // http://www.tannerhelland.com/3643/grayscale-image-algorithm-vb6/\r\n\t\t\t\r\n\t\t\t    // Unsupported algorithm\r\n\t\t\t    if (grayscaleAlgorithms.indexOf(algorithm) === -1) {\r\n\t\t\t        throw new Error('Unsupported grayscale algorithm: ' + algorithm);\r\n\t\t\t    }\r\n\t\t\t\r\n\t\t\t    // None\r\n\t\t\t    if (algorithm === 'none') {\r\n\t\t\t        return null;\r\n\t\t\t    }\r\n\t\t\t\r\n\t\t\t    // Get Red/Green/Blue values\r\n\t\t\t    var gray = void 0;\r\n\t\t\t    var r = data[i];\r\n\t\t\t    var g = data[i + 1];\r\n\t\t\t    var b = data[i + 2];\r\n\t\t\t\r\n\t\t\t    switch (algorithm) {\r\n\t\t\t        case 'average':\r\n\t\t\t            gray = (r + g + b) / 3;\r\n\t\t\t            break;\r\n\t\t\t\r\n\t\t\t        case 'luma':\r\n\t\t\t            // Default\r\n\t\t\t            gray = r * 0.3 + g * 0.59 + b * 0.11;\r\n\t\t\t            break;\r\n\t\t\t\r\n\t\t\t        case 'luma-601':\r\n\t\t\t            // CCIR-601\r\n\t\t\t            gray = r * 0.299 + g * 0.587 + b * 0.114;\r\n\t\t\t            break;\r\n\t\t\t\r\n\t\t\t        case 'luma-709':\r\n\t\t\t            // ITU-R-709\r\n\t\t\t            gray = r * 0.2126 + g * 0.7152 + b * 0.0722;\r\n\t\t\t            break;\r\n\t\t\t\r\n\t\t\t        case 'luma-240':\r\n\t\t\t            // SMPTE-240M\r\n\t\t\t            gray = r * 0.212 + g * 0.701 + b * 0.087;\r\n\t\t\t            break;\r\n\t\t\t\r\n\t\t\t        case 'desaturation':\r\n\t\t\t            gray = (Math.max(r, g, b) + Math.min(r, g, b)) / 2;\r\n\t\t\t            break;\r\n\t\t\t\r\n\t\t\t        case 'decomposition-min':\r\n\t\t\t            gray = Math.min(r, g, b);\r\n\t\t\t            break;\r\n\t\t\t\r\n\t\t\t        case 'decomposition-max':\r\n\t\t\t            gray = Math.max(r, g, b);\r\n\t\t\t            break;\r\n\t\t\t\r\n\t\t\t        case 'red-chanel':\r\n\t\t\t            gray = r;\r\n\t\t\t            break;\r\n\t\t\t\r\n\t\t\t        case 'green-chanel':\r\n\t\t\t            gray = g;\r\n\t\t\t            break;\r\n\t\t\t\r\n\t\t\t        case 'blue-chanel':\r\n\t\t\t            gray = b;\r\n\t\t\t            break;\r\n\t\t\t    }\r\n\t\t\t\r\n\t\t\t    // Shades of gray\r\n\t\t\t    if (shades !== undefined) {\r\n\t\t\t        gray = parseInt(gray / shades) * shades;\r\n\t\t\t    }\r\n\t\t\t\r\n\t\t\t    // Force integer\r\n\t\t\t    gray = parseInt(gray);\r\n\t\t\t\r\n\t\t\t    // Set new r/g/b values\r\n\t\t\t    data[i] = color(gray);\r\n\t\t\t    data[i + 1] = color(gray);\r\n\t\t\t    data[i + 2] = color(gray);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// Apply filters on provided canvas\r\n\t\t\tfunction canvasFilters(canvas, settings) {\r\n\t\t\t    settings = Object.assign({}, {\r\n\t\t\t        smoothing: false, // Smoothing [true|fale]\r\n\t\t\t        brightness: 0, // Image brightness [-255 to +255]\r\n\t\t\t        contrast: 0, // Image contrast [-255 to +255]\r\n\t\t\t        gamma: 0, // Image gamma correction [0.01 to 7.99]\r\n\t\t\t        grayscale: 'none', // Graysale algorithm [average, luma, luma-601, luma-709, luma-240, desaturation, decomposition-[min|max], [red|green|blue]-chanel]\r\n\t\t\t        shadesOfGray: 256, // Number of shades of gray [2-256]\r\n\t\t\t        invertColor: false // Invert color...\r\n\t\t\t    }, settings || {});\r\n\t\t\t\r\n\t\t\t    // Get canvas 2d context\r\n\t\t\t    var context = canvas.getContext('2d');\r\n\t\t\t\r\n\t\t\t    // Smoothing\r\n\t\t\t    if (context.imageSmoothingEnabled !== undefined) {\r\n\t\t\t        context.imageSmoothingEnabled = settings.smoothing;\r\n\t\t\t    } else {\r\n\t\t\t        context.mozImageSmoothingEnabled = settings.smoothing;\r\n\t\t\t        context.webkitImageSmoothingEnabled = settings.smoothing;\r\n\t\t\t        context.msImageSmoothingEnabled = settings.smoothing;\r\n\t\t\t        context.oImageSmoothingEnabled = settings.smoothing;\r\n\t\t\t    }\r\n\t\t\t\r\n\t\t\t    // Get image data\r\n\t\t\t    var imageData = context.getImageData(0, 0, canvas.width, canvas.height);\r\n\t\t\t    var data = imageData.data;\r\n\t\t\t\r\n\t\t\t    var contrastFactor = void 0,\r\n\t\t\t        brightnessOffset = void 0,\r\n\t\t\t        gammaCorrection = void 0,\r\n\t\t\t        shadesOfGrayFactor = void 0;\r\n\t\t\t\r\n\t\t\t    if (settings.contrast !== 0) {\r\n\t\t\t        contrastFactor = 259 * (settings.contrast + 255) / (255 * (259 - settings.contrast));\r\n\t\t\t    }\r\n\t\t\t\r\n\t\t\t    if (settings.brightness !== 0) {\r\n\t\t\t        brightnessOffset = settings.brightness;\r\n\t\t\t    }\r\n\t\t\t\r\n\t\t\t    if (settings.gamma !== 0) {\r\n\t\t\t        gammaCorrection = 1 / settings.gamma;\r\n\t\t\t    }\r\n\t\t\t\r\n\t\t\t    // Shades of gray\r\n\t\t\t    if (settings.shadesOfGray > 1 && settings.shadesOfGray < 256) {\r\n\t\t\t        shadesOfGrayFactor = 255 / (settings.shadesOfGray - 1);\r\n\t\t\t    }\r\n\t\t\t\r\n\t\t\t    // For each pixel\r\n\t\t\t    for (var i = 0, il = data.length; i < il; i += 4) {\r\n\t\t\t        // Apply filters\r\n\t\t\t        invertColor(data, i, settings.invertColor);\r\n\t\t\t        brightness(data, i, brightnessOffset);\r\n\t\t\t        contrast(data, i, contrastFactor);\r\n\t\t\t        gamma(data, i, gammaCorrection);\r\n\t\t\t        grayscale(data, i, settings.grayscale, shadesOfGrayFactor);\r\n\t\t\t    }\r\n\t\t\t\r\n\t\t\t    // Write new image data on the context\r\n\t\t\t    context.putImageData(imageData, 0, 0);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// Exports\r\n\t\t\texports.canvasFilters = canvasFilters;\r\n\t\t\texports.default = canvasFilters;\r\n\t\t\r\n\t\t/***/ }\r\n\t\t/******/ ])\r\n\t\t});\r\n\t\t;\r\n\t\t//# sourceMappingURL=lw.canvas-filters.js.map\r\n\t\r\n\t/***/ }\r\n\t/******/ ])\r\n\t});\r\n\t;\r\n\t//# sourceMappingURL=lw.canvas-grid.js.map\r\n\r\n/***/ }\r\n/******/ ])\r\n});\r\n;\r\n//# sourceMappingURL=lw.raster-to-gcode.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/lw.raster-to-gcode/dist/lw.raster-to-gcode.js\n// module id = 1\n// module chunks = 0"],"sourceRoot":""}