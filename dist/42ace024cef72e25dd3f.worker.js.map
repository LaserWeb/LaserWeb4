{"version":3,"sources":["webpack:///42ace024cef72e25dd3f.worker.js","webpack:///webpack/bootstrap 42ace024cef72e25dd3f","webpack:///./lib/workers/cam-preflight.js","webpack:///../~/poly2tri/src/xy.js","webpack:///../~/poly2tri/src/advancingfront.js","webpack:///../~/poly2tri/src/pointerror.js","webpack:///../~/poly2tri/src/triangle.js","webpack:///./lib/mesh.js","webpack:///../~/clipper-lib/clipper.js","webpack:///../~/eve/eve.js","webpack:///../~/poly2tri/src/assert.js","webpack:///../~/poly2tri/src/point.js","webpack:///../~/poly2tri/src/sweep.js","webpack:///../~/poly2tri/src/sweepcontext.js","webpack:///../~/poly2tri/src/utils.js","webpack:///../~/snapsvg-cjs/dist/snap.svg-cjs.js"],"names":["modules","hotCreateRequire","moduleId","ensure","chunkId","callback","hotStatus","hotSetStatus","hotChunksLoading","__webpack_require__","e","finishChunkLoading","hotWaitingFilesMap","hotEnsureUpdateChunk","hotWaitingFiles","hotUpdateDownloaded","call","fn","me","installedModules","request","hot","active","parents","indexOf","push","children","hotCurrentParents","console","warn","name","Object","prototype","hasOwnProperty","canDefineProperty","defineProperty","configurable","enumerable","get","set","value","hotCreateModule","_acceptedDependencies","_declinedDependencies","_selfAccepted","_selfDeclined","_disposeHandlers","accept","dep","i","length","decline","dispose","addDisposeHandler","removeDisposeHandler","idx","splice","check","hotCheck","apply","hotApply","status","l","hotStatusHandlers","addStatusHandler","removeStatusHandler","data","hotCurrentModuleData","newStatus","toModuleId","id","isNumber","Error","hotApplyOnUpdate","err","hotDownloadManifest","update","hotRequestedFilesMap","hotAvailibleFilesMap","c","hotUpdateNewHash","h","hotCallback","hotUpdate","hotDownloadUpdateChunk","outdatedModules","options","getAffectedStuff","module","outdatedDependencies","queue","slice","pop","parentId","parent","addAllToSet","a","b","item","appliedUpdate","result","ignoreUnaccepted","outdatedSelfAcceptedModules","errorHandler","disposeHandlers","j","cb","child","moduleOutdatedDependencies","dependency","hotCurrentHash","error","callbacks","exports","loaded","x","m","p","_mesh","self","onmessage","event","matchColor","filterColor","color","examineDocTree","isTab","doc","documents","find","d","rawPaths","jobs","tabGeometry","union","rawPathsToClipperPaths","scale","translate","op","filterFillColor","fillColor","filterStrokeColor","strokeColor","isClosed","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_iterator","Symbol","iterator","next","done","rawPath","return","clipperPaths","geometry","xor","openGeometry","concat","type","docsWithImages","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","_event$data","settings","opIndex","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_step3","_iterator3","_iteratorNormalCompletion4","_didIteratorError4","_iteratorError4","_step4","_iterator4","tabDocuments","chunk","percent","job","shift","postMessage","parseInt","message","level","toString","close","__REACT_HOT_LOADER__","toStringBase","y","s","compare","equals","Node","t","this","point","triangle","prev","AdvancingFront","head","tail","head_","tail_","search_node_","setHead","node","setTail","search","setSearch","findSearchNode","locateNode","locatePoint","px","nx","xy","PointError","points","constructor","Triangle","points_","neighbors_","interior_","constrained_edge","delaunay_edge","p2s","getPoint","index","GetPoint","getPoints","getNeighbor","containsPoint","containsEdge","edge","q","containsPoints","p1","p2","isInterior","setInterior","interior","markNeighborPointers","markNeighbor","clearNeighbors","clearDelaunayEdges","pointCW","pointCCW","neighborCW","neighborCCW","getConstrainedEdgeCW","getConstrainedEdgeCCW","getConstrainedEdgeAcross","setConstrainedEdgeCW","ce","setConstrainedEdgeCCW","getDelaunayEdgeCW","getDelaunayEdgeCCW","setDelaunayEdgeCW","setDelaunayEdgeCCW","neighborAcross","oppositePoint","cw","legalize","opoint","npoint","edgeIndex","markConstrainedEdgeByIndex","markConstrainedEdgeByEdge","markConstrainedEdgeByPoints","_interopRequireDefault","obj","__esModule","default","linearizeCubicBezier","p1x","p1y","c1x","c1y","c2x","c2y","p2x","p2y","minNumSegments","minSegmentLength","bez","p0","p3","numSegments","nextX","nextY","linearizeSnapPath","path","alertFn","subpath","elementToLinearSnapPaths","element","Snap","snapElement","attr","Number","w","map","transform","globalMatrix","parsePathString","snapPathToRawPaths","snapPath","pxPerInch","factor","currentPath","elementToRawPaths","flipY","allRawPaths","deltaY","hasClosedRawPaths","filterClosedRawPaths","scaleX","scaleY","translateX","translateY","X","mmToClipperScale","Y","_clipperLib2","Clipper","CleanPolygons","cleanPolyDist","SimplifyPolygons","PolyFillType","pftEvenOdd","clipperPathsToPolyTree","paths","AddPaths","PolyType","ptSubject","polyTree","PolyTree","Execute","ClipType","ctUnion","triangulatePolyTree","pointToVertex","contourToVertexes","nodesToVertexes","nodes","Contour","processNode","vertexes","holes","Childs","context","_sweepcontext2","addHoles","triangulate","triangles","getTriangles","_iteratorNormalCompletion5","_didIteratorError5","_iteratorError5","_step5","_iterator5","_iteratorNormalCompletion6","_didIteratorError6","_iteratorError6","_step6","_iterator6","hole","_iteratorNormalCompletion7","_didIteratorError7","_iteratorError7","_step7","_iterator7","_iteratorNormalCompletion8","_didIteratorError8","_iteratorError8","_step8","_iterator8","triangulateRawPaths","clipperPathsToCPaths","memoryBlocks","doubleSize","cPaths","Module","_malloc","cPathsBase","cPathSizes","cPathSizesBase","clipperPath","cPath","pathArray","Float64Array","HEAPU32","buffer","byteOffset","clipperToCppScale","cPathsToClipperPaths","cPathsRef","cNumPathsRef","cPathSizesRef","cNumPaths","pathSize","cPathsToCamPaths","convertedPaths","convertedPath","safeToClose","Z","clipperBounds","minX","MAX_VALUE","minY","maxX","maxY","_iteratorNormalCompletion9","_didIteratorError9","_iteratorError9","_step9","_iterator9","_iteratorNormalCompletion10","_didIteratorError10","_iteratorError10","_step10","_iterator10","pt","Math","min","max","clip","paths1","paths2","clipType","clipper","ptClip","diff","ctDifference","ctXor","offset","amount","joinType","endType","JoinType","jtRound","EndType","etClosedPolygon","jtSquare","jtMiter","co","ClipperOffset","arcTolerance","offsetted","inchToClipperScale","_clipperLib","_sweepcontext","register","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_RESULT__","BigInteger","ClipperLib","biginteger_used","fromInt","fromNumber","fromString","nbi","am1","n","v","floor","am2","xl","xh","am3","int2char","BI_RM","charAt","intAt","BI_RC","charCodeAt","bnpCopyTo","r","bnpFromInt","DV","nbv","bnpFromString","k","fromRadix","mi","sh","DB","clamp","ZERO","subTo","bnpClamp","DM","bnToString","negate","toRadix","km","bnNegate","bnAbs","bnCompareTo","nbits","bnBitLength","bnpDLShiftTo","bnpDRShiftTo","bnpLShiftTo","bs","cbs","bm","ds","bnpRShiftTo","bnpSubTo","bnpMultiplyTo","abs","am","bnpSquareTo","bnpDivRemTo","pm","copyTo","ts","ms","nsh","lShiftTo","ys","y0","yt","F1","F2","d1","FV","d2","dlShiftTo","compareTo","ONE","qd","drShiftTo","rShiftTo","bnMod","divRemTo","Classic","cConvert","mod","cRevert","cReduce","cMulTo","multiplyTo","reduce","cSqrTo","squareTo","bnpInvDigit","Montgomery","mp","invDigit","mpl","mph","um","mt2","montConvert","montRevert","montReduce","u0","montSqrTo","montMulTo","bnpIsEven","bnpExp","z","r2","g","convert","sqrTo","mulTo","revert","bnModPowInt","isEven","exp","bnClone","bnIntValue","bnByteValue","bnShortValue","bnpChunkSize","LN2","log","bnSigNum","bnpToRadix","signum","cs","chunkSize","pow","intValue","substr","bnpFromRadix","dMultiply","dAddOffset","bnpFromNumber","testBit","bitwiseTo","shiftLeft","op_or","isProbablePrime","bitLength","Array","nextBytes","bnToByteArray","bnEquals","bnMin","bnMax","bnpBitwiseTo","f","op_and","bnAnd","bnOr","op_xor","bnXor","op_andnot","bnAndNot","bnNot","bnShiftLeft","bnShiftRight","lbit","bnGetLowestSetBit","cbit","bnBitCount","bnTestBit","bnpChangeBit","bnSetBit","changeBit","bnClearBit","bnFlipBit","bnpAddTo","bnAdd","addTo","bnSubtract","bnMultiply","bnSquare","bnDivide","bnRemainder","bnDivideAndRemainder","bnpDMultiply","bnpDAddOffset","NullExp","nNop","nMulTo","nSqrTo","bnPow","bnpMultiplyLowerTo","bnpMultiplyUpperTo","Barrett","q3","mu","divide","barrettConvert","barrettRevert","barrettReduce","multiplyUpperTo","multiplyLowerTo","barrettSqrTo","barrettMulTo","bnModPow","k1","g2","is1","bnGCD","clone","getLowestSetBit","bnpModInt","bnModInverse","ac","u","subtract","add","bnIsProbablePrime","lowprimes","lplim","modInt","millerRabin","bnpMillerRabin","n1","shiftRight","random","modPow","modPowInt","use_int32","use_xyz","use_lines","isNode","window","navigator_appName","nav","navigator","userAgent","toLowerCase","appName","browser","chrome","chromium","safari","firefox","firefox17","firefox15","firefox3","opera","msie10","msie9","msie8","msie7","msie","dbits","canary","j_lm","BI_FP","rr","vv","byteValue","shortValue","toByteArray","and","or","andNot","not","bitCount","setBit","clearBit","flipBit","multiply","remainder","divideAndRemainder","modInverse","gcd","square","Int128","IsNegative","op_Equality","val1","val2","op_Inequality","op_GreaterThan","op_LessThan","op_Addition","lhs","rhs","op_Subtraction","Int128Mul","op_Division","ToDouble","parseFloat","Inherit","ce2","$baseCtor","props","getOwnPropertyNames","getOwnPropertyDescriptor","Path","Paths","DoublePoint","arguments","DoublePoint0","DoublePoint1","dp","DoublePoint2","PolyNode","m_Parent","m_polygon","m_Index","m_jointype","m_endtype","m_Childs","IsOpen","IsHoleNode","ChildCount","AddChild","Child","cnt","GetNext","GetNextSiblingUp","Parent","IsHole","m_AllPolys","Clear","ilen","GetFirst","Total","Math_Abs_Int64","Math_Abs_Int32","Math_Abs_Double","Math_Max_Int32_Int32","Cast_Int32","Cast_Int64","ceil","toInteger","PI","PI2","IntPoint","alen","Round","IntPoint0","IntPoint1","IntPoint1dp","IntPoint2","IntPoint3","IntRect","left","top","right","bottom","ir","IntRect0","IntRect1","IntRect4","ctIntersection","pftNonZero","pftPositive","pftNegative","etOpenSquare","etOpenRound","etOpenButt","etClosedLine","EdgeSide","esLeft","esRight","Direction","dRightToLeft","dLeftToRight","TEdge","Bot","Curr","Top","Delta","Dx","PolyTyp","Side","WindDelta","WindCnt","WindCnt2","OutIdx","Next","Prev","NextInLML","NextInAEL","PrevInAEL","NextInSEL","PrevInSEL","IntersectNode","Edge1","Edge2","Pt","MyIntersectNodeSort","Compare","node1","node2","LocalMinima","LeftBound","RightBound","Scanbeam","OutRec","Idx","FirstLeft","Pts","BottomPt","OutPt","Join","OutPt1","OutPt2","OffPt","ClipperBase","m_MinimaList","m_CurrentLM","m_edges","m_UseFullRange","m_HasOpenPaths","PreserveCollinear","horizontal","Skip","Unassigned","tolerance","loRange","hiRange","near_zero","val","IsHorizontal","PointIsVertex","pp","pp2","PointOnLineSegment","linePt1","linePt2","UseFullRange","PointOnPolygon","SlopesEqual","e1","e2","pt1","pt2","pt3","pt4","SlopesEqual3","SlopesEqual4","SlopesEqual5","DisposeLocalMinimaList","jlen","tmpLm","RangeTest","useFullRange","Value","InitEdge","eNext","ePrev","InitEdge2","polyType","SetDx","FindNextLocMin","E","E2","ProcessBound","LeftBoundIsForward","EStart","Horz","Result","locMin","InsertLocalMinima","ReverseHorizontal","AddPath","pg","Closed","highI","edges","IsFlat","$1","eStart","eLoopStop","Pt2IsBetweenPt1AndPt3","RemoveEdge","leftBoundIsForward","EMin","ppg","closed","newLm","PopLocalMinima","tmp","Reset","lm","InitOptions","m_PolyOuts","m_ClipType","m_Scanbeam","m_ActiveEdges","m_SortedEdges","m_IntersectList","m_IntersectNodeComparer","m_ExecuteLocked","m_ClipFillType","m_SubjFillType","m_Joins","m_GhostJoins","m_UsingPolyTree","ReverseSolution","StrictlySimple","ZFillFunction","ioReverseSolution","ioStrictlySimple","ioPreserveCollinear","DisposeAllPolyPts","DisposeScanbeamList","sb2","InsertScanbeam","newSb","ispolytree","solution","subjFillType","clipFillType","succeeded","ExecuteInternal","BuildResult","polytree","BuildResult2","FixHoleLinkage","outRec","orfl","botY","PopScanbeam","InsertLocalMinimaIntoAEL","ProcessHorizontals","topY","ProcessIntersections","ProcessEdgesAtTopOfScanbeam","Area","ReversePolyPtLinks","JoinCommonEdges","FixupOutPolygon","DoSimplePolygons","DisposeOutRec","AddJoin","Op1","Op2","AddGhostJoin","Op","SetZ","lb","rb","InsertEdgeIntoAEL","SetWindingCount","IsContributing","AddOutPt","AddLocalMinPoly","AddEdgeToSEL","HorzSegmentsOverlap","IntersectEdges","startEdge","E2InsertsBeforeE1","TopX","IsEvenOddFillType","IsEvenOddAltFillType","pft","pft2","Inside","CopyAELToSEL","SwapPositionsInAEL","edge1","edge2","SwapPositionsInSEL","AddLocalMaxPoly","AppendPolygon","prevE","outPt","CreateOutRec","ToFront","newOp","SetHoleState","SwapPoints","seg1a","seg1b","seg2a","seg2b","isHole","GetDx","FirstIsBottomPt","btmPt1","btmPt2","dx1p","dx1n","dx2p","dx2n","GetBottomPt","dups","GetLowermostRec","outRec1","outRec2","bPt1","bPt2","Param1RightOfParam2","GetOutRec","outrec","holeStateRec","side","p1_lft","p1_rt","p2_lft","p2_rt","OKIdx","ObsoleteIdx","pp1","SwapSides","SwapPolyIndexes","outIdx","e1Contributing","e2Contributing","oldE1WindCnt","e1FillType","e2FillType","e1FillType2","e2FillType2","e1Wc","e2Wc","e1Wc2","e2Wc2","DeleteFromAEL","AelPrev","AelNext","DeleteFromSEL","SelPrev","SelNext","UpdateEdgeIntoAEL","isTopOfScanbeam","horzEdge","ProcessHorizontal","GetHorzDirection","HorzEdge","$var","Left","Right","Dir","dir","horzLeft","horzRight","eLastHorz","eMaxPair","GetMaximaPair","IsLastHorz","GetNextInAEL","op1","eNextHorz","op2","IsMinima","IsMaxima","IsIntermediate","BuildIntersectList","FixupIntersectionOrder","ProcessIntersectList","$$e2","isModified","IntersectPoint","newNode","EdgesAdjacent","inode","IntersectNodeSort","sort","iNode","R1","round","R2","R3","R4","currentY","ip","b1","b2","IsMaximaEdge","DoMaxima","ReversePaths","polys","len","reverse","Orientation","poly","PointCount","pts","polyg","pn","lastOK","DupOutPt","InsertAfter","GetOverlap","a1","a2","$val","JoinHorz","op1b","op2b","DiscardLeft","Dir1","Dir2","JoinPoints","isHorizontal","reverse1","reverse2","DiscardLeftSide","Reverse1","Reverse2","GetBounds","GetBounds2","ops","opStart","PointInPolygon","ipNext","startOp","ptx","pty","poly0x","poly0y","poly1x","poly1y","Poly2ContainsPoly1","outPt1","outPt2","res","FixupFirstLefts1","OldOutRec","NewOutRec","firstLeft","ParseFirstLeft","FixupFirstLefts2","$i2","$t2","$l2","join","UpdateOutPtIdxs","oRec","op3","op4","outrec2","SimplifyPolygon","fillType","DistanceSqrd","dx","dy","DistanceFromLineSqrd","ln1","ln2","A","B","C","SlopesNearCollinear","distSqrd","PointsAreClose","ExcludeOp","CleanPolygon","distance","outPts","Minkowski","pattern","IsSum","IsClosed","delta","polyCnt","pathCnt","quads","quad","MinkowskiSum","path_or_paths","pathIsClosed","TranslatePath","outPath","MinkowskiDiff","poly1","poly2","PolyTreeToPaths","AddPolyNodeToPaths","NodeType","ntAny","polynode","nt","match","ntOpen","ntClosed","$i3","$t3","$l3","OpenPathsFromPolyTree","ClosedPathsFromPolyTree","miterLimit","def_arc_tolerance","m_destPolys","m_srcPoly","m_destPoly","m_normals","m_delta","m_sinA","m_sin","m_cos","m_miterLim","m_StepsPerRad","m_lowest","m_polyNodes","MiterLimit","ArcTolerance","two_pi","FixOrientations","GetUnitNormal","sqrt","DoOffset","steps","acos","sin","cos","OffsetPoint","DoSquare","DoRound","X2","clpr","outer","outerNode","jointype","cosA","DoMiter","tan","atan2","alert","JS","AreaOfPolygon","AreaOfPolygons","area","BoundsOfPath","BoundsOfPaths","bounds","Clean","polygon","isPolygons","Clone","k_length","results","plen","Lighten","P","rem","addlast","bxax","byay","ax","ay","toleranceSq","PerimeterOfPath","perimeter","PerimeterOfPaths","ScaleDownPath","ScaleDownPaths","ScaleUpPath","ScaleUpPaths","ExPolygons","ExPolygon","AddOuterPolyNodeToExPolygons","expolygons","ep","childs","childs2","ExPolygonsToPaths","PolyTreeToExPolygons","__WEBPACK_AMD_DEFINE_ARRAY__","glob","current_event","stop","version","has","separator","comaseparator","wildcard","numsort","events","firstDefined","ii","lastDefined","eve","scope","String","oldstop","args","listeners","indexed","out","zIndex","_events","items","jj","nes","names","split","es","on","exist","attrs","subname","RegExp","test","nts","off","unbind","key","cur","funcs","once","f2","assert","condition","Point","_p2t_edge_list","toJSON","set_zero","sub","mul","normalize","cross","cmp","dot","tcx","initTriangulation","createAdvancingFront","sweepPoints","finalizationPolygon","pointCount","pointEvent","edgeEventByEdge","front","meshClean","new_node","newFrontTriangle","fill","fillAdvancingFront","edge_event","isEdgeSideOfTriangle","fillEdgeEvent","edgeEventByPoints","eq","o1","orient2d","COLLINEAR","o2","CW","flipEdgeEvent","addToMap","mapTriangleToNodes","isAngleObtuse","isBasinAngleRight","fillBasin","ot","oi","inside","inCircle","rotateTrianglePair","not_legalized","pa","pb","pc","pd","adx","ady","bdx","bdy","adxbdy","bdxady","oabd","cdx","cdy","cdxady","adxcdy","ocad","bdxcdy","cdxbdy","alift","blift","clift","det","n2","n3","n4","ce1","ce3","ce4","de1","de2","de3","de4","CCW","basin","left_node","bottom_node","right_node","width","left_highest","fillBasinReq","isShallow","o","height","fillRightAboveEdgeEvent","fillLeftAboveEdgeEvent","fillRightBelowEdgeEvent","fillRightConcaveEdgeEvent","fillRightConvexEdgeEvent","fillLeftBelowEdgeEvent","fillLeftConcaveEdgeEvent","fillLeftConvexEdgeEvent","inScanArea","nextFlipTriangle","newP","nextFlipPoint","flipScanEdgeEvent","edge_index","o2d","flip_triangle","utils","EPSILON","sweep","kAlpha","Edge","Basin","clear","EdgeEvent","SweepContext","contour","triangles_","map_","cloneArrays","edge_list","pmin_","pmax_","front_","af_head_","af_middle_","af_tail_","initEdges","addHole","polyline","AddHole","addPoint","AddPoint","addPoints","getBoundingBox","GetTriangles","getMap","xmax","xmin","ymax","ymin","middle","removeNode","removeFromMap","detleft","detright","oadb","oadc","bx","by","mina","animations","requestAnimFrame","requestAnimationFrame","webkitRequestAnimationFrame","mozRequestAnimationFrame","oRequestAnimationFrame","msRequestAnimationFrame","setTimeout","isArray","idgen","idprefix","Date","ID","timer","now","sta","dur","speed","spd","duration","stopit","pause","pdif","resume","start","end","easing","frame","anim","linear","time","getById","easeout","easein","easeinout","Q","backin","backout","elastic","bounce","root","nodeType","wrap","is","Element","querySelector","Paper","$","el","createTextNode","text","createComment","substring","getAttributeNS","xlink","xmlns","getAttribute","nodeValue","Str","setAttributeNS","setAttribute","removeAttribute","createElementNS","isFinite","objectToString","repush","array","cacher","postprocessor","newf","arg","cache","count","angle","x1","y1","x2","y2","x3","y3","math","rad","deg","svgTransform2string","tstr","replace","all","params","transform2matrix","bbox","tdata","parseTransformString","Matrix","bb","tlen","command","absolute","inver","invert","rotate","getSomeDefs","ownerSVGElement","parentNode","select","pdefs","defs","make","getSomeSVG","unit2px","getW","mgr","getBBox","getH","nam","svg","class","appendChild","removeChild","add2group","list","forEach","childNodes","snap","hub","paper","tagName","nodeName","anims","_","mask","symbol","method","Fragment","frag","desc","proto","ownerDocument","getElementsByTagName","body","dom","contentDocument","jsonFiller","win","document","toFloat","toInt","mmax","mmin","colourRegExp","commaSpaces","hsrg","hs","rg","pathCommand","tCommand","pathValues","url","format","tokenRegex","objNotationRegex","replacer","quote","quotedName","isFunc","str","asin","num","atan","len2","closestPoint","distance2","best","bestLength","scan","scanDistance","pathNode","pathLength","getTotalLength","precision","pathSegList","numberOfItems","bestDistance","Infinity","scanLength","getPointAtLength","before","after","beforeLength","afterLength","beforeDistance","afterDistance","snapTo","values","getRGB","colour","hex","rgbtoString","toHex","red","green","blue","opacity","rgb","hsb2rgb","hsl2rgb","hsb","hsl","toFixed","style","defaultView","getComputedStyle","getPropertyValue","hsbtoString","hsltoString","prepareRGB","string","clr","packageRGB","rgb2hsl","rgb2hsb","R","G","H","S","V","L","M","pathString","pth","arr","paramCounts","TString","rgTransform","_unit2px","contains","compareDocumentPosition","adown","documentElement","bup","query","selectAll","nodelist","querySelectorAll","setInterval","attributes","json","att","parse","createDocumentFragment","full","div","createElement","innerHTML","firstChild","fragment","ch","lastIndexOf","css","letter","cssAttr","alignment-baseline","baseline-shift","clip-path","clip-rule","color-interpolation","color-interpolation-filters","color-profile","color-rendering","cursor","direction","display","dominant-baseline","enable-background","fill-opacity","fill-rule","filter","flood-color","flood-opacity","font","font-family","font-size","font-size-adjust","font-stretch","font-style","font-variant","font-weight","glyph-orientation-horizontal","glyph-orientation-vertical","image-rendering","kerning","letter-spacing","lighting-color","marker","marker-end","marker-mid","marker-start","overflow","pointer-events","shape-rendering","stop-color","stop-opacity","stroke","stroke-dasharray","stroke-dashoffset","stroke-linecap","stroke-linejoin","stroke-miterlimit","stroke-opacity","stroke-width","text-anchor","text-decoration","text-rendering","unicode-bidi","visibility","word-spacing","writing-mode","toUpperCase","ajax","postData","req","XMLHttpRequest","encodeURIComponent","open","setRequestHeader","onreadystatechange","readyState","send","load","responseText","getOffset","elem","box","getBoundingClientRect","docElem","clientTop","clientLeft","pageYOffset","scrollTop","pageXOffset","scrollLeft","getElementByPoint","target","canvas","elementFromPoint","so","sr","createSVGRect","hits","getIntersectionList","plugin","extractTransform","doReturn","matrix","fixids","urltest","it","uses","URL","linktest","els","ids","oldid","old","fs","from","to","chld","elproto","isWithoutTransform","removed","localMatrix","original","href","getElementById","pathfinder","deflt","bboxwt","realPath","propString","papa","global","getCTM","local","localString","toTransformString","totalMatrix","diffMatrix","total","gradientTransform","patternTransform","append","appendTo","prepend","first","insertBefore","prependTo","nextSibling","insertAfter","remove","asPX","use","xlink:href","cloneNode","toDefs","toPattern","patternUnits","viewBox","refX","refY","cx","cy","markerWidth","markerHeight","orient","Animation","animation","inAnim","_attrs","_callback","curStatus","animate","setter","fkeys","tkeys","keys","equal","eldata","removeData","outerSVG","innerSVG","toDataURL","btoa","contents","unescape","matrixproto","norm","mag","fromCharCode","determinant","row","scalex","shear","scaley","isSimple","isSuperSimple","noRotation","shorter","fillStroke","grad","gradient","setFontSize","fontSize","textExtract","chi","getFontSize","reURLValue","clipIt","gradrg","tokens","stops","toAbsolute","txt","className","baseVal","vb","rx","ry","tp","textPath","tuner","tuned","getter","textContent","rgNotSpace","addClass","pos","clazz","finalValue","classes","curClasses","removeClass","hasClass","toggleClass","flag","getNumber","getUnit","unit","operators","+","-","/","*","reUnit","reAddon","plus","evnt","atr","aUnit","isNaN","bplus","rect","circle","preload","onerror","src","img","cssText","onload","image","preserveAspectRatio","offsetWidth","offsetHeight","ellipse","group","vbx","vby","vbw","vbh","ptrn","vx","vy","vw","vh","line","Gstops","GaddStop","GgetBBox","seed","step","unshift","gradientLinear","gradientRadial","gradientUnits","addStop","fx","fy","ps","sleep","r1","r0","rectPath","pathClone","getPointAtSegmentLength","bezlen","findDotsAtSegment","getTotLen","getLengthFactory","istotal","O","onlystart","path2curve","sp","subpaths","t1","t13","t12","t2","t3","mx","my","ny","alpha","bezierBBox","curveDim","isPointInsideBBox","isBBoxIntersect","bbox1","bbox2","base3","p4","x4","y4","z2","Tvalues","Cvalues","sum","ct","xbase","ybase","comb","ll","intersect","denominator","py","px2","py2","interHelper","bez1","bez2","justCount","l1","l2","dots1","dots2","di","di1","dj","dj1","ci","cj","pathIntersection","path1","path2","interPathHelper","pathIntersectionNumber","x1m","y1m","x2m","y2m","pi","pj","intr","kk","segment1","segment2","isPointInsidePath","pathBBox","dim","ellipsePath","pathToRelative","lowerCase","rel","pathToAbsolute","pa0","crz","dots","catmullRom2bezier","l2c","q2c","_13","_23","a2c","large_arc_flag","sweep_flag","recursive","_120","f1","rx2","ry2","df","f2old","x2old","y2old","c1","s1","c2","s2","hx","hy","m1","m2","m3","m4","newres","x0","b2ac","sqrtb2ac","tvalues","mt","curve","qx","qy","attrs2","processPath","pcom","T","fixArc","pcoms1","pcoms2","fixM","pfirst","seg","seg2","seglen","seg2len","mapPath","pathi","crp","iLen","getSubpathsAtLength","getPath","getSubpath","closest","found","intersection","intersectionNumber","isPointInside","toRelative","toCubic","Set","bindings","setproto","thisArg","each","begin","handler","callbacker","bind","aname","unbound","insertion","todel","arglen","exclude","getEmpty","equaliseTransform","tt1","tt2","maxlength","path2array","getViewBox","getColour","Function","isNumeric","arrayEqual","arr1","arr2","bUnit","supportsTouch","touchMap","mousedown","mousemove","mouseup","getScroll","preventTouch","originalEvent","preventDefault","stopTouch","stopPropagation","addEvent","realName","scrollY","scrollX","targetTouches","olde","clientX","clientY","addEventListener","removeEventListener","drag","dragMove","dragi","touch","touches","identifier","_drag","move_scope","dragUp","unmousemove","unmouseup","end_scope","start_scope","eventName","hover","f_in","f_out","scope_in","scope_out","mouseover","mouseout","unhover","unmouseover","unmouseout","draggable","onmove","onstart","onend","init","origTransform","undrag","unmousedown","pproto","rgurl","filstr","filterUnits","blur","def","shadow","grayscale","sepia","saturate","hueRotate","amount2","brightness","contrast","firstLetter","getAlign","way","align"],"mappings":"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","file":"42ace024cef72e25dd3f.worker.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// Copied from https://github.com/facebook/react/blob/bef45b0/src/shared/utils/canDefineProperty.js\r\n/******/ \tvar canDefineProperty = false;\r\n/******/ \ttry {\r\n/******/ \t\tObject.defineProperty({}, \"x\", {\r\n/******/ \t\t\tget: function() {}\r\n/******/ \t\t});\r\n/******/ \t\tcanDefineProperty = true;\r\n/******/ \t} catch(x) {\r\n/******/ \t\t// IE will fail on defineProperty\r\n/******/ \t}\r\n/******/ \t\r\n/******/ \tvar hotApplyOnUpdate = true;\r\n/******/ \tvar hotCurrentHash = \"42ace024cef72e25dd3f\"; // eslint-disable-line no-unused-vars\r\n/******/ \tvar hotCurrentModuleData = {};\r\n/******/ \tvar hotCurrentParents = []; // eslint-disable-line no-unused-vars\r\n/******/ \t\r\n/******/ \tfunction hotCreateRequire(moduleId) { // eslint-disable-line no-unused-vars\r\n/******/ \t\tvar me = installedModules[moduleId];\r\n/******/ \t\tif(!me) return __webpack_require__;\r\n/******/ \t\tvar fn = function(request) {\r\n/******/ \t\t\tif(me.hot.active) {\r\n/******/ \t\t\t\tif(installedModules[request]) {\r\n/******/ \t\t\t\t\tif(installedModules[request].parents.indexOf(moduleId) < 0)\r\n/******/ \t\t\t\t\t\tinstalledModules[request].parents.push(moduleId);\r\n/******/ \t\t\t\t\tif(me.children.indexOf(request) < 0)\r\n/******/ \t\t\t\t\t\tme.children.push(request);\r\n/******/ \t\t\t\t} else hotCurrentParents = [moduleId];\r\n/******/ \t\t\t} else {\r\n/******/ \t\t\t\tconsole.warn(\"[HMR] unexpected require(\" + request + \") from disposed module \" + moduleId);\r\n/******/ \t\t\t\thotCurrentParents = [];\r\n/******/ \t\t\t}\r\n/******/ \t\t\treturn __webpack_require__(request);\r\n/******/ \t\t};\r\n/******/ \t\tfor(var name in __webpack_require__) {\r\n/******/ \t\t\tif(Object.prototype.hasOwnProperty.call(__webpack_require__, name)) {\r\n/******/ \t\t\t\tif(canDefineProperty) {\r\n/******/ \t\t\t\t\tObject.defineProperty(fn, name, (function(name) {\r\n/******/ \t\t\t\t\t\treturn {\r\n/******/ \t\t\t\t\t\t\tconfigurable: true,\r\n/******/ \t\t\t\t\t\t\tenumerable: true,\r\n/******/ \t\t\t\t\t\t\tget: function() {\r\n/******/ \t\t\t\t\t\t\t\treturn __webpack_require__[name];\r\n/******/ \t\t\t\t\t\t\t},\r\n/******/ \t\t\t\t\t\t\tset: function(value) {\r\n/******/ \t\t\t\t\t\t\t\t__webpack_require__[name] = value;\r\n/******/ \t\t\t\t\t\t\t}\r\n/******/ \t\t\t\t\t\t};\r\n/******/ \t\t\t\t\t}(name)));\r\n/******/ \t\t\t\t} else {\r\n/******/ \t\t\t\t\tfn[name] = __webpack_require__[name];\r\n/******/ \t\t\t\t}\r\n/******/ \t\t\t}\r\n/******/ \t\t}\r\n/******/ \t\r\n/******/ \t\tfunction ensure(chunkId, callback) {\r\n/******/ \t\t\tif(hotStatus === \"ready\")\r\n/******/ \t\t\t\thotSetStatus(\"prepare\");\r\n/******/ \t\t\thotChunksLoading++;\r\n/******/ \t\t\t__webpack_require__.e(chunkId, function() {\r\n/******/ \t\t\t\ttry {\r\n/******/ \t\t\t\t\tcallback.call(null, fn);\r\n/******/ \t\t\t\t} finally {\r\n/******/ \t\t\t\t\tfinishChunkLoading();\r\n/******/ \t\t\t\t}\r\n/******/ \t\r\n/******/ \t\t\t\tfunction finishChunkLoading() {\r\n/******/ \t\t\t\t\thotChunksLoading--;\r\n/******/ \t\t\t\t\tif(hotStatus === \"prepare\") {\r\n/******/ \t\t\t\t\t\tif(!hotWaitingFilesMap[chunkId]) {\r\n/******/ \t\t\t\t\t\t\thotEnsureUpdateChunk(chunkId);\r\n/******/ \t\t\t\t\t\t}\r\n/******/ \t\t\t\t\t\tif(hotChunksLoading === 0 && hotWaitingFiles === 0) {\r\n/******/ \t\t\t\t\t\t\thotUpdateDownloaded();\r\n/******/ \t\t\t\t\t\t}\r\n/******/ \t\t\t\t\t}\r\n/******/ \t\t\t\t}\r\n/******/ \t\t\t});\r\n/******/ \t\t}\r\n/******/ \t\tif(canDefineProperty) {\r\n/******/ \t\t\tObject.defineProperty(fn, \"e\", {\r\n/******/ \t\t\t\tenumerable: true,\r\n/******/ \t\t\t\tvalue: ensure\r\n/******/ \t\t\t});\r\n/******/ \t\t} else {\r\n/******/ \t\t\tfn.e = ensure;\r\n/******/ \t\t}\r\n/******/ \t\treturn fn;\r\n/******/ \t}\r\n/******/ \t\r\n/******/ \tfunction hotCreateModule(moduleId) { // eslint-disable-line no-unused-vars\r\n/******/ \t\tvar hot = {\r\n/******/ \t\t\t// private stuff\r\n/******/ \t\t\t_acceptedDependencies: {},\r\n/******/ \t\t\t_declinedDependencies: {},\r\n/******/ \t\t\t_selfAccepted: false,\r\n/******/ \t\t\t_selfDeclined: false,\r\n/******/ \t\t\t_disposeHandlers: [],\r\n/******/ \t\r\n/******/ \t\t\t// Module API\r\n/******/ \t\t\tactive: true,\r\n/******/ \t\t\taccept: function(dep, callback) {\r\n/******/ \t\t\t\tif(typeof dep === \"undefined\")\r\n/******/ \t\t\t\t\thot._selfAccepted = true;\r\n/******/ \t\t\t\telse if(typeof dep === \"function\")\r\n/******/ \t\t\t\t\thot._selfAccepted = dep;\r\n/******/ \t\t\t\telse if(typeof dep === \"object\")\r\n/******/ \t\t\t\t\tfor(var i = 0; i < dep.length; i++)\r\n/******/ \t\t\t\t\t\thot._acceptedDependencies[dep[i]] = callback;\r\n/******/ \t\t\t\telse\r\n/******/ \t\t\t\t\thot._acceptedDependencies[dep] = callback;\r\n/******/ \t\t\t},\r\n/******/ \t\t\tdecline: function(dep) {\r\n/******/ \t\t\t\tif(typeof dep === \"undefined\")\r\n/******/ \t\t\t\t\thot._selfDeclined = true;\r\n/******/ \t\t\t\telse if(typeof dep === \"number\")\r\n/******/ \t\t\t\t\thot._declinedDependencies[dep] = true;\r\n/******/ \t\t\t\telse\r\n/******/ \t\t\t\t\tfor(var i = 0; i < dep.length; i++)\r\n/******/ \t\t\t\t\t\thot._declinedDependencies[dep[i]] = true;\r\n/******/ \t\t\t},\r\n/******/ \t\t\tdispose: function(callback) {\r\n/******/ \t\t\t\thot._disposeHandlers.push(callback);\r\n/******/ \t\t\t},\r\n/******/ \t\t\taddDisposeHandler: function(callback) {\r\n/******/ \t\t\t\thot._disposeHandlers.push(callback);\r\n/******/ \t\t\t},\r\n/******/ \t\t\tremoveDisposeHandler: function(callback) {\r\n/******/ \t\t\t\tvar idx = hot._disposeHandlers.indexOf(callback);\r\n/******/ \t\t\t\tif(idx >= 0) hot._disposeHandlers.splice(idx, 1);\r\n/******/ \t\t\t},\r\n/******/ \t\r\n/******/ \t\t\t// Management API\r\n/******/ \t\t\tcheck: hotCheck,\r\n/******/ \t\t\tapply: hotApply,\r\n/******/ \t\t\tstatus: function(l) {\r\n/******/ \t\t\t\tif(!l) return hotStatus;\r\n/******/ \t\t\t\thotStatusHandlers.push(l);\r\n/******/ \t\t\t},\r\n/******/ \t\t\taddStatusHandler: function(l) {\r\n/******/ \t\t\t\thotStatusHandlers.push(l);\r\n/******/ \t\t\t},\r\n/******/ \t\t\tremoveStatusHandler: function(l) {\r\n/******/ \t\t\t\tvar idx = hotStatusHandlers.indexOf(l);\r\n/******/ \t\t\t\tif(idx >= 0) hotStatusHandlers.splice(idx, 1);\r\n/******/ \t\t\t},\r\n/******/ \t\r\n/******/ \t\t\t//inherit from previous dispose call\r\n/******/ \t\t\tdata: hotCurrentModuleData[moduleId]\r\n/******/ \t\t};\r\n/******/ \t\treturn hot;\r\n/******/ \t}\r\n/******/ \t\r\n/******/ \tvar hotStatusHandlers = [];\r\n/******/ \tvar hotStatus = \"idle\";\r\n/******/ \t\r\n/******/ \tfunction hotSetStatus(newStatus) {\r\n/******/ \t\thotStatus = newStatus;\r\n/******/ \t\tfor(var i = 0; i < hotStatusHandlers.length; i++)\r\n/******/ \t\t\thotStatusHandlers[i].call(null, newStatus);\r\n/******/ \t}\r\n/******/ \t\r\n/******/ \t// while downloading\r\n/******/ \tvar hotWaitingFiles = 0;\r\n/******/ \tvar hotChunksLoading = 0;\r\n/******/ \tvar hotWaitingFilesMap = {};\r\n/******/ \tvar hotRequestedFilesMap = {};\r\n/******/ \tvar hotAvailibleFilesMap = {};\r\n/******/ \tvar hotCallback;\r\n/******/ \t\r\n/******/ \t// The update info\r\n/******/ \tvar hotUpdate, hotUpdateNewHash;\r\n/******/ \t\r\n/******/ \tfunction toModuleId(id) {\r\n/******/ \t\tvar isNumber = (+id) + \"\" === id;\r\n/******/ \t\treturn isNumber ? +id : id;\r\n/******/ \t}\r\n/******/ \t\r\n/******/ \tfunction hotCheck(apply, callback) {\r\n/******/ \t\tif(hotStatus !== \"idle\") throw new Error(\"check() is only allowed in idle status\");\r\n/******/ \t\tif(typeof apply === \"function\") {\r\n/******/ \t\t\thotApplyOnUpdate = false;\r\n/******/ \t\t\tcallback = apply;\r\n/******/ \t\t} else {\r\n/******/ \t\t\thotApplyOnUpdate = apply;\r\n/******/ \t\t\tcallback = callback || function(err) {\r\n/******/ \t\t\t\tif(err) throw err;\r\n/******/ \t\t\t};\r\n/******/ \t\t}\r\n/******/ \t\thotSetStatus(\"check\");\r\n/******/ \t\thotDownloadManifest(function(err, update) {\r\n/******/ \t\t\tif(err) return callback(err);\r\n/******/ \t\t\tif(!update) {\r\n/******/ \t\t\t\thotSetStatus(\"idle\");\r\n/******/ \t\t\t\tcallback(null, null);\r\n/******/ \t\t\t\treturn;\r\n/******/ \t\t\t}\r\n/******/ \t\r\n/******/ \t\t\thotRequestedFilesMap = {};\r\n/******/ \t\t\thotAvailibleFilesMap = {};\r\n/******/ \t\t\thotWaitingFilesMap = {};\r\n/******/ \t\t\tfor(var i = 0; i < update.c.length; i++)\r\n/******/ \t\t\t\thotAvailibleFilesMap[update.c[i]] = true;\r\n/******/ \t\t\thotUpdateNewHash = update.h;\r\n/******/ \t\r\n/******/ \t\t\thotSetStatus(\"prepare\");\r\n/******/ \t\t\thotCallback = callback;\r\n/******/ \t\t\thotUpdate = {};\r\n/******/ \t\t\tvar chunkId = 0;\r\n/******/ \t\t\t{ // eslint-disable-line no-lone-blocks\r\n/******/ \t\t\t\t/*globals chunkId */\r\n/******/ \t\t\t\thotEnsureUpdateChunk(chunkId);\r\n/******/ \t\t\t}\r\n/******/ \t\t\tif(hotStatus === \"prepare\" && hotChunksLoading === 0 && hotWaitingFiles === 0) {\r\n/******/ \t\t\t\thotUpdateDownloaded();\r\n/******/ \t\t\t}\r\n/******/ \t\t});\r\n/******/ \t}\r\n/******/ \t\r\n/******/ \tfunction hotAddUpdateChunk(chunkId, moreModules) { // eslint-disable-line no-unused-vars\r\n/******/ \t\tif(!hotAvailibleFilesMap[chunkId] || !hotRequestedFilesMap[chunkId])\r\n/******/ \t\t\treturn;\r\n/******/ \t\thotRequestedFilesMap[chunkId] = false;\r\n/******/ \t\tfor(var moduleId in moreModules) {\r\n/******/ \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\r\n/******/ \t\t\t\thotUpdate[moduleId] = moreModules[moduleId];\r\n/******/ \t\t\t}\r\n/******/ \t\t}\r\n/******/ \t\tif(--hotWaitingFiles === 0 && hotChunksLoading === 0) {\r\n/******/ \t\t\thotUpdateDownloaded();\r\n/******/ \t\t}\r\n/******/ \t}\r\n/******/ \t\r\n/******/ \tfunction hotEnsureUpdateChunk(chunkId) {\r\n/******/ \t\tif(!hotAvailibleFilesMap[chunkId]) {\r\n/******/ \t\t\thotWaitingFilesMap[chunkId] = true;\r\n/******/ \t\t} else {\r\n/******/ \t\t\thotRequestedFilesMap[chunkId] = true;\r\n/******/ \t\t\thotWaitingFiles++;\r\n/******/ \t\t\thotDownloadUpdateChunk(chunkId);\r\n/******/ \t\t}\r\n/******/ \t}\r\n/******/ \t\r\n/******/ \tfunction hotUpdateDownloaded() {\r\n/******/ \t\thotSetStatus(\"ready\");\r\n/******/ \t\tvar callback = hotCallback;\r\n/******/ \t\thotCallback = null;\r\n/******/ \t\tif(!callback) return;\r\n/******/ \t\tif(hotApplyOnUpdate) {\r\n/******/ \t\t\thotApply(hotApplyOnUpdate, callback);\r\n/******/ \t\t} else {\r\n/******/ \t\t\tvar outdatedModules = [];\r\n/******/ \t\t\tfor(var id in hotUpdate) {\r\n/******/ \t\t\t\tif(Object.prototype.hasOwnProperty.call(hotUpdate, id)) {\r\n/******/ \t\t\t\t\toutdatedModules.push(toModuleId(id));\r\n/******/ \t\t\t\t}\r\n/******/ \t\t\t}\r\n/******/ \t\t\tcallback(null, outdatedModules);\r\n/******/ \t\t}\r\n/******/ \t}\r\n/******/ \t\r\n/******/ \tfunction hotApply(options, callback) {\r\n/******/ \t\tif(hotStatus !== \"ready\") throw new Error(\"apply() is only allowed in ready status\");\r\n/******/ \t\tif(typeof options === \"function\") {\r\n/******/ \t\t\tcallback = options;\r\n/******/ \t\t\toptions = {};\r\n/******/ \t\t} else if(options && typeof options === \"object\") {\r\n/******/ \t\t\tcallback = callback || function(err) {\r\n/******/ \t\t\t\tif(err) throw err;\r\n/******/ \t\t\t};\r\n/******/ \t\t} else {\r\n/******/ \t\t\toptions = {};\r\n/******/ \t\t\tcallback = callback || function(err) {\r\n/******/ \t\t\t\tif(err) throw err;\r\n/******/ \t\t\t};\r\n/******/ \t\t}\r\n/******/ \t\r\n/******/ \t\tfunction getAffectedStuff(module) {\r\n/******/ \t\t\tvar outdatedModules = [module];\r\n/******/ \t\t\tvar outdatedDependencies = {};\r\n/******/ \t\r\n/******/ \t\t\tvar queue = outdatedModules.slice();\r\n/******/ \t\t\twhile(queue.length > 0) {\r\n/******/ \t\t\t\tvar moduleId = queue.pop();\r\n/******/ \t\t\t\tvar module = installedModules[moduleId];\r\n/******/ \t\t\t\tif(!module || module.hot._selfAccepted)\r\n/******/ \t\t\t\t\tcontinue;\r\n/******/ \t\t\t\tif(module.hot._selfDeclined) {\r\n/******/ \t\t\t\t\treturn new Error(\"Aborted because of self decline: \" + moduleId);\r\n/******/ \t\t\t\t}\r\n/******/ \t\t\t\tif(moduleId === 0) {\r\n/******/ \t\t\t\t\treturn;\r\n/******/ \t\t\t\t}\r\n/******/ \t\t\t\tfor(var i = 0; i < module.parents.length; i++) {\r\n/******/ \t\t\t\t\tvar parentId = module.parents[i];\r\n/******/ \t\t\t\t\tvar parent = installedModules[parentId];\r\n/******/ \t\t\t\t\tif(parent.hot._declinedDependencies[moduleId]) {\r\n/******/ \t\t\t\t\t\treturn new Error(\"Aborted because of declined dependency: \" + moduleId + \" in \" + parentId);\r\n/******/ \t\t\t\t\t}\r\n/******/ \t\t\t\t\tif(outdatedModules.indexOf(parentId) >= 0) continue;\r\n/******/ \t\t\t\t\tif(parent.hot._acceptedDependencies[moduleId]) {\r\n/******/ \t\t\t\t\t\tif(!outdatedDependencies[parentId])\r\n/******/ \t\t\t\t\t\t\toutdatedDependencies[parentId] = [];\r\n/******/ \t\t\t\t\t\taddAllToSet(outdatedDependencies[parentId], [moduleId]);\r\n/******/ \t\t\t\t\t\tcontinue;\r\n/******/ \t\t\t\t\t}\r\n/******/ \t\t\t\t\tdelete outdatedDependencies[parentId];\r\n/******/ \t\t\t\t\toutdatedModules.push(parentId);\r\n/******/ \t\t\t\t\tqueue.push(parentId);\r\n/******/ \t\t\t\t}\r\n/******/ \t\t\t}\r\n/******/ \t\r\n/******/ \t\t\treturn [outdatedModules, outdatedDependencies];\r\n/******/ \t\t}\r\n/******/ \t\r\n/******/ \t\tfunction addAllToSet(a, b) {\r\n/******/ \t\t\tfor(var i = 0; i < b.length; i++) {\r\n/******/ \t\t\t\tvar item = b[i];\r\n/******/ \t\t\t\tif(a.indexOf(item) < 0)\r\n/******/ \t\t\t\t\ta.push(item);\r\n/******/ \t\t\t}\r\n/******/ \t\t}\r\n/******/ \t\r\n/******/ \t\t// at begin all updates modules are outdated\r\n/******/ \t\t// the \"outdated\" status can propagate to parents if they don't accept the children\r\n/******/ \t\tvar outdatedDependencies = {};\r\n/******/ \t\tvar outdatedModules = [];\r\n/******/ \t\tvar appliedUpdate = {};\r\n/******/ \t\tfor(var id in hotUpdate) {\r\n/******/ \t\t\tif(Object.prototype.hasOwnProperty.call(hotUpdate, id)) {\r\n/******/ \t\t\t\tvar moduleId = toModuleId(id);\r\n/******/ \t\t\t\tvar result = getAffectedStuff(moduleId);\r\n/******/ \t\t\t\tif(!result) {\r\n/******/ \t\t\t\t\tif(options.ignoreUnaccepted)\r\n/******/ \t\t\t\t\t\tcontinue;\r\n/******/ \t\t\t\t\thotSetStatus(\"abort\");\r\n/******/ \t\t\t\t\treturn callback(new Error(\"Aborted because \" + moduleId + \" is not accepted\"));\r\n/******/ \t\t\t\t}\r\n/******/ \t\t\t\tif(result instanceof Error) {\r\n/******/ \t\t\t\t\thotSetStatus(\"abort\");\r\n/******/ \t\t\t\t\treturn callback(result);\r\n/******/ \t\t\t\t}\r\n/******/ \t\t\t\tappliedUpdate[moduleId] = hotUpdate[moduleId];\r\n/******/ \t\t\t\taddAllToSet(outdatedModules, result[0]);\r\n/******/ \t\t\t\tfor(var moduleId in result[1]) {\r\n/******/ \t\t\t\t\tif(Object.prototype.hasOwnProperty.call(result[1], moduleId)) {\r\n/******/ \t\t\t\t\t\tif(!outdatedDependencies[moduleId])\r\n/******/ \t\t\t\t\t\t\toutdatedDependencies[moduleId] = [];\r\n/******/ \t\t\t\t\t\taddAllToSet(outdatedDependencies[moduleId], result[1][moduleId]);\r\n/******/ \t\t\t\t\t}\r\n/******/ \t\t\t\t}\r\n/******/ \t\t\t}\r\n/******/ \t\t}\r\n/******/ \t\r\n/******/ \t\t// Store self accepted outdated modules to require them later by the module system\r\n/******/ \t\tvar outdatedSelfAcceptedModules = [];\r\n/******/ \t\tfor(var i = 0; i < outdatedModules.length; i++) {\r\n/******/ \t\t\tvar moduleId = outdatedModules[i];\r\n/******/ \t\t\tif(installedModules[moduleId] && installedModules[moduleId].hot._selfAccepted)\r\n/******/ \t\t\t\toutdatedSelfAcceptedModules.push({\r\n/******/ \t\t\t\t\tmodule: moduleId,\r\n/******/ \t\t\t\t\terrorHandler: installedModules[moduleId].hot._selfAccepted\r\n/******/ \t\t\t\t});\r\n/******/ \t\t}\r\n/******/ \t\r\n/******/ \t\t// Now in \"dispose\" phase\r\n/******/ \t\thotSetStatus(\"dispose\");\r\n/******/ \t\tvar queue = outdatedModules.slice();\r\n/******/ \t\twhile(queue.length > 0) {\r\n/******/ \t\t\tvar moduleId = queue.pop();\r\n/******/ \t\t\tvar module = installedModules[moduleId];\r\n/******/ \t\t\tif(!module) continue;\r\n/******/ \t\r\n/******/ \t\t\tvar data = {};\r\n/******/ \t\r\n/******/ \t\t\t// Call dispose handlers\r\n/******/ \t\t\tvar disposeHandlers = module.hot._disposeHandlers;\r\n/******/ \t\t\tfor(var j = 0; j < disposeHandlers.length; j++) {\r\n/******/ \t\t\t\tvar cb = disposeHandlers[j];\r\n/******/ \t\t\t\tcb(data);\r\n/******/ \t\t\t}\r\n/******/ \t\t\thotCurrentModuleData[moduleId] = data;\r\n/******/ \t\r\n/******/ \t\t\t// disable module (this disables requires from this module)\r\n/******/ \t\t\tmodule.hot.active = false;\r\n/******/ \t\r\n/******/ \t\t\t// remove module from cache\r\n/******/ \t\t\tdelete installedModules[moduleId];\r\n/******/ \t\r\n/******/ \t\t\t// remove \"parents\" references from all children\r\n/******/ \t\t\tfor(var j = 0; j < module.children.length; j++) {\r\n/******/ \t\t\t\tvar child = installedModules[module.children[j]];\r\n/******/ \t\t\t\tif(!child) continue;\r\n/******/ \t\t\t\tvar idx = child.parents.indexOf(moduleId);\r\n/******/ \t\t\t\tif(idx >= 0) {\r\n/******/ \t\t\t\t\tchild.parents.splice(idx, 1);\r\n/******/ \t\t\t\t}\r\n/******/ \t\t\t}\r\n/******/ \t\t}\r\n/******/ \t\r\n/******/ \t\t// remove outdated dependency from module children\r\n/******/ \t\tfor(var moduleId in outdatedDependencies) {\r\n/******/ \t\t\tif(Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) {\r\n/******/ \t\t\t\tvar module = installedModules[moduleId];\r\n/******/ \t\t\t\tvar moduleOutdatedDependencies = outdatedDependencies[moduleId];\r\n/******/ \t\t\t\tfor(var j = 0; j < moduleOutdatedDependencies.length; j++) {\r\n/******/ \t\t\t\t\tvar dependency = moduleOutdatedDependencies[j];\r\n/******/ \t\t\t\t\tvar idx = module.children.indexOf(dependency);\r\n/******/ \t\t\t\t\tif(idx >= 0) module.children.splice(idx, 1);\r\n/******/ \t\t\t\t}\r\n/******/ \t\t\t}\r\n/******/ \t\t}\r\n/******/ \t\r\n/******/ \t\t// Not in \"apply\" phase\r\n/******/ \t\thotSetStatus(\"apply\");\r\n/******/ \t\r\n/******/ \t\thotCurrentHash = hotUpdateNewHash;\r\n/******/ \t\r\n/******/ \t\t// insert new code\r\n/******/ \t\tfor(var moduleId in appliedUpdate) {\r\n/******/ \t\t\tif(Object.prototype.hasOwnProperty.call(appliedUpdate, moduleId)) {\r\n/******/ \t\t\t\tmodules[moduleId] = appliedUpdate[moduleId];\r\n/******/ \t\t\t}\r\n/******/ \t\t}\r\n/******/ \t\r\n/******/ \t\t// call accept handlers\r\n/******/ \t\tvar error = null;\r\n/******/ \t\tfor(var moduleId in outdatedDependencies) {\r\n/******/ \t\t\tif(Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) {\r\n/******/ \t\t\t\tvar module = installedModules[moduleId];\r\n/******/ \t\t\t\tvar moduleOutdatedDependencies = outdatedDependencies[moduleId];\r\n/******/ \t\t\t\tvar callbacks = [];\r\n/******/ \t\t\t\tfor(var i = 0; i < moduleOutdatedDependencies.length; i++) {\r\n/******/ \t\t\t\t\tvar dependency = moduleOutdatedDependencies[i];\r\n/******/ \t\t\t\t\tvar cb = module.hot._acceptedDependencies[dependency];\r\n/******/ \t\t\t\t\tif(callbacks.indexOf(cb) >= 0) continue;\r\n/******/ \t\t\t\t\tcallbacks.push(cb);\r\n/******/ \t\t\t\t}\r\n/******/ \t\t\t\tfor(var i = 0; i < callbacks.length; i++) {\r\n/******/ \t\t\t\t\tvar cb = callbacks[i];\r\n/******/ \t\t\t\t\ttry {\r\n/******/ \t\t\t\t\t\tcb(outdatedDependencies);\r\n/******/ \t\t\t\t\t} catch(err) {\r\n/******/ \t\t\t\t\t\tif(!error)\r\n/******/ \t\t\t\t\t\t\terror = err;\r\n/******/ \t\t\t\t\t}\r\n/******/ \t\t\t\t}\r\n/******/ \t\t\t}\r\n/******/ \t\t}\r\n/******/ \t\r\n/******/ \t\t// Load self accepted modules\r\n/******/ \t\tfor(var i = 0; i < outdatedSelfAcceptedModules.length; i++) {\r\n/******/ \t\t\tvar item = outdatedSelfAcceptedModules[i];\r\n/******/ \t\t\tvar moduleId = item.module;\r\n/******/ \t\t\thotCurrentParents = [moduleId];\r\n/******/ \t\t\ttry {\r\n/******/ \t\t\t\t__webpack_require__(moduleId);\r\n/******/ \t\t\t} catch(err) {\r\n/******/ \t\t\t\tif(typeof item.errorHandler === \"function\") {\r\n/******/ \t\t\t\t\ttry {\r\n/******/ \t\t\t\t\t\titem.errorHandler(err);\r\n/******/ \t\t\t\t\t} catch(err) {\r\n/******/ \t\t\t\t\t\tif(!error)\r\n/******/ \t\t\t\t\t\t\terror = err;\r\n/******/ \t\t\t\t\t}\r\n/******/ \t\t\t\t} else if(!error)\r\n/******/ \t\t\t\t\terror = err;\r\n/******/ \t\t\t}\r\n/******/ \t\t}\r\n/******/ \t\r\n/******/ \t\t// handle errors in accept handlers and self accepted module load\r\n/******/ \t\tif(error) {\r\n/******/ \t\t\thotSetStatus(\"fail\");\r\n/******/ \t\t\treturn callback(error);\r\n/******/ \t\t}\r\n/******/ \t\r\n/******/ \t\thotSetStatus(\"idle\");\r\n/******/ \t\tcallback(null, outdatedModules);\r\n/******/ \t}\r\n/******/\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false,\n/******/ \t\t\thot: hotCreateModule(moduleId),\n/******/ \t\t\tparents: hotCurrentParents,\n/******/ \t\t\tchildren: []\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, hotCreateRequire(moduleId));\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// __webpack_hash__\n/******/ \t__webpack_require__.h = function() { return hotCurrentHash; };\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn hotCreateRequire(0)(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _mesh = __webpack_require__(5);\n\t\n\tself.onmessage = function (event) {\n\t\n\t    var jobs = [];\n\t\n\t    var _event$data = event.data,\n\t        settings = _event$data.settings,\n\t        opIndex = _event$data.opIndex,\n\t        op = _event$data.op,\n\t        geometry = _event$data.geometry,\n\t        openGeometry = _event$data.openGeometry,\n\t        tabGeometry = _event$data.tabGeometry,\n\t        documents = _event$data.documents;\n\t\n\t\n\t    var docsWithImages = [];\n\t\n\t    function matchColor(filterColor, color) {\n\t        if (!filterColor) return true;\n\t        if (!color) return false;\n\t        return filterColor[0] == color[0] && filterColor[1] == color[1] && filterColor[2] == color[2] && filterColor[3] == color[3];\n\t    }\n\t\n\t    function examineDocTree(isTab, id) {\n\t        var doc = documents.find(function (d) {\n\t            return d.id === id;\n\t        });\n\t        if (doc.rawPaths) {\n\t            jobs.push(function (cb) {\n\t                if (isTab) {\n\t                    tabGeometry = (0, _mesh.union)(tabGeometry, (0, _mesh.rawPathsToClipperPaths)(doc.rawPaths, doc.scale[0], doc.scale[1], doc.translate[0], doc.translate[1]));\n\t                } else if (matchColor(op.filterFillColor, doc.fillColor) && matchColor(op.filterStrokeColor, doc.strokeColor)) {\n\t                    var isClosed = false;\n\t                    var _iteratorNormalCompletion = true;\n\t                    var _didIteratorError = false;\n\t                    var _iteratorError = undefined;\n\t\n\t                    try {\n\t                        for (var _iterator = doc.rawPaths[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t                            var rawPath = _step.value;\n\t\n\t                            if (rawPath.length >= 4 && rawPath[0] == rawPath[rawPath.length - 2] && rawPath[1] == rawPath[rawPath.length - 1]) isClosed = true;\n\t                        }\n\t                    } catch (err) {\n\t                        _didIteratorError = true;\n\t                        _iteratorError = err;\n\t                    } finally {\n\t                        try {\n\t                            if (!_iteratorNormalCompletion && _iterator.return) {\n\t                                _iterator.return();\n\t                            }\n\t                        } finally {\n\t                            if (_didIteratorError) {\n\t                                throw _iteratorError;\n\t                            }\n\t                        }\n\t                    }\n\t\n\t                    var clipperPaths = (0, _mesh.rawPathsToClipperPaths)(doc.rawPaths, doc.scale[0], doc.scale[1], doc.translate[0], doc.translate[1]);\n\t                    if (isClosed) geometry = (0, _mesh.xor)(geometry, clipperPaths);else if (!op.filterFillColor) openGeometry = openGeometry.concat(clipperPaths);\n\t                }\n\t                cb();\n\t            });\n\t        }\n\t        if (doc.type === 'image' && !isTab) {\n\t            docsWithImages.push(doc);\n\t        }\n\t        var _iteratorNormalCompletion2 = true;\n\t        var _didIteratorError2 = false;\n\t        var _iteratorError2 = undefined;\n\t\n\t        try {\n\t            for (var _iterator2 = doc.children[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t                var child = _step2.value;\n\t\n\t                examineDocTree(isTab, child);\n\t            }\n\t        } catch (err) {\n\t            _didIteratorError2 = true;\n\t            _iteratorError2 = err;\n\t        } finally {\n\t            try {\n\t                if (!_iteratorNormalCompletion2 && _iterator2.return) {\n\t                    _iterator2.return();\n\t                }\n\t            } finally {\n\t                if (_didIteratorError2) {\n\t                    throw _iteratorError2;\n\t                }\n\t            }\n\t        }\n\t    }\n\t    var _iteratorNormalCompletion3 = true;\n\t    var _didIteratorError3 = false;\n\t    var _iteratorError3 = undefined;\n\t\n\t    try {\n\t        for (var _iterator3 = op.documents[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n\t            var id = _step3.value;\n\t\n\t            examineDocTree(false, id);\n\t        }\n\t    } catch (err) {\n\t        _didIteratorError3 = true;\n\t        _iteratorError3 = err;\n\t    } finally {\n\t        try {\n\t            if (!_iteratorNormalCompletion3 && _iterator3.return) {\n\t                _iterator3.return();\n\t            }\n\t        } finally {\n\t            if (_didIteratorError3) {\n\t                throw _iteratorError3;\n\t            }\n\t        }\n\t    }\n\t\n\t    var _iteratorNormalCompletion4 = true;\n\t    var _didIteratorError4 = false;\n\t    var _iteratorError4 = undefined;\n\t\n\t    try {\n\t        for (var _iterator4 = op.tabDocuments[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n\t            var _id = _step4.value;\n\t\n\t            examineDocTree(true, _id);\n\t        }\n\t    } catch (err) {\n\t        _didIteratorError4 = true;\n\t        _iteratorError4 = err;\n\t    } finally {\n\t        try {\n\t            if (!_iteratorNormalCompletion4 && _iterator4.return) {\n\t                _iterator4.return();\n\t            }\n\t        } finally {\n\t            if (_didIteratorError4) {\n\t                throw _iteratorError4;\n\t            }\n\t        }\n\t    }\n\t\n\t    var chunk = 100 / jobs.length;\n\t    var percent = 0;\n\t\n\t    while (jobs.length) {\n\t        try {\n\t            var job = jobs.shift();\n\t            if (job) job(function () {\n\t                percent = percent + chunk;\n\t                postMessage({ event: \"onProgress\", percent: parseInt(percent) });\n\t            });\n\t        } catch (error) {\n\t            console.error(error);\n\t            postMessage({ event: \"onError\", message: \"Something wrong has happened, sorry.\", level: \"error\", error: error.toString() });\n\t        }\n\t    }\n\t\n\t    postMessage({ event: \"onDone\", settings: settings, opIndex: opIndex, op: op, geometry: geometry, openGeometry: openGeometry, tabGeometry: tabGeometry, docsWithImages: docsWithImages });\n\t    self.close();\n\t};\n\t;\n\n\tvar _temp = function () {\n\t    if (typeof __REACT_HOT_LOADER__ === 'undefined') {\n\t        return;\n\t    }\n\t}();\n\n\t;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\n\t/*\n\t * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors\n\t * http://code.google.com/p/poly2tri/\n\t * \n\t * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors\n\t * https://github.com/r3mi/poly2tri.js\n\t * \n\t * All rights reserved.\n\t * \n\t * Distributed under the 3-clause BSD License, see LICENSE.txt\n\t */\n\t\n\t\"use strict\";\n\t\n\t/**\n\t * The following functions operate on \"Point\" or any \"Point like\" object with {x,y},\n\t * as defined by the {@link XY} type\n\t * ([duck typing]{@link http://en.wikipedia.org/wiki/Duck_typing}).\n\t * @module\n\t * @private\n\t */\n\t\n\t/**\n\t * poly2tri.js supports using custom point class instead of {@linkcode Point}.\n\t * Any \"Point like\" object with <code>{x, y}</code> attributes is supported\n\t * to initialize the SweepContext polylines and points\n\t * ([duck typing]{@link http://en.wikipedia.org/wiki/Duck_typing}).\n\t *\n\t * poly2tri.js might add extra fields to the point objects when computing the\n\t * triangulation : they are prefixed with <code>_p2t_</code> to avoid collisions\n\t * with fields in the custom class.\n\t *\n\t * @example\n\t *      var contour = [{x:100, y:100}, {x:100, y:300}, {x:300, y:300}, {x:300, y:100}];\n\t *      var swctx = new poly2tri.SweepContext(contour);\n\t *\n\t * @typedef {Object} XY\n\t * @property {number} x - x coordinate\n\t * @property {number} y - y coordinate\n\t */\n\t\n\t\n\t/**\n\t * Point pretty printing : prints x and y coordinates.\n\t * @example\n\t *      xy.toStringBase({x:5, y:42})\n\t *      //  \"(5;42)\"\n\t * @protected\n\t * @param {!XY} p - point object with {x,y}\n\t * @returns {string} <code>\"(x;y)\"</code>\n\t */\n\tfunction toStringBase(p) {\n\t    return (\"(\" + p.x + \";\" + p.y + \")\");\n\t}\n\t\n\t/**\n\t * Point pretty printing. Delegates to the point's custom \"toString()\" method if exists,\n\t * else simply prints x and y coordinates.\n\t * @example\n\t *      xy.toString({x:5, y:42})\n\t *      //  \"(5;42)\"\n\t * @example\n\t *      xy.toString({x:5,y:42,toString:function() {return this.x+\":\"+this.y;}})\n\t *      //  \"5:42\"\n\t * @param {!XY} p - point object with {x,y}\n\t * @returns {string} <code>\"(x;y)\"</code>\n\t */\n\tfunction toString(p) {\n\t    // Try a custom toString first, and fallback to own implementation if none\n\t    var s = p.toString();\n\t    return (s === '[object Object]' ? toStringBase(p) : s);\n\t}\n\t\n\t\n\t/**\n\t * Compare two points component-wise. Ordered by y axis first, then x axis.\n\t * @param {!XY} a - point object with {x,y}\n\t * @param {!XY} b - point object with {x,y}\n\t * @return {number} <code>&lt; 0</code> if <code>a &lt; b</code>,\n\t *         <code>&gt; 0</code> if <code>a &gt; b</code>, \n\t *         <code>0</code> otherwise.\n\t */\n\tfunction compare(a, b) {\n\t    if (a.y === b.y) {\n\t        return a.x - b.x;\n\t    } else {\n\t        return a.y - b.y;\n\t    }\n\t}\n\t\n\t/**\n\t * Test two Point objects for equality.\n\t * @param {!XY} a - point object with {x,y}\n\t * @param {!XY} b - point object with {x,y}\n\t * @return {boolean} <code>True</code> if <code>a == b</code>, <code>false</code> otherwise.\n\t */\n\tfunction equals(a, b) {\n\t    return a.x === b.x && a.y === b.y;\n\t}\n\t\n\t\n\tmodule.exports = {\n\t    toString: toString,\n\t    toStringBase: toStringBase,\n\t    compare: compare,\n\t    equals: equals\n\t};\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports) {\n\n\t/*\n\t * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors\n\t * http://code.google.com/p/poly2tri/\n\t * \n\t * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors\n\t * https://github.com/r3mi/poly2tri.js\n\t * \n\t * All rights reserved.\n\t * \n\t * Distributed under the 3-clause BSD License, see LICENSE.txt\n\t */\n\t\n\t/* jshint maxcomplexity:11 */\n\t\n\t\"use strict\";\n\t\n\t\n\t/*\n\t * Note\n\t * ====\n\t * the structure of this JavaScript version of poly2tri intentionally follows\n\t * as closely as possible the structure of the reference C++ version, to make it \n\t * easier to keep the 2 versions in sync.\n\t */\n\t\n\t\n\t// -------------------------------------------------------------------------Node\n\t\n\t/**\n\t * Advancing front node\n\t * @constructor\n\t * @private\n\t * @struct\n\t * @param {!XY} p - Point\n\t * @param {Triangle=} t triangle (optional)\n\t */\n\tvar Node = function(p, t) {\n\t    /** @type {XY} */\n\t    this.point = p;\n\t\n\t    /** @type {Triangle|null} */\n\t    this.triangle = t || null;\n\t\n\t    /** @type {Node|null} */\n\t    this.next = null;\n\t    /** @type {Node|null} */\n\t    this.prev = null;\n\t\n\t    /** @type {number} */\n\t    this.value = p.x;\n\t};\n\t\n\t// ---------------------------------------------------------------AdvancingFront\n\t/**\n\t * @constructor\n\t * @private\n\t * @struct\n\t * @param {Node} head\n\t * @param {Node} tail\n\t */\n\tvar AdvancingFront = function(head, tail) {\n\t    /** @type {Node} */\n\t    this.head_ = head;\n\t    /** @type {Node} */\n\t    this.tail_ = tail;\n\t    /** @type {Node} */\n\t    this.search_node_ = head;\n\t};\n\t\n\t/** @return {Node} */\n\tAdvancingFront.prototype.head = function() {\n\t    return this.head_;\n\t};\n\t\n\t/** @param {Node} node */\n\tAdvancingFront.prototype.setHead = function(node) {\n\t    this.head_ = node;\n\t};\n\t\n\t/** @return {Node} */\n\tAdvancingFront.prototype.tail = function() {\n\t    return this.tail_;\n\t};\n\t\n\t/** @param {Node} node */\n\tAdvancingFront.prototype.setTail = function(node) {\n\t    this.tail_ = node;\n\t};\n\t\n\t/** @return {Node} */\n\tAdvancingFront.prototype.search = function() {\n\t    return this.search_node_;\n\t};\n\t\n\t/** @param {Node} node */\n\tAdvancingFront.prototype.setSearch = function(node) {\n\t    this.search_node_ = node;\n\t};\n\t\n\t/** @return {Node} */\n\tAdvancingFront.prototype.findSearchNode = function(/*x*/) {\n\t    // TODO: implement BST index\n\t    return this.search_node_;\n\t};\n\t\n\t/**\n\t * @param {number} x value\n\t * @return {Node}\n\t */\n\tAdvancingFront.prototype.locateNode = function(x) {\n\t    var node = this.search_node_;\n\t\n\t    /* jshint boss:true */\n\t    if (x < node.value) {\n\t        while (node = node.prev) {\n\t            if (x >= node.value) {\n\t                this.search_node_ = node;\n\t                return node;\n\t            }\n\t        }\n\t    } else {\n\t        while (node = node.next) {\n\t            if (x < node.value) {\n\t                this.search_node_ = node.prev;\n\t                return node.prev;\n\t            }\n\t        }\n\t    }\n\t    return null;\n\t};\n\t\n\t/**\n\t * @param {!XY} point - Point\n\t * @return {Node}\n\t */\n\tAdvancingFront.prototype.locatePoint = function(point) {\n\t    var px = point.x;\n\t    var node = this.findSearchNode(px);\n\t    var nx = node.point.x;\n\t\n\t    if (px === nx) {\n\t        // Here we are comparing point references, not values\n\t        if (point !== node.point) {\n\t            // We might have two nodes with same x value for a short time\n\t            if (point === node.prev.point) {\n\t                node = node.prev;\n\t            } else if (point === node.next.point) {\n\t                node = node.next;\n\t            } else {\n\t                throw new Error('poly2tri Invalid AdvancingFront.locatePoint() call');\n\t            }\n\t        }\n\t    } else if (px < nx) {\n\t        /* jshint boss:true */\n\t        while (node = node.prev) {\n\t            if (point === node.point) {\n\t                break;\n\t            }\n\t        }\n\t    } else {\n\t        while (node = node.next) {\n\t            if (point === node.point) {\n\t                break;\n\t            }\n\t        }\n\t    }\n\t\n\t    if (node) {\n\t        this.search_node_ = node;\n\t    }\n\t    return node;\n\t};\n\t\n\t\n\t// ----------------------------------------------------------------------Exports\n\t\n\tmodule.exports = AdvancingFront;\n\tmodule.exports.Node = Node;\n\t\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/*\n\t * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors\n\t * http://code.google.com/p/poly2tri/\n\t * \n\t * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors\n\t * https://github.com/r3mi/poly2tri.js\n\t * \n\t * All rights reserved.\n\t * \n\t * Distributed under the 3-clause BSD License, see LICENSE.txt\n\t */\n\t\n\t\"use strict\";\n\t\n\t/*\n\t * Class added in the JavaScript version (was not present in the c++ version)\n\t */\n\t\n\tvar xy = __webpack_require__(1);\n\t\n\t/**\n\t * Custom exception class to indicate invalid Point values\n\t * @constructor\n\t * @public\n\t * @extends Error\n\t * @struct\n\t * @param {string=} message - error message\n\t * @param {Array.<XY>=} points - invalid points\n\t */\n\tvar PointError = function(message, points) {\n\t    this.name = \"PointError\";\n\t    /**\n\t     * Invalid points\n\t     * @public\n\t     * @type {Array.<XY>}\n\t     */\n\t    this.points = points = points || [];\n\t    /**\n\t     * Error message\n\t     * @public\n\t     * @type {string}\n\t     */\n\t    this.message = message || \"Invalid Points!\";\n\t    for (var i = 0; i < points.length; i++) {\n\t        this.message += \" \" + xy.toString(points[i]);\n\t    }\n\t};\n\tPointError.prototype = new Error();\n\tPointError.prototype.constructor = PointError;\n\t\n\t\n\tmodule.exports = PointError;\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/*\n\t * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors\n\t * http://code.google.com/p/poly2tri/\n\t * \n\t * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors\n\t * https://github.com/r3mi/poly2tri.js\n\t *\n\t * All rights reserved.\n\t * \n\t * Distributed under the 3-clause BSD License, see LICENSE.txt\n\t */\n\t\n\t/* jshint maxcomplexity:10 */\n\t\n\t\"use strict\";\n\t\n\t\n\t/*\n\t * Note\n\t * ====\n\t * the structure of this JavaScript version of poly2tri intentionally follows\n\t * as closely as possible the structure of the reference C++ version, to make it \n\t * easier to keep the 2 versions in sync.\n\t */\n\t\n\tvar xy = __webpack_require__(1);\n\t\n\t\n\t// ---------------------------------------------------------------------Triangle\n\t/**\n\t * Triangle class.<br>\n\t * Triangle-based data structures are known to have better performance than\n\t * quad-edge structures.\n\t * See: J. Shewchuk, \"Triangle: Engineering a 2D Quality Mesh Generator and\n\t * Delaunay Triangulator\", \"Triangulations in CGAL\"\n\t *\n\t * @constructor\n\t * @struct\n\t * @param {!XY} pa  point object with {x,y}\n\t * @param {!XY} pb  point object with {x,y}\n\t * @param {!XY} pc  point object with {x,y}\n\t */\n\tvar Triangle = function(a, b, c) {\n\t    /**\n\t     * Triangle points\n\t     * @private\n\t     * @type {Array.<XY>}\n\t     */\n\t    this.points_ = [a, b, c];\n\t\n\t    /**\n\t     * Neighbor list\n\t     * @private\n\t     * @type {Array.<Triangle>}\n\t     */\n\t    this.neighbors_ = [null, null, null];\n\t\n\t    /**\n\t     * Has this triangle been marked as an interior triangle?\n\t     * @private\n\t     * @type {boolean}\n\t     */\n\t    this.interior_ = false;\n\t\n\t    /**\n\t     * Flags to determine if an edge is a Constrained edge\n\t     * @private\n\t     * @type {Array.<boolean>}\n\t     */\n\t    this.constrained_edge = [false, false, false];\n\t\n\t    /**\n\t     * Flags to determine if an edge is a Delauney edge\n\t     * @private\n\t     * @type {Array.<boolean>}\n\t     */\n\t    this.delaunay_edge = [false, false, false];\n\t};\n\t\n\tvar p2s = xy.toString;\n\t/**\n\t * For pretty printing ex. <code>\"[(5;42)(10;20)(21;30)]\"</code>.\n\t * @public\n\t * @return {string}\n\t */\n\tTriangle.prototype.toString = function() {\n\t    return (\"[\" + p2s(this.points_[0]) + p2s(this.points_[1]) + p2s(this.points_[2]) + \"]\");\n\t};\n\t\n\t/**\n\t * Get one vertice of the triangle.\n\t * The output triangles of a triangulation have vertices which are references\n\t * to the initial input points (not copies): any custom fields in the\n\t * initial points can be retrieved in the output triangles.\n\t * @example\n\t *      var contour = [{x:100, y:100, id:1}, {x:100, y:300, id:2}, {x:300, y:300, id:3}];\n\t *      var swctx = new poly2tri.SweepContext(contour);\n\t *      swctx.triangulate();\n\t *      var triangles = swctx.getTriangles();\n\t *      typeof triangles[0].getPoint(0).id\n\t *      //  \"number\"\n\t * @param {number} index - vertice index: 0, 1 or 2\n\t * @public\n\t * @returns {XY}\n\t */\n\tTriangle.prototype.getPoint = function(index) {\n\t    return this.points_[index];\n\t};\n\t\n\t/**\n\t * For backward compatibility\n\t * @function\n\t * @deprecated use {@linkcode Triangle#getPoint} instead\n\t */\n\tTriangle.prototype.GetPoint = Triangle.prototype.getPoint;\n\t\n\t/**\n\t * Get all 3 vertices of the triangle as an array\n\t * @public\n\t * @return {Array.<XY>}\n\t */\n\t// Method added in the JavaScript version (was not present in the c++ version)\n\tTriangle.prototype.getPoints = function() {\n\t    return this.points_;\n\t};\n\t\n\t/**\n\t * @private\n\t * @param {number} index\n\t * @returns {?Triangle}\n\t */\n\tTriangle.prototype.getNeighbor = function(index) {\n\t    return this.neighbors_[index];\n\t};\n\t\n\t/**\n\t * Test if this Triangle contains the Point object given as parameter as one of its vertices.\n\t * Only point references are compared, not values.\n\t * @public\n\t * @param {XY} point - point object with {x,y}\n\t * @return {boolean} <code>True</code> if the Point object is of the Triangle's vertices,\n\t *         <code>false</code> otherwise.\n\t */\n\tTriangle.prototype.containsPoint = function(point) {\n\t    var points = this.points_;\n\t    // Here we are comparing point references, not values\n\t    return (point === points[0] || point === points[1] || point === points[2]);\n\t};\n\t\n\t/**\n\t * Test if this Triangle contains the Edge object given as parameter as its\n\t * bounding edges. Only point references are compared, not values.\n\t * @private\n\t * @param {Edge} edge\n\t * @return {boolean} <code>True</code> if the Edge object is of the Triangle's bounding\n\t *         edges, <code>false</code> otherwise.\n\t */\n\tTriangle.prototype.containsEdge = function(edge) {\n\t    return this.containsPoint(edge.p) && this.containsPoint(edge.q);\n\t};\n\t\n\t/**\n\t * Test if this Triangle contains the two Point objects given as parameters among its vertices.\n\t * Only point references are compared, not values.\n\t * @param {XY} p1 - point object with {x,y}\n\t * @param {XY} p2 - point object with {x,y}\n\t * @return {boolean}\n\t */\n\tTriangle.prototype.containsPoints = function(p1, p2) {\n\t    return this.containsPoint(p1) && this.containsPoint(p2);\n\t};\n\t\n\t/**\n\t * Has this triangle been marked as an interior triangle?\n\t * @returns {boolean}\n\t */\n\tTriangle.prototype.isInterior = function() {\n\t    return this.interior_;\n\t};\n\t\n\t/**\n\t * Mark this triangle as an interior triangle\n\t * @private\n\t * @param {boolean} interior\n\t * @returns {Triangle} this\n\t */\n\tTriangle.prototype.setInterior = function(interior) {\n\t    this.interior_ = interior;\n\t    return this;\n\t};\n\t\n\t/**\n\t * Update neighbor pointers.\n\t * @private\n\t * @param {XY} p1 - point object with {x,y}\n\t * @param {XY} p2 - point object with {x,y}\n\t * @param {Triangle} t Triangle object.\n\t * @throws {Error} if can't find objects\n\t */\n\tTriangle.prototype.markNeighborPointers = function(p1, p2, t) {\n\t    var points = this.points_;\n\t    // Here we are comparing point references, not values\n\t    if ((p1 === points[2] && p2 === points[1]) || (p1 === points[1] && p2 === points[2])) {\n\t        this.neighbors_[0] = t;\n\t    } else if ((p1 === points[0] && p2 === points[2]) || (p1 === points[2] && p2 === points[0])) {\n\t        this.neighbors_[1] = t;\n\t    } else if ((p1 === points[0] && p2 === points[1]) || (p1 === points[1] && p2 === points[0])) {\n\t        this.neighbors_[2] = t;\n\t    } else {\n\t        throw new Error('poly2tri Invalid Triangle.markNeighborPointers() call');\n\t    }\n\t};\n\t\n\t/**\n\t * Exhaustive search to update neighbor pointers\n\t * @private\n\t * @param {!Triangle} t\n\t */\n\tTriangle.prototype.markNeighbor = function(t) {\n\t    var points = this.points_;\n\t    if (t.containsPoints(points[1], points[2])) {\n\t        this.neighbors_[0] = t;\n\t        t.markNeighborPointers(points[1], points[2], this);\n\t    } else if (t.containsPoints(points[0], points[2])) {\n\t        this.neighbors_[1] = t;\n\t        t.markNeighborPointers(points[0], points[2], this);\n\t    } else if (t.containsPoints(points[0], points[1])) {\n\t        this.neighbors_[2] = t;\n\t        t.markNeighborPointers(points[0], points[1], this);\n\t    }\n\t};\n\t\n\t\n\tTriangle.prototype.clearNeighbors = function() {\n\t    this.neighbors_[0] = null;\n\t    this.neighbors_[1] = null;\n\t    this.neighbors_[2] = null;\n\t};\n\t\n\tTriangle.prototype.clearDelaunayEdges = function() {\n\t    this.delaunay_edge[0] = false;\n\t    this.delaunay_edge[1] = false;\n\t    this.delaunay_edge[2] = false;\n\t};\n\t\n\t/**\n\t * Returns the point clockwise to the given point.\n\t * @private\n\t * @param {XY} p - point object with {x,y}\n\t */\n\tTriangle.prototype.pointCW = function(p) {\n\t    var points = this.points_;\n\t    // Here we are comparing point references, not values\n\t    if (p === points[0]) {\n\t        return points[2];\n\t    } else if (p === points[1]) {\n\t        return points[0];\n\t    } else if (p === points[2]) {\n\t        return points[1];\n\t    } else {\n\t        return null;\n\t    }\n\t};\n\t\n\t/**\n\t * Returns the point counter-clockwise to the given point.\n\t * @private\n\t * @param {XY} p - point object with {x,y}\n\t */\n\tTriangle.prototype.pointCCW = function(p) {\n\t    var points = this.points_;\n\t    // Here we are comparing point references, not values\n\t    if (p === points[0]) {\n\t        return points[1];\n\t    } else if (p === points[1]) {\n\t        return points[2];\n\t    } else if (p === points[2]) {\n\t        return points[0];\n\t    } else {\n\t        return null;\n\t    }\n\t};\n\t\n\t/**\n\t * Returns the neighbor clockwise to given point.\n\t * @private\n\t * @param {XY} p - point object with {x,y}\n\t */\n\tTriangle.prototype.neighborCW = function(p) {\n\t    // Here we are comparing point references, not values\n\t    if (p === this.points_[0]) {\n\t        return this.neighbors_[1];\n\t    } else if (p === this.points_[1]) {\n\t        return this.neighbors_[2];\n\t    } else {\n\t        return this.neighbors_[0];\n\t    }\n\t};\n\t\n\t/**\n\t * Returns the neighbor counter-clockwise to given point.\n\t * @private\n\t * @param {XY} p - point object with {x,y}\n\t */\n\tTriangle.prototype.neighborCCW = function(p) {\n\t    // Here we are comparing point references, not values\n\t    if (p === this.points_[0]) {\n\t        return this.neighbors_[2];\n\t    } else if (p === this.points_[1]) {\n\t        return this.neighbors_[0];\n\t    } else {\n\t        return this.neighbors_[1];\n\t    }\n\t};\n\t\n\tTriangle.prototype.getConstrainedEdgeCW = function(p) {\n\t    // Here we are comparing point references, not values\n\t    if (p === this.points_[0]) {\n\t        return this.constrained_edge[1];\n\t    } else if (p === this.points_[1]) {\n\t        return this.constrained_edge[2];\n\t    } else {\n\t        return this.constrained_edge[0];\n\t    }\n\t};\n\t\n\tTriangle.prototype.getConstrainedEdgeCCW = function(p) {\n\t    // Here we are comparing point references, not values\n\t    if (p === this.points_[0]) {\n\t        return this.constrained_edge[2];\n\t    } else if (p === this.points_[1]) {\n\t        return this.constrained_edge[0];\n\t    } else {\n\t        return this.constrained_edge[1];\n\t    }\n\t};\n\t\n\t// Additional check from Java version (see issue #88)\n\tTriangle.prototype.getConstrainedEdgeAcross = function(p) {\n\t    // Here we are comparing point references, not values\n\t    if (p === this.points_[0]) {\n\t        return this.constrained_edge[0];\n\t    } else if (p === this.points_[1]) {\n\t        return this.constrained_edge[1];\n\t    } else {\n\t        return this.constrained_edge[2];\n\t    }\n\t};\n\t\n\tTriangle.prototype.setConstrainedEdgeCW = function(p, ce) {\n\t    // Here we are comparing point references, not values\n\t    if (p === this.points_[0]) {\n\t        this.constrained_edge[1] = ce;\n\t    } else if (p === this.points_[1]) {\n\t        this.constrained_edge[2] = ce;\n\t    } else {\n\t        this.constrained_edge[0] = ce;\n\t    }\n\t};\n\t\n\tTriangle.prototype.setConstrainedEdgeCCW = function(p, ce) {\n\t    // Here we are comparing point references, not values\n\t    if (p === this.points_[0]) {\n\t        this.constrained_edge[2] = ce;\n\t    } else if (p === this.points_[1]) {\n\t        this.constrained_edge[0] = ce;\n\t    } else {\n\t        this.constrained_edge[1] = ce;\n\t    }\n\t};\n\t\n\tTriangle.prototype.getDelaunayEdgeCW = function(p) {\n\t    // Here we are comparing point references, not values\n\t    if (p === this.points_[0]) {\n\t        return this.delaunay_edge[1];\n\t    } else if (p === this.points_[1]) {\n\t        return this.delaunay_edge[2];\n\t    } else {\n\t        return this.delaunay_edge[0];\n\t    }\n\t};\n\t\n\tTriangle.prototype.getDelaunayEdgeCCW = function(p) {\n\t    // Here we are comparing point references, not values\n\t    if (p === this.points_[0]) {\n\t        return this.delaunay_edge[2];\n\t    } else if (p === this.points_[1]) {\n\t        return this.delaunay_edge[0];\n\t    } else {\n\t        return this.delaunay_edge[1];\n\t    }\n\t};\n\t\n\tTriangle.prototype.setDelaunayEdgeCW = function(p, e) {\n\t    // Here we are comparing point references, not values\n\t    if (p === this.points_[0]) {\n\t        this.delaunay_edge[1] = e;\n\t    } else if (p === this.points_[1]) {\n\t        this.delaunay_edge[2] = e;\n\t    } else {\n\t        this.delaunay_edge[0] = e;\n\t    }\n\t};\n\t\n\tTriangle.prototype.setDelaunayEdgeCCW = function(p, e) {\n\t    // Here we are comparing point references, not values\n\t    if (p === this.points_[0]) {\n\t        this.delaunay_edge[2] = e;\n\t    } else if (p === this.points_[1]) {\n\t        this.delaunay_edge[0] = e;\n\t    } else {\n\t        this.delaunay_edge[1] = e;\n\t    }\n\t};\n\t\n\t/**\n\t * The neighbor across to given point.\n\t * @private\n\t * @param {XY} p - point object with {x,y}\n\t * @returns {Triangle}\n\t */\n\tTriangle.prototype.neighborAcross = function(p) {\n\t    // Here we are comparing point references, not values\n\t    if (p === this.points_[0]) {\n\t        return this.neighbors_[0];\n\t    } else if (p === this.points_[1]) {\n\t        return this.neighbors_[1];\n\t    } else {\n\t        return this.neighbors_[2];\n\t    }\n\t};\n\t\n\t/**\n\t * @private\n\t * @param {!Triangle} t Triangle object.\n\t * @param {XY} p - point object with {x,y}\n\t */\n\tTriangle.prototype.oppositePoint = function(t, p) {\n\t    var cw = t.pointCW(p);\n\t    return this.pointCW(cw);\n\t};\n\t\n\t/**\n\t * Legalize triangle by rotating clockwise around oPoint\n\t * @private\n\t * @param {XY} opoint - point object with {x,y}\n\t * @param {XY} npoint - point object with {x,y}\n\t * @throws {Error} if oPoint can not be found\n\t */\n\tTriangle.prototype.legalize = function(opoint, npoint) {\n\t    var points = this.points_;\n\t    // Here we are comparing point references, not values\n\t    if (opoint === points[0]) {\n\t        points[1] = points[0];\n\t        points[0] = points[2];\n\t        points[2] = npoint;\n\t    } else if (opoint === points[1]) {\n\t        points[2] = points[1];\n\t        points[1] = points[0];\n\t        points[0] = npoint;\n\t    } else if (opoint === points[2]) {\n\t        points[0] = points[2];\n\t        points[2] = points[1];\n\t        points[1] = npoint;\n\t    } else {\n\t        throw new Error('poly2tri Invalid Triangle.legalize() call');\n\t    }\n\t};\n\t\n\t/**\n\t * Returns the index of a point in the triangle. \n\t * The point *must* be a reference to one of the triangle's vertices.\n\t * @private\n\t * @param {XY} p - point object with {x,y}\n\t * @returns {number} index 0, 1 or 2\n\t * @throws {Error} if p can not be found\n\t */\n\tTriangle.prototype.index = function(p) {\n\t    var points = this.points_;\n\t    // Here we are comparing point references, not values\n\t    if (p === points[0]) {\n\t        return 0;\n\t    } else if (p === points[1]) {\n\t        return 1;\n\t    } else if (p === points[2]) {\n\t        return 2;\n\t    } else {\n\t        throw new Error('poly2tri Invalid Triangle.index() call');\n\t    }\n\t};\n\t\n\t/**\n\t * @private\n\t * @param {XY} p1 - point object with {x,y}\n\t * @param {XY} p2 - point object with {x,y}\n\t * @return {number} index 0, 1 or 2, or -1 if errror\n\t */\n\tTriangle.prototype.edgeIndex = function(p1, p2) {\n\t    var points = this.points_;\n\t    // Here we are comparing point references, not values\n\t    if (p1 === points[0]) {\n\t        if (p2 === points[1]) {\n\t            return 2;\n\t        } else if (p2 === points[2]) {\n\t            return 1;\n\t        }\n\t    } else if (p1 === points[1]) {\n\t        if (p2 === points[2]) {\n\t            return 0;\n\t        } else if (p2 === points[0]) {\n\t            return 2;\n\t        }\n\t    } else if (p1 === points[2]) {\n\t        if (p2 === points[0]) {\n\t            return 1;\n\t        } else if (p2 === points[1]) {\n\t            return 0;\n\t        }\n\t    }\n\t    return -1;\n\t};\n\t\n\t/**\n\t * Mark an edge of this triangle as constrained.\n\t * @private\n\t * @param {number} index - edge index\n\t */\n\tTriangle.prototype.markConstrainedEdgeByIndex = function(index) {\n\t    this.constrained_edge[index] = true;\n\t};\n\t/**\n\t * Mark an edge of this triangle as constrained.\n\t * @private\n\t * @param {Edge} edge instance\n\t */\n\tTriangle.prototype.markConstrainedEdgeByEdge = function(edge) {\n\t    this.markConstrainedEdgeByPoints(edge.p, edge.q);\n\t};\n\t/**\n\t * Mark an edge of this triangle as constrained.\n\t * This method takes two Point instances defining the edge of the triangle.\n\t * @private\n\t * @param {XY} p - point object with {x,y}\n\t * @param {XY} q - point object with {x,y}\n\t */\n\tTriangle.prototype.markConstrainedEdgeByPoints = function(p, q) {\n\t    var points = this.points_;\n\t    // Here we are comparing point references, not values        \n\t    if ((q === points[0] && p === points[1]) || (q === points[1] && p === points[0])) {\n\t        this.constrained_edge[2] = true;\n\t    } else if ((q === points[0] && p === points[2]) || (q === points[2] && p === points[0])) {\n\t        this.constrained_edge[1] = true;\n\t    } else if ((q === points[1] && p === points[2]) || (q === points[2] && p === points[1])) {\n\t        this.constrained_edge[0] = true;\n\t    }\n\t};\n\t\n\t\n\t// ---------------------------------------------------------Exports (public API)\n\t\n\tmodule.exports = Triangle;\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t// Copyright 2014-2016 Todd Fleming\n\t//\n\t// This program is free software: you can redistribute it and/or modify\n\t// it under the terms of the GNU Affero General Public License as published by\n\t// the Free Software Foundation, either version 3 of the License, or\n\t// (at your option) any later version.\n\t// \n\t// This program is distributed in the hope that it will be useful,\n\t// but WITHOUT ANY WARRANTY; without even the implied warranty of\n\t// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\t// GNU Affero General Public License for more details.\n\t// \n\t// You should have received a copy of the GNU Affero General Public License\n\t// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\t\n\t// TODO: pass React elements to alertFn\n\t\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.arcTolerance = exports.cleanPolyDist = exports.clipperToCppScale = exports.mmToClipperScale = exports.inchToClipperScale = undefined;\n\texports.elementToRawPaths = elementToRawPaths;\n\texports.flipY = flipY;\n\texports.hasClosedRawPaths = hasClosedRawPaths;\n\texports.filterClosedRawPaths = filterClosedRawPaths;\n\texports.rawPathsToClipperPaths = rawPathsToClipperPaths;\n\texports.triangulateRawPaths = triangulateRawPaths;\n\texports.clipperPathsToCPaths = clipperPathsToCPaths;\n\texports.cPathsToClipperPaths = cPathsToClipperPaths;\n\texports.cPathsToCamPaths = cPathsToCamPaths;\n\texports.clipperBounds = clipperBounds;\n\texports.clip = clip;\n\texports.union = union;\n\texports.diff = diff;\n\texports.xor = xor;\n\texports.offset = offset;\n\t\n\tvar _clipperLib = __webpack_require__(6);\n\t\n\tvar _clipperLib2 = _interopRequireDefault(_clipperLib);\n\t\n\tvar _sweepcontext = __webpack_require__(11);\n\t\n\tvar _sweepcontext2 = _interopRequireDefault(_sweepcontext);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar inchToClipperScale = exports.inchToClipperScale = 1270000000;\n\tvar mmToClipperScale = exports.mmToClipperScale = inchToClipperScale / 25.4; // 50000000;\n\tvar clipperToCppScale = exports.clipperToCppScale = 1 / 128; // Prevent overflow for coordinates up to ~1000 mm\n\tvar cleanPolyDist = exports.cleanPolyDist = 100;\n\tvar arcTolerance = exports.arcTolerance = 10000;\n\t\n\t// Linearize a cubic bezier. Returns ['L', x2, y2, x3, y3, ...]. The return value doesn't\n\t// include (p1x, p1y); it's part of the previous segment.\n\tfunction linearizeCubicBezier(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, minNumSegments, minSegmentLength) {\n\t    function bez(p0, p1, p2, p3, t) {\n\t        return (1 - t) * (1 - t) * (1 - t) * p0 + 3 * (1 - t) * (1 - t) * t * p1 + 3 * (1 - t) * t * t * p2 + t * t * t * p3;\n\t    }\n\t\n\t    if (p1x == c1x && p1y == c1y && p2x == c2x && p2y == c2y) return ['L', p2x, p2y];\n\t\n\t    var numSegments = minNumSegments;\n\t    while (true) {\n\t        var x = p1x;\n\t        var y = p1y;\n\t        var result = ['L'];\n\t        for (var i = 1; i <= numSegments; ++i) {\n\t            var t = 1.0 * i / numSegments;\n\t            var nextX = bez(p1x, c1x, c2x, p2x, t);\n\t            var nextY = bez(p1y, c1y, c2y, p2y, t);\n\t            if ((nextX - x) * (nextX - x) + (nextY - y) * (nextY - y) > minSegmentLength * minSegmentLength) {\n\t                numSegments *= 2;\n\t                result = null;\n\t                break;\n\t            }\n\t            result.push(nextX, nextY);\n\t            x = nextX;\n\t            y = nextY;\n\t        }\n\t        if (result) return result;\n\t    }\n\t}\n\t\n\t// Linearize a path. Both the input path and the returned path are in snap.svg's format.\n\t// Calls alertFn with an error message and returns null if there's a problem.\n\tfunction linearizeSnapPath(path, minNumSegments, minSegmentLength, alertFn) {\n\t    if (path.length < 2 || path[0].length != 3 || path[0][0] != 'M') {\n\t        alertFn('Path does not begin with M');\n\t        return null;\n\t    }\n\t    var x = path[0][1];\n\t    var y = path[0][2];\n\t    var result = [path[0]];\n\t    for (var i = 1; i < path.length; ++i) {\n\t        var subpath = path[i];\n\t        if (subpath[0] == 'C' && subpath.length == 7) {\n\t            result.push(linearizeCubicBezier(x, y, subpath[1], subpath[2], subpath[3], subpath[4], subpath[5], subpath[6], minNumSegments, minSegmentLength));\n\t            x = subpath[5];\n\t            y = subpath[6];\n\t        } else if (subpath[0] == 'M' && subpath.length == 3) {\n\t            result.push(subpath);\n\t            x = subpath[1];\n\t            y = subpath[2];\n\t        } else {\n\t            alertFn('Subpath has an unknown prefix: ' + subpath[0]);\n\t            return null;\n\t        }\n\t    }\n\t    return result;\n\t};\n\t\n\t// Get linear paths (snap format) from an SVG element. Calls alertFn with an \n\t// error message and returns null if there's a problem.\n\tfunction elementToLinearSnapPaths(element, minNumSegments, minSegmentLength, alertFn) {\n\t    var path = null;\n\t    var Snap = __webpack_require__(13);\n\t    var snapElement = Snap(element);\n\t\n\t    if (snapElement.type == 'path') path = snapElement.attr('d');else if (snapElement.type == 'rect') {\n\t        var x = Number(snapElement.attr('x'));\n\t        var y = Number(snapElement.attr('y'));\n\t        var w = Number(snapElement.attr('width'));\n\t        var h = Number(snapElement.attr('height'));\n\t        path = 'm' + x + ',' + y + ' ' + w + ',' + 0 + ' ' + 0 + ',' + h + ' ' + -w + ',' + 0 + ' ' + 0 + ',' + -h + ' ';\n\t    } else {\n\t        alertFn('<b>' + snapElement.type + \"</b> is not supported; try Inkscape's <strong>Object to Path</strong> command\");\n\t        return null;\n\t    }\n\t\n\t    if (snapElement.attr('clip-path') != '') {\n\t        alertFn('clip-path is not supported');\n\t        return null;\n\t    }\n\t\n\t    if (snapElement.attr('mask') != '') {\n\t        alertFn('mask is not supported');\n\t        return null;\n\t    }\n\t\n\t    if (path == null) {\n\t        alertFn('path is missing');\n\t        return;\n\t    }\n\t\n\t    path = Snap.path.map(path, snapElement.transform().globalMatrix);\n\t    path = Snap.parsePathString(path);\n\t    path = linearizeSnapPath(path, minNumSegments, minSegmentLength, alertFn);\n\t    return path;\n\t};\n\t\n\t// Convert a path in snap.svg format to [[x0, y0, x1, y1, ...], ...].\n\t// Result is in mm. Returns multiple paths. Only supports linear paths.\n\t// Calls alertFn with an error message and returns null if there's a problem.\n\tfunction snapPathToRawPaths(snapPath, pxPerInch, alertFn) {\n\t    var factor = 25.4 / pxPerInch;\n\t    if (snapPath.length < 2 || snapPath[0].length != 3 || snapPath[0][0] != 'M') {\n\t        alertFn('Path does not begin with M');\n\t        return null;\n\t    }\n\t    var currentPath = [snapPath[0][1] * factor, snapPath[0][2] * factor];\n\t    var result = [currentPath];\n\t    for (var i = 1; i < snapPath.length; ++i) {\n\t        var subpath = snapPath[i];\n\t        if (subpath[0] == 'M' && subpath.length == 3) {\n\t            currentPath = [subpath[1] * factor, subpath[2] * factor];\n\t            result.push(currentPath);\n\t        } else if (subpath[0] == 'L') {\n\t            for (var j = 0; j < (subpath.length - 1) / 2; ++j) {\n\t                currentPath.push(subpath[1 + j * 2] * factor, subpath[2 + j * 2] * factor);\n\t            }\n\t        } else {\n\t            alertFn('Subpath has a non-linear prefix: ' + subpath[0]);\n\t            return null;\n\t        }\n\t    }\n\t    return result;\n\t};\n\t\n\t// Convert a path in an SVG element to [[x0, y0, x1, y1, ...], ...].\n\t// Result is in mm. Returns multiple paths. Converts curves.\n\t// Calls alertFn with an error message and returns null if there's a problem.\n\tfunction elementToRawPaths(element, pxPerInch, minNumSegments, minSegmentLength, alertFn) {\n\t    var path = elementToLinearSnapPaths(element, minNumSegments, minSegmentLength, alertFn);\n\t    if (path !== null) return snapPathToRawPaths(path, pxPerInch, alertFn);\n\t    return null;\n\t}\n\t\n\t// [[[x0, y0, x1, y1, ...], ...], ...]\n\tfunction flipY(allRawPaths, deltaY) {\n\t    var _iteratorNormalCompletion = true;\n\t    var _didIteratorError = false;\n\t    var _iteratorError = undefined;\n\t\n\t    try {\n\t        for (var _iterator = allRawPaths[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t            var rawPaths = _step.value;\n\t            var _iteratorNormalCompletion2 = true;\n\t            var _didIteratorError2 = false;\n\t            var _iteratorError2 = undefined;\n\t\n\t            try {\n\t                for (var _iterator2 = rawPaths[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t                    var rawPath = _step2.value;\n\t\n\t                    for (var i = 0; i < rawPath.length; i += 2) {\n\t                        rawPath[i + 1] = deltaY - rawPath[i + 1];\n\t                    }\n\t                }\n\t            } catch (err) {\n\t                _didIteratorError2 = true;\n\t                _iteratorError2 = err;\n\t            } finally {\n\t                try {\n\t                    if (!_iteratorNormalCompletion2 && _iterator2.return) {\n\t                        _iterator2.return();\n\t                    }\n\t                } finally {\n\t                    if (_didIteratorError2) {\n\t                        throw _iteratorError2;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    } catch (err) {\n\t        _didIteratorError = true;\n\t        _iteratorError = err;\n\t    } finally {\n\t        try {\n\t            if (!_iteratorNormalCompletion && _iterator.return) {\n\t                _iterator.return();\n\t            }\n\t        } finally {\n\t            if (_didIteratorError) {\n\t                throw _iteratorError;\n\t            }\n\t        }\n\t    }\n\t}\n\t\n\tfunction hasClosedRawPaths(rawPaths) {\n\t    var _iteratorNormalCompletion3 = true;\n\t    var _didIteratorError3 = false;\n\t    var _iteratorError3 = undefined;\n\t\n\t    try {\n\t        for (var _iterator3 = rawPaths[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n\t            var path = _step3.value;\n\t\n\t            if (path.length >= 4 && path[0] == path[path.length - 2] && path[1] == path[path.length - 1]) return true;\n\t        }\n\t    } catch (err) {\n\t        _didIteratorError3 = true;\n\t        _iteratorError3 = err;\n\t    } finally {\n\t        try {\n\t            if (!_iteratorNormalCompletion3 && _iterator3.return) {\n\t                _iterator3.return();\n\t            }\n\t        } finally {\n\t            if (_didIteratorError3) {\n\t                throw _iteratorError3;\n\t            }\n\t        }\n\t    }\n\t\n\t    return false;\n\t}\n\t\n\tfunction filterClosedRawPaths(rawPaths) {\n\t    var result = [];\n\t    var _iteratorNormalCompletion4 = true;\n\t    var _didIteratorError4 = false;\n\t    var _iteratorError4 = undefined;\n\t\n\t    try {\n\t        for (var _iterator4 = rawPaths[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n\t            var path = _step4.value;\n\t\n\t            if (path.length >= 4 && path[0] == path[path.length - 2] && path[1] == path[path.length - 1]) result.push(path);\n\t        }\n\t    } catch (err) {\n\t        _didIteratorError4 = true;\n\t        _iteratorError4 = err;\n\t    } finally {\n\t        try {\n\t            if (!_iteratorNormalCompletion4 && _iterator4.return) {\n\t                _iterator4.return();\n\t            }\n\t        } finally {\n\t            if (_didIteratorError4) {\n\t                throw _iteratorError4;\n\t            }\n\t        }\n\t    }\n\t\n\t    return result;\n\t}\n\t\n\tfunction rawPathsToClipperPaths(rawPaths, scaleX, scaleY, translateX, translateY) {\n\t    var result = rawPaths.map(function (p) {\n\t        var result = [];\n\t        for (var i = 0; i < p.length; i += 2) {\n\t            result.push({ X: (p[i] * scaleX + translateX) * mmToClipperScale, Y: (p[i + 1] * scaleY + translateY) * mmToClipperScale });\n\t        }return result;\n\t    });\n\t    if (hasClosedRawPaths(rawPaths)) {\n\t        result = _clipperLib2.default.Clipper.CleanPolygons(result, cleanPolyDist);\n\t        result = _clipperLib2.default.Clipper.SimplifyPolygons(result, _clipperLib2.default.PolyFillType.pftEvenOdd);\n\t    }\n\t    return result;\n\t}\n\t\n\tfunction clipperPathsToPolyTree(paths) {\n\t    var c = new _clipperLib2.default.Clipper();\n\t    c.AddPaths(paths, _clipperLib2.default.PolyType.ptSubject, true);\n\t    var polyTree = new _clipperLib2.default.PolyTree();\n\t    c.Execute(_clipperLib2.default.ClipType.ctUnion, polyTree, _clipperLib2.default.PolyFillType.pftEvenOdd, _clipperLib2.default.PolyFillType.pftEvenOdd);\n\t    return polyTree;\n\t}\n\t\n\tfunction triangulatePolyTree(polyTree) {\n\t    var result = [];\n\t    var pointToVertex = function pointToVertex(point) {\n\t        return { x: point.X / mmToClipperScale, y: point.Y / mmToClipperScale };\n\t    };\n\t    var contourToVertexes = function contourToVertexes(path) {\n\t        return path.map(pointToVertex);\n\t    };\n\t    var nodesToVertexes = function nodesToVertexes(nodes) {\n\t        return nodes.map(function (node) {\n\t            return contourToVertexes(node.Contour());\n\t        });\n\t    };\n\t    var processNode = function processNode(node) {\n\t        var vertexes = contourToVertexes(node.Contour());\n\t        var holes = nodesToVertexes(node.Childs());\n\t        var context = new _sweepcontext2.default(vertexes);\n\t        context.addHoles(holes);\n\t        context.triangulate();\n\t        var triangles = context.getTriangles();\n\t        var _iteratorNormalCompletion5 = true;\n\t        var _didIteratorError5 = false;\n\t        var _iteratorError5 = undefined;\n\t\n\t        try {\n\t            for (var _iterator5 = triangles[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n\t                var t = _step5.value;\n\t\n\t                var p = t.getPoints();\n\t                result.push(p[0].x, p[0].y, p[1].x, p[1].y, p[2].x, p[2].y);\n\t            }\n\t        } catch (err) {\n\t            _didIteratorError5 = true;\n\t            _iteratorError5 = err;\n\t        } finally {\n\t            try {\n\t                if (!_iteratorNormalCompletion5 && _iterator5.return) {\n\t                    _iterator5.return();\n\t                }\n\t            } finally {\n\t                if (_didIteratorError5) {\n\t                    throw _iteratorError5;\n\t                }\n\t            }\n\t        }\n\t\n\t        var _iteratorNormalCompletion6 = true;\n\t        var _didIteratorError6 = false;\n\t        var _iteratorError6 = undefined;\n\t\n\t        try {\n\t            for (var _iterator6 = node.Childs()[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n\t                var hole = _step6.value;\n\t                var _iteratorNormalCompletion7 = true;\n\t                var _didIteratorError7 = false;\n\t                var _iteratorError7 = undefined;\n\t\n\t                try {\n\t                    for (var _iterator7 = hole.Childs()[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n\t                        var next = _step7.value;\n\t\n\t                        processNode(next);\n\t                    }\n\t                } catch (err) {\n\t                    _didIteratorError7 = true;\n\t                    _iteratorError7 = err;\n\t                } finally {\n\t                    try {\n\t                        if (!_iteratorNormalCompletion7 && _iterator7.return) {\n\t                            _iterator7.return();\n\t                        }\n\t                    } finally {\n\t                        if (_didIteratorError7) {\n\t                            throw _iteratorError7;\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        } catch (err) {\n\t            _didIteratorError6 = true;\n\t            _iteratorError6 = err;\n\t        } finally {\n\t            try {\n\t                if (!_iteratorNormalCompletion6 && _iterator6.return) {\n\t                    _iterator6.return();\n\t                }\n\t            } finally {\n\t                if (_didIteratorError6) {\n\t                    throw _iteratorError6;\n\t                }\n\t            }\n\t        }\n\t    };\n\t    var _iteratorNormalCompletion8 = true;\n\t    var _didIteratorError8 = false;\n\t    var _iteratorError8 = undefined;\n\t\n\t    try {\n\t        for (var _iterator8 = polyTree.Childs()[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n\t            var node = _step8.value;\n\t\n\t            processNode(node);\n\t        }\n\t    } catch (err) {\n\t        _didIteratorError8 = true;\n\t        _iteratorError8 = err;\n\t    } finally {\n\t        try {\n\t            if (!_iteratorNormalCompletion8 && _iterator8.return) {\n\t                _iterator8.return();\n\t            }\n\t        } finally {\n\t            if (_didIteratorError8) {\n\t                throw _iteratorError8;\n\t            }\n\t        }\n\t    }\n\t\n\t    return result;\n\t}\n\t\n\tfunction triangulateRawPaths(rawPaths) {\n\t    return triangulatePolyTree(clipperPathsToPolyTree(rawPathsToClipperPaths(rawPaths, 1, 1, 0, 0)));\n\t}\n\t\n\t// Convert Clipper paths to C. Returns [double** cPaths, int cNumPaths, int* cPathSizes].\n\tfunction clipperPathsToCPaths(memoryBlocks, clipperPaths) {\n\t    var doubleSize = 8;\n\t\n\t    var cPaths = Module._malloc(clipperPaths.length * 4);\n\t    memoryBlocks.push(cPaths);\n\t    var cPathsBase = cPaths >> 2;\n\t\n\t    var cPathSizes = Module._malloc(clipperPaths.length * 4);\n\t    memoryBlocks.push(cPathSizes);\n\t    var cPathSizesBase = cPathSizes >> 2;\n\t\n\t    for (var i = 0; i < clipperPaths.length; ++i) {\n\t        var clipperPath = clipperPaths[i];\n\t\n\t        var cPath = Module._malloc(clipperPath.length * 2 * doubleSize + 4);\n\t        memoryBlocks.push(cPath);\n\t        if (cPath & 4) cPath += 4;\n\t        //console.log(\"-> \" + cPath.toString(16));\n\t        var pathArray = new Float64Array(Module.HEAPU32.buffer, Module.HEAPU32.byteOffset + cPath);\n\t\n\t        for (var j = 0; j < clipperPath.length; ++j) {\n\t            var point = clipperPath[j];\n\t            pathArray[j * 2] = point.X * clipperToCppScale;\n\t            pathArray[j * 2 + 1] = point.Y * clipperToCppScale;\n\t        }\n\t\n\t        Module.HEAPU32[cPathsBase + i] = cPath;\n\t        Module.HEAPU32[cPathSizesBase + i] = clipperPath.length;\n\t    }\n\t\n\t    return [cPaths, clipperPaths.length, cPathSizes];\n\t}\n\t\n\t// Convert C paths to Clipper paths. double**& cPathsRef, int& cNumPathsRef, int*& cPathSizesRef\n\t// Each point has X, Y (stride = 2).\n\tfunction cPathsToClipperPaths(memoryBlocks, cPathsRef, cNumPathsRef, cPathSizesRef) {\n\t    var cPaths = Module.HEAPU32[cPathsRef >> 2];\n\t    memoryBlocks.push(cPaths);\n\t    var cPathsBase = cPaths >> 2;\n\t\n\t    var cNumPaths = Module.HEAPU32[cNumPathsRef >> 2];\n\t\n\t    var cPathSizes = Module.HEAPU32[cPathSizesRef >> 2];\n\t    memoryBlocks.push(cPathSizes);\n\t    var cPathSizesBase = cPathSizes >> 2;\n\t\n\t    var clipperPaths = [];\n\t    for (var i = 0; i < cNumPaths; ++i) {\n\t        var pathSize = Module.HEAPU32[cPathSizesBase + i];\n\t        var cPath = Module.HEAPU32[cPathsBase + i];\n\t        // cPath contains value to pass to Module._free(). The aligned version contains the actual data.\n\t        memoryBlocks.push(cPath);\n\t        if (cPath & 4) cPath += 4;\n\t        var pathArray = new Float64Array(Module.HEAPU32.buffer, Module.HEAPU32.byteOffset + cPath);\n\t\n\t        var clipperPath = [];\n\t        clipperPaths.push(clipperPath);\n\t        for (var j = 0; j < pathSize; ++j) {\n\t            clipperPath.push({\n\t                X: pathArray[j * 2] / clipperToCppScale,\n\t                Y: pathArray[j * 2 + 1] / clipperToCppScale\n\t            });\n\t        }\n\t    }\n\t\n\t    return clipperPaths;\n\t}\n\t\n\t// Convert C paths to array of CamPath. double**& cPathsRef, int& cNumPathsRef, int*& cPathSizesRef\n\t// Each point has X, Y, Z (stride = 3).\n\tfunction cPathsToCamPaths(memoryBlocks, cPathsRef, cNumPathsRef, cPathSizesRef) {\n\t    var cPaths = Module.HEAPU32[cPathsRef >> 2];\n\t    memoryBlocks.push(cPaths);\n\t    var cPathsBase = cPaths >> 2;\n\t\n\t    var cNumPaths = Module.HEAPU32[cNumPathsRef >> 2];\n\t\n\t    var cPathSizes = Module.HEAPU32[cPathSizesRef >> 2];\n\t    memoryBlocks.push(cPathSizes);\n\t    var cPathSizesBase = cPathSizes >> 2;\n\t\n\t    var convertedPaths = [];\n\t    for (var i = 0; i < cNumPaths; ++i) {\n\t        var pathSize = Module.HEAPU32[cPathSizesBase + i];\n\t        var cPath = Module.HEAPU32[cPathsBase + i];\n\t        // cPath contains value to pass to Module._free(). The aligned version contains the actual data.\n\t        memoryBlocks.push(cPath);\n\t        if (cPath & 4) cPath += 4;\n\t        var pathArray = new Float64Array(Module.HEAPU32.buffer, Module.HEAPU32.byteOffset + cPath);\n\t\n\t        var convertedPath = [];\n\t        convertedPaths.push({ path: convertedPath, safeToClose: false });\n\t        for (var j = 0; j < pathSize; ++j) {\n\t            convertedPath.push({\n\t                X: pathArray[j * 3] / clipperToCppScale,\n\t                Y: pathArray[j * 3 + 1] / clipperToCppScale,\n\t                Z: pathArray[j * 3 + 2] / clipperToCppScale\n\t            });\n\t        } //console.log('got: path', i, ':', pathArray[0], pathArray[1], pathArray[2]);\n\t    }\n\t\n\t    return convertedPaths;\n\t}\n\t\n\tfunction clipperBounds(paths) {\n\t    var minX = Number.MAX_VALUE;\n\t    var minY = Number.MAX_VALUE;\n\t    var maxX = -Number.MAX_VALUE;\n\t    var maxY = -Number.MAX_VALUE;\n\t    var _iteratorNormalCompletion9 = true;\n\t    var _didIteratorError9 = false;\n\t    var _iteratorError9 = undefined;\n\t\n\t    try {\n\t        for (var _iterator9 = paths[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n\t            var path = _step9.value;\n\t            var _iteratorNormalCompletion10 = true;\n\t            var _didIteratorError10 = false;\n\t            var _iteratorError10 = undefined;\n\t\n\t            try {\n\t                for (var _iterator10 = path[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {\n\t                    var pt = _step10.value;\n\t\n\t                    minX = Math.min(minX, pt.X);\n\t                    maxX = Math.max(maxX, pt.X);\n\t                    minY = Math.min(minY, pt.Y);\n\t                    maxY = Math.max(maxY, pt.Y);\n\t                }\n\t            } catch (err) {\n\t                _didIteratorError10 = true;\n\t                _iteratorError10 = err;\n\t            } finally {\n\t                try {\n\t                    if (!_iteratorNormalCompletion10 && _iterator10.return) {\n\t                        _iterator10.return();\n\t                    }\n\t                } finally {\n\t                    if (_didIteratorError10) {\n\t                        throw _iteratorError10;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    } catch (err) {\n\t        _didIteratorError9 = true;\n\t        _iteratorError9 = err;\n\t    } finally {\n\t        try {\n\t            if (!_iteratorNormalCompletion9 && _iterator9.return) {\n\t                _iterator9.return();\n\t            }\n\t        } finally {\n\t            if (_didIteratorError9) {\n\t                throw _iteratorError9;\n\t            }\n\t        }\n\t    }\n\t\n\t    return { minX: minX, minY: minY, maxX: maxX, maxY: maxY };\n\t}\n\t\n\t// Clip Clipper geometry. clipType is a ClipperLib.ClipType constant. Returns new geometry.\n\tfunction clip(paths1, paths2, clipType) {\n\t    var clipper = new _clipperLib2.default.Clipper();\n\t    clipper.AddPaths(paths1, _clipperLib2.default.PolyType.ptSubject, true);\n\t    clipper.AddPaths(paths2, _clipperLib2.default.PolyType.ptClip, true);\n\t    var result = [];\n\t    clipper.Execute(clipType, result, _clipperLib2.default.PolyFillType.pftEvenOdd, _clipperLib2.default.PolyFillType.pftEvenOdd);\n\t    return result;\n\t}\n\t\n\t// Return union of two Clipper geometries. Returns new geometry.\n\tfunction union(paths1, paths2) {\n\t    return clip(paths1, paths2, _clipperLib2.default.ClipType.ctUnion);\n\t}\n\t\n\t// Return difference between two Clipper geometries. Returns new geometry.\n\tfunction diff(paths1, paths2) {\n\t    return clip(paths1, paths2, _clipperLib2.default.ClipType.ctDifference);\n\t}\n\t\n\t// Return xor of two Clipper geometries. Returns new geometry.\n\tfunction xor(paths1, paths2) {\n\t    return clip(paths1, paths2, _clipperLib2.default.ClipType.ctXor);\n\t}\n\t\n\t// Offset Clipper geometries by amount (positive expands, negative shrinks). Returns new geometry.\n\tfunction offset(paths, amount, joinType, endType) {\n\t    if (joinType === undefined) joinType = _clipperLib2.default.JoinType.jtRound;\n\t    if (endType === undefined) endType = _clipperLib2.default.EndType.etClosedPolygon;\n\t\n\t    // bug workaround: join types are swapped in ClipperLib 6.1.3.2\n\t    if (joinType === _clipperLib2.default.JoinType.jtSquare) joinType = _clipperLib2.default.JoinType.jtMiter;else if (joinType === _clipperLib2.default.JoinType.jtMiter) joinType = _clipperLib2.default.JoinType.jtSquare;\n\t\n\t    var co = new _clipperLib2.default.ClipperOffset(2, arcTolerance);\n\t    co.AddPaths(paths, joinType, endType);\n\t    var offsetted = [];\n\t    co.Execute(offsetted, amount);\n\t    return offsetted;\n\t}\n\t;\n\t\n\tvar _temp = function () {\n\t    if (typeof __REACT_HOT_LOADER__ === 'undefined') {\n\t        return;\n\t    }\n\t\n\t    __REACT_HOT_LOADER__.register(inchToClipperScale, 'inchToClipperScale', '/Users/jorgerobles/repos_1/LaserWeb4/src/lib/mesh.js');\n\t\n\t    __REACT_HOT_LOADER__.register(mmToClipperScale, 'mmToClipperScale', '/Users/jorgerobles/repos_1/LaserWeb4/src/lib/mesh.js');\n\t\n\t    __REACT_HOT_LOADER__.register(clipperToCppScale, 'clipperToCppScale', '/Users/jorgerobles/repos_1/LaserWeb4/src/lib/mesh.js');\n\t\n\t    __REACT_HOT_LOADER__.register(cleanPolyDist, 'cleanPolyDist', '/Users/jorgerobles/repos_1/LaserWeb4/src/lib/mesh.js');\n\t\n\t    __REACT_HOT_LOADER__.register(arcTolerance, 'arcTolerance', '/Users/jorgerobles/repos_1/LaserWeb4/src/lib/mesh.js');\n\t\n\t    __REACT_HOT_LOADER__.register(linearizeCubicBezier, 'linearizeCubicBezier', '/Users/jorgerobles/repos_1/LaserWeb4/src/lib/mesh.js');\n\t\n\t    __REACT_HOT_LOADER__.register(linearizeSnapPath, 'linearizeSnapPath', '/Users/jorgerobles/repos_1/LaserWeb4/src/lib/mesh.js');\n\t\n\t    __REACT_HOT_LOADER__.register(elementToLinearSnapPaths, 'elementToLinearSnapPaths', '/Users/jorgerobles/repos_1/LaserWeb4/src/lib/mesh.js');\n\t\n\t    __REACT_HOT_LOADER__.register(snapPathToRawPaths, 'snapPathToRawPaths', '/Users/jorgerobles/repos_1/LaserWeb4/src/lib/mesh.js');\n\t\n\t    __REACT_HOT_LOADER__.register(elementToRawPaths, 'elementToRawPaths', '/Users/jorgerobles/repos_1/LaserWeb4/src/lib/mesh.js');\n\t\n\t    __REACT_HOT_LOADER__.register(flipY, 'flipY', '/Users/jorgerobles/repos_1/LaserWeb4/src/lib/mesh.js');\n\t\n\t    __REACT_HOT_LOADER__.register(hasClosedRawPaths, 'hasClosedRawPaths', '/Users/jorgerobles/repos_1/LaserWeb4/src/lib/mesh.js');\n\t\n\t    __REACT_HOT_LOADER__.register(filterClosedRawPaths, 'filterClosedRawPaths', '/Users/jorgerobles/repos_1/LaserWeb4/src/lib/mesh.js');\n\t\n\t    __REACT_HOT_LOADER__.register(rawPathsToClipperPaths, 'rawPathsToClipperPaths', '/Users/jorgerobles/repos_1/LaserWeb4/src/lib/mesh.js');\n\t\n\t    __REACT_HOT_LOADER__.register(clipperPathsToPolyTree, 'clipperPathsToPolyTree', '/Users/jorgerobles/repos_1/LaserWeb4/src/lib/mesh.js');\n\t\n\t    __REACT_HOT_LOADER__.register(triangulatePolyTree, 'triangulatePolyTree', '/Users/jorgerobles/repos_1/LaserWeb4/src/lib/mesh.js');\n\t\n\t    __REACT_HOT_LOADER__.register(triangulateRawPaths, 'triangulateRawPaths', '/Users/jorgerobles/repos_1/LaserWeb4/src/lib/mesh.js');\n\t\n\t    __REACT_HOT_LOADER__.register(clipperPathsToCPaths, 'clipperPathsToCPaths', '/Users/jorgerobles/repos_1/LaserWeb4/src/lib/mesh.js');\n\t\n\t    __REACT_HOT_LOADER__.register(cPathsToClipperPaths, 'cPathsToClipperPaths', '/Users/jorgerobles/repos_1/LaserWeb4/src/lib/mesh.js');\n\t\n\t    __REACT_HOT_LOADER__.register(cPathsToCamPaths, 'cPathsToCamPaths', '/Users/jorgerobles/repos_1/LaserWeb4/src/lib/mesh.js');\n\t\n\t    __REACT_HOT_LOADER__.register(clipperBounds, 'clipperBounds', '/Users/jorgerobles/repos_1/LaserWeb4/src/lib/mesh.js');\n\t\n\t    __REACT_HOT_LOADER__.register(clip, 'clip', '/Users/jorgerobles/repos_1/LaserWeb4/src/lib/mesh.js');\n\t\n\t    __REACT_HOT_LOADER__.register(union, 'union', '/Users/jorgerobles/repos_1/LaserWeb4/src/lib/mesh.js');\n\t\n\t    __REACT_HOT_LOADER__.register(diff, 'diff', '/Users/jorgerobles/repos_1/LaserWeb4/src/lib/mesh.js');\n\t\n\t    __REACT_HOT_LOADER__.register(xor, 'xor', '/Users/jorgerobles/repos_1/LaserWeb4/src/lib/mesh.js');\n\t\n\t    __REACT_HOT_LOADER__.register(offset, 'offset', '/Users/jorgerobles/repos_1/LaserWeb4/src/lib/mesh.js');\n\t}();\n\n\t;\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;// rev 482\n\t/********************************************************************************\n\t *                                                                              *\n\t * Author    :  Angus Johnson                                                   *\n\t * Version   :  6.2.1                                                          *\n\t * Date      :  31 October 2014                                                 *\n\t * Website   :  http://www.angusj.com                                           *\n\t * Copyright :  Angus Johnson 2010-2014                                         *\n\t *                                                                              *\n\t * License:                                                                     *\n\t * Use, modification & distribution is subject to Boost Software License Ver 1. *\n\t * http://www.boost.org/LICENSE_1_0.txt                                         *\n\t *                                                                              *\n\t * Attributions:                                                                *\n\t * The code in this library is an extension of Bala Vatti's clipping algorithm: *\n\t * \"A generic solution to polygon clipping\"                                     *\n\t * Communications of the ACM, Vol 35, Issue 7 (July 1992) pp 56-63.             *\n\t * http://portal.acm.org/citation.cfm?id=129906                                 *\n\t *                                                                              *\n\t * Computer graphics and geometric modeling: implementation and algorithms      *\n\t * By Max K. Agoston                                                            *\n\t * Springer; 1 edition (January 4, 2005)                                        *\n\t * http://books.google.com/books?q=vatti+clipping+agoston                       *\n\t *                                                                              *\n\t * See also:                                                                    *\n\t * \"Polygon Offsetting by Computing Winding Numbers\"                            *\n\t * Paper no. DETC2005-85513 pp. 565-575                                         *\n\t * ASME 2005 International Design Engineering Technical Conferences             *\n\t * and Computers and Information in Engineering Conference (IDETC/CIE2005)      *\n\t * September 24-28, 2005 , Long Beach, California, USA                          *\n\t * http://www.me.berkeley.edu/~mcmains/pubs/DAC05OffsetPolygon.pdf              *\n\t *                                                                              *\n\t *******************************************************************************/\n\t/*******************************************************************************\n\t *                                                                              *\n\t * Author    :  Timo                                                            *\n\t * Version   :  6.2.1.0                                                         *\n\t * Date      :  17 June 2016                                                 *\n\t *                                                                              *\n\t * This is a translation of the C# Clipper library to Javascript.               *\n\t * Int128 struct of C# is implemented using JSBN of Tom Wu.                     *\n\t * Because Javascript lacks support for 64-bit integers, the space              *\n\t * is a little more restricted than in C# version.                              *\n\t *                                                                              *\n\t * C# version has support for coordinate space:                                 *\n\t * +-4611686018427387903 ( sqrt(2^127 -1)/2 )                                   *\n\t * while Javascript version has support for space:                              *\n\t * +-4503599627370495 ( sqrt(2^106 -1)/2 )                                      *\n\t *                                                                              *\n\t * Tom Wu's JSBN proved to be the fastest big integer library:                  *\n\t * http://jsperf.com/big-integer-library-test                                   *\n\t *                                                                              *\n\t * This class can be made simpler when (if ever) 64-bit integer support comes.  *\n\t *                                                                              *\n\t *******************************************************************************/\n\t/*******************************************************************************\n\t *                                                                              *\n\t * Basic JavaScript BN library - subset useful for RSA encryption.              *\n\t * http://www-cs-students.stanford.edu/~tjw/jsbn/                               *\n\t * Copyright (c) 2005  Tom Wu                                                   *\n\t * All Rights Reserved.                                                         *\n\t * See \"LICENSE\" for details:                                                   *\n\t * http://www-cs-students.stanford.edu/~tjw/jsbn/LICENSE                        *\n\t *                                                                              *\n\t *******************************************************************************/\n\t(function ()\n\t{\n\t  \"use strict\";\n\t  //use_int32: When enabled 32bit ints are used instead of 64bit ints. This\n\t  //improve performance but coordinate values are limited to the range +/- 46340\n\t  var use_int32 = false;\n\t  //use_xyz: adds a Z member to IntPoint. Adds a minor cost to performance.\n\t  var use_xyz = false;\n\t  //UseLines: Enables open path clipping. Adds a very minor cost to performance.\n\t  var use_lines = true;\n\t\n\t  var ClipperLib = {};\n\t  var isNode = false;\n\t  if (typeof module !== 'undefined' && module.exports)\n\t  {\n\t    module.exports = ClipperLib;\n\t    isNode = true;\n\t  }\n\t  else\n\t  {\n\t    if (true) {\n\t      !(__WEBPACK_AMD_DEFINE_FACTORY__ = (ClipperLib), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t    if (typeof (document) !== \"undefined\") window.ClipperLib = ClipperLib;\n\t    else self['ClipperLib'] = ClipperLib;\n\t  }\n\t  var navigator_appName;\n\t  if (!isNode)\n\t  {\n\t    var nav = navigator.userAgent.toString().toLowerCase();\n\t    navigator_appName = navigator.appName;\n\t  }\n\t  else\n\t  {\n\t    var nav = \"chrome\"; // Node.js uses Chrome's V8 engine\n\t    navigator_appName = \"Netscape\"; // Firefox, Chrome and Safari returns \"Netscape\", so Node.js should also\n\t  }\n\t  // Browser test to speedup performance critical functions\n\t  var browser = {};\n\t  if (nav.indexOf(\"chrome\") != -1 && nav.indexOf(\"chromium\") == -1) browser.chrome = 1;\n\t  else browser.chrome = 0;\n\t  if (nav.indexOf(\"chromium\") != -1) browser.chromium = 1;\n\t  else browser.chromium = 0;\n\t  if (nav.indexOf(\"safari\") != -1 && nav.indexOf(\"chrome\") == -1 && nav.indexOf(\"chromium\") == -1) browser.safari = 1;\n\t  else browser.safari = 0;\n\t  if (nav.indexOf(\"firefox\") != -1) browser.firefox = 1;\n\t  else browser.firefox = 0;\n\t  if (nav.indexOf(\"firefox/17\") != -1) browser.firefox17 = 1;\n\t  else browser.firefox17 = 0;\n\t  if (nav.indexOf(\"firefox/15\") != -1) browser.firefox15 = 1;\n\t  else browser.firefox15 = 0;\n\t  if (nav.indexOf(\"firefox/3\") != -1) browser.firefox3 = 1;\n\t  else browser.firefox3 = 0;\n\t  if (nav.indexOf(\"opera\") != -1) browser.opera = 1;\n\t  else browser.opera = 0;\n\t  if (nav.indexOf(\"msie 10\") != -1) browser.msie10 = 1;\n\t  else browser.msie10 = 0;\n\t  if (nav.indexOf(\"msie 9\") != -1) browser.msie9 = 1;\n\t  else browser.msie9 = 0;\n\t  if (nav.indexOf(\"msie 8\") != -1) browser.msie8 = 1;\n\t  else browser.msie8 = 0;\n\t  if (nav.indexOf(\"msie 7\") != -1) browser.msie7 = 1;\n\t  else browser.msie7 = 0;\n\t  if (nav.indexOf(\"msie \") != -1) browser.msie = 1;\n\t  else browser.msie = 0;\n\t  ClipperLib.biginteger_used = null;\n\t\n\t  // Copyright (c) 2005  Tom Wu\n\t  // All Rights Reserved.\n\t  // See \"LICENSE\" for details.\n\t  // Basic JavaScript BN library - subset useful for RSA encryption.\n\t  // Bits per digit\n\t  var dbits;\n\t  // JavaScript engine analysis\n\t  var canary = 0xdeadbeefcafe;\n\t  var j_lm = ((canary & 0xffffff) == 0xefcafe);\n\t  // (public) Constructor\n\t  function BigInteger(a, b, c)\n\t  {\n\t    // This test variable can be removed,\n\t    // but at least for performance tests it is useful piece of knowledge\n\t    // This is the only ClipperLib related variable in BigInteger library\n\t    ClipperLib.biginteger_used = 1;\n\t    if (a != null)\n\t      if (\"number\" == typeof a && \"undefined\" == typeof (b)) this.fromInt(a); // faster conversion\n\t      else if (\"number\" == typeof a) this.fromNumber(a, b, c);\n\t    else if (b == null && \"string\" != typeof a) this.fromString(a, 256);\n\t    else this.fromString(a, b);\n\t  }\n\t  // return new, unset BigInteger\n\t  function nbi()\n\t  {\n\t    return new BigInteger(null,undefined,undefined);\n\t  }\n\t  // am: Compute w_j += (x*this_i), propagate carries,\n\t  // c is initial carry, returns final carry.\n\t  // c < 3*dvalue, x < 2*dvalue, this_i < dvalue\n\t  // We need to select the fastest one that works in this environment.\n\t  // am1: use a single mult and divide to get the high bits,\n\t  // max digit bits should be 26 because\n\t  // max internal value = 2*dvalue^2-2*dvalue (< 2^53)\n\t  function am1(i, x, w, j, c, n)\n\t  {\n\t    while (--n >= 0)\n\t    {\n\t      var v = x * this[i++] + w[j] + c;\n\t      c = Math.floor(v / 0x4000000);\n\t      w[j++] = v & 0x3ffffff;\n\t    }\n\t    return c;\n\t  }\n\t  // am2 avoids a big mult-and-extract completely.\n\t  // Max digit bits should be <= 30 because we do bitwise ops\n\t  // on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)\n\t  function am2(i, x, w, j, c, n)\n\t  {\n\t    var xl = x & 0x7fff,\n\t      xh = x >> 15;\n\t    while (--n >= 0)\n\t    {\n\t      var l = this[i] & 0x7fff;\n\t      var h = this[i++] >> 15;\n\t      var m = xh * l + h * xl;\n\t      l = xl * l + ((m & 0x7fff) << 15) + w[j] + (c & 0x3fffffff);\n\t      c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);\n\t      w[j++] = l & 0x3fffffff;\n\t    }\n\t    return c;\n\t  }\n\t  // Alternately, set max digit bits to 28 since some\n\t  // browsers slow down when dealing with 32-bit numbers.\n\t  function am3(i, x, w, j, c, n)\n\t  {\n\t    var xl = x & 0x3fff,\n\t      xh = x >> 14;\n\t    while (--n >= 0)\n\t    {\n\t      var l = this[i] & 0x3fff;\n\t      var h = this[i++] >> 14;\n\t      var m = xh * l + h * xl;\n\t      l = xl * l + ((m & 0x3fff) << 14) + w[j] + c;\n\t      c = (l >> 28) + (m >> 14) + xh * h;\n\t      w[j++] = l & 0xfffffff;\n\t    }\n\t    return c;\n\t  }\n\t  if (j_lm && (navigator_appName == \"Microsoft Internet Explorer\"))\n\t  {\n\t    BigInteger.prototype.am = am2;\n\t    dbits = 30;\n\t  }\n\t  else if (j_lm && (navigator_appName != \"Netscape\"))\n\t  {\n\t    BigInteger.prototype.am = am1;\n\t    dbits = 26;\n\t  }\n\t  else\n\t  { // Mozilla/Netscape seems to prefer am3\n\t    BigInteger.prototype.am = am3;\n\t    dbits = 28;\n\t  }\n\t  BigInteger.prototype.DB = dbits;\n\t  BigInteger.prototype.DM = ((1 << dbits) - 1);\n\t  BigInteger.prototype.DV = (1 << dbits);\n\t  var BI_FP = 52;\n\t  BigInteger.prototype.FV = Math.pow(2, BI_FP);\n\t  BigInteger.prototype.F1 = BI_FP - dbits;\n\t  BigInteger.prototype.F2 = 2 * dbits - BI_FP;\n\t  // Digit conversions\n\t  var BI_RM = \"0123456789abcdefghijklmnopqrstuvwxyz\";\n\t  var BI_RC = new Array();\n\t  var rr, vv;\n\t  rr = \"0\".charCodeAt(0);\n\t  for (vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;\n\t  rr = \"a\".charCodeAt(0);\n\t  for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\n\t  rr = \"A\".charCodeAt(0);\n\t  for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\n\t\n\t  function int2char(n)\n\t  {\n\t    return BI_RM.charAt(n);\n\t  }\n\t\n\t  function intAt(s, i)\n\t  {\n\t    var c = BI_RC[s.charCodeAt(i)];\n\t    return (c == null) ? -1 : c;\n\t  }\n\t  // (protected) copy this to r\n\t  function bnpCopyTo(r)\n\t  {\n\t    for (var i = this.t - 1; i >= 0; --i) r[i] = this[i];\n\t    r.t = this.t;\n\t    r.s = this.s;\n\t  }\n\t  // (protected) set from integer value x, -DV <= x < DV\n\t  function bnpFromInt(x)\n\t  {\n\t    this.t = 1;\n\t    this.s = (x < 0) ? -1 : 0;\n\t    if (x > 0) this[0] = x;\n\t    else if (x < -1) this[0] = x + this.DV;\n\t    else this.t = 0;\n\t  }\n\t  // return bigint initialized to value\n\t  function nbv(i)\n\t  {\n\t    var r = nbi();\n\t    r.fromInt(i);\n\t    return r;\n\t  }\n\t  // (protected) set from string and radix\n\t  function bnpFromString(s, b)\n\t  {\n\t    var k;\n\t    if (b == 16) k = 4;\n\t    else if (b == 8) k = 3;\n\t    else if (b == 256) k = 8; // byte array\n\t    else if (b == 2) k = 1;\n\t    else if (b == 32) k = 5;\n\t    else if (b == 4) k = 2;\n\t    else\n\t    {\n\t      this.fromRadix(s, b);\n\t      return;\n\t    }\n\t    this.t = 0;\n\t    this.s = 0;\n\t    var i = s.length,\n\t      mi = false,\n\t      sh = 0;\n\t    while (--i >= 0)\n\t    {\n\t      var x = (k == 8) ? s[i] & 0xff : intAt(s, i);\n\t      if (x < 0)\n\t      {\n\t        if (s.charAt(i) == \"-\") mi = true;\n\t        continue;\n\t      }\n\t      mi = false;\n\t      if (sh == 0)\n\t        this[this.t++] = x;\n\t      else if (sh + k > this.DB)\n\t      {\n\t        this[this.t - 1] |= (x & ((1 << (this.DB - sh)) - 1)) << sh;\n\t        this[this.t++] = (x >> (this.DB - sh));\n\t      }\n\t      else\n\t        this[this.t - 1] |= x << sh;\n\t      sh += k;\n\t      if (sh >= this.DB) sh -= this.DB;\n\t    }\n\t    if (k == 8 && (s[0] & 0x80) != 0)\n\t    {\n\t      this.s = -1;\n\t      if (sh > 0) this[this.t - 1] |= ((1 << (this.DB - sh)) - 1) << sh;\n\t    }\n\t    this.clamp();\n\t    if (mi) BigInteger.ZERO.subTo(this, this);\n\t  }\n\t  // (protected) clamp off excess high words\n\t  function bnpClamp()\n\t  {\n\t    var c = this.s & this.DM;\n\t    while (this.t > 0 && this[this.t - 1] == c)--this.t;\n\t  }\n\t  // (public) return string representation in given radix\n\t  function bnToString(b)\n\t  {\n\t    if (this.s < 0) return \"-\" + this.negate().toString(b);\n\t    var k;\n\t    if (b == 16) k = 4;\n\t    else if (b == 8) k = 3;\n\t    else if (b == 2) k = 1;\n\t    else if (b == 32) k = 5;\n\t    else if (b == 4) k = 2;\n\t    else return this.toRadix(b);\n\t    var km = (1 << k) - 1,\n\t      d, m = false,\n\t      r = \"\",\n\t      i = this.t;\n\t    var p = this.DB - (i * this.DB) % k;\n\t    if (i-- > 0)\n\t    {\n\t      if (p < this.DB && (d = this[i] >> p) > 0)\n\t      {\n\t        m = true;\n\t        r = int2char(d);\n\t      }\n\t      while (i >= 0)\n\t      {\n\t        if (p < k)\n\t        {\n\t          d = (this[i] & ((1 << p) - 1)) << (k - p);\n\t          d |= this[--i] >> (p += this.DB - k);\n\t        }\n\t        else\n\t        {\n\t          d = (this[i] >> (p -= k)) & km;\n\t          if (p <= 0)\n\t          {\n\t            p += this.DB;\n\t            --i;\n\t          }\n\t        }\n\t        if (d > 0) m = true;\n\t        if (m) r += int2char(d);\n\t      }\n\t    }\n\t    return m ? r : \"0\";\n\t  }\n\t  // (public) -this\n\t  function bnNegate()\n\t  {\n\t    var r = nbi();\n\t    BigInteger.ZERO.subTo(this, r);\n\t    return r;\n\t  }\n\t  // (public) |this|\n\t  function bnAbs()\n\t  {\n\t    return (this.s < 0) ? this.negate() : this;\n\t  }\n\t  // (public) return + if this > a, - if this < a, 0 if equal\n\t  function bnCompareTo(a)\n\t  {\n\t    var r = this.s - a.s;\n\t    if (r != 0) return r;\n\t    var i = this.t;\n\t    r = i - a.t;\n\t    if (r != 0) return (this.s < 0) ? -r : r;\n\t    while (--i >= 0)\n\t      if ((r = this[i] - a[i]) != 0) return r;\n\t    return 0;\n\t  }\n\t  // returns bit length of the integer x\n\t  function nbits(x)\n\t  {\n\t    var r = 1,\n\t      t;\n\t    if ((t = x >>> 16) != 0)\n\t    {\n\t      x = t;\n\t      r += 16;\n\t    }\n\t    if ((t = x >> 8) != 0)\n\t    {\n\t      x = t;\n\t      r += 8;\n\t    }\n\t    if ((t = x >> 4) != 0)\n\t    {\n\t      x = t;\n\t      r += 4;\n\t    }\n\t    if ((t = x >> 2) != 0)\n\t    {\n\t      x = t;\n\t      r += 2;\n\t    }\n\t    if ((t = x >> 1) != 0)\n\t    {\n\t      x = t;\n\t      r += 1;\n\t    }\n\t    return r;\n\t  }\n\t  // (public) return the number of bits in \"this\"\n\t  function bnBitLength()\n\t  {\n\t    if (this.t <= 0) return 0;\n\t    return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ (this.s & this.DM));\n\t  }\n\t  // (protected) r = this << n*DB\n\t  function bnpDLShiftTo(n, r)\n\t  {\n\t    var i;\n\t    for (i = this.t - 1; i >= 0; --i) r[i + n] = this[i];\n\t    for (i = n - 1; i >= 0; --i) r[i] = 0;\n\t    r.t = this.t + n;\n\t    r.s = this.s;\n\t  }\n\t  // (protected) r = this >> n*DB\n\t  function bnpDRShiftTo(n, r)\n\t  {\n\t    for (var i = n; i < this.t; ++i) r[i - n] = this[i];\n\t    r.t = Math.max(this.t - n, 0);\n\t    r.s = this.s;\n\t  }\n\t  // (protected) r = this << n\n\t  function bnpLShiftTo(n, r)\n\t  {\n\t    var bs = n % this.DB;\n\t    var cbs = this.DB - bs;\n\t    var bm = (1 << cbs) - 1;\n\t    var ds = Math.floor(n / this.DB),\n\t      c = (this.s << bs) & this.DM,\n\t      i;\n\t    for (i = this.t - 1; i >= 0; --i)\n\t    {\n\t      r[i + ds + 1] = (this[i] >> cbs) | c;\n\t      c = (this[i] & bm) << bs;\n\t    }\n\t    for (i = ds - 1; i >= 0; --i) r[i] = 0;\n\t    r[ds] = c;\n\t    r.t = this.t + ds + 1;\n\t    r.s = this.s;\n\t    r.clamp();\n\t  }\n\t  // (protected) r = this >> n\n\t  function bnpRShiftTo(n, r)\n\t  {\n\t    r.s = this.s;\n\t    var ds = Math.floor(n / this.DB);\n\t    if (ds >= this.t)\n\t    {\n\t      r.t = 0;\n\t      return;\n\t    }\n\t    var bs = n % this.DB;\n\t    var cbs = this.DB - bs;\n\t    var bm = (1 << bs) - 1;\n\t    r[0] = this[ds] >> bs;\n\t    for (var i = ds + 1; i < this.t; ++i)\n\t    {\n\t      r[i - ds - 1] |= (this[i] & bm) << cbs;\n\t      r[i - ds] = this[i] >> bs;\n\t    }\n\t    if (bs > 0) r[this.t - ds - 1] |= (this.s & bm) << cbs;\n\t    r.t = this.t - ds;\n\t    r.clamp();\n\t  }\n\t  // (protected) r = this - a\n\t  function bnpSubTo(a, r)\n\t  {\n\t    var i = 0,\n\t      c = 0,\n\t      m = Math.min(a.t, this.t);\n\t    while (i < m)\n\t    {\n\t      c += this[i] - a[i];\n\t      r[i++] = c & this.DM;\n\t      c >>= this.DB;\n\t    }\n\t    if (a.t < this.t)\n\t    {\n\t      c -= a.s;\n\t      while (i < this.t)\n\t      {\n\t        c += this[i];\n\t        r[i++] = c & this.DM;\n\t        c >>= this.DB;\n\t      }\n\t      c += this.s;\n\t    }\n\t    else\n\t    {\n\t      c += this.s;\n\t      while (i < a.t)\n\t      {\n\t        c -= a[i];\n\t        r[i++] = c & this.DM;\n\t        c >>= this.DB;\n\t      }\n\t      c -= a.s;\n\t    }\n\t    r.s = (c < 0) ? -1 : 0;\n\t    if (c < -1) r[i++] = this.DV + c;\n\t    else if (c > 0) r[i++] = c;\n\t    r.t = i;\n\t    r.clamp();\n\t  }\n\t  // (protected) r = this * a, r != this,a (HAC 14.12)\n\t  // \"this\" should be the larger one if appropriate.\n\t  function bnpMultiplyTo(a, r)\n\t  {\n\t    var x = this.abs(),\n\t      y = a.abs();\n\t    var i = x.t;\n\t    r.t = i + y.t;\n\t    while (--i >= 0) r[i] = 0;\n\t    for (i = 0; i < y.t; ++i) r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);\n\t    r.s = 0;\n\t    r.clamp();\n\t    if (this.s != a.s) BigInteger.ZERO.subTo(r, r);\n\t  }\n\t  // (protected) r = this^2, r != this (HAC 14.16)\n\t  function bnpSquareTo(r)\n\t  {\n\t    var x = this.abs();\n\t    var i = r.t = 2 * x.t;\n\t    while (--i >= 0) r[i] = 0;\n\t    for (i = 0; i < x.t - 1; ++i)\n\t    {\n\t      var c = x.am(i, x[i], r, 2 * i, 0, 1);\n\t      if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV)\n\t      {\n\t        r[i + x.t] -= x.DV;\n\t        r[i + x.t + 1] = 1;\n\t      }\n\t    }\n\t    if (r.t > 0) r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);\n\t    r.s = 0;\n\t    r.clamp();\n\t  }\n\t  // (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)\n\t  // r != q, this != m.  q or r may be null.\n\t  function bnpDivRemTo(m, q, r)\n\t  {\n\t    var pm = m.abs();\n\t    if (pm.t <= 0) return;\n\t    var pt = this.abs();\n\t    if (pt.t < pm.t)\n\t    {\n\t      if (q != null) q.fromInt(0);\n\t      if (r != null) this.copyTo(r);\n\t      return;\n\t    }\n\t    if (r == null) r = nbi();\n\t    var y = nbi(),\n\t      ts = this.s,\n\t      ms = m.s;\n\t    var nsh = this.DB - nbits(pm[pm.t - 1]); // normalize modulus\n\t    if (nsh > 0)\n\t    {\n\t      pm.lShiftTo(nsh, y);\n\t      pt.lShiftTo(nsh, r);\n\t    }\n\t    else\n\t    {\n\t      pm.copyTo(y);\n\t      pt.copyTo(r);\n\t    }\n\t    var ys = y.t;\n\t    var y0 = y[ys - 1];\n\t    if (y0 == 0) return;\n\t    var yt = y0 * (1 << this.F1) + ((ys > 1) ? y[ys - 2] >> this.F2 : 0);\n\t    var d1 = this.FV / yt,\n\t      d2 = (1 << this.F1) / yt,\n\t      e = 1 << this.F2;\n\t    var i = r.t,\n\t      j = i - ys,\n\t      t = (q == null) ? nbi() : q;\n\t    y.dlShiftTo(j, t);\n\t    if (r.compareTo(t) >= 0)\n\t    {\n\t      r[r.t++] = 1;\n\t      r.subTo(t, r);\n\t    }\n\t    BigInteger.ONE.dlShiftTo(ys, t);\n\t    t.subTo(y, y); // \"negative\" y so we can replace sub with am later\n\t    while (y.t < ys) y[y.t++] = 0;\n\t    while (--j >= 0)\n\t    {\n\t      // Estimate quotient digit\n\t      var qd = (r[--i] == y0) ? this.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);\n\t      if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd)\n\t      { // Try it out\n\t        y.dlShiftTo(j, t);\n\t        r.subTo(t, r);\n\t        while (r[i] < --qd) r.subTo(t, r);\n\t      }\n\t    }\n\t    if (q != null)\n\t    {\n\t      r.drShiftTo(ys, q);\n\t      if (ts != ms) BigInteger.ZERO.subTo(q, q);\n\t    }\n\t    r.t = ys;\n\t    r.clamp();\n\t    if (nsh > 0) r.rShiftTo(nsh, r); // Denormalize remainder\n\t    if (ts < 0) BigInteger.ZERO.subTo(r, r);\n\t  }\n\t  // (public) this mod a\n\t  function bnMod(a)\n\t  {\n\t    var r = nbi();\n\t    this.abs().divRemTo(a, null, r);\n\t    if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r, r);\n\t    return r;\n\t  }\n\t  // Modular reduction using \"classic\" algorithm\n\t  function Classic(m)\n\t  {\n\t    this.m = m;\n\t  }\n\t\n\t  function cConvert(x)\n\t  {\n\t    if (x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);\n\t    else return x;\n\t  }\n\t\n\t  function cRevert(x)\n\t  {\n\t    return x;\n\t  }\n\t\n\t  function cReduce(x)\n\t  {\n\t    x.divRemTo(this.m, null, x);\n\t  }\n\t\n\t  function cMulTo(x, y, r)\n\t  {\n\t    x.multiplyTo(y, r);\n\t    this.reduce(r);\n\t  }\n\t\n\t  function cSqrTo(x, r)\n\t  {\n\t    x.squareTo(r);\n\t    this.reduce(r);\n\t  }\n\t  Classic.prototype.convert = cConvert;\n\t  Classic.prototype.revert = cRevert;\n\t  Classic.prototype.reduce = cReduce;\n\t  Classic.prototype.mulTo = cMulTo;\n\t  Classic.prototype.sqrTo = cSqrTo;\n\t  // (protected) return \"-1/this % 2^DB\"; useful for Mont. reduction\n\t  // justification:\n\t  //         xy == 1 (mod m)\n\t  //         xy =  1+km\n\t  //   xy(2-xy) = (1+km)(1-km)\n\t  // x[y(2-xy)] = 1-k^2m^2\n\t  // x[y(2-xy)] == 1 (mod m^2)\n\t  // if y is 1/x mod m, then y(2-xy) is 1/x mod m^2\n\t  // should reduce x and y(2-xy) by m^2 at each step to keep size bounded.\n\t  // JS multiply \"overflows\" differently from C/C++, so care is needed here.\n\t  function bnpInvDigit()\n\t  {\n\t    if (this.t < 1) return 0;\n\t    var x = this[0];\n\t    if ((x & 1) == 0) return 0;\n\t    var y = x & 3; // y == 1/x mod 2^2\n\t    y = (y * (2 - (x & 0xf) * y)) & 0xf; // y == 1/x mod 2^4\n\t    y = (y * (2 - (x & 0xff) * y)) & 0xff; // y == 1/x mod 2^8\n\t    y = (y * (2 - (((x & 0xffff) * y) & 0xffff))) & 0xffff; // y == 1/x mod 2^16\n\t    // last step - calculate inverse mod DV directly;\n\t    // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints\n\t    y = (y * (2 - x * y % this.DV)) % this.DV; // y == 1/x mod 2^dbits\n\t    // we really want the negative inverse, and -DV < y < DV\n\t    return (y > 0) ? this.DV - y : -y;\n\t  }\n\t  // Montgomery reduction\n\t  function Montgomery(m)\n\t  {\n\t    this.m = m;\n\t    this.mp = m.invDigit();\n\t    this.mpl = this.mp & 0x7fff;\n\t    this.mph = this.mp >> 15;\n\t    this.um = (1 << (m.DB - 15)) - 1;\n\t    this.mt2 = 2 * m.t;\n\t  }\n\t  // xR mod m\n\t  function montConvert(x)\n\t  {\n\t    var r = nbi();\n\t    x.abs().dlShiftTo(this.m.t, r);\n\t    r.divRemTo(this.m, null, r);\n\t    if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r, r);\n\t    return r;\n\t  }\n\t  // x/R mod m\n\t  function montRevert(x)\n\t  {\n\t    var r = nbi();\n\t    x.copyTo(r);\n\t    this.reduce(r);\n\t    return r;\n\t  }\n\t  // x = x/R mod m (HAC 14.32)\n\t  function montReduce(x)\n\t  {\n\t    while (x.t <= this.mt2) // pad x so am has enough room later\n\t      x[x.t++] = 0;\n\t    for (var i = 0; i < this.m.t; ++i)\n\t    {\n\t      // faster way of calculating u0 = x[i]*mp mod DV\n\t      var j = x[i] & 0x7fff;\n\t      var u0 = (j * this.mpl + (((j * this.mph + (x[i] >> 15) * this.mpl) & this.um) << 15)) & x.DM;\n\t      // use am to combine the multiply-shift-add into one call\n\t      j = i + this.m.t;\n\t      x[j] += this.m.am(0, u0, x, i, 0, this.m.t);\n\t      // propagate carry\n\t      while (x[j] >= x.DV)\n\t      {\n\t        x[j] -= x.DV;\n\t        x[++j]++;\n\t      }\n\t    }\n\t    x.clamp();\n\t    x.drShiftTo(this.m.t, x);\n\t    if (x.compareTo(this.m) >= 0) x.subTo(this.m, x);\n\t  }\n\t  // r = \"x^2/R mod m\"; x != r\n\t  function montSqrTo(x, r)\n\t  {\n\t    x.squareTo(r);\n\t    this.reduce(r);\n\t  }\n\t  // r = \"xy/R mod m\"; x,y != r\n\t  function montMulTo(x, y, r)\n\t  {\n\t    x.multiplyTo(y, r);\n\t    this.reduce(r);\n\t  }\n\t  Montgomery.prototype.convert = montConvert;\n\t  Montgomery.prototype.revert = montRevert;\n\t  Montgomery.prototype.reduce = montReduce;\n\t  Montgomery.prototype.mulTo = montMulTo;\n\t  Montgomery.prototype.sqrTo = montSqrTo;\n\t  // (protected) true iff this is even\n\t  function bnpIsEven()\n\t  {\n\t    return ((this.t > 0) ? (this[0] & 1) : this.s) == 0;\n\t  }\n\t  // (protected) this^e, e < 2^32, doing sqr and mul with \"r\" (HAC 14.79)\n\t  function bnpExp(e, z)\n\t  {\n\t    if (e > 0xffffffff || e < 1) return BigInteger.ONE;\n\t    var r = nbi(),\n\t      r2 = nbi(),\n\t      g = z.convert(this),\n\t      i = nbits(e) - 1;\n\t    g.copyTo(r);\n\t    while (--i >= 0)\n\t    {\n\t      z.sqrTo(r, r2);\n\t      if ((e & (1 << i)) > 0) z.mulTo(r2, g, r);\n\t      else\n\t      {\n\t        var t = r;\n\t        r = r2;\n\t        r2 = t;\n\t      }\n\t    }\n\t    return z.revert(r);\n\t  }\n\t  // (public) this^e % m, 0 <= e < 2^32\n\t  function bnModPowInt(e, m)\n\t  {\n\t    var z;\n\t    if (e < 256 || m.isEven()) z = new Classic(m);\n\t    else z = new Montgomery(m);\n\t    return this.exp(e, z);\n\t  }\n\t  // protected\n\t  BigInteger.prototype.copyTo = bnpCopyTo;\n\t  BigInteger.prototype.fromInt = bnpFromInt;\n\t  BigInteger.prototype.fromString = bnpFromString;\n\t  BigInteger.prototype.clamp = bnpClamp;\n\t  BigInteger.prototype.dlShiftTo = bnpDLShiftTo;\n\t  BigInteger.prototype.drShiftTo = bnpDRShiftTo;\n\t  BigInteger.prototype.lShiftTo = bnpLShiftTo;\n\t  BigInteger.prototype.rShiftTo = bnpRShiftTo;\n\t  BigInteger.prototype.subTo = bnpSubTo;\n\t  BigInteger.prototype.multiplyTo = bnpMultiplyTo;\n\t  BigInteger.prototype.squareTo = bnpSquareTo;\n\t  BigInteger.prototype.divRemTo = bnpDivRemTo;\n\t  BigInteger.prototype.invDigit = bnpInvDigit;\n\t  BigInteger.prototype.isEven = bnpIsEven;\n\t  BigInteger.prototype.exp = bnpExp;\n\t  // public\n\t  BigInteger.prototype.toString = bnToString;\n\t  BigInteger.prototype.negate = bnNegate;\n\t  BigInteger.prototype.abs = bnAbs;\n\t  BigInteger.prototype.compareTo = bnCompareTo;\n\t  BigInteger.prototype.bitLength = bnBitLength;\n\t  BigInteger.prototype.mod = bnMod;\n\t  BigInteger.prototype.modPowInt = bnModPowInt;\n\t  // \"constants\"\n\t  BigInteger.ZERO = nbv(0);\n\t  BigInteger.ONE = nbv(1);\n\t  // Copyright (c) 2005-2009  Tom Wu\n\t  // All Rights Reserved.\n\t  // See \"LICENSE\" for details.\n\t  // Extended JavaScript BN functions, required for RSA private ops.\n\t  // Version 1.1: new BigInteger(\"0\", 10) returns \"proper\" zero\n\t  // Version 1.2: square() API, isProbablePrime fix\n\t  // (public)\n\t  function bnClone()\n\t  {\n\t    var r = nbi();\n\t    this.copyTo(r);\n\t    return r;\n\t  }\n\t  // (public) return value as integer\n\t  function bnIntValue()\n\t  {\n\t    if (this.s < 0)\n\t    {\n\t      if (this.t == 1) return this[0] - this.DV;\n\t      else if (this.t == 0) return -1;\n\t    }\n\t    else if (this.t == 1) return this[0];\n\t    else if (this.t == 0) return 0;\n\t    // assumes 16 < DB < 32\n\t    return ((this[1] & ((1 << (32 - this.DB)) - 1)) << this.DB) | this[0];\n\t  }\n\t  // (public) return value as byte\n\t  function bnByteValue()\n\t  {\n\t    return (this.t == 0) ? this.s : (this[0] << 24) >> 24;\n\t  }\n\t  // (public) return value as short (assumes DB>=16)\n\t  function bnShortValue()\n\t  {\n\t    return (this.t == 0) ? this.s : (this[0] << 16) >> 16;\n\t  }\n\t  // (protected) return x s.t. r^x < DV\n\t  function bnpChunkSize(r)\n\t  {\n\t    return Math.floor(Math.LN2 * this.DB / Math.log(r));\n\t  }\n\t  // (public) 0 if this == 0, 1 if this > 0\n\t  function bnSigNum()\n\t  {\n\t    if (this.s < 0) return -1;\n\t    else if (this.t <= 0 || (this.t == 1 && this[0] <= 0)) return 0;\n\t    else return 1;\n\t  }\n\t  // (protected) convert to radix string\n\t  function bnpToRadix(b)\n\t  {\n\t    if (b == null) b = 10;\n\t    if (this.signum() == 0 || b < 2 || b > 36) return \"0\";\n\t    var cs = this.chunkSize(b);\n\t    var a = Math.pow(b, cs);\n\t    var d = nbv(a),\n\t      y = nbi(),\n\t      z = nbi(),\n\t      r = \"\";\n\t    this.divRemTo(d, y, z);\n\t    while (y.signum() > 0)\n\t    {\n\t      r = (a + z.intValue()).toString(b).substr(1) + r;\n\t      y.divRemTo(d, y, z);\n\t    }\n\t    return z.intValue().toString(b) + r;\n\t  }\n\t  // (protected) convert from radix string\n\t  function bnpFromRadix(s, b)\n\t  {\n\t    this.fromInt(0);\n\t    if (b == null) b = 10;\n\t    var cs = this.chunkSize(b);\n\t    var d = Math.pow(b, cs),\n\t      mi = false,\n\t      j = 0,\n\t      w = 0;\n\t    for (var i = 0; i < s.length; ++i)\n\t    {\n\t      var x = intAt(s, i);\n\t      if (x < 0)\n\t      {\n\t        if (s.charAt(i) == \"-\" && this.signum() == 0) mi = true;\n\t        continue;\n\t      }\n\t      w = b * w + x;\n\t      if (++j >= cs)\n\t      {\n\t        this.dMultiply(d);\n\t        this.dAddOffset(w, 0);\n\t        j = 0;\n\t        w = 0;\n\t      }\n\t    }\n\t    if (j > 0)\n\t    {\n\t      this.dMultiply(Math.pow(b, j));\n\t      this.dAddOffset(w, 0);\n\t    }\n\t    if (mi) BigInteger.ZERO.subTo(this, this);\n\t  }\n\t  // (protected) alternate constructor\n\t  function bnpFromNumber(a, b, c)\n\t  {\n\t    if (\"number\" == typeof b)\n\t    {\n\t      // new BigInteger(int,int,RNG)\n\t      if (a < 2) this.fromInt(1);\n\t      else\n\t      {\n\t        this.fromNumber(a, c);\n\t        if (!this.testBit(a - 1)) // force MSB set\n\t          this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);\n\t        if (this.isEven()) this.dAddOffset(1, 0); // force odd\n\t        while (!this.isProbablePrime(b))\n\t        {\n\t          this.dAddOffset(2, 0);\n\t          if (this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);\n\t        }\n\t      }\n\t    }\n\t    else\n\t    {\n\t      // new BigInteger(int,RNG)\n\t      var x = new Array(),\n\t        t = a & 7;\n\t      x.length = (a >> 3) + 1;\n\t      b.nextBytes(x);\n\t      if (t > 0) x[0] &= ((1 << t) - 1);\n\t      else x[0] = 0;\n\t      this.fromString(x, 256);\n\t    }\n\t  }\n\t  // (public) convert to bigendian byte array\n\t  function bnToByteArray()\n\t  {\n\t    var i = this.t,\n\t      r = new Array();\n\t    r[0] = this.s;\n\t    var p = this.DB - (i * this.DB) % 8,\n\t      d, k = 0;\n\t    if (i-- > 0)\n\t    {\n\t      if (p < this.DB && (d = this[i] >> p) != (this.s & this.DM) >> p)\n\t        r[k++] = d | (this.s << (this.DB - p));\n\t      while (i >= 0)\n\t      {\n\t        if (p < 8)\n\t        {\n\t          d = (this[i] & ((1 << p) - 1)) << (8 - p);\n\t          d |= this[--i] >> (p += this.DB - 8);\n\t        }\n\t        else\n\t        {\n\t          d = (this[i] >> (p -= 8)) & 0xff;\n\t          if (p <= 0)\n\t          {\n\t            p += this.DB;\n\t            --i;\n\t          }\n\t        }\n\t        if ((d & 0x80) != 0) d |= -256;\n\t        if (k == 0 && (this.s & 0x80) != (d & 0x80))++k;\n\t        if (k > 0 || d != this.s) r[k++] = d;\n\t      }\n\t    }\n\t    return r;\n\t  }\n\t\n\t  function bnEquals(a)\n\t  {\n\t    return (this.compareTo(a) == 0);\n\t  }\n\t\n\t  function bnMin(a)\n\t  {\n\t    return (this.compareTo(a) < 0) ? this : a;\n\t  }\n\t\n\t  function bnMax(a)\n\t  {\n\t    return (this.compareTo(a) > 0) ? this : a;\n\t  }\n\t  // (protected) r = this op a (bitwise)\n\t  function bnpBitwiseTo(a, op, r)\n\t  {\n\t    var i, f, m = Math.min(a.t, this.t);\n\t    for (i = 0; i < m; ++i) r[i] = op(this[i], a[i]);\n\t    if (a.t < this.t)\n\t    {\n\t      f = a.s & this.DM;\n\t      for (i = m; i < this.t; ++i) r[i] = op(this[i], f);\n\t      r.t = this.t;\n\t    }\n\t    else\n\t    {\n\t      f = this.s & this.DM;\n\t      for (i = m; i < a.t; ++i) r[i] = op(f, a[i]);\n\t      r.t = a.t;\n\t    }\n\t    r.s = op(this.s, a.s);\n\t    r.clamp();\n\t  }\n\t  // (public) this & a\n\t  function op_and(x, y)\n\t  {\n\t    return x & y;\n\t  }\n\t\n\t  function bnAnd(a)\n\t  {\n\t    var r = nbi();\n\t    this.bitwiseTo(a, op_and, r);\n\t    return r;\n\t  }\n\t  // (public) this | a\n\t  function op_or(x, y)\n\t  {\n\t    return x | y;\n\t  }\n\t\n\t  function bnOr(a)\n\t  {\n\t    var r = nbi();\n\t    this.bitwiseTo(a, op_or, r);\n\t    return r;\n\t  }\n\t  // (public) this ^ a\n\t  function op_xor(x, y)\n\t  {\n\t    return x ^ y;\n\t  }\n\t\n\t  function bnXor(a)\n\t  {\n\t    var r = nbi();\n\t    this.bitwiseTo(a, op_xor, r);\n\t    return r;\n\t  }\n\t  // (public) this & ~a\n\t  function op_andnot(x, y)\n\t  {\n\t    return x & ~y;\n\t  }\n\t\n\t  function bnAndNot(a)\n\t  {\n\t    var r = nbi();\n\t    this.bitwiseTo(a, op_andnot, r);\n\t    return r;\n\t  }\n\t  // (public) ~this\n\t  function bnNot()\n\t  {\n\t    var r = nbi();\n\t    for (var i = 0; i < this.t; ++i) r[i] = this.DM & ~this[i];\n\t    r.t = this.t;\n\t    r.s = ~this.s;\n\t    return r;\n\t  }\n\t  // (public) this << n\n\t  function bnShiftLeft(n)\n\t  {\n\t    var r = nbi();\n\t    if (n < 0) this.rShiftTo(-n, r);\n\t    else this.lShiftTo(n, r);\n\t    return r;\n\t  }\n\t  // (public) this >> n\n\t  function bnShiftRight(n)\n\t  {\n\t    var r = nbi();\n\t    if (n < 0) this.lShiftTo(-n, r);\n\t    else this.rShiftTo(n, r);\n\t    return r;\n\t  }\n\t  // return index of lowest 1-bit in x, x < 2^31\n\t  function lbit(x)\n\t  {\n\t    if (x == 0) return -1;\n\t    var r = 0;\n\t    if ((x & 0xffff) == 0)\n\t    {\n\t      x >>= 16;\n\t      r += 16;\n\t    }\n\t    if ((x & 0xff) == 0)\n\t    {\n\t      x >>= 8;\n\t      r += 8;\n\t    }\n\t    if ((x & 0xf) == 0)\n\t    {\n\t      x >>= 4;\n\t      r += 4;\n\t    }\n\t    if ((x & 3) == 0)\n\t    {\n\t      x >>= 2;\n\t      r += 2;\n\t    }\n\t    if ((x & 1) == 0)++r;\n\t    return r;\n\t  }\n\t  // (public) returns index of lowest 1-bit (or -1 if none)\n\t  function bnGetLowestSetBit()\n\t  {\n\t    for (var i = 0; i < this.t; ++i)\n\t      if (this[i] != 0) return i * this.DB + lbit(this[i]);\n\t    if (this.s < 0) return this.t * this.DB;\n\t    return -1;\n\t  }\n\t  // return number of 1 bits in x\n\t  function cbit(x)\n\t  {\n\t    var r = 0;\n\t    while (x != 0)\n\t    {\n\t      x &= x - 1;\n\t      ++r;\n\t    }\n\t    return r;\n\t  }\n\t  // (public) return number of set bits\n\t  function bnBitCount()\n\t  {\n\t    var r = 0,\n\t      x = this.s & this.DM;\n\t    for (var i = 0; i < this.t; ++i) r += cbit(this[i] ^ x);\n\t    return r;\n\t  }\n\t  // (public) true iff nth bit is set\n\t  function bnTestBit(n)\n\t  {\n\t    var j = Math.floor(n / this.DB);\n\t    if (j >= this.t) return (this.s != 0);\n\t    return ((this[j] & (1 << (n % this.DB))) != 0);\n\t  }\n\t  // (protected) this op (1<<n)\n\t  function bnpChangeBit(n, op)\n\t  {\n\t    var r = BigInteger.ONE.shiftLeft(n);\n\t    this.bitwiseTo(r, op, r);\n\t    return r;\n\t  }\n\t  // (public) this | (1<<n)\n\t  function bnSetBit(n)\n\t  {\n\t    return this.changeBit(n, op_or);\n\t  }\n\t  // (public) this & ~(1<<n)\n\t  function bnClearBit(n)\n\t  {\n\t    return this.changeBit(n, op_andnot);\n\t  }\n\t  // (public) this ^ (1<<n)\n\t  function bnFlipBit(n)\n\t  {\n\t    return this.changeBit(n, op_xor);\n\t  }\n\t  // (protected) r = this + a\n\t  function bnpAddTo(a, r)\n\t  {\n\t    var i = 0,\n\t      c = 0,\n\t      m = Math.min(a.t, this.t);\n\t    while (i < m)\n\t    {\n\t      c += this[i] + a[i];\n\t      r[i++] = c & this.DM;\n\t      c >>= this.DB;\n\t    }\n\t    if (a.t < this.t)\n\t    {\n\t      c += a.s;\n\t      while (i < this.t)\n\t      {\n\t        c += this[i];\n\t        r[i++] = c & this.DM;\n\t        c >>= this.DB;\n\t      }\n\t      c += this.s;\n\t    }\n\t    else\n\t    {\n\t      c += this.s;\n\t      while (i < a.t)\n\t      {\n\t        c += a[i];\n\t        r[i++] = c & this.DM;\n\t        c >>= this.DB;\n\t      }\n\t      c += a.s;\n\t    }\n\t    r.s = (c < 0) ? -1 : 0;\n\t    if (c > 0) r[i++] = c;\n\t    else if (c < -1) r[i++] = this.DV + c;\n\t    r.t = i;\n\t    r.clamp();\n\t  }\n\t  // (public) this + a\n\t  function bnAdd(a)\n\t  {\n\t    var r = nbi();\n\t    this.addTo(a, r);\n\t    return r;\n\t  }\n\t  // (public) this - a\n\t  function bnSubtract(a)\n\t  {\n\t    var r = nbi();\n\t    this.subTo(a, r);\n\t    return r;\n\t  }\n\t  // (public) this * a\n\t  function bnMultiply(a)\n\t  {\n\t    var r = nbi();\n\t    this.multiplyTo(a, r);\n\t    return r;\n\t  }\n\t  // (public) this^2\n\t  function bnSquare()\n\t  {\n\t    var r = nbi();\n\t    this.squareTo(r);\n\t    return r;\n\t  }\n\t  // (public) this / a\n\t  function bnDivide(a)\n\t  {\n\t    var r = nbi();\n\t    this.divRemTo(a, r, null);\n\t    return r;\n\t  }\n\t  // (public) this % a\n\t  function bnRemainder(a)\n\t  {\n\t    var r = nbi();\n\t    this.divRemTo(a, null, r);\n\t    return r;\n\t  }\n\t  // (public) [this/a,this%a]\n\t  function bnDivideAndRemainder(a)\n\t  {\n\t    var q = nbi(),\n\t      r = nbi();\n\t    this.divRemTo(a, q, r);\n\t    return new Array(q, r);\n\t  }\n\t  // (protected) this *= n, this >= 0, 1 < n < DV\n\t  function bnpDMultiply(n)\n\t  {\n\t    this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);\n\t    ++this.t;\n\t    this.clamp();\n\t  }\n\t  // (protected) this += n << w words, this >= 0\n\t  function bnpDAddOffset(n, w)\n\t  {\n\t    if (n == 0) return;\n\t    while (this.t <= w) this[this.t++] = 0;\n\t    this[w] += n;\n\t    while (this[w] >= this.DV)\n\t    {\n\t      this[w] -= this.DV;\n\t      if (++w >= this.t) this[this.t++] = 0;\n\t      ++this[w];\n\t    }\n\t  }\n\t  // A \"null\" reducer\n\t  function NullExp()\n\t  {}\n\t\n\t  function nNop(x)\n\t  {\n\t    return x;\n\t  }\n\t\n\t  function nMulTo(x, y, r)\n\t  {\n\t    x.multiplyTo(y, r);\n\t  }\n\t\n\t  function nSqrTo(x, r)\n\t  {\n\t    x.squareTo(r);\n\t  }\n\t  NullExp.prototype.convert = nNop;\n\t  NullExp.prototype.revert = nNop;\n\t  NullExp.prototype.mulTo = nMulTo;\n\t  NullExp.prototype.sqrTo = nSqrTo;\n\t  // (public) this^e\n\t  function bnPow(e)\n\t  {\n\t    return this.exp(e, new NullExp());\n\t  }\n\t  // (protected) r = lower n words of \"this * a\", a.t <= n\n\t  // \"this\" should be the larger one if appropriate.\n\t  function bnpMultiplyLowerTo(a, n, r)\n\t  {\n\t    var i = Math.min(this.t + a.t, n);\n\t    r.s = 0; // assumes a,this >= 0\n\t    r.t = i;\n\t    while (i > 0) r[--i] = 0;\n\t    var j;\n\t    for (j = r.t - this.t; i < j; ++i) r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);\n\t    for (j = Math.min(a.t, n); i < j; ++i) this.am(0, a[i], r, i, 0, n - i);\n\t    r.clamp();\n\t  }\n\t  // (protected) r = \"this * a\" without lower n words, n > 0\n\t  // \"this\" should be the larger one if appropriate.\n\t  function bnpMultiplyUpperTo(a, n, r)\n\t  {\n\t    --n;\n\t    var i = r.t = this.t + a.t - n;\n\t    r.s = 0; // assumes a,this >= 0\n\t    while (--i >= 0) r[i] = 0;\n\t    for (i = Math.max(n - this.t, 0); i < a.t; ++i)\n\t      r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n);\n\t    r.clamp();\n\t    r.drShiftTo(1, r);\n\t  }\n\t  // Barrett modular reduction\n\t  function Barrett(m)\n\t  {\n\t    // setup Barrett\n\t    this.r2 = nbi();\n\t    this.q3 = nbi();\n\t    BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);\n\t    this.mu = this.r2.divide(m);\n\t    this.m = m;\n\t  }\n\t\n\t  function barrettConvert(x)\n\t  {\n\t    if (x.s < 0 || x.t > 2 * this.m.t) return x.mod(this.m);\n\t    else if (x.compareTo(this.m) < 0) return x;\n\t    else\n\t    {\n\t      var r = nbi();\n\t      x.copyTo(r);\n\t      this.reduce(r);\n\t      return r;\n\t    }\n\t  }\n\t\n\t  function barrettRevert(x)\n\t  {\n\t    return x;\n\t  }\n\t  // x = x mod m (HAC 14.42)\n\t  function barrettReduce(x)\n\t  {\n\t    x.drShiftTo(this.m.t - 1, this.r2);\n\t    if (x.t > this.m.t + 1)\n\t    {\n\t      x.t = this.m.t + 1;\n\t      x.clamp();\n\t    }\n\t    this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);\n\t    this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);\n\t    while (x.compareTo(this.r2) < 0) x.dAddOffset(1, this.m.t + 1);\n\t    x.subTo(this.r2, x);\n\t    while (x.compareTo(this.m) >= 0) x.subTo(this.m, x);\n\t  }\n\t  // r = x^2 mod m; x != r\n\t  function barrettSqrTo(x, r)\n\t  {\n\t    x.squareTo(r);\n\t    this.reduce(r);\n\t  }\n\t  // r = x*y mod m; x,y != r\n\t  function barrettMulTo(x, y, r)\n\t  {\n\t    x.multiplyTo(y, r);\n\t    this.reduce(r);\n\t  }\n\t  Barrett.prototype.convert = barrettConvert;\n\t  Barrett.prototype.revert = barrettRevert;\n\t  Barrett.prototype.reduce = barrettReduce;\n\t  Barrett.prototype.mulTo = barrettMulTo;\n\t  Barrett.prototype.sqrTo = barrettSqrTo;\n\t  // (public) this^e % m (HAC 14.85)\n\t  function bnModPow(e, m)\n\t  {\n\t    var i = e.bitLength(),\n\t      k, r = nbv(1),\n\t      z;\n\t    if (i <= 0) return r;\n\t    else if (i < 18) k = 1;\n\t    else if (i < 48) k = 3;\n\t    else if (i < 144) k = 4;\n\t    else if (i < 768) k = 5;\n\t    else k = 6;\n\t    if (i < 8)\n\t      z = new Classic(m);\n\t    else if (m.isEven())\n\t      z = new Barrett(m);\n\t    else\n\t      z = new Montgomery(m);\n\t    // precomputation\n\t    var g = new Array(),\n\t      n = 3,\n\t      k1 = k - 1,\n\t      km = (1 << k) - 1;\n\t    g[1] = z.convert(this);\n\t    if (k > 1)\n\t    {\n\t      var g2 = nbi();\n\t      z.sqrTo(g[1], g2);\n\t      while (n <= km)\n\t      {\n\t        g[n] = nbi();\n\t        z.mulTo(g2, g[n - 2], g[n]);\n\t        n += 2;\n\t      }\n\t    }\n\t    var j = e.t - 1,\n\t      w, is1 = true,\n\t      r2 = nbi(),\n\t      t;\n\t    i = nbits(e[j]) - 1;\n\t    while (j >= 0)\n\t    {\n\t      if (i >= k1) w = (e[j] >> (i - k1)) & km;\n\t      else\n\t      {\n\t        w = (e[j] & ((1 << (i + 1)) - 1)) << (k1 - i);\n\t        if (j > 0) w |= e[j - 1] >> (this.DB + i - k1);\n\t      }\n\t      n = k;\n\t      while ((w & 1) == 0)\n\t      {\n\t        w >>= 1;\n\t        --n;\n\t      }\n\t      if ((i -= n) < 0)\n\t      {\n\t        i += this.DB;\n\t        --j;\n\t      }\n\t      if (is1)\n\t      { // ret == 1, don't bother squaring or multiplying it\n\t        g[w].copyTo(r);\n\t        is1 = false;\n\t      }\n\t      else\n\t      {\n\t        while (n > 1)\n\t        {\n\t          z.sqrTo(r, r2);\n\t          z.sqrTo(r2, r);\n\t          n -= 2;\n\t        }\n\t        if (n > 0) z.sqrTo(r, r2);\n\t        else\n\t        {\n\t          t = r;\n\t          r = r2;\n\t          r2 = t;\n\t        }\n\t        z.mulTo(r2, g[w], r);\n\t      }\n\t      while (j >= 0 && (e[j] & (1 << i)) == 0)\n\t      {\n\t        z.sqrTo(r, r2);\n\t        t = r;\n\t        r = r2;\n\t        r2 = t;\n\t        if (--i < 0)\n\t        {\n\t          i = this.DB - 1;\n\t          --j;\n\t        }\n\t      }\n\t    }\n\t    return z.revert(r);\n\t  }\n\t  // (public) gcd(this,a) (HAC 14.54)\n\t  function bnGCD(a)\n\t  {\n\t    var x = (this.s < 0) ? this.negate() : this.clone();\n\t    var y = (a.s < 0) ? a.negate() : a.clone();\n\t    if (x.compareTo(y) < 0)\n\t    {\n\t      var t = x;\n\t      x = y;\n\t      y = t;\n\t    }\n\t    var i = x.getLowestSetBit(),\n\t      g = y.getLowestSetBit();\n\t    if (g < 0) return x;\n\t    if (i < g) g = i;\n\t    if (g > 0)\n\t    {\n\t      x.rShiftTo(g, x);\n\t      y.rShiftTo(g, y);\n\t    }\n\t    while (x.signum() > 0)\n\t    {\n\t      if ((i = x.getLowestSetBit()) > 0) x.rShiftTo(i, x);\n\t      if ((i = y.getLowestSetBit()) > 0) y.rShiftTo(i, y);\n\t      if (x.compareTo(y) >= 0)\n\t      {\n\t        x.subTo(y, x);\n\t        x.rShiftTo(1, x);\n\t      }\n\t      else\n\t      {\n\t        y.subTo(x, y);\n\t        y.rShiftTo(1, y);\n\t      }\n\t    }\n\t    if (g > 0) y.lShiftTo(g, y);\n\t    return y;\n\t  }\n\t  // (protected) this % n, n < 2^26\n\t  function bnpModInt(n)\n\t  {\n\t    if (n <= 0) return 0;\n\t    var d = this.DV % n,\n\t      r = (this.s < 0) ? n - 1 : 0;\n\t    if (this.t > 0)\n\t      if (d == 0) r = this[0] % n;\n\t      else\n\t        for (var i = this.t - 1; i >= 0; --i) r = (d * r + this[i]) % n;\n\t    return r;\n\t  }\n\t  // (public) 1/this % m (HAC 14.61)\n\t  function bnModInverse(m)\n\t  {\n\t    var ac = m.isEven();\n\t    if ((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO;\n\t    var u = m.clone(),\n\t      v = this.clone();\n\t    var a = nbv(1),\n\t      b = nbv(0),\n\t      c = nbv(0),\n\t      d = nbv(1);\n\t    while (u.signum() != 0)\n\t    {\n\t      while (u.isEven())\n\t      {\n\t        u.rShiftTo(1, u);\n\t        if (ac)\n\t        {\n\t          if (!a.isEven() || !b.isEven())\n\t          {\n\t            a.addTo(this, a);\n\t            b.subTo(m, b);\n\t          }\n\t          a.rShiftTo(1, a);\n\t        }\n\t        else if (!b.isEven()) b.subTo(m, b);\n\t        b.rShiftTo(1, b);\n\t      }\n\t      while (v.isEven())\n\t      {\n\t        v.rShiftTo(1, v);\n\t        if (ac)\n\t        {\n\t          if (!c.isEven() || !d.isEven())\n\t          {\n\t            c.addTo(this, c);\n\t            d.subTo(m, d);\n\t          }\n\t          c.rShiftTo(1, c);\n\t        }\n\t        else if (!d.isEven()) d.subTo(m, d);\n\t        d.rShiftTo(1, d);\n\t      }\n\t      if (u.compareTo(v) >= 0)\n\t      {\n\t        u.subTo(v, u);\n\t        if (ac) a.subTo(c, a);\n\t        b.subTo(d, b);\n\t      }\n\t      else\n\t      {\n\t        v.subTo(u, v);\n\t        if (ac) c.subTo(a, c);\n\t        d.subTo(b, d);\n\t      }\n\t    }\n\t    if (v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;\n\t    if (d.compareTo(m) >= 0) return d.subtract(m);\n\t    if (d.signum() < 0) d.addTo(m, d);\n\t    else return d;\n\t    if (d.signum() < 0) return d.add(m);\n\t    else return d;\n\t  }\n\t  var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];\n\t  var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];\n\t  // (public) test primality with certainty >= 1-.5^t\n\t  function bnIsProbablePrime(t)\n\t  {\n\t    var i, x = this.abs();\n\t    if (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1])\n\t    {\n\t      for (i = 0; i < lowprimes.length; ++i)\n\t        if (x[0] == lowprimes[i]) return true;\n\t      return false;\n\t    }\n\t    if (x.isEven()) return false;\n\t    i = 1;\n\t    while (i < lowprimes.length)\n\t    {\n\t      var m = lowprimes[i],\n\t        j = i + 1;\n\t      while (j < lowprimes.length && m < lplim) m *= lowprimes[j++];\n\t      m = x.modInt(m);\n\t      while (i < j)\n\t        if (m % lowprimes[i++] == 0) return false;\n\t    }\n\t    return x.millerRabin(t);\n\t  }\n\t  // (protected) true if probably prime (HAC 4.24, Miller-Rabin)\n\t  function bnpMillerRabin(t)\n\t  {\n\t    var n1 = this.subtract(BigInteger.ONE);\n\t    var k = n1.getLowestSetBit();\n\t    if (k <= 0) return false;\n\t    var r = n1.shiftRight(k);\n\t    t = (t + 1) >> 1;\n\t    if (t > lowprimes.length) t = lowprimes.length;\n\t    var a = nbi();\n\t    for (var i = 0; i < t; ++i)\n\t    {\n\t      //Pick bases at random, instead of starting at 2\n\t      a.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);\n\t      var y = a.modPow(r, this);\n\t      if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0)\n\t      {\n\t        var j = 1;\n\t        while (j++ < k && y.compareTo(n1) != 0)\n\t        {\n\t          y = y.modPowInt(2, this);\n\t          if (y.compareTo(BigInteger.ONE) == 0) return false;\n\t        }\n\t        if (y.compareTo(n1) != 0) return false;\n\t      }\n\t    }\n\t    return true;\n\t  }\n\t  // protected\n\t  BigInteger.prototype.chunkSize = bnpChunkSize;\n\t  BigInteger.prototype.toRadix = bnpToRadix;\n\t  BigInteger.prototype.fromRadix = bnpFromRadix;\n\t  BigInteger.prototype.fromNumber = bnpFromNumber;\n\t  BigInteger.prototype.bitwiseTo = bnpBitwiseTo;\n\t  BigInteger.prototype.changeBit = bnpChangeBit;\n\t  BigInteger.prototype.addTo = bnpAddTo;\n\t  BigInteger.prototype.dMultiply = bnpDMultiply;\n\t  BigInteger.prototype.dAddOffset = bnpDAddOffset;\n\t  BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;\n\t  BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;\n\t  BigInteger.prototype.modInt = bnpModInt;\n\t  BigInteger.prototype.millerRabin = bnpMillerRabin;\n\t  // public\n\t  BigInteger.prototype.clone = bnClone;\n\t  BigInteger.prototype.intValue = bnIntValue;\n\t  BigInteger.prototype.byteValue = bnByteValue;\n\t  BigInteger.prototype.shortValue = bnShortValue;\n\t  BigInteger.prototype.signum = bnSigNum;\n\t  BigInteger.prototype.toByteArray = bnToByteArray;\n\t  BigInteger.prototype.equals = bnEquals;\n\t  BigInteger.prototype.min = bnMin;\n\t  BigInteger.prototype.max = bnMax;\n\t  BigInteger.prototype.and = bnAnd;\n\t  BigInteger.prototype.or = bnOr;\n\t  BigInteger.prototype.xor = bnXor;\n\t  BigInteger.prototype.andNot = bnAndNot;\n\t  BigInteger.prototype.not = bnNot;\n\t  BigInteger.prototype.shiftLeft = bnShiftLeft;\n\t  BigInteger.prototype.shiftRight = bnShiftRight;\n\t  BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;\n\t  BigInteger.prototype.bitCount = bnBitCount;\n\t  BigInteger.prototype.testBit = bnTestBit;\n\t  BigInteger.prototype.setBit = bnSetBit;\n\t  BigInteger.prototype.clearBit = bnClearBit;\n\t  BigInteger.prototype.flipBit = bnFlipBit;\n\t  BigInteger.prototype.add = bnAdd;\n\t  BigInteger.prototype.subtract = bnSubtract;\n\t  BigInteger.prototype.multiply = bnMultiply;\n\t  BigInteger.prototype.divide = bnDivide;\n\t  BigInteger.prototype.remainder = bnRemainder;\n\t  BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;\n\t  BigInteger.prototype.modPow = bnModPow;\n\t  BigInteger.prototype.modInverse = bnModInverse;\n\t  BigInteger.prototype.pow = bnPow;\n\t  BigInteger.prototype.gcd = bnGCD;\n\t  BigInteger.prototype.isProbablePrime = bnIsProbablePrime;\n\t  // JSBN-specific extension\n\t  BigInteger.prototype.square = bnSquare;\n\t  var Int128 = BigInteger;\n\t  // BigInteger interfaces not implemented in jsbn:\n\t  // BigInteger(int signum, byte[] magnitude)\n\t  // double doubleValue()\n\t  // float floatValue()\n\t  // int hashCode()\n\t  // long longValue()\n\t  // static BigInteger valueOf(long val)\n\t  // Helper functions to make BigInteger functions callable with two parameters\n\t  // as in original C# Clipper\n\t  Int128.prototype.IsNegative = function ()\n\t  {\n\t    if (this.compareTo(Int128.ZERO) == -1) return true;\n\t    else return false;\n\t  };\n\t  Int128.op_Equality = function (val1, val2)\n\t  {\n\t    if (val1.compareTo(val2) == 0) return true;\n\t    else return false;\n\t  };\n\t  Int128.op_Inequality = function (val1, val2)\n\t  {\n\t    if (val1.compareTo(val2) != 0) return true;\n\t    else return false;\n\t  };\n\t  Int128.op_GreaterThan = function (val1, val2)\n\t  {\n\t    if (val1.compareTo(val2) > 0) return true;\n\t    else return false;\n\t  };\n\t  Int128.op_LessThan = function (val1, val2)\n\t  {\n\t    if (val1.compareTo(val2) < 0) return true;\n\t    else return false;\n\t  };\n\t  Int128.op_Addition = function (lhs, rhs)\n\t  {\n\t    return new Int128(lhs).add(new Int128(rhs));\n\t  };\n\t  Int128.op_Subtraction = function (lhs, rhs)\n\t  {\n\t    return new Int128(lhs).subtract(new Int128(rhs));\n\t  };\n\t  Int128.Int128Mul = function (lhs, rhs)\n\t  {\n\t    return new Int128(lhs).multiply(new Int128(rhs));\n\t  };\n\t  Int128.op_Division = function (lhs, rhs)\n\t  {\n\t    return lhs.divide(rhs);\n\t  };\n\t  Int128.prototype.ToDouble = function ()\n\t  {\n\t    return parseFloat(this.toString()); // This could be something faster\n\t  };\n\t  // end of Int128 section\n\t  /*\n\t  // Uncomment the following two lines if you want to use Int128 outside ClipperLib\n\t  if (typeof(document) !== \"undefined\") window.Int128 = Int128;\n\t  else self.Int128 = Int128;\n\t  */\n\t\n\t\n\t  // ---------------------------------------------\n\t  // Here starts the actual Clipper library:\n\t  // Helper function to support Inheritance in Javascript\n\t\tvar Inherit = function (ce, ce2)\n\t\t{\n\t\t\tvar p;\n\t\t\tif (typeof (Object.getOwnPropertyNames) == 'undefined')\n\t\t\t{\n\t\t\t\tfor (p in ce2.prototype)\n\t\t\t\t\tif (typeof (ce.prototype[p]) == 'undefined' || ce.prototype[p] == Object.prototype[p]) ce.prototype[p] = ce2.prototype[p];\n\t\t\t\tfor (p in ce2)\n\t\t\t\t\tif (typeof (ce[p]) == 'undefined') ce[p] = ce2[p];\n\t\t\t\tce.$baseCtor = ce2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvar props = Object.getOwnPropertyNames(ce2.prototype);\n\t\t\t\tfor (var i = 0; i < props.length; i++)\n\t\t\t\t\tif (typeof (Object.getOwnPropertyDescriptor(ce.prototype, props[i])) == 'undefined') Object.defineProperty(ce.prototype, props[i], Object.getOwnPropertyDescriptor(ce2.prototype, props[i]));\n\t\t\t\tfor (p in ce2)\n\t\t\t\t\tif (typeof (ce[p]) == 'undefined') ce[p] = ce2[p];\n\t\t\t\tce.$baseCtor = ce2;\n\t\t\t}\n\t\t};\n\t  ClipperLib.Path = function ()\n\t  {\n\t    return [];\n\t  };\n\t  ClipperLib.Paths = function ()\n\t  {\n\t    return []; // Was previously [[]], but caused problems when pushed\n\t  };\n\t  // Preserves the calling way of original C# Clipper\n\t  // Is essential due to compatibility, because DoublePoint is public class in original C# version\n\t  ClipperLib.DoublePoint = function ()\n\t  {\n\t    var a = arguments;\n\t    this.X = 0;\n\t    this.Y = 0;\n\t    // public DoublePoint(DoublePoint dp)\n\t    // public DoublePoint(IntPoint ip)\n\t    if (a.length == 1)\n\t    {\n\t      this.X = a[0].X;\n\t      this.Y = a[0].Y;\n\t    }\n\t    else if (a.length == 2)\n\t    {\n\t      this.X = a[0];\n\t      this.Y = a[1];\n\t    }\n\t  }; // This is internal faster function when called without arguments\n\t  ClipperLib.DoublePoint0 = function ()\n\t  {\n\t    this.X = 0;\n\t    this.Y = 0;\n\t  };\n\t  // This is internal faster function when called with 1 argument (dp or ip)\n\t  ClipperLib.DoublePoint1 = function (dp)\n\t  {\n\t    this.X = dp.X;\n\t    this.Y = dp.Y;\n\t  };\n\t  // This is internal faster function when called with 2 arguments (x and y)\n\t  ClipperLib.DoublePoint2 = function (x, y)\n\t  {\n\t    this.X = x;\n\t    this.Y = y;\n\t  };\n\t  // PolyTree & PolyNode start\n\t  // -------------------------------\n\t  ClipperLib.PolyNode = function ()\n\t  {\n\t    this.m_Parent = null;\n\t    this.m_polygon = new ClipperLib.Path();\n\t    this.m_Index = 0;\n\t    this.m_jointype = 0;\n\t    this.m_endtype = 0;\n\t    this.m_Childs = [];\n\t    this.IsOpen = false;\n\t  };\n\t  ClipperLib.PolyNode.prototype.IsHoleNode = function ()\n\t  {\n\t    var result = true;\n\t    var node = this.m_Parent;\n\t    while (node !== null)\n\t    {\n\t      result = !result;\n\t      node = node.m_Parent;\n\t    }\n\t    return result;\n\t  };\n\t  ClipperLib.PolyNode.prototype.ChildCount = function ()\n\t  {\n\t    return this.m_Childs.length;\n\t  };\n\t  ClipperLib.PolyNode.prototype.Contour = function ()\n\t  {\n\t    return this.m_polygon;\n\t  };\n\t  ClipperLib.PolyNode.prototype.AddChild = function (Child)\n\t  {\n\t    var cnt = this.m_Childs.length;\n\t    this.m_Childs.push(Child);\n\t    Child.m_Parent = this;\n\t    Child.m_Index = cnt;\n\t  };\n\t  ClipperLib.PolyNode.prototype.GetNext = function ()\n\t  {\n\t    if (this.m_Childs.length > 0)\n\t      return this.m_Childs[0];\n\t    else\n\t      return this.GetNextSiblingUp();\n\t  };\n\t  ClipperLib.PolyNode.prototype.GetNextSiblingUp = function ()\n\t  {\n\t    if (this.m_Parent === null)\n\t      return null;\n\t    else if (this.m_Index == this.m_Parent.m_Childs.length - 1)\n\t      return this.m_Parent.GetNextSiblingUp();\n\t    else\n\t      return this.m_Parent.m_Childs[this.m_Index + 1];\n\t  };\n\t  ClipperLib.PolyNode.prototype.Childs = function ()\n\t  {\n\t    return this.m_Childs;\n\t  };\n\t  ClipperLib.PolyNode.prototype.Parent = function ()\n\t  {\n\t    return this.m_Parent;\n\t  };\n\t  ClipperLib.PolyNode.prototype.IsHole = function ()\n\t  {\n\t    return this.IsHoleNode();\n\t  };\n\t  // PolyTree : PolyNode\n\t  ClipperLib.PolyTree = function ()\n\t  {\n\t    this.m_AllPolys = [];\n\t    ClipperLib.PolyNode.call(this);\n\t  };\n\t  ClipperLib.PolyTree.prototype.Clear = function ()\n\t  {\n\t    for (var i = 0, ilen = this.m_AllPolys.length; i < ilen; i++)\n\t      this.m_AllPolys[i] = null;\n\t    this.m_AllPolys.length = 0;\n\t    this.m_Childs.length = 0;\n\t  };\n\t  ClipperLib.PolyTree.prototype.GetFirst = function ()\n\t  {\n\t    if (this.m_Childs.length > 0)\n\t      return this.m_Childs[0];\n\t    else\n\t      return null;\n\t  };\n\t  ClipperLib.PolyTree.prototype.Total = function ()\n\t  {\n\t\t\tvar result = this.m_AllPolys.length;\n\t\t\t//with negative offsets, ignore the hidden outer polygon ...\n\t\t\tif (result > 0 && this.m_Childs[0] != this.m_AllPolys[0]) result--;\n\t\t\treturn result;\n\t  };\n\t  Inherit(ClipperLib.PolyTree, ClipperLib.PolyNode);\n\t  // -------------------------------\n\t  // PolyTree & PolyNode end\n\t  ClipperLib.Math_Abs_Int64 = ClipperLib.Math_Abs_Int32 = ClipperLib.Math_Abs_Double = function (a)\n\t  {\n\t    return Math.abs(a);\n\t  };\n\t  ClipperLib.Math_Max_Int32_Int32 = function (a, b)\n\t  {\n\t    return Math.max(a, b);\n\t  };\n\t  /*\n\t  -----------------------------------\n\t  cast_32 speedtest: http://jsperf.com/truncate-float-to-integer/2\n\t  -----------------------------------\n\t  */\n\t  if (browser.msie || browser.opera || browser.safari) ClipperLib.Cast_Int32 = function (a)\n\t  {\n\t    return a | 0;\n\t  };\n\t  else ClipperLib.Cast_Int32 = function (a)\n\t  { // eg. browser.chrome || browser.chromium || browser.firefox\n\t    return~~ a;\n\t  };\n\t  /*\n\t  --------------------------\n\t  cast_64 speedtests: http://jsperf.com/truncate-float-to-integer\n\t  Chrome: bitwise_not_floor\n\t  Firefox17: toInteger (typeof test)\n\t  IE9: bitwise_or_floor\n\t  IE7 and IE8: to_parseint\n\t  Chromium: to_floor_or_ceil\n\t  Firefox3: to_floor_or_ceil\n\t  Firefox15: to_floor_or_ceil\n\t  Opera: to_floor_or_ceil\n\t  Safari: to_floor_or_ceil\n\t  --------------------------\n\t  */\n\t  if (browser.chrome) ClipperLib.Cast_Int64 = function (a)\n\t  {\n\t    if (a < -2147483648 || a > 2147483647)\n\t      return a < 0 ? Math.ceil(a) : Math.floor(a);\n\t    else return~~ a;\n\t  };\n\t  else if (browser.firefox && typeof (Number.toInteger) == \"function\") ClipperLib.Cast_Int64 = function (a)\n\t  {\n\t    return Number.toInteger(a);\n\t  };\n\t  else if (browser.msie7 || browser.msie8) ClipperLib.Cast_Int64 = function (a)\n\t  {\n\t    return parseInt(a, 10);\n\t  };\n\t  else if (browser.msie) ClipperLib.Cast_Int64 = function (a)\n\t  {\n\t    if (a < -2147483648 || a > 2147483647)\n\t      return a < 0 ? Math.ceil(a) : Math.floor(a);\n\t    return a | 0;\n\t  };\n\t  // eg. browser.chromium || browser.firefox || browser.opera || browser.safari\n\t  else ClipperLib.Cast_Int64 = function (a)\n\t  {\n\t    return a < 0 ? Math.ceil(a) : Math.floor(a);\n\t  };\n\t  ClipperLib.Clear = function (a)\n\t  {\n\t    a.length = 0;\n\t  };\n\t  //ClipperLib.MaxSteps = 64; // How many steps at maximum in arc in BuildArc() function\n\t  ClipperLib.PI = 3.141592653589793;\n\t  ClipperLib.PI2 = 2 * 3.141592653589793;\n\t  ClipperLib.IntPoint = function ()\n\t  {\n\t    var a = arguments,\n\t      alen = a.length;\n\t    this.X = 0;\n\t    this.Y = 0;\n\t    if (use_xyz)\n\t    {\n\t      this.Z = 0;\n\t      if (alen == 3) // public IntPoint(cInt x, cInt y, cInt z = 0)\n\t      {\n\t        this.X = a[0];\n\t        this.Y = a[1];\n\t        this.Z = a[2];\n\t      }\n\t      else if (alen == 2) // public IntPoint(cInt x, cInt y)\n\t      {\n\t        this.X = a[0];\n\t        this.Y = a[1];\n\t        this.Z = 0;\n\t      }\n\t      else if (alen == 1)\n\t      {\n\t        if (a[0] instanceof ClipperLib.DoublePoint) // public IntPoint(DoublePoint dp)\n\t        {\n\t          var dp = a[0];\n\t          this.X = ClipperLib.Clipper.Round(dp.X);\n\t          this.Y = ClipperLib.Clipper.Round(dp.Y);\n\t          this.Z = 0;\n\t        }\n\t        else // public IntPoint(IntPoint pt)\n\t        {\n\t          var pt = a[0];\n\t          if (typeof (pt.Z) == \"undefined\") pt.Z = 0;\n\t          this.X = pt.X;\n\t          this.Y = pt.Y;\n\t          this.Z = pt.Z;\n\t        }\n\t      }\n\t      else // public IntPoint()\n\t      {\n\t        this.X = 0;\n\t        this.Y = 0;\n\t        this.Z = 0;\n\t      }\n\t    }\n\t    else // if (!use_xyz)\n\t    {\n\t      if (alen == 2) // public IntPoint(cInt X, cInt Y)\n\t      {\n\t        this.X = a[0];\n\t        this.Y = a[1];\n\t      }\n\t      else if (alen == 1)\n\t      {\n\t        if (a[0] instanceof ClipperLib.DoublePoint) // public IntPoint(DoublePoint dp)\n\t        {\n\t          var dp = a[0];\n\t          this.X = ClipperLib.Clipper.Round(dp.X);\n\t          this.Y = ClipperLib.Clipper.Round(dp.Y);\n\t        }\n\t        else // public IntPoint(IntPoint pt)\n\t        {\n\t          var pt = a[0];\n\t          this.X = pt.X;\n\t          this.Y = pt.Y;\n\t        }\n\t      }\n\t      else // public IntPoint(IntPoint pt)\n\t      {\n\t        this.X = 0;\n\t        this.Y = 0;\n\t      }\n\t    }\n\t  };\n\t  ClipperLib.IntPoint.op_Equality = function (a, b)\n\t  {\n\t    //return a == b;\n\t    return a.X == b.X && a.Y == b.Y;\n\t  };\n\t  ClipperLib.IntPoint.op_Inequality = function (a, b)\n\t  {\n\t    //return a != b;\n\t    return a.X != b.X || a.Y != b.Y;\n\t  };\n\t  /*\n\t  ClipperLib.IntPoint.prototype.Equals = function (obj)\n\t  {\n\t    if (obj === null)\n\t        return false;\n\t    if (obj instanceof ClipperLib.IntPoint)\n\t    {\n\t        var a = Cast(obj, ClipperLib.IntPoint);\n\t        return (this.X == a.X) && (this.Y == a.Y);\n\t    }\n\t    else\n\t        return false;\n\t  };\n\t*/\n\t  if (use_xyz)\n\t  {\n\t    ClipperLib.IntPoint0 = function ()\n\t    {\n\t      this.X = 0;\n\t      this.Y = 0;\n\t      this.Z = 0;\n\t    };\n\t    ClipperLib.IntPoint1 = function (pt)\n\t    {\n\t      this.X = pt.X;\n\t      this.Y = pt.Y;\n\t      this.Z = pt.Z;\n\t    };\n\t    ClipperLib.IntPoint1dp = function (dp)\n\t    {\n\t      this.X = ClipperLib.Clipper.Round(dp.X);\n\t      this.Y = ClipperLib.Clipper.Round(dp.Y);\n\t      this.Z = 0;\n\t    };\n\t    ClipperLib.IntPoint2 = function (x, y)\n\t    {\n\t      this.X = x;\n\t      this.Y = y;\n\t      this.Z = 0;\n\t    };\n\t    ClipperLib.IntPoint3 = function (x, y, z)\n\t    {\n\t      this.X = x;\n\t      this.Y = y;\n\t      this.Z = z;\n\t    };\n\t  }\n\t  else // if (!use_xyz)\n\t  {\n\t    ClipperLib.IntPoint0 = function ()\n\t    {\n\t      this.X = 0;\n\t      this.Y = 0;\n\t    };\n\t    ClipperLib.IntPoint1 = function (pt)\n\t    {\n\t      this.X = pt.X;\n\t      this.Y = pt.Y;\n\t    };\n\t    ClipperLib.IntPoint1dp = function (dp)\n\t    {\n\t      this.X = ClipperLib.Clipper.Round(dp.X);\n\t      this.Y = ClipperLib.Clipper.Round(dp.Y);\n\t    };\n\t    ClipperLib.IntPoint2 = function (x, y)\n\t    {\n\t      this.X = x;\n\t      this.Y = y;\n\t    };\n\t  }\n\t  ClipperLib.IntRect = function ()\n\t  {\n\t    var a = arguments,\n\t      alen = a.length;\n\t    if (alen == 4) // function (l, t, r, b)\n\t    {\n\t      this.left = a[0];\n\t      this.top = a[1];\n\t      this.right = a[2];\n\t      this.bottom = a[3];\n\t    }\n\t    else if (alen == 1) // function (ir)\n\t    {\n\t      this.left = ir.left;\n\t      this.top = ir.top;\n\t      this.right = ir.right;\n\t      this.bottom = ir.bottom;\n\t    }\n\t    else // function ()\n\t    {\n\t      this.left = 0;\n\t      this.top = 0;\n\t      this.right = 0;\n\t      this.bottom = 0;\n\t    }\n\t  };\n\t  ClipperLib.IntRect0 = function ()\n\t  {\n\t    this.left = 0;\n\t    this.top = 0;\n\t    this.right = 0;\n\t    this.bottom = 0;\n\t  };\n\t  ClipperLib.IntRect1 = function (ir)\n\t  {\n\t    this.left = ir.left;\n\t    this.top = ir.top;\n\t    this.right = ir.right;\n\t    this.bottom = ir.bottom;\n\t  };\n\t  ClipperLib.IntRect4 = function (l, t, r, b)\n\t  {\n\t    this.left = l;\n\t    this.top = t;\n\t    this.right = r;\n\t    this.bottom = b;\n\t  };\n\t  ClipperLib.ClipType = {\n\t    ctIntersection: 0,\n\t    ctUnion: 1,\n\t    ctDifference: 2,\n\t    ctXor: 3\n\t  };\n\t  ClipperLib.PolyType = {\n\t    ptSubject: 0,\n\t    ptClip: 1\n\t  };\n\t  ClipperLib.PolyFillType = {\n\t    pftEvenOdd: 0,\n\t    pftNonZero: 1,\n\t    pftPositive: 2,\n\t    pftNegative: 3\n\t  };\n\t  ClipperLib.JoinType = {\n\t    jtSquare: 0,\n\t    jtRound: 1,\n\t    jtMiter: 2\n\t  };\n\t  ClipperLib.EndType = {\n\t    etOpenSquare: 0,\n\t    etOpenRound: 1,\n\t    etOpenButt: 2,\n\t    etClosedLine: 3,\n\t    etClosedPolygon: 4\n\t  };\n\t  ClipperLib.EdgeSide = {\n\t    esLeft: 0,\n\t    esRight: 1\n\t  };\n\t  ClipperLib.Direction = {\n\t    dRightToLeft: 0,\n\t    dLeftToRight: 1\n\t  };\n\t  ClipperLib.TEdge = function ()\n\t  {\n\t    this.Bot = new ClipperLib.IntPoint();\n\t    this.Curr = new ClipperLib.IntPoint();\n\t    this.Top = new ClipperLib.IntPoint();\n\t    this.Delta = new ClipperLib.IntPoint();\n\t    this.Dx = 0;\n\t    this.PolyTyp = ClipperLib.PolyType.ptSubject;\n\t    this.Side = ClipperLib.EdgeSide.esLeft;\n\t    this.WindDelta = 0;\n\t    this.WindCnt = 0;\n\t    this.WindCnt2 = 0;\n\t    this.OutIdx = 0;\n\t    this.Next = null;\n\t    this.Prev = null;\n\t    this.NextInLML = null;\n\t    this.NextInAEL = null;\n\t    this.PrevInAEL = null;\n\t    this.NextInSEL = null;\n\t    this.PrevInSEL = null;\n\t  };\n\t  ClipperLib.IntersectNode = function ()\n\t  {\n\t    this.Edge1 = null;\n\t    this.Edge2 = null;\n\t    this.Pt = new ClipperLib.IntPoint();\n\t  };\n\t  ClipperLib.MyIntersectNodeSort = function () {};\n\t  ClipperLib.MyIntersectNodeSort.Compare = function (node1, node2)\n\t  {\n\t    var i = node2.Pt.Y - node1.Pt.Y;\n\t    if (i > 0) return 1;\n\t    else if (i < 0) return -1;\n\t    else return 0;\n\t  };\n\t\n\t  ClipperLib.LocalMinima = function ()\n\t  {\n\t    this.Y = 0;\n\t    this.LeftBound = null;\n\t    this.RightBound = null;\n\t    this.Next = null;\n\t  };\n\t  ClipperLib.Scanbeam = function ()\n\t  {\n\t    this.Y = 0;\n\t    this.Next = null;\n\t  };\n\t  ClipperLib.OutRec = function ()\n\t  {\n\t    this.Idx = 0;\n\t    this.IsHole = false;\n\t    this.IsOpen = false;\n\t    this.FirstLeft = null;\n\t    this.Pts = null;\n\t    this.BottomPt = null;\n\t    this.PolyNode = null;\n\t  };\n\t  ClipperLib.OutPt = function ()\n\t  {\n\t    this.Idx = 0;\n\t    this.Pt = new ClipperLib.IntPoint();\n\t    this.Next = null;\n\t    this.Prev = null;\n\t  };\n\t  ClipperLib.Join = function ()\n\t  {\n\t    this.OutPt1 = null;\n\t    this.OutPt2 = null;\n\t    this.OffPt = new ClipperLib.IntPoint();\n\t  };\n\t  ClipperLib.ClipperBase = function ()\n\t  {\n\t    this.m_MinimaList = null;\n\t    this.m_CurrentLM = null;\n\t    this.m_edges = new Array();\n\t    this.m_UseFullRange = false;\n\t    this.m_HasOpenPaths = false;\n\t    this.PreserveCollinear = false;\n\t    this.m_MinimaList = null;\n\t    this.m_CurrentLM = null;\n\t    this.m_UseFullRange = false;\n\t    this.m_HasOpenPaths = false;\n\t  };\n\t  // Ranges are in original C# too high for Javascript (in current state 2013 september):\n\t  // protected const double horizontal = -3.4E+38;\n\t  // internal const cInt loRange = 0x3FFFFFFF; // = 1073741823 = sqrt(2^63 -1)/2\n\t  // internal const cInt hiRange = 0x3FFFFFFFFFFFFFFFL; // = 4611686018427387903 = sqrt(2^127 -1)/2\n\t  // So had to adjust them to more suitable for Javascript.\n\t  // If JS some day supports truly 64-bit integers, then these ranges can be as in C#\n\t  // and biginteger library can be more simpler (as then 128bit can be represented as two 64bit numbers)\n\t  ClipperLib.ClipperBase.horizontal = -9007199254740992; //-2^53\n\t  ClipperLib.ClipperBase.Skip = -2;\n\t  ClipperLib.ClipperBase.Unassigned = -1;\n\t  ClipperLib.ClipperBase.tolerance = 1E-20;\n\t  if (use_int32)\n\t  {\n\t    ClipperLib.ClipperBase.loRange = 0x7FFF;\n\t    ClipperLib.ClipperBase.hiRange = 0x7FFF;\n\t  }\n\t  else\n\t  {\n\t    ClipperLib.ClipperBase.loRange = 47453132; // sqrt(2^53 -1)/2\n\t    ClipperLib.ClipperBase.hiRange = 4503599627370495; // sqrt(2^106 -1)/2\n\t  }\n\t\n\t  ClipperLib.ClipperBase.near_zero = function (val)\n\t  {\n\t    return (val > -ClipperLib.ClipperBase.tolerance) && (val < ClipperLib.ClipperBase.tolerance);\n\t  };\n\t  ClipperLib.ClipperBase.IsHorizontal = function (e)\n\t  {\n\t    return e.Delta.Y === 0;\n\t  };\n\t  ClipperLib.ClipperBase.prototype.PointIsVertex = function (pt, pp)\n\t  {\n\t    var pp2 = pp;\n\t    do {\n\t      if (ClipperLib.IntPoint.op_Equality(pp2.Pt, pt))\n\t        return true;\n\t      pp2 = pp2.Next;\n\t    }\n\t    while (pp2 != pp)\n\t    return false;\n\t  };\n\t  ClipperLib.ClipperBase.prototype.PointOnLineSegment = function (pt, linePt1, linePt2, UseFullRange)\n\t  {\n\t    if (UseFullRange)\n\t      return ((pt.X == linePt1.X) && (pt.Y == linePt1.Y)) ||\n\t        ((pt.X == linePt2.X) && (pt.Y == linePt2.Y)) ||\n\t        (((pt.X > linePt1.X) == (pt.X < linePt2.X)) &&\n\t        ((pt.Y > linePt1.Y) == (pt.Y < linePt2.Y)) &&\n\t        (Int128.op_Equality(Int128.Int128Mul((pt.X - linePt1.X), (linePt2.Y - linePt1.Y)),\n\t          Int128.Int128Mul((linePt2.X - linePt1.X), (pt.Y - linePt1.Y)))));\n\t    else\n\t      return ((pt.X == linePt1.X) && (pt.Y == linePt1.Y)) || ((pt.X == linePt2.X) && (pt.Y == linePt2.Y)) || (((pt.X > linePt1.X) == (pt.X < linePt2.X)) && ((pt.Y > linePt1.Y) == (pt.Y < linePt2.Y)) && ((pt.X - linePt1.X) * (linePt2.Y - linePt1.Y) == (linePt2.X - linePt1.X) * (pt.Y - linePt1.Y)));\n\t  };\n\t  ClipperLib.ClipperBase.prototype.PointOnPolygon = function (pt, pp, UseFullRange)\n\t  {\n\t    var pp2 = pp;\n\t    while (true)\n\t    {\n\t      if (this.PointOnLineSegment(pt, pp2.Pt, pp2.Next.Pt, UseFullRange))\n\t        return true;\n\t      pp2 = pp2.Next;\n\t      if (pp2 == pp)\n\t        break;\n\t    }\n\t    return false;\n\t  };\n\t  ClipperLib.ClipperBase.prototype.SlopesEqual = ClipperLib.ClipperBase.SlopesEqual = function ()\n\t  {\n\t    var a = arguments,\n\t      alen = a.length;\n\t    var e1, e2, pt1, pt2, pt3, pt4, UseFullRange;\n\t    if (alen == 3) // function (e1, e2, UseFullRange)\n\t    {\n\t      e1 = a[0];\n\t      e2 = a[1];\n\t      UseFullRange = a[2];\n\t      if (UseFullRange)\n\t        return Int128.op_Equality(Int128.Int128Mul(e1.Delta.Y, e2.Delta.X), Int128.Int128Mul(e1.Delta.X, e2.Delta.Y));\n\t      else\n\t        return ClipperLib.Cast_Int64((e1.Delta.Y) * (e2.Delta.X)) == ClipperLib.Cast_Int64((e1.Delta.X) * (e2.Delta.Y));\n\t    }\n\t    else if (alen == 4) // function (pt1, pt2, pt3, UseFullRange)\n\t    {\n\t      pt1 = a[0];\n\t      pt2 = a[1];\n\t      pt3 = a[2];\n\t      UseFullRange = a[3];\n\t      if (UseFullRange)\n\t        return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt2.X - pt3.X), Int128.Int128Mul(pt1.X - pt2.X, pt2.Y - pt3.Y));\n\t      else\n\t        return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt2.X - pt3.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt2.Y - pt3.Y)) === 0;\n\t    }\n\t    else // function (pt1, pt2, pt3, pt4, UseFullRange)\n\t    {\n\t      pt1 = a[0];\n\t      pt2 = a[1];\n\t      pt3 = a[2];\n\t      pt4 = a[3];\n\t      UseFullRange = a[4];\n\t      if (UseFullRange)\n\t        return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt3.X - pt4.X), Int128.Int128Mul(pt1.X - pt2.X, pt3.Y - pt4.Y));\n\t      else\n\t        return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt3.X - pt4.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt3.Y - pt4.Y)) === 0;\n\t    }\n\t  };\n\t  ClipperLib.ClipperBase.SlopesEqual3 = function (e1, e2, UseFullRange)\n\t  {\n\t    if (UseFullRange)\n\t      return Int128.op_Equality(Int128.Int128Mul(e1.Delta.Y, e2.Delta.X), Int128.Int128Mul(e1.Delta.X, e2.Delta.Y));\n\t    else\n\t      return ClipperLib.Cast_Int64((e1.Delta.Y) * (e2.Delta.X)) == ClipperLib.Cast_Int64((e1.Delta.X) * (e2.Delta.Y));\n\t  };\n\t  ClipperLib.ClipperBase.SlopesEqual4 = function (pt1, pt2, pt3, UseFullRange)\n\t  {\n\t    if (UseFullRange)\n\t      return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt2.X - pt3.X), Int128.Int128Mul(pt1.X - pt2.X, pt2.Y - pt3.Y));\n\t    else\n\t      return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt2.X - pt3.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt2.Y - pt3.Y)) === 0;\n\t  };\n\t  ClipperLib.ClipperBase.SlopesEqual5 = function (pt1, pt2, pt3, pt4, UseFullRange)\n\t  {\n\t    if (UseFullRange)\n\t      return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt3.X - pt4.X), Int128.Int128Mul(pt1.X - pt2.X, pt3.Y - pt4.Y));\n\t    else\n\t      return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt3.X - pt4.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt3.Y - pt4.Y)) === 0;\n\t  };\n\t  ClipperLib.ClipperBase.prototype.Clear = function ()\n\t  {\n\t    this.DisposeLocalMinimaList();\n\t    for (var i = 0, ilen = this.m_edges.length; i < ilen; ++i)\n\t    {\n\t      for (var j = 0, jlen = this.m_edges[i].length; j < jlen; ++j)\n\t        this.m_edges[i][j] = null;\n\t      ClipperLib.Clear(this.m_edges[i]);\n\t    }\n\t    ClipperLib.Clear(this.m_edges);\n\t    this.m_UseFullRange = false;\n\t    this.m_HasOpenPaths = false;\n\t  };\n\t  ClipperLib.ClipperBase.prototype.DisposeLocalMinimaList = function ()\n\t  {\n\t    while (this.m_MinimaList !== null)\n\t    {\n\t      var tmpLm = this.m_MinimaList.Next;\n\t      this.m_MinimaList = null;\n\t      this.m_MinimaList = tmpLm;\n\t    }\n\t    this.m_CurrentLM = null;\n\t  };\n\t  ClipperLib.ClipperBase.prototype.RangeTest = function (Pt, useFullRange)\n\t  {\n\t    if (useFullRange.Value)\n\t    {\n\t      if (Pt.X > ClipperLib.ClipperBase.hiRange || Pt.Y > ClipperLib.ClipperBase.hiRange || -Pt.X > ClipperLib.ClipperBase.hiRange || -Pt.Y > ClipperLib.ClipperBase.hiRange)\n\t        ClipperLib.Error(\"Coordinate outside allowed range in RangeTest().\");\n\t    }\n\t    else if (Pt.X > ClipperLib.ClipperBase.loRange || Pt.Y > ClipperLib.ClipperBase.loRange || -Pt.X > ClipperLib.ClipperBase.loRange || -Pt.Y > ClipperLib.ClipperBase.loRange)\n\t    {\n\t      useFullRange.Value = true;\n\t      this.RangeTest(Pt, useFullRange);\n\t    }\n\t  };\n\t  ClipperLib.ClipperBase.prototype.InitEdge = function (e, eNext, ePrev, pt)\n\t  {\n\t    e.Next = eNext;\n\t    e.Prev = ePrev;\n\t    //e.Curr = pt;\n\t    e.Curr.X = pt.X;\n\t    e.Curr.Y = pt.Y;\n\t    e.OutIdx = -1;\n\t  };\n\t  ClipperLib.ClipperBase.prototype.InitEdge2 = function (e, polyType)\n\t  {\n\t    if (e.Curr.Y >= e.Next.Curr.Y)\n\t    {\n\t      //e.Bot = e.Curr;\n\t      e.Bot.X = e.Curr.X;\n\t      e.Bot.Y = e.Curr.Y;\n\t      //e.Top = e.Next.Curr;\n\t      e.Top.X = e.Next.Curr.X;\n\t      e.Top.Y = e.Next.Curr.Y;\n\t    }\n\t    else\n\t    {\n\t      //e.Top = e.Curr;\n\t      e.Top.X = e.Curr.X;\n\t      e.Top.Y = e.Curr.Y;\n\t      //e.Bot = e.Next.Curr;\n\t      e.Bot.X = e.Next.Curr.X;\n\t      e.Bot.Y = e.Next.Curr.Y;\n\t    }\n\t    this.SetDx(e);\n\t    e.PolyTyp = polyType;\n\t  };\n\t  ClipperLib.ClipperBase.prototype.FindNextLocMin = function (E)\n\t  {\n\t    var E2;\n\t    for (;;)\n\t    {\n\t      while (ClipperLib.IntPoint.op_Inequality(E.Bot, E.Prev.Bot) || ClipperLib.IntPoint.op_Equality(E.Curr, E.Top))\n\t        E = E.Next;\n\t      if (E.Dx != ClipperLib.ClipperBase.horizontal && E.Prev.Dx != ClipperLib.ClipperBase.horizontal)\n\t        break;\n\t      while (E.Prev.Dx == ClipperLib.ClipperBase.horizontal)\n\t        E = E.Prev;\n\t      E2 = E;\n\t      while (E.Dx == ClipperLib.ClipperBase.horizontal)\n\t        E = E.Next;\n\t      if (E.Top.Y == E.Prev.Bot.Y)\n\t        continue;\n\t      //ie just an intermediate horz.\n\t      if (E2.Prev.Bot.X < E.Bot.X)\n\t        E = E2;\n\t      break;\n\t    }\n\t    return E;\n\t  };\n\t  ClipperLib.ClipperBase.prototype.ProcessBound = function (E, LeftBoundIsForward)\n\t  {\n\t    var EStart;\n\t    var Result = E;\n\t    var Horz;\n\t\n\t      if (Result.OutIdx == ClipperLib.ClipperBase.Skip)\n\t      {\n\t        //check if there are edges beyond the skip edge in the bound and if so\n\t        //create another LocMin and calling ProcessBound once more ...\n\t        E = Result;\n\t        if (LeftBoundIsForward)\n\t        {\n\t          while (E.Top.Y == E.Next.Bot.Y) E = E.Next;\n\t          while (E != Result && E.Dx == ClipperLib.ClipperBase.horizontal) E = E.Prev;\n\t        }\n\t        else\n\t        {\n\t          while (E.Top.Y == E.Prev.Bot.Y) E = E.Prev;\n\t          while (E != Result && E.Dx == ClipperLib.ClipperBase.horizontal) E = E.Next;\n\t        }\n\t        if (E == Result)\n\t        {\n\t          if (LeftBoundIsForward) Result = E.Next;\n\t          else Result = E.Prev;\n\t        }\n\t        else\n\t        {\n\t          //there are more edges in the bound beyond result starting with E\n\t          if (LeftBoundIsForward)\n\t            E = Result.Next;\n\t          else\n\t            E = Result.Prev;\n\t          var locMin = new ClipperLib.LocalMinima();\n\t          locMin.Next = null;\n\t          locMin.Y = E.Bot.Y;\n\t          locMin.LeftBound = null;\n\t          locMin.RightBound = E;\n\t          E.WindDelta = 0;\n\t          Result = this.ProcessBound(E, LeftBoundIsForward);\n\t          this.InsertLocalMinima(locMin);\n\t        }\n\t        return Result;\n\t      }\n\t\n\t      if (E.Dx == ClipperLib.ClipperBase.horizontal)\n\t      {\n\t        //We need to be careful with open paths because this may not be a\n\t        //true local minima (ie E may be following a skip edge).\n\t        //Also, consecutive horz. edges may start heading left before going right.\n\t        if (LeftBoundIsForward) EStart = E.Prev;\n\t        else EStart = E.Next;\n\t        if (EStart.OutIdx != ClipperLib.ClipperBase.Skip)\n\t        {\n\t          if (EStart.Dx == ClipperLib.ClipperBase.horizontal) //ie an adjoining horizontal skip edge\n\t          {\n\t            if (EStart.Bot.X != E.Bot.X && EStart.Top.X != E.Bot.X)\n\t              this.ReverseHorizontal(E);\n\t          }\n\t          else if (EStart.Bot.X != E.Bot.X)\n\t            this.ReverseHorizontal(E);\n\t        }\n\t      }\n\t\n\t      EStart = E;\n\t      if (LeftBoundIsForward)\n\t      {\n\t        while (Result.Top.Y == Result.Next.Bot.Y && Result.Next.OutIdx != ClipperLib.ClipperBase.Skip)\n\t          Result = Result.Next;\n\t        if (Result.Dx == ClipperLib.ClipperBase.horizontal && Result.Next.OutIdx != ClipperLib.ClipperBase.Skip)\n\t        {\n\t          //nb: at the top of a bound, horizontals are added to the bound\n\t          //only when the preceding edge attaches to the horizontal's left vertex\n\t          //unless a Skip edge is encountered when that becomes the top divide\n\t          Horz = Result;\n\t          while (Horz.Prev.Dx == ClipperLib.ClipperBase.horizontal)\n\t            Horz = Horz.Prev;\n\t          if (Horz.Prev.Top.X == Result.Next.Top.X)\n\t          {\n\t            if (!LeftBoundIsForward)\n\t              Result = Horz.Prev;\n\t          }\n\t          else if (Horz.Prev.Top.X > Result.Next.Top.X)\n\t            Result = Horz.Prev;\n\t        }\n\t        while (E != Result)\n\t        {\n\t          E.NextInLML = E.Next;\n\t          if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Prev.Top.X)\n\t            this.ReverseHorizontal(E);\n\t          E = E.Next;\n\t        }\n\t        if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Prev.Top.X)\n\t          this.ReverseHorizontal(E);\n\t        Result = Result.Next;\n\t        //move to the edge just beyond current bound\n\t      }\n\t      else\n\t      {\n\t        while (Result.Top.Y == Result.Prev.Bot.Y && Result.Prev.OutIdx != ClipperLib.ClipperBase.Skip)\n\t          Result = Result.Prev;\n\t        if (Result.Dx == ClipperLib.ClipperBase.horizontal && Result.Prev.OutIdx != ClipperLib.ClipperBase.Skip)\n\t        {\n\t          Horz = Result;\n\t          while (Horz.Next.Dx == ClipperLib.ClipperBase.horizontal)\n\t            Horz = Horz.Next;\n\t          if (Horz.Next.Top.X == Result.Prev.Top.X)\n\t          {\n\t            if (!LeftBoundIsForward)\n\t              Result = Horz.Next;\n\t          }\n\t          else if (Horz.Next.Top.X > Result.Prev.Top.X)\n\t            Result = Horz.Next;\n\t        }\n\t        while (E != Result)\n\t        {\n\t          E.NextInLML = E.Prev;\n\t          if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Next.Top.X)\n\t            this.ReverseHorizontal(E);\n\t          E = E.Prev;\n\t        }\n\t        if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Next.Top.X)\n\t          this.ReverseHorizontal(E);\n\t        Result = Result.Prev;\n\t        //move to the edge just beyond current bound\n\t      }\n\t\n\t    return Result;\n\t  };\n\t\n\t  ClipperLib.ClipperBase.prototype.AddPath = function (pg, polyType, Closed)\n\t  {\n\t    if (use_lines)\n\t    {\n\t      if (!Closed && polyType == ClipperLib.PolyType.ptClip)\n\t        ClipperLib.Error(\"AddPath: Open paths must be subject.\");\n\t    }\n\t    else\n\t    {\n\t      if (!Closed)\n\t        ClipperLib.Error(\"AddPath: Open paths have been disabled.\");\n\t    }\n\t    var highI = pg.length - 1;\n\t    if (Closed)\n\t      while (highI > 0 && (ClipperLib.IntPoint.op_Equality(pg[highI], pg[0])))\n\t    --highI;\n\t    while (highI > 0 && (ClipperLib.IntPoint.op_Equality(pg[highI], pg[highI - 1])))\n\t    --highI;\n\t    if ((Closed && highI < 2) || (!Closed && highI < 1))\n\t      return false;\n\t    //create a new edge array ...\n\t    var edges = new Array();\n\t    for (var i = 0; i <= highI; i++)\n\t      edges.push(new ClipperLib.TEdge());\n\t    var IsFlat = true;\n\t    //1. Basic (first) edge initialization ...\n\t\n\t    //edges[1].Curr = pg[1];\n\t    edges[1].Curr.X = pg[1].X;\n\t    edges[1].Curr.Y = pg[1].Y;\n\t\n\t    var $1 = {Value: this.m_UseFullRange};\n\t    this.RangeTest(pg[0], $1);\n\t    this.m_UseFullRange = $1.Value;\n\t\n\t    $1.Value = this.m_UseFullRange;\n\t    this.RangeTest(pg[highI], $1);\n\t    this.m_UseFullRange = $1.Value;\n\t\n\t    this.InitEdge(edges[0], edges[1], edges[highI], pg[0]);\n\t    this.InitEdge(edges[highI], edges[0], edges[highI - 1], pg[highI]);\n\t    for (var i = highI - 1; i >= 1; --i)\n\t    {\n\t      $1.Value = this.m_UseFullRange;\n\t      this.RangeTest(pg[i], $1);\n\t      this.m_UseFullRange = $1.Value;\n\t\n\t      this.InitEdge(edges[i], edges[i + 1], edges[i - 1], pg[i]);\n\t    }\n\t\n\t    var eStart = edges[0];\n\t    //2. Remove duplicate vertices, and (when closed) collinear edges ...\n\t    var E = eStart,\n\t      eLoopStop = eStart;\n\t    for (;;)\n\t    {\n\t    //console.log(E.Next, eStart);\n\t    \t//nb: allows matching start and end points when not Closed ...\n\t      if (E.Curr == E.Next.Curr && (Closed || E.Next != eStart))\n\t      {\n\t        if (E == E.Next)\n\t          break;\n\t        if (E == eStart)\n\t          eStart = E.Next;\n\t        E = this.RemoveEdge(E);\n\t        eLoopStop = E;\n\t        continue;\n\t      }\n\t      if (E.Prev == E.Next)\n\t        break;\n\t      else if (Closed && ClipperLib.ClipperBase.SlopesEqual(E.Prev.Curr, E.Curr, E.Next.Curr, this.m_UseFullRange) && (!this.PreserveCollinear || !this.Pt2IsBetweenPt1AndPt3(E.Prev.Curr, E.Curr, E.Next.Curr)))\n\t      {\n\t        //Collinear edges are allowed for open paths but in closed paths\n\t        //the default is to merge adjacent collinear edges into a single edge.\n\t        //However, if the PreserveCollinear property is enabled, only overlapping\n\t        //collinear edges (ie spikes) will be removed from closed paths.\n\t        if (E == eStart)\n\t          eStart = E.Next;\n\t        E = this.RemoveEdge(E);\n\t        E = E.Prev;\n\t        eLoopStop = E;\n\t        continue;\n\t      }\n\t      E = E.Next;\n\t      if ((E == eLoopStop) || (!Closed && E.Next == eStart)) break;\n\t    }\n\t    if ((!Closed && (E == E.Next)) || (Closed && (E.Prev == E.Next)))\n\t      return false;\n\t    if (!Closed)\n\t    {\n\t      this.m_HasOpenPaths = true;\n\t      eStart.Prev.OutIdx = ClipperLib.ClipperBase.Skip;\n\t    }\n\t    //3. Do second stage of edge initialization ...\n\t    E = eStart;\n\t    do {\n\t      this.InitEdge2(E, polyType);\n\t      E = E.Next;\n\t      if (IsFlat && E.Curr.Y != eStart.Curr.Y)\n\t        IsFlat = false;\n\t    }\n\t    while (E != eStart)\n\t    //4. Finally, add edge bounds to LocalMinima list ...\n\t    //Totally flat paths must be handled differently when adding them\n\t    //to LocalMinima list to avoid endless loops etc ...\n\t    if (IsFlat)\n\t    {\n\t      if (Closed)\n\t        return false;\n\t      E.Prev.OutIdx = ClipperLib.ClipperBase.Skip;\n\t      if (E.Prev.Bot.X < E.Prev.Top.X)\n\t        this.ReverseHorizontal(E.Prev);\n\t      var locMin = new ClipperLib.LocalMinima();\n\t      locMin.Next = null;\n\t      locMin.Y = E.Bot.Y;\n\t      locMin.LeftBound = null;\n\t      locMin.RightBound = E;\n\t      locMin.RightBound.Side = ClipperLib.EdgeSide.esRight;\n\t      locMin.RightBound.WindDelta = 0;\n\t      while (E.Next.OutIdx != ClipperLib.ClipperBase.Skip)\n\t      {\n\t        E.NextInLML = E.Next;\n\t        if (E.Bot.X != E.Prev.Top.X)\n\t          this.ReverseHorizontal(E);\n\t        E = E.Next;\n\t      }\n\t      this.InsertLocalMinima(locMin);\n\t      this.m_edges.push(edges);\n\t      return true;\n\t    }\n\t    this.m_edges.push(edges);\n\t    var leftBoundIsForward;\n\t    var EMin = null;\n\t\n\t\t\t//workaround to avoid an endless loop in the while loop below when\n\t    //open paths have matching start and end points ...\n\t    if(ClipperLib.IntPoint.op_Equality(E.Prev.Bot, E.Prev.Top))\n\t    \tE = E.Next;\n\t\n\t    for (;;)\n\t    {\n\t      E = this.FindNextLocMin(E);\n\t      if (E == EMin)\n\t        break;\n\t      else if (EMin == null)\n\t        EMin = E;\n\t      //E and E.Prev now share a local minima (left aligned if horizontal).\n\t      //Compare their slopes to find which starts which bound ...\n\t      var locMin = new ClipperLib.LocalMinima();\n\t      locMin.Next = null;\n\t      locMin.Y = E.Bot.Y;\n\t      if (E.Dx < E.Prev.Dx)\n\t      {\n\t        locMin.LeftBound = E.Prev;\n\t        locMin.RightBound = E;\n\t        leftBoundIsForward = false;\n\t        //Q.nextInLML = Q.prev\n\t      }\n\t      else\n\t      {\n\t        locMin.LeftBound = E;\n\t        locMin.RightBound = E.Prev;\n\t        leftBoundIsForward = true;\n\t        //Q.nextInLML = Q.next\n\t      }\n\t      locMin.LeftBound.Side = ClipperLib.EdgeSide.esLeft;\n\t      locMin.RightBound.Side = ClipperLib.EdgeSide.esRight;\n\t      if (!Closed)\n\t        locMin.LeftBound.WindDelta = 0;\n\t      else if (locMin.LeftBound.Next == locMin.RightBound)\n\t        locMin.LeftBound.WindDelta = -1;\n\t      else\n\t        locMin.LeftBound.WindDelta = 1;\n\t      locMin.RightBound.WindDelta = -locMin.LeftBound.WindDelta;\n\t      E = this.ProcessBound(locMin.LeftBound, leftBoundIsForward);\n\t      if (E.OutIdx == ClipperLib.ClipperBase.Skip)\n\t      \tE = this.ProcessBound(E, leftBoundIsForward);\n\t      var E2 = this.ProcessBound(locMin.RightBound, !leftBoundIsForward);\n\t      if (E2.OutIdx == ClipperLib.ClipperBase.Skip) E2 = this.ProcessBound(E2, !leftBoundIsForward);\n\t      if (locMin.LeftBound.OutIdx == ClipperLib.ClipperBase.Skip)\n\t        locMin.LeftBound = null;\n\t      else if (locMin.RightBound.OutIdx == ClipperLib.ClipperBase.Skip)\n\t        locMin.RightBound = null;\n\t      this.InsertLocalMinima(locMin);\n\t      if (!leftBoundIsForward)\n\t        E = E2;\n\t    }\n\t    return true;\n\t  };\n\t  ClipperLib.ClipperBase.prototype.AddPaths = function (ppg, polyType, closed)\n\t  {\n\t    //  console.log(\"-------------------------------------------\");\n\t    //  console.log(JSON.stringify(ppg));\n\t    var result = false;\n\t    for (var i = 0, ilen = ppg.length; i < ilen; ++i)\n\t      if (this.AddPath(ppg[i], polyType, closed))\n\t        result = true;\n\t    return result;\n\t  };\n\t  //------------------------------------------------------------------------------\n\t  ClipperLib.ClipperBase.prototype.Pt2IsBetweenPt1AndPt3 = function (pt1, pt2, pt3)\n\t  {\n\t    if ((ClipperLib.IntPoint.op_Equality(pt1, pt3)) || (ClipperLib.IntPoint.op_Equality(pt1, pt2)) ||       (ClipperLib.IntPoint.op_Equality(pt3, pt2)))\n\t\n\t   //if ((pt1 == pt3) || (pt1 == pt2) || (pt3 == pt2))\n\t   return false;\n\t\n\t    else if (pt1.X != pt3.X)\n\t      return (pt2.X > pt1.X) == (pt2.X < pt3.X);\n\t    else\n\t      return (pt2.Y > pt1.Y) == (pt2.Y < pt3.Y);\n\t  };\n\t  ClipperLib.ClipperBase.prototype.RemoveEdge = function (e)\n\t  {\n\t    //removes e from double_linked_list (but without removing from memory)\n\t    e.Prev.Next = e.Next;\n\t    e.Next.Prev = e.Prev;\n\t    var result = e.Next;\n\t    e.Prev = null; //flag as removed (see ClipperBase.Clear)\n\t    return result;\n\t  };\n\t  ClipperLib.ClipperBase.prototype.SetDx = function (e)\n\t  {\n\t    e.Delta.X = (e.Top.X - e.Bot.X);\n\t    e.Delta.Y = (e.Top.Y - e.Bot.Y);\n\t    if (e.Delta.Y === 0) e.Dx = ClipperLib.ClipperBase.horizontal;\n\t    else e.Dx = (e.Delta.X) / (e.Delta.Y);\n\t  };\n\t  ClipperLib.ClipperBase.prototype.InsertLocalMinima = function (newLm)\n\t  {\n\t    if (this.m_MinimaList === null)\n\t    {\n\t      this.m_MinimaList = newLm;\n\t    }\n\t    else if (newLm.Y >= this.m_MinimaList.Y)\n\t    {\n\t      newLm.Next = this.m_MinimaList;\n\t      this.m_MinimaList = newLm;\n\t    }\n\t    else\n\t    {\n\t      var tmpLm = this.m_MinimaList;\n\t      while (tmpLm.Next !== null && (newLm.Y < tmpLm.Next.Y))\n\t        tmpLm = tmpLm.Next;\n\t      newLm.Next = tmpLm.Next;\n\t      tmpLm.Next = newLm;\n\t    }\n\t  };\n\t  ClipperLib.ClipperBase.prototype.PopLocalMinima = function ()\n\t  {\n\t    if (this.m_CurrentLM === null)\n\t      return;\n\t    this.m_CurrentLM = this.m_CurrentLM.Next;\n\t  };\n\t  ClipperLib.ClipperBase.prototype.ReverseHorizontal = function (e)\n\t  {\n\t    //swap horizontal edges' top and bottom x's so they follow the natural\n\t    //progression of the bounds - ie so their xbots will align with the\n\t    //adjoining lower edge. [Helpful in the ProcessHorizontal() method.]\n\t    var tmp = e.Top.X;\n\t    e.Top.X = e.Bot.X;\n\t    e.Bot.X = tmp;\n\t    if (use_xyz)\n\t    {\n\t      tmp = e.Top.Z;\n\t      e.Top.Z = e.Bot.Z;\n\t      e.Bot.Z = tmp;\n\t    }\n\t  };\n\t  ClipperLib.ClipperBase.prototype.Reset = function ()\n\t  {\n\t    this.m_CurrentLM = this.m_MinimaList;\n\t    if (this.m_CurrentLM == null)\n\t      return;\n\t    //ie nothing to process\n\t    //reset all edges ...\n\t    var lm = this.m_MinimaList;\n\t    while (lm != null)\n\t    {\n\t      var e = lm.LeftBound;\n\t      if (e != null)\n\t      {\n\t        //e.Curr = e.Bot;\n\t        e.Curr.X = e.Bot.X;\n\t        e.Curr.Y = e.Bot.Y;\n\t        e.Side = ClipperLib.EdgeSide.esLeft;\n\t        e.OutIdx = ClipperLib.ClipperBase.Unassigned;\n\t      }\n\t      e = lm.RightBound;\n\t      if (e != null)\n\t      {\n\t        //e.Curr = e.Bot;\n\t        e.Curr.X = e.Bot.X;\n\t        e.Curr.Y = e.Bot.Y;\n\t        e.Side = ClipperLib.EdgeSide.esRight;\n\t        e.OutIdx = ClipperLib.ClipperBase.Unassigned;\n\t      }\n\t      lm = lm.Next;\n\t    }\n\t  };\n\t  ClipperLib.Clipper = function (InitOptions) // public Clipper(int InitOptions = 0)\n\t  {\n\t    if (typeof (InitOptions) == \"undefined\") InitOptions = 0;\n\t    this.m_PolyOuts = null;\n\t    this.m_ClipType = ClipperLib.ClipType.ctIntersection;\n\t    this.m_Scanbeam = null;\n\t    this.m_ActiveEdges = null;\n\t    this.m_SortedEdges = null;\n\t    this.m_IntersectList = null;\n\t    this.m_IntersectNodeComparer = null;\n\t    this.m_ExecuteLocked = false;\n\t    this.m_ClipFillType = ClipperLib.PolyFillType.pftEvenOdd;\n\t    this.m_SubjFillType = ClipperLib.PolyFillType.pftEvenOdd;\n\t    this.m_Joins = null;\n\t    this.m_GhostJoins = null;\n\t    this.m_UsingPolyTree = false;\n\t    this.ReverseSolution = false;\n\t    this.StrictlySimple = false;\n\t    ClipperLib.ClipperBase.call(this);\n\t    this.m_Scanbeam = null;\n\t    this.m_ActiveEdges = null;\n\t    this.m_SortedEdges = null;\n\t    this.m_IntersectList = new Array();\n\t    this.m_IntersectNodeComparer = ClipperLib.MyIntersectNodeSort.Compare;\n\t    this.m_ExecuteLocked = false;\n\t    this.m_UsingPolyTree = false;\n\t    this.m_PolyOuts = new Array();\n\t    this.m_Joins = new Array();\n\t    this.m_GhostJoins = new Array();\n\t    this.ReverseSolution = (1 & InitOptions) !== 0;\n\t    this.StrictlySimple = (2 & InitOptions) !== 0;\n\t    this.PreserveCollinear = (4 & InitOptions) !== 0;\n\t    if (use_xyz)\n\t    {\n\t      this.ZFillFunction = null; // function (IntPoint vert1, IntPoint vert2, ref IntPoint intersectPt);\n\t    }\n\t  };\n\t  ClipperLib.Clipper.ioReverseSolution = 1;\n\t  ClipperLib.Clipper.ioStrictlySimple = 2;\n\t  ClipperLib.Clipper.ioPreserveCollinear = 4;\n\t\n\t  ClipperLib.Clipper.prototype.Clear = function ()\n\t  {\n\t    if (this.m_edges.length === 0)\n\t      return;\n\t    //avoids problems with ClipperBase destructor\n\t    this.DisposeAllPolyPts();\n\t    ClipperLib.ClipperBase.prototype.Clear.call(this);\n\t  };\n\t\n\t  ClipperLib.Clipper.prototype.DisposeScanbeamList = function ()\n\t  {\n\t    while (this.m_Scanbeam !== null)\n\t    {\n\t      var sb2 = this.m_Scanbeam.Next;\n\t      this.m_Scanbeam = null;\n\t      this.m_Scanbeam = sb2;\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.Reset = function ()\n\t  {\n\t    ClipperLib.ClipperBase.prototype.Reset.call(this);\n\t    this.m_Scanbeam = null;\n\t    this.m_ActiveEdges = null;\n\t    this.m_SortedEdges = null;\n\t\n\t    var lm = this.m_MinimaList;\n\t    while (lm !== null)\n\t    {\n\t      this.InsertScanbeam(lm.Y);\n\t      lm = lm.Next;\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.InsertScanbeam = function (Y)\n\t  {\n\t    if (this.m_Scanbeam === null)\n\t    {\n\t      this.m_Scanbeam = new ClipperLib.Scanbeam();\n\t      this.m_Scanbeam.Next = null;\n\t      this.m_Scanbeam.Y = Y;\n\t    }\n\t    else if (Y > this.m_Scanbeam.Y)\n\t    {\n\t      var newSb = new ClipperLib.Scanbeam();\n\t      newSb.Y = Y;\n\t      newSb.Next = this.m_Scanbeam;\n\t      this.m_Scanbeam = newSb;\n\t    }\n\t    else\n\t    {\n\t      var sb2 = this.m_Scanbeam;\n\t      while (sb2.Next !== null && (Y <= sb2.Next.Y))\n\t        sb2 = sb2.Next;\n\t      if (Y == sb2.Y)\n\t        return;\n\t      //ie ignores duplicates\n\t      var newSb = new ClipperLib.Scanbeam();\n\t      newSb.Y = Y;\n\t      newSb.Next = sb2.Next;\n\t      sb2.Next = newSb;\n\t    }\n\t  };\n\t  // ************************************\n\t  ClipperLib.Clipper.prototype.Execute = function ()\n\t  {\n\t    var a = arguments,\n\t      alen = a.length,\n\t      ispolytree = a[1] instanceof ClipperLib.PolyTree;\n\t    if (alen == 4 && !ispolytree) // function (clipType, solution, subjFillType, clipFillType)\n\t    {\n\t      var clipType = a[0],\n\t        solution = a[1],\n\t        subjFillType = a[2],\n\t        clipFillType = a[3];\n\t      if (this.m_ExecuteLocked)\n\t        return false;\n\t      if (this.m_HasOpenPaths)\n\t        ClipperLib.Error(\"Error: PolyTree struct is need for open path clipping.\");\n\t      this.m_ExecuteLocked = true;\n\t      ClipperLib.Clear(solution);\n\t      this.m_SubjFillType = subjFillType;\n\t      this.m_ClipFillType = clipFillType;\n\t      this.m_ClipType = clipType;\n\t      this.m_UsingPolyTree = false;\n\t      try\n\t      {\n\t        var succeeded = this.ExecuteInternal();\n\t        //build the return polygons ...\n\t        if (succeeded) this.BuildResult(solution);\n\t      }\n\t      finally\n\t      {\n\t        this.DisposeAllPolyPts();\n\t        this.m_ExecuteLocked = false;\n\t      }\n\t      return succeeded;\n\t    }\n\t    else if (alen == 4 && ispolytree) // function (clipType, polytree, subjFillType, clipFillType)\n\t    {\n\t      var clipType = a[0],\n\t        polytree = a[1],\n\t        subjFillType = a[2],\n\t        clipFillType = a[3];\n\t      if (this.m_ExecuteLocked)\n\t        return false;\n\t      this.m_ExecuteLocked = true;\n\t      this.m_SubjFillType = subjFillType;\n\t      this.m_ClipFillType = clipFillType;\n\t      this.m_ClipType = clipType;\n\t      this.m_UsingPolyTree = true;\n\t      try\n\t      {\n\t        var succeeded = this.ExecuteInternal();\n\t        //build the return polygons ...\n\t        if (succeeded) this.BuildResult2(polytree);\n\t      }\n\t      finally\n\t      {\n\t        this.DisposeAllPolyPts();\n\t        this.m_ExecuteLocked = false;\n\t      }\n\t      return succeeded;\n\t    }\n\t    else if (alen == 2 && !ispolytree) // function (clipType, solution)\n\t    {\n\t      var clipType = a[0],\n\t        solution = a[1];\n\t      return this.Execute(clipType, solution, ClipperLib.PolyFillType.pftEvenOdd, ClipperLib.PolyFillType.pftEvenOdd);\n\t    }\n\t    else if (alen == 2 && ispolytree) // function (clipType, polytree)\n\t    {\n\t      var clipType = a[0],\n\t        polytree = a[1];\n\t      return this.Execute(clipType, polytree, ClipperLib.PolyFillType.pftEvenOdd, ClipperLib.PolyFillType.pftEvenOdd);\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.FixHoleLinkage = function (outRec)\n\t  {\n\t    //skip if an outermost polygon or\n\t    //already already points to the correct FirstLeft ...\n\t    if (outRec.FirstLeft === null || (outRec.IsHole != outRec.FirstLeft.IsHole && outRec.FirstLeft.Pts !== null))\n\t      return;\n\t    var orfl = outRec.FirstLeft;\n\t    while (orfl !== null && ((orfl.IsHole == outRec.IsHole) || orfl.Pts === null))\n\t      orfl = orfl.FirstLeft;\n\t    outRec.FirstLeft = orfl;\n\t  };\n\t  ClipperLib.Clipper.prototype.ExecuteInternal = function ()\n\t  {\n\t    try\n\t    {\n\t      this.Reset();\n\t      if (this.m_CurrentLM === null)\n\t        return false;\n\t      var botY = this.PopScanbeam();\n\t      do {\n\t        this.InsertLocalMinimaIntoAEL(botY);\n\t        ClipperLib.Clear(this.m_GhostJoins);\n\t        this.ProcessHorizontals(false);\n\t        if (this.m_Scanbeam === null)\n\t          break;\n\t        var topY = this.PopScanbeam();\n\t        if (!this.ProcessIntersections(topY)) return false;\n\t\n\t        this.ProcessEdgesAtTopOfScanbeam(topY);\n\t        botY = topY;\n\t      }\n\t      while (this.m_Scanbeam !== null || this.m_CurrentLM !== null)\n\t      //fix orientations ...\n\t      for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n\t      {\n\t        var outRec = this.m_PolyOuts[i];\n\t        if (outRec.Pts === null || outRec.IsOpen)\n\t          continue;\n\t        if ((outRec.IsHole ^ this.ReverseSolution) == (this.Area(outRec) > 0))\n\t          this.ReversePolyPtLinks(outRec.Pts);\n\t      }\n\t      this.JoinCommonEdges();\n\t      for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n\t      {\n\t        var outRec = this.m_PolyOuts[i];\n\t        if (outRec.Pts !== null && !outRec.IsOpen)\n\t          this.FixupOutPolygon(outRec);\n\t      }\n\t      if (this.StrictlySimple)\n\t        this.DoSimplePolygons();\n\t      return true;\n\t    }\n\t    finally\n\t    {\n\t      ClipperLib.Clear(this.m_Joins);\n\t      ClipperLib.Clear(this.m_GhostJoins);\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.PopScanbeam = function ()\n\t  {\n\t    var Y = this.m_Scanbeam.Y;\n\t    this.m_Scanbeam = this.m_Scanbeam.Next;\n\t    return Y;\n\t  };\n\t\n\t  ClipperLib.Clipper.prototype.DisposeAllPolyPts = function ()\n\t  {\n\t    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; ++i)\n\t      this.DisposeOutRec(i);\n\t    ClipperLib.Clear(this.m_PolyOuts);\n\t  };\n\t  ClipperLib.Clipper.prototype.DisposeOutRec = function (index)\n\t  {\n\t    var outRec = this.m_PolyOuts[index];\n\t    outRec.Pts = null;\n\t    outRec = null;\n\t    this.m_PolyOuts[index] = null;\n\t  };\n\t\n\t  ClipperLib.Clipper.prototype.AddJoin = function (Op1, Op2, OffPt)\n\t  {\n\t    var j = new ClipperLib.Join();\n\t    j.OutPt1 = Op1;\n\t    j.OutPt2 = Op2;\n\t    //j.OffPt = OffPt;\n\t    j.OffPt.X = OffPt.X;\n\t    j.OffPt.Y = OffPt.Y;\n\t    this.m_Joins.push(j);\n\t  };\n\t  ClipperLib.Clipper.prototype.AddGhostJoin = function (Op, OffPt)\n\t  {\n\t    var j = new ClipperLib.Join();\n\t    j.OutPt1 = Op;\n\t    //j.OffPt = OffPt;\n\t    j.OffPt.X = OffPt.X;\n\t    j.OffPt.Y = OffPt.Y;\n\t    this.m_GhostJoins.push(j);\n\t  };\n\t  if (use_xyz)\n\t  {\n\t    ClipperLib.Clipper.prototype.SetZ = function (pt, e1, e2)\n\t    {\n\t      if (this.ZFillFunction !== null)\n\t      {\n\t        if (pt.Z != 0 || this.ZFillFunction === null) return;\n\t        else if (ClipperLib.IntPoint.op_Equality(pt, e1.Bot)) pt.Z = e1.Bot.Z;\n\t        else if (ClipperLib.IntPoint.op_Equality(pt, e1.Top)) pt.Z = e1.Top.Z;\n\t        else if (ClipperLib.IntPoint.op_Equality(pt, e2.Bot)) pt.Z = e2.Bot.Z;\n\t        else if (ClipperLib.IntPoint.op_Equality(pt, e2.Top)) pt.Z = e2.Top.Z;\n\t        else ZFillFunction(e1.Bot, e1.Top, e2.Bot, e2.Top, pt);\n\t      }\n\t    };\n\t\n\t    //------------------------------------------------------------------------------\n\t  }\n\t\n\t  ClipperLib.Clipper.prototype.InsertLocalMinimaIntoAEL = function (botY)\n\t  {\n\t    while (this.m_CurrentLM !== null && (this.m_CurrentLM.Y == botY))\n\t    {\n\t      var lb = this.m_CurrentLM.LeftBound;\n\t      var rb = this.m_CurrentLM.RightBound;\n\t      this.PopLocalMinima();\n\t      var Op1 = null;\n\t      if (lb === null)\n\t      {\n\t        this.InsertEdgeIntoAEL(rb, null);\n\t        this.SetWindingCount(rb);\n\t        if (this.IsContributing(rb))\n\t          Op1 = this.AddOutPt(rb, rb.Bot);\n\t      }\n\t      else if (rb == null)\n\t      {\n\t        this.InsertEdgeIntoAEL(lb, null);\n\t        this.SetWindingCount(lb);\n\t        if (this.IsContributing(lb))\n\t          Op1 = this.AddOutPt(lb, lb.Bot);\n\t        this.InsertScanbeam(lb.Top.Y);\n\t      }\n\t      else\n\t      {\n\t        this.InsertEdgeIntoAEL(lb, null);\n\t        this.InsertEdgeIntoAEL(rb, lb);\n\t        this.SetWindingCount(lb);\n\t        rb.WindCnt = lb.WindCnt;\n\t        rb.WindCnt2 = lb.WindCnt2;\n\t        if (this.IsContributing(lb))\n\t          Op1 = this.AddLocalMinPoly(lb, rb, lb.Bot);\n\t        this.InsertScanbeam(lb.Top.Y);\n\t      }\n\t      if (rb != null)\n\t      {\n\t        if (ClipperLib.ClipperBase.IsHorizontal(rb))\n\t          this.AddEdgeToSEL(rb);\n\t        else\n\t          this.InsertScanbeam(rb.Top.Y);\n\t      }\n\t      if (lb == null || rb == null) continue;\n\t      //if output polygons share an Edge with a horizontal rb, they'll need joining later ...\n\t      if (Op1 !== null && ClipperLib.ClipperBase.IsHorizontal(rb) && this.m_GhostJoins.length > 0 && rb.WindDelta !== 0)\n\t      {\n\t        for (var i = 0, ilen = this.m_GhostJoins.length; i < ilen; i++)\n\t        {\n\t          //if the horizontal Rb and a 'ghost' horizontal overlap, then convert\n\t          //the 'ghost' join to a real join ready for later ...\n\t          var j = this.m_GhostJoins[i];\n\t\n\t\t\t\t\t\tif (this.HorzSegmentsOverlap(j.OutPt1.Pt.X, j.OffPt.X, rb.Bot.X, rb.Top.X))\n\t            this.AddJoin(j.OutPt1, Op1, j.OffPt);\n\t        }\n\t      }\n\t      if (lb.OutIdx >= 0 && lb.PrevInAEL !== null &&\n\t        lb.PrevInAEL.Curr.X == lb.Bot.X &&\n\t        lb.PrevInAEL.OutIdx >= 0 &&\n\t        ClipperLib.ClipperBase.SlopesEqual(lb.PrevInAEL, lb, this.m_UseFullRange) &&\n\t        lb.WindDelta !== 0 && lb.PrevInAEL.WindDelta !== 0)\n\t      {\n\t        var Op2 = this.AddOutPt(lb.PrevInAEL, lb.Bot);\n\t        this.AddJoin(Op1, Op2, lb.Top);\n\t      }\n\t      if (lb.NextInAEL != rb)\n\t      {\n\t        if (rb.OutIdx >= 0 && rb.PrevInAEL.OutIdx >= 0 &&\n\t          ClipperLib.ClipperBase.SlopesEqual(rb.PrevInAEL, rb, this.m_UseFullRange) &&\n\t          rb.WindDelta !== 0 && rb.PrevInAEL.WindDelta !== 0)\n\t        {\n\t          var Op2 = this.AddOutPt(rb.PrevInAEL, rb.Bot);\n\t          this.AddJoin(Op1, Op2, rb.Top);\n\t        }\n\t        var e = lb.NextInAEL;\n\t        if (e !== null)\n\t          while (e != rb)\n\t          {\n\t            //nb: For calculating winding counts etc, IntersectEdges() assumes\n\t            //that param1 will be to the right of param2 ABOVE the intersection ...\n\t            this.IntersectEdges(rb, e, lb.Curr, false);\n\t            //order important here\n\t            e = e.NextInAEL;\n\t          }\n\t      }\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.InsertEdgeIntoAEL = function (edge, startEdge)\n\t  {\n\t    if (this.m_ActiveEdges === null)\n\t    {\n\t      edge.PrevInAEL = null;\n\t      edge.NextInAEL = null;\n\t      this.m_ActiveEdges = edge;\n\t    }\n\t    else if (startEdge === null && this.E2InsertsBeforeE1(this.m_ActiveEdges, edge))\n\t    {\n\t      edge.PrevInAEL = null;\n\t      edge.NextInAEL = this.m_ActiveEdges;\n\t      this.m_ActiveEdges.PrevInAEL = edge;\n\t      this.m_ActiveEdges = edge;\n\t    }\n\t    else\n\t    {\n\t      if (startEdge === null)\n\t        startEdge = this.m_ActiveEdges;\n\t      while (startEdge.NextInAEL !== null && !this.E2InsertsBeforeE1(startEdge.NextInAEL, edge))\n\t        startEdge = startEdge.NextInAEL;\n\t      edge.NextInAEL = startEdge.NextInAEL;\n\t      if (startEdge.NextInAEL !== null)\n\t        startEdge.NextInAEL.PrevInAEL = edge;\n\t      edge.PrevInAEL = startEdge;\n\t      startEdge.NextInAEL = edge;\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.E2InsertsBeforeE1 = function (e1, e2)\n\t  {\n\t    if (e2.Curr.X == e1.Curr.X)\n\t    {\n\t      if (e2.Top.Y > e1.Top.Y)\n\t        return e2.Top.X < ClipperLib.Clipper.TopX(e1, e2.Top.Y);\n\t      else\n\t        return e1.Top.X > ClipperLib.Clipper.TopX(e2, e1.Top.Y);\n\t    }\n\t    else\n\t      return e2.Curr.X < e1.Curr.X;\n\t  };\n\t  ClipperLib.Clipper.prototype.IsEvenOddFillType = function (edge)\n\t  {\n\t    if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)\n\t      return this.m_SubjFillType == ClipperLib.PolyFillType.pftEvenOdd;\n\t    else\n\t      return this.m_ClipFillType == ClipperLib.PolyFillType.pftEvenOdd;\n\t  };\n\t  ClipperLib.Clipper.prototype.IsEvenOddAltFillType = function (edge)\n\t  {\n\t    if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)\n\t      return this.m_ClipFillType == ClipperLib.PolyFillType.pftEvenOdd;\n\t    else\n\t      return this.m_SubjFillType == ClipperLib.PolyFillType.pftEvenOdd;\n\t  };\n\t  ClipperLib.Clipper.prototype.IsContributing = function (edge)\n\t  {\n\t    var pft, pft2;\n\t    if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)\n\t    {\n\t      pft = this.m_SubjFillType;\n\t      pft2 = this.m_ClipFillType;\n\t    }\n\t    else\n\t    {\n\t      pft = this.m_ClipFillType;\n\t      pft2 = this.m_SubjFillType;\n\t    }\n\t    switch (pft)\n\t    {\n\t    case ClipperLib.PolyFillType.pftEvenOdd:\n\t      if (edge.WindDelta === 0 && edge.WindCnt != 1)\n\t        return false;\n\t      break;\n\t    case ClipperLib.PolyFillType.pftNonZero:\n\t      if (Math.abs(edge.WindCnt) != 1)\n\t        return false;\n\t      break;\n\t    case ClipperLib.PolyFillType.pftPositive:\n\t      if (edge.WindCnt != 1)\n\t        return false;\n\t      break;\n\t    default:\n\t      if (edge.WindCnt != -1)\n\t        return false;\n\t      break;\n\t    }\n\t    switch (this.m_ClipType)\n\t    {\n\t    case ClipperLib.ClipType.ctIntersection:\n\t      switch (pft2)\n\t      {\n\t      case ClipperLib.PolyFillType.pftEvenOdd:\n\t      case ClipperLib.PolyFillType.pftNonZero:\n\t        return (edge.WindCnt2 !== 0);\n\t      case ClipperLib.PolyFillType.pftPositive:\n\t        return (edge.WindCnt2 > 0);\n\t      default:\n\t        return (edge.WindCnt2 < 0);\n\t      }\n\t    case ClipperLib.ClipType.ctUnion:\n\t      switch (pft2)\n\t      {\n\t      case ClipperLib.PolyFillType.pftEvenOdd:\n\t      case ClipperLib.PolyFillType.pftNonZero:\n\t        return (edge.WindCnt2 === 0);\n\t      case ClipperLib.PolyFillType.pftPositive:\n\t        return (edge.WindCnt2 <= 0);\n\t      default:\n\t        return (edge.WindCnt2 >= 0);\n\t      }\n\t    case ClipperLib.ClipType.ctDifference:\n\t      if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)\n\t        switch (pft2)\n\t        {\n\t        case ClipperLib.PolyFillType.pftEvenOdd:\n\t        case ClipperLib.PolyFillType.pftNonZero:\n\t          return (edge.WindCnt2 === 0);\n\t        case ClipperLib.PolyFillType.pftPositive:\n\t          return (edge.WindCnt2 <= 0);\n\t        default:\n\t          return (edge.WindCnt2 >= 0);\n\t        }\n\t      else\n\t        switch (pft2)\n\t        {\n\t        case ClipperLib.PolyFillType.pftEvenOdd:\n\t        case ClipperLib.PolyFillType.pftNonZero:\n\t          return (edge.WindCnt2 !== 0);\n\t        case ClipperLib.PolyFillType.pftPositive:\n\t          return (edge.WindCnt2 > 0);\n\t        default:\n\t          return (edge.WindCnt2 < 0);\n\t        }\n\t    case ClipperLib.ClipType.ctXor:\n\t      if (edge.WindDelta === 0)\n\t        switch (pft2)\n\t        {\n\t        case ClipperLib.PolyFillType.pftEvenOdd:\n\t        case ClipperLib.PolyFillType.pftNonZero:\n\t          return (edge.WindCnt2 === 0);\n\t        case ClipperLib.PolyFillType.pftPositive:\n\t          return (edge.WindCnt2 <= 0);\n\t        default:\n\t          return (edge.WindCnt2 >= 0);\n\t        }\n\t      else\n\t        return true;\n\t    }\n\t    return true;\n\t  };\n\t  ClipperLib.Clipper.prototype.SetWindingCount = function (edge)\n\t  {\n\t    var e = edge.PrevInAEL;\n\t    //find the edge of the same polytype that immediately preceeds 'edge' in AEL\n\t    while (e !== null && ((e.PolyTyp != edge.PolyTyp) || (e.WindDelta === 0)))\n\t      e = e.PrevInAEL;\n\t    if (e === null)\n\t    {\n\t      edge.WindCnt = (edge.WindDelta === 0 ? 1 : edge.WindDelta);\n\t      edge.WindCnt2 = 0;\n\t      e = this.m_ActiveEdges;\n\t      //ie get ready to calc WindCnt2\n\t    }\n\t    else if (edge.WindDelta === 0 && this.m_ClipType != ClipperLib.ClipType.ctUnion)\n\t    {\n\t      edge.WindCnt = 1;\n\t      edge.WindCnt2 = e.WindCnt2;\n\t      e = e.NextInAEL;\n\t      //ie get ready to calc WindCnt2\n\t    }\n\t    else if (this.IsEvenOddFillType(edge))\n\t    {\n\t      //EvenOdd filling ...\n\t      if (edge.WindDelta === 0)\n\t      {\n\t        //are we inside a subj polygon ...\n\t        var Inside = true;\n\t        var e2 = e.PrevInAEL;\n\t        while (e2 !== null)\n\t        {\n\t          if (e2.PolyTyp == e.PolyTyp && e2.WindDelta !== 0)\n\t            Inside = !Inside;\n\t          e2 = e2.PrevInAEL;\n\t        }\n\t        edge.WindCnt = (Inside ? 0 : 1);\n\t      }\n\t      else\n\t      {\n\t        edge.WindCnt = edge.WindDelta;\n\t      }\n\t      edge.WindCnt2 = e.WindCnt2;\n\t      e = e.NextInAEL;\n\t      //ie get ready to calc WindCnt2\n\t    }\n\t    else\n\t    {\n\t      //nonZero, Positive or Negative filling ...\n\t      if (e.WindCnt * e.WindDelta < 0)\n\t      {\n\t        //prev edge is 'decreasing' WindCount (WC) toward zero\n\t        //so we're outside the previous polygon ...\n\t        if (Math.abs(e.WindCnt) > 1)\n\t        {\n\t          //outside prev poly but still inside another.\n\t          //when reversing direction of prev poly use the same WC\n\t          if (e.WindDelta * edge.WindDelta < 0)\n\t            edge.WindCnt = e.WindCnt;\n\t          else\n\t            edge.WindCnt = e.WindCnt + edge.WindDelta;\n\t        }\n\t        else\n\t          edge.WindCnt = (edge.WindDelta === 0 ? 1 : edge.WindDelta);\n\t      }\n\t      else\n\t      {\n\t        //prev edge is 'increasing' WindCount (WC) away from zero\n\t        //so we're inside the previous polygon ...\n\t        if (edge.WindDelta === 0)\n\t          edge.WindCnt = (e.WindCnt < 0 ? e.WindCnt - 1 : e.WindCnt + 1);\n\t        else if (e.WindDelta * edge.WindDelta < 0)\n\t          edge.WindCnt = e.WindCnt;\n\t        else\n\t          edge.WindCnt = e.WindCnt + edge.WindDelta;\n\t      }\n\t      edge.WindCnt2 = e.WindCnt2;\n\t      e = e.NextInAEL;\n\t      //ie get ready to calc WindCnt2\n\t    }\n\t    //update WindCnt2 ...\n\t    if (this.IsEvenOddAltFillType(edge))\n\t    {\n\t      //EvenOdd filling ...\n\t      while (e != edge)\n\t      {\n\t        if (e.WindDelta !== 0)\n\t          edge.WindCnt2 = (edge.WindCnt2 === 0 ? 1 : 0);\n\t        e = e.NextInAEL;\n\t      }\n\t    }\n\t    else\n\t    {\n\t      //nonZero, Positive or Negative filling ...\n\t      while (e != edge)\n\t      {\n\t        edge.WindCnt2 += e.WindDelta;\n\t        e = e.NextInAEL;\n\t      }\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.AddEdgeToSEL = function (edge)\n\t  {\n\t    //SEL pointers in PEdge are reused to build a list of horizontal edges.\n\t    //However, we don't need to worry about order with horizontal edge processing.\n\t    if (this.m_SortedEdges === null)\n\t    {\n\t      this.m_SortedEdges = edge;\n\t      edge.PrevInSEL = null;\n\t      edge.NextInSEL = null;\n\t    }\n\t    else\n\t    {\n\t      edge.NextInSEL = this.m_SortedEdges;\n\t      edge.PrevInSEL = null;\n\t      this.m_SortedEdges.PrevInSEL = edge;\n\t      this.m_SortedEdges = edge;\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.CopyAELToSEL = function ()\n\t  {\n\t    var e = this.m_ActiveEdges;\n\t    this.m_SortedEdges = e;\n\t    while (e !== null)\n\t    {\n\t      e.PrevInSEL = e.PrevInAEL;\n\t      e.NextInSEL = e.NextInAEL;\n\t      e = e.NextInAEL;\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.SwapPositionsInAEL = function (edge1, edge2)\n\t  {\n\t    //check that one or other edge hasn't already been removed from AEL ...\n\t    if (edge1.NextInAEL == edge1.PrevInAEL || edge2.NextInAEL == edge2.PrevInAEL)\n\t      return;\n\t    if (edge1.NextInAEL == edge2)\n\t    {\n\t      var next = edge2.NextInAEL;\n\t      if (next !== null)\n\t        next.PrevInAEL = edge1;\n\t      var prev = edge1.PrevInAEL;\n\t      if (prev !== null)\n\t        prev.NextInAEL = edge2;\n\t      edge2.PrevInAEL = prev;\n\t      edge2.NextInAEL = edge1;\n\t      edge1.PrevInAEL = edge2;\n\t      edge1.NextInAEL = next;\n\t    }\n\t    else if (edge2.NextInAEL == edge1)\n\t    {\n\t      var next = edge1.NextInAEL;\n\t      if (next !== null)\n\t        next.PrevInAEL = edge2;\n\t      var prev = edge2.PrevInAEL;\n\t      if (prev !== null)\n\t        prev.NextInAEL = edge1;\n\t      edge1.PrevInAEL = prev;\n\t      edge1.NextInAEL = edge2;\n\t      edge2.PrevInAEL = edge1;\n\t      edge2.NextInAEL = next;\n\t    }\n\t    else\n\t    {\n\t      var next = edge1.NextInAEL;\n\t      var prev = edge1.PrevInAEL;\n\t      edge1.NextInAEL = edge2.NextInAEL;\n\t      if (edge1.NextInAEL !== null)\n\t        edge1.NextInAEL.PrevInAEL = edge1;\n\t      edge1.PrevInAEL = edge2.PrevInAEL;\n\t      if (edge1.PrevInAEL !== null)\n\t        edge1.PrevInAEL.NextInAEL = edge1;\n\t      edge2.NextInAEL = next;\n\t      if (edge2.NextInAEL !== null)\n\t        edge2.NextInAEL.PrevInAEL = edge2;\n\t      edge2.PrevInAEL = prev;\n\t      if (edge2.PrevInAEL !== null)\n\t        edge2.PrevInAEL.NextInAEL = edge2;\n\t    }\n\t    if (edge1.PrevInAEL === null)\n\t      this.m_ActiveEdges = edge1;\n\t    else if (edge2.PrevInAEL === null)\n\t      this.m_ActiveEdges = edge2;\n\t  };\n\t  ClipperLib.Clipper.prototype.SwapPositionsInSEL = function (edge1, edge2)\n\t  {\n\t    if (edge1.NextInSEL === null && edge1.PrevInSEL === null)\n\t      return;\n\t    if (edge2.NextInSEL === null && edge2.PrevInSEL === null)\n\t      return;\n\t    if (edge1.NextInSEL == edge2)\n\t    {\n\t      var next = edge2.NextInSEL;\n\t      if (next !== null)\n\t        next.PrevInSEL = edge1;\n\t      var prev = edge1.PrevInSEL;\n\t      if (prev !== null)\n\t        prev.NextInSEL = edge2;\n\t      edge2.PrevInSEL = prev;\n\t      edge2.NextInSEL = edge1;\n\t      edge1.PrevInSEL = edge2;\n\t      edge1.NextInSEL = next;\n\t    }\n\t    else if (edge2.NextInSEL == edge1)\n\t    {\n\t      var next = edge1.NextInSEL;\n\t      if (next !== null)\n\t        next.PrevInSEL = edge2;\n\t      var prev = edge2.PrevInSEL;\n\t      if (prev !== null)\n\t        prev.NextInSEL = edge1;\n\t      edge1.PrevInSEL = prev;\n\t      edge1.NextInSEL = edge2;\n\t      edge2.PrevInSEL = edge1;\n\t      edge2.NextInSEL = next;\n\t    }\n\t    else\n\t    {\n\t      var next = edge1.NextInSEL;\n\t      var prev = edge1.PrevInSEL;\n\t      edge1.NextInSEL = edge2.NextInSEL;\n\t      if (edge1.NextInSEL !== null)\n\t        edge1.NextInSEL.PrevInSEL = edge1;\n\t      edge1.PrevInSEL = edge2.PrevInSEL;\n\t      if (edge1.PrevInSEL !== null)\n\t        edge1.PrevInSEL.NextInSEL = edge1;\n\t      edge2.NextInSEL = next;\n\t      if (edge2.NextInSEL !== null)\n\t        edge2.NextInSEL.PrevInSEL = edge2;\n\t      edge2.PrevInSEL = prev;\n\t      if (edge2.PrevInSEL !== null)\n\t        edge2.PrevInSEL.NextInSEL = edge2;\n\t    }\n\t    if (edge1.PrevInSEL === null)\n\t      this.m_SortedEdges = edge1;\n\t    else if (edge2.PrevInSEL === null)\n\t      this.m_SortedEdges = edge2;\n\t  };\n\t  ClipperLib.Clipper.prototype.AddLocalMaxPoly = function (e1, e2, pt)\n\t  {\n\t    this.AddOutPt(e1, pt);\n\t    if (e2.WindDelta == 0) this.AddOutPt(e2, pt);\n\t    if (e1.OutIdx == e2.OutIdx)\n\t    {\n\t      e1.OutIdx = -1;\n\t      e2.OutIdx = -1;\n\t    }\n\t    else if (e1.OutIdx < e2.OutIdx)\n\t      this.AppendPolygon(e1, e2);\n\t    else\n\t      this.AppendPolygon(e2, e1);\n\t  };\n\t  ClipperLib.Clipper.prototype.AddLocalMinPoly = function (e1, e2, pt)\n\t  {\n\t    var result;\n\t    var e, prevE;\n\t    if (ClipperLib.ClipperBase.IsHorizontal(e2) || (e1.Dx > e2.Dx))\n\t    {\n\t      result = this.AddOutPt(e1, pt);\n\t      e2.OutIdx = e1.OutIdx;\n\t      e1.Side = ClipperLib.EdgeSide.esLeft;\n\t      e2.Side = ClipperLib.EdgeSide.esRight;\n\t      e = e1;\n\t      if (e.PrevInAEL == e2)\n\t        prevE = e2.PrevInAEL;\n\t      else\n\t        prevE = e.PrevInAEL;\n\t    }\n\t    else\n\t    {\n\t      result = this.AddOutPt(e2, pt);\n\t      e1.OutIdx = e2.OutIdx;\n\t      e1.Side = ClipperLib.EdgeSide.esRight;\n\t      e2.Side = ClipperLib.EdgeSide.esLeft;\n\t      e = e2;\n\t      if (e.PrevInAEL == e1)\n\t        prevE = e1.PrevInAEL;\n\t      else\n\t        prevE = e.PrevInAEL;\n\t    }\n\t    if (prevE !== null && prevE.OutIdx >= 0 && (ClipperLib.Clipper.TopX(prevE, pt.Y) == ClipperLib.Clipper.TopX(e, pt.Y)) && ClipperLib.ClipperBase.SlopesEqual(e, prevE, this.m_UseFullRange) && (e.WindDelta !== 0) && (prevE.WindDelta !== 0))\n\t    {\n\t      var outPt = this.AddOutPt(prevE, pt);\n\t      this.AddJoin(result, outPt, e.Top);\n\t    }\n\t    return result;\n\t  };\n\t  ClipperLib.Clipper.prototype.CreateOutRec = function ()\n\t  {\n\t    var result = new ClipperLib.OutRec();\n\t    result.Idx = -1;\n\t    result.IsHole = false;\n\t    result.IsOpen = false;\n\t    result.FirstLeft = null;\n\t    result.Pts = null;\n\t    result.BottomPt = null;\n\t    result.PolyNode = null;\n\t    this.m_PolyOuts.push(result);\n\t    result.Idx = this.m_PolyOuts.length - 1;\n\t    return result;\n\t  };\n\t  ClipperLib.Clipper.prototype.AddOutPt = function (e, pt)\n\t  {\n\t    var ToFront = (e.Side == ClipperLib.EdgeSide.esLeft);\n\t    if (e.OutIdx < 0)\n\t    {\n\t      var outRec = this.CreateOutRec();\n\t      outRec.IsOpen = (e.WindDelta === 0);\n\t      var newOp = new ClipperLib.OutPt();\n\t      outRec.Pts = newOp;\n\t      newOp.Idx = outRec.Idx;\n\t      //newOp.Pt = pt;\n\t      newOp.Pt.X = pt.X;\n\t      newOp.Pt.Y = pt.Y;\n\t      newOp.Next = newOp;\n\t      newOp.Prev = newOp;\n\t      if (!outRec.IsOpen)\n\t        this.SetHoleState(e, outRec);\n\t      e.OutIdx = outRec.Idx;\n\t      //nb: do this after SetZ !\n\t      return newOp;\n\t    }\n\t    else\n\t    {\n\t      var outRec = this.m_PolyOuts[e.OutIdx];\n\t      //OutRec.Pts is the 'Left-most' point & OutRec.Pts.Prev is the 'Right-most'\n\t      var op = outRec.Pts;\n\t      if (ToFront && ClipperLib.IntPoint.op_Equality(pt, op.Pt))\n\t        return op;\n\t      else if (!ToFront && ClipperLib.IntPoint.op_Equality(pt, op.Prev.Pt))\n\t        return op.Prev;\n\t      var newOp = new ClipperLib.OutPt();\n\t      newOp.Idx = outRec.Idx;\n\t      //newOp.Pt = pt;\n\t      newOp.Pt.X = pt.X;\n\t      newOp.Pt.Y = pt.Y;\n\t      newOp.Next = op;\n\t      newOp.Prev = op.Prev;\n\t      newOp.Prev.Next = newOp;\n\t      op.Prev = newOp;\n\t      if (ToFront)\n\t        outRec.Pts = newOp;\n\t      return newOp;\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.SwapPoints = function (pt1, pt2)\n\t  {\n\t    var tmp = new ClipperLib.IntPoint(pt1.Value);\n\t    //pt1.Value = pt2.Value;\n\t    pt1.Value.X = pt2.Value.X;\n\t    pt1.Value.Y = pt2.Value.Y;\n\t    //pt2.Value = tmp;\n\t    pt2.Value.X = tmp.X;\n\t    pt2.Value.Y = tmp.Y;\n\t  };\n\t  ClipperLib.Clipper.prototype.HorzSegmentsOverlap = function (seg1a, seg1b, seg2a, seg2b)\n\t\t{\n\t\t\tvar tmp;\n\t\t\tif (seg1a > seg1b)\n\t\t\t{\n\t\t\t\ttmp = seg1a;\n\t\t\t\tseg1a = seg1b;\n\t\t\t\tseg1b = tmp;\n\t\t\t}\n\t\t\tif (seg2a > seg2b)\n\t\t\t{\n\t\t\t\ttmp = seg2a;\n\t\t\t\tseg2a = seg2b;\n\t\t\t\tseg2b = tmp;\n\t\t\t}\n\t\t\treturn (seg1a < seg2b) && (seg2a < seg1b);\n\t\t}\n\t\n\t  ClipperLib.Clipper.prototype.SetHoleState = function (e, outRec)\n\t  {\n\t    var isHole = false;\n\t    var e2 = e.PrevInAEL;\n\t    while (e2 !== null)\n\t    {\n\t      if (e2.OutIdx >= 0 && e2.WindDelta != 0)\n\t      {\n\t        isHole = !isHole;\n\t        if (outRec.FirstLeft === null)\n\t          outRec.FirstLeft = this.m_PolyOuts[e2.OutIdx];\n\t      }\n\t      e2 = e2.PrevInAEL;\n\t    }\n\t    if (isHole)\n\t      outRec.IsHole = true;\n\t  };\n\t  ClipperLib.Clipper.prototype.GetDx = function (pt1, pt2)\n\t  {\n\t    if (pt1.Y == pt2.Y)\n\t      return ClipperLib.ClipperBase.horizontal;\n\t    else\n\t      return (pt2.X - pt1.X) / (pt2.Y - pt1.Y);\n\t  };\n\t  ClipperLib.Clipper.prototype.FirstIsBottomPt = function (btmPt1, btmPt2)\n\t  {\n\t    var p = btmPt1.Prev;\n\t    while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt1.Pt)) && (p != btmPt1))\n\t      p = p.Prev;\n\t    var dx1p = Math.abs(this.GetDx(btmPt1.Pt, p.Pt));\n\t    p = btmPt1.Next;\n\t    while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt1.Pt)) && (p != btmPt1))\n\t      p = p.Next;\n\t    var dx1n = Math.abs(this.GetDx(btmPt1.Pt, p.Pt));\n\t    p = btmPt2.Prev;\n\t    while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt2.Pt)) && (p != btmPt2))\n\t      p = p.Prev;\n\t    var dx2p = Math.abs(this.GetDx(btmPt2.Pt, p.Pt));\n\t    p = btmPt2.Next;\n\t    while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt2.Pt)) && (p != btmPt2))\n\t      p = p.Next;\n\t    var dx2n = Math.abs(this.GetDx(btmPt2.Pt, p.Pt));\n\t    return (dx1p >= dx2p && dx1p >= dx2n) || (dx1n >= dx2p && dx1n >= dx2n);\n\t  };\n\t  ClipperLib.Clipper.prototype.GetBottomPt = function (pp)\n\t  {\n\t    var dups = null;\n\t    var p = pp.Next;\n\t    while (p != pp)\n\t    {\n\t      if (p.Pt.Y > pp.Pt.Y)\n\t      {\n\t        pp = p;\n\t        dups = null;\n\t      }\n\t      else if (p.Pt.Y == pp.Pt.Y && p.Pt.X <= pp.Pt.X)\n\t      {\n\t        if (p.Pt.X < pp.Pt.X)\n\t        {\n\t          dups = null;\n\t          pp = p;\n\t        }\n\t        else\n\t        {\n\t          if (p.Next != pp && p.Prev != pp)\n\t            dups = p;\n\t        }\n\t      }\n\t      p = p.Next;\n\t    }\n\t    if (dups !== null)\n\t    {\n\t      //there appears to be at least 2 vertices at bottomPt so ...\n\t      while (dups != p)\n\t      {\n\t        if (!this.FirstIsBottomPt(p, dups))\n\t          pp = dups;\n\t        dups = dups.Next;\n\t        while (ClipperLib.IntPoint.op_Inequality(dups.Pt, pp.Pt))\n\t          dups = dups.Next;\n\t      }\n\t    }\n\t    return pp;\n\t  };\n\t  ClipperLib.Clipper.prototype.GetLowermostRec = function (outRec1, outRec2)\n\t  {\n\t    //work out which polygon fragment has the correct hole state ...\n\t    if (outRec1.BottomPt === null)\n\t      outRec1.BottomPt = this.GetBottomPt(outRec1.Pts);\n\t    if (outRec2.BottomPt === null)\n\t      outRec2.BottomPt = this.GetBottomPt(outRec2.Pts);\n\t    var bPt1 = outRec1.BottomPt;\n\t    var bPt2 = outRec2.BottomPt;\n\t    if (bPt1.Pt.Y > bPt2.Pt.Y)\n\t      return outRec1;\n\t    else if (bPt1.Pt.Y < bPt2.Pt.Y)\n\t      return outRec2;\n\t    else if (bPt1.Pt.X < bPt2.Pt.X)\n\t      return outRec1;\n\t    else if (bPt1.Pt.X > bPt2.Pt.X)\n\t      return outRec2;\n\t    else if (bPt1.Next == bPt1)\n\t      return outRec2;\n\t    else if (bPt2.Next == bPt2)\n\t      return outRec1;\n\t    else if (this.FirstIsBottomPt(bPt1, bPt2))\n\t      return outRec1;\n\t    else\n\t      return outRec2;\n\t  };\n\t  ClipperLib.Clipper.prototype.Param1RightOfParam2 = function (outRec1, outRec2)\n\t  {\n\t    do {\n\t      outRec1 = outRec1.FirstLeft;\n\t      if (outRec1 == outRec2)\n\t        return true;\n\t    }\n\t    while (outRec1 !== null)\n\t    return false;\n\t  };\n\t  ClipperLib.Clipper.prototype.GetOutRec = function (idx)\n\t  {\n\t    var outrec = this.m_PolyOuts[idx];\n\t    while (outrec != this.m_PolyOuts[outrec.Idx])\n\t      outrec = this.m_PolyOuts[outrec.Idx];\n\t    return outrec;\n\t  };\n\t  ClipperLib.Clipper.prototype.AppendPolygon = function (e1, e2)\n\t  {\n\t    //get the start and ends of both output polygons ...\n\t    var outRec1 = this.m_PolyOuts[e1.OutIdx];\n\t    var outRec2 = this.m_PolyOuts[e2.OutIdx];\n\t    var holeStateRec;\n\t    if (this.Param1RightOfParam2(outRec1, outRec2))\n\t      holeStateRec = outRec2;\n\t    else if (this.Param1RightOfParam2(outRec2, outRec1))\n\t      holeStateRec = outRec1;\n\t    else\n\t      holeStateRec = this.GetLowermostRec(outRec1, outRec2);\n\t    var p1_lft = outRec1.Pts;\n\t    var p1_rt = p1_lft.Prev;\n\t    var p2_lft = outRec2.Pts;\n\t    var p2_rt = p2_lft.Prev;\n\t    var side;\n\t    //join e2 poly onto e1 poly and delete pointers to e2 ...\n\t    if (e1.Side == ClipperLib.EdgeSide.esLeft)\n\t    {\n\t      if (e2.Side == ClipperLib.EdgeSide.esLeft)\n\t      {\n\t        //z y x a b c\n\t        this.ReversePolyPtLinks(p2_lft);\n\t        p2_lft.Next = p1_lft;\n\t        p1_lft.Prev = p2_lft;\n\t        p1_rt.Next = p2_rt;\n\t        p2_rt.Prev = p1_rt;\n\t        outRec1.Pts = p2_rt;\n\t      }\n\t      else\n\t      {\n\t        //x y z a b c\n\t        p2_rt.Next = p1_lft;\n\t        p1_lft.Prev = p2_rt;\n\t        p2_lft.Prev = p1_rt;\n\t        p1_rt.Next = p2_lft;\n\t        outRec1.Pts = p2_lft;\n\t      }\n\t      side = ClipperLib.EdgeSide.esLeft;\n\t    }\n\t    else\n\t    {\n\t      if (e2.Side == ClipperLib.EdgeSide.esRight)\n\t      {\n\t        //a b c z y x\n\t        this.ReversePolyPtLinks(p2_lft);\n\t        p1_rt.Next = p2_rt;\n\t        p2_rt.Prev = p1_rt;\n\t        p2_lft.Next = p1_lft;\n\t        p1_lft.Prev = p2_lft;\n\t      }\n\t      else\n\t      {\n\t        //a b c x y z\n\t        p1_rt.Next = p2_lft;\n\t        p2_lft.Prev = p1_rt;\n\t        p1_lft.Prev = p2_rt;\n\t        p2_rt.Next = p1_lft;\n\t      }\n\t      side = ClipperLib.EdgeSide.esRight;\n\t    }\n\t    outRec1.BottomPt = null;\n\t    if (holeStateRec == outRec2)\n\t    {\n\t      if (outRec2.FirstLeft != outRec1)\n\t        outRec1.FirstLeft = outRec2.FirstLeft;\n\t      outRec1.IsHole = outRec2.IsHole;\n\t    }\n\t    outRec2.Pts = null;\n\t    outRec2.BottomPt = null;\n\t    outRec2.FirstLeft = outRec1;\n\t    var OKIdx = e1.OutIdx;\n\t    var ObsoleteIdx = e2.OutIdx;\n\t    e1.OutIdx = -1;\n\t    //nb: safe because we only get here via AddLocalMaxPoly\n\t    e2.OutIdx = -1;\n\t    var e = this.m_ActiveEdges;\n\t    while (e !== null)\n\t    {\n\t      if (e.OutIdx == ObsoleteIdx)\n\t      {\n\t        e.OutIdx = OKIdx;\n\t        e.Side = side;\n\t        break;\n\t      }\n\t      e = e.NextInAEL;\n\t    }\n\t    outRec2.Idx = outRec1.Idx;\n\t  };\n\t  ClipperLib.Clipper.prototype.ReversePolyPtLinks = function (pp)\n\t  {\n\t    if (pp === null)\n\t      return;\n\t    var pp1;\n\t    var pp2;\n\t    pp1 = pp;\n\t    do {\n\t      pp2 = pp1.Next;\n\t      pp1.Next = pp1.Prev;\n\t      pp1.Prev = pp2;\n\t      pp1 = pp2;\n\t    }\n\t    while (pp1 != pp)\n\t  };\n\t  ClipperLib.Clipper.SwapSides = function (edge1, edge2)\n\t  {\n\t    var side = edge1.Side;\n\t    edge1.Side = edge2.Side;\n\t    edge2.Side = side;\n\t  };\n\t  ClipperLib.Clipper.SwapPolyIndexes = function (edge1, edge2)\n\t  {\n\t    var outIdx = edge1.OutIdx;\n\t    edge1.OutIdx = edge2.OutIdx;\n\t    edge2.OutIdx = outIdx;\n\t  };\n\t  ClipperLib.Clipper.prototype.IntersectEdges = function (e1, e2, pt)\n\t  {\n\t    //e1 will be to the left of e2 BELOW the intersection. Therefore e1 is before\n\t    //e2 in AEL except when e1 is being inserted at the intersection point ...\n\t    var e1Contributing = (e1.OutIdx >= 0);\n\t    var e2Contributing = (e2.OutIdx >= 0);\n\t\n\t    if (use_xyz)\n\t    \tthis.SetZ(pt, e1, e2);\n\t\n\t    if (use_lines)\n\t    {\n\t      //if either edge is on an OPEN path ...\n\t      if (e1.WindDelta === 0 || e2.WindDelta === 0)\n\t      {\n\t        //ignore subject-subject open path intersections UNLESS they\n\t        //are both open paths, AND they are both 'contributing maximas' ...\n\t\t\t\t\tif (e1.WindDelta == 0 && e2.WindDelta == 0) return;\n\t        //if intersecting a subj line with a subj poly ...\n\t        else if (e1.PolyTyp == e2.PolyTyp &&\n\t          e1.WindDelta != e2.WindDelta && this.m_ClipType == ClipperLib.ClipType.ctUnion)\n\t        {\n\t          if (e1.WindDelta === 0)\n\t          {\n\t            if (e2Contributing)\n\t            {\n\t              this.AddOutPt(e1, pt);\n\t              if (e1Contributing)\n\t                e1.OutIdx = -1;\n\t            }\n\t          }\n\t          else\n\t          {\n\t            if (e1Contributing)\n\t            {\n\t              this.AddOutPt(e2, pt);\n\t              if (e2Contributing)\n\t                e2.OutIdx = -1;\n\t            }\n\t          }\n\t        }\n\t        else if (e1.PolyTyp != e2.PolyTyp)\n\t        {\n\t          if ((e1.WindDelta === 0) && Math.abs(e2.WindCnt) == 1 &&\n\t            (this.m_ClipType != ClipperLib.ClipType.ctUnion || e2.WindCnt2 === 0))\n\t          {\n\t            this.AddOutPt(e1, pt);\n\t            if (e1Contributing)\n\t              e1.OutIdx = -1;\n\t          }\n\t          else if ((e2.WindDelta === 0) && (Math.abs(e1.WindCnt) == 1) &&\n\t            (this.m_ClipType != ClipperLib.ClipType.ctUnion || e1.WindCnt2 === 0))\n\t          {\n\t            this.AddOutPt(e2, pt);\n\t            if (e2Contributing)\n\t              e2.OutIdx = -1;\n\t          }\n\t        }\n\t        return;\n\t      }\n\t    }\n\t    //update winding counts...\n\t    //assumes that e1 will be to the Right of e2 ABOVE the intersection\n\t    if (e1.PolyTyp == e2.PolyTyp)\n\t    {\n\t      if (this.IsEvenOddFillType(e1))\n\t      {\n\t        var oldE1WindCnt = e1.WindCnt;\n\t        e1.WindCnt = e2.WindCnt;\n\t        e2.WindCnt = oldE1WindCnt;\n\t      }\n\t      else\n\t      {\n\t        if (e1.WindCnt + e2.WindDelta === 0)\n\t          e1.WindCnt = -e1.WindCnt;\n\t        else\n\t          e1.WindCnt += e2.WindDelta;\n\t        if (e2.WindCnt - e1.WindDelta === 0)\n\t          e2.WindCnt = -e2.WindCnt;\n\t        else\n\t          e2.WindCnt -= e1.WindDelta;\n\t      }\n\t    }\n\t    else\n\t    {\n\t      if (!this.IsEvenOddFillType(e2))\n\t        e1.WindCnt2 += e2.WindDelta;\n\t      else\n\t        e1.WindCnt2 = (e1.WindCnt2 === 0) ? 1 : 0;\n\t      if (!this.IsEvenOddFillType(e1))\n\t        e2.WindCnt2 -= e1.WindDelta;\n\t      else\n\t        e2.WindCnt2 = (e2.WindCnt2 === 0) ? 1 : 0;\n\t    }\n\t    var e1FillType, e2FillType, e1FillType2, e2FillType2;\n\t    if (e1.PolyTyp == ClipperLib.PolyType.ptSubject)\n\t    {\n\t      e1FillType = this.m_SubjFillType;\n\t      e1FillType2 = this.m_ClipFillType;\n\t    }\n\t    else\n\t    {\n\t      e1FillType = this.m_ClipFillType;\n\t      e1FillType2 = this.m_SubjFillType;\n\t    }\n\t    if (e2.PolyTyp == ClipperLib.PolyType.ptSubject)\n\t    {\n\t      e2FillType = this.m_SubjFillType;\n\t      e2FillType2 = this.m_ClipFillType;\n\t    }\n\t    else\n\t    {\n\t      e2FillType = this.m_ClipFillType;\n\t      e2FillType2 = this.m_SubjFillType;\n\t    }\n\t    var e1Wc, e2Wc;\n\t    switch (e1FillType)\n\t    {\n\t    case ClipperLib.PolyFillType.pftPositive:\n\t      e1Wc = e1.WindCnt;\n\t      break;\n\t    case ClipperLib.PolyFillType.pftNegative:\n\t      e1Wc = -e1.WindCnt;\n\t      break;\n\t    default:\n\t      e1Wc = Math.abs(e1.WindCnt);\n\t      break;\n\t    }\n\t    switch (e2FillType)\n\t    {\n\t    case ClipperLib.PolyFillType.pftPositive:\n\t      e2Wc = e2.WindCnt;\n\t      break;\n\t    case ClipperLib.PolyFillType.pftNegative:\n\t      e2Wc = -e2.WindCnt;\n\t      break;\n\t    default:\n\t      e2Wc = Math.abs(e2.WindCnt);\n\t      break;\n\t    }\n\t    if (e1Contributing && e2Contributing)\n\t    {\n\t\t\t\tif ((e1Wc != 0 && e1Wc != 1) || (e2Wc != 0 && e2Wc != 1) ||\n\t\t\t\t(e1.PolyTyp != e2.PolyTyp && this.m_ClipType != ClipperLib.ClipType.ctXor))\n\t\t\t\t{\n\t\t\t\t\tthis.AddLocalMaxPoly(e1, e2, pt);\n\t\t\t\t}\n\t      else\n\t      {\n\t        this.AddOutPt(e1, pt);\n\t        this.AddOutPt(e2, pt);\n\t        ClipperLib.Clipper.SwapSides(e1, e2);\n\t        ClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n\t      }\n\t    }\n\t    else if (e1Contributing)\n\t    {\n\t      if (e2Wc === 0 || e2Wc == 1)\n\t      {\n\t        this.AddOutPt(e1, pt);\n\t        ClipperLib.Clipper.SwapSides(e1, e2);\n\t        ClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n\t      }\n\t    }\n\t    else if (e2Contributing)\n\t    {\n\t      if (e1Wc === 0 || e1Wc == 1)\n\t      {\n\t        this.AddOutPt(e2, pt);\n\t        ClipperLib.Clipper.SwapSides(e1, e2);\n\t        ClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n\t      }\n\t    }\n\t\t\telse if ( (e1Wc == 0 || e1Wc == 1) && (e2Wc == 0 || e2Wc == 1))\n\t    {\n\t      //neither edge is currently contributing ...\n\t      var e1Wc2, e2Wc2;\n\t      switch (e1FillType2)\n\t      {\n\t      case ClipperLib.PolyFillType.pftPositive:\n\t        e1Wc2 = e1.WindCnt2;\n\t        break;\n\t      case ClipperLib.PolyFillType.pftNegative:\n\t        e1Wc2 = -e1.WindCnt2;\n\t        break;\n\t      default:\n\t        e1Wc2 = Math.abs(e1.WindCnt2);\n\t        break;\n\t      }\n\t      switch (e2FillType2)\n\t      {\n\t      case ClipperLib.PolyFillType.pftPositive:\n\t        e2Wc2 = e2.WindCnt2;\n\t        break;\n\t      case ClipperLib.PolyFillType.pftNegative:\n\t        e2Wc2 = -e2.WindCnt2;\n\t        break;\n\t      default:\n\t        e2Wc2 = Math.abs(e2.WindCnt2);\n\t        break;\n\t      }\n\t      if (e1.PolyTyp != e2.PolyTyp)\n\t      {\n\t        this.AddLocalMinPoly(e1, e2, pt);\n\t      }\n\t      else if (e1Wc == 1 && e2Wc == 1)\n\t        switch (this.m_ClipType)\n\t        {\n\t        case ClipperLib.ClipType.ctIntersection:\n\t          if (e1Wc2 > 0 && e2Wc2 > 0)\n\t            this.AddLocalMinPoly(e1, e2, pt);\n\t          break;\n\t        case ClipperLib.ClipType.ctUnion:\n\t          if (e1Wc2 <= 0 && e2Wc2 <= 0)\n\t            this.AddLocalMinPoly(e1, e2, pt);\n\t          break;\n\t        case ClipperLib.ClipType.ctDifference:\n\t          if (((e1.PolyTyp == ClipperLib.PolyType.ptClip) && (e1Wc2 > 0) && (e2Wc2 > 0)) ||\n\t            ((e1.PolyTyp == ClipperLib.PolyType.ptSubject) && (e1Wc2 <= 0) && (e2Wc2 <= 0)))\n\t            this.AddLocalMinPoly(e1, e2, pt);\n\t          break;\n\t        case ClipperLib.ClipType.ctXor:\n\t          this.AddLocalMinPoly(e1, e2, pt);\n\t          break;\n\t        }\n\t      else\n\t        ClipperLib.Clipper.SwapSides(e1, e2);\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.DeleteFromAEL = function (e)\n\t  {\n\t    var AelPrev = e.PrevInAEL;\n\t    var AelNext = e.NextInAEL;\n\t    if (AelPrev === null && AelNext === null && (e != this.m_ActiveEdges))\n\t      return;\n\t    //already deleted\n\t    if (AelPrev !== null)\n\t      AelPrev.NextInAEL = AelNext;\n\t    else\n\t      this.m_ActiveEdges = AelNext;\n\t    if (AelNext !== null)\n\t      AelNext.PrevInAEL = AelPrev;\n\t    e.NextInAEL = null;\n\t    e.PrevInAEL = null;\n\t  };\n\t  ClipperLib.Clipper.prototype.DeleteFromSEL = function (e)\n\t  {\n\t    var SelPrev = e.PrevInSEL;\n\t    var SelNext = e.NextInSEL;\n\t    if (SelPrev === null && SelNext === null && (e != this.m_SortedEdges))\n\t      return;\n\t    //already deleted\n\t    if (SelPrev !== null)\n\t      SelPrev.NextInSEL = SelNext;\n\t    else\n\t      this.m_SortedEdges = SelNext;\n\t    if (SelNext !== null)\n\t      SelNext.PrevInSEL = SelPrev;\n\t    e.NextInSEL = null;\n\t    e.PrevInSEL = null;\n\t  };\n\t  ClipperLib.Clipper.prototype.UpdateEdgeIntoAEL = function (e)\n\t  {\n\t    if (e.NextInLML === null)\n\t      ClipperLib.Error(\"UpdateEdgeIntoAEL: invalid call\");\n\t    var AelPrev = e.PrevInAEL;\n\t    var AelNext = e.NextInAEL;\n\t    e.NextInLML.OutIdx = e.OutIdx;\n\t    if (AelPrev !== null)\n\t      AelPrev.NextInAEL = e.NextInLML;\n\t    else\n\t      this.m_ActiveEdges = e.NextInLML;\n\t    if (AelNext !== null)\n\t      AelNext.PrevInAEL = e.NextInLML;\n\t    e.NextInLML.Side = e.Side;\n\t    e.NextInLML.WindDelta = e.WindDelta;\n\t    e.NextInLML.WindCnt = e.WindCnt;\n\t    e.NextInLML.WindCnt2 = e.WindCnt2;\n\t    e = e.NextInLML;\n\t    //    e.Curr = e.Bot;\n\t    e.Curr.X = e.Bot.X;\n\t    e.Curr.Y = e.Bot.Y;\n\t    e.PrevInAEL = AelPrev;\n\t    e.NextInAEL = AelNext;\n\t    if (!ClipperLib.ClipperBase.IsHorizontal(e))\n\t      this.InsertScanbeam(e.Top.Y);\n\t    return e;\n\t  };\n\t  ClipperLib.Clipper.prototype.ProcessHorizontals = function (isTopOfScanbeam)\n\t  {\n\t    var horzEdge = this.m_SortedEdges;\n\t    while (horzEdge !== null)\n\t    {\n\t      this.DeleteFromSEL(horzEdge);\n\t      this.ProcessHorizontal(horzEdge, isTopOfScanbeam);\n\t      horzEdge = this.m_SortedEdges;\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.GetHorzDirection = function (HorzEdge, $var)\n\t  {\n\t    if (HorzEdge.Bot.X < HorzEdge.Top.X)\n\t    {\n\t        $var.Left = HorzEdge.Bot.X;\n\t        $var.Right = HorzEdge.Top.X;\n\t        $var.Dir = ClipperLib.Direction.dLeftToRight;\n\t    }\n\t    else\n\t    {\n\t        $var.Left = HorzEdge.Top.X;\n\t        $var.Right = HorzEdge.Bot.X;\n\t        $var.Dir = ClipperLib.Direction.dRightToLeft;\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.ProcessHorizontal = function (horzEdge, isTopOfScanbeam)\n\t  {\n\t    var $var = {Dir: null, Left: null, Right: null};\n\t    this.GetHorzDirection(horzEdge, $var);\n\t    var dir = $var.Dir;\n\t    var horzLeft = $var.Left;\n\t    var horzRight = $var.Right;\n\t\n\t    var eLastHorz = horzEdge,\n\t      eMaxPair = null;\n\t    while (eLastHorz.NextInLML !== null && ClipperLib.ClipperBase.IsHorizontal(eLastHorz.NextInLML))\n\t      eLastHorz = eLastHorz.NextInLML;\n\t    if (eLastHorz.NextInLML === null)\n\t      eMaxPair = this.GetMaximaPair(eLastHorz);\n\t    for (;;)\n\t    {\n\t      var IsLastHorz = (horzEdge == eLastHorz);\n\t      var e = this.GetNextInAEL(horzEdge, dir);\n\t      while (e !== null)\n\t      {\n\t        //Break if we've got to the end of an intermediate horizontal edge ...\n\t        //nb: Smaller Dx's are to the right of larger Dx's ABOVE the horizontal.\n\t        if (e.Curr.X == horzEdge.Top.X && horzEdge.NextInLML !== null && e.Dx < horzEdge.NextInLML.Dx)\n\t          break;\n\t        var eNext = this.GetNextInAEL(e, dir);\n\t        //saves eNext for later\n\t        if ((dir == ClipperLib.Direction.dLeftToRight && e.Curr.X <= horzRight) || (dir == ClipperLib.Direction.dRightToLeft && e.Curr.X >= horzLeft))\n\t        {\n\t          //so far we're still in range of the horizontal Edge  but make sure\n\t          //we're at the last of consec. horizontals when matching with eMaxPair\n\t          if (e == eMaxPair && IsLastHorz)\n\t          {\n\t\t\t\t\t\t\tif (horzEdge.OutIdx >= 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvar op1 = this.AddOutPt(horzEdge, horzEdge.Top);\n\t\t\t\t\t\t\t\tvar eNextHorz = this.m_SortedEdges;\n\t\t\t\t\t\t\t\twhile (eNextHorz !== null)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif (eNextHorz.OutIdx >= 0 &&\n\t\t\t\t\t\t\t\t\t\tthis.HorzSegmentsOverlap(horzEdge.Bot.X,\n\t\t\t\t\t\t\t\t\t\thorzEdge.Top.X, eNextHorz.Bot.X, eNextHorz.Top.X))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tvar op2 = this.AddOutPt(eNextHorz, eNextHorz.Bot);\n\t\t\t\t\t\t\t\t\t\tthis.AddJoin(op2, op1, eNextHorz.Top);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\teNextHorz = eNextHorz.NextInSEL;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tthis.AddGhostJoin(op1, horzEdge.Bot);\n\t\t\t\t\t\t\t\tthis.AddLocalMaxPoly(horzEdge, eMaxPair, horzEdge.Top);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis.DeleteFromAEL(horzEdge);\n\t\t\t\t\t\t\tthis.DeleteFromAEL(eMaxPair);\n\t            return;\n\t          }\n\t          else if (dir == ClipperLib.Direction.dLeftToRight)\n\t          {\n\t            var Pt = new ClipperLib.IntPoint(e.Curr.X, horzEdge.Curr.Y);\n\t            this.IntersectEdges(horzEdge, e, Pt);\n\t          }\n\t          else\n\t          {\n\t            var Pt = new ClipperLib.IntPoint(e.Curr.X, horzEdge.Curr.Y);\n\t            this.IntersectEdges(e, horzEdge, Pt);\n\t          }\n\t          this.SwapPositionsInAEL(horzEdge, e);\n\t        }\n\t        else if ((dir == ClipperLib.Direction.dLeftToRight && e.Curr.X >= horzRight) || (dir == ClipperLib.Direction.dRightToLeft && e.Curr.X <= horzLeft))\n\t          break;\n\t        e = eNext;\n\t      }\n\t      //end while\n\t      if (horzEdge.NextInLML !== null && ClipperLib.ClipperBase.IsHorizontal(horzEdge.NextInLML))\n\t      {\n\t        horzEdge = this.UpdateEdgeIntoAEL(horzEdge);\n\t        if (horzEdge.OutIdx >= 0)\n\t          this.AddOutPt(horzEdge, horzEdge.Bot);\n\t\n\t          var $var = {Dir: dir, Left: horzLeft, Right: horzRight};\n\t          this.GetHorzDirection(horzEdge, $var);\n\t          dir = $var.Dir;\n\t          horzLeft = $var.Left;\n\t          horzRight = $var.Right;\n\t      }\n\t      else\n\t        break;\n\t    }\n\t    //end for (;;)\n\t    if (horzEdge.NextInLML !== null)\n\t    {\n\t      if (horzEdge.OutIdx >= 0)\n\t      {\n\t        var op1 = this.AddOutPt(horzEdge, horzEdge.Top);\n\t\t\t\t\tif (isTopOfScanbeam) this.AddGhostJoin(op1, horzEdge.Bot);\n\t        horzEdge = this.UpdateEdgeIntoAEL(horzEdge);\n\t        if (horzEdge.WindDelta === 0)\n\t          return;\n\t        //nb: HorzEdge is no longer horizontal here\n\t        var ePrev = horzEdge.PrevInAEL;\n\t        var eNext = horzEdge.NextInAEL;\n\t        if (ePrev !== null && ePrev.Curr.X == horzEdge.Bot.X &&\n\t          ePrev.Curr.Y == horzEdge.Bot.Y && ePrev.WindDelta !== 0 &&\n\t          (ePrev.OutIdx >= 0 && ePrev.Curr.Y > ePrev.Top.Y &&\n\t            ClipperLib.ClipperBase.SlopesEqual(horzEdge, ePrev, this.m_UseFullRange)))\n\t        {\n\t          var op2 = this.AddOutPt(ePrev, horzEdge.Bot);\n\t          this.AddJoin(op1, op2, horzEdge.Top);\n\t        }\n\t        else if (eNext !== null && eNext.Curr.X == horzEdge.Bot.X &&\n\t          eNext.Curr.Y == horzEdge.Bot.Y && eNext.WindDelta !== 0 &&\n\t          eNext.OutIdx >= 0 && eNext.Curr.Y > eNext.Top.Y &&\n\t          ClipperLib.ClipperBase.SlopesEqual(horzEdge, eNext, this.m_UseFullRange))\n\t        {\n\t          var op2 = this.AddOutPt(eNext, horzEdge.Bot);\n\t          this.AddJoin(op1, op2, horzEdge.Top);\n\t        }\n\t      }\n\t      else horzEdge = this.UpdateEdgeIntoAEL(horzEdge);\n\t    }\n\t  \telse\n\t    {\n\t      if (horzEdge.OutIdx >= 0)\n\t        this.AddOutPt(horzEdge, horzEdge.Top);\n\t      this.DeleteFromAEL(horzEdge);\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.GetNextInAEL = function (e, Direction)\n\t  {\n\t    return Direction == ClipperLib.Direction.dLeftToRight ? e.NextInAEL : e.PrevInAEL;\n\t  };\n\t  ClipperLib.Clipper.prototype.IsMinima = function (e)\n\t  {\n\t    return e !== null && (e.Prev.NextInLML != e) && (e.Next.NextInLML != e);\n\t  };\n\t  ClipperLib.Clipper.prototype.IsMaxima = function (e, Y)\n\t  {\n\t    return (e !== null && e.Top.Y == Y && e.NextInLML === null);\n\t  };\n\t  ClipperLib.Clipper.prototype.IsIntermediate = function (e, Y)\n\t  {\n\t    return (e.Top.Y == Y && e.NextInLML !== null);\n\t  };\n\t  ClipperLib.Clipper.prototype.GetMaximaPair = function (e)\n\t  {\n\t    var result = null;\n\t    if ((ClipperLib.IntPoint.op_Equality(e.Next.Top, e.Top)) && e.Next.NextInLML === null)\n\t      result = e.Next;\n\t    else if ((ClipperLib.IntPoint.op_Equality(e.Prev.Top, e.Top)) && e.Prev.NextInLML === null)\n\t      result = e.Prev;\n\t    if (result !== null && (result.OutIdx == -2 || (result.NextInAEL == result.PrevInAEL && !ClipperLib.ClipperBase.IsHorizontal(result))))\n\t      return null;\n\t    return result;\n\t  };\n\t\n\t  ClipperLib.Clipper.prototype.ProcessIntersections = function (topY)\n\t  {\n\t    if (this.m_ActiveEdges == null)\n\t      return true;\n\t    try\n\t    {\n\t      this.BuildIntersectList(topY);\n\t      if (this.m_IntersectList.length == 0)\n\t        return true;\n\t      if (this.m_IntersectList.length == 1 || this.FixupIntersectionOrder())\n\t        this.ProcessIntersectList();\n\t      else\n\t        return false;\n\t    }\n\t    catch ($$e2)\n\t    {\n\t      this.m_SortedEdges = null;\n\t      this.m_IntersectList.length = 0;\n\t      ClipperLib.Error(\"ProcessIntersections error\");\n\t    }\n\t    this.m_SortedEdges = null;\n\t    return true;\n\t  };\n\t  ClipperLib.Clipper.prototype.BuildIntersectList = function (topY)\n\t  {\n\t    if (this.m_ActiveEdges === null)\n\t      return;\n\t    //prepare for sorting ...\n\t    var e = this.m_ActiveEdges;\n\t    //console.log(JSON.stringify(JSON.decycle( e )));\n\t    this.m_SortedEdges = e;\n\t    while (e !== null)\n\t    {\n\t      e.PrevInSEL = e.PrevInAEL;\n\t      e.NextInSEL = e.NextInAEL;\n\t      e.Curr.X = ClipperLib.Clipper.TopX(e, topY);\n\t      e = e.NextInAEL;\n\t    }\n\t    //bubblesort ...\n\t    var isModified = true;\n\t    while (isModified && this.m_SortedEdges !== null)\n\t    {\n\t      isModified = false;\n\t      e = this.m_SortedEdges;\n\t      while (e.NextInSEL !== null)\n\t      {\n\t        var eNext = e.NextInSEL;\n\t        var pt = new ClipperLib.IntPoint();\n\t        //console.log(\"e.Curr.X: \" + e.Curr.X + \" eNext.Curr.X\" + eNext.Curr.X);\n\t        if (e.Curr.X > eNext.Curr.X)\n\t        {\n\t\t\t\t\t\tthis.IntersectPoint(e, eNext, pt);\n\t          var newNode = new ClipperLib.IntersectNode();\n\t          newNode.Edge1 = e;\n\t          newNode.Edge2 = eNext;\n\t          //newNode.Pt = pt;\n\t          newNode.Pt.X = pt.X;\n\t          newNode.Pt.Y = pt.Y;\n\t          this.m_IntersectList.push(newNode);\n\t          this.SwapPositionsInSEL(e, eNext);\n\t          isModified = true;\n\t        }\n\t        else\n\t          e = eNext;\n\t      }\n\t      if (e.PrevInSEL !== null)\n\t        e.PrevInSEL.NextInSEL = null;\n\t      else\n\t        break;\n\t    }\n\t    this.m_SortedEdges = null;\n\t  };\n\t  ClipperLib.Clipper.prototype.EdgesAdjacent = function (inode)\n\t  {\n\t    return (inode.Edge1.NextInSEL == inode.Edge2) || (inode.Edge1.PrevInSEL == inode.Edge2);\n\t  };\n\t  ClipperLib.Clipper.IntersectNodeSort = function (node1, node2)\n\t  {\n\t    //the following typecast is safe because the differences in Pt.Y will\n\t    //be limited to the height of the scanbeam.\n\t    return (node2.Pt.Y - node1.Pt.Y);\n\t  };\n\t  ClipperLib.Clipper.prototype.FixupIntersectionOrder = function ()\n\t  {\n\t    //pre-condition: intersections are sorted bottom-most first.\n\t    //Now it's crucial that intersections are made only between adjacent edges,\n\t    //so to ensure this the order of intersections may need adjusting ...\n\t    this.m_IntersectList.sort(this.m_IntersectNodeComparer);\n\t    this.CopyAELToSEL();\n\t    var cnt = this.m_IntersectList.length;\n\t    for (var i = 0; i < cnt; i++)\n\t    {\n\t      if (!this.EdgesAdjacent(this.m_IntersectList[i]))\n\t      {\n\t        var j = i + 1;\n\t        while (j < cnt && !this.EdgesAdjacent(this.m_IntersectList[j]))\n\t          j++;\n\t        if (j == cnt)\n\t          return false;\n\t        var tmp = this.m_IntersectList[i];\n\t        this.m_IntersectList[i] = this.m_IntersectList[j];\n\t        this.m_IntersectList[j] = tmp;\n\t      }\n\t      this.SwapPositionsInSEL(this.m_IntersectList[i].Edge1, this.m_IntersectList[i].Edge2);\n\t    }\n\t    return true;\n\t  };\n\t  ClipperLib.Clipper.prototype.ProcessIntersectList = function ()\n\t  {\n\t    for (var i = 0, ilen = this.m_IntersectList.length; i < ilen; i++)\n\t    {\n\t      var iNode = this.m_IntersectList[i];\n\t      this.IntersectEdges(iNode.Edge1, iNode.Edge2, iNode.Pt);\n\t      this.SwapPositionsInAEL(iNode.Edge1, iNode.Edge2);\n\t    }\n\t    this.m_IntersectList.length = 0;\n\t  };\n\t  /*\n\t  --------------------------------\n\t  Round speedtest: http://jsperf.com/fastest-round\n\t  --------------------------------\n\t  */\n\t  var R1 = function (a)\n\t  {\n\t    return a < 0 ? Math.ceil(a - 0.5) : Math.round(a)\n\t  };\n\t  var R2 = function (a)\n\t  {\n\t    return a < 0 ? Math.ceil(a - 0.5) : Math.floor(a + 0.5)\n\t  };\n\t  var R3 = function (a)\n\t  {\n\t    return a < 0 ? -Math.round(Math.abs(a)) : Math.round(a)\n\t  };\n\t  var R4 = function (a)\n\t  {\n\t    if (a < 0)\n\t    {\n\t      a -= 0.5;\n\t      return a < -2147483648 ? Math.ceil(a) : a | 0;\n\t    }\n\t    else\n\t    {\n\t      a += 0.5;\n\t      return a > 2147483647 ? Math.floor(a) : a | 0;\n\t    }\n\t  };\n\t  if (browser.msie) ClipperLib.Clipper.Round = R1;\n\t  else if (browser.chromium) ClipperLib.Clipper.Round = R3;\n\t  else if (browser.safari) ClipperLib.Clipper.Round = R4;\n\t  else ClipperLib.Clipper.Round = R2; // eg. browser.chrome || browser.firefox || browser.opera\n\t  ClipperLib.Clipper.TopX = function (edge, currentY)\n\t  {\n\t    //if (edge.Bot == edge.Curr) alert (\"edge.Bot = edge.Curr\");\n\t    //if (edge.Bot == edge.Top) alert (\"edge.Bot = edge.Top\");\n\t    if (currentY == edge.Top.Y)\n\t      return edge.Top.X;\n\t    return edge.Bot.X + ClipperLib.Clipper.Round(edge.Dx * (currentY - edge.Bot.Y));\n\t  };\n\t  ClipperLib.Clipper.prototype.IntersectPoint = function (edge1, edge2, ip)\n\t  {\n\t    ip.X = 0;\n\t    ip.Y = 0;\n\t    var b1, b2;\n\t    //nb: with very large coordinate values, it's possible for SlopesEqual() to\n\t    //return false but for the edge.Dx value be equal due to double precision rounding.\n\t    if (edge1.Dx == edge2.Dx)\n\t\t\t{\n\t\t\t\tip.Y = edge1.Curr.Y;\n\t\t\t\tip.X = ClipperLib.Clipper.TopX(edge1, ip.Y);\n\t\t\t\treturn;\n\t    }\n\t    if (edge1.Delta.X === 0)\n\t    {\n\t      ip.X = edge1.Bot.X;\n\t      if (ClipperLib.ClipperBase.IsHorizontal(edge2))\n\t      {\n\t        ip.Y = edge2.Bot.Y;\n\t      }\n\t      else\n\t      {\n\t        b2 = edge2.Bot.Y - (edge2.Bot.X / edge2.Dx);\n\t        ip.Y = ClipperLib.Clipper.Round(ip.X / edge2.Dx + b2);\n\t      }\n\t    }\n\t    else if (edge2.Delta.X === 0)\n\t    {\n\t      ip.X = edge2.Bot.X;\n\t      if (ClipperLib.ClipperBase.IsHorizontal(edge1))\n\t      {\n\t        ip.Y = edge1.Bot.Y;\n\t      }\n\t      else\n\t      {\n\t        b1 = edge1.Bot.Y - (edge1.Bot.X / edge1.Dx);\n\t        ip.Y = ClipperLib.Clipper.Round(ip.X / edge1.Dx + b1);\n\t      }\n\t    }\n\t    else\n\t    {\n\t      b1 = edge1.Bot.X - edge1.Bot.Y * edge1.Dx;\n\t      b2 = edge2.Bot.X - edge2.Bot.Y * edge2.Dx;\n\t      var q = (b2 - b1) / (edge1.Dx - edge2.Dx);\n\t      ip.Y = ClipperLib.Clipper.Round(q);\n\t      if (Math.abs(edge1.Dx) < Math.abs(edge2.Dx))\n\t        ip.X = ClipperLib.Clipper.Round(edge1.Dx * q + b1);\n\t      else\n\t        ip.X = ClipperLib.Clipper.Round(edge2.Dx * q + b2);\n\t    }\n\t    if (ip.Y < edge1.Top.Y || ip.Y < edge2.Top.Y)\n\t    {\n\t      if (edge1.Top.Y > edge2.Top.Y)\n\t      {\n\t        ip.Y = edge1.Top.Y;\n\t        ip.X = ClipperLib.Clipper.TopX(edge2, edge1.Top.Y);\n\t        return ip.X < edge1.Top.X;\n\t      }\n\t      else\n\t        ip.Y = edge2.Top.Y;\n\t      if (Math.abs(edge1.Dx) < Math.abs(edge2.Dx))\n\t        ip.X = ClipperLib.Clipper.TopX(edge1, ip.Y);\n\t      else\n\t        ip.X = ClipperLib.Clipper.TopX(edge2, ip.Y);\n\t    }\n\t\t\t//finally, don't allow 'ip' to be BELOW curr.Y (ie bottom of scanbeam) ...\n\t\t\tif (ip.Y > edge1.Curr.Y)\n\t\t\t{\n\t\t\t\tip.Y = edge1.Curr.Y;\n\t\t\t\t//better to use the more vertical edge to derive X ...\n\t\t\t\tif (Math.abs(edge1.Dx) > Math.abs(edge2.Dx))\n\t\t\t\t\tip.X = ClipperLib.Clipper.TopX(edge2, ip.Y);\n\t\t\t\telse\n\t\t\t\t\tip.X = ClipperLib.Clipper.TopX(edge1, ip.Y);\n\t\t\t}\n\t  };\n\t\n\t  ClipperLib.Clipper.prototype.ProcessEdgesAtTopOfScanbeam = function (topY)\n\t  {\n\t    var e = this.m_ActiveEdges;\n\t    while (e !== null)\n\t    {\n\t      //1. process maxima, treating them as if they're 'bent' horizontal edges,\n\t      //   but exclude maxima with horizontal edges. nb: e can't be a horizontal.\n\t      var IsMaximaEdge = this.IsMaxima(e, topY);\n\t      if (IsMaximaEdge)\n\t      {\n\t        var eMaxPair = this.GetMaximaPair(e);\n\t        IsMaximaEdge = (eMaxPair === null || !ClipperLib.ClipperBase.IsHorizontal(eMaxPair));\n\t      }\n\t      if (IsMaximaEdge)\n\t      {\n\t        var ePrev = e.PrevInAEL;\n\t        this.DoMaxima(e);\n\t        if (ePrev === null)\n\t          e = this.m_ActiveEdges;\n\t        else\n\t          e = ePrev.NextInAEL;\n\t      }\n\t      else\n\t      {\n\t        //2. promote horizontal edges, otherwise update Curr.X and Curr.Y ...\n\t        if (this.IsIntermediate(e, topY) && ClipperLib.ClipperBase.IsHorizontal(e.NextInLML))\n\t        {\n\t          e = this.UpdateEdgeIntoAEL(e);\n\t          if (e.OutIdx >= 0)\n\t            this.AddOutPt(e, e.Bot);\n\t          this.AddEdgeToSEL(e);\n\t        }\n\t        else\n\t        {\n\t          e.Curr.X = ClipperLib.Clipper.TopX(e, topY);\n\t          e.Curr.Y = topY;\n\t        }\n\t        if (this.StrictlySimple)\n\t        {\n\t          var ePrev = e.PrevInAEL;\n\t          if ((e.OutIdx >= 0) && (e.WindDelta !== 0) && ePrev !== null &&\n\t            (ePrev.OutIdx >= 0) && (ePrev.Curr.X == e.Curr.X) &&\n\t            (ePrev.WindDelta !== 0))\n\t          {\n\t           \tvar ip = new ClipperLib.IntPoint(e.Curr);\n\t\n\t\t\t\t\t\t\tif(use_xyz)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tthis.SetZ(ip, ePrev, e);\n\t\t\t\t\t\t\t}\n\t\n\t            var op = this.AddOutPt(ePrev, ip);\n\t            var op2 = this.AddOutPt(e, ip);\n\t            this.AddJoin(op, op2, ip);\n\t            //StrictlySimple (type-3) join\n\t          }\n\t        }\n\t        e = e.NextInAEL;\n\t      }\n\t    }\n\t    //3. Process horizontals at the Top of the scanbeam ...\n\t    this.ProcessHorizontals(true);\n\t    //4. Promote intermediate vertices ...\n\t    e = this.m_ActiveEdges;\n\t    while (e !== null)\n\t    {\n\t      if (this.IsIntermediate(e, topY))\n\t      {\n\t        var op = null;\n\t        if (e.OutIdx >= 0)\n\t          op = this.AddOutPt(e, e.Top);\n\t        e = this.UpdateEdgeIntoAEL(e);\n\t        //if output polygons share an edge, they'll need joining later ...\n\t        var ePrev = e.PrevInAEL;\n\t        var eNext = e.NextInAEL;\n\t        if (ePrev !== null && ePrev.Curr.X == e.Bot.X &&\n\t          ePrev.Curr.Y == e.Bot.Y && op !== null &&\n\t          ePrev.OutIdx >= 0 && ePrev.Curr.Y > ePrev.Top.Y &&\n\t          ClipperLib.ClipperBase.SlopesEqual(e, ePrev, this.m_UseFullRange) &&\n\t          (e.WindDelta !== 0) && (ePrev.WindDelta !== 0))\n\t        {\n\t          var op2 = this.AddOutPt(ePrev, e.Bot);\n\t          this.AddJoin(op, op2, e.Top);\n\t        }\n\t        else if (eNext !== null && eNext.Curr.X == e.Bot.X &&\n\t          eNext.Curr.Y == e.Bot.Y && op !== null &&\n\t          eNext.OutIdx >= 0 && eNext.Curr.Y > eNext.Top.Y &&\n\t          ClipperLib.ClipperBase.SlopesEqual(e, eNext, this.m_UseFullRange) &&\n\t          (e.WindDelta !== 0) && (eNext.WindDelta !== 0))\n\t        {\n\t          var op2 = this.AddOutPt(eNext, e.Bot);\n\t          this.AddJoin(op, op2, e.Top);\n\t        }\n\t      }\n\t      e = e.NextInAEL;\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.DoMaxima = function (e)\n\t  {\n\t    var eMaxPair = this.GetMaximaPair(e);\n\t    if (eMaxPair === null)\n\t    {\n\t      if (e.OutIdx >= 0)\n\t        this.AddOutPt(e, e.Top);\n\t      this.DeleteFromAEL(e);\n\t      return;\n\t    }\n\t    var eNext = e.NextInAEL;\n\t    var use_lines = true;\n\t    while (eNext !== null && eNext != eMaxPair)\n\t    {\n\t      this.IntersectEdges(e, eNext, e.Top);\n\t      this.SwapPositionsInAEL(e, eNext);\n\t      eNext = e.NextInAEL;\n\t    }\n\t    if (e.OutIdx == -1 && eMaxPair.OutIdx == -1)\n\t    {\n\t      this.DeleteFromAEL(e);\n\t      this.DeleteFromAEL(eMaxPair);\n\t    }\n\t    else if (e.OutIdx >= 0 && eMaxPair.OutIdx >= 0)\n\t    {\n\t    \tif (e.OutIdx >= 0) this.AddLocalMaxPoly(e, eMaxPair, e.Top);\n\t      this.DeleteFromAEL(e);\n\t      this.DeleteFromAEL(eMaxPair);\n\t    }\n\t    else if (use_lines && e.WindDelta === 0)\n\t    {\n\t      if (e.OutIdx >= 0)\n\t      {\n\t        this.AddOutPt(e, e.Top);\n\t        e.OutIdx = -1;\n\t      }\n\t      this.DeleteFromAEL(e);\n\t      if (eMaxPair.OutIdx >= 0)\n\t      {\n\t        this.AddOutPt(eMaxPair, e.Top);\n\t        eMaxPair.OutIdx = -1;\n\t      }\n\t      this.DeleteFromAEL(eMaxPair);\n\t    }\n\t    else\n\t      ClipperLib.Error(\"DoMaxima error\");\n\t  };\n\t  ClipperLib.Clipper.ReversePaths = function (polys)\n\t  {\n\t    for (var i = 0, len = polys.length; i < len; i++)\n\t      polys[i].reverse();\n\t  };\n\t  ClipperLib.Clipper.Orientation = function (poly)\n\t  {\n\t    return ClipperLib.Clipper.Area(poly) >= 0;\n\t  };\n\t  ClipperLib.Clipper.prototype.PointCount = function (pts)\n\t  {\n\t    if (pts === null)\n\t      return 0;\n\t    var result = 0;\n\t    var p = pts;\n\t    do {\n\t      result++;\n\t      p = p.Next;\n\t    }\n\t    while (p != pts)\n\t    return result;\n\t  };\n\t  ClipperLib.Clipper.prototype.BuildResult = function (polyg)\n\t  {\n\t    ClipperLib.Clear(polyg);\n\t    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n\t    {\n\t      var outRec = this.m_PolyOuts[i];\n\t      if (outRec.Pts === null)\n\t        continue;\n\t      var p = outRec.Pts.Prev;\n\t      var cnt = this.PointCount(p);\n\t      if (cnt < 2)\n\t        continue;\n\t      var pg = new Array(cnt);\n\t      for (var j = 0; j < cnt; j++)\n\t      {\n\t        pg[j] = p.Pt;\n\t        p = p.Prev;\n\t      }\n\t      polyg.push(pg);\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.BuildResult2 = function (polytree)\n\t  {\n\t    polytree.Clear();\n\t    //add each output polygon/contour to polytree ...\n\t    //polytree.m_AllPolys.set_Capacity(this.m_PolyOuts.length);\n\t    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n\t    {\n\t      var outRec = this.m_PolyOuts[i];\n\t      var cnt = this.PointCount(outRec.Pts);\n\t      if ((outRec.IsOpen && cnt < 2) || (!outRec.IsOpen && cnt < 3))\n\t        continue;\n\t      this.FixHoleLinkage(outRec);\n\t      var pn = new ClipperLib.PolyNode();\n\t      polytree.m_AllPolys.push(pn);\n\t      outRec.PolyNode = pn;\n\t      pn.m_polygon.length = cnt;\n\t      var op = outRec.Pts.Prev;\n\t      for (var j = 0; j < cnt; j++)\n\t      {\n\t        pn.m_polygon[j] = op.Pt;\n\t        op = op.Prev;\n\t      }\n\t    }\n\t    //fixup PolyNode links etc ...\n\t    //polytree.m_Childs.set_Capacity(this.m_PolyOuts.length);\n\t    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n\t    {\n\t      var outRec = this.m_PolyOuts[i];\n\t      if (outRec.PolyNode === null)\n\t        continue;\n\t      else if (outRec.IsOpen)\n\t      {\n\t        outRec.PolyNode.IsOpen = true;\n\t        polytree.AddChild(outRec.PolyNode);\n\t      }\n\t      else if (outRec.FirstLeft !== null && outRec.FirstLeft.PolyNode != null)\n\t        outRec.FirstLeft.PolyNode.AddChild(outRec.PolyNode);\n\t      else\n\t        polytree.AddChild(outRec.PolyNode);\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.FixupOutPolygon = function (outRec)\n\t  {\n\t    //FixupOutPolygon() - removes duplicate points and simplifies consecutive\n\t    //parallel edges by removing the middle vertex.\n\t    var lastOK = null;\n\t    outRec.BottomPt = null;\n\t    var pp = outRec.Pts;\n\t    for (;;)\n\t    {\n\t      if (pp.Prev == pp || pp.Prev == pp.Next)\n\t      {\n\t        outRec.Pts = null;\n\t        return;\n\t      }\n\t      //test for duplicate points and collinear edges ...\n\t      if ((ClipperLib.IntPoint.op_Equality(pp.Pt, pp.Next.Pt)) || (ClipperLib.IntPoint.op_Equality(pp.Pt, pp.Prev.Pt)) ||\n\t        (ClipperLib.ClipperBase.SlopesEqual(pp.Prev.Pt, pp.Pt, pp.Next.Pt, this.m_UseFullRange) &&\n\t          (!this.PreserveCollinear || !this.Pt2IsBetweenPt1AndPt3(pp.Prev.Pt, pp.Pt, pp.Next.Pt))))\n\t      {\n\t        lastOK = null;\n\t        pp.Prev.Next = pp.Next;\n\t        pp.Next.Prev = pp.Prev;\n\t        pp = pp.Prev;\n\t      }\n\t      else if (pp == lastOK)\n\t        break;\n\t      else\n\t      {\n\t        if (lastOK === null)\n\t          lastOK = pp;\n\t        pp = pp.Next;\n\t      }\n\t    }\n\t    outRec.Pts = pp;\n\t  };\n\t  ClipperLib.Clipper.prototype.DupOutPt = function (outPt, InsertAfter)\n\t  {\n\t    var result = new ClipperLib.OutPt();\n\t    //result.Pt = outPt.Pt;\n\t    result.Pt.X = outPt.Pt.X;\n\t    result.Pt.Y = outPt.Pt.Y;\n\t    result.Idx = outPt.Idx;\n\t    if (InsertAfter)\n\t    {\n\t      result.Next = outPt.Next;\n\t      result.Prev = outPt;\n\t      outPt.Next.Prev = result;\n\t      outPt.Next = result;\n\t    }\n\t    else\n\t    {\n\t      result.Prev = outPt.Prev;\n\t      result.Next = outPt;\n\t      outPt.Prev.Next = result;\n\t      outPt.Prev = result;\n\t    }\n\t    return result;\n\t  };\n\t  ClipperLib.Clipper.prototype.GetOverlap = function (a1, a2, b1, b2, $val)\n\t  {\n\t    if (a1 < a2)\n\t    {\n\t      if (b1 < b2)\n\t      {\n\t        $val.Left = Math.max(a1, b1);\n\t        $val.Right = Math.min(a2, b2);\n\t      }\n\t      else\n\t      {\n\t        $val.Left = Math.max(a1, b2);\n\t        $val.Right = Math.min(a2, b1);\n\t      }\n\t    }\n\t    else\n\t    {\n\t      if (b1 < b2)\n\t      {\n\t        $val.Left = Math.max(a2, b1);\n\t        $val.Right = Math.min(a1, b2);\n\t      }\n\t      else\n\t      {\n\t        $val.Left = Math.max(a2, b2);\n\t        $val.Right = Math.min(a1, b1);\n\t      }\n\t    }\n\t    return $val.Left < $val.Right;\n\t  };\n\t  ClipperLib.Clipper.prototype.JoinHorz = function (op1, op1b, op2, op2b, Pt, DiscardLeft)\n\t  {\n\t    var Dir1 = (op1.Pt.X > op1b.Pt.X ? ClipperLib.Direction.dRightToLeft : ClipperLib.Direction.dLeftToRight);\n\t    var Dir2 = (op2.Pt.X > op2b.Pt.X ? ClipperLib.Direction.dRightToLeft : ClipperLib.Direction.dLeftToRight);\n\t    if (Dir1 == Dir2)\n\t      return false;\n\t    //When DiscardLeft, we want Op1b to be on the Left of Op1, otherwise we\n\t    //want Op1b to be on the Right. (And likewise with Op2 and Op2b.)\n\t    //So, to facilitate this while inserting Op1b and Op2b ...\n\t    //when DiscardLeft, make sure we're AT or RIGHT of Pt before adding Op1b,\n\t    //otherwise make sure we're AT or LEFT of Pt. (Likewise with Op2b.)\n\t    if (Dir1 == ClipperLib.Direction.dLeftToRight)\n\t    {\n\t      while (op1.Next.Pt.X <= Pt.X &&\n\t        op1.Next.Pt.X >= op1.Pt.X && op1.Next.Pt.Y == Pt.Y)\n\t        op1 = op1.Next;\n\t      if (DiscardLeft && (op1.Pt.X != Pt.X))\n\t        op1 = op1.Next;\n\t      op1b = this.DupOutPt(op1, !DiscardLeft);\n\t      if (ClipperLib.IntPoint.op_Inequality(op1b.Pt, Pt))\n\t      {\n\t        op1 = op1b;\n\t        //op1.Pt = Pt;\n\t        op1.Pt.X = Pt.X;\n\t        op1.Pt.Y = Pt.Y;\n\t        op1b = this.DupOutPt(op1, !DiscardLeft);\n\t      }\n\t    }\n\t    else\n\t    {\n\t      while (op1.Next.Pt.X >= Pt.X &&\n\t        op1.Next.Pt.X <= op1.Pt.X && op1.Next.Pt.Y == Pt.Y)\n\t        op1 = op1.Next;\n\t      if (!DiscardLeft && (op1.Pt.X != Pt.X))\n\t        op1 = op1.Next;\n\t      op1b = this.DupOutPt(op1, DiscardLeft);\n\t      if (ClipperLib.IntPoint.op_Inequality(op1b.Pt, Pt))\n\t      {\n\t        op1 = op1b;\n\t        //op1.Pt = Pt;\n\t        op1.Pt.X = Pt.X;\n\t        op1.Pt.Y = Pt.Y;\n\t        op1b = this.DupOutPt(op1, DiscardLeft);\n\t      }\n\t    }\n\t    if (Dir2 == ClipperLib.Direction.dLeftToRight)\n\t    {\n\t      while (op2.Next.Pt.X <= Pt.X &&\n\t        op2.Next.Pt.X >= op2.Pt.X && op2.Next.Pt.Y == Pt.Y)\n\t        op2 = op2.Next;\n\t      if (DiscardLeft && (op2.Pt.X != Pt.X))\n\t        op2 = op2.Next;\n\t      op2b = this.DupOutPt(op2, !DiscardLeft);\n\t      if (ClipperLib.IntPoint.op_Inequality(op2b.Pt, Pt))\n\t      {\n\t        op2 = op2b;\n\t        //op2.Pt = Pt;\n\t        op2.Pt.X = Pt.X;\n\t        op2.Pt.Y = Pt.Y;\n\t        op2b = this.DupOutPt(op2, !DiscardLeft);\n\t      }\n\t    }\n\t    else\n\t    {\n\t      while (op2.Next.Pt.X >= Pt.X &&\n\t        op2.Next.Pt.X <= op2.Pt.X && op2.Next.Pt.Y == Pt.Y)\n\t        op2 = op2.Next;\n\t      if (!DiscardLeft && (op2.Pt.X != Pt.X))\n\t        op2 = op2.Next;\n\t      op2b = this.DupOutPt(op2, DiscardLeft);\n\t      if (ClipperLib.IntPoint.op_Inequality(op2b.Pt, Pt))\n\t      {\n\t        op2 = op2b;\n\t        //op2.Pt = Pt;\n\t        op2.Pt.X = Pt.X;\n\t        op2.Pt.Y = Pt.Y;\n\t        op2b = this.DupOutPt(op2, DiscardLeft);\n\t      }\n\t    }\n\t    if ((Dir1 == ClipperLib.Direction.dLeftToRight) == DiscardLeft)\n\t    {\n\t      op1.Prev = op2;\n\t      op2.Next = op1;\n\t      op1b.Next = op2b;\n\t      op2b.Prev = op1b;\n\t    }\n\t    else\n\t    {\n\t      op1.Next = op2;\n\t      op2.Prev = op1;\n\t      op1b.Prev = op2b;\n\t      op2b.Next = op1b;\n\t    }\n\t    return true;\n\t  };\n\t  ClipperLib.Clipper.prototype.JoinPoints = function (j, outRec1, outRec2)\n\t  {\n\t    var op1 = j.OutPt1,\n\t      op1b = new ClipperLib.OutPt();\n\t    var op2 = j.OutPt2,\n\t      op2b = new ClipperLib.OutPt();\n\t    //There are 3 kinds of joins for output polygons ...\n\t    //1. Horizontal joins where Join.OutPt1 & Join.OutPt2 are a vertices anywhere\n\t    //along (horizontal) collinear edges (& Join.OffPt is on the same horizontal).\n\t    //2. Non-horizontal joins where Join.OutPt1 & Join.OutPt2 are at the same\n\t    //location at the Bottom of the overlapping segment (& Join.OffPt is above).\n\t    //3. StrictlySimple joins where edges touch but are not collinear and where\n\t    //Join.OutPt1, Join.OutPt2 & Join.OffPt all share the same point.\n\t    var isHorizontal = (j.OutPt1.Pt.Y == j.OffPt.Y);\n\t    if (isHorizontal && (ClipperLib.IntPoint.op_Equality(j.OffPt, j.OutPt1.Pt)) && (ClipperLib.IntPoint.op_Equality(j.OffPt, j.OutPt2.Pt)))\n\t    {\n\t      //Strictly Simple join ...\n\t\t\t\tif (outRec1 != outRec2) return false;\n\t\n\t      op1b = j.OutPt1.Next;\n\t      while (op1b != op1 && (ClipperLib.IntPoint.op_Equality(op1b.Pt, j.OffPt)))\n\t        op1b = op1b.Next;\n\t      var reverse1 = (op1b.Pt.Y > j.OffPt.Y);\n\t      op2b = j.OutPt2.Next;\n\t      while (op2b != op2 && (ClipperLib.IntPoint.op_Equality(op2b.Pt, j.OffPt)))\n\t        op2b = op2b.Next;\n\t      var reverse2 = (op2b.Pt.Y > j.OffPt.Y);\n\t      if (reverse1 == reverse2)\n\t        return false;\n\t      if (reverse1)\n\t      {\n\t        op1b = this.DupOutPt(op1, false);\n\t        op2b = this.DupOutPt(op2, true);\n\t        op1.Prev = op2;\n\t        op2.Next = op1;\n\t        op1b.Next = op2b;\n\t        op2b.Prev = op1b;\n\t        j.OutPt1 = op1;\n\t        j.OutPt2 = op1b;\n\t        return true;\n\t      }\n\t      else\n\t      {\n\t        op1b = this.DupOutPt(op1, true);\n\t        op2b = this.DupOutPt(op2, false);\n\t        op1.Next = op2;\n\t        op2.Prev = op1;\n\t        op1b.Prev = op2b;\n\t        op2b.Next = op1b;\n\t        j.OutPt1 = op1;\n\t        j.OutPt2 = op1b;\n\t        return true;\n\t      }\n\t    }\n\t    else if (isHorizontal)\n\t    {\n\t      //treat horizontal joins differently to non-horizontal joins since with\n\t      //them we're not yet sure where the overlapping is. OutPt1.Pt & OutPt2.Pt\n\t      //may be anywhere along the horizontal edge.\n\t      op1b = op1;\n\t      while (op1.Prev.Pt.Y == op1.Pt.Y && op1.Prev != op1b && op1.Prev != op2)\n\t        op1 = op1.Prev;\n\t      while (op1b.Next.Pt.Y == op1b.Pt.Y && op1b.Next != op1 && op1b.Next != op2)\n\t        op1b = op1b.Next;\n\t      if (op1b.Next == op1 || op1b.Next == op2)\n\t        return false;\n\t      //a flat 'polygon'\n\t      op2b = op2;\n\t      while (op2.Prev.Pt.Y == op2.Pt.Y && op2.Prev != op2b && op2.Prev != op1b)\n\t        op2 = op2.Prev;\n\t      while (op2b.Next.Pt.Y == op2b.Pt.Y && op2b.Next != op2 && op2b.Next != op1)\n\t        op2b = op2b.Next;\n\t      if (op2b.Next == op2 || op2b.Next == op1)\n\t        return false;\n\t      //a flat 'polygon'\n\t      //Op1 -. Op1b & Op2 -. Op2b are the extremites of the horizontal edges\n\t\n\t      var $val = {Left: null, Right: null};\n\t      if (!this.GetOverlap(op1.Pt.X, op1b.Pt.X, op2.Pt.X, op2b.Pt.X, $val))\n\t        return false;\n\t      var Left = $val.Left;\n\t      var Right = $val.Right;\n\t\n\t      //DiscardLeftSide: when overlapping edges are joined, a spike will created\n\t      //which needs to be cleaned up. However, we don't want Op1 or Op2 caught up\n\t      //on the discard Side as either may still be needed for other joins ...\n\t      var Pt = new ClipperLib.IntPoint();\n\t      var DiscardLeftSide;\n\t      if (op1.Pt.X >= Left && op1.Pt.X <= Right)\n\t      {\n\t        //Pt = op1.Pt;\n\t        Pt.X = op1.Pt.X;\n\t        Pt.Y = op1.Pt.Y;\n\t        DiscardLeftSide = (op1.Pt.X > op1b.Pt.X);\n\t      }\n\t      else if (op2.Pt.X >= Left && op2.Pt.X <= Right)\n\t      {\n\t        //Pt = op2.Pt;\n\t        Pt.X = op2.Pt.X;\n\t        Pt.Y = op2.Pt.Y;\n\t        DiscardLeftSide = (op2.Pt.X > op2b.Pt.X);\n\t      }\n\t      else if (op1b.Pt.X >= Left && op1b.Pt.X <= Right)\n\t      {\n\t        //Pt = op1b.Pt;\n\t        Pt.X = op1b.Pt.X;\n\t        Pt.Y = op1b.Pt.Y;\n\t        DiscardLeftSide = op1b.Pt.X > op1.Pt.X;\n\t      }\n\t      else\n\t      {\n\t        //Pt = op2b.Pt;\n\t        Pt.X = op2b.Pt.X;\n\t        Pt.Y = op2b.Pt.Y;\n\t        DiscardLeftSide = (op2b.Pt.X > op2.Pt.X);\n\t      }\n\t      j.OutPt1 = op1;\n\t      j.OutPt2 = op2;\n\t      return this.JoinHorz(op1, op1b, op2, op2b, Pt, DiscardLeftSide);\n\t    }\n\t    else\n\t    {\n\t      //nb: For non-horizontal joins ...\n\t      //    1. Jr.OutPt1.Pt.Y == Jr.OutPt2.Pt.Y\n\t      //    2. Jr.OutPt1.Pt > Jr.OffPt.Y\n\t      //make sure the polygons are correctly oriented ...\n\t      op1b = op1.Next;\n\t      while ((ClipperLib.IntPoint.op_Equality(op1b.Pt, op1.Pt)) && (op1b != op1))\n\t        op1b = op1b.Next;\n\t      var Reverse1 = ((op1b.Pt.Y > op1.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual(op1.Pt, op1b.Pt, j.OffPt, this.m_UseFullRange));\n\t      if (Reverse1)\n\t      {\n\t        op1b = op1.Prev;\n\t        while ((ClipperLib.IntPoint.op_Equality(op1b.Pt, op1.Pt)) && (op1b != op1))\n\t          op1b = op1b.Prev;\n\t        if ((op1b.Pt.Y > op1.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual(op1.Pt, op1b.Pt, j.OffPt, this.m_UseFullRange))\n\t          return false;\n\t      }\n\t      op2b = op2.Next;\n\t      while ((ClipperLib.IntPoint.op_Equality(op2b.Pt, op2.Pt)) && (op2b != op2))\n\t        op2b = op2b.Next;\n\t      var Reverse2 = ((op2b.Pt.Y > op2.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual(op2.Pt, op2b.Pt, j.OffPt, this.m_UseFullRange));\n\t      if (Reverse2)\n\t      {\n\t        op2b = op2.Prev;\n\t        while ((ClipperLib.IntPoint.op_Equality(op2b.Pt, op2.Pt)) && (op2b != op2))\n\t          op2b = op2b.Prev;\n\t        if ((op2b.Pt.Y > op2.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual(op2.Pt, op2b.Pt, j.OffPt, this.m_UseFullRange))\n\t          return false;\n\t      }\n\t      if ((op1b == op1) || (op2b == op2) || (op1b == op2b) ||\n\t        ((outRec1 == outRec2) && (Reverse1 == Reverse2)))\n\t        return false;\n\t      if (Reverse1)\n\t      {\n\t        op1b = this.DupOutPt(op1, false);\n\t        op2b = this.DupOutPt(op2, true);\n\t        op1.Prev = op2;\n\t        op2.Next = op1;\n\t        op1b.Next = op2b;\n\t        op2b.Prev = op1b;\n\t        j.OutPt1 = op1;\n\t        j.OutPt2 = op1b;\n\t        return true;\n\t      }\n\t      else\n\t      {\n\t        op1b = this.DupOutPt(op1, true);\n\t        op2b = this.DupOutPt(op2, false);\n\t        op1.Next = op2;\n\t        op2.Prev = op1;\n\t        op1b.Prev = op2b;\n\t        op2b.Next = op1b;\n\t        j.OutPt1 = op1;\n\t        j.OutPt2 = op1b;\n\t        return true;\n\t      }\n\t    }\n\t  };\n\t  ClipperLib.Clipper.GetBounds = function (paths)\n\t  {\n\t    var i = 0,\n\t      cnt = paths.length;\n\t    while (i < cnt && paths[i].length == 0) i++;\n\t    if (i == cnt) return new ClipperLib.IntRect(0, 0, 0, 0);\n\t    var result = new ClipperLib.IntRect();\n\t    result.left = paths[i][0].X;\n\t    result.right = result.left;\n\t    result.top = paths[i][0].Y;\n\t    result.bottom = result.top;\n\t    for (; i < cnt; i++)\n\t      for (var j = 0, jlen = paths[i].length; j < jlen; j++)\n\t      {\n\t        if (paths[i][j].X < result.left) result.left = paths[i][j].X;\n\t        else if (paths[i][j].X > result.right) result.right = paths[i][j].X;\n\t        if (paths[i][j].Y < result.top) result.top = paths[i][j].Y;\n\t        else if (paths[i][j].Y > result.bottom) result.bottom = paths[i][j].Y;\n\t      }\n\t    return result;\n\t  }\n\t  ClipperLib.Clipper.prototype.GetBounds2 = function (ops)\n\t  {\n\t    var opStart = ops;\n\t    var result = new ClipperLib.IntRect();\n\t    result.left = ops.Pt.X;\n\t    result.right = ops.Pt.X;\n\t    result.top = ops.Pt.Y;\n\t    result.bottom = ops.Pt.Y;\n\t    ops = ops.Next;\n\t    while (ops != opStart)\n\t    {\n\t      if (ops.Pt.X < result.left)\n\t        result.left = ops.Pt.X;\n\t      if (ops.Pt.X > result.right)\n\t        result.right = ops.Pt.X;\n\t      if (ops.Pt.Y < result.top)\n\t        result.top = ops.Pt.Y;\n\t      if (ops.Pt.Y > result.bottom)\n\t        result.bottom = ops.Pt.Y;\n\t      ops = ops.Next;\n\t    }\n\t    return result;\n\t  };\n\t\n\t  ClipperLib.Clipper.PointInPolygon = function (pt, path)\n\t  {\n\t    //returns 0 if false, +1 if true, -1 if pt ON polygon boundary\n\t\t\t//See \"The Point in Polygon Problem for Arbitrary Polygons\" by Hormann & Agathos\n\t    //http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.88.5498&rep=rep1&type=pdf\n\t    var result = 0,\n\t      cnt = path.length;\n\t    if (cnt < 3)\n\t      return 0;\n\t    var ip = path[0];\n\t    for (var i = 1; i <= cnt; ++i)\n\t    {\n\t      var ipNext = (i == cnt ? path[0] : path[i]);\n\t      if (ipNext.Y == pt.Y)\n\t      {\n\t        if ((ipNext.X == pt.X) || (ip.Y == pt.Y && ((ipNext.X > pt.X) == (ip.X < pt.X))))\n\t          return -1;\n\t      }\n\t      if ((ip.Y < pt.Y) != (ipNext.Y < pt.Y))\n\t      {\n\t        if (ip.X >= pt.X)\n\t        {\n\t          if (ipNext.X > pt.X)\n\t            result = 1 - result;\n\t          else\n\t          {\n\t            var d = (ip.X - pt.X) * (ipNext.Y - pt.Y) - (ipNext.X - pt.X) * (ip.Y - pt.Y);\n\t            if (d == 0)\n\t              return -1;\n\t            else if ((d > 0) == (ipNext.Y > ip.Y))\n\t              result = 1 - result;\n\t          }\n\t        }\n\t        else\n\t        {\n\t          if (ipNext.X > pt.X)\n\t          {\n\t            var d = (ip.X - pt.X) * (ipNext.Y - pt.Y) - (ipNext.X - pt.X) * (ip.Y - pt.Y);\n\t            if (d == 0)\n\t              return -1;\n\t            else if ((d > 0) == (ipNext.Y > ip.Y))\n\t              result = 1 - result;\n\t          }\n\t        }\n\t      }\n\t      ip = ipNext;\n\t    }\n\t    return result;\n\t  };\n\t\n\t  ClipperLib.Clipper.prototype.PointInPolygon = function (pt, op)\n\t  {\n\t    //returns 0 if false, +1 if true, -1 if pt ON polygon boundary\n\t\t\t//See \"The Point in Polygon Problem for Arbitrary Polygons\" by Hormann & Agathos\n\t    //http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.88.5498&rep=rep1&type=pdf\n\t    var result = 0;\n\t    var startOp = op;\n\t\t\tvar ptx = pt.X, pty = pt.Y;\n\t    var poly0x = op.Pt.X, poly0y = op.Pt.Y;\n\t    do\n\t    {\n\t\t\t\top = op.Next;\n\t\t\t\tvar poly1x = op.Pt.X, poly1y = op.Pt.Y;\n\t      if (poly1y == pty)\n\t      {\n\t        if ((poly1x == ptx) || (poly0y == pty && ((poly1x > ptx) == (poly0x < ptx))))\n\t          return -1;\n\t      }\n\t      if ((poly0y < pty) != (poly1y < pty))\n\t      {\n\t        if (poly0x >= ptx)\n\t        {\n\t          if (poly1x > ptx)\n\t            result = 1 - result;\n\t          else\n\t          {\n\t            var d = (poly0x - ptx) * (poly1y - pty) - (poly1x - ptx) * (poly0y - pty);\n\t            if (d == 0)\n\t              return -1;\n\t            if ((d > 0) == (poly1y > poly0y))\n\t              result = 1 - result;\n\t          }\n\t        }\n\t        else\n\t        {\n\t          if (poly1x > ptx)\n\t          {\n\t            var d = (poly0x - ptx) * (poly1y - pty) - (poly1x - ptx) * (poly0y - pty);\n\t            if (d == 0)\n\t              return -1;\n\t            if ((d > 0) == (poly1y > poly0y))\n\t              result = 1 - result;\n\t          }\n\t        }\n\t      }\n\t      poly0x = poly1x;\n\t      poly0y = poly1y;\n\t    } while (startOp != op);\n\t\n\t    return result;\n\t  };\n\t\n\t  ClipperLib.Clipper.prototype.Poly2ContainsPoly1 = function (outPt1, outPt2)\n\t  {\n\t    var op = outPt1;\n\t    do\n\t    {\n\t\t\t\t//nb: PointInPolygon returns 0 if false, +1 if true, -1 if pt on polygon\n\t      var res = this.PointInPolygon(op.Pt, outPt2);\n\t      if (res >= 0)\n\t        return res > 0;\n\t      op = op.Next;\n\t    }\n\t    while (op != outPt1)\n\t    return true;\n\t  };\n\t  ClipperLib.Clipper.prototype.FixupFirstLefts1 = function (OldOutRec, NewOutRec)\n\t  {\n\t    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n\t    {\n\t\t\t\tvar outRec = this.m_PolyOuts[i];\n\t\t\t\tif (outRec.Pts == null || outRec.FirstLeft == null)\n\t\t\t\t\tcontinue;\n\t\t\t\tvar firstLeft = this.ParseFirstLeft(outRec.FirstLeft);\n\t\t\t\tif (firstLeft == OldOutRec)\n\t\t\t\t{\n\t        if (this.Poly2ContainsPoly1(outRec.Pts, NewOutRec.Pts))\n\t          outRec.FirstLeft = NewOutRec;\n\t      }\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.FixupFirstLefts2 = function (OldOutRec, NewOutRec)\n\t  {\n\t    for (var $i2 = 0, $t2 = this.m_PolyOuts, $l2 = $t2.length, outRec = $t2[$i2]; $i2 < $l2; $i2++, outRec = $t2[$i2])\n\t      if (outRec.FirstLeft == OldOutRec)\n\t        outRec.FirstLeft = NewOutRec;\n\t  };\n\t  ClipperLib.Clipper.ParseFirstLeft = function (FirstLeft)\n\t  {\n\t    while (FirstLeft != null && FirstLeft.Pts == null)\n\t      FirstLeft = FirstLeft.FirstLeft;\n\t    return FirstLeft;\n\t  };\n\t  ClipperLib.Clipper.prototype.JoinCommonEdges = function ()\n\t  {\n\t    for (var i = 0, ilen = this.m_Joins.length; i < ilen; i++)\n\t    {\n\t      var join = this.m_Joins[i];\n\t      var outRec1 = this.GetOutRec(join.OutPt1.Idx);\n\t      var outRec2 = this.GetOutRec(join.OutPt2.Idx);\n\t      if (outRec1.Pts == null || outRec2.Pts == null)\n\t        continue;\n\t      //get the polygon fragment with the correct hole state (FirstLeft)\n\t      //before calling JoinPoints() ...\n\t      var holeStateRec;\n\t      if (outRec1 == outRec2)\n\t        holeStateRec = outRec1;\n\t      else if (this.Param1RightOfParam2(outRec1, outRec2))\n\t        holeStateRec = outRec2;\n\t      else if (this.Param1RightOfParam2(outRec2, outRec1))\n\t        holeStateRec = outRec1;\n\t      else\n\t        holeStateRec = this.GetLowermostRec(outRec1, outRec2);\n\t\n\t      if (!this.JoinPoints(join, outRec1, outRec2)) continue;\n\t\n\t      if (outRec1 == outRec2)\n\t      {\n\t        //instead of joining two polygons, we've just created a new one by\n\t        //splitting one polygon into two.\n\t        outRec1.Pts = join.OutPt1;\n\t        outRec1.BottomPt = null;\n\t        outRec2 = this.CreateOutRec();\n\t        outRec2.Pts = join.OutPt2;\n\t        //update all OutRec2.Pts Idx's ...\n\t        this.UpdateOutPtIdxs(outRec2);\n\t        //We now need to check every OutRec.FirstLeft pointer. If it points\n\t        //to OutRec1 it may need to point to OutRec2 instead ...\n\t        if (this.m_UsingPolyTree)\n\t          for (var j = 0, jlen = this.m_PolyOuts.length; j < jlen - 1; j++)\n\t          {\n\t            var oRec = this.m_PolyOuts[j];\n\t            if (oRec.Pts == null || ClipperLib.Clipper.ParseFirstLeft(oRec.FirstLeft) != outRec1 || oRec.IsHole == outRec1.IsHole)\n\t              continue;\n\t            if (this.Poly2ContainsPoly1(oRec.Pts, join.OutPt2))\n\t              oRec.FirstLeft = outRec2;\n\t          }\n\t        if (this.Poly2ContainsPoly1(outRec2.Pts, outRec1.Pts))\n\t        {\n\t          //outRec2 is contained by outRec1 ...\n\t          outRec2.IsHole = !outRec1.IsHole;\n\t          outRec2.FirstLeft = outRec1;\n\t          //fixup FirstLeft pointers that may need reassigning to OutRec1\n\t          if (this.m_UsingPolyTree)\n\t            this.FixupFirstLefts2(outRec2, outRec1);\n\t          if ((outRec2.IsHole ^ this.ReverseSolution) == (this.Area(outRec2) > 0))\n\t            this.ReversePolyPtLinks(outRec2.Pts);\n\t        }\n\t        else if (this.Poly2ContainsPoly1(outRec1.Pts, outRec2.Pts))\n\t        {\n\t          //outRec1 is contained by outRec2 ...\n\t          outRec2.IsHole = outRec1.IsHole;\n\t          outRec1.IsHole = !outRec2.IsHole;\n\t          outRec2.FirstLeft = outRec1.FirstLeft;\n\t          outRec1.FirstLeft = outRec2;\n\t          //fixup FirstLeft pointers that may need reassigning to OutRec1\n\t          if (this.m_UsingPolyTree)\n\t            this.FixupFirstLefts2(outRec1, outRec2);\n\t          if ((outRec1.IsHole ^ this.ReverseSolution) == (this.Area(outRec1) > 0))\n\t            this.ReversePolyPtLinks(outRec1.Pts);\n\t        }\n\t        else\n\t        {\n\t          //the 2 polygons are completely separate ...\n\t          outRec2.IsHole = outRec1.IsHole;\n\t          outRec2.FirstLeft = outRec1.FirstLeft;\n\t          //fixup FirstLeft pointers that may need reassigning to OutRec2\n\t          if (this.m_UsingPolyTree)\n\t            this.FixupFirstLefts1(outRec1, outRec2);\n\t        }\n\t      }\n\t      else\n\t      {\n\t        //joined 2 polygons together ...\n\t        outRec2.Pts = null;\n\t        outRec2.BottomPt = null;\n\t        outRec2.Idx = outRec1.Idx;\n\t        outRec1.IsHole = holeStateRec.IsHole;\n\t        if (holeStateRec == outRec2)\n\t          outRec1.FirstLeft = outRec2.FirstLeft;\n\t        outRec2.FirstLeft = outRec1;\n\t        //fixup FirstLeft pointers that may need reassigning to OutRec1\n\t        if (this.m_UsingPolyTree)\n\t          this.FixupFirstLefts2(outRec2, outRec1);\n\t      }\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.UpdateOutPtIdxs = function (outrec)\n\t  {\n\t    var op = outrec.Pts;\n\t    do {\n\t      op.Idx = outrec.Idx;\n\t      op = op.Prev;\n\t    }\n\t    while (op != outrec.Pts)\n\t  };\n\t  ClipperLib.Clipper.prototype.DoSimplePolygons = function ()\n\t  {\n\t    var i = 0;\n\t    while (i < this.m_PolyOuts.length)\n\t    {\n\t      var outrec = this.m_PolyOuts[i++];\n\t      var op = outrec.Pts;\n\t\t\t\tif (op == null || outrec.IsOpen)\n\t\t\t\t\tcontinue;\n\t      do //for each Pt in Polygon until duplicate found do ...\n\t      {\n\t        var op2 = op.Next;\n\t        while (op2 != outrec.Pts)\n\t        {\n\t          if ((ClipperLib.IntPoint.op_Equality(op.Pt, op2.Pt)) && op2.Next != op && op2.Prev != op)\n\t          {\n\t            //split the polygon into two ...\n\t            var op3 = op.Prev;\n\t            var op4 = op2.Prev;\n\t            op.Prev = op4;\n\t            op4.Next = op;\n\t            op2.Prev = op3;\n\t            op3.Next = op2;\n\t            outrec.Pts = op;\n\t            var outrec2 = this.CreateOutRec();\n\t            outrec2.Pts = op2;\n\t            this.UpdateOutPtIdxs(outrec2);\n\t            if (this.Poly2ContainsPoly1(outrec2.Pts, outrec.Pts))\n\t            {\n\t              //OutRec2 is contained by OutRec1 ...\n\t              outrec2.IsHole = !outrec.IsHole;\n\t              outrec2.FirstLeft = outrec;\n\t\t\t\t\t\t\t\tif (this.m_UsingPolyTree) this.FixupFirstLefts2(outrec2, outrec);\n\t\n\t            }\n\t            else if (this.Poly2ContainsPoly1(outrec.Pts, outrec2.Pts))\n\t            {\n\t              //OutRec1 is contained by OutRec2 ...\n\t              outrec2.IsHole = outrec.IsHole;\n\t              outrec.IsHole = !outrec2.IsHole;\n\t              outrec2.FirstLeft = outrec.FirstLeft;\n\t              outrec.FirstLeft = outrec2;\n\t              if (this.m_UsingPolyTree) this.FixupFirstLefts2(outrec, outrec2);\n\t            }\n\t            else\n\t            {\n\t              //the 2 polygons are separate ...\n\t              outrec2.IsHole = outrec.IsHole;\n\t              outrec2.FirstLeft = outrec.FirstLeft;\n\t\t\t\t\t\t\t\tif (this.m_UsingPolyTree) this.FixupFirstLefts1(outrec, outrec2);\n\t            }\n\t            op2 = op;\n\t            //ie get ready for the next iteration\n\t          }\n\t          op2 = op2.Next;\n\t        }\n\t        op = op.Next;\n\t      }\n\t      while (op != outrec.Pts)\n\t    }\n\t  };\n\t  ClipperLib.Clipper.Area = function (poly)\n\t  {\n\t    var cnt = poly.length;\n\t    if (cnt < 3)\n\t      return 0;\n\t    var a = 0;\n\t    for (var i = 0, j = cnt - 1; i < cnt; ++i)\n\t    {\n\t      a += (poly[j].X + poly[i].X) * (poly[j].Y - poly[i].Y);\n\t      j = i;\n\t    }\n\t    return -a * 0.5;\n\t  };\n\t  ClipperLib.Clipper.prototype.Area = function (outRec)\n\t  {\n\t    var op = outRec.Pts;\n\t    if (op == null)\n\t      return 0;\n\t    var a = 0;\n\t    do {\n\t      a = a + (op.Prev.Pt.X + op.Pt.X) * (op.Prev.Pt.Y - op.Pt.Y);\n\t      op = op.Next;\n\t    }\n\t    while (op != outRec.Pts)\n\t    return a * 0.5;\n\t  };\n\t  ClipperLib.Clipper.SimplifyPolygon = function (poly, fillType)\n\t  {\n\t    var result = new Array();\n\t    var c = new ClipperLib.Clipper(0);\n\t    c.StrictlySimple = true;\n\t    c.AddPath(poly, ClipperLib.PolyType.ptSubject, true);\n\t    c.Execute(ClipperLib.ClipType.ctUnion, result, fillType, fillType);\n\t    return result;\n\t  };\n\t  ClipperLib.Clipper.SimplifyPolygons = function (polys, fillType)\n\t  {\n\t    if (typeof (fillType) == \"undefined\") fillType = ClipperLib.PolyFillType.pftEvenOdd;\n\t    var result = new Array();\n\t    var c = new ClipperLib.Clipper(0);\n\t    c.StrictlySimple = true;\n\t    c.AddPaths(polys, ClipperLib.PolyType.ptSubject, true);\n\t    c.Execute(ClipperLib.ClipType.ctUnion, result, fillType, fillType);\n\t    return result;\n\t  };\n\t  ClipperLib.Clipper.DistanceSqrd = function (pt1, pt2)\n\t  {\n\t    var dx = (pt1.X - pt2.X);\n\t    var dy = (pt1.Y - pt2.Y);\n\t    return (dx * dx + dy * dy);\n\t  };\n\t  ClipperLib.Clipper.DistanceFromLineSqrd = function (pt, ln1, ln2)\n\t  {\n\t    //The equation of a line in general form (Ax + By + C = 0)\n\t    //given 2 points (x,y) & (x,y) is ...\n\t    //(y - y)x + (x - x)y + (y - y)x - (x - x)y = 0\n\t    //A = (y - y); B = (x - x); C = (y - y)x - (x - x)y\n\t    //perpendicular distance of point (x,y) = (Ax + By + C)/Sqrt(A + B)\n\t    //see http://en.wikipedia.org/wiki/Perpendicular_distance\n\t    var A = ln1.Y - ln2.Y;\n\t    var B = ln2.X - ln1.X;\n\t    var C = A * ln1.X + B * ln1.Y;\n\t    C = A * pt.X + B * pt.Y - C;\n\t    return (C * C) / (A * A + B * B);\n\t  };\n\t\n\t\tClipperLib.Clipper.SlopesNearCollinear = function(pt1, pt2, pt3, distSqrd)\n\t\t{\n\t\t\t//this function is more accurate when the point that's GEOMETRICALLY\n\t\t\t//between the other 2 points is the one that's tested for distance.\n\t\t\t//nb: with 'spikes', either pt1 or pt3 is geometrically between the other pts\n\t\t\tif (Math.abs(pt1.X - pt2.X) > Math.abs(pt1.Y - pt2.Y))\n\t\t\t{\n\t\t\tif ((pt1.X > pt2.X) == (pt1.X < pt3.X))\n\t\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt1, pt2, pt3) < distSqrd;\n\t\t\telse if ((pt2.X > pt1.X) == (pt2.X < pt3.X))\n\t\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt2, pt1, pt3) < distSqrd;\n\t\t\t\t\telse\n\t\t\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt3, pt1, pt2) < distSqrd;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\tif ((pt1.Y > pt2.Y) == (pt1.Y < pt3.Y))\n\t\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt1, pt2, pt3) < distSqrd;\n\t\t\telse if ((pt2.Y > pt1.Y) == (pt2.Y < pt3.Y))\n\t\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt2, pt1, pt3) < distSqrd;\n\t\t\t\t\telse\n\t\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt3, pt1, pt2) < distSqrd;\n\t\t\t}\n\t\t}\n\t\n\t  ClipperLib.Clipper.PointsAreClose = function (pt1, pt2, distSqrd)\n\t  {\n\t    var dx = pt1.X - pt2.X;\n\t    var dy = pt1.Y - pt2.Y;\n\t    return ((dx * dx) + (dy * dy) <= distSqrd);\n\t  };\n\t  //------------------------------------------------------------------------------\n\t  ClipperLib.Clipper.ExcludeOp = function (op)\n\t  {\n\t    var result = op.Prev;\n\t    result.Next = op.Next;\n\t    op.Next.Prev = result;\n\t    result.Idx = 0;\n\t    return result;\n\t  };\n\t  ClipperLib.Clipper.CleanPolygon = function (path, distance)\n\t  {\n\t    if (typeof (distance) == \"undefined\") distance = 1.415;\n\t    //distance = proximity in units/pixels below which vertices will be stripped.\n\t    //Default ~= sqrt(2) so when adjacent vertices or semi-adjacent vertices have\n\t    //both x & y coords within 1 unit, then the second vertex will be stripped.\n\t    var cnt = path.length;\n\t    if (cnt == 0)\n\t      return new Array();\n\t    var outPts = new Array(cnt);\n\t    for (var i = 0; i < cnt; ++i)\n\t      outPts[i] = new ClipperLib.OutPt();\n\t    for (var i = 0; i < cnt; ++i)\n\t    {\n\t      outPts[i].Pt = path[i];\n\t      outPts[i].Next = outPts[(i + 1) % cnt];\n\t      outPts[i].Next.Prev = outPts[i];\n\t      outPts[i].Idx = 0;\n\t    }\n\t    var distSqrd = distance * distance;\n\t    var op = outPts[0];\n\t    while (op.Idx == 0 && op.Next != op.Prev)\n\t    {\n\t      if (ClipperLib.Clipper.PointsAreClose(op.Pt, op.Prev.Pt, distSqrd))\n\t      {\n\t        op = ClipperLib.Clipper.ExcludeOp(op);\n\t        cnt--;\n\t      }\n\t      else if (ClipperLib.Clipper.PointsAreClose(op.Prev.Pt, op.Next.Pt, distSqrd))\n\t      {\n\t        ClipperLib.Clipper.ExcludeOp(op.Next);\n\t        op = ClipperLib.Clipper.ExcludeOp(op);\n\t        cnt -= 2;\n\t      }\n\t      else if (ClipperLib.Clipper.SlopesNearCollinear(op.Prev.Pt, op.Pt, op.Next.Pt, distSqrd))\n\t      {\n\t        op = ClipperLib.Clipper.ExcludeOp(op);\n\t        cnt--;\n\t      }\n\t      else\n\t      {\n\t        op.Idx = 1;\n\t        op = op.Next;\n\t      }\n\t    }\n\t    if (cnt < 3)\n\t      cnt = 0;\n\t    var result = new Array(cnt);\n\t    for (var i = 0; i < cnt; ++i)\n\t    {\n\t      result[i] = new ClipperLib.IntPoint(op.Pt);\n\t      op = op.Next;\n\t    }\n\t    outPts = null;\n\t    return result;\n\t  };\n\t  ClipperLib.Clipper.CleanPolygons = function (polys, distance)\n\t  {\n\t    var result = new Array(polys.length);\n\t    for (var i = 0, ilen = polys.length; i < ilen; i++)\n\t      result[i] = ClipperLib.Clipper.CleanPolygon(polys[i], distance);\n\t    return result;\n\t  };\n\t  ClipperLib.Clipper.Minkowski = function (pattern, path, IsSum, IsClosed)\n\t  {\n\t    var delta = (IsClosed ? 1 : 0);\n\t    var polyCnt = pattern.length;\n\t    var pathCnt = path.length;\n\t    var result = new Array();\n\t    if (IsSum)\n\t      for (var i = 0; i < pathCnt; i++)\n\t      {\n\t        var p = new Array(polyCnt);\n\t        for (var j = 0, jlen = pattern.length, ip = pattern[j]; j < jlen; j++, ip = pattern[j])\n\t          p[j] = new ClipperLib.IntPoint(path[i].X + ip.X, path[i].Y + ip.Y);\n\t        result.push(p);\n\t      }\n\t    else\n\t      for (var i = 0; i < pathCnt; i++)\n\t      {\n\t        var p = new Array(polyCnt);\n\t        for (var j = 0, jlen = pattern.length, ip = pattern[j]; j < jlen; j++, ip = pattern[j])\n\t          p[j] = new ClipperLib.IntPoint(path[i].X - ip.X, path[i].Y - ip.Y);\n\t        result.push(p);\n\t      }\n\t    var quads = new Array();\n\t    for (var i = 0; i < pathCnt - 1 + delta; i++)\n\t      for (var j = 0; j < polyCnt; j++)\n\t      {\n\t        var quad = new Array();\n\t        quad.push(result[i % pathCnt][j % polyCnt]);\n\t        quad.push(result[(i + 1) % pathCnt][j % polyCnt]);\n\t        quad.push(result[(i + 1) % pathCnt][(j + 1) % polyCnt]);\n\t        quad.push(result[i % pathCnt][(j + 1) % polyCnt]);\n\t        if (!ClipperLib.Clipper.Orientation(quad))\n\t          quad.reverse();\n\t        quads.push(quad);\n\t      }\n\t\t\t\treturn quads;\n\t  };\n\t\n\t\tClipperLib.Clipper.MinkowskiSum = function(pattern, path_or_paths, pathIsClosed)\n\t\t{\n\t\t\tif(!(path_or_paths[0] instanceof Array))\n\t\t\t{\n\t\t\t\tvar path = path_or_paths;\n\t\t\t\tvar paths = ClipperLib.Clipper.Minkowski(pattern, path, true, pathIsClosed);\n\t\t\t\tvar c = new ClipperLib.Clipper();\n\t\t\t\tc.AddPaths(paths, ClipperLib.PolyType.ptSubject, true);\n\t\t\t\tc.Execute(ClipperLib.ClipType.ctUnion, paths, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);\n\t\t\t\treturn paths;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t \t\t\tvar paths = path_or_paths;\n\t\t\t\tvar solution = new ClipperLib.Paths();\n\t\t\t\tvar c = new ClipperLib.Clipper();\n\t\t\t\tfor (var i = 0; i < paths.length; ++i)\n\t\t\t\t{\n\t\t\t\t\tvar tmp = ClipperLib.Clipper.Minkowski(pattern, paths[i], true, pathIsClosed);\n\t\t\t\t\tc.AddPaths(tmp, ClipperLib.PolyType.ptSubject, true);\n\t\t\t\t\tif (pathIsClosed)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar path = ClipperLib.Clipper.TranslatePath(paths[i], pattern[0]);\n\t\t\t\t\t\tc.AddPath(path, ClipperLib.PolyType.ptClip, true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tc.Execute(ClipperLib.ClipType.ctUnion, solution,\n\t\t\t\t\tClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);\n\t\t\t\treturn solution;\n\t\t\t}\n\t\t}\n\t\t//------------------------------------------------------------------------------\n\t\n\t\tClipperLib.Clipper.TranslatePath = function (path, delta)\n\t\t{\n\t\t\tvar outPath = new ClipperLib.Path();\n\t\t\tfor (var i = 0; i < path.length; i++)\n\t\t\t\toutPath.push(new ClipperLib.IntPoint(path[i].X + delta.X, path[i].Y + delta.Y));\n\t\t\treturn outPath;\n\t\t}\n\t\t//------------------------------------------------------------------------------\n\t\n\t\tClipperLib.Clipper.MinkowskiDiff = function (poly1, poly2)\n\t\t{\n\t\t\tvar paths = ClipperLib.Clipper.Minkowski(poly1, poly2, false, true);\n\t\t\tvar c = new ClipperLib.Clipper();\n\t\t\tc.AddPaths(paths, ClipperLib.PolyType.ptSubject, true);\n\t\t\tc.Execute(ClipperLib.ClipType.ctUnion, paths, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);\n\t\t\treturn paths;\n\t\t}\n\t\n\t  ClipperLib.Clipper.PolyTreeToPaths = function (polytree)\n\t  {\n\t    var result = new Array();\n\t    //result.set_Capacity(polytree.get_Total());\n\t    ClipperLib.Clipper.AddPolyNodeToPaths(polytree, ClipperLib.Clipper.NodeType.ntAny, result);\n\t    return result;\n\t  };\n\t  ClipperLib.Clipper.AddPolyNodeToPaths = function (polynode, nt, paths)\n\t  {\n\t    var match = true;\n\t    switch (nt)\n\t    {\n\t    case ClipperLib.Clipper.NodeType.ntOpen:\n\t      return;\n\t    case ClipperLib.Clipper.NodeType.ntClosed:\n\t      match = !polynode.IsOpen;\n\t      break;\n\t    default:\n\t      break;\n\t    }\n\t    if (polynode.m_polygon.length > 0 && match)\n\t      paths.push(polynode.m_polygon);\n\t    for (var $i3 = 0, $t3 = polynode.Childs(), $l3 = $t3.length, pn = $t3[$i3]; $i3 < $l3; $i3++, pn = $t3[$i3])\n\t      ClipperLib.Clipper.AddPolyNodeToPaths(pn, nt, paths);\n\t  };\n\t  ClipperLib.Clipper.OpenPathsFromPolyTree = function (polytree)\n\t  {\n\t    var result = new ClipperLib.Paths();\n\t    //result.set_Capacity(polytree.ChildCount());\n\t    for (var i = 0, ilen = polytree.ChildCount(); i < ilen; i++)\n\t      if (polytree.Childs()[i].IsOpen)\n\t        result.push(polytree.Childs()[i].m_polygon);\n\t    return result;\n\t  };\n\t  ClipperLib.Clipper.ClosedPathsFromPolyTree = function (polytree)\n\t  {\n\t    var result = new ClipperLib.Paths();\n\t    //result.set_Capacity(polytree.Total());\n\t    ClipperLib.Clipper.AddPolyNodeToPaths(polytree, ClipperLib.Clipper.NodeType.ntClosed, result);\n\t    return result;\n\t  };\n\t  Inherit(ClipperLib.Clipper, ClipperLib.ClipperBase);\n\t  ClipperLib.Clipper.NodeType = {\n\t    ntAny: 0,\n\t    ntOpen: 1,\n\t    ntClosed: 2\n\t  };\n\t  ClipperLib.ClipperOffset = function (miterLimit, arcTolerance)\n\t  {\n\t    if (typeof (miterLimit) == \"undefined\") miterLimit = 2;\n\t    if (typeof (arcTolerance) == \"undefined\") arcTolerance = ClipperLib.ClipperOffset.def_arc_tolerance;\n\t    this.m_destPolys = new ClipperLib.Paths();\n\t    this.m_srcPoly = new ClipperLib.Path();\n\t    this.m_destPoly = new ClipperLib.Path();\n\t    this.m_normals = new Array();\n\t    this.m_delta = 0;\n\t    this.m_sinA = 0;\n\t    this.m_sin = 0;\n\t    this.m_cos = 0;\n\t    this.m_miterLim = 0;\n\t    this.m_StepsPerRad = 0;\n\t    this.m_lowest = new ClipperLib.IntPoint();\n\t    this.m_polyNodes = new ClipperLib.PolyNode();\n\t    this.MiterLimit = miterLimit;\n\t    this.ArcTolerance = arcTolerance;\n\t    this.m_lowest.X = -1;\n\t  };\n\t  ClipperLib.ClipperOffset.two_pi = 6.28318530717959;\n\t  ClipperLib.ClipperOffset.def_arc_tolerance = 0.25;\n\t  ClipperLib.ClipperOffset.prototype.Clear = function ()\n\t  {\n\t    ClipperLib.Clear(this.m_polyNodes.Childs());\n\t    this.m_lowest.X = -1;\n\t  };\n\t  ClipperLib.ClipperOffset.Round = ClipperLib.Clipper.Round;\n\t  ClipperLib.ClipperOffset.prototype.AddPath = function (path, joinType, endType)\n\t  {\n\t    var highI = path.length - 1;\n\t    if (highI < 0)\n\t      return;\n\t    var newNode = new ClipperLib.PolyNode();\n\t    newNode.m_jointype = joinType;\n\t    newNode.m_endtype = endType;\n\t    //strip duplicate points from path and also get index to the lowest point ...\n\t    if (endType == ClipperLib.EndType.etClosedLine || endType == ClipperLib.EndType.etClosedPolygon)\n\t      while (highI > 0 && ClipperLib.IntPoint.op_Equality(path[0], path[highI]))\n\t        highI--;\n\t    //newNode.m_polygon.set_Capacity(highI + 1);\n\t    newNode.m_polygon.push(path[0]);\n\t    var j = 0,\n\t      k = 0;\n\t    for (var i = 1; i <= highI; i++)\n\t      if (ClipperLib.IntPoint.op_Inequality(newNode.m_polygon[j], path[i]))\n\t      {\n\t        j++;\n\t        newNode.m_polygon.push(path[i]);\n\t        if (path[i].Y > newNode.m_polygon[k].Y || (path[i].Y == newNode.m_polygon[k].Y && path[i].X < newNode.m_polygon[k].X))\n\t          k = j;\n\t      }\n\t    if (endType == ClipperLib.EndType.etClosedPolygon && j < 2) return;\n\t\n\t    this.m_polyNodes.AddChild(newNode);\n\t    //if this path's lowest pt is lower than all the others then update m_lowest\n\t    if (endType != ClipperLib.EndType.etClosedPolygon)\n\t      return;\n\t    if (this.m_lowest.X < 0)\n\t      this.m_lowest = new ClipperLib.IntPoint(this.m_polyNodes.ChildCount() - 1, k);\n\t    else\n\t    {\n\t      var ip = this.m_polyNodes.Childs()[this.m_lowest.X].m_polygon[this.m_lowest.Y];\n\t      if (newNode.m_polygon[k].Y > ip.Y || (newNode.m_polygon[k].Y == ip.Y && newNode.m_polygon[k].X < ip.X))\n\t        this.m_lowest = new ClipperLib.IntPoint(this.m_polyNodes.ChildCount() - 1, k);\n\t    }\n\t  };\n\t  ClipperLib.ClipperOffset.prototype.AddPaths = function (paths, joinType, endType)\n\t  {\n\t    for (var i = 0, ilen = paths.length; i < ilen; i++)\n\t      this.AddPath(paths[i], joinType, endType);\n\t  };\n\t  ClipperLib.ClipperOffset.prototype.FixOrientations = function ()\n\t  {\n\t    //fixup orientations of all closed paths if the orientation of the\n\t    //closed path with the lowermost vertex is wrong ...\n\t    if (this.m_lowest.X >= 0 && !ClipperLib.Clipper.Orientation(this.m_polyNodes.Childs()[this.m_lowest.X].m_polygon))\n\t    {\n\t      for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n\t      {\n\t        var node = this.m_polyNodes.Childs()[i];\n\t        if (node.m_endtype == ClipperLib.EndType.etClosedPolygon || (node.m_endtype == ClipperLib.EndType.etClosedLine && ClipperLib.Clipper.Orientation(node.m_polygon)))\n\t          node.m_polygon.reverse();\n\t      }\n\t    }\n\t    else\n\t    {\n\t      for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n\t      {\n\t        var node = this.m_polyNodes.Childs()[i];\n\t        if (node.m_endtype == ClipperLib.EndType.etClosedLine && !ClipperLib.Clipper.Orientation(node.m_polygon))\n\t          node.m_polygon.reverse();\n\t      }\n\t    }\n\t  };\n\t  ClipperLib.ClipperOffset.GetUnitNormal = function (pt1, pt2)\n\t  {\n\t    var dx = (pt2.X - pt1.X);\n\t    var dy = (pt2.Y - pt1.Y);\n\t    if ((dx == 0) && (dy == 0))\n\t      return new ClipperLib.DoublePoint(0, 0);\n\t    var f = 1 / Math.sqrt(dx * dx + dy * dy);\n\t    dx *= f;\n\t    dy *= f;\n\t    return new ClipperLib.DoublePoint(dy, -dx);\n\t  };\n\t  ClipperLib.ClipperOffset.prototype.DoOffset = function (delta)\n\t  {\n\t    this.m_destPolys = new Array();\n\t    this.m_delta = delta;\n\t    //if Zero offset, just copy any CLOSED polygons to m_p and return ...\n\t    if (ClipperLib.ClipperBase.near_zero(delta))\n\t    {\n\t      //this.m_destPolys.set_Capacity(this.m_polyNodes.ChildCount);\n\t      for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n\t      {\n\t        var node = this.m_polyNodes.Childs()[i];\n\t        if (node.m_endtype == ClipperLib.EndType.etClosedPolygon)\n\t          this.m_destPolys.push(node.m_polygon);\n\t      }\n\t      return;\n\t    }\n\t    //see offset_triginometry3.svg in the documentation folder ...\n\t    if (this.MiterLimit > 2)\n\t      this.m_miterLim = 2 / (this.MiterLimit * this.MiterLimit);\n\t    else\n\t      this.m_miterLim = 0.5;\n\t    var y;\n\t    if (this.ArcTolerance <= 0)\n\t      y = ClipperLib.ClipperOffset.def_arc_tolerance;\n\t    else if (this.ArcTolerance > Math.abs(delta) * ClipperLib.ClipperOffset.def_arc_tolerance)\n\t      y = Math.abs(delta) * ClipperLib.ClipperOffset.def_arc_tolerance;\n\t    else\n\t      y = this.ArcTolerance;\n\t    //see offset_triginometry2.svg in the documentation folder ...\n\t    var steps = 3.14159265358979 / Math.acos(1 - y / Math.abs(delta));\n\t    this.m_sin = Math.sin(ClipperLib.ClipperOffset.two_pi / steps);\n\t    this.m_cos = Math.cos(ClipperLib.ClipperOffset.two_pi / steps);\n\t    this.m_StepsPerRad = steps / ClipperLib.ClipperOffset.two_pi;\n\t    if (delta < 0)\n\t      this.m_sin = -this.m_sin;\n\t    //this.m_destPolys.set_Capacity(this.m_polyNodes.ChildCount * 2);\n\t    for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n\t    {\n\t      var node = this.m_polyNodes.Childs()[i];\n\t      this.m_srcPoly = node.m_polygon;\n\t      var len = this.m_srcPoly.length;\n\t      if (len == 0 || (delta <= 0 && (len < 3 || node.m_endtype != ClipperLib.EndType.etClosedPolygon)))\n\t        continue;\n\t      this.m_destPoly = new Array();\n\t      if (len == 1)\n\t      {\n\t        if (node.m_jointype == ClipperLib.JoinType.jtRound)\n\t        {\n\t          var X = 1,\n\t            Y = 0;\n\t          for (var j = 1; j <= steps; j++)\n\t          {\n\t            this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X + X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y + Y * delta)));\n\t            var X2 = X;\n\t            X = X * this.m_cos - this.m_sin * Y;\n\t            Y = X2 * this.m_sin + Y * this.m_cos;\n\t          }\n\t        }\n\t        else\n\t        {\n\t          var X = -1,\n\t            Y = -1;\n\t          for (var j = 0; j < 4; ++j)\n\t          {\n\t            this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X + X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y + Y * delta)));\n\t            if (X < 0)\n\t              X = 1;\n\t            else if (Y < 0)\n\t              Y = 1;\n\t            else\n\t              X = -1;\n\t          }\n\t        }\n\t        this.m_destPolys.push(this.m_destPoly);\n\t        continue;\n\t      }\n\t      //build m_normals ...\n\t      this.m_normals.length = 0;\n\t      //this.m_normals.set_Capacity(len);\n\t      for (var j = 0; j < len - 1; j++)\n\t        this.m_normals.push(ClipperLib.ClipperOffset.GetUnitNormal(this.m_srcPoly[j], this.m_srcPoly[j + 1]));\n\t      if (node.m_endtype == ClipperLib.EndType.etClosedLine || node.m_endtype == ClipperLib.EndType.etClosedPolygon)\n\t        this.m_normals.push(ClipperLib.ClipperOffset.GetUnitNormal(this.m_srcPoly[len - 1], this.m_srcPoly[0]));\n\t      else\n\t        this.m_normals.push(new ClipperLib.DoublePoint(this.m_normals[len - 2]));\n\t      if (node.m_endtype == ClipperLib.EndType.etClosedPolygon)\n\t      {\n\t        var k = len - 1;\n\t        for (var j = 0; j < len; j++)\n\t          k = this.OffsetPoint(j, k, node.m_jointype);\n\t        this.m_destPolys.push(this.m_destPoly);\n\t      }\n\t      else if (node.m_endtype == ClipperLib.EndType.etClosedLine)\n\t      {\n\t        var k = len - 1;\n\t        for (var j = 0; j < len; j++)\n\t          k = this.OffsetPoint(j, k, node.m_jointype);\n\t        this.m_destPolys.push(this.m_destPoly);\n\t        this.m_destPoly = new Array();\n\t        //re-build m_normals ...\n\t        var n = this.m_normals[len - 1];\n\t        for (var j = len - 1; j > 0; j--)\n\t          this.m_normals[j] = new ClipperLib.DoublePoint(-this.m_normals[j - 1].X, -this.m_normals[j - 1].Y);\n\t        this.m_normals[0] = new ClipperLib.DoublePoint(-n.X, -n.Y);\n\t        k = 0;\n\t        for (var j = len - 1; j >= 0; j--)\n\t          k = this.OffsetPoint(j, k, node.m_jointype);\n\t        this.m_destPolys.push(this.m_destPoly);\n\t      }\n\t      else\n\t      {\n\t        var k = 0;\n\t        for (var j = 1; j < len - 1; ++j)\n\t          k = this.OffsetPoint(j, k, node.m_jointype);\n\t        var pt1;\n\t        if (node.m_endtype == ClipperLib.EndType.etOpenButt)\n\t        {\n\t          var j = len - 1;\n\t          pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[j].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[j].Y * delta));\n\t          this.m_destPoly.push(pt1);\n\t          pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X - this.m_normals[j].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y - this.m_normals[j].Y * delta));\n\t          this.m_destPoly.push(pt1);\n\t        }\n\t        else\n\t        {\n\t          var j = len - 1;\n\t          k = len - 2;\n\t          this.m_sinA = 0;\n\t          this.m_normals[j] = new ClipperLib.DoublePoint(-this.m_normals[j].X, -this.m_normals[j].Y);\n\t          if (node.m_endtype == ClipperLib.EndType.etOpenSquare)\n\t            this.DoSquare(j, k);\n\t          else\n\t            this.DoRound(j, k);\n\t        }\n\t        //re-build m_normals ...\n\t        for (var j = len - 1; j > 0; j--)\n\t          this.m_normals[j] = new ClipperLib.DoublePoint(-this.m_normals[j - 1].X, -this.m_normals[j - 1].Y);\n\t        this.m_normals[0] = new ClipperLib.DoublePoint(-this.m_normals[1].X, -this.m_normals[1].Y);\n\t        k = len - 1;\n\t        for (var j = k - 1; j > 0; --j)\n\t          k = this.OffsetPoint(j, k, node.m_jointype);\n\t        if (node.m_endtype == ClipperLib.EndType.etOpenButt)\n\t        {\n\t          pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X - this.m_normals[0].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y - this.m_normals[0].Y * delta));\n\t          this.m_destPoly.push(pt1);\n\t          pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X + this.m_normals[0].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y + this.m_normals[0].Y * delta));\n\t          this.m_destPoly.push(pt1);\n\t        }\n\t        else\n\t        {\n\t          k = 1;\n\t          this.m_sinA = 0;\n\t          if (node.m_endtype == ClipperLib.EndType.etOpenSquare)\n\t            this.DoSquare(0, 1);\n\t          else\n\t            this.DoRound(0, 1);\n\t        }\n\t        this.m_destPolys.push(this.m_destPoly);\n\t      }\n\t    }\n\t  };\n\t  ClipperLib.ClipperOffset.prototype.Execute = function ()\n\t  {\n\t    var a = arguments,\n\t      ispolytree = a[0] instanceof ClipperLib.PolyTree;\n\t    if (!ispolytree) // function (solution, delta)\n\t    {\n\t      var solution = a[0],\n\t        delta = a[1];\n\t      ClipperLib.Clear(solution);\n\t      this.FixOrientations();\n\t      this.DoOffset(delta);\n\t      //now clean up 'corners' ...\n\t      var clpr = new ClipperLib.Clipper(0);\n\t      clpr.AddPaths(this.m_destPolys, ClipperLib.PolyType.ptSubject, true);\n\t      if (delta > 0)\n\t      {\n\t        clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftPositive, ClipperLib.PolyFillType.pftPositive);\n\t      }\n\t      else\n\t      {\n\t        var r = ClipperLib.Clipper.GetBounds(this.m_destPolys);\n\t        var outer = new ClipperLib.Path();\n\t        outer.push(new ClipperLib.IntPoint(r.left - 10, r.bottom + 10));\n\t        outer.push(new ClipperLib.IntPoint(r.right + 10, r.bottom + 10));\n\t        outer.push(new ClipperLib.IntPoint(r.right + 10, r.top - 10));\n\t        outer.push(new ClipperLib.IntPoint(r.left - 10, r.top - 10));\n\t        clpr.AddPath(outer, ClipperLib.PolyType.ptSubject, true);\n\t        clpr.ReverseSolution = true;\n\t        clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftNegative, ClipperLib.PolyFillType.pftNegative);\n\t        if (solution.length > 0)\n\t          solution.splice(0, 1);\n\t      }\n\t      //console.log(JSON.stringify(solution));\n\t    }\n\t    else // function (polytree, delta)\n\t    {\n\t      var solution = a[0],\n\t        delta = a[1];\n\t      solution.Clear();\n\t      this.FixOrientations();\n\t      this.DoOffset(delta);\n\t      //now clean up 'corners' ...\n\t      var clpr = new ClipperLib.Clipper(0);\n\t      clpr.AddPaths(this.m_destPolys, ClipperLib.PolyType.ptSubject, true);\n\t      if (delta > 0)\n\t      {\n\t        clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftPositive, ClipperLib.PolyFillType.pftPositive);\n\t      }\n\t      else\n\t      {\n\t        var r = ClipperLib.Clipper.GetBounds(this.m_destPolys);\n\t        var outer = new ClipperLib.Path();\n\t        outer.push(new ClipperLib.IntPoint(r.left - 10, r.bottom + 10));\n\t        outer.push(new ClipperLib.IntPoint(r.right + 10, r.bottom + 10));\n\t        outer.push(new ClipperLib.IntPoint(r.right + 10, r.top - 10));\n\t        outer.push(new ClipperLib.IntPoint(r.left - 10, r.top - 10));\n\t        clpr.AddPath(outer, ClipperLib.PolyType.ptSubject, true);\n\t        clpr.ReverseSolution = true;\n\t        clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftNegative, ClipperLib.PolyFillType.pftNegative);\n\t        //remove the outer PolyNode rectangle ...\n\t        if (solution.ChildCount() == 1 && solution.Childs()[0].ChildCount() > 0)\n\t        {\n\t          var outerNode = solution.Childs()[0];\n\t          //solution.Childs.set_Capacity(outerNode.ChildCount);\n\t          solution.Childs()[0] = outerNode.Childs()[0];\n\t          solution.Childs()[0].m_Parent = solution;\n\t          for (var i = 1; i < outerNode.ChildCount(); i++)\n\t            solution.AddChild(outerNode.Childs()[i]);\n\t        }\n\t        else\n\t          solution.Clear();\n\t      }\n\t    }\n\t  };\n\t  ClipperLib.ClipperOffset.prototype.OffsetPoint = function (j, k, jointype)\n\t  {\n\t\t\t//cross product ...\n\t\t\tthis.m_sinA = (this.m_normals[k].X * this.m_normals[j].Y - this.m_normals[j].X * this.m_normals[k].Y);\n\t\n\t\t\tif (Math.abs(this.m_sinA * this.m_delta) < 1.0)\n\t\t\t{\n\t\t\t\t//dot product ...\n\t\t\t\tvar cosA = (this.m_normals[k].X * this.m_normals[j].X + this.m_normals[j].Y * this.m_normals[k].Y);\n\t\t\t\tif (cosA > 0) // angle ==> 0 degrees\n\t\t\t\t{\n\t\t\t\t\tthis.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[k].X * this.m_delta),\n\t\t\t\t\t\tClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[k].Y * this.m_delta)));\n\t\t\t\t\treturn k;\n\t\t\t\t}\n\t\t\t\t//else angle ==> 180 degrees\n\t\t\t}\n\t    else if (this.m_sinA > 1)\n\t      this.m_sinA = 1.0;\n\t    else if (this.m_sinA < -1)\n\t      this.m_sinA = -1.0;\n\t    if (this.m_sinA * this.m_delta < 0)\n\t    {\n\t      this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[k].X * this.m_delta),\n\t        ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[k].Y * this.m_delta)));\n\t      this.m_destPoly.push(new ClipperLib.IntPoint(this.m_srcPoly[j]));\n\t      this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[j].X * this.m_delta),\n\t        ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[j].Y * this.m_delta)));\n\t    }\n\t    else\n\t      switch (jointype)\n\t      {\n\t      case ClipperLib.JoinType.jtMiter:\n\t        {\n\t          var r = 1 + (this.m_normals[j].X * this.m_normals[k].X + this.m_normals[j].Y * this.m_normals[k].Y);\n\t          if (r >= this.m_miterLim)\n\t            this.DoMiter(j, k, r);\n\t          else\n\t            this.DoSquare(j, k);\n\t          break;\n\t        }\n\t      case ClipperLib.JoinType.jtSquare:\n\t        this.DoSquare(j, k);\n\t        break;\n\t      case ClipperLib.JoinType.jtRound:\n\t        this.DoRound(j, k);\n\t        break;\n\t      }\n\t    k = j;\n\t    return k;\n\t  };\n\t  ClipperLib.ClipperOffset.prototype.DoSquare = function (j, k)\n\t  {\n\t    var dx = Math.tan(Math.atan2(this.m_sinA,\n\t      this.m_normals[k].X * this.m_normals[j].X + this.m_normals[k].Y * this.m_normals[j].Y) / 4);\n\t    this.m_destPoly.push(new ClipperLib.IntPoint(\n\t      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_delta * (this.m_normals[k].X - this.m_normals[k].Y * dx)),\n\t      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_delta * (this.m_normals[k].Y + this.m_normals[k].X * dx))));\n\t    this.m_destPoly.push(new ClipperLib.IntPoint(\n\t      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_delta * (this.m_normals[j].X + this.m_normals[j].Y * dx)),\n\t      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_delta * (this.m_normals[j].Y - this.m_normals[j].X * dx))));\n\t  };\n\t  ClipperLib.ClipperOffset.prototype.DoMiter = function (j, k, r)\n\t  {\n\t    var q = this.m_delta / r;\n\t    this.m_destPoly.push(new ClipperLib.IntPoint(\n\t      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + (this.m_normals[k].X + this.m_normals[j].X) * q),\n\t      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + (this.m_normals[k].Y + this.m_normals[j].Y) * q)));\n\t  };\n\t  ClipperLib.ClipperOffset.prototype.DoRound = function (j, k)\n\t  {\n\t    var a = Math.atan2(this.m_sinA,\n\t      this.m_normals[k].X * this.m_normals[j].X + this.m_normals[k].Y * this.m_normals[j].Y);\n\t\n\t    \tvar steps = Math.max(ClipperLib.Cast_Int32(ClipperLib.ClipperOffset.Round(this.m_StepsPerRad * Math.abs(a))), 1);\n\t\n\t    var X = this.m_normals[k].X,\n\t      Y = this.m_normals[k].Y,\n\t      X2;\n\t    for (var i = 0; i < steps; ++i)\n\t    {\n\t      this.m_destPoly.push(new ClipperLib.IntPoint(\n\t        ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + X * this.m_delta),\n\t        ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + Y * this.m_delta)));\n\t      X2 = X;\n\t      X = X * this.m_cos - this.m_sin * Y;\n\t      Y = X2 * this.m_sin + Y * this.m_cos;\n\t    }\n\t    this.m_destPoly.push(new ClipperLib.IntPoint(\n\t      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[j].X * this.m_delta),\n\t      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[j].Y * this.m_delta)));\n\t  };\n\t  ClipperLib.Error = function (message)\n\t  {\n\t    try\n\t    {\n\t      throw new Error(message);\n\t    }\n\t    catch (err)\n\t    {\n\t      alert(err.message);\n\t    }\n\t  };\n\t  // ---------------------------------\n\t  // JS extension by Timo 2013\n\t  ClipperLib.JS = {};\n\t  ClipperLib.JS.AreaOfPolygon = function (poly, scale)\n\t  {\n\t    if (!scale) scale = 1;\n\t    return ClipperLib.Clipper.Area(poly) / (scale * scale);\n\t  };\n\t  ClipperLib.JS.AreaOfPolygons = function (poly, scale)\n\t  {\n\t    if (!scale) scale = 1;\n\t    var area = 0;\n\t    for (var i = 0; i < poly.length; i++)\n\t    {\n\t      area += ClipperLib.Clipper.Area(poly[i]);\n\t    }\n\t    return area / (scale * scale);\n\t  };\n\t  ClipperLib.JS.BoundsOfPath = function (path, scale)\n\t  {\n\t    return ClipperLib.JS.BoundsOfPaths([path], scale);\n\t  };\n\t  ClipperLib.JS.BoundsOfPaths = function (paths, scale)\n\t  {\n\t    if (!scale) scale = 1;\n\t    var bounds = ClipperLib.Clipper.GetBounds(paths);\n\t    bounds.left /= scale;\n\t    bounds.bottom /= scale;\n\t    bounds.right /= scale;\n\t    bounds.top /= scale;\n\t    return bounds;\n\t  };\n\t  // Clean() joins vertices that are too near each other\n\t  // and causes distortion to offsetted polygons without cleaning\n\t  ClipperLib.JS.Clean = function (polygon, delta)\n\t  {\n\t    if (!(polygon instanceof Array)) return [];\n\t    var isPolygons = polygon[0] instanceof Array;\n\t    var polygon = ClipperLib.JS.Clone(polygon);\n\t    if (typeof delta != \"number\" || delta === null)\n\t    {\n\t      ClipperLib.Error(\"Delta is not a number in Clean().\");\n\t      return polygon;\n\t    }\n\t    if (polygon.length === 0 || (polygon.length == 1 && polygon[0].length === 0) || delta < 0) return polygon;\n\t    if (!isPolygons) polygon = [polygon];\n\t    var k_length = polygon.length;\n\t    var len, poly, result, d, p, j, i;\n\t    var results = [];\n\t    for (var k = 0; k < k_length; k++)\n\t    {\n\t      poly = polygon[k];\n\t      len = poly.length;\n\t      if (len === 0) continue;\n\t      else if (len < 3)\n\t      {\n\t        result = poly;\n\t        results.push(result);\n\t        continue;\n\t      }\n\t      result = poly;\n\t      d = delta * delta;\n\t      //d = Math.floor(c_delta * c_delta);\n\t      p = poly[0];\n\t      j = 1;\n\t      for (i = 1; i < len; i++)\n\t      {\n\t        if ((poly[i].X - p.X) * (poly[i].X - p.X) +\n\t          (poly[i].Y - p.Y) * (poly[i].Y - p.Y) <= d)\n\t          continue;\n\t        result[j] = poly[i];\n\t        p = poly[i];\n\t        j++;\n\t      }\n\t      p = poly[j - 1];\n\t      if ((poly[0].X - p.X) * (poly[0].X - p.X) +\n\t        (poly[0].Y - p.Y) * (poly[0].Y - p.Y) <= d)\n\t        j--;\n\t      if (j < len)\n\t        result.splice(j, len - j);\n\t      if (result.length) results.push(result);\n\t    }\n\t    if (!isPolygons && results.length) results = results[0];\n\t    else if (!isPolygons && results.length === 0) results = [];\n\t    else if (isPolygons && results.length === 0) results = [\n\t      []\n\t    ];\n\t    return results;\n\t  }\n\t  // Make deep copy of Polygons or Polygon\n\t  // so that also IntPoint objects are cloned and not only referenced\n\t  // This should be the fastest way\n\t  ClipperLib.JS.Clone = function (polygon)\n\t  {\n\t    if (!(polygon instanceof Array)) return [];\n\t    if (polygon.length === 0) return [];\n\t    else if (polygon.length == 1 && polygon[0].length === 0) return [[]];\n\t    var isPolygons = polygon[0] instanceof Array;\n\t    if (!isPolygons) polygon = [polygon];\n\t    var len = polygon.length,\n\t      plen, i, j, result;\n\t    var results = new Array(len);\n\t    for (i = 0; i < len; i++)\n\t    {\n\t      plen = polygon[i].length;\n\t      result = new Array(plen);\n\t      for (j = 0; j < plen; j++)\n\t      {\n\t        result[j] = {\n\t          X: polygon[i][j].X,\n\t          Y: polygon[i][j].Y\n\t        };\n\t      }\n\t      results[i] = result;\n\t    }\n\t    if (!isPolygons) results = results[0];\n\t    return results;\n\t  };\n\t  // Removes points that doesn't affect much to the visual appearance.\n\t  // If middle point is at or under certain distance (tolerance) of the line segment between\n\t  // start and end point, the middle point is removed.\n\t  ClipperLib.JS.Lighten = function (polygon, tolerance)\n\t  {\n\t    if (!(polygon instanceof Array)) return [];\n\t    if (typeof tolerance != \"number\" || tolerance === null)\n\t    {\n\t      ClipperLib.Error(\"Tolerance is not a number in Lighten().\")\n\t      return ClipperLib.JS.Clone(polygon);\n\t    }\n\t    if (polygon.length === 0 || (polygon.length == 1 && polygon[0].length === 0) || tolerance < 0)\n\t    {\n\t      return ClipperLib.JS.Clone(polygon);\n\t    }\n\t    if (!(polygon[0] instanceof Array)) polygon = [polygon];\n\t    var i, j, poly, k, poly2, plen, A, B, P, d, rem, addlast;\n\t    var bxax, byay, l, ax, ay;\n\t    var len = polygon.length;\n\t    var toleranceSq = tolerance * tolerance;\n\t    var results = [];\n\t    for (i = 0; i < len; i++)\n\t    {\n\t      poly = polygon[i];\n\t      plen = poly.length;\n\t      if (plen == 0) continue;\n\t      for (k = 0; k < 1000000; k++) // could be forever loop, but wiser to restrict max repeat count\n\t      {\n\t        poly2 = [];\n\t        plen = poly.length;\n\t        // the first have to added to the end, if first and last are not the same\n\t        // this way we ensure that also the actual last point can be removed if needed\n\t        if (poly[plen - 1].X != poly[0].X || poly[plen - 1].Y != poly[0].Y)\n\t        {\n\t          addlast = 1;\n\t          poly.push(\n\t          {\n\t            X: poly[0].X,\n\t            Y: poly[0].Y\n\t          });\n\t          plen = poly.length;\n\t        }\n\t        else addlast = 0;\n\t        rem = []; // Indexes of removed points\n\t        for (j = 0; j < plen - 2; j++)\n\t        {\n\t          A = poly[j]; // Start point of line segment\n\t          P = poly[j + 1]; // Middle point. This is the one to be removed.\n\t          B = poly[j + 2]; // End point of line segment\n\t          ax = A.X;\n\t          ay = A.Y;\n\t          bxax = B.X - ax;\n\t          byay = B.Y - ay;\n\t          if (bxax !== 0 || byay !== 0) // To avoid Nan, when A==P && P==B. And to avoid peaks (A==B && A!=P), which have lenght, but not area.\n\t          {\n\t            l = ((P.X - ax) * bxax + (P.Y - ay) * byay) / (bxax * bxax + byay * byay);\n\t            if (l > 1)\n\t            {\n\t              ax = B.X;\n\t              ay = B.Y;\n\t            }\n\t            else if (l > 0)\n\t            {\n\t              ax += bxax * l;\n\t              ay += byay * l;\n\t            }\n\t          }\n\t          bxax = P.X - ax;\n\t          byay = P.Y - ay;\n\t          d = bxax * bxax + byay * byay;\n\t          if (d <= toleranceSq)\n\t          {\n\t            rem[j + 1] = 1;\n\t            j++; // when removed, transfer the pointer to the next one\n\t          }\n\t        }\n\t        // add all unremoved points to poly2\n\t        poly2.push(\n\t        {\n\t          X: poly[0].X,\n\t          Y: poly[0].Y\n\t        });\n\t        for (j = 1; j < plen - 1; j++)\n\t          if (!rem[j]) poly2.push(\n\t          {\n\t            X: poly[j].X,\n\t            Y: poly[j].Y\n\t          });\n\t        poly2.push(\n\t        {\n\t          X: poly[plen - 1].X,\n\t          Y: poly[plen - 1].Y\n\t        });\n\t        // if the first point was added to the end, remove it\n\t        if (addlast) poly.pop();\n\t        // break, if there was not anymore removed points\n\t        if (!rem.length) break;\n\t        // else continue looping using poly2, to check if there are points to remove\n\t        else poly = poly2;\n\t      }\n\t      plen = poly2.length;\n\t      // remove duplicate from end, if needed\n\t      if (poly2[plen - 1].X == poly2[0].X && poly2[plen - 1].Y == poly2[0].Y)\n\t      {\n\t        poly2.pop();\n\t      }\n\t      if (poly2.length > 2) // to avoid two-point-polygons\n\t        results.push(poly2);\n\t    }\n\t    if (!(polygon[0] instanceof Array)) results = results[0];\n\t    if (typeof (results) == \"undefined\") results = [\n\t      []\n\t    ];\n\t    return results;\n\t  }\n\t  ClipperLib.JS.PerimeterOfPath = function (path, closed, scale)\n\t  {\n\t    if (typeof (path) == \"undefined\") return 0;\n\t    var sqrt = Math.sqrt;\n\t    var perimeter = 0.0;\n\t    var p1, p2, p1x = 0.0,\n\t      p1y = 0.0,\n\t      p2x = 0.0,\n\t      p2y = 0.0;\n\t    var j = path.length;\n\t    if (j < 2) return 0;\n\t    if (closed)\n\t    {\n\t      path[j] = path[0];\n\t      j++;\n\t    }\n\t    while (--j)\n\t    {\n\t      p1 = path[j];\n\t      p1x = p1.X;\n\t      p1y = p1.Y;\n\t      p2 = path[j - 1];\n\t      p2x = p2.X;\n\t      p2y = p2.Y;\n\t      perimeter += sqrt((p1x - p2x) * (p1x - p2x) + (p1y - p2y) * (p1y - p2y));\n\t    }\n\t    if (closed) path.pop();\n\t    return perimeter / scale;\n\t  };\n\t  ClipperLib.JS.PerimeterOfPaths = function (paths, closed, scale)\n\t  {\n\t    if (!scale) scale = 1;\n\t    var perimeter = 0;\n\t    for (var i = 0; i < paths.length; i++)\n\t    {\n\t      perimeter += ClipperLib.JS.PerimeterOfPath(paths[i], closed, scale);\n\t    }\n\t    return perimeter;\n\t  };\n\t  ClipperLib.JS.ScaleDownPath = function (path, scale)\n\t  {\n\t    var i, p;\n\t    if (!scale) scale = 1;\n\t    i = path.length;\n\t    while (i--)\n\t    {\n\t      p = path[i];\n\t      p.X = p.X / scale;\n\t      p.Y = p.Y / scale;\n\t    }\n\t  };\n\t  ClipperLib.JS.ScaleDownPaths = function (paths, scale)\n\t  {\n\t    var i, j, p;\n\t    if (!scale) scale = 1;\n\t    i = paths.length;\n\t    while (i--)\n\t    {\n\t      j = paths[i].length;\n\t      while (j--)\n\t      {\n\t        p = paths[i][j];\n\t        p.X = p.X / scale;\n\t        p.Y = p.Y / scale;\n\t      }\n\t    }\n\t  };\n\t  ClipperLib.JS.ScaleUpPath = function (path, scale)\n\t  {\n\t    var i, p, round = Math.round;\n\t    if (!scale) scale = 1;\n\t    i = path.length;\n\t    while (i--)\n\t    {\n\t      p = path[i];\n\t      p.X = round(p.X * scale);\n\t      p.Y = round(p.Y * scale);\n\t    }\n\t  };\n\t  ClipperLib.JS.ScaleUpPaths = function (paths, scale)\n\t  {\n\t    var i, j, p, round = Math.round;\n\t    if (!scale) scale = 1;\n\t    i = paths.length;\n\t    while (i--)\n\t    {\n\t      j = paths[i].length;\n\t      while (j--)\n\t      {\n\t        p = paths[i][j];\n\t        p.X = round(p.X * scale);\n\t        p.Y = round(p.Y * scale);\n\t      }\n\t    }\n\t  };\n\t  ClipperLib.ExPolygons = function ()\n\t  {\n\t    return [];\n\t  }\n\t  ClipperLib.ExPolygon = function ()\n\t  {\n\t    this.outer = null;\n\t    this.holes = null;\n\t  };\n\t  ClipperLib.JS.AddOuterPolyNodeToExPolygons = function (polynode, expolygons)\n\t  {\n\t    var ep = new ClipperLib.ExPolygon();\n\t    ep.outer = polynode.Contour();\n\t    var childs = polynode.Childs();\n\t    var ilen = childs.length;\n\t    ep.holes = new Array(ilen);\n\t    var node, n, i, j, childs2, jlen;\n\t    for (i = 0; i < ilen; i++)\n\t    {\n\t      node = childs[i];\n\t      ep.holes[i] = node.Contour();\n\t      //Add outer polygons contained by (nested within) holes ...\n\t      for (j = 0, childs2 = node.Childs(), jlen = childs2.length; j < jlen; j++)\n\t      {\n\t        n = childs2[j];\n\t        ClipperLib.JS.AddOuterPolyNodeToExPolygons(n, expolygons);\n\t      }\n\t    }\n\t    expolygons.push(ep);\n\t  };\n\t  ClipperLib.JS.ExPolygonsToPaths = function (expolygons)\n\t  {\n\t    var a, i, alen, ilen;\n\t    var paths = new ClipperLib.Paths();\n\t    for (a = 0, alen = expolygons.length; a < alen; a++)\n\t    {\n\t      paths.push(expolygons[a].outer);\n\t      for (i = 0, ilen = expolygons[a].holes.length; i < ilen; i++)\n\t      {\n\t        paths.push(expolygons[a].holes[i]);\n\t      }\n\t    }\n\t    return paths;\n\t  }\n\t  ClipperLib.JS.PolyTreeToExPolygons = function (polytree)\n\t  {\n\t    var expolygons = new ClipperLib.ExPolygons();\n\t    var node, i, childs, ilen;\n\t    for (i = 0, childs = polytree.Childs(), ilen = childs.length; i < ilen; i++)\n\t    {\n\t      node = childs[i];\n\t      ClipperLib.JS.AddOuterPolyNodeToExPolygons(node, expolygons);\n\t    }\n\t    return expolygons;\n\t  };\n\t})();\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n\t// \n\t// Licensed under the Apache License, Version 2.0 (the \"License\");\n\t// you may not use this file except in compliance with the License.\n\t// You may obtain a copy of the License at\n\t// \n\t// http://www.apache.org/licenses/LICENSE-2.0\n\t// \n\t// Unless required by applicable law or agreed to in writing, software\n\t// distributed under the License is distributed on an \"AS IS\" BASIS,\n\t// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t// See the License for the specific language governing permissions and\n\t// limitations under the License.\n\t//  \\\\\n\t//  Eve 0.4.2 - JavaScript Events Library                       \\\\\n\t//  \\\\\n\t//  Author Dmitry Baranovskiy (http://dmitry.baranovskiy.com/)  \\\\\n\t//  \\\\\n\t\n\t(function (glob) {\n\t    var version = \"0.4.2\",\n\t        has = \"hasOwnProperty\",\n\t        separator = /[\\.\\/]/,\n\t        comaseparator = /\\s*,\\s*/,\n\t        wildcard = \"*\",\n\t        fun = function () {},\n\t        numsort = function (a, b) {\n\t            return a - b;\n\t        },\n\t        current_event,\n\t        stop,\n\t        events = {n: {}},\n\t        firstDefined = function () {\n\t            for (var i = 0, ii = this.length; i < ii; i++) {\n\t                if (typeof this[i] != \"undefined\") {\n\t                    return this[i];\n\t                }\n\t            }\n\t        },\n\t        lastDefined = function () {\n\t            var i = this.length;\n\t            while (--i) {\n\t                if (typeof this[i] != \"undefined\") {\n\t                    return this[i];\n\t                }\n\t            }\n\t        },\n\t    /*\\\n\t     * eve\n\t     [ method ]\n\t\n\t     * Fires event with given `name`, given scope and other parameters.\n\t\n\t     > Arguments\n\t\n\t     - name (string) name of the *event*, dot (`.`) or slash (`/`) separated\n\t     - scope (object) context for the event handlers\n\t     - varargs (...) the rest of arguments will be sent to event handlers\n\t\n\t     = (object) array of returned values from the listeners. Array has two methods `.firstDefined()` and `.lastDefined()` to get first or last not `undefined` value.\n\t    \\*/\n\t        eve = function (name, scope) {\n\t            name = String(name);\n\t            var e = events,\n\t                oldstop = stop,\n\t                args = Array.prototype.slice.call(arguments, 2),\n\t                listeners = eve.listeners(name),\n\t                z = 0,\n\t                f = false,\n\t                l,\n\t                indexed = [],\n\t                queue = {},\n\t                out = [],\n\t                ce = current_event,\n\t                errors = [];\n\t            out.firstDefined = firstDefined;\n\t            out.lastDefined = lastDefined;\n\t            current_event = name;\n\t            stop = 0;\n\t            for (var i = 0, ii = listeners.length; i < ii; i++) if (\"zIndex\" in listeners[i]) {\n\t                indexed.push(listeners[i].zIndex);\n\t                if (listeners[i].zIndex < 0) {\n\t                    queue[listeners[i].zIndex] = listeners[i];\n\t                }\n\t            }\n\t            indexed.sort(numsort);\n\t            while (indexed[z] < 0) {\n\t                l = queue[indexed[z++]];\n\t                out.push(l.apply(scope, args));\n\t                if (stop) {\n\t                    stop = oldstop;\n\t                    return out;\n\t                }\n\t            }\n\t            for (i = 0; i < ii; i++) {\n\t                l = listeners[i];\n\t                if (\"zIndex\" in l) {\n\t                    if (l.zIndex == indexed[z]) {\n\t                        out.push(l.apply(scope, args));\n\t                        if (stop) {\n\t                            break;\n\t                        }\n\t                        do {\n\t                            z++;\n\t                            l = queue[indexed[z]];\n\t                            l && out.push(l.apply(scope, args));\n\t                            if (stop) {\n\t                                break;\n\t                            }\n\t                        } while (l)\n\t                    } else {\n\t                        queue[l.zIndex] = l;\n\t                    }\n\t                } else {\n\t                    out.push(l.apply(scope, args));\n\t                    if (stop) {\n\t                        break;\n\t                    }\n\t                }\n\t            }\n\t            stop = oldstop;\n\t            current_event = ce;\n\t            return out;\n\t        };\n\t        // Undocumented. Debug only.\n\t        eve._events = events;\n\t    /*\\\n\t     * eve.listeners\n\t     [ method ]\n\t\n\t     * Internal method which gives you array of all event handlers that will be triggered by the given `name`.\n\t\n\t     > Arguments\n\t\n\t     - name (string) name of the event, dot (`.`) or slash (`/`) separated\n\t\n\t     = (array) array of event handlers\n\t    \\*/\n\t    eve.listeners = function (name) {\n\t        var names = name.split(separator),\n\t            e = events,\n\t            item,\n\t            items,\n\t            k,\n\t            i,\n\t            ii,\n\t            j,\n\t            jj,\n\t            nes,\n\t            es = [e],\n\t            out = [];\n\t        for (i = 0, ii = names.length; i < ii; i++) {\n\t            nes = [];\n\t            for (j = 0, jj = es.length; j < jj; j++) {\n\t                e = es[j].n;\n\t                items = [e[names[i]], e[wildcard]];\n\t                k = 2;\n\t                while (k--) {\n\t                    item = items[k];\n\t                    if (item) {\n\t                        nes.push(item);\n\t                        out = out.concat(item.f || []);\n\t                    }\n\t                }\n\t            }\n\t            es = nes;\n\t        }\n\t        return out;\n\t    };\n\t    \n\t    /*\\\n\t     * eve.on\n\t     [ method ]\n\t     **\n\t     * Binds given event handler with a given name. You can use wildcards `*` for the names:\n\t     | eve.on(\"*.under.*\", f);\n\t     | eve(\"mouse.under.floor\"); // triggers f\n\t     * Use @eve to trigger the listener.\n\t     **\n\t     > Arguments\n\t     **\n\t     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards\n\t     - f (function) event handler function\n\t     **\n\t     = (function) returned function accepts a single numeric parameter that represents z-index of the handler. It is an optional feature and only used when you need to ensure that some subset of handlers will be invoked in a given order, despite of the order of assignment. \n\t     > Example:\n\t     | eve.on(\"mouse\", eatIt)(2);\n\t     | eve.on(\"mouse\", scream);\n\t     | eve.on(\"mouse\", catchIt)(1);\n\t     * This will ensure that `catchIt` function will be called before `eatIt`.\n\t     *\n\t     * If you want to put your handler before non-indexed handlers, specify a negative value.\n\t     * Note: I assume most of the time you dont need to worry about z-index, but its nice to have this feature just in case.\n\t    \\*/\n\t    eve.on = function (name, f) {\n\t        name = String(name);\n\t        if (typeof f != \"function\") {\n\t            return function () {};\n\t        }\n\t        var names = name.split(comaseparator);\n\t        for (var i = 0, ii = names.length; i < ii; i++) {\n\t            (function (name) {\n\t                var names = name.split(separator),\n\t                    e = events,\n\t                    exist;\n\t                for (var i = 0, ii = names.length; i < ii; i++) {\n\t                    e = e.n;\n\t                    e = e.hasOwnProperty(names[i]) && e[names[i]] || (e[names[i]] = {n: {}});\n\t                }\n\t                e.f = e.f || [];\n\t                for (i = 0, ii = e.f.length; i < ii; i++) if (e.f[i] == f) {\n\t                    exist = true;\n\t                    break;\n\t                }\n\t                !exist && e.f.push(f);\n\t            }(names[i]));\n\t        }\n\t        return function (zIndex) {\n\t            if (+zIndex == +zIndex) {\n\t                f.zIndex = +zIndex;\n\t            }\n\t        };\n\t    };\n\t    /*\\\n\t     * eve.f\n\t     [ method ]\n\t     **\n\t     * Returns function that will fire given event with optional arguments.\n\t     * Arguments that will be passed to the result function will be also\n\t     * concated to the list of final arguments.\n\t     | el.onclick = eve.f(\"click\", 1, 2);\n\t     | eve.on(\"click\", function (a, b, c) {\n\t     |     console.log(a, b, c); // 1, 2, [event object]\n\t     | });\n\t     > Arguments\n\t     - event (string) event name\n\t     - varargs () and any other arguments\n\t     = (function) possible event handler function\n\t    \\*/\n\t    eve.f = function (event) {\n\t        var attrs = [].slice.call(arguments, 1);\n\t        return function () {\n\t            eve.apply(null, [event, null].concat(attrs).concat([].slice.call(arguments, 0)));\n\t        };\n\t    };\n\t    /*\\\n\t     * eve.stop\n\t     [ method ]\n\t     **\n\t     * Is used inside an event handler to stop the event, preventing any subsequent listeners from firing.\n\t    \\*/\n\t    eve.stop = function () {\n\t        stop = 1;\n\t    };\n\t    /*\\\n\t     * eve.nt\n\t     [ method ]\n\t     **\n\t     * Could be used inside event handler to figure out actual name of the event.\n\t     **\n\t     > Arguments\n\t     **\n\t     - subname (string) #optional subname of the event\n\t     **\n\t     = (string) name of the event, if `subname` is not specified\n\t     * or\n\t     = (boolean) `true`, if current events name contains `subname`\n\t    \\*/\n\t    eve.nt = function (subname) {\n\t        if (subname) {\n\t            return new RegExp(\"(?:\\\\.|\\\\/|^)\" + subname + \"(?:\\\\.|\\\\/|$)\").test(current_event);\n\t        }\n\t        return current_event;\n\t    };\n\t    /*\\\n\t     * eve.nts\n\t     [ method ]\n\t     **\n\t     * Could be used inside event handler to figure out actual name of the event.\n\t     **\n\t     **\n\t     = (array) names of the event\n\t    \\*/\n\t    eve.nts = function () {\n\t        return current_event.split(separator);\n\t    };\n\t    /*\\\n\t     * eve.off\n\t     [ method ]\n\t     **\n\t     * Removes given function from the list of event listeners assigned to given name.\n\t     * If no arguments specified all the events will be cleared.\n\t     **\n\t     > Arguments\n\t     **\n\t     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards\n\t     - f (function) event handler function\n\t    \\*/\n\t    /*\\\n\t     * eve.unbind\n\t     [ method ]\n\t     **\n\t     * See @eve.off\n\t    \\*/\n\t    eve.off = eve.unbind = function (name, f) {\n\t        if (!name) {\n\t            eve._events = events = {n: {}};\n\t            return;\n\t        }\n\t        var names = name.split(comaseparator);\n\t        if (names.length > 1) {\n\t            for (var i = 0, ii = names.length; i < ii; i++) {\n\t                eve.off(names[i], f);\n\t            }\n\t            return;\n\t        }\n\t        names = name.split(separator);\n\t        var e,\n\t            key,\n\t            splice,\n\t            i, ii, j, jj,\n\t            cur = [events];\n\t        for (i = 0, ii = names.length; i < ii; i++) {\n\t            for (j = 0; j < cur.length; j += splice.length - 2) {\n\t                splice = [j, 1];\n\t                e = cur[j].n;\n\t                if (names[i] != wildcard) {\n\t                    if (e[names[i]]) {\n\t                        splice.push(e[names[i]]);\n\t                    }\n\t                } else {\n\t                    for (key in e) if (e[has](key)) {\n\t                        splice.push(e[key]);\n\t                    }\n\t                }\n\t                cur.splice.apply(cur, splice);\n\t            }\n\t        }\n\t        for (i = 0, ii = cur.length; i < ii; i++) {\n\t            e = cur[i];\n\t            while (e.n) {\n\t                if (f) {\n\t                    if (e.f) {\n\t                        for (j = 0, jj = e.f.length; j < jj; j++) if (e.f[j] == f) {\n\t                            e.f.splice(j, 1);\n\t                            break;\n\t                        }\n\t                        !e.f.length && delete e.f;\n\t                    }\n\t                    for (key in e.n) if (e.n[has](key) && e.n[key].f) {\n\t                        var funcs = e.n[key].f;\n\t                        for (j = 0, jj = funcs.length; j < jj; j++) if (funcs[j] == f) {\n\t                            funcs.splice(j, 1);\n\t                            break;\n\t                        }\n\t                        !funcs.length && delete e.n[key].f;\n\t                    }\n\t                } else {\n\t                    delete e.f;\n\t                    for (key in e.n) if (e.n[has](key) && e.n[key].f) {\n\t                        delete e.n[key].f;\n\t                    }\n\t                }\n\t                e = e.n;\n\t            }\n\t        }\n\t    };\n\t    /*\\\n\t     * eve.once\n\t     [ method ]\n\t     **\n\t     * Binds given event handler with a given name to only run once then unbind itself.\n\t     | eve.once(\"login\", f);\n\t     | eve(\"login\"); // triggers f\n\t     | eve(\"login\"); // no listeners\n\t     * Use @eve to trigger the listener.\n\t     **\n\t     > Arguments\n\t     **\n\t     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards\n\t     - f (function) event handler function\n\t     **\n\t     = (function) same return function as @eve.on\n\t    \\*/\n\t    eve.once = function (name, f) {\n\t        var f2 = function () {\n\t            eve.unbind(name, f2);\n\t            return f.apply(this, arguments);\n\t        };\n\t        return eve.on(name, f2);\n\t    };\n\t    /*\\\n\t     * eve.version\n\t     [ property (string) ]\n\t     **\n\t     * Current version of the library.\n\t    \\*/\n\t    eve.version = version;\n\t    eve.toString = function () {\n\t        return \"You are running Eve \" + version;\n\t    };\n\t    (typeof module != \"undefined\" && module.exports) ? (module.exports = eve) : ( true ? (!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() { return eve; }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))) : (glob.eve = eve));\n\t})(this);\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports) {\n\n\t/*\n\t * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors\n\t * http://code.google.com/p/poly2tri/\n\t *\n\t * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors\n\t * https://github.com/r3mi/poly2tri.js\n\t *\n\t * All rights reserved.\n\t *\n\t * Distributed under the 3-clause BSD License, see LICENSE.txt\n\t */\n\t\n\t\"use strict\";\n\t\n\t/*\n\t * Function added in the JavaScript version (was not present in the c++ version)\n\t */\n\t\n\t/**\n\t * assert and throw an exception.\n\t *\n\t * @private\n\t * @param {boolean} condition   the condition which is asserted\n\t * @param {string} message      the message which is display is condition is falsy\n\t */\n\tfunction assert(condition, message) {\n\t    if (!condition) {\n\t        throw new Error(message || \"Assert Failed\");\n\t    }\n\t}\n\tmodule.exports = assert;\n\t\n\t\n\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/*\n\t * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors\n\t * http://code.google.com/p/poly2tri/\n\t * \n\t * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors\n\t * https://github.com/r3mi/poly2tri.js\n\t * \n\t * All rights reserved.\n\t * \n\t * Distributed under the 3-clause BSD License, see LICENSE.txt\n\t */\n\t\n\t\"use strict\";\n\t\n\t\n\t/*\n\t * Note\n\t * ====\n\t * the structure of this JavaScript version of poly2tri intentionally follows\n\t * as closely as possible the structure of the reference C++ version, to make it \n\t * easier to keep the 2 versions in sync.\n\t */\n\t\n\tvar xy = __webpack_require__(1);\n\t\n\t// ------------------------------------------------------------------------Point\n\t/**\n\t * Construct a point\n\t * @example\n\t *      var point = new poly2tri.Point(150, 150);\n\t * @public\n\t * @constructor\n\t * @struct\n\t * @param {number=} x    coordinate (0 if undefined)\n\t * @param {number=} y    coordinate (0 if undefined)\n\t */\n\tvar Point = function(x, y) {\n\t    /**\n\t     * @type {number}\n\t     * @expose\n\t     */\n\t    this.x = +x || 0;\n\t    /**\n\t     * @type {number}\n\t     * @expose\n\t     */\n\t    this.y = +y || 0;\n\t\n\t    // All extra fields added to Point are prefixed with _p2t_\n\t    // to avoid collisions if custom Point class is used.\n\t\n\t    /**\n\t     * The edges this point constitutes an upper ending point\n\t     * @private\n\t     * @type {Array.<Edge>}\n\t     */\n\t    this._p2t_edge_list = null;\n\t};\n\t\n\t/**\n\t * For pretty printing\n\t * @example\n\t *      \"p=\" + new poly2tri.Point(5,42)\n\t *      //  \"p=(5;42)\"\n\t * @returns {string} <code>\"(x;y)\"</code>\n\t */\n\tPoint.prototype.toString = function() {\n\t    return xy.toStringBase(this);\n\t};\n\t\n\t/**\n\t * JSON output, only coordinates\n\t * @example\n\t *      JSON.stringify(new poly2tri.Point(1,2))\n\t *      //  '{\"x\":1,\"y\":2}'\n\t */\n\tPoint.prototype.toJSON = function() {\n\t    return { x: this.x, y: this.y };\n\t};\n\t\n\t/**\n\t * Creates a copy of this Point object.\n\t * @return {Point} new cloned point\n\t */\n\tPoint.prototype.clone = function() {\n\t    return new Point(this.x, this.y);\n\t};\n\t\n\t/**\n\t * Set this Point instance to the origo. <code>(0; 0)</code>\n\t * @return {Point} this (for chaining)\n\t */\n\tPoint.prototype.set_zero = function() {\n\t    this.x = 0.0;\n\t    this.y = 0.0;\n\t    return this; // for chaining\n\t};\n\t\n\t/**\n\t * Set the coordinates of this instance.\n\t * @param {number} x   coordinate\n\t * @param {number} y   coordinate\n\t * @return {Point} this (for chaining)\n\t */\n\tPoint.prototype.set = function(x, y) {\n\t    this.x = +x || 0;\n\t    this.y = +y || 0;\n\t    return this; // for chaining\n\t};\n\t\n\t/**\n\t * Negate this Point instance. (component-wise)\n\t * @return {Point} this (for chaining)\n\t */\n\tPoint.prototype.negate = function() {\n\t    this.x = -this.x;\n\t    this.y = -this.y;\n\t    return this; // for chaining\n\t};\n\t\n\t/**\n\t * Add another Point object to this instance. (component-wise)\n\t * @param {!Point} n - Point object.\n\t * @return {Point} this (for chaining)\n\t */\n\tPoint.prototype.add = function(n) {\n\t    this.x += n.x;\n\t    this.y += n.y;\n\t    return this; // for chaining\n\t};\n\t\n\t/**\n\t * Subtract this Point instance with another point given. (component-wise)\n\t * @param {!Point} n - Point object.\n\t * @return {Point} this (for chaining)\n\t */\n\tPoint.prototype.sub = function(n) {\n\t    this.x -= n.x;\n\t    this.y -= n.y;\n\t    return this; // for chaining\n\t};\n\t\n\t/**\n\t * Multiply this Point instance by a scalar. (component-wise)\n\t * @param {number} s   scalar.\n\t * @return {Point} this (for chaining)\n\t */\n\tPoint.prototype.mul = function(s) {\n\t    this.x *= s;\n\t    this.y *= s;\n\t    return this; // for chaining\n\t};\n\t\n\t/**\n\t * Return the distance of this Point instance from the origo.\n\t * @return {number} distance\n\t */\n\tPoint.prototype.length = function() {\n\t    return Math.sqrt(this.x * this.x + this.y * this.y);\n\t};\n\t\n\t/**\n\t * Normalize this Point instance (as a vector).\n\t * @return {number} The original distance of this instance from the origo.\n\t */\n\tPoint.prototype.normalize = function() {\n\t    var len = this.length();\n\t    this.x /= len;\n\t    this.y /= len;\n\t    return len;\n\t};\n\t\n\t/**\n\t * Test this Point object with another for equality.\n\t * @param {!XY} p - any \"Point like\" object with {x,y}\n\t * @return {boolean} <code>true</code> if same x and y coordinates, <code>false</code> otherwise.\n\t */\n\tPoint.prototype.equals = function(p) {\n\t    return this.x === p.x && this.y === p.y;\n\t};\n\t\n\t\n\t// -----------------------------------------------------Point (\"static\" methods)\n\t\n\t/**\n\t * Negate a point component-wise and return the result as a new Point object.\n\t * @param {!XY} p - any \"Point like\" object with {x,y}\n\t * @return {Point} the resulting Point object.\n\t */\n\tPoint.negate = function(p) {\n\t    return new Point(-p.x, -p.y);\n\t};\n\t\n\t/**\n\t * Add two points component-wise and return the result as a new Point object.\n\t * @param {!XY} a - any \"Point like\" object with {x,y}\n\t * @param {!XY} b - any \"Point like\" object with {x,y}\n\t * @return {Point} the resulting Point object.\n\t */\n\tPoint.add = function(a, b) {\n\t    return new Point(a.x + b.x, a.y + b.y);\n\t};\n\t\n\t/**\n\t * Subtract two points component-wise and return the result as a new Point object.\n\t * @param {!XY} a - any \"Point like\" object with {x,y}\n\t * @param {!XY} b - any \"Point like\" object with {x,y}\n\t * @return {Point} the resulting Point object.\n\t */\n\tPoint.sub = function(a, b) {\n\t    return new Point(a.x - b.x, a.y - b.y);\n\t};\n\t\n\t/**\n\t * Multiply a point by a scalar and return the result as a new Point object.\n\t * @param {number} s - the scalar\n\t * @param {!XY} p - any \"Point like\" object with {x,y}\n\t * @return {Point} the resulting Point object.\n\t */\n\tPoint.mul = function(s, p) {\n\t    return new Point(s * p.x, s * p.y);\n\t};\n\t\n\t/**\n\t * Perform the cross product on either two points (this produces a scalar)\n\t * or a point and a scalar (this produces a point).\n\t * This function requires two parameters, either may be a Point object or a\n\t * number.\n\t * @param  {XY|number} a - Point object or scalar.\n\t * @param  {XY|number} b - Point object or scalar.\n\t * @return {Point|number} a Point object or a number, depending on the parameters.\n\t */\n\tPoint.cross = function(a, b) {\n\t    if (typeof(a) === 'number') {\n\t        if (typeof(b) === 'number') {\n\t            return a * b;\n\t        } else {\n\t            return new Point(-a * b.y, a * b.x);\n\t        }\n\t    } else {\n\t        if (typeof(b) === 'number') {\n\t            return new Point(b * a.y, -b * a.x);\n\t        } else {\n\t            return a.x * b.y - a.y * b.x;\n\t        }\n\t    }\n\t};\n\t\n\t\n\t// -----------------------------------------------------------------\"Point-Like\"\n\t/*\n\t * The following functions operate on \"Point\" or any \"Point like\" object \n\t * with {x,y} (duck typing).\n\t */\n\t\n\tPoint.toString = xy.toString;\n\tPoint.compare = xy.compare;\n\tPoint.cmp = xy.compare; // backward compatibility\n\tPoint.equals = xy.equals;\n\t\n\t/**\n\t * Peform the dot product on two vectors.\n\t * @public\n\t * @param {!XY} a - any \"Point like\" object with {x,y}\n\t * @param {!XY} b - any \"Point like\" object with {x,y}\n\t * @return {number} The dot product\n\t */\n\tPoint.dot = function(a, b) {\n\t    return a.x * b.x + a.y * b.y;\n\t};\n\t\n\t\n\t// ---------------------------------------------------------Exports (public API)\n\t\n\tmodule.exports = Point;\n\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/*\n\t * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors\n\t * http://code.google.com/p/poly2tri/\n\t * \n\t * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors\n\t * https://github.com/r3mi/poly2tri.js\n\t * \n\t * All rights reserved.\n\t * \n\t * Distributed under the 3-clause BSD License, see LICENSE.txt\n\t */\n\t\n\t/* jshint latedef:nofunc, maxcomplexity:9 */\n\t\n\t\"use strict\";\n\t\n\t/**\n\t * This 'Sweep' module is present in order to keep this JavaScript version\n\t * as close as possible to the reference C++ version, even though almost all\n\t * functions could be declared as methods on the {@linkcode module:sweepcontext~SweepContext} object.\n\t * @module\n\t * @private\n\t */\n\t\n\t/*\n\t * Note\n\t * ====\n\t * the structure of this JavaScript version of poly2tri intentionally follows\n\t * as closely as possible the structure of the reference C++ version, to make it \n\t * easier to keep the 2 versions in sync.\n\t */\n\t\n\tvar assert = __webpack_require__(8);\n\tvar PointError = __webpack_require__(3);\n\tvar Triangle = __webpack_require__(4);\n\tvar Node = __webpack_require__(2).Node;\n\t\n\t\n\t// ------------------------------------------------------------------------utils\n\t\n\tvar utils = __webpack_require__(12);\n\t\n\t/** @const */\n\tvar EPSILON = utils.EPSILON;\n\t\n\t/** @const */\n\tvar Orientation = utils.Orientation;\n\t/** @const */\n\tvar orient2d = utils.orient2d;\n\t/** @const */\n\tvar inScanArea = utils.inScanArea;\n\t/** @const */\n\tvar isAngleObtuse = utils.isAngleObtuse;\n\t\n\t\n\t// ------------------------------------------------------------------------Sweep\n\t\n\t/**\n\t * Triangulate the polygon with holes and Steiner points.\n\t * Do this AFTER you've added the polyline, holes, and Steiner points\n\t * @private\n\t * @param {!SweepContext} tcx - SweepContext object\n\t */\n\tfunction triangulate(tcx) {\n\t    tcx.initTriangulation();\n\t    tcx.createAdvancingFront();\n\t    // Sweep points; build mesh\n\t    sweepPoints(tcx);\n\t    // Clean up\n\t    finalizationPolygon(tcx);\n\t}\n\t\n\t/**\n\t * Start sweeping the Y-sorted point set from bottom to top\n\t * @param {!SweepContext} tcx - SweepContext object\n\t */\n\tfunction sweepPoints(tcx) {\n\t    var i, len = tcx.pointCount();\n\t    for (i = 1; i < len; ++i) {\n\t        var point = tcx.getPoint(i);\n\t        var node = pointEvent(tcx, point);\n\t        var edges = point._p2t_edge_list;\n\t        for (var j = 0; edges && j < edges.length; ++j) {\n\t            edgeEventByEdge(tcx, edges[j], node);\n\t        }\n\t    }\n\t}\n\t\n\t/**\n\t * @param {!SweepContext} tcx - SweepContext object\n\t */\n\tfunction finalizationPolygon(tcx) {\n\t    // Get an Internal triangle to start with\n\t    var t = tcx.front().head().next.triangle;\n\t    var p = tcx.front().head().next.point;\n\t    while (!t.getConstrainedEdgeCW(p)) {\n\t        t = t.neighborCCW(p);\n\t    }\n\t\n\t    // Collect interior triangles constrained by edges\n\t    tcx.meshClean(t);\n\t}\n\t\n\t/**\n\t * Find closes node to the left of the new point and\n\t * create a new triangle. If needed new holes and basins\n\t * will be filled to.\n\t * @param {!SweepContext} tcx - SweepContext object\n\t * @param {!XY} point   Point\n\t */\n\tfunction pointEvent(tcx, point) {\n\t    var node = tcx.locateNode(point);\n\t    var new_node = newFrontTriangle(tcx, point, node);\n\t\n\t    // Only need to check +epsilon since point never have smaller\n\t    // x value than node due to how we fetch nodes from the front\n\t    if (point.x <= node.point.x + (EPSILON)) {\n\t        fill(tcx, node);\n\t    }\n\t\n\t    //tcx.AddNode(new_node);\n\t\n\t    fillAdvancingFront(tcx, new_node);\n\t    return new_node;\n\t}\n\t\n\tfunction edgeEventByEdge(tcx, edge, node) {\n\t    tcx.edge_event.constrained_edge = edge;\n\t    tcx.edge_event.right = (edge.p.x > edge.q.x);\n\t\n\t    if (isEdgeSideOfTriangle(node.triangle, edge.p, edge.q)) {\n\t        return;\n\t    }\n\t\n\t    // For now we will do all needed filling\n\t    // TODO: integrate with flip process might give some better performance\n\t    //       but for now this avoid the issue with cases that needs both flips and fills\n\t    fillEdgeEvent(tcx, edge, node);\n\t    edgeEventByPoints(tcx, edge.p, edge.q, node.triangle, edge.q);\n\t}\n\t\n\tfunction edgeEventByPoints(tcx, ep, eq, triangle, point) {\n\t    if (isEdgeSideOfTriangle(triangle, ep, eq)) {\n\t        return;\n\t    }\n\t\n\t    var p1 = triangle.pointCCW(point);\n\t    var o1 = orient2d(eq, p1, ep);\n\t    if (o1 === Orientation.COLLINEAR) {\n\t        // TODO integrate here changes from C++ version\n\t        // (C++ repo revision 09880a869095 dated March 8, 2011)\n\t        throw new PointError('poly2tri EdgeEvent: Collinear not supported!', [eq, p1, ep]);\n\t    }\n\t\n\t    var p2 = triangle.pointCW(point);\n\t    var o2 = orient2d(eq, p2, ep);\n\t    if (o2 === Orientation.COLLINEAR) {\n\t        // TODO integrate here changes from C++ version\n\t        // (C++ repo revision 09880a869095 dated March 8, 2011)\n\t        throw new PointError('poly2tri EdgeEvent: Collinear not supported!', [eq, p2, ep]);\n\t    }\n\t\n\t    if (o1 === o2) {\n\t        // Need to decide if we are rotating CW or CCW to get to a triangle\n\t        // that will cross edge\n\t        if (o1 === Orientation.CW) {\n\t            triangle = triangle.neighborCCW(point);\n\t        } else {\n\t            triangle = triangle.neighborCW(point);\n\t        }\n\t        edgeEventByPoints(tcx, ep, eq, triangle, point);\n\t    } else {\n\t        // This triangle crosses constraint so lets flippin start!\n\t        flipEdgeEvent(tcx, ep, eq, triangle, point);\n\t    }\n\t}\n\t\n\tfunction isEdgeSideOfTriangle(triangle, ep, eq) {\n\t    var index = triangle.edgeIndex(ep, eq);\n\t    if (index !== -1) {\n\t        triangle.markConstrainedEdgeByIndex(index);\n\t        var t = triangle.getNeighbor(index);\n\t        if (t) {\n\t            t.markConstrainedEdgeByPoints(ep, eq);\n\t        }\n\t        return true;\n\t    }\n\t    return false;\n\t}\n\t\n\t/**\n\t * Creates a new front triangle and legalize it\n\t * @param {!SweepContext} tcx - SweepContext object\n\t */\n\tfunction newFrontTriangle(tcx, point, node) {\n\t    var triangle = new Triangle(point, node.point, node.next.point);\n\t\n\t    triangle.markNeighbor(node.triangle);\n\t    tcx.addToMap(triangle);\n\t\n\t    var new_node = new Node(point);\n\t    new_node.next = node.next;\n\t    new_node.prev = node;\n\t    node.next.prev = new_node;\n\t    node.next = new_node;\n\t\n\t    if (!legalize(tcx, triangle)) {\n\t        tcx.mapTriangleToNodes(triangle);\n\t    }\n\t\n\t    return new_node;\n\t}\n\t\n\t/**\n\t * Adds a triangle to the advancing front to fill a hole.\n\t * @param {!SweepContext} tcx - SweepContext object\n\t * @param node - middle node, that is the bottom of the hole\n\t */\n\tfunction fill(tcx, node) {\n\t    var triangle = new Triangle(node.prev.point, node.point, node.next.point);\n\t\n\t    // TODO: should copy the constrained_edge value from neighbor triangles\n\t    //       for now constrained_edge values are copied during the legalize\n\t    triangle.markNeighbor(node.prev.triangle);\n\t    triangle.markNeighbor(node.triangle);\n\t\n\t    tcx.addToMap(triangle);\n\t\n\t    // Update the advancing front\n\t    node.prev.next = node.next;\n\t    node.next.prev = node.prev;\n\t\n\t\n\t    // If it was legalized the triangle has already been mapped\n\t    if (!legalize(tcx, triangle)) {\n\t        tcx.mapTriangleToNodes(triangle);\n\t    }\n\t\n\t    //tcx.removeNode(node);\n\t}\n\t\n\t/**\n\t * Fills holes in the Advancing Front\n\t * @param {!SweepContext} tcx - SweepContext object\n\t */\n\tfunction fillAdvancingFront(tcx, n) {\n\t    // Fill right holes\n\t    var node = n.next;\n\t    while (node.next) {\n\t        // TODO integrate here changes from C++ version\n\t        // (C++ repo revision acf81f1f1764 dated April 7, 2012)\n\t        if (isAngleObtuse(node.point, node.next.point, node.prev.point)) {\n\t            break;\n\t        }\n\t        fill(tcx, node);\n\t        node = node.next;\n\t    }\n\t\n\t    // Fill left holes\n\t    node = n.prev;\n\t    while (node.prev) {\n\t        // TODO integrate here changes from C++ version\n\t        // (C++ repo revision acf81f1f1764 dated April 7, 2012)\n\t        if (isAngleObtuse(node.point, node.next.point, node.prev.point)) {\n\t            break;\n\t        }\n\t        fill(tcx, node);\n\t        node = node.prev;\n\t    }\n\t\n\t    // Fill right basins\n\t    if (n.next && n.next.next) {\n\t        if (isBasinAngleRight(n)) {\n\t            fillBasin(tcx, n);\n\t        }\n\t    }\n\t}\n\t\n\t/**\n\t * The basin angle is decided against the horizontal line [1,0].\n\t * @param {Node} node\n\t * @return {boolean} true if angle < 3*/4\n\t */\n\tfunction isBasinAngleRight(node) {\n\t    var ax = node.point.x - node.next.next.point.x;\n\t    var ay = node.point.y - node.next.next.point.y;\n\t    assert(ay >= 0, \"unordered y\");\n\t    return (ax >= 0 || Math.abs(ax) < ay);\n\t}\n\t\n\t/**\n\t * Returns true if triangle was legalized\n\t * @param {!SweepContext} tcx - SweepContext object\n\t * @return {boolean}\n\t */\n\tfunction legalize(tcx, t) {\n\t    // To legalize a triangle we start by finding if any of the three edges\n\t    // violate the Delaunay condition\n\t    for (var i = 0; i < 3; ++i) {\n\t        if (t.delaunay_edge[i]) {\n\t            continue;\n\t        }\n\t        var ot = t.getNeighbor(i);\n\t        if (ot) {\n\t            var p = t.getPoint(i);\n\t            var op = ot.oppositePoint(t, p);\n\t            var oi = ot.index(op);\n\t\n\t            // If this is a Constrained Edge or a Delaunay Edge(only during recursive legalization)\n\t            // then we should not try to legalize\n\t            if (ot.constrained_edge[oi] || ot.delaunay_edge[oi]) {\n\t                t.constrained_edge[i] = ot.constrained_edge[oi];\n\t                continue;\n\t            }\n\t\n\t            var inside = inCircle(p, t.pointCCW(p), t.pointCW(p), op);\n\t            if (inside) {\n\t                // Lets mark this shared edge as Delaunay\n\t                t.delaunay_edge[i] = true;\n\t                ot.delaunay_edge[oi] = true;\n\t\n\t                // Lets rotate shared edge one vertex CW to legalize it\n\t                rotateTrianglePair(t, p, ot, op);\n\t\n\t                // We now got one valid Delaunay Edge shared by two triangles\n\t                // This gives us 4 new edges to check for Delaunay\n\t\n\t                // Make sure that triangle to node mapping is done only one time for a specific triangle\n\t                var not_legalized = !legalize(tcx, t);\n\t                if (not_legalized) {\n\t                    tcx.mapTriangleToNodes(t);\n\t                }\n\t\n\t                not_legalized = !legalize(tcx, ot);\n\t                if (not_legalized) {\n\t                    tcx.mapTriangleToNodes(ot);\n\t                }\n\t                // Reset the Delaunay edges, since they only are valid Delaunay edges\n\t                // until we add a new triangle or point.\n\t                // XXX: need to think about this. Can these edges be tried after we\n\t                //      return to previous recursive level?\n\t                t.delaunay_edge[i] = false;\n\t                ot.delaunay_edge[oi] = false;\n\t\n\t                // If triangle have been legalized no need to check the other edges since\n\t                // the recursive legalization will handles those so we can end here.\n\t                return true;\n\t            }\n\t        }\n\t    }\n\t    return false;\n\t}\n\t\n\t/**\n\t * <b>Requirement</b>:<br>\n\t * 1. a,b and c form a triangle.<br>\n\t * 2. a and d is know to be on opposite side of bc<br>\n\t * <pre>\n\t *                a\n\t *                +\n\t *               / \\\n\t *              /   \\\n\t *            b/     \\c\n\t *            +-------+\n\t *           /    d    \\\n\t *          /           \\\n\t * </pre>\n\t * <b>Fact</b>: d has to be in area B to have a chance to be inside the circle formed by\n\t *  a,b and c<br>\n\t *  d is outside B if orient2d(a,b,d) or orient2d(c,a,d) is CW<br>\n\t *  This preknowledge gives us a way to optimize the incircle test\n\t * @param pa - triangle point, opposite d\n\t * @param pb - triangle point\n\t * @param pc - triangle point\n\t * @param pd - point opposite a\n\t * @return {boolean} true if d is inside circle, false if on circle edge\n\t */\n\tfunction inCircle(pa, pb, pc, pd) {\n\t    var adx = pa.x - pd.x;\n\t    var ady = pa.y - pd.y;\n\t    var bdx = pb.x - pd.x;\n\t    var bdy = pb.y - pd.y;\n\t\n\t    var adxbdy = adx * bdy;\n\t    var bdxady = bdx * ady;\n\t    var oabd = adxbdy - bdxady;\n\t    if (oabd <= 0) {\n\t        return false;\n\t    }\n\t\n\t    var cdx = pc.x - pd.x;\n\t    var cdy = pc.y - pd.y;\n\t\n\t    var cdxady = cdx * ady;\n\t    var adxcdy = adx * cdy;\n\t    var ocad = cdxady - adxcdy;\n\t    if (ocad <= 0) {\n\t        return false;\n\t    }\n\t\n\t    var bdxcdy = bdx * cdy;\n\t    var cdxbdy = cdx * bdy;\n\t\n\t    var alift = adx * adx + ady * ady;\n\t    var blift = bdx * bdx + bdy * bdy;\n\t    var clift = cdx * cdx + cdy * cdy;\n\t\n\t    var det = alift * (bdxcdy - cdxbdy) + blift * ocad + clift * oabd;\n\t    return det > 0;\n\t}\n\t\n\t/**\n\t * Rotates a triangle pair one vertex CW\n\t *<pre>\n\t *       n2                    n2\n\t *  P +-----+             P +-----+\n\t *    | t  /|               |\\  t |\n\t *    |   / |               | \\   |\n\t *  n1|  /  |n3           n1|  \\  |n3\n\t *    | /   |    after CW   |   \\ |\n\t *    |/ oT |               | oT \\|\n\t *    +-----+ oP            +-----+\n\t *       n4                    n4\n\t * </pre>\n\t */\n\tfunction rotateTrianglePair(t, p, ot, op) {\n\t    var n1, n2, n3, n4;\n\t    n1 = t.neighborCCW(p);\n\t    n2 = t.neighborCW(p);\n\t    n3 = ot.neighborCCW(op);\n\t    n4 = ot.neighborCW(op);\n\t\n\t    var ce1, ce2, ce3, ce4;\n\t    ce1 = t.getConstrainedEdgeCCW(p);\n\t    ce2 = t.getConstrainedEdgeCW(p);\n\t    ce3 = ot.getConstrainedEdgeCCW(op);\n\t    ce4 = ot.getConstrainedEdgeCW(op);\n\t\n\t    var de1, de2, de3, de4;\n\t    de1 = t.getDelaunayEdgeCCW(p);\n\t    de2 = t.getDelaunayEdgeCW(p);\n\t    de3 = ot.getDelaunayEdgeCCW(op);\n\t    de4 = ot.getDelaunayEdgeCW(op);\n\t\n\t    t.legalize(p, op);\n\t    ot.legalize(op, p);\n\t\n\t    // Remap delaunay_edge\n\t    ot.setDelaunayEdgeCCW(p, de1);\n\t    t.setDelaunayEdgeCW(p, de2);\n\t    t.setDelaunayEdgeCCW(op, de3);\n\t    ot.setDelaunayEdgeCW(op, de4);\n\t\n\t    // Remap constrained_edge\n\t    ot.setConstrainedEdgeCCW(p, ce1);\n\t    t.setConstrainedEdgeCW(p, ce2);\n\t    t.setConstrainedEdgeCCW(op, ce3);\n\t    ot.setConstrainedEdgeCW(op, ce4);\n\t\n\t    // Remap neighbors\n\t    // XXX: might optimize the markNeighbor by keeping track of\n\t    //      what side should be assigned to what neighbor after the\n\t    //      rotation. Now mark neighbor does lots of testing to find\n\t    //      the right side.\n\t    t.clearNeighbors();\n\t    ot.clearNeighbors();\n\t    if (n1) {\n\t        ot.markNeighbor(n1);\n\t    }\n\t    if (n2) {\n\t        t.markNeighbor(n2);\n\t    }\n\t    if (n3) {\n\t        t.markNeighbor(n3);\n\t    }\n\t    if (n4) {\n\t        ot.markNeighbor(n4);\n\t    }\n\t    t.markNeighbor(ot);\n\t}\n\t\n\t/**\n\t * Fills a basin that has formed on the Advancing Front to the right\n\t * of given node.<br>\n\t * First we decide a left,bottom and right node that forms the\n\t * boundaries of the basin. Then we do a reqursive fill.\n\t *\n\t * @param {!SweepContext} tcx - SweepContext object\n\t * @param node - starting node, this or next node will be left node\n\t */\n\tfunction fillBasin(tcx, node) {\n\t    if (orient2d(node.point, node.next.point, node.next.next.point) === Orientation.CCW) {\n\t        tcx.basin.left_node = node.next.next;\n\t    } else {\n\t        tcx.basin.left_node = node.next;\n\t    }\n\t\n\t    // Find the bottom and right node\n\t    tcx.basin.bottom_node = tcx.basin.left_node;\n\t    while (tcx.basin.bottom_node.next && tcx.basin.bottom_node.point.y >= tcx.basin.bottom_node.next.point.y) {\n\t        tcx.basin.bottom_node = tcx.basin.bottom_node.next;\n\t    }\n\t    if (tcx.basin.bottom_node === tcx.basin.left_node) {\n\t        // No valid basin\n\t        return;\n\t    }\n\t\n\t    tcx.basin.right_node = tcx.basin.bottom_node;\n\t    while (tcx.basin.right_node.next && tcx.basin.right_node.point.y < tcx.basin.right_node.next.point.y) {\n\t        tcx.basin.right_node = tcx.basin.right_node.next;\n\t    }\n\t    if (tcx.basin.right_node === tcx.basin.bottom_node) {\n\t        // No valid basins\n\t        return;\n\t    }\n\t\n\t    tcx.basin.width = tcx.basin.right_node.point.x - tcx.basin.left_node.point.x;\n\t    tcx.basin.left_highest = tcx.basin.left_node.point.y > tcx.basin.right_node.point.y;\n\t\n\t    fillBasinReq(tcx, tcx.basin.bottom_node);\n\t}\n\t\n\t/**\n\t * Recursive algorithm to fill a Basin with triangles\n\t *\n\t * @param {!SweepContext} tcx - SweepContext object\n\t * @param node - bottom_node\n\t */\n\tfunction fillBasinReq(tcx, node) {\n\t    // if shallow stop filling\n\t    if (isShallow(tcx, node)) {\n\t        return;\n\t    }\n\t\n\t    fill(tcx, node);\n\t\n\t    var o;\n\t    if (node.prev === tcx.basin.left_node && node.next === tcx.basin.right_node) {\n\t        return;\n\t    } else if (node.prev === tcx.basin.left_node) {\n\t        o = orient2d(node.point, node.next.point, node.next.next.point);\n\t        if (o === Orientation.CW) {\n\t            return;\n\t        }\n\t        node = node.next;\n\t    } else if (node.next === tcx.basin.right_node) {\n\t        o = orient2d(node.point, node.prev.point, node.prev.prev.point);\n\t        if (o === Orientation.CCW) {\n\t            return;\n\t        }\n\t        node = node.prev;\n\t    } else {\n\t        // Continue with the neighbor node with lowest Y value\n\t        if (node.prev.point.y < node.next.point.y) {\n\t            node = node.prev;\n\t        } else {\n\t            node = node.next;\n\t        }\n\t    }\n\t\n\t    fillBasinReq(tcx, node);\n\t}\n\t\n\tfunction isShallow(tcx, node) {\n\t    var height;\n\t    if (tcx.basin.left_highest) {\n\t        height = tcx.basin.left_node.point.y - node.point.y;\n\t    } else {\n\t        height = tcx.basin.right_node.point.y - node.point.y;\n\t    }\n\t\n\t    // if shallow stop filling\n\t    if (tcx.basin.width > height) {\n\t        return true;\n\t    }\n\t    return false;\n\t}\n\t\n\tfunction fillEdgeEvent(tcx, edge, node) {\n\t    if (tcx.edge_event.right) {\n\t        fillRightAboveEdgeEvent(tcx, edge, node);\n\t    } else {\n\t        fillLeftAboveEdgeEvent(tcx, edge, node);\n\t    }\n\t}\n\t\n\tfunction fillRightAboveEdgeEvent(tcx, edge, node) {\n\t    while (node.next.point.x < edge.p.x) {\n\t        // Check if next node is below the edge\n\t        if (orient2d(edge.q, node.next.point, edge.p) === Orientation.CCW) {\n\t            fillRightBelowEdgeEvent(tcx, edge, node);\n\t        } else {\n\t            node = node.next;\n\t        }\n\t    }\n\t}\n\t\n\tfunction fillRightBelowEdgeEvent(tcx, edge, node) {\n\t    if (node.point.x < edge.p.x) {\n\t        if (orient2d(node.point, node.next.point, node.next.next.point) === Orientation.CCW) {\n\t            // Concave\n\t            fillRightConcaveEdgeEvent(tcx, edge, node);\n\t        } else {\n\t            // Convex\n\t            fillRightConvexEdgeEvent(tcx, edge, node);\n\t            // Retry this one\n\t            fillRightBelowEdgeEvent(tcx, edge, node);\n\t        }\n\t    }\n\t}\n\t\n\tfunction fillRightConcaveEdgeEvent(tcx, edge, node) {\n\t    fill(tcx, node.next);\n\t    if (node.next.point !== edge.p) {\n\t        // Next above or below edge?\n\t        if (orient2d(edge.q, node.next.point, edge.p) === Orientation.CCW) {\n\t            // Below\n\t            if (orient2d(node.point, node.next.point, node.next.next.point) === Orientation.CCW) {\n\t                // Next is concave\n\t                fillRightConcaveEdgeEvent(tcx, edge, node);\n\t            } else {\n\t                // Next is convex\n\t                /* jshint noempty:false */\n\t            }\n\t        }\n\t    }\n\t}\n\t\n\tfunction fillRightConvexEdgeEvent(tcx, edge, node) {\n\t    // Next concave or convex?\n\t    if (orient2d(node.next.point, node.next.next.point, node.next.next.next.point) === Orientation.CCW) {\n\t        // Concave\n\t        fillRightConcaveEdgeEvent(tcx, edge, node.next);\n\t    } else {\n\t        // Convex\n\t        // Next above or below edge?\n\t        if (orient2d(edge.q, node.next.next.point, edge.p) === Orientation.CCW) {\n\t            // Below\n\t            fillRightConvexEdgeEvent(tcx, edge, node.next);\n\t        } else {\n\t            // Above\n\t            /* jshint noempty:false */\n\t        }\n\t    }\n\t}\n\t\n\tfunction fillLeftAboveEdgeEvent(tcx, edge, node) {\n\t    while (node.prev.point.x > edge.p.x) {\n\t        // Check if next node is below the edge\n\t        if (orient2d(edge.q, node.prev.point, edge.p) === Orientation.CW) {\n\t            fillLeftBelowEdgeEvent(tcx, edge, node);\n\t        } else {\n\t            node = node.prev;\n\t        }\n\t    }\n\t}\n\t\n\tfunction fillLeftBelowEdgeEvent(tcx, edge, node) {\n\t    if (node.point.x > edge.p.x) {\n\t        if (orient2d(node.point, node.prev.point, node.prev.prev.point) === Orientation.CW) {\n\t            // Concave\n\t            fillLeftConcaveEdgeEvent(tcx, edge, node);\n\t        } else {\n\t            // Convex\n\t            fillLeftConvexEdgeEvent(tcx, edge, node);\n\t            // Retry this one\n\t            fillLeftBelowEdgeEvent(tcx, edge, node);\n\t        }\n\t    }\n\t}\n\t\n\tfunction fillLeftConvexEdgeEvent(tcx, edge, node) {\n\t    // Next concave or convex?\n\t    if (orient2d(node.prev.point, node.prev.prev.point, node.prev.prev.prev.point) === Orientation.CW) {\n\t        // Concave\n\t        fillLeftConcaveEdgeEvent(tcx, edge, node.prev);\n\t    } else {\n\t        // Convex\n\t        // Next above or below edge?\n\t        if (orient2d(edge.q, node.prev.prev.point, edge.p) === Orientation.CW) {\n\t            // Below\n\t            fillLeftConvexEdgeEvent(tcx, edge, node.prev);\n\t        } else {\n\t            // Above\n\t            /* jshint noempty:false */\n\t        }\n\t    }\n\t}\n\t\n\tfunction fillLeftConcaveEdgeEvent(tcx, edge, node) {\n\t    fill(tcx, node.prev);\n\t    if (node.prev.point !== edge.p) {\n\t        // Next above or below edge?\n\t        if (orient2d(edge.q, node.prev.point, edge.p) === Orientation.CW) {\n\t            // Below\n\t            if (orient2d(node.point, node.prev.point, node.prev.prev.point) === Orientation.CW) {\n\t                // Next is concave\n\t                fillLeftConcaveEdgeEvent(tcx, edge, node);\n\t            } else {\n\t                // Next is convex\n\t                /* jshint noempty:false */\n\t            }\n\t        }\n\t    }\n\t}\n\t\n\tfunction flipEdgeEvent(tcx, ep, eq, t, p) {\n\t    var ot = t.neighborAcross(p);\n\t    assert(ot, \"FLIP failed due to missing triangle!\");\n\t\n\t    var op = ot.oppositePoint(t, p);\n\t\n\t    // Additional check from Java version (see issue #88)\n\t    if (t.getConstrainedEdgeAcross(p)) {\n\t        var index = t.index(p);\n\t        throw new PointError(\"poly2tri Intersecting Constraints\",\n\t                [p, op, t.getPoint((index + 1) % 3), t.getPoint((index + 2) % 3)]);\n\t    }\n\t\n\t    if (inScanArea(p, t.pointCCW(p), t.pointCW(p), op)) {\n\t        // Lets rotate shared edge one vertex CW\n\t        rotateTrianglePair(t, p, ot, op);\n\t        tcx.mapTriangleToNodes(t);\n\t        tcx.mapTriangleToNodes(ot);\n\t\n\t        // XXX: in the original C++ code for the next 2 lines, we are\n\t        // comparing point values (and not pointers). In this JavaScript\n\t        // code, we are comparing point references (pointers). This works\n\t        // because we can't have 2 different points with the same values.\n\t        // But to be really equivalent, we should use \"Point.equals\" here.\n\t        if (p === eq && op === ep) {\n\t            if (eq === tcx.edge_event.constrained_edge.q && ep === tcx.edge_event.constrained_edge.p) {\n\t                t.markConstrainedEdgeByPoints(ep, eq);\n\t                ot.markConstrainedEdgeByPoints(ep, eq);\n\t                legalize(tcx, t);\n\t                legalize(tcx, ot);\n\t            } else {\n\t                // XXX: I think one of the triangles should be legalized here?\n\t                /* jshint noempty:false */\n\t            }\n\t        } else {\n\t            var o = orient2d(eq, op, ep);\n\t            t = nextFlipTriangle(tcx, o, t, ot, p, op);\n\t            flipEdgeEvent(tcx, ep, eq, t, p);\n\t        }\n\t    } else {\n\t        var newP = nextFlipPoint(ep, eq, ot, op);\n\t        flipScanEdgeEvent(tcx, ep, eq, t, ot, newP);\n\t        edgeEventByPoints(tcx, ep, eq, t, p);\n\t    }\n\t}\n\t\n\t/**\n\t * After a flip we have two triangles and know that only one will still be\n\t * intersecting the edge. So decide which to contiune with and legalize the other\n\t *\n\t * @param {!SweepContext} tcx - SweepContext object\n\t * @param o - should be the result of an orient2d( eq, op, ep )\n\t * @param t - triangle 1\n\t * @param ot - triangle 2\n\t * @param p - a point shared by both triangles\n\t * @param op - another point shared by both triangles\n\t * @return returns the triangle still intersecting the edge\n\t */\n\tfunction nextFlipTriangle(tcx, o, t, ot, p, op) {\n\t    var edge_index;\n\t    if (o === Orientation.CCW) {\n\t        // ot is not crossing edge after flip\n\t        edge_index = ot.edgeIndex(p, op);\n\t        ot.delaunay_edge[edge_index] = true;\n\t        legalize(tcx, ot);\n\t        ot.clearDelaunayEdges();\n\t        return t;\n\t    }\n\t\n\t    // t is not crossing edge after flip\n\t    edge_index = t.edgeIndex(p, op);\n\t\n\t    t.delaunay_edge[edge_index] = true;\n\t    legalize(tcx, t);\n\t    t.clearDelaunayEdges();\n\t    return ot;\n\t}\n\t\n\t/**\n\t * When we need to traverse from one triangle to the next we need\n\t * the point in current triangle that is the opposite point to the next\n\t * triangle.\n\t */\n\tfunction nextFlipPoint(ep, eq, ot, op) {\n\t    var o2d = orient2d(eq, op, ep);\n\t    if (o2d === Orientation.CW) {\n\t        // Right\n\t        return ot.pointCCW(op);\n\t    } else if (o2d === Orientation.CCW) {\n\t        // Left\n\t        return ot.pointCW(op);\n\t    } else {\n\t        throw new PointError(\"poly2tri [Unsupported] nextFlipPoint: opposing point on constrained edge!\", [eq, op, ep]);\n\t    }\n\t}\n\t\n\t/**\n\t * Scan part of the FlipScan algorithm<br>\n\t * When a triangle pair isn't flippable we will scan for the next\n\t * point that is inside the flip triangle scan area. When found\n\t * we generate a new flipEdgeEvent\n\t *\n\t * @param {!SweepContext} tcx - SweepContext object\n\t * @param ep - last point on the edge we are traversing\n\t * @param eq - first point on the edge we are traversing\n\t * @param {!Triangle} flip_triangle - the current triangle sharing the point eq with edge\n\t * @param t\n\t * @param p\n\t */\n\tfunction flipScanEdgeEvent(tcx, ep, eq, flip_triangle, t, p) {\n\t    var ot = t.neighborAcross(p);\n\t    assert(ot, \"FLIP failed due to missing triangle\");\n\t\n\t    var op = ot.oppositePoint(t, p);\n\t\n\t    if (inScanArea(eq, flip_triangle.pointCCW(eq), flip_triangle.pointCW(eq), op)) {\n\t        // flip with new edge op.eq\n\t        flipEdgeEvent(tcx, eq, op, ot, op);\n\t    } else {\n\t        var newP = nextFlipPoint(ep, eq, ot, op);\n\t        flipScanEdgeEvent(tcx, ep, eq, flip_triangle, ot, newP);\n\t    }\n\t}\n\t\n\t\n\t// ----------------------------------------------------------------------Exports\n\t\n\texports.triangulate = triangulate;\n\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/*\n\t * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors\n\t * http://code.google.com/p/poly2tri/\n\t * \n\t * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors\n\t * https://github.com/r3mi/poly2tri.js\n\t * \n\t * All rights reserved.\n\t * \n\t * Distributed under the 3-clause BSD License, see LICENSE.txt\n\t */\n\t\n\t/* jshint maxcomplexity:6 */\n\t\n\t\"use strict\";\n\t\n\t\n\t/*\n\t * Note\n\t * ====\n\t * the structure of this JavaScript version of poly2tri intentionally follows\n\t * as closely as possible the structure of the reference C++ version, to make it \n\t * easier to keep the 2 versions in sync.\n\t */\n\t\n\tvar PointError = __webpack_require__(3);\n\tvar Point = __webpack_require__(9);\n\tvar Triangle = __webpack_require__(4);\n\tvar sweep = __webpack_require__(10);\n\tvar AdvancingFront = __webpack_require__(2);\n\tvar Node = AdvancingFront.Node;\n\t\n\t\n\t// ------------------------------------------------------------------------utils\n\t\n\t/**\n\t * Initial triangle factor, seed triangle will extend 30% of\n\t * PointSet width to both left and right.\n\t * @private\n\t * @const\n\t */\n\tvar kAlpha = 0.3;\n\t\n\t\n\t// -------------------------------------------------------------------------Edge\n\t/**\n\t * Represents a simple polygon's edge\n\t * @constructor\n\t * @struct\n\t * @private\n\t * @param {Point} p1\n\t * @param {Point} p2\n\t * @throw {PointError} if p1 is same as p2\n\t */\n\tvar Edge = function(p1, p2) {\n\t    this.p = p1;\n\t    this.q = p2;\n\t\n\t    if (p1.y > p2.y) {\n\t        this.q = p1;\n\t        this.p = p2;\n\t    } else if (p1.y === p2.y) {\n\t        if (p1.x > p2.x) {\n\t            this.q = p1;\n\t            this.p = p2;\n\t        } else if (p1.x === p2.x) {\n\t            throw new PointError('poly2tri Invalid Edge constructor: repeated points!', [p1]);\n\t        }\n\t    }\n\t\n\t    if (!this.q._p2t_edge_list) {\n\t        this.q._p2t_edge_list = [];\n\t    }\n\t    this.q._p2t_edge_list.push(this);\n\t};\n\t\n\t\n\t// ------------------------------------------------------------------------Basin\n\t/**\n\t * @constructor\n\t * @struct\n\t * @private\n\t */\n\tvar Basin = function() {\n\t    /** @type {Node} */\n\t    this.left_node = null;\n\t    /** @type {Node} */\n\t    this.bottom_node = null;\n\t    /** @type {Node} */\n\t    this.right_node = null;\n\t    /** @type {number} */\n\t    this.width = 0.0;\n\t    /** @type {boolean} */\n\t    this.left_highest = false;\n\t};\n\t\n\tBasin.prototype.clear = function() {\n\t    this.left_node = null;\n\t    this.bottom_node = null;\n\t    this.right_node = null;\n\t    this.width = 0.0;\n\t    this.left_highest = false;\n\t};\n\t\n\t// --------------------------------------------------------------------EdgeEvent\n\t/**\n\t * @constructor\n\t * @struct\n\t * @private\n\t */\n\tvar EdgeEvent = function() {\n\t    /** @type {Edge} */\n\t    this.constrained_edge = null;\n\t    /** @type {boolean} */\n\t    this.right = false;\n\t};\n\t\n\t// ----------------------------------------------------SweepContext (public API)\n\t/**\n\t * SweepContext constructor option\n\t * @typedef {Object} SweepContextOptions\n\t * @property {boolean=} cloneArrays - if <code>true</code>, do a shallow copy of the Array parameters\n\t *                  (contour, holes). Points inside arrays are never copied.\n\t *                  Default is <code>false</code> : keep a reference to the array arguments,\n\t *                  who will be modified in place.\n\t */\n\t/**\n\t * Constructor for the triangulation context.\n\t * It accepts a simple polyline (with non repeating points), \n\t * which defines the constrained edges.\n\t *\n\t * @example\n\t *          var contour = [\n\t *              new poly2tri.Point(100, 100),\n\t *              new poly2tri.Point(100, 300),\n\t *              new poly2tri.Point(300, 300),\n\t *              new poly2tri.Point(300, 100)\n\t *          ];\n\t *          var swctx = new poly2tri.SweepContext(contour, {cloneArrays: true});\n\t * @example\n\t *          var contour = [{x:100, y:100}, {x:100, y:300}, {x:300, y:300}, {x:300, y:100}];\n\t *          var swctx = new poly2tri.SweepContext(contour, {cloneArrays: true});\n\t * @constructor\n\t * @public\n\t * @struct\n\t * @param {Array.<XY>} contour - array of point objects. The points can be either {@linkcode Point} instances,\n\t *          or any \"Point like\" custom class with <code>{x, y}</code> attributes.\n\t * @param {SweepContextOptions=} options - constructor options\n\t */\n\tvar SweepContext = function(contour, options) {\n\t    options = options || {};\n\t    this.triangles_ = [];\n\t    this.map_ = [];\n\t    this.points_ = (options.cloneArrays ? contour.slice(0) : contour);\n\t    this.edge_list = [];\n\t\n\t    // Bounding box of all points. Computed at the start of the triangulation, \n\t    // it is stored in case it is needed by the caller.\n\t    this.pmin_ = this.pmax_ = null;\n\t\n\t    /**\n\t     * Advancing front\n\t     * @private\n\t     * @type {AdvancingFront}\n\t     */\n\t    this.front_ = null;\n\t\n\t    /**\n\t     * head point used with advancing front\n\t     * @private\n\t     * @type {Point}\n\t     */\n\t    this.head_ = null;\n\t\n\t    /**\n\t     * tail point used with advancing front\n\t     * @private\n\t     * @type {Point}\n\t     */\n\t    this.tail_ = null;\n\t\n\t    /**\n\t     * @private\n\t     * @type {Node}\n\t     */\n\t    this.af_head_ = null;\n\t    /**\n\t     * @private\n\t     * @type {Node}\n\t     */\n\t    this.af_middle_ = null;\n\t    /**\n\t     * @private\n\t     * @type {Node}\n\t     */\n\t    this.af_tail_ = null;\n\t\n\t    this.basin = new Basin();\n\t    this.edge_event = new EdgeEvent();\n\t\n\t    this.initEdges(this.points_);\n\t};\n\t\n\t\n\t/**\n\t * Add a hole to the constraints\n\t * @example\n\t *      var swctx = new poly2tri.SweepContext(contour);\n\t *      var hole = [\n\t *          new poly2tri.Point(200, 200),\n\t *          new poly2tri.Point(200, 250),\n\t *          new poly2tri.Point(250, 250)\n\t *      ];\n\t *      swctx.addHole(hole);\n\t * @example\n\t *      var swctx = new poly2tri.SweepContext(contour);\n\t *      swctx.addHole([{x:200, y:200}, {x:200, y:250}, {x:250, y:250}]);\n\t * @public\n\t * @param {Array.<XY>} polyline - array of \"Point like\" objects with {x,y}\n\t */\n\tSweepContext.prototype.addHole = function(polyline) {\n\t    this.initEdges(polyline);\n\t    var i, len = polyline.length;\n\t    for (i = 0; i < len; i++) {\n\t        this.points_.push(polyline[i]);\n\t    }\n\t    return this; // for chaining\n\t};\n\t\n\t/**\n\t * For backward compatibility\n\t * @function\n\t * @deprecated use {@linkcode SweepContext#addHole} instead\n\t */\n\tSweepContext.prototype.AddHole = SweepContext.prototype.addHole;\n\t\n\t\n\t/**\n\t * Add several holes to the constraints\n\t * @example\n\t *      var swctx = new poly2tri.SweepContext(contour);\n\t *      var holes = [\n\t *          [ new poly2tri.Point(200, 200), new poly2tri.Point(200, 250), new poly2tri.Point(250, 250) ],\n\t *          [ new poly2tri.Point(300, 300), new poly2tri.Point(300, 350), new poly2tri.Point(350, 350) ]\n\t *      ];\n\t *      swctx.addHoles(holes);\n\t * @example\n\t *      var swctx = new poly2tri.SweepContext(contour);\n\t *      var holes = [\n\t *          [{x:200, y:200}, {x:200, y:250}, {x:250, y:250}],\n\t *          [{x:300, y:300}, {x:300, y:350}, {x:350, y:350}]\n\t *      ];\n\t *      swctx.addHoles(holes);\n\t * @public\n\t * @param {Array.<Array.<XY>>} holes - array of array of \"Point like\" objects with {x,y}\n\t */\n\t// Method added in the JavaScript version (was not present in the c++ version)\n\tSweepContext.prototype.addHoles = function(holes) {\n\t    var i, len = holes.length;\n\t    for (i = 0; i < len; i++) {\n\t        this.initEdges(holes[i]);\n\t    }\n\t    this.points_ = this.points_.concat.apply(this.points_, holes);\n\t    return this; // for chaining\n\t};\n\t\n\t\n\t/**\n\t * Add a Steiner point to the constraints\n\t * @example\n\t *      var swctx = new poly2tri.SweepContext(contour);\n\t *      var point = new poly2tri.Point(150, 150);\n\t *      swctx.addPoint(point);\n\t * @example\n\t *      var swctx = new poly2tri.SweepContext(contour);\n\t *      swctx.addPoint({x:150, y:150});\n\t * @public\n\t * @param {XY} point - any \"Point like\" object with {x,y}\n\t */\n\tSweepContext.prototype.addPoint = function(point) {\n\t    this.points_.push(point);\n\t    return this; // for chaining\n\t};\n\t\n\t/**\n\t * For backward compatibility\n\t * @function\n\t * @deprecated use {@linkcode SweepContext#addPoint} instead\n\t */\n\tSweepContext.prototype.AddPoint = SweepContext.prototype.addPoint;\n\t\n\t\n\t/**\n\t * Add several Steiner points to the constraints\n\t * @example\n\t *      var swctx = new poly2tri.SweepContext(contour);\n\t *      var points = [\n\t *          new poly2tri.Point(150, 150),\n\t *          new poly2tri.Point(200, 250),\n\t *          new poly2tri.Point(250, 250)\n\t *      ];\n\t *      swctx.addPoints(points);\n\t * @example\n\t *      var swctx = new poly2tri.SweepContext(contour);\n\t *      swctx.addPoints([{x:150, y:150}, {x:200, y:250}, {x:250, y:250}]);\n\t * @public\n\t * @param {Array.<XY>} points - array of \"Point like\" object with {x,y}\n\t */\n\t// Method added in the JavaScript version (was not present in the c++ version)\n\tSweepContext.prototype.addPoints = function(points) {\n\t    this.points_ = this.points_.concat(points);\n\t    return this; // for chaining\n\t};\n\t\n\t\n\t/**\n\t * Triangulate the polygon with holes and Steiner points.\n\t * Do this AFTER you've added the polyline, holes, and Steiner points\n\t * @example\n\t *      var swctx = new poly2tri.SweepContext(contour);\n\t *      swctx.triangulate();\n\t *      var triangles = swctx.getTriangles();\n\t * @public\n\t */\n\t// Shortcut method for sweep.triangulate(SweepContext).\n\t// Method added in the JavaScript version (was not present in the c++ version)\n\tSweepContext.prototype.triangulate = function() {\n\t    sweep.triangulate(this);\n\t    return this; // for chaining\n\t};\n\t\n\t\n\t/**\n\t * Get the bounding box of the provided constraints (contour, holes and \n\t * Steinter points). Warning : these values are not available if the triangulation \n\t * has not been done yet.\n\t * @public\n\t * @returns {{min:Point,max:Point}} object with 'min' and 'max' Point\n\t */\n\t// Method added in the JavaScript version (was not present in the c++ version)\n\tSweepContext.prototype.getBoundingBox = function() {\n\t    return {min: this.pmin_, max: this.pmax_};\n\t};\n\t\n\t/**\n\t * Get result of triangulation.\n\t * The output triangles have vertices which are references\n\t * to the initial input points (not copies): any custom fields in the\n\t * initial points can be retrieved in the output triangles.\n\t * @example\n\t *      var swctx = new poly2tri.SweepContext(contour);\n\t *      swctx.triangulate();\n\t *      var triangles = swctx.getTriangles();\n\t * @example\n\t *      var contour = [{x:100, y:100, id:1}, {x:100, y:300, id:2}, {x:300, y:300, id:3}];\n\t *      var swctx = new poly2tri.SweepContext(contour);\n\t *      swctx.triangulate();\n\t *      var triangles = swctx.getTriangles();\n\t *      typeof triangles[0].getPoint(0).id\n\t *      //  \"number\"\n\t * @public\n\t * @returns {array<Triangle>}   array of triangles\n\t */\n\tSweepContext.prototype.getTriangles = function() {\n\t    return this.triangles_;\n\t};\n\t\n\t/**\n\t * For backward compatibility\n\t * @function\n\t * @deprecated use {@linkcode SweepContext#getTriangles} instead\n\t */\n\tSweepContext.prototype.GetTriangles = SweepContext.prototype.getTriangles;\n\t\n\t\n\t// ---------------------------------------------------SweepContext (private API)\n\t\n\t/** @private */\n\tSweepContext.prototype.front = function() {\n\t    return this.front_;\n\t};\n\t\n\t/** @private */\n\tSweepContext.prototype.pointCount = function() {\n\t    return this.points_.length;\n\t};\n\t\n\t/** @private */\n\tSweepContext.prototype.head = function() {\n\t    return this.head_;\n\t};\n\t\n\t/** @private */\n\tSweepContext.prototype.setHead = function(p1) {\n\t    this.head_ = p1;\n\t};\n\t\n\t/** @private */\n\tSweepContext.prototype.tail = function() {\n\t    return this.tail_;\n\t};\n\t\n\t/** @private */\n\tSweepContext.prototype.setTail = function(p1) {\n\t    this.tail_ = p1;\n\t};\n\t\n\t/** @private */\n\tSweepContext.prototype.getMap = function() {\n\t    return this.map_;\n\t};\n\t\n\t/** @private */\n\tSweepContext.prototype.initTriangulation = function() {\n\t    var xmax = this.points_[0].x;\n\t    var xmin = this.points_[0].x;\n\t    var ymax = this.points_[0].y;\n\t    var ymin = this.points_[0].y;\n\t\n\t    // Calculate bounds\n\t    var i, len = this.points_.length;\n\t    for (i = 1; i < len; i++) {\n\t        var p = this.points_[i];\n\t        /* jshint expr:true */\n\t        (p.x > xmax) && (xmax = p.x);\n\t        (p.x < xmin) && (xmin = p.x);\n\t        (p.y > ymax) && (ymax = p.y);\n\t        (p.y < ymin) && (ymin = p.y);\n\t    }\n\t    this.pmin_ = new Point(xmin, ymin);\n\t    this.pmax_ = new Point(xmax, ymax);\n\t\n\t    var dx = kAlpha * (xmax - xmin);\n\t    var dy = kAlpha * (ymax - ymin);\n\t    this.head_ = new Point(xmax + dx, ymin - dy);\n\t    this.tail_ = new Point(xmin - dx, ymin - dy);\n\t\n\t    // Sort points along y-axis\n\t    this.points_.sort(Point.compare);\n\t};\n\t\n\t/** @private */\n\tSweepContext.prototype.initEdges = function(polyline) {\n\t    var i, len = polyline.length;\n\t    for (i = 0; i < len; ++i) {\n\t        this.edge_list.push(new Edge(polyline[i], polyline[(i + 1) % len]));\n\t    }\n\t};\n\t\n\t/** @private */\n\tSweepContext.prototype.getPoint = function(index) {\n\t    return this.points_[index];\n\t};\n\t\n\t/** @private */\n\tSweepContext.prototype.addToMap = function(triangle) {\n\t    this.map_.push(triangle);\n\t};\n\t\n\t/** @private */\n\tSweepContext.prototype.locateNode = function(point) {\n\t    return this.front_.locateNode(point.x);\n\t};\n\t\n\t/** @private */\n\tSweepContext.prototype.createAdvancingFront = function() {\n\t    var head;\n\t    var middle;\n\t    var tail;\n\t    // Initial triangle\n\t    var triangle = new Triangle(this.points_[0], this.tail_, this.head_);\n\t\n\t    this.map_.push(triangle);\n\t\n\t    head = new Node(triangle.getPoint(1), triangle);\n\t    middle = new Node(triangle.getPoint(0), triangle);\n\t    tail = new Node(triangle.getPoint(2));\n\t\n\t    this.front_ = new AdvancingFront(head, tail);\n\t\n\t    head.next = middle;\n\t    middle.next = tail;\n\t    middle.prev = head;\n\t    tail.prev = middle;\n\t};\n\t\n\t/** @private */\n\tSweepContext.prototype.removeNode = function(node) {\n\t    // do nothing\n\t    /* jshint unused:false */\n\t};\n\t\n\t/** @private */\n\tSweepContext.prototype.mapTriangleToNodes = function(t) {\n\t    for (var i = 0; i < 3; ++i) {\n\t        if (!t.getNeighbor(i)) {\n\t            var n = this.front_.locatePoint(t.pointCW(t.getPoint(i)));\n\t            if (n) {\n\t                n.triangle = t;\n\t            }\n\t        }\n\t    }\n\t};\n\t\n\t/** @private */\n\tSweepContext.prototype.removeFromMap = function(triangle) {\n\t    var i, map = this.map_, len = map.length;\n\t    for (i = 0; i < len; i++) {\n\t        if (map[i] === triangle) {\n\t            map.splice(i, 1);\n\t            break;\n\t        }\n\t    }\n\t};\n\t\n\t/**\n\t * Do a depth first traversal to collect triangles\n\t * @private\n\t * @param {Triangle} triangle start\n\t */\n\tSweepContext.prototype.meshClean = function(triangle) {\n\t    // New implementation avoids recursive calls and use a loop instead.\n\t    // Cf. issues # 57, 65 and 69.\n\t    var triangles = [triangle], t, i;\n\t    /* jshint boss:true */\n\t    while (t = triangles.pop()) {\n\t        if (!t.isInterior()) {\n\t            t.setInterior(true);\n\t            this.triangles_.push(t);\n\t            for (i = 0; i < 3; i++) {\n\t                if (!t.constrained_edge[i]) {\n\t                    triangles.push(t.getNeighbor(i));\n\t                }\n\t            }\n\t        }\n\t    }\n\t};\n\t\n\t// ----------------------------------------------------------------------Exports\n\t\n\tmodule.exports = SweepContext;\n\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports) {\n\n\t/*\n\t * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors\n\t * http://code.google.com/p/poly2tri/\n\t * \n\t * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors\n\t * https://github.com/r3mi/poly2tri.js\n\t * \n\t * All rights reserved.\n\t * \n\t * Distributed under the 3-clause BSD License, see LICENSE.txt\n\t */\n\t\n\t\"use strict\";\n\t\n\t/**\n\t * Precision to detect repeated or collinear points\n\t * @private\n\t * @const {number}\n\t * @default\n\t */\n\tvar EPSILON = 1e-12;\n\texports.EPSILON = EPSILON;\n\t\n\t/**\n\t * @private\n\t * @enum {number}\n\t * @readonly\n\t */\n\tvar Orientation = {\n\t    \"CW\": 1,\n\t    \"CCW\": -1,\n\t    \"COLLINEAR\": 0\n\t};\n\texports.Orientation = Orientation;\n\t\n\t\n\t/**\n\t * Formula to calculate signed area<br>\n\t * Positive if CCW<br>\n\t * Negative if CW<br>\n\t * 0 if collinear<br>\n\t * <pre>\n\t * A[P1,P2,P3]  =  (x1*y2 - y1*x2) + (x2*y3 - y2*x3) + (x3*y1 - y3*x1)\n\t *              =  (x1-x3)*(y2-y3) - (y1-y3)*(x2-x3)\n\t * </pre>\n\t *\n\t * @private\n\t * @param {!XY} pa  point object with {x,y}\n\t * @param {!XY} pb  point object with {x,y}\n\t * @param {!XY} pc  point object with {x,y}\n\t * @return {Orientation}\n\t */\n\tfunction orient2d(pa, pb, pc) {\n\t    var detleft = (pa.x - pc.x) * (pb.y - pc.y);\n\t    var detright = (pa.y - pc.y) * (pb.x - pc.x);\n\t    var val = detleft - detright;\n\t    if (val > -(EPSILON) && val < (EPSILON)) {\n\t        return Orientation.COLLINEAR;\n\t    } else if (val > 0) {\n\t        return Orientation.CCW;\n\t    } else {\n\t        return Orientation.CW;\n\t    }\n\t}\n\texports.orient2d = orient2d;\n\t\n\t\n\t/**\n\t *\n\t * @private\n\t * @param {!XY} pa  point object with {x,y}\n\t * @param {!XY} pb  point object with {x,y}\n\t * @param {!XY} pc  point object with {x,y}\n\t * @param {!XY} pd  point object with {x,y}\n\t * @return {boolean}\n\t */\n\tfunction inScanArea(pa, pb, pc, pd) {\n\t    var oadb = (pa.x - pb.x) * (pd.y - pb.y) - (pd.x - pb.x) * (pa.y - pb.y);\n\t    if (oadb >= -EPSILON) {\n\t        return false;\n\t    }\n\t\n\t    var oadc = (pa.x - pc.x) * (pd.y - pc.y) - (pd.x - pc.x) * (pa.y - pc.y);\n\t    if (oadc <= EPSILON) {\n\t        return false;\n\t    }\n\t    return true;\n\t}\n\texports.inScanArea = inScanArea;\n\t\n\t\n\t/**\n\t * Check if the angle between (pa,pb) and (pa,pc) is obtuse i.e. (angle > /2 || angle < -/2)\n\t *\n\t * @private\n\t * @param {!XY} pa  point object with {x,y}\n\t * @param {!XY} pb  point object with {x,y}\n\t * @param {!XY} pc  point object with {x,y}\n\t * @return {boolean} true if angle is obtuse\n\t */\n\tfunction isAngleObtuse(pa, pb, pc) {\n\t    var ax = pb.x - pa.x;\n\t    var ay = pb.y - pa.y;\n\t    var bx = pc.x - pa.x;\n\t    var by = pc.y - pa.y;\n\t    return (ax * bx + ay * by) < 0;\n\t}\n\texports.isAngleObtuse = isAngleObtuse;\n\t\n\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\twindow.eve = __webpack_require__(7)\n\t\n\t// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n\t//\n\t// Licensed under the Apache License, Version 2.0 (the \"License\");\n\t// you may not use this file except in compliance with the License.\n\t// You may obtain a copy of the License at\n\t//\n\t// http://www.apache.org/licenses/LICENSE-2.0\n\t//\n\t// Unless required by applicable law or agreed to in writing, software\n\t// distributed under the License is distributed on an \"AS IS\" BASIS,\n\t// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t// See the License for the specific language governing permissions and\n\t// limitations under the License.\n\tvar mina = (function (eve) {\n\t    var animations = {},\n\t    requestAnimFrame = window.requestAnimationFrame       ||\n\t                       window.webkitRequestAnimationFrame ||\n\t                       window.mozRequestAnimationFrame    ||\n\t                       window.oRequestAnimationFrame      ||\n\t                       window.msRequestAnimationFrame     ||\n\t                       function (callback) {\n\t                           setTimeout(callback, 16);\n\t                       },\n\t    isArray = Array.isArray || function (a) {\n\t        return a instanceof Array ||\n\t            Object.prototype.toString.call(a) == \"[object Array]\";\n\t    },\n\t    idgen = 0,\n\t    idprefix = \"M\" + (+new Date).toString(36),\n\t    ID = function () {\n\t        return idprefix + (idgen++).toString(36);\n\t    },\n\t    diff = function (a, b, A, B) {\n\t        if (isArray(a)) {\n\t            res = [];\n\t            for (var i = 0, ii = a.length; i < ii; i++) {\n\t                res[i] = diff(a[i], b, A[i], B);\n\t            }\n\t            return res;\n\t        }\n\t        var dif = (A - a) / (B - b);\n\t        return function (bb) {\n\t            return a + dif * (bb - b);\n\t        };\n\t    },\n\t    timer = Date.now || function () {\n\t        return +new Date;\n\t    },\n\t    sta = function (val) {\n\t        var a = this;\n\t        if (val == null) {\n\t            return a.s;\n\t        }\n\t        var ds = a.s - val;\n\t        a.b += a.dur * ds;\n\t        a.B += a.dur * ds;\n\t        a.s = val;\n\t    },\n\t    speed = function (val) {\n\t        var a = this;\n\t        if (val == null) {\n\t            return a.spd;\n\t        }\n\t        a.spd = val;\n\t    },\n\t    duration = function (val) {\n\t        var a = this;\n\t        if (val == null) {\n\t            return a.dur;\n\t        }\n\t        a.s = a.s * val / a.dur;\n\t        a.dur = val;\n\t    },\n\t    stopit = function () {\n\t        var a = this;\n\t        delete animations[a.id];\n\t        a.update();\n\t        eve(\"mina.stop.\" + a.id, a);\n\t    },\n\t    pause = function () {\n\t        var a = this;\n\t        if (a.pdif) {\n\t            return;\n\t        }\n\t        delete animations[a.id];\n\t        a.update();\n\t        a.pdif = a.get() - a.b;\n\t    },\n\t    resume = function () {\n\t        var a = this;\n\t        if (!a.pdif) {\n\t            return;\n\t        }\n\t        a.b = a.get() - a.pdif;\n\t        delete a.pdif;\n\t        animations[a.id] = a;\n\t    },\n\t    update = function () {\n\t        var a = this,\n\t            res;\n\t        if (isArray(a.start)) {\n\t            res = [];\n\t            for (var j = 0, jj = a.start.length; j < jj; j++) {\n\t                res[j] = +a.start[j] +\n\t                    (a.end[j] - a.start[j]) * a.easing(a.s);\n\t            }\n\t        } else {\n\t            res = +a.start + (a.end - a.start) * a.easing(a.s);\n\t        }\n\t        a.set(res);\n\t    },\n\t    frame = function () {\n\t        var len = 0;\n\t        for (var i in animations) if (animations.hasOwnProperty(i)) {\n\t            var a = animations[i],\n\t                b = a.get(),\n\t                res;\n\t            len++;\n\t            a.s = (b - a.b) / (a.dur / a.spd);\n\t            if (a.s >= 1) {\n\t                delete animations[i];\n\t                a.s = 1;\n\t                len--;\n\t                (function (a) {\n\t                    setTimeout(function () {\n\t                        eve(\"mina.finish.\" + a.id, a);\n\t                    });\n\t                }(a));\n\t            }\n\t            a.update();\n\t        }\n\t        len && requestAnimFrame(frame);\n\t    },\n\t    /*\\\n\t     * mina\n\t     [ method ]\n\t     **\n\t     * Generic animation of numbers\n\t     **\n\t     - a (number) start _slave_ number\n\t     - A (number) end _slave_ number\n\t     - b (number) start _master_ number (start time in general case)\n\t     - B (number) end _master_ number (end time in gereal case)\n\t     - get (function) getter of _master_ number (see @mina.time)\n\t     - set (function) setter of _slave_ number\n\t     - easing (function) #optional easing function, default is @mina.linear\n\t     = (object) animation descriptor\n\t     o {\n\t     o         id (string) animation id,\n\t     o         start (number) start _slave_ number,\n\t     o         end (number) end _slave_ number,\n\t     o         b (number) start _master_ number,\n\t     o         s (number) animation status (0..1),\n\t     o         dur (number) animation duration,\n\t     o         spd (number) animation speed,\n\t     o         get (function) getter of _master_ number (see @mina.time),\n\t     o         set (function) setter of _slave_ number,\n\t     o         easing (function) easing function, default is @mina.linear,\n\t     o         status (function) status getter/setter,\n\t     o         speed (function) speed getter/setter,\n\t     o         duration (function) duration getter/setter,\n\t     o         stop (function) animation stopper\n\t     o         pause (function) pauses the animation\n\t     o         resume (function) resumes the animation\n\t     o         update (function) calles setter with the right value of the animation\n\t     o }\n\t    \\*/\n\t    mina = function (a, A, b, B, get, set, easing) {\n\t        var anim = {\n\t            id: ID(),\n\t            start: a,\n\t            end: A,\n\t            b: b,\n\t            s: 0,\n\t            dur: B - b,\n\t            spd: 1,\n\t            get: get,\n\t            set: set,\n\t            easing: easing || mina.linear,\n\t            status: sta,\n\t            speed: speed,\n\t            duration: duration,\n\t            stop: stopit,\n\t            pause: pause,\n\t            resume: resume,\n\t            update: update\n\t        };\n\t        animations[anim.id] = anim;\n\t        var len = 0, i;\n\t        for (i in animations) if (animations.hasOwnProperty(i)) {\n\t            len++;\n\t            if (len == 2) {\n\t                break;\n\t            }\n\t        }\n\t        len == 1 && requestAnimFrame(frame);\n\t        return anim;\n\t    };\n\t    /*\\\n\t     * mina.time\n\t     [ method ]\n\t     **\n\t     * Returns the current time. Equivalent to:\n\t     | function () {\n\t     |     return (new Date).getTime();\n\t     | }\n\t    \\*/\n\t    mina.time = timer;\n\t    /*\\\n\t     * mina.getById\n\t     [ method ]\n\t     **\n\t     * Returns an animation by its id\n\t     - id (string) animation's id\n\t     = (object) See @mina\n\t    \\*/\n\t    mina.getById = function (id) {\n\t        return animations[id] || null;\n\t    };\n\t\n\t    /*\\\n\t     * mina.linear\n\t     [ method ]\n\t     **\n\t     * Default linear easing\n\t     - n (number) input 0..1\n\t     = (number) output 0..1\n\t    \\*/\n\t    mina.linear = function (n) {\n\t        return n;\n\t    };\n\t    /*\\\n\t     * mina.easeout\n\t     [ method ]\n\t     **\n\t     * Easeout easing\n\t     - n (number) input 0..1\n\t     = (number) output 0..1\n\t    \\*/\n\t    mina.easeout = function (n) {\n\t        return Math.pow(n, 1.7);\n\t    };\n\t    /*\\\n\t     * mina.easein\n\t     [ method ]\n\t     **\n\t     * Easein easing\n\t     - n (number) input 0..1\n\t     = (number) output 0..1\n\t    \\*/\n\t    mina.easein = function (n) {\n\t        return Math.pow(n, .48);\n\t    };\n\t    /*\\\n\t     * mina.easeinout\n\t     [ method ]\n\t     **\n\t     * Easeinout easing\n\t     - n (number) input 0..1\n\t     = (number) output 0..1\n\t    \\*/\n\t    mina.easeinout = function (n) {\n\t        if (n == 1) {\n\t            return 1;\n\t        }\n\t        if (n == 0) {\n\t            return 0;\n\t        }\n\t        var q = .48 - n / 1.04,\n\t            Q = Math.sqrt(.1734 + q * q),\n\t            x = Q - q,\n\t            X = Math.pow(Math.abs(x), 1 / 3) * (x < 0 ? -1 : 1),\n\t            y = -Q - q,\n\t            Y = Math.pow(Math.abs(y), 1 / 3) * (y < 0 ? -1 : 1),\n\t            t = X + Y + .5;\n\t        return (1 - t) * 3 * t * t + t * t * t;\n\t    };\n\t    /*\\\n\t     * mina.backin\n\t     [ method ]\n\t     **\n\t     * Backin easing\n\t     - n (number) input 0..1\n\t     = (number) output 0..1\n\t    \\*/\n\t    mina.backin = function (n) {\n\t        if (n == 1) {\n\t            return 1;\n\t        }\n\t        var s = 1.70158;\n\t        return n * n * ((s + 1) * n - s);\n\t    };\n\t    /*\\\n\t     * mina.backout\n\t     [ method ]\n\t     **\n\t     * Backout easing\n\t     - n (number) input 0..1\n\t     = (number) output 0..1\n\t    \\*/\n\t    mina.backout = function (n) {\n\t        if (n == 0) {\n\t            return 0;\n\t        }\n\t        n = n - 1;\n\t        var s = 1.70158;\n\t        return n * n * ((s + 1) * n + s) + 1;\n\t    };\n\t    /*\\\n\t     * mina.elastic\n\t     [ method ]\n\t     **\n\t     * Elastic easing\n\t     - n (number) input 0..1\n\t     = (number) output 0..1\n\t    \\*/\n\t    mina.elastic = function (n) {\n\t        if (n == !!n) {\n\t            return n;\n\t        }\n\t        return Math.pow(2, -10 * n) * Math.sin((n - .075) *\n\t            (2 * Math.PI) / .3) + 1;\n\t    };\n\t    /*\\\n\t     * mina.bounce\n\t     [ method ]\n\t     **\n\t     * Bounce easing\n\t     - n (number) input 0..1\n\t     = (number) output 0..1\n\t    \\*/\n\t    mina.bounce = function (n) {\n\t        var s = 7.5625,\n\t            p = 2.75,\n\t            l;\n\t        if (n < (1 / p)) {\n\t            l = s * n * n;\n\t        } else {\n\t            if (n < (2 / p)) {\n\t                n -= (1.5 / p);\n\t                l = s * n * n + .75;\n\t            } else {\n\t                if (n < (2.5 / p)) {\n\t                    n -= (2.25 / p);\n\t                    l = s * n * n + .9375;\n\t                } else {\n\t                    n -= (2.625 / p);\n\t                    l = s * n * n + .984375;\n\t                }\n\t            }\n\t        }\n\t        return l;\n\t    };\n\t    window.mina = mina;\n\t    return mina;\n\t})(typeof eve == \"undefined\" ? function () {} : eve);\n\t// Copyright (c) 2013 - 2015 Adobe Systems Incorporated. All rights reserved.\n\t//\n\t// Licensed under the Apache License, Version 2.0 (the \"License\");\n\t// you may not use this file except in compliance with the License.\n\t// You may obtain a copy of the License at\n\t//\n\t// http://www.apache.org/licenses/LICENSE-2.0\n\t//\n\t// Unless required by applicable law or agreed to in writing, software\n\t// distributed under the License is distributed on an \"AS IS\" BASIS,\n\t// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t// See the License for the specific language governing permissions and\n\t// limitations under the License.\n\t\n\tvar Snap = (function(root) {\n\tSnap.version = \"0.4.0\";\n\t/*\\\n\t * Snap\n\t [ method ]\n\t **\n\t * Creates a drawing surface or wraps existing SVG element.\n\t **\n\t - width (number|string) width of surface\n\t - height (number|string) height of surface\n\t * or\n\t - DOM (SVGElement) element to be wrapped into Snap structure\n\t * or\n\t - array (array) array of elements (will return set of elements)\n\t * or\n\t - query (string) CSS query selector\n\t = (object) @Element\n\t\\*/\n\tfunction Snap(w, h) {\n\t    if (w) {\n\t        if (w.nodeType) {\n\t            return wrap(w);\n\t        }\n\t        if (is(w, \"array\") && Snap.set) {\n\t            return Snap.set.apply(Snap, w);\n\t        }\n\t        if (w instanceof Element) {\n\t            return w;\n\t        }\n\t        if (h == null) {\n\t            w = glob.doc.querySelector(String(w));\n\t            return wrap(w);\n\t        }\n\t    }\n\t    w = w == null ? \"100%\" : w;\n\t    h = h == null ? \"100%\" : h;\n\t    return new Paper(w, h);\n\t}\n\tSnap.toString = function () {\n\t    return \"Snap v\" + this.version;\n\t};\n\tSnap._ = {};\n\tvar glob = {\n\t    win: root.window,\n\t    doc: root.window.document\n\t};\n\tSnap._.glob = glob;\n\tvar has = \"hasOwnProperty\",\n\t    Str = String,\n\t    toFloat = parseFloat,\n\t    toInt = parseInt,\n\t    math = Math,\n\t    mmax = math.max,\n\t    mmin = math.min,\n\t    abs = math.abs,\n\t    pow = math.pow,\n\t    PI = math.PI,\n\t    round = math.round,\n\t    E = \"\",\n\t    S = \" \",\n\t    objectToString = Object.prototype.toString,\n\t    ISURL = /^url\\(['\"]?([^\\)]+?)['\"]?\\)$/i,\n\t    colourRegExp = /^\\s*((#[a-f\\d]{6})|(#[a-f\\d]{3})|rgba?\\(\\s*([\\d\\.]+%?\\s*,\\s*[\\d\\.]+%?\\s*,\\s*[\\d\\.]+%?(?:\\s*,\\s*[\\d\\.]+%?)?)\\s*\\)|hsba?\\(\\s*([\\d\\.]+(?:deg|\\xb0|%)?\\s*,\\s*[\\d\\.]+%?\\s*,\\s*[\\d\\.]+(?:%?\\s*,\\s*[\\d\\.]+)?%?)\\s*\\)|hsla?\\(\\s*([\\d\\.]+(?:deg|\\xb0|%)?\\s*,\\s*[\\d\\.]+%?\\s*,\\s*[\\d\\.]+(?:%?\\s*,\\s*[\\d\\.]+)?%?)\\s*\\))\\s*$/i,\n\t    bezierrg = /^(?:cubic-)?bezier\\(([^,]+),([^,]+),([^,]+),([^\\)]+)\\)/,\n\t    reURLValue = /^url\\(#?([^)]+)\\)$/,\n\t    separator = Snap._.separator = /[,\\s]+/,\n\t    whitespace = /[\\s]/g,\n\t    commaSpaces = /[\\s]*,[\\s]*/,\n\t    hsrg = {hs: 1, rg: 1},\n\t    pathCommand = /([a-z])[\\s,]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[\\s]*,?[\\s]*)+)/ig,\n\t    tCommand = /([rstm])[\\s,]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[\\s]*,?[\\s]*)+)/ig,\n\t    pathValues = /(-?\\d*\\.?\\d*(?:e[\\-+]?\\\\d+)?)[\\s]*,?[\\s]*/ig,\n\t    idgen = 0,\n\t    idprefix = \"S\" + (+new Date).toString(36),\n\t    ID = function (el) {\n\t        return (el && el.type ? el.type : E) + idprefix + (idgen++).toString(36);\n\t    },\n\t    xlink = \"http://www.w3.org/1999/xlink\",\n\t    xmlns = \"http://www.w3.org/2000/svg\",\n\t    hub = {},\n\t    URL = Snap.url = function (url) {\n\t        return \"url('#\" + url + \"')\";\n\t    };\n\t\n\tfunction $(el, attr) {\n\t    if (attr) {\n\t        if (el == \"#text\") {\n\t            el = glob.doc.createTextNode(attr.text || attr[\"#text\"] || \"\");\n\t        }\n\t        if (el == \"#comment\") {\n\t            el = glob.doc.createComment(attr.text || attr[\"#text\"] || \"\");\n\t        }\n\t        if (typeof el == \"string\") {\n\t            el = $(el);\n\t        }\n\t        if (typeof attr == \"string\") {\n\t            if (el.nodeType == 1) {\n\t                if (attr.substring(0, 6) == \"xlink:\") {\n\t                    return el.getAttributeNS(xlink, attr.substring(6));\n\t                }\n\t                if (attr.substring(0, 4) == \"xml:\") {\n\t                    return el.getAttributeNS(xmlns, attr.substring(4));\n\t                }\n\t                return el.getAttribute(attr);\n\t            } else if (attr == \"text\") {\n\t                return el.nodeValue;\n\t            } else {\n\t                return null;\n\t            }\n\t        }\n\t        if (el.nodeType == 1) {\n\t            for (var key in attr) if (attr[has](key)) {\n\t                var val = Str(attr[key]);\n\t                if (val) {\n\t                    if (key.substring(0, 6) == \"xlink:\") {\n\t                        el.setAttributeNS(xlink, key.substring(6), val);\n\t                    } else if (key.substring(0, 4) == \"xml:\") {\n\t                        el.setAttributeNS(xmlns, key.substring(4), val);\n\t                    } else {\n\t                        el.setAttribute(key, val);\n\t                    }\n\t                } else {\n\t                    el.removeAttribute(key);\n\t                }\n\t            }\n\t        } else if (\"text\" in attr) {\n\t            el.nodeValue = attr.text;\n\t        }\n\t    } else {\n\t        el = glob.doc.createElementNS(xmlns, el);\n\t    }\n\t    return el;\n\t}\n\tSnap._.$ = $;\n\tSnap._.id = ID;\n\tfunction getAttrs(el) {\n\t    var attrs = el.attributes,\n\t        name,\n\t        out = {};\n\t    for (var i = 0; i < attrs.length; i++) {\n\t        if (attrs[i].namespaceURI == xlink) {\n\t            name = \"xlink:\";\n\t        } else {\n\t            name = \"\";\n\t        }\n\t        name += attrs[i].name;\n\t        out[name] = attrs[i].textContent;\n\t    }\n\t    return out;\n\t}\n\tfunction is(o, type) {\n\t    type = Str.prototype.toLowerCase.call(type);\n\t    if (type == \"finite\") {\n\t        return isFinite(o);\n\t    }\n\t    if (type == \"array\" &&\n\t        (o instanceof Array || Array.isArray && Array.isArray(o))) {\n\t        return true;\n\t    }\n\t    return  (type == \"null\" && o === null) ||\n\t            (type == typeof o && o !== null) ||\n\t            (type == \"object\" && o === Object(o)) ||\n\t            objectToString.call(o).slice(8, -1).toLowerCase() == type;\n\t}\n\t/*\\\n\t * Snap.format\n\t [ method ]\n\t **\n\t * Replaces construction of type `{<name>}` to the corresponding argument\n\t **\n\t - token (string) string to format\n\t - json (object) object which properties are used as a replacement\n\t = (string) formatted string\n\t > Usage\n\t | // this draws a rectangular shape equivalent to \"M10,20h40v50h-40z\"\n\t | paper.path(Snap.format(\"M{x},{y}h{dim.width}v{dim.height}h{dim['negative width']}z\", {\n\t |     x: 10,\n\t |     y: 20,\n\t |     dim: {\n\t |         width: 40,\n\t |         height: 50,\n\t |         \"negative width\": -40\n\t |     }\n\t | }));\n\t\\*/\n\tSnap.format = (function () {\n\t    var tokenRegex = /\\{([^\\}]+)\\}/g,\n\t        objNotationRegex = /(?:(?:^|\\.)(.+?)(?=\\[|\\.|$|\\()|\\[('|\")(.+?)\\2\\])(\\(\\))?/g, // matches .xxxxx or [\"xxxxx\"] to run over object properties\n\t        replacer = function (all, key, obj) {\n\t            var res = obj;\n\t            key.replace(objNotationRegex, function (all, name, quote, quotedName, isFunc) {\n\t                name = name || quotedName;\n\t                if (res) {\n\t                    if (name in res) {\n\t                        res = res[name];\n\t                    }\n\t                    typeof res == \"function\" && isFunc && (res = res());\n\t                }\n\t            });\n\t            res = (res == null || res == obj ? all : res) + \"\";\n\t            return res;\n\t        };\n\t    return function (str, obj) {\n\t        return Str(str).replace(tokenRegex, function (all, key) {\n\t            return replacer(all, key, obj);\n\t        });\n\t    };\n\t})();\n\tfunction clone(obj) {\n\t    if (typeof obj == \"function\" || Object(obj) !== obj) {\n\t        return obj;\n\t    }\n\t    var res = new obj.constructor;\n\t    for (var key in obj) if (obj[has](key)) {\n\t        res[key] = clone(obj[key]);\n\t    }\n\t    return res;\n\t}\n\tSnap._.clone = clone;\n\tfunction repush(array, item) {\n\t    for (var i = 0, ii = array.length; i < ii; i++) if (array[i] === item) {\n\t        return array.push(array.splice(i, 1)[0]);\n\t    }\n\t}\n\tfunction cacher(f, scope, postprocessor) {\n\t    function newf() {\n\t        var arg = Array.prototype.slice.call(arguments, 0),\n\t            args = arg.join(\"\\u2400\"),\n\t            cache = newf.cache = newf.cache || {},\n\t            count = newf.count = newf.count || [];\n\t        if (cache[has](args)) {\n\t            repush(count, args);\n\t            return postprocessor ? postprocessor(cache[args]) : cache[args];\n\t        }\n\t        count.length >= 1e3 && delete cache[count.shift()];\n\t        count.push(args);\n\t        cache[args] = f.apply(scope, arg);\n\t        return postprocessor ? postprocessor(cache[args]) : cache[args];\n\t    }\n\t    return newf;\n\t}\n\tSnap._.cacher = cacher;\n\tfunction angle(x1, y1, x2, y2, x3, y3) {\n\t    if (x3 == null) {\n\t        var x = x1 - x2,\n\t            y = y1 - y2;\n\t        if (!x && !y) {\n\t            return 0;\n\t        }\n\t        return (180 + math.atan2(-y, -x) * 180 / PI + 360) % 360;\n\t    } else {\n\t        return angle(x1, y1, x3, y3) - angle(x2, y2, x3, y3);\n\t    }\n\t}\n\tfunction rad(deg) {\n\t    return deg % 360 * PI / 180;\n\t}\n\tfunction deg(rad) {\n\t    return rad * 180 / PI % 360;\n\t}\n\tfunction x_y() {\n\t    return this.x + S + this.y;\n\t}\n\tfunction x_y_w_h() {\n\t    return this.x + S + this.y + S + this.width + \" \\xd7 \" + this.height;\n\t}\n\t\n\t/*\\\n\t * Snap.rad\n\t [ method ]\n\t **\n\t * Transform angle to radians\n\t - deg (number) angle in degrees\n\t = (number) angle in radians\n\t\\*/\n\tSnap.rad = rad;\n\t/*\\\n\t * Snap.deg\n\t [ method ]\n\t **\n\t * Transform angle to degrees\n\t - rad (number) angle in radians\n\t = (number) angle in degrees\n\t\\*/\n\tSnap.deg = deg;\n\t/*\\\n\t * Snap.sin\n\t [ method ]\n\t **\n\t * Equivalent to `Math.sin()` only works with degrees, not radians.\n\t - angle (number) angle in degrees\n\t = (number) sin\n\t\\*/\n\tSnap.sin = function (angle) {\n\t    return math.sin(Snap.rad(angle));\n\t};\n\t/*\\\n\t * Snap.tan\n\t [ method ]\n\t **\n\t * Equivalent to `Math.tan()` only works with degrees, not radians.\n\t - angle (number) angle in degrees\n\t = (number) tan\n\t\\*/\n\tSnap.tan = function (angle) {\n\t    return math.tan(Snap.rad(angle));\n\t};\n\t/*\\\n\t * Snap.cos\n\t [ method ]\n\t **\n\t * Equivalent to `Math.cos()` only works with degrees, not radians.\n\t - angle (number) angle in degrees\n\t = (number) cos\n\t\\*/\n\tSnap.cos = function (angle) {\n\t    return math.cos(Snap.rad(angle));\n\t};\n\t/*\\\n\t * Snap.asin\n\t [ method ]\n\t **\n\t * Equivalent to `Math.asin()` only works with degrees, not radians.\n\t - num (number) value\n\t = (number) asin in degrees\n\t\\*/\n\tSnap.asin = function (num) {\n\t    return Snap.deg(math.asin(num));\n\t};\n\t/*\\\n\t * Snap.acos\n\t [ method ]\n\t **\n\t * Equivalent to `Math.acos()` only works with degrees, not radians.\n\t - num (number) value\n\t = (number) acos in degrees\n\t\\*/\n\tSnap.acos = function (num) {\n\t    return Snap.deg(math.acos(num));\n\t};\n\t/*\\\n\t * Snap.atan\n\t [ method ]\n\t **\n\t * Equivalent to `Math.atan()` only works with degrees, not radians.\n\t - num (number) value\n\t = (number) atan in degrees\n\t\\*/\n\tSnap.atan = function (num) {\n\t    return Snap.deg(math.atan(num));\n\t};\n\t/*\\\n\t * Snap.atan2\n\t [ method ]\n\t **\n\t * Equivalent to `Math.atan2()` only works with degrees, not radians.\n\t - num (number) value\n\t = (number) atan2 in degrees\n\t\\*/\n\tSnap.atan2 = function (num) {\n\t    return Snap.deg(math.atan2(num));\n\t};\n\t/*\\\n\t * Snap.angle\n\t [ method ]\n\t **\n\t * Returns an angle between two or three points\n\t > Parameters\n\t - x1 (number) x coord of first point\n\t - y1 (number) y coord of first point\n\t - x2 (number) x coord of second point\n\t - y2 (number) y coord of second point\n\t - x3 (number) #optional x coord of third point\n\t - y3 (number) #optional y coord of third point\n\t = (number) angle in degrees\n\t\\*/\n\tSnap.angle = angle;\n\t/*\\\n\t * Snap.len\n\t [ method ]\n\t **\n\t * Returns distance between two points\n\t > Parameters\n\t - x1 (number) x coord of first point\n\t - y1 (number) y coord of first point\n\t - x2 (number) x coord of second point\n\t - y2 (number) y coord of second point\n\t = (number) distance\n\t\\*/\n\tSnap.len = function (x1, y1, x2, y2) {\n\t    return Math.sqrt(Snap.len2(x1, y1, x2, y2));\n\t};\n\t/*\\\n\t * Snap.len2\n\t [ method ]\n\t **\n\t * Returns squared distance between two points\n\t > Parameters\n\t - x1 (number) x coord of first point\n\t - y1 (number) y coord of first point\n\t - x2 (number) x coord of second point\n\t - y2 (number) y coord of second point\n\t = (number) distance\n\t\\*/\n\tSnap.len2 = function (x1, y1, x2, y2) {\n\t    return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);\n\t};\n\t/*\\\n\t * Snap.closestPoint\n\t [ method ]\n\t **\n\t * Returns closest point to a given one on a given path.\n\t > Parameters\n\t - path (Element) path element\n\t - x (number) x coord of a point\n\t - y (number) y coord of a point\n\t = (object) in format\n\t {\n\t    x (number) x coord of the point on the path\n\t    y (number) y coord of the point on the path\n\t    length (number) length of the path to the point\n\t    distance (number) distance from the given point to the path\n\t }\n\t\\*/\n\t// Copied from http://bl.ocks.org/mbostock/8027637\n\tSnap.closestPoint = function (path, x, y) {\n\t    function distance2(p) {\n\t        var dx = p.x - x,\n\t            dy = p.y - y;\n\t        return dx * dx + dy * dy;\n\t    }\n\t    var pathNode = path.node,\n\t        pathLength = pathNode.getTotalLength(),\n\t        precision = pathLength / pathNode.pathSegList.numberOfItems * .125,\n\t        best,\n\t        bestLength,\n\t        bestDistance = Infinity;\n\t\n\t    // linear scan for coarse approximation\n\t    for (var scan, scanLength = 0, scanDistance; scanLength <= pathLength; scanLength += precision) {\n\t        if ((scanDistance = distance2(scan = pathNode.getPointAtLength(scanLength))) < bestDistance) {\n\t            best = scan, bestLength = scanLength, bestDistance = scanDistance;\n\t        }\n\t    }\n\t\n\t    // binary search for precise estimate\n\t    precision *= .5;\n\t    while (precision > .5) {\n\t        var before,\n\t            after,\n\t            beforeLength,\n\t            afterLength,\n\t            beforeDistance,\n\t            afterDistance;\n\t        if ((beforeLength = bestLength - precision) >= 0 && (beforeDistance = distance2(before = pathNode.getPointAtLength(beforeLength))) < bestDistance) {\n\t            best = before, bestLength = beforeLength, bestDistance = beforeDistance;\n\t        } else if ((afterLength = bestLength + precision) <= pathLength && (afterDistance = distance2(after = pathNode.getPointAtLength(afterLength))) < bestDistance) {\n\t            best = after, bestLength = afterLength, bestDistance = afterDistance;\n\t        } else {\n\t            precision *= .5;\n\t        }\n\t    }\n\t\n\t    best = {\n\t        x: best.x,\n\t        y: best.y,\n\t        length: bestLength,\n\t        distance: Math.sqrt(bestDistance)\n\t    };\n\t    return best;\n\t}\n\t/*\\\n\t * Snap.is\n\t [ method ]\n\t **\n\t * Handy replacement for the `typeof` operator\n\t - o () any object or primitive\n\t - type (string) name of the type, e.g., `string`, `function`, `number`, etc.\n\t = (boolean) `true` if given value is of given type\n\t\\*/\n\tSnap.is = is;\n\t/*\\\n\t * Snap.snapTo\n\t [ method ]\n\t **\n\t * Snaps given value to given grid\n\t - values (array|number) given array of values or step of the grid\n\t - value (number) value to adjust\n\t - tolerance (number) #optional maximum distance to the target value that would trigger the snap. Default is `10`.\n\t = (number) adjusted value\n\t\\*/\n\tSnap.snapTo = function (values, value, tolerance) {\n\t    tolerance = is(tolerance, \"finite\") ? tolerance : 10;\n\t    if (is(values, \"array\")) {\n\t        var i = values.length;\n\t        while (i--) if (abs(values[i] - value) <= tolerance) {\n\t            return values[i];\n\t        }\n\t    } else {\n\t        values = +values;\n\t        var rem = value % values;\n\t        if (rem < tolerance) {\n\t            return value - rem;\n\t        }\n\t        if (rem > values - tolerance) {\n\t            return value - rem + values;\n\t        }\n\t    }\n\t    return value;\n\t};\n\t// Colour\n\t/*\\\n\t * Snap.getRGB\n\t [ method ]\n\t **\n\t * Parses color string as RGB object\n\t - color (string) color string in one of the following formats:\n\t # <ul>\n\t #     <li>Color name (<code>red</code>, <code>green</code>, <code>cornflowerblue</code>, etc)</li>\n\t #     <li>#  shortened HTML color: (<code>#000</code>, <code>#fc0</code>, etc.)</li>\n\t #     <li>#  full length HTML color: (<code>#000000</code>, <code>#bd2300</code>)</li>\n\t #     <li>rgb(, , )  red, green and blue channels values: (<code>rgb(200,&nbsp;100,&nbsp;0)</code>)</li>\n\t #     <li>rgba(, , , )  also with opacity</li>\n\t #     <li>rgb(%, %, %)  same as above, but in %: (<code>rgb(100%,&nbsp;175%,&nbsp;0%)</code>)</li>\n\t #     <li>rgba(%, %, %, %)  also with opacity</li>\n\t #     <li>hsb(, , )  hue, saturation and brightness values: (<code>hsb(0.5,&nbsp;0.25,&nbsp;1)</code>)</li>\n\t #     <li>hsba(, , , )  also with opacity</li>\n\t #     <li>hsb(%, %, %)  same as above, but in %</li>\n\t #     <li>hsba(%, %, %, %)  also with opacity</li>\n\t #     <li>hsl(, , )  hue, saturation and luminosity values: (<code>hsb(0.5,&nbsp;0.25,&nbsp;0.5)</code>)</li>\n\t #     <li>hsla(, , , )  also with opacity</li>\n\t #     <li>hsl(%, %, %)  same as above, but in %</li>\n\t #     <li>hsla(%, %, %, %)  also with opacity</li>\n\t # </ul>\n\t * Note that `%` can be used any time: `rgb(20%, 255, 50%)`.\n\t = (object) RGB object in the following format:\n\t o {\n\t o     r (number) red,\n\t o     g (number) green,\n\t o     b (number) blue,\n\t o     hex (string) color in HTML/CSS format: #,\n\t o     error (boolean) true if string can't be parsed\n\t o }\n\t\\*/\n\tSnap.getRGB = cacher(function (colour) {\n\t    if (!colour || !!((colour = Str(colour)).indexOf(\"-\") + 1)) {\n\t        return {r: -1, g: -1, b: -1, hex: \"none\", error: 1, toString: rgbtoString};\n\t    }\n\t    if (colour == \"none\") {\n\t        return {r: -1, g: -1, b: -1, hex: \"none\", toString: rgbtoString};\n\t    }\n\t    !(hsrg[has](colour.toLowerCase().substring(0, 2)) || colour.charAt() == \"#\") && (colour = toHex(colour));\n\t    if (!colour) {\n\t        return {r: -1, g: -1, b: -1, hex: \"none\", error: 1, toString: rgbtoString};\n\t    }\n\t    var res,\n\t        red,\n\t        green,\n\t        blue,\n\t        opacity,\n\t        t,\n\t        values,\n\t        rgb = colour.match(colourRegExp);\n\t    if (rgb) {\n\t        if (rgb[2]) {\n\t            blue = toInt(rgb[2].substring(5), 16);\n\t            green = toInt(rgb[2].substring(3, 5), 16);\n\t            red = toInt(rgb[2].substring(1, 3), 16);\n\t        }\n\t        if (rgb[3]) {\n\t            blue = toInt((t = rgb[3].charAt(3)) + t, 16);\n\t            green = toInt((t = rgb[3].charAt(2)) + t, 16);\n\t            red = toInt((t = rgb[3].charAt(1)) + t, 16);\n\t        }\n\t        if (rgb[4]) {\n\t            values = rgb[4].split(commaSpaces);\n\t            red = toFloat(values[0]);\n\t            values[0].slice(-1) == \"%\" && (red *= 2.55);\n\t            green = toFloat(values[1]);\n\t            values[1].slice(-1) == \"%\" && (green *= 2.55);\n\t            blue = toFloat(values[2]);\n\t            values[2].slice(-1) == \"%\" && (blue *= 2.55);\n\t            rgb[1].toLowerCase().slice(0, 4) == \"rgba\" && (opacity = toFloat(values[3]));\n\t            values[3] && values[3].slice(-1) == \"%\" && (opacity /= 100);\n\t        }\n\t        if (rgb[5]) {\n\t            values = rgb[5].split(commaSpaces);\n\t            red = toFloat(values[0]);\n\t            values[0].slice(-1) == \"%\" && (red /= 100);\n\t            green = toFloat(values[1]);\n\t            values[1].slice(-1) == \"%\" && (green /= 100);\n\t            blue = toFloat(values[2]);\n\t            values[2].slice(-1) == \"%\" && (blue /= 100);\n\t            (values[0].slice(-3) == \"deg\" || values[0].slice(-1) == \"\\xb0\") && (red /= 360);\n\t            rgb[1].toLowerCase().slice(0, 4) == \"hsba\" && (opacity = toFloat(values[3]));\n\t            values[3] && values[3].slice(-1) == \"%\" && (opacity /= 100);\n\t            return Snap.hsb2rgb(red, green, blue, opacity);\n\t        }\n\t        if (rgb[6]) {\n\t            values = rgb[6].split(commaSpaces);\n\t            red = toFloat(values[0]);\n\t            values[0].slice(-1) == \"%\" && (red /= 100);\n\t            green = toFloat(values[1]);\n\t            values[1].slice(-1) == \"%\" && (green /= 100);\n\t            blue = toFloat(values[2]);\n\t            values[2].slice(-1) == \"%\" && (blue /= 100);\n\t            (values[0].slice(-3) == \"deg\" || values[0].slice(-1) == \"\\xb0\") && (red /= 360);\n\t            rgb[1].toLowerCase().slice(0, 4) == \"hsla\" && (opacity = toFloat(values[3]));\n\t            values[3] && values[3].slice(-1) == \"%\" && (opacity /= 100);\n\t            return Snap.hsl2rgb(red, green, blue, opacity);\n\t        }\n\t        red = mmin(math.round(red), 255);\n\t        green = mmin(math.round(green), 255);\n\t        blue = mmin(math.round(blue), 255);\n\t        opacity = mmin(mmax(opacity, 0), 1);\n\t        rgb = {r: red, g: green, b: blue, toString: rgbtoString};\n\t        rgb.hex = \"#\" + (16777216 | blue | (green << 8) | (red << 16)).toString(16).slice(1);\n\t        rgb.opacity = is(opacity, \"finite\") ? opacity : 1;\n\t        return rgb;\n\t    }\n\t    return {r: -1, g: -1, b: -1, hex: \"none\", error: 1, toString: rgbtoString};\n\t}, Snap);\n\t/*\\\n\t * Snap.hsb\n\t [ method ]\n\t **\n\t * Converts HSB values to a hex representation of the color\n\t - h (number) hue\n\t - s (number) saturation\n\t - b (number) value or brightness\n\t = (string) hex representation of the color\n\t\\*/\n\tSnap.hsb = cacher(function (h, s, b) {\n\t    return Snap.hsb2rgb(h, s, b).hex;\n\t});\n\t/*\\\n\t * Snap.hsl\n\t [ method ]\n\t **\n\t * Converts HSL values to a hex representation of the color\n\t - h (number) hue\n\t - s (number) saturation\n\t - l (number) luminosity\n\t = (string) hex representation of the color\n\t\\*/\n\tSnap.hsl = cacher(function (h, s, l) {\n\t    return Snap.hsl2rgb(h, s, l).hex;\n\t});\n\t/*\\\n\t * Snap.rgb\n\t [ method ]\n\t **\n\t * Converts RGB values to a hex representation of the color\n\t - r (number) red\n\t - g (number) green\n\t - b (number) blue\n\t = (string) hex representation of the color\n\t\\*/\n\tSnap.rgb = cacher(function (r, g, b, o) {\n\t    if (is(o, \"finite\")) {\n\t        var round = math.round;\n\t        return \"rgba(\" + [round(r), round(g), round(b), +o.toFixed(2)] + \")\";\n\t    }\n\t    return \"#\" + (16777216 | b | (g << 8) | (r << 16)).toString(16).slice(1);\n\t});\n\tvar toHex = function (color) {\n\t    var i = glob.doc.getElementsByTagName(\"head\")[0] || glob.doc.getElementsByTagName(\"svg\")[0],\n\t        red = \"rgb(255, 0, 0)\";\n\t    toHex = cacher(function (color) {\n\t        if (color.toLowerCase() == \"red\") {\n\t            return red;\n\t        }\n\t        i.style.color = red;\n\t        i.style.color = color;\n\t        var out = glob.doc.defaultView.getComputedStyle(i, E).getPropertyValue(\"color\");\n\t        return out == red ? null : out;\n\t    });\n\t    return toHex(color);\n\t},\n\thsbtoString = function () {\n\t    return \"hsb(\" + [this.h, this.s, this.b] + \")\";\n\t},\n\thsltoString = function () {\n\t    return \"hsl(\" + [this.h, this.s, this.l] + \")\";\n\t},\n\trgbtoString = function () {\n\t    return this.opacity == 1 || this.opacity == null ?\n\t            this.hex :\n\t            \"rgba(\" + [this.r, this.g, this.b, this.opacity] + \")\";\n\t},\n\tprepareRGB = function (r, g, b) {\n\t    if (g == null && is(r, \"object\") && \"r\" in r && \"g\" in r && \"b\" in r) {\n\t        b = r.b;\n\t        g = r.g;\n\t        r = r.r;\n\t    }\n\t    if (g == null && is(r, string)) {\n\t        var clr = Snap.getRGB(r);\n\t        r = clr.r;\n\t        g = clr.g;\n\t        b = clr.b;\n\t    }\n\t    if (r > 1 || g > 1 || b > 1) {\n\t        r /= 255;\n\t        g /= 255;\n\t        b /= 255;\n\t    }\n\t\n\t    return [r, g, b];\n\t},\n\tpackageRGB = function (r, g, b, o) {\n\t    r = math.round(r * 255);\n\t    g = math.round(g * 255);\n\t    b = math.round(b * 255);\n\t    var rgb = {\n\t        r: r,\n\t        g: g,\n\t        b: b,\n\t        opacity: is(o, \"finite\") ? o : 1,\n\t        hex: Snap.rgb(r, g, b),\n\t        toString: rgbtoString\n\t    };\n\t    is(o, \"finite\") && (rgb.opacity = o);\n\t    return rgb;\n\t};\n\t/*\\\n\t * Snap.color\n\t [ method ]\n\t **\n\t * Parses the color string and returns an object featuring the color's component values\n\t - clr (string) color string in one of the supported formats (see @Snap.getRGB)\n\t = (object) Combined RGB/HSB object in the following format:\n\t o {\n\t o     r (number) red,\n\t o     g (number) green,\n\t o     b (number) blue,\n\t o     hex (string) color in HTML/CSS format: #,\n\t o     error (boolean) `true` if string can't be parsed,\n\t o     h (number) hue,\n\t o     s (number) saturation,\n\t o     v (number) value (brightness),\n\t o     l (number) lightness\n\t o }\n\t\\*/\n\tSnap.color = function (clr) {\n\t    var rgb;\n\t    if (is(clr, \"object\") && \"h\" in clr && \"s\" in clr && \"b\" in clr) {\n\t        rgb = Snap.hsb2rgb(clr);\n\t        clr.r = rgb.r;\n\t        clr.g = rgb.g;\n\t        clr.b = rgb.b;\n\t        clr.opacity = 1;\n\t        clr.hex = rgb.hex;\n\t    } else if (is(clr, \"object\") && \"h\" in clr && \"s\" in clr && \"l\" in clr) {\n\t        rgb = Snap.hsl2rgb(clr);\n\t        clr.r = rgb.r;\n\t        clr.g = rgb.g;\n\t        clr.b = rgb.b;\n\t        clr.opacity = 1;\n\t        clr.hex = rgb.hex;\n\t    } else {\n\t        if (is(clr, \"string\")) {\n\t            clr = Snap.getRGB(clr);\n\t        }\n\t        if (is(clr, \"object\") && \"r\" in clr && \"g\" in clr && \"b\" in clr && !(\"error\" in clr)) {\n\t            rgb = Snap.rgb2hsl(clr);\n\t            clr.h = rgb.h;\n\t            clr.s = rgb.s;\n\t            clr.l = rgb.l;\n\t            rgb = Snap.rgb2hsb(clr);\n\t            clr.v = rgb.b;\n\t        } else {\n\t            clr = {hex: \"none\"};\n\t            clr.r = clr.g = clr.b = clr.h = clr.s = clr.v = clr.l = -1;\n\t            clr.error = 1;\n\t        }\n\t    }\n\t    clr.toString = rgbtoString;\n\t    return clr;\n\t};\n\t/*\\\n\t * Snap.hsb2rgb\n\t [ method ]\n\t **\n\t * Converts HSB values to an RGB object\n\t - h (number) hue\n\t - s (number) saturation\n\t - v (number) value or brightness\n\t = (object) RGB object in the following format:\n\t o {\n\t o     r (number) red,\n\t o     g (number) green,\n\t o     b (number) blue,\n\t o     hex (string) color in HTML/CSS format: #\n\t o }\n\t\\*/\n\tSnap.hsb2rgb = function (h, s, v, o) {\n\t    if (is(h, \"object\") && \"h\" in h && \"s\" in h && \"b\" in h) {\n\t        v = h.b;\n\t        s = h.s;\n\t        o = h.o;\n\t        h = h.h;\n\t    }\n\t    h *= 360;\n\t    var R, G, B, X, C;\n\t    h = (h % 360) / 60;\n\t    C = v * s;\n\t    X = C * (1 - abs(h % 2 - 1));\n\t    R = G = B = v - C;\n\t\n\t    h = ~~h;\n\t    R += [C, X, 0, 0, X, C][h];\n\t    G += [X, C, C, X, 0, 0][h];\n\t    B += [0, 0, X, C, C, X][h];\n\t    return packageRGB(R, G, B, o);\n\t};\n\t/*\\\n\t * Snap.hsl2rgb\n\t [ method ]\n\t **\n\t * Converts HSL values to an RGB object\n\t - h (number) hue\n\t - s (number) saturation\n\t - l (number) luminosity\n\t = (object) RGB object in the following format:\n\t o {\n\t o     r (number) red,\n\t o     g (number) green,\n\t o     b (number) blue,\n\t o     hex (string) color in HTML/CSS format: #\n\t o }\n\t\\*/\n\tSnap.hsl2rgb = function (h, s, l, o) {\n\t    if (is(h, \"object\") && \"h\" in h && \"s\" in h && \"l\" in h) {\n\t        l = h.l;\n\t        s = h.s;\n\t        h = h.h;\n\t    }\n\t    if (h > 1 || s > 1 || l > 1) {\n\t        h /= 360;\n\t        s /= 100;\n\t        l /= 100;\n\t    }\n\t    h *= 360;\n\t    var R, G, B, X, C;\n\t    h = (h % 360) / 60;\n\t    C = 2 * s * (l < .5 ? l : 1 - l);\n\t    X = C * (1 - abs(h % 2 - 1));\n\t    R = G = B = l - C / 2;\n\t\n\t    h = ~~h;\n\t    R += [C, X, 0, 0, X, C][h];\n\t    G += [X, C, C, X, 0, 0][h];\n\t    B += [0, 0, X, C, C, X][h];\n\t    return packageRGB(R, G, B, o);\n\t};\n\t/*\\\n\t * Snap.rgb2hsb\n\t [ method ]\n\t **\n\t * Converts RGB values to an HSB object\n\t - r (number) red\n\t - g (number) green\n\t - b (number) blue\n\t = (object) HSB object in the following format:\n\t o {\n\t o     h (number) hue,\n\t o     s (number) saturation,\n\t o     b (number) brightness\n\t o }\n\t\\*/\n\tSnap.rgb2hsb = function (r, g, b) {\n\t    b = prepareRGB(r, g, b);\n\t    r = b[0];\n\t    g = b[1];\n\t    b = b[2];\n\t\n\t    var H, S, V, C;\n\t    V = mmax(r, g, b);\n\t    C = V - mmin(r, g, b);\n\t    H = (C == 0 ? null :\n\t         V == r ? (g - b) / C :\n\t         V == g ? (b - r) / C + 2 :\n\t                  (r - g) / C + 4\n\t        );\n\t    H = ((H + 360) % 6) * 60 / 360;\n\t    S = C == 0 ? 0 : C / V;\n\t    return {h: H, s: S, b: V, toString: hsbtoString};\n\t};\n\t/*\\\n\t * Snap.rgb2hsl\n\t [ method ]\n\t **\n\t * Converts RGB values to an HSL object\n\t - r (number) red\n\t - g (number) green\n\t - b (number) blue\n\t = (object) HSL object in the following format:\n\t o {\n\t o     h (number) hue,\n\t o     s (number) saturation,\n\t o     l (number) luminosity\n\t o }\n\t\\*/\n\tSnap.rgb2hsl = function (r, g, b) {\n\t    b = prepareRGB(r, g, b);\n\t    r = b[0];\n\t    g = b[1];\n\t    b = b[2];\n\t\n\t    var H, S, L, M, m, C;\n\t    M = mmax(r, g, b);\n\t    m = mmin(r, g, b);\n\t    C = M - m;\n\t    H = (C == 0 ? null :\n\t         M == r ? (g - b) / C :\n\t         M == g ? (b - r) / C + 2 :\n\t                  (r - g) / C + 4);\n\t    H = ((H + 360) % 6) * 60 / 360;\n\t    L = (M + m) / 2;\n\t    S = (C == 0 ? 0 :\n\t         L < .5 ? C / (2 * L) :\n\t                  C / (2 - 2 * L));\n\t    return {h: H, s: S, l: L, toString: hsltoString};\n\t};\n\t\n\t// Transformations\n\t/*\\\n\t * Snap.parsePathString\n\t [ method ]\n\t **\n\t * Utility method\n\t **\n\t * Parses given path string into an array of arrays of path segments\n\t - pathString (string|array) path string or array of segments (in the last case it is returned straight away)\n\t = (array) array of segments\n\t\\*/\n\tSnap.parsePathString = function (pathString) {\n\t    if (!pathString) {\n\t        return null;\n\t    }\n\t    var pth = Snap.path(pathString);\n\t    if (pth.arr) {\n\t        return Snap.path.clone(pth.arr);\n\t    }\n\t\n\t    var paramCounts = {a: 7, c: 6, o: 2, h: 1, l: 2, m: 2, r: 4, q: 4, s: 4, t: 2, v: 1, u: 3, z: 0},\n\t        data = [];\n\t    if (is(pathString, \"array\") && is(pathString[0], \"array\")) { // rough assumption\n\t        data = Snap.path.clone(pathString);\n\t    }\n\t    if (!data.length) {\n\t        Str(pathString).replace(pathCommand, function (a, b, c) {\n\t            var params = [],\n\t                name = b.toLowerCase();\n\t            c.replace(pathValues, function (a, b) {\n\t                b && params.push(+b);\n\t            });\n\t            if (name == \"m\" && params.length > 2) {\n\t                data.push([b].concat(params.splice(0, 2)));\n\t                name = \"l\";\n\t                b = b == \"m\" ? \"l\" : \"L\";\n\t            }\n\t            if (name == \"o\" && params.length == 1) {\n\t                data.push([b, params[0]]);\n\t            }\n\t            if (name == \"r\") {\n\t                data.push([b].concat(params));\n\t            } else while (params.length >= paramCounts[name]) {\n\t                data.push([b].concat(params.splice(0, paramCounts[name])));\n\t                if (!paramCounts[name]) {\n\t                    break;\n\t                }\n\t            }\n\t        });\n\t    }\n\t    data.toString = Snap.path.toString;\n\t    pth.arr = Snap.path.clone(data);\n\t    return data;\n\t};\n\t/*\\\n\t * Snap.parseTransformString\n\t [ method ]\n\t **\n\t * Utility method\n\t **\n\t * Parses given transform string into an array of transformations\n\t - TString (string|array) transform string or array of transformations (in the last case it is returned straight away)\n\t = (array) array of transformations\n\t\\*/\n\tvar parseTransformString = Snap.parseTransformString = function (TString) {\n\t    if (!TString) {\n\t        return null;\n\t    }\n\t    var paramCounts = {r: 3, s: 4, t: 2, m: 6},\n\t        data = [];\n\t    if (is(TString, \"array\") && is(TString[0], \"array\")) { // rough assumption\n\t        data = Snap.path.clone(TString);\n\t    }\n\t    if (!data.length) {\n\t        Str(TString).replace(tCommand, function (a, b, c) {\n\t            var params = [],\n\t                name = b.toLowerCase();\n\t            c.replace(pathValues, function (a, b) {\n\t                b && params.push(+b);\n\t            });\n\t            data.push([b].concat(params));\n\t        });\n\t    }\n\t    data.toString = Snap.path.toString;\n\t    return data;\n\t};\n\tfunction svgTransform2string(tstr) {\n\t    var res = [];\n\t    tstr = tstr.replace(/(?:^|\\s)(\\w+)\\(([^)]+)\\)/g, function (all, name, params) {\n\t        params = params.split(/\\s*,\\s*|\\s+/);\n\t        if (name == \"rotate\" && params.length == 1) {\n\t            params.push(0, 0);\n\t        }\n\t        if (name == \"scale\") {\n\t            if (params.length > 2) {\n\t                params = params.slice(0, 2);\n\t            } else if (params.length == 2) {\n\t                params.push(0, 0);\n\t            }\n\t            if (params.length == 1) {\n\t                params.push(params[0], 0, 0);\n\t            }\n\t        }\n\t        if (name == \"skewX\") {\n\t            res.push([\"m\", 1, 0, math.tan(rad(params[0])), 1, 0, 0]);\n\t        } else if (name == \"skewY\") {\n\t            res.push([\"m\", 1, math.tan(rad(params[0])), 0, 1, 0, 0]);\n\t        } else {\n\t            res.push([name.charAt(0)].concat(params));\n\t        }\n\t        return all;\n\t    });\n\t    return res;\n\t}\n\tSnap._.svgTransform2string = svgTransform2string;\n\tSnap._.rgTransform = /^[a-z][\\s]*-?\\.?\\d/i;\n\tfunction transform2matrix(tstr, bbox) {\n\t    var tdata = parseTransformString(tstr),\n\t        m = new Snap.Matrix;\n\t    if (tdata) {\n\t        for (var i = 0, ii = tdata.length; i < ii; i++) {\n\t            var t = tdata[i],\n\t                tlen = t.length,\n\t                command = Str(t[0]).toLowerCase(),\n\t                absolute = t[0] != command,\n\t                inver = absolute ? m.invert() : 0,\n\t                x1,\n\t                y1,\n\t                x2,\n\t                y2,\n\t                bb;\n\t            if (command == \"t\" && tlen == 2){\n\t                m.translate(t[1], 0);\n\t            } else if (command == \"t\" && tlen == 3) {\n\t                if (absolute) {\n\t                    x1 = inver.x(0, 0);\n\t                    y1 = inver.y(0, 0);\n\t                    x2 = inver.x(t[1], t[2]);\n\t                    y2 = inver.y(t[1], t[2]);\n\t                    m.translate(x2 - x1, y2 - y1);\n\t                } else {\n\t                    m.translate(t[1], t[2]);\n\t                }\n\t            } else if (command == \"r\") {\n\t                if (tlen == 2) {\n\t                    bb = bb || bbox;\n\t                    m.rotate(t[1], bb.x + bb.width / 2, bb.y + bb.height / 2);\n\t                } else if (tlen == 4) {\n\t                    if (absolute) {\n\t                        x2 = inver.x(t[2], t[3]);\n\t                        y2 = inver.y(t[2], t[3]);\n\t                        m.rotate(t[1], x2, y2);\n\t                    } else {\n\t                        m.rotate(t[1], t[2], t[3]);\n\t                    }\n\t                }\n\t            } else if (command == \"s\") {\n\t                if (tlen == 2 || tlen == 3) {\n\t                    bb = bb || bbox;\n\t                    m.scale(t[1], t[tlen - 1], bb.x + bb.width / 2, bb.y + bb.height / 2);\n\t                } else if (tlen == 4) {\n\t                    if (absolute) {\n\t                        x2 = inver.x(t[2], t[3]);\n\t                        y2 = inver.y(t[2], t[3]);\n\t                        m.scale(t[1], t[1], x2, y2);\n\t                    } else {\n\t                        m.scale(t[1], t[1], t[2], t[3]);\n\t                    }\n\t                } else if (tlen == 5) {\n\t                    if (absolute) {\n\t                        x2 = inver.x(t[3], t[4]);\n\t                        y2 = inver.y(t[3], t[4]);\n\t                        m.scale(t[1], t[2], x2, y2);\n\t                    } else {\n\t                        m.scale(t[1], t[2], t[3], t[4]);\n\t                    }\n\t                }\n\t            } else if (command == \"m\" && tlen == 7) {\n\t                m.add(t[1], t[2], t[3], t[4], t[5], t[6]);\n\t            }\n\t        }\n\t    }\n\t    return m;\n\t}\n\tSnap._.transform2matrix = transform2matrix;\n\tSnap._unit2px = unit2px;\n\tvar contains = glob.doc.contains || glob.doc.compareDocumentPosition ?\n\t    function (a, b) {\n\t        var adown = a.nodeType == 9 ? a.documentElement : a,\n\t            bup = b && b.parentNode;\n\t            return a == bup || !!(bup && bup.nodeType == 1 && (\n\t                adown.contains ?\n\t                    adown.contains(bup) :\n\t                    a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16\n\t            ));\n\t    } :\n\t    function (a, b) {\n\t        if (b) {\n\t            while (b) {\n\t                b = b.parentNode;\n\t                if (b == a) {\n\t                    return true;\n\t                }\n\t            }\n\t        }\n\t        return false;\n\t    };\n\tfunction getSomeDefs(el) {\n\t    var p = (el.node.ownerSVGElement && wrap(el.node.ownerSVGElement)) ||\n\t            (el.node.parentNode && wrap(el.node.parentNode)) ||\n\t            Snap.select(\"svg\") ||\n\t            Snap(0, 0),\n\t        pdefs = p.select(\"defs\"),\n\t        defs  = pdefs == null ? false : pdefs.node;\n\t    if (!defs) {\n\t        defs = make(\"defs\", p.node).node;\n\t    }\n\t    return defs;\n\t}\n\tfunction getSomeSVG(el) {\n\t    return el.node.ownerSVGElement && wrap(el.node.ownerSVGElement) || Snap.select(\"svg\");\n\t}\n\tSnap._.getSomeDefs = getSomeDefs;\n\tSnap._.getSomeSVG = getSomeSVG;\n\tfunction unit2px(el, name, value) {\n\t    var svg = getSomeSVG(el).node,\n\t        out = {},\n\t        mgr = svg.querySelector(\".svg---mgr\");\n\t    if (!mgr) {\n\t        mgr = $(\"rect\");\n\t        $(mgr, {x: -9e9, y: -9e9, width: 10, height: 10, \"class\": \"svg---mgr\", fill: \"none\"});\n\t        svg.appendChild(mgr);\n\t    }\n\t    function getW(val) {\n\t        if (val == null) {\n\t            return E;\n\t        }\n\t        if (val == +val) {\n\t            return val;\n\t        }\n\t        $(mgr, {width: val});\n\t        try {\n\t            return mgr.getBBox().width;\n\t        } catch (e) {\n\t            return 0;\n\t        }\n\t    }\n\t    function getH(val) {\n\t        if (val == null) {\n\t            return E;\n\t        }\n\t        if (val == +val) {\n\t            return val;\n\t        }\n\t        $(mgr, {height: val});\n\t        try {\n\t            return mgr.getBBox().height;\n\t        } catch (e) {\n\t            return 0;\n\t        }\n\t    }\n\t    function set(nam, f) {\n\t        if (name == null) {\n\t            out[nam] = f(el.attr(nam) || 0);\n\t        } else if (nam == name) {\n\t            out = f(value == null ? el.attr(nam) || 0 : value);\n\t        }\n\t    }\n\t    switch (el.type) {\n\t        case \"rect\":\n\t            set(\"rx\", getW);\n\t            set(\"ry\", getH);\n\t        case \"image\":\n\t            set(\"width\", getW);\n\t            set(\"height\", getH);\n\t        case \"text\":\n\t            set(\"x\", getW);\n\t            set(\"y\", getH);\n\t        break;\n\t        case \"circle\":\n\t            set(\"cx\", getW);\n\t            set(\"cy\", getH);\n\t            set(\"r\", getW);\n\t        break;\n\t        case \"ellipse\":\n\t            set(\"cx\", getW);\n\t            set(\"cy\", getH);\n\t            set(\"rx\", getW);\n\t            set(\"ry\", getH);\n\t        break;\n\t        case \"line\":\n\t            set(\"x1\", getW);\n\t            set(\"x2\", getW);\n\t            set(\"y1\", getH);\n\t            set(\"y2\", getH);\n\t        break;\n\t        case \"marker\":\n\t            set(\"refX\", getW);\n\t            set(\"markerWidth\", getW);\n\t            set(\"refY\", getH);\n\t            set(\"markerHeight\", getH);\n\t        break;\n\t        case \"radialGradient\":\n\t            set(\"fx\", getW);\n\t            set(\"fy\", getH);\n\t        break;\n\t        case \"tspan\":\n\t            set(\"dx\", getW);\n\t            set(\"dy\", getH);\n\t        break;\n\t        default:\n\t            set(name, getW);\n\t    }\n\t    svg.removeChild(mgr);\n\t    return out;\n\t}\n\t/*\\\n\t * Snap.select\n\t [ method ]\n\t **\n\t * Wraps a DOM element specified by CSS selector as @Element\n\t - query (string) CSS selector of the element\n\t = (Element) the current element\n\t\\*/\n\tSnap.select = function (query) {\n\t    query = Str(query).replace(/([^\\\\]):/g, \"$1\\\\:\");\n\t    return wrap(glob.doc.querySelector(query));\n\t};\n\t/*\\\n\t * Snap.selectAll\n\t [ method ]\n\t **\n\t * Wraps DOM elements specified by CSS selector as set or array of @Element\n\t - query (string) CSS selector of the element\n\t = (Element) the current element\n\t\\*/\n\tSnap.selectAll = function (query) {\n\t    var nodelist = glob.doc.querySelectorAll(query),\n\t        set = (Snap.set || Array)();\n\t    for (var i = 0; i < nodelist.length; i++) {\n\t        set.push(wrap(nodelist[i]));\n\t    }\n\t    return set;\n\t};\n\t\n\tfunction add2group(list) {\n\t    if (!is(list, \"array\")) {\n\t        list = Array.prototype.slice.call(arguments, 0);\n\t    }\n\t    var i = 0,\n\t        j = 0,\n\t        node = this.node;\n\t    while (this[i]) delete this[i++];\n\t    for (i = 0; i < list.length; i++) {\n\t        if (list[i].type == \"set\") {\n\t            list[i].forEach(function (el) {\n\t                node.appendChild(el.node);\n\t            });\n\t        } else {\n\t            node.appendChild(list[i].node);\n\t        }\n\t    }\n\t    var children = node.childNodes;\n\t    for (i = 0; i < children.length; i++) {\n\t        this[j++] = wrap(children[i]);\n\t    }\n\t    return this;\n\t}\n\t// Hub garbage collector every 10s\n\tsetInterval(function () {\n\t    for (var key in hub) if (hub[has](key)) {\n\t        var el = hub[key],\n\t            node = el.node;\n\t        if (el.type != \"svg\" && !node.ownerSVGElement || el.type == \"svg\" && (!node.parentNode || \"ownerSVGElement\" in node.parentNode && !node.ownerSVGElement)) {\n\t            delete hub[key];\n\t        }\n\t    }\n\t}, 1e4);\n\tfunction Element(el) {\n\t    if (el.snap in hub) {\n\t        return hub[el.snap];\n\t    }\n\t    var svg;\n\t    try {\n\t        svg = el.ownerSVGElement;\n\t    } catch(e) {}\n\t    /*\\\n\t     * Element.node\n\t     [ property (object) ]\n\t     **\n\t     * Gives you a reference to the DOM object, so you can assign event handlers or just mess around.\n\t     > Usage\n\t     | // draw a circle at coordinate 10,10 with radius of 10\n\t     | var c = paper.circle(10, 10, 10);\n\t     | c.node.onclick = function () {\n\t     |     c.attr(\"fill\", \"red\");\n\t     | };\n\t    \\*/\n\t    this.node = el;\n\t    if (svg) {\n\t        this.paper = new Paper(svg);\n\t    }\n\t    /*\\\n\t     * Element.type\n\t     [ property (string) ]\n\t     **\n\t     * SVG tag name of the given element.\n\t    \\*/\n\t    this.type = el.tagName || el.nodeName;\n\t    var id = this.id = ID(this);\n\t    this.anims = {};\n\t    this._ = {\n\t        transform: []\n\t    };\n\t    el.snap = id;\n\t    hub[id] = this;\n\t    if (this.type == \"g\") {\n\t        this.add = add2group;\n\t    }\n\t    if (this.type in {g: 1, mask: 1, pattern: 1, symbol: 1}) {\n\t        for (var method in Paper.prototype) if (Paper.prototype[has](method)) {\n\t            this[method] = Paper.prototype[method];\n\t        }\n\t    }\n\t}\n\t   /*\\\n\t     * Element.attr\n\t     [ method ]\n\t     **\n\t     * Gets or sets given attributes of the element.\n\t     **\n\t     - params (object) contains key-value pairs of attributes you want to set\n\t     * or\n\t     - param (string) name of the attribute\n\t     = (Element) the current element\n\t     * or\n\t     = (string) value of attribute\n\t     > Usage\n\t     | el.attr({\n\t     |     fill: \"#fc0\",\n\t     |     stroke: \"#000\",\n\t     |     strokeWidth: 2, // CamelCase...\n\t     |     \"fill-opacity\": 0.5, // or dash-separated names\n\t     |     width: \"*=2\" // prefixed values\n\t     | });\n\t     | console.log(el.attr(\"fill\")); // #fc0\n\t     * Prefixed values in format `\"+=10\"` supported. All four operations\n\t     * (`+`, `-`, `*` and `/`) could be used. Optionally you can use units for `+`\n\t     * and `-`: `\"+=2em\"`.\n\t    \\*/\n\t    Element.prototype.attr = function (params, value) {\n\t        var el = this,\n\t            node = el.node;\n\t        if (!params) {\n\t            if (node.nodeType != 1) {\n\t                return {\n\t                    text: node.nodeValue\n\t                };\n\t            }\n\t            var attr = node.attributes,\n\t                out = {};\n\t            for (var i = 0, ii = attr.length; i < ii; i++) {\n\t                out[attr[i].nodeName] = attr[i].nodeValue;\n\t            }\n\t            return out;\n\t        }\n\t        if (is(params, \"string\")) {\n\t            if (arguments.length > 1) {\n\t                var json = {};\n\t                json[params] = value;\n\t                params = json;\n\t            } else {\n\t                return eve(\"snap.util.getattr.\" + params, el).firstDefined();\n\t            }\n\t        }\n\t        for (var att in params) {\n\t            if (params[has](att)) {\n\t                eve(\"snap.util.attr.\" + att, el, params[att]);\n\t            }\n\t        }\n\t        return el;\n\t    };\n\t/*\\\n\t * Snap.parse\n\t [ method ]\n\t **\n\t * Parses SVG fragment and converts it into a @Fragment\n\t **\n\t - svg (string) SVG string\n\t = (Fragment) the @Fragment\n\t\\*/\n\tSnap.parse = function (svg) {\n\t    var f = glob.doc.createDocumentFragment(),\n\t        full = true,\n\t        div = glob.doc.createElement(\"div\");\n\t    svg = Str(svg);\n\t    if (!svg.match(/^\\s*<\\s*svg(?:\\s|>)/)) {\n\t        svg = \"<svg>\" + svg + \"</svg>\";\n\t        full = false;\n\t    }\n\t    div.innerHTML = svg;\n\t    svg = div.getElementsByTagName(\"svg\")[0];\n\t    if (svg) {\n\t        if (full) {\n\t            f = svg;\n\t        } else {\n\t            while (svg.firstChild) {\n\t                f.appendChild(svg.firstChild);\n\t            }\n\t        }\n\t    }\n\t    return new Fragment(f);\n\t};\n\tfunction Fragment(frag) {\n\t    this.node = frag;\n\t}\n\t/*\\\n\t * Snap.fragment\n\t [ method ]\n\t **\n\t * Creates a DOM fragment from a given list of elements or strings\n\t **\n\t - varargs () SVG string\n\t = (Fragment) the @Fragment\n\t\\*/\n\tSnap.fragment = function () {\n\t    var args = Array.prototype.slice.call(arguments, 0),\n\t        f = glob.doc.createDocumentFragment();\n\t    for (var i = 0, ii = args.length; i < ii; i++) {\n\t        var item = args[i];\n\t        if (item.node && item.node.nodeType) {\n\t            f.appendChild(item.node);\n\t        }\n\t        if (item.nodeType) {\n\t            f.appendChild(item);\n\t        }\n\t        if (typeof item == \"string\") {\n\t            f.appendChild(Snap.parse(item).node);\n\t        }\n\t    }\n\t    return new Fragment(f);\n\t};\n\t\n\tfunction make(name, parent) {\n\t    var res = $(name);\n\t    parent.appendChild(res);\n\t    var el = wrap(res);\n\t    return el;\n\t}\n\tfunction Paper(w, h) {\n\t    var res,\n\t        desc,\n\t        defs,\n\t        proto = Paper.prototype;\n\t    if (w && w.tagName == \"svg\") {\n\t        if (w.snap in hub) {\n\t            return hub[w.snap];\n\t        }\n\t        var doc = w.ownerDocument;\n\t        res = new Element(w);\n\t        desc = w.getElementsByTagName(\"desc\")[0];\n\t        defs = w.getElementsByTagName(\"defs\")[0];\n\t        if (!desc) {\n\t            desc = $(\"desc\");\n\t            desc.appendChild(doc.createTextNode(\"Created with Snap\"));\n\t            res.node.appendChild(desc);\n\t        }\n\t        if (!defs) {\n\t            defs = $(\"defs\");\n\t            res.node.appendChild(defs);\n\t        }\n\t        res.defs = defs;\n\t        for (var key in proto) if (proto[has](key)) {\n\t            res[key] = proto[key];\n\t        }\n\t        res.paper = res.root = res;\n\t    } else {\n\t        res = make(\"svg\", glob.doc.body);\n\t        $(res.node, {\n\t            height: h,\n\t            version: 1.1,\n\t            width: w,\n\t            xmlns: xmlns\n\t        });\n\t    }\n\t    return res;\n\t}\n\tfunction wrap(dom) {\n\t    if (!dom) {\n\t        return dom;\n\t    }\n\t    if (dom instanceof Element || dom instanceof Fragment) {\n\t        return dom;\n\t    }\n\t    if (dom.tagName && dom.tagName.toLowerCase() == \"svg\") {\n\t        return new Paper(dom);\n\t    }\n\t    if (dom.tagName && dom.tagName.toLowerCase() == \"object\" && dom.type == \"image/svg+xml\") {\n\t        return new Paper(dom.contentDocument.getElementsByTagName(\"svg\")[0]);\n\t    }\n\t    return new Element(dom);\n\t}\n\t\n\tSnap._.make = make;\n\tSnap._.wrap = wrap;\n\t/*\\\n\t * Paper.el\n\t [ method ]\n\t **\n\t * Creates an element on paper with a given name and no attributes\n\t **\n\t - name (string) tag name\n\t - attr (object) attributes\n\t = (Element) the current element\n\t > Usage\n\t | var c = paper.circle(10, 10, 10); // is the same as...\n\t | var c = paper.el(\"circle\").attr({\n\t |     cx: 10,\n\t |     cy: 10,\n\t |     r: 10\n\t | });\n\t | // and the same as\n\t | var c = paper.el(\"circle\", {\n\t |     cx: 10,\n\t |     cy: 10,\n\t |     r: 10\n\t | });\n\t\\*/\n\tPaper.prototype.el = function (name, attr) {\n\t    var el = make(name, this.node);\n\t    attr && el.attr(attr);\n\t    return el;\n\t};\n\t/*\\\n\t * Element.children\n\t [ method ]\n\t **\n\t * Returns array of all the children of the element.\n\t = (array) array of Elements\n\t\\*/\n\tElement.prototype.children = function () {\n\t    var out = [],\n\t        ch = this.node.childNodes;\n\t    for (var i = 0, ii = ch.length; i < ii; i++) {\n\t        out[i] = Snap(ch[i]);\n\t    }\n\t    return out;\n\t};\n\tfunction jsonFiller(root, o) {\n\t    for (var i = 0, ii = root.length; i < ii; i++) {\n\t        var item = {\n\t                type: root[i].type,\n\t                attr: root[i].attr()\n\t            },\n\t            children = root[i].children();\n\t        o.push(item);\n\t        if (children.length) {\n\t            jsonFiller(children, item.childNodes = []);\n\t        }\n\t    }\n\t}\n\t/*\\\n\t * Element.toJSON\n\t [ method ]\n\t **\n\t * Returns object representation of the given element and all its children.\n\t = (object) in format\n\t o {\n\t o     type (string) this.type,\n\t o     attr (object) attributes map,\n\t o     childNodes (array) optional array of children in the same format\n\t o }\n\t\\*/\n\tElement.prototype.toJSON = function () {\n\t    var out = [];\n\t    jsonFiller([this], out);\n\t    return out[0];\n\t};\n\t// default\n\teve.on(\"snap.util.getattr\", function () {\n\t    var att = eve.nt();\n\t    att = att.substring(att.lastIndexOf(\".\") + 1);\n\t    var css = att.replace(/[A-Z]/g, function (letter) {\n\t        return \"-\" + letter.toLowerCase();\n\t    });\n\t    if (cssAttr[has](css)) {\n\t        return this.node.ownerDocument.defaultView.getComputedStyle(this.node, null).getPropertyValue(css);\n\t    } else {\n\t        return $(this.node, att);\n\t    }\n\t});\n\tvar cssAttr = {\n\t    \"alignment-baseline\": 0,\n\t    \"baseline-shift\": 0,\n\t    \"clip\": 0,\n\t    \"clip-path\": 0,\n\t    \"clip-rule\": 0,\n\t    \"color\": 0,\n\t    \"color-interpolation\": 0,\n\t    \"color-interpolation-filters\": 0,\n\t    \"color-profile\": 0,\n\t    \"color-rendering\": 0,\n\t    \"cursor\": 0,\n\t    \"direction\": 0,\n\t    \"display\": 0,\n\t    \"dominant-baseline\": 0,\n\t    \"enable-background\": 0,\n\t    \"fill\": 0,\n\t    \"fill-opacity\": 0,\n\t    \"fill-rule\": 0,\n\t    \"filter\": 0,\n\t    \"flood-color\": 0,\n\t    \"flood-opacity\": 0,\n\t    \"font\": 0,\n\t    \"font-family\": 0,\n\t    \"font-size\": 0,\n\t    \"font-size-adjust\": 0,\n\t    \"font-stretch\": 0,\n\t    \"font-style\": 0,\n\t    \"font-variant\": 0,\n\t    \"font-weight\": 0,\n\t    \"glyph-orientation-horizontal\": 0,\n\t    \"glyph-orientation-vertical\": 0,\n\t    \"image-rendering\": 0,\n\t    \"kerning\": 0,\n\t    \"letter-spacing\": 0,\n\t    \"lighting-color\": 0,\n\t    \"marker\": 0,\n\t    \"marker-end\": 0,\n\t    \"marker-mid\": 0,\n\t    \"marker-start\": 0,\n\t    \"mask\": 0,\n\t    \"opacity\": 0,\n\t    \"overflow\": 0,\n\t    \"pointer-events\": 0,\n\t    \"shape-rendering\": 0,\n\t    \"stop-color\": 0,\n\t    \"stop-opacity\": 0,\n\t    \"stroke\": 0,\n\t    \"stroke-dasharray\": 0,\n\t    \"stroke-dashoffset\": 0,\n\t    \"stroke-linecap\": 0,\n\t    \"stroke-linejoin\": 0,\n\t    \"stroke-miterlimit\": 0,\n\t    \"stroke-opacity\": 0,\n\t    \"stroke-width\": 0,\n\t    \"text-anchor\": 0,\n\t    \"text-decoration\": 0,\n\t    \"text-rendering\": 0,\n\t    \"unicode-bidi\": 0,\n\t    \"visibility\": 0,\n\t    \"word-spacing\": 0,\n\t    \"writing-mode\": 0\n\t};\n\t\n\teve.on(\"snap.util.attr\", function (value) {\n\t    var att = eve.nt(),\n\t        attr = {};\n\t    att = att.substring(att.lastIndexOf(\".\") + 1);\n\t    attr[att] = value;\n\t    var style = att.replace(/-(\\w)/gi, function (all, letter) {\n\t            return letter.toUpperCase();\n\t        }),\n\t        css = att.replace(/[A-Z]/g, function (letter) {\n\t            return \"-\" + letter.toLowerCase();\n\t        });\n\t    if (cssAttr[has](css)) {\n\t        this.node.style[style] = value == null ? E : value;\n\t    } else {\n\t        $(this.node, attr);\n\t    }\n\t});\n\t(function (proto) {}(Paper.prototype));\n\t\n\t// simple ajax\n\t/*\\\n\t * Snap.ajax\n\t [ method ]\n\t **\n\t * Simple implementation of Ajax\n\t **\n\t - url (string) URL\n\t - postData (object|string) data for post request\n\t - callback (function) callback\n\t - scope (object) #optional scope of callback\n\t * or\n\t - url (string) URL\n\t - callback (function) callback\n\t - scope (object) #optional scope of callback\n\t = (XMLHttpRequest) the XMLHttpRequest object, just in case\n\t\\*/\n\tSnap.ajax = function (url, postData, callback, scope){\n\t    var req = new XMLHttpRequest,\n\t        id = ID();\n\t    if (req) {\n\t        if (is(postData, \"function\")) {\n\t            scope = callback;\n\t            callback = postData;\n\t            postData = null;\n\t        } else if (is(postData, \"object\")) {\n\t            var pd = [];\n\t            for (var key in postData) if (postData.hasOwnProperty(key)) {\n\t                pd.push(encodeURIComponent(key) + \"=\" + encodeURIComponent(postData[key]));\n\t            }\n\t            postData = pd.join(\"&\");\n\t        }\n\t        req.open((postData ? \"POST\" : \"GET\"), url, true);\n\t        if (postData) {\n\t            req.setRequestHeader(\"X-Requested-With\", \"XMLHttpRequest\");\n\t            req.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\");\n\t        }\n\t        if (callback) {\n\t            eve.once(\"snap.ajax.\" + id + \".0\", callback);\n\t            eve.once(\"snap.ajax.\" + id + \".200\", callback);\n\t            eve.once(\"snap.ajax.\" + id + \".304\", callback);\n\t        }\n\t        req.onreadystatechange = function() {\n\t            if (req.readyState != 4) return;\n\t            eve(\"snap.ajax.\" + id + \".\" + req.status, scope, req);\n\t        };\n\t        if (req.readyState == 4) {\n\t            return req;\n\t        }\n\t        req.send(postData);\n\t        return req;\n\t    }\n\t};\n\t/*\\\n\t * Snap.load\n\t [ method ]\n\t **\n\t * Loads external SVG file as a @Fragment (see @Snap.ajax for more advanced AJAX)\n\t **\n\t - url (string) URL\n\t - callback (function) callback\n\t - scope (object) #optional scope of callback\n\t\\*/\n\tSnap.load = function (url, callback, scope) {\n\t    Snap.ajax(url, function (req) {\n\t        var f = Snap.parse(req.responseText);\n\t        scope ? callback.call(scope, f) : callback(f);\n\t    });\n\t};\n\tvar getOffset = function (elem) {\n\t    var box = elem.getBoundingClientRect(),\n\t        doc = elem.ownerDocument,\n\t        body = doc.body,\n\t        docElem = doc.documentElement,\n\t        clientTop = docElem.clientTop || body.clientTop || 0, clientLeft = docElem.clientLeft || body.clientLeft || 0,\n\t        top  = box.top  + (g.win.pageYOffset || docElem.scrollTop || body.scrollTop ) - clientTop,\n\t        left = box.left + (g.win.pageXOffset || docElem.scrollLeft || body.scrollLeft) - clientLeft;\n\t    return {\n\t        y: top,\n\t        x: left\n\t    };\n\t};\n\t/*\\\n\t * Snap.getElementByPoint\n\t [ method ]\n\t **\n\t * Returns you topmost element under given point.\n\t **\n\t = (object) Snap element object\n\t - x (number) x coordinate from the top left corner of the window\n\t - y (number) y coordinate from the top left corner of the window\n\t > Usage\n\t | Snap.getElementByPoint(mouseX, mouseY).attr({stroke: \"#f00\"});\n\t\\*/\n\tSnap.getElementByPoint = function (x, y) {\n\t    var paper = this,\n\t        svg = paper.canvas,\n\t        target = glob.doc.elementFromPoint(x, y);\n\t    if (glob.win.opera && target.tagName == \"svg\") {\n\t        var so = getOffset(target),\n\t            sr = target.createSVGRect();\n\t        sr.x = x - so.x;\n\t        sr.y = y - so.y;\n\t        sr.width = sr.height = 1;\n\t        var hits = target.getIntersectionList(sr, null);\n\t        if (hits.length) {\n\t            target = hits[hits.length - 1];\n\t        }\n\t    }\n\t    if (!target) {\n\t        return null;\n\t    }\n\t    return wrap(target);\n\t};\n\t/*\\\n\t * Snap.plugin\n\t [ method ]\n\t **\n\t * Let you write plugins. You pass in a function with five arguments, like this:\n\t | Snap.plugin(function (Snap, Element, Paper, global, Fragment) {\n\t |     Snap.newmethod = function () {};\n\t |     Element.prototype.newmethod = function () {};\n\t |     Paper.prototype.newmethod = function () {};\n\t | });\n\t * Inside the function you have access to all main objects (and their\n\t * prototypes). This allow you to extend anything you want.\n\t **\n\t - f (function) your plugin body\n\t\\*/\n\tSnap.plugin = function (f) {\n\t    f(Snap, Element, Paper, glob, Fragment);\n\t};\n\tglob.win.Snap = Snap;\n\treturn Snap;\n\t}(window || this));\n\t\n\t// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n\t//\n\t// Licensed under the Apache License, Version 2.0 (the \"License\");\n\t// you may not use this file except in compliance with the License.\n\t// You may obtain a copy of the License at\n\t//\n\t// http://www.apache.org/licenses/LICENSE-2.0\n\t//\n\t// Unless required by applicable law or agreed to in writing, software\n\t// distributed under the License is distributed on an \"AS IS\" BASIS,\n\t// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t// See the License for the specific language governing permissions and\n\t// limitations under the License.\n\tSnap.plugin(function (Snap, Element, Paper, glob, Fragment) {\n\t    var elproto = Element.prototype,\n\t        is = Snap.is,\n\t        Str = String,\n\t        unit2px = Snap._unit2px,\n\t        $ = Snap._.$,\n\t        make = Snap._.make,\n\t        getSomeDefs = Snap._.getSomeDefs,\n\t        has = \"hasOwnProperty\",\n\t        wrap = Snap._.wrap;\n\t    /*\\\n\t     * Element.getBBox\n\t     [ method ]\n\t     **\n\t     * Returns the bounding box descriptor for the given element\n\t     **\n\t     = (object) bounding box descriptor:\n\t     o {\n\t     o     cx: (number) x of the center,\n\t     o     cy: (number) x of the center,\n\t     o     h: (number) height,\n\t     o     height: (number) height,\n\t     o     path: (string) path command for the box,\n\t     o     r0: (number) radius of a circle that fully encloses the box,\n\t     o     r1: (number) radius of the smallest circle that can be enclosed,\n\t     o     r2: (number) radius of the largest circle that can be enclosed,\n\t     o     vb: (string) box as a viewbox command,\n\t     o     w: (number) width,\n\t     o     width: (number) width,\n\t     o     x2: (number) x of the right side,\n\t     o     x: (number) x of the left side,\n\t     o     y2: (number) y of the bottom edge,\n\t     o     y: (number) y of the top edge\n\t     o }\n\t    \\*/\n\t    elproto.getBBox = function (isWithoutTransform) {\n\t        if (!Snap.Matrix || !Snap.path) {\n\t            return this.node.getBBox();\n\t        }\n\t        var el = this,\n\t            m = new Snap.Matrix;\n\t        if (el.removed) {\n\t            return Snap._.box();\n\t        }\n\t        while (el.type == \"use\") {\n\t            if (!isWithoutTransform) {\n\t                m = m.add(el.transform().localMatrix.translate(el.attr(\"x\") || 0, el.attr(\"y\") || 0));\n\t            }\n\t            if (el.original) {\n\t                el = el.original;\n\t            } else {\n\t                var href = el.attr(\"xlink:href\");\n\t                el = el.original = el.node.ownerDocument.getElementById(href.substring(href.indexOf(\"#\") + 1));\n\t            }\n\t        }\n\t        var _ = el._,\n\t            pathfinder = Snap.path.get[el.type] || Snap.path.get.deflt;\n\t        try {\n\t            if (isWithoutTransform) {\n\t                _.bboxwt = pathfinder ? Snap.path.getBBox(el.realPath = pathfinder(el)) : Snap._.box(el.node.getBBox());\n\t                return Snap._.box(_.bboxwt);\n\t            } else {\n\t                el.realPath = pathfinder(el);\n\t                el.matrix = el.transform().localMatrix;\n\t                _.bbox = Snap.path.getBBox(Snap.path.map(el.realPath, m.add(el.matrix)));\n\t                return Snap._.box(_.bbox);\n\t            }\n\t        } catch (e) {\n\t            // Firefox doesnt give you bbox of hidden element\n\t            return Snap._.box();\n\t        }\n\t    };\n\t    var propString = function () {\n\t        return this.string;\n\t    };\n\t    function extractTransform(el, tstr) {\n\t        if (tstr == null) {\n\t            var doReturn = true;\n\t            if (el.type == \"linearGradient\" || el.type == \"radialGradient\") {\n\t                tstr = el.node.getAttribute(\"gradientTransform\");\n\t            } else if (el.type == \"pattern\") {\n\t                tstr = el.node.getAttribute(\"patternTransform\");\n\t            } else {\n\t                tstr = el.node.getAttribute(\"transform\");\n\t            }\n\t            if (!tstr) {\n\t                return new Snap.Matrix;\n\t            }\n\t            tstr = Snap._.svgTransform2string(tstr);\n\t        } else {\n\t            if (!Snap._.rgTransform.test(tstr)) {\n\t                tstr = Snap._.svgTransform2string(tstr);\n\t            } else {\n\t                tstr = Str(tstr).replace(/\\.{3}|\\u2026/g, el._.transform || E);\n\t            }\n\t            if (is(tstr, \"array\")) {\n\t                tstr = Snap.path ? Snap.path.toString.call(tstr) : Str(tstr);\n\t            }\n\t            el._.transform = tstr;\n\t        }\n\t        var m = Snap._.transform2matrix(tstr, el.getBBox(1));\n\t        if (doReturn) {\n\t            return m;\n\t        } else {\n\t            el.matrix = m;\n\t        }\n\t    }\n\t    /*\\\n\t     * Element.transform\n\t     [ method ]\n\t     **\n\t     * Gets or sets transformation of the element\n\t     **\n\t     - tstr (string) transform string in Snap or SVG format\n\t     = (Element) the current element\n\t     * or\n\t     = (object) transformation descriptor:\n\t     o {\n\t     o     string (string) transform string,\n\t     o     globalMatrix (Matrix) matrix of all transformations applied to element or its parents,\n\t     o     localMatrix (Matrix) matrix of transformations applied only to the element,\n\t     o     diffMatrix (Matrix) matrix of difference between global and local transformations,\n\t     o     global (string) global transformation as string,\n\t     o     local (string) local transformation as string,\n\t     o     toString (function) returns `string` property\n\t     o }\n\t    \\*/\n\t    elproto.transform = function (tstr) {\n\t        var _ = this._;\n\t        if (tstr == null) {\n\t            var papa = this,\n\t                global = new Snap.Matrix(this.node.getCTM()),\n\t                local = extractTransform(this),\n\t                ms = [local],\n\t                m = new Snap.Matrix,\n\t                i,\n\t                localString = local.toTransformString(),\n\t                string = Str(local) == Str(this.matrix) ?\n\t                            Str(_.transform) : localString;\n\t            while (papa.type != \"svg\" && (papa = papa.parent())) {\n\t                ms.push(extractTransform(papa));\n\t            }\n\t            i = ms.length;\n\t            while (i--) {\n\t                m.add(ms[i]);\n\t            }\n\t            return {\n\t                string: string,\n\t                globalMatrix: global,\n\t                totalMatrix: m,\n\t                localMatrix: local,\n\t                diffMatrix: global.clone().add(local.invert()),\n\t                global: global.toTransformString(),\n\t                total: m.toTransformString(),\n\t                local: localString,\n\t                toString: propString\n\t            };\n\t        }\n\t        if (tstr instanceof Snap.Matrix) {\n\t            this.matrix = tstr;\n\t            this._.transform = tstr.toTransformString();\n\t        } else {\n\t            extractTransform(this, tstr);\n\t        }\n\t\n\t        if (this.node) {\n\t            if (this.type == \"linearGradient\" || this.type == \"radialGradient\") {\n\t                $(this.node, {gradientTransform: this.matrix});\n\t            } else if (this.type == \"pattern\") {\n\t                $(this.node, {patternTransform: this.matrix});\n\t            } else {\n\t                $(this.node, {transform: this.matrix});\n\t            }\n\t        }\n\t\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Element.parent\n\t     [ method ]\n\t     **\n\t     * Returns the element's parent\n\t     **\n\t     = (Element) the parent element\n\t    \\*/\n\t    elproto.parent = function () {\n\t        return wrap(this.node.parentNode);\n\t    };\n\t    /*\\\n\t     * Element.append\n\t     [ method ]\n\t     **\n\t     * Appends the given element to current one\n\t     **\n\t     - el (Element|Set) element to append\n\t     = (Element) the parent element\n\t    \\*/\n\t    /*\\\n\t     * Element.add\n\t     [ method ]\n\t     **\n\t     * See @Element.append\n\t    \\*/\n\t    elproto.append = elproto.add = function (el) {\n\t        if (el) {\n\t            if (el.type == \"set\") {\n\t                var it = this;\n\t                el.forEach(function (el) {\n\t                    it.add(el);\n\t                });\n\t                return this;\n\t            }\n\t            el = wrap(el);\n\t            this.node.appendChild(el.node);\n\t            el.paper = this.paper;\n\t        }\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Element.appendTo\n\t     [ method ]\n\t     **\n\t     * Appends the current element to the given one\n\t     **\n\t     - el (Element) parent element to append to\n\t     = (Element) the child element\n\t    \\*/\n\t    elproto.appendTo = function (el) {\n\t        if (el) {\n\t            el = wrap(el);\n\t            el.append(this);\n\t        }\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Element.prepend\n\t     [ method ]\n\t     **\n\t     * Prepends the given element to the current one\n\t     **\n\t     - el (Element) element to prepend\n\t     = (Element) the parent element\n\t    \\*/\n\t    elproto.prepend = function (el) {\n\t        if (el) {\n\t            if (el.type == \"set\") {\n\t                var it = this,\n\t                    first;\n\t                el.forEach(function (el) {\n\t                    if (first) {\n\t                        first.after(el);\n\t                    } else {\n\t                        it.prepend(el);\n\t                    }\n\t                    first = el;\n\t                });\n\t                return this;\n\t            }\n\t            el = wrap(el);\n\t            var parent = el.parent();\n\t            this.node.insertBefore(el.node, this.node.firstChild);\n\t            this.add && this.add();\n\t            el.paper = this.paper;\n\t            this.parent() && this.parent().add();\n\t            parent && parent.add();\n\t        }\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Element.prependTo\n\t     [ method ]\n\t     **\n\t     * Prepends the current element to the given one\n\t     **\n\t     - el (Element) parent element to prepend to\n\t     = (Element) the child element\n\t    \\*/\n\t    elproto.prependTo = function (el) {\n\t        el = wrap(el);\n\t        el.prepend(this);\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Element.before\n\t     [ method ]\n\t     **\n\t     * Inserts given element before the current one\n\t     **\n\t     - el (Element) element to insert\n\t     = (Element) the parent element\n\t    \\*/\n\t    elproto.before = function (el) {\n\t        if (el.type == \"set\") {\n\t            var it = this;\n\t            el.forEach(function (el) {\n\t                var parent = el.parent();\n\t                it.node.parentNode.insertBefore(el.node, it.node);\n\t                parent && parent.add();\n\t            });\n\t            this.parent().add();\n\t            return this;\n\t        }\n\t        el = wrap(el);\n\t        var parent = el.parent();\n\t        this.node.parentNode.insertBefore(el.node, this.node);\n\t        this.parent() && this.parent().add();\n\t        parent && parent.add();\n\t        el.paper = this.paper;\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Element.after\n\t     [ method ]\n\t     **\n\t     * Inserts given element after the current one\n\t     **\n\t     - el (Element) element to insert\n\t     = (Element) the parent element\n\t    \\*/\n\t    elproto.after = function (el) {\n\t        el = wrap(el);\n\t        var parent = el.parent();\n\t        if (this.node.nextSibling) {\n\t            this.node.parentNode.insertBefore(el.node, this.node.nextSibling);\n\t        } else {\n\t            this.node.parentNode.appendChild(el.node);\n\t        }\n\t        this.parent() && this.parent().add();\n\t        parent && parent.add();\n\t        el.paper = this.paper;\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Element.insertBefore\n\t     [ method ]\n\t     **\n\t     * Inserts the element after the given one\n\t     **\n\t     - el (Element) element next to whom insert to\n\t     = (Element) the parent element\n\t    \\*/\n\t    elproto.insertBefore = function (el) {\n\t        el = wrap(el);\n\t        var parent = this.parent();\n\t        el.node.parentNode.insertBefore(this.node, el.node);\n\t        this.paper = el.paper;\n\t        parent && parent.add();\n\t        el.parent() && el.parent().add();\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Element.insertAfter\n\t     [ method ]\n\t     **\n\t     * Inserts the element after the given one\n\t     **\n\t     - el (Element) element next to whom insert to\n\t     = (Element) the parent element\n\t    \\*/\n\t    elproto.insertAfter = function (el) {\n\t        el = wrap(el);\n\t        var parent = this.parent();\n\t        el.node.parentNode.insertBefore(this.node, el.node.nextSibling);\n\t        this.paper = el.paper;\n\t        parent && parent.add();\n\t        el.parent() && el.parent().add();\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Element.remove\n\t     [ method ]\n\t     **\n\t     * Removes element from the DOM\n\t     = (Element) the detached element\n\t    \\*/\n\t    elproto.remove = function () {\n\t        var parent = this.parent();\n\t        this.node.parentNode && this.node.parentNode.removeChild(this.node);\n\t        delete this.paper;\n\t        this.removed = true;\n\t        parent && parent.add();\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Element.select\n\t     [ method ]\n\t     **\n\t     * Gathers the nested @Element matching the given set of CSS selectors\n\t     **\n\t     - query (string) CSS selector\n\t     = (Element) result of query selection\n\t    \\*/\n\t    elproto.select = function (query) {\n\t        query = Str(query).replace(/([^\\\\]):/g, \"$1\\\\:\");\n\t        return wrap(this.node.querySelector(query));\n\t    };\n\t    /*\\\n\t     * Element.selectAll\n\t     [ method ]\n\t     **\n\t     * Gathers nested @Element objects matching the given set of CSS selectors\n\t     **\n\t     - query (string) CSS selector\n\t     = (Set|array) result of query selection\n\t    \\*/\n\t    elproto.selectAll = function (query) {\n\t        var nodelist = this.node.querySelectorAll(query),\n\t            set = (Snap.set || Array)();\n\t        for (var i = 0; i < nodelist.length; i++) {\n\t            set.push(wrap(nodelist[i]));\n\t        }\n\t        return set;\n\t    };\n\t    /*\\\n\t     * Element.asPX\n\t     [ method ]\n\t     **\n\t     * Returns given attribute of the element as a `px` value (not %, em, etc.)\n\t     **\n\t     - attr (string) attribute name\n\t     - value (string) #optional attribute value\n\t     = (Element) result of query selection\n\t    \\*/\n\t    elproto.asPX = function (attr, value) {\n\t        if (value == null) {\n\t            value = this.attr(attr);\n\t        }\n\t        return +unit2px(this, attr, value);\n\t    };\n\t    // SIERRA Element.use(): I suggest adding a note about how to access the original element the returned <use> instantiates. It's a part of SVG with which ordinary web developers may be least familiar.\n\t    /*\\\n\t     * Element.use\n\t     [ method ]\n\t     **\n\t     * Creates a `<use>` element linked to the current element\n\t     **\n\t     = (Element) the `<use>` element\n\t    \\*/\n\t    elproto.use = function () {\n\t        var use,\n\t            id = this.node.id;\n\t        if (!id) {\n\t            id = this.id;\n\t            $(this.node, {\n\t                id: id\n\t            });\n\t        }\n\t        if (this.type == \"linearGradient\" || this.type == \"radialGradient\" ||\n\t            this.type == \"pattern\") {\n\t            use = make(this.type, this.node.parentNode);\n\t        } else {\n\t            use = make(\"use\", this.node.parentNode);\n\t        }\n\t        $(use.node, {\n\t            \"xlink:href\": \"#\" + id\n\t        });\n\t        use.original = this;\n\t        return use;\n\t    };\n\t    function fixids(el) {\n\t        var els = el.selectAll(\"*\"),\n\t            it,\n\t            url = /^\\s*url\\((\"|'|)(.*)\\1\\)\\s*$/,\n\t            ids = [],\n\t            uses = {};\n\t        function urltest(it, name) {\n\t            var val = $(it.node, name);\n\t            val = val && val.match(url);\n\t            val = val && val[2];\n\t            if (val && val.charAt() == \"#\") {\n\t                val = val.substring(1);\n\t            } else {\n\t                return;\n\t            }\n\t            if (val) {\n\t                uses[val] = (uses[val] || []).concat(function (id) {\n\t                    var attr = {};\n\t                    attr[name] = URL(id);\n\t                    $(it.node, attr);\n\t                });\n\t            }\n\t        }\n\t        function linktest(it) {\n\t            var val = $(it.node, \"xlink:href\");\n\t            if (val && val.charAt() == \"#\") {\n\t                val = val.substring(1);\n\t            } else {\n\t                return;\n\t            }\n\t            if (val) {\n\t                uses[val] = (uses[val] || []).concat(function (id) {\n\t                    it.attr(\"xlink:href\", \"#\" + id);\n\t                });\n\t            }\n\t        }\n\t        for (var i = 0, ii = els.length; i < ii; i++) {\n\t            it = els[i];\n\t            urltest(it, \"fill\");\n\t            urltest(it, \"stroke\");\n\t            urltest(it, \"filter\");\n\t            urltest(it, \"mask\");\n\t            urltest(it, \"clip-path\");\n\t            linktest(it);\n\t            var oldid = $(it.node, \"id\");\n\t            if (oldid) {\n\t                $(it.node, {id: it.id});\n\t                ids.push({\n\t                    old: oldid,\n\t                    id: it.id\n\t                });\n\t            }\n\t        }\n\t        for (i = 0, ii = ids.length; i < ii; i++) {\n\t            var fs = uses[ids[i].old];\n\t            if (fs) {\n\t                for (var j = 0, jj = fs.length; j < jj; j++) {\n\t                    fs[j](ids[i].id);\n\t                }\n\t            }\n\t        }\n\t    }\n\t    /*\\\n\t     * Element.clone\n\t     [ method ]\n\t     **\n\t     * Creates a clone of the element and inserts it after the element\n\t     **\n\t     = (Element) the clone\n\t    \\*/\n\t    elproto.clone = function () {\n\t        var clone = wrap(this.node.cloneNode(true));\n\t        if ($(clone.node, \"id\")) {\n\t            $(clone.node, {id: clone.id});\n\t        }\n\t        fixids(clone);\n\t        clone.insertAfter(this);\n\t        return clone;\n\t    };\n\t    /*\\\n\t     * Element.toDefs\n\t     [ method ]\n\t     **\n\t     * Moves element to the shared `<defs>` area\n\t     **\n\t     = (Element) the element\n\t    \\*/\n\t    elproto.toDefs = function () {\n\t        var defs = getSomeDefs(this);\n\t        defs.appendChild(this.node);\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Element.toPattern\n\t     [ method ]\n\t     **\n\t     * Creates a `<pattern>` element from the current element\n\t     **\n\t     * To create a pattern you have to specify the pattern rect:\n\t     - x (string|number)\n\t     - y (string|number)\n\t     - width (string|number)\n\t     - height (string|number)\n\t     = (Element) the `<pattern>` element\n\t     * You can use pattern later on as an argument for `fill` attribute:\n\t     | var p = paper.path(\"M10-5-10,15M15,0,0,15M0-5-20,15\").attr({\n\t     |         fill: \"none\",\n\t     |         stroke: \"#bada55\",\n\t     |         strokeWidth: 5\n\t     |     }).pattern(0, 0, 10, 10),\n\t     |     c = paper.circle(200, 200, 100);\n\t     | c.attr({\n\t     |     fill: p\n\t     | });\n\t    \\*/\n\t    elproto.pattern = elproto.toPattern = function (x, y, width, height) {\n\t        var p = make(\"pattern\", getSomeDefs(this));\n\t        if (x == null) {\n\t            x = this.getBBox();\n\t        }\n\t        if (is(x, \"object\") && \"x\" in x) {\n\t            y = x.y;\n\t            width = x.width;\n\t            height = x.height;\n\t            x = x.x;\n\t        }\n\t        $(p.node, {\n\t            x: x,\n\t            y: y,\n\t            width: width,\n\t            height: height,\n\t            patternUnits: \"userSpaceOnUse\",\n\t            id: p.id,\n\t            viewBox: [x, y, width, height].join(\" \")\n\t        });\n\t        p.node.appendChild(this.node);\n\t        return p;\n\t    };\n\t// SIERRA Element.marker(): clarify what a reference point is. E.g., helps you offset the object from its edge such as when centering it over a path.\n\t// SIERRA Element.marker(): I suggest the method should accept default reference point values.  Perhaps centered with (refX = width/2) and (refY = height/2)? Also, couldn't it assume the element's current _width_ and _height_? And please specify what _x_ and _y_ mean: offsets? If so, from where?  Couldn't they also be assigned default values?\n\t    /*\\\n\t     * Element.marker\n\t     [ method ]\n\t     **\n\t     * Creates a `<marker>` element from the current element\n\t     **\n\t     * To create a marker you have to specify the bounding rect and reference point:\n\t     - x (number)\n\t     - y (number)\n\t     - width (number)\n\t     - height (number)\n\t     - refX (number)\n\t     - refY (number)\n\t     = (Element) the `<marker>` element\n\t     * You can specify the marker later as an argument for `marker-start`, `marker-end`, `marker-mid`, and `marker` attributes. The `marker` attribute places the marker at every point along the path, and `marker-mid` places them at every point except the start and end.\n\t    \\*/\n\t    // TODO add usage for markers\n\t    elproto.marker = function (x, y, width, height, refX, refY) {\n\t        var p = make(\"marker\", getSomeDefs(this));\n\t        if (x == null) {\n\t            x = this.getBBox();\n\t        }\n\t        if (is(x, \"object\") && \"x\" in x) {\n\t            y = x.y;\n\t            width = x.width;\n\t            height = x.height;\n\t            refX = x.refX || x.cx;\n\t            refY = x.refY || x.cy;\n\t            x = x.x;\n\t        }\n\t        $(p.node, {\n\t            viewBox: [x, y, width, height].join(\" \"),\n\t            markerWidth: width,\n\t            markerHeight: height,\n\t            orient: \"auto\",\n\t            refX: refX || 0,\n\t            refY: refY || 0,\n\t            id: p.id\n\t        });\n\t        p.node.appendChild(this.node);\n\t        return p;\n\t    };\n\t    // animation\n\t    function slice(from, to, f) {\n\t        return function (arr) {\n\t            var res = arr.slice(from, to);\n\t            if (res.length == 1) {\n\t                res = res[0];\n\t            }\n\t            return f ? f(res) : res;\n\t        };\n\t    }\n\t    var Animation = function (attr, ms, easing, callback) {\n\t        if (typeof easing == \"function\" && !easing.length) {\n\t            callback = easing;\n\t            easing = mina.linear;\n\t        }\n\t        this.attr = attr;\n\t        this.dur = ms;\n\t        easing && (this.easing = easing);\n\t        callback && (this.callback = callback);\n\t    };\n\t    Snap._.Animation = Animation;\n\t    /*\\\n\t     * Snap.animation\n\t     [ method ]\n\t     **\n\t     * Creates an animation object\n\t     **\n\t     - attr (object) attributes of final destination\n\t     - duration (number) duration of the animation, in milliseconds\n\t     - easing (function) #optional one of easing functions of @mina or custom one\n\t     - callback (function) #optional callback function that fires when animation ends\n\t     = (object) animation object\n\t    \\*/\n\t    Snap.animation = function (attr, ms, easing, callback) {\n\t        return new Animation(attr, ms, easing, callback);\n\t    };\n\t    /*\\\n\t     * Element.inAnim\n\t     [ method ]\n\t     **\n\t     * Returns a set of animations that may be able to manipulate the current element\n\t     **\n\t     = (object) in format:\n\t     o {\n\t     o     anim (object) animation object,\n\t     o     mina (object) @mina object,\n\t     o     curStatus (number) 0..1  status of the animation: 0  just started, 1  just finished,\n\t     o     status (function) gets or sets the status of the animation,\n\t     o     stop (function) stops the animation\n\t     o }\n\t    \\*/\n\t    elproto.inAnim = function () {\n\t        var el = this,\n\t            res = [];\n\t        for (var id in el.anims) if (el.anims[has](id)) {\n\t            (function (a) {\n\t                res.push({\n\t                    anim: new Animation(a._attrs, a.dur, a.easing, a._callback),\n\t                    mina: a,\n\t                    curStatus: a.status(),\n\t                    status: function (val) {\n\t                        return a.status(val);\n\t                    },\n\t                    stop: function () {\n\t                        a.stop();\n\t                    }\n\t                });\n\t            }(el.anims[id]));\n\t        }\n\t        return res;\n\t    };\n\t    /*\\\n\t     * Snap.animate\n\t     [ method ]\n\t     **\n\t     * Runs generic animation of one number into another with a caring function\n\t     **\n\t     - from (number|array) number or array of numbers\n\t     - to (number|array) number or array of numbers\n\t     - setter (function) caring function that accepts one number argument\n\t     - duration (number) duration, in milliseconds\n\t     - easing (function) #optional easing function from @mina or custom\n\t     - callback (function) #optional callback function to execute when animation ends\n\t     = (object) animation object in @mina format\n\t     o {\n\t     o     id (string) animation id, consider it read-only,\n\t     o     duration (function) gets or sets the duration of the animation,\n\t     o     easing (function) easing,\n\t     o     speed (function) gets or sets the speed of the animation,\n\t     o     status (function) gets or sets the status of the animation,\n\t     o     stop (function) stops the animation\n\t     o }\n\t     | var rect = Snap().rect(0, 0, 10, 10);\n\t     | Snap.animate(0, 10, function (val) {\n\t     |     rect.attr({\n\t     |         x: val\n\t     |     });\n\t     | }, 1000);\n\t     | // in given context is equivalent to\n\t     | rect.animate({x: 10}, 1000);\n\t    \\*/\n\t    Snap.animate = function (from, to, setter, ms, easing, callback) {\n\t        if (typeof easing == \"function\" && !easing.length) {\n\t            callback = easing;\n\t            easing = mina.linear;\n\t        }\n\t        var now = mina.time(),\n\t            anim = mina(from, to, now, now + ms, mina.time, setter, easing);\n\t        callback && eve.once(\"mina.finish.\" + anim.id, callback);\n\t        return anim;\n\t    };\n\t    /*\\\n\t     * Element.stop\n\t     [ method ]\n\t     **\n\t     * Stops all the animations for the current element\n\t     **\n\t     = (Element) the current element\n\t    \\*/\n\t    elproto.stop = function () {\n\t        var anims = this.inAnim();\n\t        for (var i = 0, ii = anims.length; i < ii; i++) {\n\t            anims[i].stop();\n\t        }\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Element.animate\n\t     [ method ]\n\t     **\n\t     * Animates the given attributes of the element\n\t     **\n\t     - attrs (object) key-value pairs of destination attributes\n\t     - duration (number) duration of the animation in milliseconds\n\t     - easing (function) #optional easing function from @mina or custom\n\t     - callback (function) #optional callback function that executes when the animation ends\n\t     = (Element) the current element\n\t    \\*/\n\t    elproto.animate = function (attrs, ms, easing, callback) {\n\t        if (typeof easing == \"function\" && !easing.length) {\n\t            callback = easing;\n\t            easing = mina.linear;\n\t        }\n\t        if (attrs instanceof Animation) {\n\t            callback = attrs.callback;\n\t            easing = attrs.easing;\n\t            ms = easing.dur;\n\t            attrs = attrs.attr;\n\t        }\n\t        var fkeys = [], tkeys = [], keys = {}, from, to, f, eq,\n\t            el = this;\n\t        for (var key in attrs) if (attrs[has](key)) {\n\t            if (el.equal) {\n\t                eq = el.equal(key, Str(attrs[key]));\n\t                from = eq.from;\n\t                to = eq.to;\n\t                f = eq.f;\n\t            } else {\n\t                from = +el.attr(key);\n\t                to = +attrs[key];\n\t            }\n\t            var len = is(from, \"array\") ? from.length : 1;\n\t            keys[key] = slice(fkeys.length, fkeys.length + len, f);\n\t            fkeys = fkeys.concat(from);\n\t            tkeys = tkeys.concat(to);\n\t        }\n\t        var now = mina.time(),\n\t            anim = mina(fkeys, tkeys, now, now + ms, mina.time, function (val) {\n\t                var attr = {};\n\t                for (var key in keys) if (keys[has](key)) {\n\t                    attr[key] = keys[key](val);\n\t                }\n\t                el.attr(attr);\n\t            }, easing);\n\t        el.anims[anim.id] = anim;\n\t        anim._attrs = attrs;\n\t        anim._callback = callback;\n\t        eve(\"snap.animcreated.\" + el.id, anim);\n\t        eve.once(\"mina.finish.\" + anim.id, function () {\n\t            delete el.anims[anim.id];\n\t            callback && callback.call(el);\n\t        });\n\t        eve.once(\"mina.stop.\" + anim.id, function () {\n\t            delete el.anims[anim.id];\n\t        });\n\t        return el;\n\t    };\n\t    var eldata = {};\n\t    /*\\\n\t     * Element.data\n\t     [ method ]\n\t     **\n\t     * Adds or retrieves given value associated with given key. (Dont confuse\n\t     * with `data-` attributes)\n\t     *\n\t     * See also @Element.removeData\n\t     - key (string) key to store data\n\t     - value (any) #optional value to store\n\t     = (object) @Element\n\t     * or, if value is not specified:\n\t     = (any) value\n\t     > Usage\n\t     | for (var i = 0, i < 5, i++) {\n\t     |     paper.circle(10 + 15 * i, 10, 10)\n\t     |          .attr({fill: \"#000\"})\n\t     |          .data(\"i\", i)\n\t     |          .click(function () {\n\t     |             alert(this.data(\"i\"));\n\t     |          });\n\t     | }\n\t    \\*/\n\t    elproto.data = function (key, value) {\n\t        var data = eldata[this.id] = eldata[this.id] || {};\n\t        if (arguments.length == 0){\n\t            eve(\"snap.data.get.\" + this.id, this, data, null);\n\t            return data;\n\t        }\n\t        if (arguments.length == 1) {\n\t            if (Snap.is(key, \"object\")) {\n\t                for (var i in key) if (key[has](i)) {\n\t                    this.data(i, key[i]);\n\t                }\n\t                return this;\n\t            }\n\t            eve(\"snap.data.get.\" + this.id, this, data[key], key);\n\t            return data[key];\n\t        }\n\t        data[key] = value;\n\t        eve(\"snap.data.set.\" + this.id, this, value, key);\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Element.removeData\n\t     [ method ]\n\t     **\n\t     * Removes value associated with an element by given key.\n\t     * If key is not provided, removes all the data of the element.\n\t     - key (string) #optional key\n\t     = (object) @Element\n\t    \\*/\n\t    elproto.removeData = function (key) {\n\t        if (key == null) {\n\t            eldata[this.id] = {};\n\t        } else {\n\t            eldata[this.id] && delete eldata[this.id][key];\n\t        }\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Element.outerSVG\n\t     [ method ]\n\t     **\n\t     * Returns SVG code for the element, equivalent to HTML's `outerHTML`.\n\t     *\n\t     * See also @Element.innerSVG\n\t     = (string) SVG code for the element\n\t    \\*/\n\t    /*\\\n\t     * Element.toString\n\t     [ method ]\n\t     **\n\t     * See @Element.outerSVG\n\t    \\*/\n\t    elproto.outerSVG = elproto.toString = toString(1);\n\t    /*\\\n\t     * Element.innerSVG\n\t     [ method ]\n\t     **\n\t     * Returns SVG code for the element's contents, equivalent to HTML's `innerHTML`\n\t     = (string) SVG code for the element\n\t    \\*/\n\t    elproto.innerSVG = toString();\n\t    function toString(type) {\n\t        return function () {\n\t            var res = type ? \"<\" + this.type : \"\",\n\t                attr = this.node.attributes,\n\t                chld = this.node.childNodes;\n\t            if (type) {\n\t                for (var i = 0, ii = attr.length; i < ii; i++) {\n\t                    res += \" \" + attr[i].name + '=\"' +\n\t                            attr[i].value.replace(/\"/g, '\\\\\"') + '\"';\n\t                }\n\t            }\n\t            if (chld.length) {\n\t                type && (res += \">\");\n\t                for (i = 0, ii = chld.length; i < ii; i++) {\n\t                    if (chld[i].nodeType == 3) {\n\t                        res += chld[i].nodeValue;\n\t                    } else if (chld[i].nodeType == 1) {\n\t                        res += wrap(chld[i]).toString();\n\t                    }\n\t                }\n\t                type && (res += \"</\" + this.type + \">\");\n\t            } else {\n\t                type && (res += \"/>\");\n\t            }\n\t            return res;\n\t        };\n\t    }\n\t    elproto.toDataURL = function () {\n\t        if (window && window.btoa) {\n\t            var bb = this.getBBox(),\n\t                svg = Snap.format('<svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"{width}\" height=\"{height}\" viewBox=\"{x} {y} {width} {height}\">{contents}</svg>', {\n\t                x: +bb.x.toFixed(3),\n\t                y: +bb.y.toFixed(3),\n\t                width: +bb.width.toFixed(3),\n\t                height: +bb.height.toFixed(3),\n\t                contents: this.outerSVG()\n\t            });\n\t            return \"data:image/svg+xml;base64,\" + btoa(unescape(encodeURIComponent(svg)));\n\t        }\n\t    };\n\t    /*\\\n\t     * Fragment.select\n\t     [ method ]\n\t     **\n\t     * See @Element.select\n\t    \\*/\n\t    Fragment.prototype.select = elproto.select;\n\t    /*\\\n\t     * Fragment.selectAll\n\t     [ method ]\n\t     **\n\t     * See @Element.selectAll\n\t    \\*/\n\t    Fragment.prototype.selectAll = elproto.selectAll;\n\t});\n\t\n\t// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n\t//\n\t// Licensed under the Apache License, Version 2.0 (the \"License\");\n\t// you may not use this file except in compliance with the License.\n\t// You may obtain a copy of the License at\n\t//\n\t// http://www.apache.org/licenses/LICENSE-2.0\n\t//\n\t// Unless required by applicable law or agreed to in writing, software\n\t// distributed under the License is distributed on an \"AS IS\" BASIS,\n\t// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t// See the License for the specific language governing permissions and\n\t// limitations under the License.\n\tSnap.plugin(function (Snap, Element, Paper, glob, Fragment) {\n\t    var objectToString = Object.prototype.toString,\n\t        Str = String,\n\t        math = Math,\n\t        E = \"\";\n\t    function Matrix(a, b, c, d, e, f) {\n\t        if (b == null && objectToString.call(a) == \"[object SVGMatrix]\") {\n\t            this.a = a.a;\n\t            this.b = a.b;\n\t            this.c = a.c;\n\t            this.d = a.d;\n\t            this.e = a.e;\n\t            this.f = a.f;\n\t            return;\n\t        }\n\t        if (a != null) {\n\t            this.a = +a;\n\t            this.b = +b;\n\t            this.c = +c;\n\t            this.d = +d;\n\t            this.e = +e;\n\t            this.f = +f;\n\t        } else {\n\t            this.a = 1;\n\t            this.b = 0;\n\t            this.c = 0;\n\t            this.d = 1;\n\t            this.e = 0;\n\t            this.f = 0;\n\t        }\n\t    }\n\t    (function (matrixproto) {\n\t        /*\\\n\t         * Matrix.add\n\t         [ method ]\n\t         **\n\t         * Adds the given matrix to existing one\n\t         - a (number)\n\t         - b (number)\n\t         - c (number)\n\t         - d (number)\n\t         - e (number)\n\t         - f (number)\n\t         * or\n\t         - matrix (object) @Matrix\n\t        \\*/\n\t        matrixproto.add = function (a, b, c, d, e, f) {\n\t            var out = [[], [], []],\n\t                m = [[this.a, this.c, this.e], [this.b, this.d, this.f], [0, 0, 1]],\n\t                matrix = [[a, c, e], [b, d, f], [0, 0, 1]],\n\t                x, y, z, res;\n\t\n\t            if (a && a instanceof Matrix) {\n\t                matrix = [[a.a, a.c, a.e], [a.b, a.d, a.f], [0, 0, 1]];\n\t            }\n\t\n\t            for (x = 0; x < 3; x++) {\n\t                for (y = 0; y < 3; y++) {\n\t                    res = 0;\n\t                    for (z = 0; z < 3; z++) {\n\t                        res += m[x][z] * matrix[z][y];\n\t                    }\n\t                    out[x][y] = res;\n\t                }\n\t            }\n\t            this.a = out[0][0];\n\t            this.b = out[1][0];\n\t            this.c = out[0][1];\n\t            this.d = out[1][1];\n\t            this.e = out[0][2];\n\t            this.f = out[1][2];\n\t            return this;\n\t        };\n\t        /*\\\n\t         * Matrix.invert\n\t         [ method ]\n\t         **\n\t         * Returns an inverted version of the matrix\n\t         = (object) @Matrix\n\t        \\*/\n\t        matrixproto.invert = function () {\n\t            var me = this,\n\t                x = me.a * me.d - me.b * me.c;\n\t            return new Matrix(me.d / x, -me.b / x, -me.c / x, me.a / x, (me.c * me.f - me.d * me.e) / x, (me.b * me.e - me.a * me.f) / x);\n\t        };\n\t        /*\\\n\t         * Matrix.clone\n\t         [ method ]\n\t         **\n\t         * Returns a copy of the matrix\n\t         = (object) @Matrix\n\t        \\*/\n\t        matrixproto.clone = function () {\n\t            return new Matrix(this.a, this.b, this.c, this.d, this.e, this.f);\n\t        };\n\t        /*\\\n\t         * Matrix.translate\n\t         [ method ]\n\t         **\n\t         * Translate the matrix\n\t         - x (number) horizontal offset distance\n\t         - y (number) vertical offset distance\n\t        \\*/\n\t        matrixproto.translate = function (x, y) {\n\t            return this.add(1, 0, 0, 1, x, y);\n\t        };\n\t        /*\\\n\t         * Matrix.scale\n\t         [ method ]\n\t         **\n\t         * Scales the matrix\n\t         - x (number) amount to be scaled, with `1` resulting in no change\n\t         - y (number) #optional amount to scale along the vertical axis. (Otherwise `x` applies to both axes.)\n\t         - cx (number) #optional horizontal origin point from which to scale\n\t         - cy (number) #optional vertical origin point from which to scale\n\t         * Default cx, cy is the middle point of the element.\n\t        \\*/\n\t        matrixproto.scale = function (x, y, cx, cy) {\n\t            y == null && (y = x);\n\t            (cx || cy) && this.add(1, 0, 0, 1, cx, cy);\n\t            this.add(x, 0, 0, y, 0, 0);\n\t            (cx || cy) && this.add(1, 0, 0, 1, -cx, -cy);\n\t            return this;\n\t        };\n\t        /*\\\n\t         * Matrix.rotate\n\t         [ method ]\n\t         **\n\t         * Rotates the matrix\n\t         - a (number) angle of rotation, in degrees\n\t         - x (number) horizontal origin point from which to rotate\n\t         - y (number) vertical origin point from which to rotate\n\t        \\*/\n\t        matrixproto.rotate = function (a, x, y) {\n\t            a = Snap.rad(a);\n\t            x = x || 0;\n\t            y = y || 0;\n\t            var cos = +math.cos(a).toFixed(9),\n\t                sin = +math.sin(a).toFixed(9);\n\t            this.add(cos, sin, -sin, cos, x, y);\n\t            return this.add(1, 0, 0, 1, -x, -y);\n\t        };\n\t        /*\\\n\t         * Matrix.x\n\t         [ method ]\n\t         **\n\t         * Returns x coordinate for given point after transformation described by the matrix. See also @Matrix.y\n\t         - x (number)\n\t         - y (number)\n\t         = (number) x\n\t        \\*/\n\t        matrixproto.x = function (x, y) {\n\t            return x * this.a + y * this.c + this.e;\n\t        };\n\t        /*\\\n\t         * Matrix.y\n\t         [ method ]\n\t         **\n\t         * Returns y coordinate for given point after transformation described by the matrix. See also @Matrix.x\n\t         - x (number)\n\t         - y (number)\n\t         = (number) y\n\t        \\*/\n\t        matrixproto.y = function (x, y) {\n\t            return x * this.b + y * this.d + this.f;\n\t        };\n\t        matrixproto.get = function (i) {\n\t            return +this[Str.fromCharCode(97 + i)].toFixed(4);\n\t        };\n\t        matrixproto.toString = function () {\n\t            return \"matrix(\" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)].join() + \")\";\n\t        };\n\t        matrixproto.offset = function () {\n\t            return [this.e.toFixed(4), this.f.toFixed(4)];\n\t        };\n\t        function norm(a) {\n\t            return a[0] * a[0] + a[1] * a[1];\n\t        }\n\t        function normalize(a) {\n\t            var mag = math.sqrt(norm(a));\n\t            a[0] && (a[0] /= mag);\n\t            a[1] && (a[1] /= mag);\n\t        }\n\t        /*\\\n\t         * Matrix.determinant\n\t         [ method ]\n\t         **\n\t         * Finds determinant of the given matrix.\n\t         = (number) determinant\n\t        \\*/\n\t        matrixproto.determinant = function () {\n\t            return this.a * this.d - this.b * this.c;\n\t        };\n\t        /*\\\n\t         * Matrix.split\n\t         [ method ]\n\t         **\n\t         * Splits matrix into primitive transformations\n\t         = (object) in format:\n\t         o dx (number) translation by x\n\t         o dy (number) translation by y\n\t         o scalex (number) scale by x\n\t         o scaley (number) scale by y\n\t         o shear (number) shear\n\t         o rotate (number) rotation in deg\n\t         o isSimple (boolean) could it be represented via simple transformations\n\t        \\*/\n\t        matrixproto.split = function () {\n\t            var out = {};\n\t            // translation\n\t            out.dx = this.e;\n\t            out.dy = this.f;\n\t\n\t            // scale and shear\n\t            var row = [[this.a, this.c], [this.b, this.d]];\n\t            out.scalex = math.sqrt(norm(row[0]));\n\t            normalize(row[0]);\n\t\n\t            out.shear = row[0][0] * row[1][0] + row[0][1] * row[1][1];\n\t            row[1] = [row[1][0] - row[0][0] * out.shear, row[1][1] - row[0][1] * out.shear];\n\t\n\t            out.scaley = math.sqrt(norm(row[1]));\n\t            normalize(row[1]);\n\t            out.shear /= out.scaley;\n\t\n\t            if (this.determinant() < 0) {\n\t                out.scalex = -out.scalex;\n\t            }\n\t\n\t            // rotation\n\t            var sin = -row[0][1],\n\t                cos = row[1][1];\n\t            if (cos < 0) {\n\t                out.rotate = Snap.deg(math.acos(cos));\n\t                if (sin < 0) {\n\t                    out.rotate = 360 - out.rotate;\n\t                }\n\t            } else {\n\t                out.rotate = Snap.deg(math.asin(sin));\n\t            }\n\t\n\t            out.isSimple = !+out.shear.toFixed(9) && (out.scalex.toFixed(9) == out.scaley.toFixed(9) || !out.rotate);\n\t            out.isSuperSimple = !+out.shear.toFixed(9) && out.scalex.toFixed(9) == out.scaley.toFixed(9) && !out.rotate;\n\t            out.noRotation = !+out.shear.toFixed(9) && !out.rotate;\n\t            return out;\n\t        };\n\t        /*\\\n\t         * Matrix.toTransformString\n\t         [ method ]\n\t         **\n\t         * Returns transform string that represents given matrix\n\t         = (string) transform string\n\t        \\*/\n\t        matrixproto.toTransformString = function (shorter) {\n\t            var s = shorter || this.split();\n\t            if (!+s.shear.toFixed(9)) {\n\t                s.scalex = +s.scalex.toFixed(4);\n\t                s.scaley = +s.scaley.toFixed(4);\n\t                s.rotate = +s.rotate.toFixed(4);\n\t                return  (s.dx || s.dy ? \"t\" + [+s.dx.toFixed(4), +s.dy.toFixed(4)] : E) +\n\t                        (s.scalex != 1 || s.scaley != 1 ? \"s\" + [s.scalex, s.scaley, 0, 0] : E) +\n\t                        (s.rotate ? \"r\" + [+s.rotate.toFixed(4), 0, 0] : E);\n\t            } else {\n\t                return \"m\" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)];\n\t            }\n\t        };\n\t    })(Matrix.prototype);\n\t    /*\\\n\t     * Snap.Matrix\n\t     [ method ]\n\t     **\n\t     * Matrix constructor, extend on your own risk.\n\t     * To create matrices use @Snap.matrix.\n\t    \\*/\n\t    Snap.Matrix = Matrix;\n\t    /*\\\n\t     * Snap.matrix\n\t     [ method ]\n\t     **\n\t     * Utility method\n\t     **\n\t     * Returns a matrix based on the given parameters\n\t     - a (number)\n\t     - b (number)\n\t     - c (number)\n\t     - d (number)\n\t     - e (number)\n\t     - f (number)\n\t     * or\n\t     - svgMatrix (SVGMatrix)\n\t     = (object) @Matrix\n\t    \\*/\n\t    Snap.matrix = function (a, b, c, d, e, f) {\n\t        return new Matrix(a, b, c, d, e, f);\n\t    };\n\t});\n\t// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n\t//\n\t// Licensed under the Apache License, Version 2.0 (the \"License\");\n\t// you may not use this file except in compliance with the License.\n\t// You may obtain a copy of the License at\n\t//\n\t// http://www.apache.org/licenses/LICENSE-2.0\n\t//\n\t// Unless required by applicable law or agreed to in writing, software\n\t// distributed under the License is distributed on an \"AS IS\" BASIS,\n\t// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t// See the License for the specific language governing permissions and\n\t// limitations under the License.\n\tSnap.plugin(function (Snap, Element, Paper, glob, Fragment) {\n\t    var has = \"hasOwnProperty\",\n\t        make = Snap._.make,\n\t        wrap = Snap._.wrap,\n\t        is = Snap.is,\n\t        getSomeDefs = Snap._.getSomeDefs,\n\t        reURLValue = /^url\\(#?([^)]+)\\)$/,\n\t        $ = Snap._.$,\n\t        URL = Snap.url,\n\t        Str = String,\n\t        separator = Snap._.separator,\n\t        E = \"\";\n\t    // Attributes event handlers\n\t    eve.on(\"snap.util.attr.mask\", function (value) {\n\t        if (value instanceof Element || value instanceof Fragment) {\n\t            eve.stop();\n\t            if (value instanceof Fragment && value.node.childNodes.length == 1) {\n\t                value = value.node.firstChild;\n\t                getSomeDefs(this).appendChild(value);\n\t                value = wrap(value);\n\t            }\n\t            if (value.type == \"mask\") {\n\t                var mask = value;\n\t            } else {\n\t                mask = make(\"mask\", getSomeDefs(this));\n\t                mask.node.appendChild(value.node);\n\t            }\n\t            !mask.node.id && $(mask.node, {\n\t                id: mask.id\n\t            });\n\t            $(this.node, {\n\t                mask: URL(mask.id)\n\t            });\n\t        }\n\t    });\n\t    (function (clipIt) {\n\t        eve.on(\"snap.util.attr.clip\", clipIt);\n\t        eve.on(\"snap.util.attr.clip-path\", clipIt);\n\t        eve.on(\"snap.util.attr.clipPath\", clipIt);\n\t    }(function (value) {\n\t        if (value instanceof Element || value instanceof Fragment) {\n\t            eve.stop();\n\t            if (value.type == \"clipPath\") {\n\t                var clip = value;\n\t            } else {\n\t                clip = make(\"clipPath\", getSomeDefs(this));\n\t                clip.node.appendChild(value.node);\n\t                !clip.node.id && $(clip.node, {\n\t                    id: clip.id\n\t                });\n\t            }\n\t            $(this.node, {\n\t                \"clip-path\": URL(clip.node.id || clip.id)\n\t            });\n\t        }\n\t    }));\n\t    function fillStroke(name) {\n\t        return function (value) {\n\t            eve.stop();\n\t            if (value instanceof Fragment && value.node.childNodes.length == 1 &&\n\t                (value.node.firstChild.tagName == \"radialGradient\" ||\n\t                value.node.firstChild.tagName == \"linearGradient\" ||\n\t                value.node.firstChild.tagName == \"pattern\")) {\n\t                value = value.node.firstChild;\n\t                getSomeDefs(this).appendChild(value);\n\t                value = wrap(value);\n\t            }\n\t            if (value instanceof Element) {\n\t                if (value.type == \"radialGradient\" || value.type == \"linearGradient\"\n\t                   || value.type == \"pattern\") {\n\t                    if (!value.node.id) {\n\t                        $(value.node, {\n\t                            id: value.id\n\t                        });\n\t                    }\n\t                    var fill = URL(value.node.id);\n\t                } else {\n\t                    fill = value.attr(name);\n\t                }\n\t            } else {\n\t                fill = Snap.color(value);\n\t                if (fill.error) {\n\t                    var grad = Snap(getSomeDefs(this).ownerSVGElement).gradient(value);\n\t                    if (grad) {\n\t                        if (!grad.node.id) {\n\t                            $(grad.node, {\n\t                                id: grad.id\n\t                            });\n\t                        }\n\t                        fill = URL(grad.node.id);\n\t                    } else {\n\t                        fill = value;\n\t                    }\n\t                } else {\n\t                    fill = Str(fill);\n\t                }\n\t            }\n\t            var attrs = {};\n\t            attrs[name] = fill;\n\t            $(this.node, attrs);\n\t            this.node.style[name] = E;\n\t        };\n\t    }\n\t    eve.on(\"snap.util.attr.fill\", fillStroke(\"fill\"));\n\t    eve.on(\"snap.util.attr.stroke\", fillStroke(\"stroke\"));\n\t    var gradrg = /^([lr])(?:\\(([^)]*)\\))?(.*)$/i;\n\t    eve.on(\"snap.util.grad.parse\", function parseGrad(string) {\n\t        string = Str(string);\n\t        var tokens = string.match(gradrg);\n\t        if (!tokens) {\n\t            return null;\n\t        }\n\t        var type = tokens[1],\n\t            params = tokens[2],\n\t            stops = tokens[3];\n\t        params = params.split(/\\s*,\\s*/).map(function (el) {\n\t            return +el == el ? +el : el;\n\t        });\n\t        if (params.length == 1 && params[0] == 0) {\n\t            params = [];\n\t        }\n\t        stops = stops.split(\"-\");\n\t        stops = stops.map(function (el) {\n\t            el = el.split(\":\");\n\t            var out = {\n\t                color: el[0]\n\t            };\n\t            if (el[1]) {\n\t                out.offset = parseFloat(el[1]);\n\t            }\n\t            return out;\n\t        });\n\t        return {\n\t            type: type,\n\t            params: params,\n\t            stops: stops\n\t        };\n\t    });\n\t\n\t    eve.on(\"snap.util.attr.d\", function (value) {\n\t        eve.stop();\n\t        if (is(value, \"array\") && is(value[0], \"array\")) {\n\t            value = Snap.path.toString.call(value);\n\t        }\n\t        value = Str(value);\n\t        if (value.match(/[ruo]/i)) {\n\t            value = Snap.path.toAbsolute(value);\n\t        }\n\t        $(this.node, {d: value});\n\t    })(-1);\n\t    eve.on(\"snap.util.attr.#text\", function (value) {\n\t        eve.stop();\n\t        value = Str(value);\n\t        var txt = glob.doc.createTextNode(value);\n\t        while (this.node.firstChild) {\n\t            this.node.removeChild(this.node.firstChild);\n\t        }\n\t        this.node.appendChild(txt);\n\t    })(-1);\n\t    eve.on(\"snap.util.attr.path\", function (value) {\n\t        eve.stop();\n\t        this.attr({d: value});\n\t    })(-1);\n\t    eve.on(\"snap.util.attr.class\", function (value) {\n\t        eve.stop();\n\t        this.node.className.baseVal = value;\n\t    })(-1);\n\t    eve.on(\"snap.util.attr.viewBox\", function (value) {\n\t        var vb;\n\t        if (is(value, \"object\") && \"x\" in value) {\n\t            vb = [value.x, value.y, value.width, value.height].join(\" \");\n\t        } else if (is(value, \"array\")) {\n\t            vb = value.join(\" \");\n\t        } else {\n\t            vb = value;\n\t        }\n\t        $(this.node, {\n\t            viewBox: vb\n\t        });\n\t        eve.stop();\n\t    })(-1);\n\t    eve.on(\"snap.util.attr.transform\", function (value) {\n\t        this.transform(value);\n\t        eve.stop();\n\t    })(-1);\n\t    eve.on(\"snap.util.attr.r\", function (value) {\n\t        if (this.type == \"rect\") {\n\t            eve.stop();\n\t            $(this.node, {\n\t                rx: value,\n\t                ry: value\n\t            });\n\t        }\n\t    })(-1);\n\t    eve.on(\"snap.util.attr.textpath\", function (value) {\n\t        eve.stop();\n\t        if (this.type == \"text\") {\n\t            var id, tp, node;\n\t            if (!value && this.textPath) {\n\t                tp = this.textPath;\n\t                while (tp.node.firstChild) {\n\t                    this.node.appendChild(tp.node.firstChild);\n\t                }\n\t                tp.remove();\n\t                delete this.textPath;\n\t                return;\n\t            }\n\t            if (is(value, \"string\")) {\n\t                var defs = getSomeDefs(this),\n\t                    path = wrap(defs.parentNode).path(value);\n\t                defs.appendChild(path.node);\n\t                id = path.id;\n\t                path.attr({id: id});\n\t            } else {\n\t                value = wrap(value);\n\t                if (value instanceof Element) {\n\t                    id = value.attr(\"id\");\n\t                    if (!id) {\n\t                        id = value.id;\n\t                        value.attr({id: id});\n\t                    }\n\t                }\n\t            }\n\t            if (id) {\n\t                tp = this.textPath;\n\t                node = this.node;\n\t                if (tp) {\n\t                    tp.attr({\"xlink:href\": \"#\" + id});\n\t                } else {\n\t                    tp = $(\"textPath\", {\n\t                        \"xlink:href\": \"#\" + id\n\t                    });\n\t                    while (node.firstChild) {\n\t                        tp.appendChild(node.firstChild);\n\t                    }\n\t                    node.appendChild(tp);\n\t                    this.textPath = wrap(tp);\n\t                }\n\t            }\n\t        }\n\t    })(-1);\n\t    eve.on(\"snap.util.attr.text\", function (value) {\n\t        if (this.type == \"text\") {\n\t            var i = 0,\n\t                node = this.node,\n\t                tuner = function (chunk) {\n\t                    var out = $(\"tspan\");\n\t                    if (is(chunk, \"array\")) {\n\t                        for (var i = 0; i < chunk.length; i++) {\n\t                            out.appendChild(tuner(chunk[i]));\n\t                        }\n\t                    } else {\n\t                        out.appendChild(glob.doc.createTextNode(chunk));\n\t                    }\n\t                    out.normalize && out.normalize();\n\t                    return out;\n\t                };\n\t            while (node.firstChild) {\n\t                node.removeChild(node.firstChild);\n\t            }\n\t            var tuned = tuner(value);\n\t            while (tuned.firstChild) {\n\t                node.appendChild(tuned.firstChild);\n\t            }\n\t        }\n\t        eve.stop();\n\t    })(-1);\n\t    function setFontSize(value) {\n\t        eve.stop();\n\t        if (value == +value) {\n\t            value += \"px\";\n\t        }\n\t        this.node.style.fontSize = value;\n\t    }\n\t    eve.on(\"snap.util.attr.fontSize\", setFontSize)(-1);\n\t    eve.on(\"snap.util.attr.font-size\", setFontSize)(-1);\n\t\n\t\n\t    eve.on(\"snap.util.getattr.transform\", function () {\n\t        eve.stop();\n\t        return this.transform();\n\t    })(-1);\n\t    eve.on(\"snap.util.getattr.textpath\", function () {\n\t        eve.stop();\n\t        return this.textPath;\n\t    })(-1);\n\t    // Markers\n\t    (function () {\n\t        function getter(end) {\n\t            return function () {\n\t                eve.stop();\n\t                var style = glob.doc.defaultView.getComputedStyle(this.node, null).getPropertyValue(\"marker-\" + end);\n\t                if (style == \"none\") {\n\t                    return style;\n\t                } else {\n\t                    return Snap(glob.doc.getElementById(style.match(reURLValue)[1]));\n\t                }\n\t            };\n\t        }\n\t        function setter(end) {\n\t            return function (value) {\n\t                eve.stop();\n\t                var name = \"marker\" + end.charAt(0).toUpperCase() + end.substring(1);\n\t                if (value == \"\" || !value) {\n\t                    this.node.style[name] = \"none\";\n\t                    return;\n\t                }\n\t                if (value.type == \"marker\") {\n\t                    var id = value.node.id;\n\t                    if (!id) {\n\t                        $(value.node, {id: value.id});\n\t                    }\n\t                    this.node.style[name] = URL(id);\n\t                    return;\n\t                }\n\t            };\n\t        }\n\t        eve.on(\"snap.util.getattr.marker-end\", getter(\"end\"))(-1);\n\t        eve.on(\"snap.util.getattr.markerEnd\", getter(\"end\"))(-1);\n\t        eve.on(\"snap.util.getattr.marker-start\", getter(\"start\"))(-1);\n\t        eve.on(\"snap.util.getattr.markerStart\", getter(\"start\"))(-1);\n\t        eve.on(\"snap.util.getattr.marker-mid\", getter(\"mid\"))(-1);\n\t        eve.on(\"snap.util.getattr.markerMid\", getter(\"mid\"))(-1);\n\t        eve.on(\"snap.util.attr.marker-end\", setter(\"end\"))(-1);\n\t        eve.on(\"snap.util.attr.markerEnd\", setter(\"end\"))(-1);\n\t        eve.on(\"snap.util.attr.marker-start\", setter(\"start\"))(-1);\n\t        eve.on(\"snap.util.attr.markerStart\", setter(\"start\"))(-1);\n\t        eve.on(\"snap.util.attr.marker-mid\", setter(\"mid\"))(-1);\n\t        eve.on(\"snap.util.attr.markerMid\", setter(\"mid\"))(-1);\n\t    }());\n\t    eve.on(\"snap.util.getattr.r\", function () {\n\t        if (this.type == \"rect\" && $(this.node, \"rx\") == $(this.node, \"ry\")) {\n\t            eve.stop();\n\t            return $(this.node, \"rx\");\n\t        }\n\t    })(-1);\n\t    function textExtract(node) {\n\t        var out = [];\n\t        var children = node.childNodes;\n\t        for (var i = 0, ii = children.length; i < ii; i++) {\n\t            var chi = children[i];\n\t            if (chi.nodeType == 3) {\n\t                out.push(chi.nodeValue);\n\t            }\n\t            if (chi.tagName == \"tspan\") {\n\t                if (chi.childNodes.length == 1 && chi.firstChild.nodeType == 3) {\n\t                    out.push(chi.firstChild.nodeValue);\n\t                } else {\n\t                    out.push(textExtract(chi));\n\t                }\n\t            }\n\t        }\n\t        return out;\n\t    }\n\t    eve.on(\"snap.util.getattr.text\", function () {\n\t        if (this.type == \"text\" || this.type == \"tspan\") {\n\t            eve.stop();\n\t            var out = textExtract(this.node);\n\t            return out.length == 1 ? out[0] : out;\n\t        }\n\t    })(-1);\n\t    eve.on(\"snap.util.getattr.#text\", function () {\n\t        return this.node.textContent;\n\t    })(-1);\n\t    eve.on(\"snap.util.getattr.viewBox\", function () {\n\t        eve.stop();\n\t        var vb = $(this.node, \"viewBox\");\n\t        if (vb) {\n\t            vb = vb.split(separator);\n\t            return Snap._.box(+vb[0], +vb[1], +vb[2], +vb[3]);\n\t        } else {\n\t            return;\n\t        }\n\t    })(-1);\n\t    eve.on(\"snap.util.getattr.points\", function () {\n\t        var p = $(this.node, \"points\");\n\t        eve.stop();\n\t        if (p) {\n\t            return p.split(separator);\n\t        } else {\n\t            return;\n\t        }\n\t    })(-1);\n\t    eve.on(\"snap.util.getattr.path\", function () {\n\t        var p = $(this.node, \"d\");\n\t        eve.stop();\n\t        return p;\n\t    })(-1);\n\t    eve.on(\"snap.util.getattr.class\", function () {\n\t        return this.node.className.baseVal;\n\t    })(-1);\n\t    function getFontSize() {\n\t        eve.stop();\n\t        return this.node.style.fontSize;\n\t    }\n\t    eve.on(\"snap.util.getattr.fontSize\", getFontSize)(-1);\n\t    eve.on(\"snap.util.getattr.font-size\", getFontSize)(-1);\n\t});\n\t\n\t// Copyright (c) 2014 Adobe Systems Incorporated. All rights reserved.\n\t//\n\t// Licensed under the Apache License, Version 2.0 (the \"License\");\n\t// you may not use this file except in compliance with the License.\n\t// You may obtain a copy of the License at\n\t//\n\t// http://www.apache.org/licenses/LICENSE-2.0\n\t//\n\t// Unless required by applicable law or agreed to in writing, software\n\t// distributed under the License is distributed on an \"AS IS\" BASIS,\n\t// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t// See the License for the specific language governing permissions and\n\t// limitations under the License.\n\tSnap.plugin(function (Snap, Element, Paper, glob, Fragment) {\n\t    var rgNotSpace = /\\S+/g,\n\t        rgBadSpace = /[\\t\\r\\n\\f]/g,\n\t        rgTrim = /(^\\s+|\\s+$)/g,\n\t        Str = String,\n\t        elproto = Element.prototype;\n\t    /*\\\n\t     * Element.addClass\n\t     [ method ]\n\t     **\n\t     * Adds given class name or list of class names to the element.\n\t     - value (string) class name or space separated list of class names\n\t     **\n\t     = (Element) original element.\n\t    \\*/\n\t    elproto.addClass = function (value) {\n\t        var classes = Str(value || \"\").match(rgNotSpace) || [],\n\t            elem = this.node,\n\t            className = elem.className.baseVal,\n\t            curClasses = className.match(rgNotSpace) || [],\n\t            j,\n\t            pos,\n\t            clazz,\n\t            finalValue;\n\t\n\t        if (classes.length) {\n\t            j = 0;\n\t            while ((clazz = classes[j++])) {\n\t                pos = curClasses.indexOf(clazz);\n\t                if (!~pos) {\n\t                    curClasses.push(clazz);\n\t                }\n\t            }\n\t\n\t            finalValue = curClasses.join(\" \");\n\t            if (className != finalValue) {\n\t                elem.className.baseVal = finalValue;\n\t            }\n\t        }\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Element.removeClass\n\t     [ method ]\n\t     **\n\t     * Removes given class name or list of class names from the element.\n\t     - value (string) class name or space separated list of class names\n\t     **\n\t     = (Element) original element.\n\t    \\*/\n\t    elproto.removeClass = function (value) {\n\t        var classes = Str(value || \"\").match(rgNotSpace) || [],\n\t            elem = this.node,\n\t            className = elem.className.baseVal,\n\t            curClasses = className.match(rgNotSpace) || [],\n\t            j,\n\t            pos,\n\t            clazz,\n\t            finalValue;\n\t        if (curClasses.length) {\n\t            j = 0;\n\t            while ((clazz = classes[j++])) {\n\t                pos = curClasses.indexOf(clazz);\n\t                if (~pos) {\n\t                    curClasses.splice(pos, 1);\n\t                }\n\t            }\n\t\n\t            finalValue = curClasses.join(\" \");\n\t            if (className != finalValue) {\n\t                elem.className.baseVal = finalValue;\n\t            }\n\t        }\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Element.hasClass\n\t     [ method ]\n\t     **\n\t     * Checks if the element has a given class name in the list of class names applied to it.\n\t     - value (string) class name\n\t     **\n\t     = (boolean) `true` if the element has given class\n\t    \\*/\n\t    elproto.hasClass = function (value) {\n\t        var elem = this.node,\n\t            className = elem.className.baseVal,\n\t            curClasses = className.match(rgNotSpace) || [];\n\t        return !!~curClasses.indexOf(value);\n\t    };\n\t    /*\\\n\t     * Element.toggleClass\n\t     [ method ]\n\t     **\n\t     * Add or remove one or more classes from the element, depending on either\n\t     * the classs presence or the value of the `flag` argument.\n\t     - value (string) class name or space separated list of class names\n\t     - flag (boolean) value to determine whether the class should be added or removed\n\t     **\n\t     = (Element) original element.\n\t    \\*/\n\t    elproto.toggleClass = function (value, flag) {\n\t        if (flag != null) {\n\t            if (flag) {\n\t                return this.addClass(value);\n\t            } else {\n\t                return this.removeClass(value);\n\t            }\n\t        }\n\t        var classes = (value || \"\").match(rgNotSpace) || [],\n\t            elem = this.node,\n\t            className = elem.className.baseVal,\n\t            curClasses = className.match(rgNotSpace) || [],\n\t            j,\n\t            pos,\n\t            clazz,\n\t            finalValue;\n\t        j = 0;\n\t        while ((clazz = classes[j++])) {\n\t            pos = curClasses.indexOf(clazz);\n\t            if (~pos) {\n\t                curClasses.splice(pos, 1);\n\t            } else {\n\t                curClasses.push(clazz);\n\t            }\n\t        }\n\t\n\t        finalValue = curClasses.join(\" \");\n\t        if (className != finalValue) {\n\t            elem.className.baseVal = finalValue;\n\t        }\n\t        return this;\n\t    };\n\t});\n\t\n\t// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n\t//\n\t// Licensed under the Apache License, Version 2.0 (the \"License\");\n\t// you may not use this file except in compliance with the License.\n\t// You may obtain a copy of the License at\n\t//\n\t// http://www.apache.org/licenses/LICENSE-2.0\n\t//\n\t// Unless required by applicable law or agreed to in writing, software\n\t// distributed under the License is distributed on an \"AS IS\" BASIS,\n\t// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t// See the License for the specific language governing permissions and\n\t// limitations under the License.\n\tSnap.plugin(function (Snap, Element, Paper, glob, Fragment) {\n\t    var operators = {\n\t            \"+\": function (x, y) {\n\t                    return x + y;\n\t                },\n\t            \"-\": function (x, y) {\n\t                    return x - y;\n\t                },\n\t            \"/\": function (x, y) {\n\t                    return x / y;\n\t                },\n\t            \"*\": function (x, y) {\n\t                    return x * y;\n\t                }\n\t        },\n\t        Str = String,\n\t        reUnit = /[a-z]+$/i,\n\t        reAddon = /^\\s*([+\\-\\/*])\\s*=\\s*([\\d.eE+\\-]+)\\s*([^\\d\\s]+)?\\s*$/;\n\t    function getNumber(val) {\n\t        return val;\n\t    }\n\t    function getUnit(unit) {\n\t        return function (val) {\n\t            return +val.toFixed(3) + unit;\n\t        };\n\t    }\n\t    eve.on(\"snap.util.attr\", function (val) {\n\t        var plus = Str(val).match(reAddon);\n\t        if (plus) {\n\t            var evnt = eve.nt(),\n\t                name = evnt.substring(evnt.lastIndexOf(\".\") + 1),\n\t                a = this.attr(name),\n\t                atr = {};\n\t            eve.stop();\n\t            var unit = plus[3] || \"\",\n\t                aUnit = a.match(reUnit),\n\t                op = operators[plus[1]];\n\t            if (aUnit && aUnit == unit) {\n\t                val = op(parseFloat(a), +plus[2]);\n\t            } else {\n\t                a = this.asPX(name);\n\t                val = op(this.asPX(name), this.asPX(name, plus[2] + unit));\n\t            }\n\t            if (isNaN(a) || isNaN(val)) {\n\t                return;\n\t            }\n\t            atr[name] = val;\n\t            this.attr(atr);\n\t        }\n\t    })(-10);\n\t    eve.on(\"snap.util.equal\", function (name, b) {\n\t        var A, B, a = Str(this.attr(name) || \"\"),\n\t            el = this,\n\t            bplus = Str(b).match(reAddon);\n\t        if (bplus) {\n\t            eve.stop();\n\t            var unit = bplus[3] || \"\",\n\t                aUnit = a.match(reUnit),\n\t                op = operators[bplus[1]];\n\t            if (aUnit && aUnit == unit) {\n\t                return {\n\t                    from: parseFloat(a),\n\t                    to: op(parseFloat(a), +bplus[2]),\n\t                    f: getUnit(aUnit)\n\t                };\n\t            } else {\n\t                a = this.asPX(name);\n\t                return {\n\t                    from: a,\n\t                    to: op(a, this.asPX(name, bplus[2] + unit)),\n\t                    f: getNumber\n\t                };\n\t            }\n\t        }\n\t    })(-10);\n\t});\n\t// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n\t//\n\t// Licensed under the Apache License, Version 2.0 (the \"License\");\n\t// you may not use this file except in compliance with the License.\n\t// You may obtain a copy of the License at\n\t//\n\t// http://www.apache.org/licenses/LICENSE-2.0\n\t//\n\t// Unless required by applicable law or agreed to in writing, software\n\t// distributed under the License is distributed on an \"AS IS\" BASIS,\n\t// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t// See the License for the specific language governing permissions and\n\t// limitations under the License.\n\tSnap.plugin(function (Snap, Element, Paper, glob, Fragment) {\n\t    var proto = Paper.prototype,\n\t        is = Snap.is;\n\t    /*\\\n\t     * Paper.rect\n\t     [ method ]\n\t     *\n\t     * Draws a rectangle\n\t     **\n\t     - x (number) x coordinate of the top left corner\n\t     - y (number) y coordinate of the top left corner\n\t     - width (number) width\n\t     - height (number) height\n\t     - rx (number) #optional horizontal radius for rounded corners, default is 0\n\t     - ry (number) #optional vertical radius for rounded corners, default is rx or 0\n\t     = (object) the `rect` element\n\t     **\n\t     > Usage\n\t     | // regular rectangle\n\t     | var c = paper.rect(10, 10, 50, 50);\n\t     | // rectangle with rounded corners\n\t     | var c = paper.rect(40, 40, 50, 50, 10);\n\t    \\*/\n\t    proto.rect = function (x, y, w, h, rx, ry) {\n\t        var attr;\n\t        if (ry == null) {\n\t            ry = rx;\n\t        }\n\t        if (is(x, \"object\") && x == \"[object Object]\") {\n\t            attr = x;\n\t        } else if (x != null) {\n\t            attr = {\n\t                x: x,\n\t                y: y,\n\t                width: w,\n\t                height: h\n\t            };\n\t            if (rx != null) {\n\t                attr.rx = rx;\n\t                attr.ry = ry;\n\t            }\n\t        }\n\t        return this.el(\"rect\", attr);\n\t    };\n\t    /*\\\n\t     * Paper.circle\n\t     [ method ]\n\t     **\n\t     * Draws a circle\n\t     **\n\t     - x (number) x coordinate of the centre\n\t     - y (number) y coordinate of the centre\n\t     - r (number) radius\n\t     = (object) the `circle` element\n\t     **\n\t     > Usage\n\t     | var c = paper.circle(50, 50, 40);\n\t    \\*/\n\t    proto.circle = function (cx, cy, r) {\n\t        var attr;\n\t        if (is(cx, \"object\") && cx == \"[object Object]\") {\n\t            attr = cx;\n\t        } else if (cx != null) {\n\t            attr = {\n\t                cx: cx,\n\t                cy: cy,\n\t                r: r\n\t            };\n\t        }\n\t        return this.el(\"circle\", attr);\n\t    };\n\t\n\t    var preload = (function () {\n\t        function onerror() {\n\t            this.parentNode.removeChild(this);\n\t        }\n\t        return function (src, f) {\n\t            var img = glob.doc.createElement(\"img\"),\n\t                body = glob.doc.body;\n\t            img.style.cssText = \"position:absolute;left:-9999em;top:-9999em\";\n\t            img.onload = function () {\n\t                f.call(img);\n\t                img.onload = img.onerror = null;\n\t                body.removeChild(img);\n\t            };\n\t            img.onerror = onerror;\n\t            body.appendChild(img);\n\t            img.src = src;\n\t        };\n\t    }());\n\t\n\t    /*\\\n\t     * Paper.image\n\t     [ method ]\n\t     **\n\t     * Places an image on the surface\n\t     **\n\t     - src (string) URI of the source image\n\t     - x (number) x offset position\n\t     - y (number) y offset position\n\t     - width (number) width of the image\n\t     - height (number) height of the image\n\t     = (object) the `image` element\n\t     * or\n\t     = (object) Snap element object with type `image`\n\t     **\n\t     > Usage\n\t     | var c = paper.image(\"apple.png\", 10, 10, 80, 80);\n\t    \\*/\n\t    proto.image = function (src, x, y, width, height) {\n\t        var el = this.el(\"image\");\n\t        if (is(src, \"object\") && \"src\" in src) {\n\t            el.attr(src);\n\t        } else if (src != null) {\n\t            var set = {\n\t                \"xlink:href\": src,\n\t                preserveAspectRatio: \"none\"\n\t            };\n\t            if (x != null && y != null) {\n\t                set.x = x;\n\t                set.y = y;\n\t            }\n\t            if (width != null && height != null) {\n\t                set.width = width;\n\t                set.height = height;\n\t            } else {\n\t                preload(src, function () {\n\t                    Snap._.$(el.node, {\n\t                        width: this.offsetWidth,\n\t                        height: this.offsetHeight\n\t                    });\n\t                });\n\t            }\n\t            Snap._.$(el.node, set);\n\t        }\n\t        return el;\n\t    };\n\t    /*\\\n\t     * Paper.ellipse\n\t     [ method ]\n\t     **\n\t     * Draws an ellipse\n\t     **\n\t     - x (number) x coordinate of the centre\n\t     - y (number) y coordinate of the centre\n\t     - rx (number) horizontal radius\n\t     - ry (number) vertical radius\n\t     = (object) the `ellipse` element\n\t     **\n\t     > Usage\n\t     | var c = paper.ellipse(50, 50, 40, 20);\n\t    \\*/\n\t    proto.ellipse = function (cx, cy, rx, ry) {\n\t        var attr;\n\t        if (is(cx, \"object\") && cx == \"[object Object]\") {\n\t            attr = cx;\n\t        } else if (cx != null) {\n\t            attr ={\n\t                cx: cx,\n\t                cy: cy,\n\t                rx: rx,\n\t                ry: ry\n\t            };\n\t        }\n\t        return this.el(\"ellipse\", attr);\n\t    };\n\t    // SIERRA Paper.path(): Unclear from the link what a Catmull-Rom curveto is, and why it would make life any easier.\n\t    /*\\\n\t     * Paper.path\n\t     [ method ]\n\t     **\n\t     * Creates a `<path>` element using the given string as the path's definition\n\t     - pathString (string) #optional path string in SVG format\n\t     * Path string consists of one-letter commands, followed by comma seprarated arguments in numerical form. Example:\n\t     | \"M10,20L30,40\"\n\t     * This example features two commands: `M`, with arguments `(10, 20)` and `L` with arguments `(30, 40)`. Uppercase letter commands express coordinates in absolute terms, while lowercase commands express them in relative terms from the most recently declared coordinates.\n\t     *\n\t     # <p>Here is short list of commands available, for more details see <a href=\"http://www.w3.org/TR/SVG/paths.html#PathData\" title=\"Details of a path's data attribute's format are described in the SVG specification.\">SVG path string format</a> or <a href=\"https://developer.mozilla.org/en/SVG/Tutorial/Paths\">article about path strings at MDN</a>.</p>\n\t     # <table><thead><tr><th>Command</th><th>Name</th><th>Parameters</th></tr></thead><tbody>\n\t     # <tr><td>M</td><td>moveto</td><td>(x y)+</td></tr>\n\t     # <tr><td>Z</td><td>closepath</td><td>(none)</td></tr>\n\t     # <tr><td>L</td><td>lineto</td><td>(x y)+</td></tr>\n\t     # <tr><td>H</td><td>horizontal lineto</td><td>x+</td></tr>\n\t     # <tr><td>V</td><td>vertical lineto</td><td>y+</td></tr>\n\t     # <tr><td>C</td><td>curveto</td><td>(x1 y1 x2 y2 x y)+</td></tr>\n\t     # <tr><td>S</td><td>smooth curveto</td><td>(x2 y2 x y)+</td></tr>\n\t     # <tr><td>Q</td><td>quadratic Bzier curveto</td><td>(x1 y1 x y)+</td></tr>\n\t     # <tr><td>T</td><td>smooth quadratic Bzier curveto</td><td>(x y)+</td></tr>\n\t     # <tr><td>A</td><td>elliptical arc</td><td>(rx ry x-axis-rotation large-arc-flag sweep-flag x y)+</td></tr>\n\t     # <tr><td>R</td><td><a href=\"http://en.wikipedia.org/wiki/CatmullRom_spline#Catmull.E2.80.93Rom_spline\">Catmull-Rom curveto</a>*</td><td>x1 y1 (x y)+</td></tr></tbody></table>\n\t     * * _Catmull-Rom curveto_ is a not standard SVG command and added to make life easier.\n\t     * Note: there is a special case when a path consists of only three commands: `M10,10Rz`. In this case the path connects back to its starting point.\n\t     > Usage\n\t     | var c = paper.path(\"M10 10L90 90\");\n\t     | // draw a diagonal line:\n\t     | // move to 10,10, line to 90,90\n\t    \\*/\n\t    proto.path = function (d) {\n\t        var attr;\n\t        if (is(d, \"object\") && !is(d, \"array\")) {\n\t            attr = d;\n\t        } else if (d) {\n\t            attr = {d: d};\n\t        }\n\t        return this.el(\"path\", attr);\n\t    };\n\t    /*\\\n\t     * Paper.g\n\t     [ method ]\n\t     **\n\t     * Creates a group element\n\t     **\n\t     - varargs () #optional elements to nest within the group\n\t     = (object) the `g` element\n\t     **\n\t     > Usage\n\t     | var c1 = paper.circle(),\n\t     |     c2 = paper.rect(),\n\t     |     g = paper.g(c2, c1); // note that the order of elements is different\n\t     * or\n\t     | var c1 = paper.circle(),\n\t     |     c2 = paper.rect(),\n\t     |     g = paper.g();\n\t     | g.add(c2, c1);\n\t    \\*/\n\t    /*\\\n\t     * Paper.group\n\t     [ method ]\n\t     **\n\t     * See @Paper.g\n\t    \\*/\n\t    proto.group = proto.g = function (first) {\n\t        var attr,\n\t            el = this.el(\"g\");\n\t        if (arguments.length == 1 && first && !first.type) {\n\t            el.attr(first);\n\t        } else if (arguments.length) {\n\t            el.add(Array.prototype.slice.call(arguments, 0));\n\t        }\n\t        return el;\n\t    };\n\t    /*\\\n\t     * Paper.svg\n\t     [ method ]\n\t     **\n\t     * Creates a nested SVG element.\n\t     - x (number) @optional X of the element\n\t     - y (number) @optional Y of the element\n\t     - width (number) @optional width of the element\n\t     - height (number) @optional height of the element\n\t     - vbx (number) @optional viewbox X\n\t     - vby (number) @optional viewbox Y\n\t     - vbw (number) @optional viewbox width\n\t     - vbh (number) @optional viewbox height\n\t     **\n\t     = (object) the `svg` element\n\t     **\n\t    \\*/\n\t    proto.svg = function (x, y, width, height, vbx, vby, vbw, vbh) {\n\t        var attrs = {};\n\t        if (is(x, \"object\") && y == null) {\n\t            attrs = x;\n\t        } else {\n\t            if (x != null) {\n\t                attrs.x = x;\n\t            }\n\t            if (y != null) {\n\t                attrs.y = y;\n\t            }\n\t            if (width != null) {\n\t                attrs.width = width;\n\t            }\n\t            if (height != null) {\n\t                attrs.height = height;\n\t            }\n\t            if (vbx != null && vby != null && vbw != null && vbh != null) {\n\t                attrs.viewBox = [vbx, vby, vbw, vbh];\n\t            }\n\t        }\n\t        return this.el(\"svg\", attrs);\n\t    };\n\t    /*\\\n\t     * Paper.mask\n\t     [ method ]\n\t     **\n\t     * Equivalent in behaviour to @Paper.g, except its a mask.\n\t     **\n\t     = (object) the `mask` element\n\t     **\n\t    \\*/\n\t    proto.mask = function (first) {\n\t        var attr,\n\t            el = this.el(\"mask\");\n\t        if (arguments.length == 1 && first && !first.type) {\n\t            el.attr(first);\n\t        } else if (arguments.length) {\n\t            el.add(Array.prototype.slice.call(arguments, 0));\n\t        }\n\t        return el;\n\t    };\n\t    /*\\\n\t     * Paper.ptrn\n\t     [ method ]\n\t     **\n\t     * Equivalent in behaviour to @Paper.g, except its a pattern.\n\t     - x (number) @optional X of the element\n\t     - y (number) @optional Y of the element\n\t     - width (number) @optional width of the element\n\t     - height (number) @optional height of the element\n\t     - vbx (number) @optional viewbox X\n\t     - vby (number) @optional viewbox Y\n\t     - vbw (number) @optional viewbox width\n\t     - vbh (number) @optional viewbox height\n\t     **\n\t     = (object) the `pattern` element\n\t     **\n\t    \\*/\n\t    proto.ptrn = function (x, y, width, height, vx, vy, vw, vh) {\n\t        if (is(x, \"object\")) {\n\t            var attr = x;\n\t        } else {\n\t            attr = {patternUnits: \"userSpaceOnUse\"};\n\t            if (x) {\n\t                attr.x = x;\n\t            }\n\t            if (y) {\n\t                attr.y = y;\n\t            }\n\t            if (width != null) {\n\t                attr.width = width;\n\t            }\n\t            if (height != null) {\n\t                attr.height = height;\n\t            }\n\t            if (vx != null && vy != null && vw != null && vh != null) {\n\t                attr.viewBox = [vx, vy, vw, vh];\n\t            } else {\n\t                attr.viewBox = [x || 0, y || 0, width || 0, height || 0];\n\t            }\n\t        }\n\t        return this.el(\"pattern\", attr);\n\t    };\n\t    /*\\\n\t     * Paper.use\n\t     [ method ]\n\t     **\n\t     * Creates a <use> element.\n\t     - id (string) @optional id of element to link\n\t     * or\n\t     - id (Element) @optional element to link\n\t     **\n\t     = (object) the `use` element\n\t     **\n\t    \\*/\n\t    proto.use = function (id) {\n\t        if (id != null) {\n\t            if (id instanceof Element) {\n\t                if (!id.attr(\"id\")) {\n\t                    id.attr({id: Snap._.id(id)});\n\t                }\n\t                id = id.attr(\"id\");\n\t            }\n\t            if (String(id).charAt() == \"#\") {\n\t                id = id.substring(1);\n\t            }\n\t            return this.el(\"use\", {\"xlink:href\": \"#\" + id});\n\t        } else {\n\t            return Element.prototype.use.call(this);\n\t        }\n\t    };\n\t    /*\\\n\t     * Paper.symbol\n\t     [ method ]\n\t     **\n\t     * Creates a <symbol> element.\n\t     - vbx (number) @optional viewbox X\n\t     - vby (number) @optional viewbox Y\n\t     - vbw (number) @optional viewbox width\n\t     - vbh (number) @optional viewbox height\n\t     = (object) the `symbol` element\n\t     **\n\t    \\*/\n\t    proto.symbol = function (vx, vy, vw, vh) {\n\t        var attr = {};\n\t        if (vx != null && vy != null && vw != null && vh != null) {\n\t            attr.viewBox = [vx, vy, vw, vh];\n\t        }\n\t\n\t        return this.el(\"symbol\", attr);\n\t    };\n\t    /*\\\n\t     * Paper.text\n\t     [ method ]\n\t     **\n\t     * Draws a text string\n\t     **\n\t     - x (number) x coordinate position\n\t     - y (number) y coordinate position\n\t     - text (string|array) The text string to draw or array of strings to nest within separate `<tspan>` elements\n\t     = (object) the `text` element\n\t     **\n\t     > Usage\n\t     | var t1 = paper.text(50, 50, \"Snap\");\n\t     | var t2 = paper.text(50, 50, [\"S\",\"n\",\"a\",\"p\"]);\n\t     | // Text path usage\n\t     | t1.attr({textpath: \"M10,10L100,100\"});\n\t     | // or\n\t     | var pth = paper.path(\"M10,10L100,100\");\n\t     | t1.attr({textpath: pth});\n\t    \\*/\n\t    proto.text = function (x, y, text) {\n\t        var attr = {};\n\t        if (is(x, \"object\")) {\n\t            attr = x;\n\t        } else if (x != null) {\n\t            attr = {\n\t                x: x,\n\t                y: y,\n\t                text: text || \"\"\n\t            };\n\t        }\n\t        return this.el(\"text\", attr);\n\t    };\n\t    /*\\\n\t     * Paper.line\n\t     [ method ]\n\t     **\n\t     * Draws a line\n\t     **\n\t     - x1 (number) x coordinate position of the start\n\t     - y1 (number) y coordinate position of the start\n\t     - x2 (number) x coordinate position of the end\n\t     - y2 (number) y coordinate position of the end\n\t     = (object) the `line` element\n\t     **\n\t     > Usage\n\t     | var t1 = paper.line(50, 50, 100, 100);\n\t    \\*/\n\t    proto.line = function (x1, y1, x2, y2) {\n\t        var attr = {};\n\t        if (is(x1, \"object\")) {\n\t            attr = x1;\n\t        } else if (x1 != null) {\n\t            attr = {\n\t                x1: x1,\n\t                x2: x2,\n\t                y1: y1,\n\t                y2: y2\n\t            };\n\t        }\n\t        return this.el(\"line\", attr);\n\t    };\n\t    /*\\\n\t     * Paper.polyline\n\t     [ method ]\n\t     **\n\t     * Draws a polyline\n\t     **\n\t     - points (array) array of points\n\t     * or\n\t     - varargs () points\n\t     = (object) the `polyline` element\n\t     **\n\t     > Usage\n\t     | var p1 = paper.polyline([10, 10, 100, 100]);\n\t     | var p2 = paper.polyline(10, 10, 100, 100);\n\t    \\*/\n\t    proto.polyline = function (points) {\n\t        if (arguments.length > 1) {\n\t            points = Array.prototype.slice.call(arguments, 0);\n\t        }\n\t        var attr = {};\n\t        if (is(points, \"object\") && !is(points, \"array\")) {\n\t            attr = points;\n\t        } else if (points != null) {\n\t            attr = {points: points};\n\t        }\n\t        return this.el(\"polyline\", attr);\n\t    };\n\t    /*\\\n\t     * Paper.polygon\n\t     [ method ]\n\t     **\n\t     * Draws a polygon. See @Paper.polyline\n\t    \\*/\n\t    proto.polygon = function (points) {\n\t        if (arguments.length > 1) {\n\t            points = Array.prototype.slice.call(arguments, 0);\n\t        }\n\t        var attr = {};\n\t        if (is(points, \"object\") && !is(points, \"array\")) {\n\t            attr = points;\n\t        } else if (points != null) {\n\t            attr = {points: points};\n\t        }\n\t        return this.el(\"polygon\", attr);\n\t    };\n\t    // gradients\n\t    (function () {\n\t        var $ = Snap._.$;\n\t        // gradients' helpers\n\t        function Gstops() {\n\t            return this.selectAll(\"stop\");\n\t        }\n\t        function GaddStop(color, offset) {\n\t            var stop = $(\"stop\"),\n\t                attr = {\n\t                    offset: +offset + \"%\"\n\t                };\n\t            color = Snap.color(color);\n\t            attr[\"stop-color\"] = color.hex;\n\t            if (color.opacity < 1) {\n\t                attr[\"stop-opacity\"] = color.opacity;\n\t            }\n\t            $(stop, attr);\n\t            this.node.appendChild(stop);\n\t            return this;\n\t        }\n\t        function GgetBBox() {\n\t            if (this.type == \"linearGradient\") {\n\t                var x1 = $(this.node, \"x1\") || 0,\n\t                    x2 = $(this.node, \"x2\") || 1,\n\t                    y1 = $(this.node, \"y1\") || 0,\n\t                    y2 = $(this.node, \"y2\") || 0;\n\t                return Snap._.box(x1, y1, math.abs(x2 - x1), math.abs(y2 - y1));\n\t            } else {\n\t                var cx = this.node.cx || .5,\n\t                    cy = this.node.cy || .5,\n\t                    r = this.node.r || 0;\n\t                return Snap._.box(cx - r, cy - r, r * 2, r * 2);\n\t            }\n\t        }\n\t        function gradient(defs, str) {\n\t            var grad = eve(\"snap.util.grad.parse\", null, str).firstDefined(),\n\t                el;\n\t            if (!grad) {\n\t                return null;\n\t            }\n\t            grad.params.unshift(defs);\n\t            if (grad.type.toLowerCase() == \"l\") {\n\t                el = gradientLinear.apply(0, grad.params);\n\t            } else {\n\t                el = gradientRadial.apply(0, grad.params);\n\t            }\n\t            if (grad.type != grad.type.toLowerCase()) {\n\t                $(el.node, {\n\t                    gradientUnits: \"userSpaceOnUse\"\n\t                });\n\t            }\n\t            var stops = grad.stops,\n\t                len = stops.length,\n\t                start = 0,\n\t                j = 0;\n\t            function seed(i, end) {\n\t                var step = (end - start) / (i - j);\n\t                for (var k = j; k < i; k++) {\n\t                    stops[k].offset = +(+start + step * (k - j)).toFixed(2);\n\t                }\n\t                j = i;\n\t                start = end;\n\t            }\n\t            len--;\n\t            for (var i = 0; i < len; i++) if (\"offset\" in stops[i]) {\n\t                seed(i, stops[i].offset);\n\t            }\n\t            stops[len].offset = stops[len].offset || 100;\n\t            seed(len, stops[len].offset);\n\t            for (i = 0; i <= len; i++) {\n\t                var stop = stops[i];\n\t                el.addStop(stop.color, stop.offset);\n\t            }\n\t            return el;\n\t        }\n\t        function gradientLinear(defs, x1, y1, x2, y2) {\n\t            var el = Snap._.make(\"linearGradient\", defs);\n\t            el.stops = Gstops;\n\t            el.addStop = GaddStop;\n\t            el.getBBox = GgetBBox;\n\t            if (x1 != null) {\n\t                $(el.node, {\n\t                    x1: x1,\n\t                    y1: y1,\n\t                    x2: x2,\n\t                    y2: y2\n\t                });\n\t            }\n\t            return el;\n\t        }\n\t        function gradientRadial(defs, cx, cy, r, fx, fy) {\n\t            var el = Snap._.make(\"radialGradient\", defs);\n\t            el.stops = Gstops;\n\t            el.addStop = GaddStop;\n\t            el.getBBox = GgetBBox;\n\t            if (cx != null) {\n\t                $(el.node, {\n\t                    cx: cx,\n\t                    cy: cy,\n\t                    r: r\n\t                });\n\t            }\n\t            if (fx != null && fy != null) {\n\t                $(el.node, {\n\t                    fx: fx,\n\t                    fy: fy\n\t                });\n\t            }\n\t            return el;\n\t        }\n\t        /*\\\n\t         * Paper.gradient\n\t         [ method ]\n\t         **\n\t         * Creates a gradient element\n\t         **\n\t         - gradient (string) gradient descriptor\n\t         > Gradient Descriptor\n\t         * The gradient descriptor is an expression formatted as\n\t         * follows: `<type>(<coords>)<colors>`.  The `<type>` can be\n\t         * either linear or radial.  The uppercase `L` or `R` letters\n\t         * indicate absolute coordinates offset from the SVG surface.\n\t         * Lowercase `l` or `r` letters indicate coordinates\n\t         * calculated relative to the element to which the gradient is\n\t         * applied.  Coordinates specify a linear gradient vector as\n\t         * `x1`, `y1`, `x2`, `y2`, or a radial gradient as `cx`, `cy`,\n\t         * `r` and optional `fx`, `fy` specifying a focal point away\n\t         * from the center of the circle. Specify `<colors>` as a list\n\t         * of dash-separated CSS color values.  Each color may be\n\t         * followed by a custom offset value, separated with a colon\n\t         * character.\n\t         > Examples\n\t         * Linear gradient, relative from top-left corner to bottom-right\n\t         * corner, from black through red to white:\n\t         | var g = paper.gradient(\"l(0, 0, 1, 1)#000-#f00-#fff\");\n\t         * Linear gradient, absolute from (0, 0) to (100, 100), from black\n\t         * through red at 25% to white:\n\t         | var g = paper.gradient(\"L(0, 0, 100, 100)#000-#f00:25-#fff\");\n\t         * Radial gradient, relative from the center of the element with radius\n\t         * half the width, from black to white:\n\t         | var g = paper.gradient(\"r(0.5, 0.5, 0.5)#000-#fff\");\n\t         * To apply the gradient:\n\t         | paper.circle(50, 50, 40).attr({\n\t         |     fill: g\n\t         | });\n\t         = (object) the `gradient` element\n\t        \\*/\n\t        proto.gradient = function (str) {\n\t            return gradient(this.defs, str);\n\t        };\n\t        proto.gradientLinear = function (x1, y1, x2, y2) {\n\t            return gradientLinear(this.defs, x1, y1, x2, y2);\n\t        };\n\t        proto.gradientRadial = function (cx, cy, r, fx, fy) {\n\t            return gradientRadial(this.defs, cx, cy, r, fx, fy);\n\t        };\n\t        /*\\\n\t         * Paper.toString\n\t         [ method ]\n\t         **\n\t         * Returns SVG code for the @Paper\n\t         = (string) SVG code for the @Paper\n\t        \\*/\n\t        proto.toString = function () {\n\t            var doc = this.node.ownerDocument,\n\t                f = doc.createDocumentFragment(),\n\t                d = doc.createElement(\"div\"),\n\t                svg = this.node.cloneNode(true),\n\t                res;\n\t            f.appendChild(d);\n\t            d.appendChild(svg);\n\t            Snap._.$(svg, {xmlns: \"http://www.w3.org/2000/svg\"});\n\t            res = d.innerHTML;\n\t            f.removeChild(f.firstChild);\n\t            return res;\n\t        };\n\t        /*\\\n\t         * Paper.toDataURL\n\t         [ method ]\n\t         **\n\t         * Returns SVG code for the @Paper as Data URI string.\n\t         = (string) Data URI string\n\t        \\*/\n\t        proto.toDataURL = function () {\n\t            if (window && window.btoa) {\n\t                return \"data:image/svg+xml;base64,\" + btoa(unescape(encodeURIComponent(this)));\n\t            }\n\t        };\n\t        /*\\\n\t         * Paper.clear\n\t         [ method ]\n\t         **\n\t         * Removes all child nodes of the paper, except <defs>.\n\t        \\*/\n\t        proto.clear = function () {\n\t            var node = this.node.firstChild,\n\t                next;\n\t            while (node) {\n\t                next = node.nextSibling;\n\t                if (node.tagName != \"defs\") {\n\t                    node.parentNode.removeChild(node);\n\t                } else {\n\t                    proto.clear.call({node: node});\n\t                }\n\t                node = next;\n\t            }\n\t        };\n\t    }());\n\t});\n\t\n\t// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n\t//\n\t// Licensed under the Apache License, Version 2.0 (the \"License\");\n\t// you may not use this file except in compliance with the License.\n\t// You may obtain a copy of the License at\n\t//\n\t// http://www.apache.org/licenses/LICENSE-2.0\n\t//\n\t// Unless required by applicable law or agreed to in writing, software\n\t// distributed under the License is distributed on an \"AS IS\" BASIS,\n\t// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t// See the License for the specific language governing permissions and\n\t// limitations under the License.\n\tSnap.plugin(function (Snap, Element, Paper, glob) {\n\t    var elproto = Element.prototype,\n\t        is = Snap.is,\n\t        clone = Snap._.clone,\n\t        has = \"hasOwnProperty\",\n\t        p2s = /,?([a-z]),?/gi,\n\t        toFloat = parseFloat,\n\t        math = Math,\n\t        PI = math.PI,\n\t        mmin = math.min,\n\t        mmax = math.max,\n\t        pow = math.pow,\n\t        abs = math.abs;\n\t    function paths(ps) {\n\t        var p = paths.ps = paths.ps || {};\n\t        if (p[ps]) {\n\t            p[ps].sleep = 100;\n\t        } else {\n\t            p[ps] = {\n\t                sleep: 100\n\t            };\n\t        }\n\t        setTimeout(function () {\n\t            for (var key in p) if (p[has](key) && key != ps) {\n\t                p[key].sleep--;\n\t                !p[key].sleep && delete p[key];\n\t            }\n\t        });\n\t        return p[ps];\n\t    }\n\t    function box(x, y, width, height) {\n\t        if (x == null) {\n\t            x = y = width = height = 0;\n\t        }\n\t        if (y == null) {\n\t            y = x.y;\n\t            width = x.width;\n\t            height = x.height;\n\t            x = x.x;\n\t        }\n\t        return {\n\t            x: x,\n\t            y: y,\n\t            width: width,\n\t            w: width,\n\t            height: height,\n\t            h: height,\n\t            x2: x + width,\n\t            y2: y + height,\n\t            cx: x + width / 2,\n\t            cy: y + height / 2,\n\t            r1: math.min(width, height) / 2,\n\t            r2: math.max(width, height) / 2,\n\t            r0: math.sqrt(width * width + height * height) / 2,\n\t            path: rectPath(x, y, width, height),\n\t            vb: [x, y, width, height].join(\" \")\n\t        };\n\t    }\n\t    function toString() {\n\t        return this.join(\",\").replace(p2s, \"$1\");\n\t    }\n\t    function pathClone(pathArray) {\n\t        var res = clone(pathArray);\n\t        res.toString = toString;\n\t        return res;\n\t    }\n\t    function getPointAtSegmentLength(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length) {\n\t        if (length == null) {\n\t            return bezlen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y);\n\t        } else {\n\t            return findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y,\n\t                getTotLen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length));\n\t        }\n\t    }\n\t    function getLengthFactory(istotal, subpath) {\n\t        function O(val) {\n\t            return +(+val).toFixed(3);\n\t        }\n\t        return Snap._.cacher(function (path, length, onlystart) {\n\t            if (path instanceof Element) {\n\t                path = path.attr(\"d\");\n\t            }\n\t            path = path2curve(path);\n\t            var x, y, p, l, sp = \"\", subpaths = {}, point,\n\t                len = 0;\n\t            for (var i = 0, ii = path.length; i < ii; i++) {\n\t                p = path[i];\n\t                if (p[0] == \"M\") {\n\t                    x = +p[1];\n\t                    y = +p[2];\n\t                } else {\n\t                    l = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);\n\t                    if (len + l > length) {\n\t                        if (subpath && !subpaths.start) {\n\t                            point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);\n\t                            sp += [\n\t                                \"C\" + O(point.start.x),\n\t                                O(point.start.y),\n\t                                O(point.m.x),\n\t                                O(point.m.y),\n\t                                O(point.x),\n\t                                O(point.y)\n\t                            ];\n\t                            if (onlystart) {return sp;}\n\t                            subpaths.start = sp;\n\t                            sp = [\n\t                                \"M\" + O(point.x),\n\t                                O(point.y) + \"C\" + O(point.n.x),\n\t                                O(point.n.y),\n\t                                O(point.end.x),\n\t                                O(point.end.y),\n\t                                O(p[5]),\n\t                                O(p[6])\n\t                            ].join();\n\t                            len += l;\n\t                            x = +p[5];\n\t                            y = +p[6];\n\t                            continue;\n\t                        }\n\t                        if (!istotal && !subpath) {\n\t                            point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);\n\t                            return point;\n\t                        }\n\t                    }\n\t                    len += l;\n\t                    x = +p[5];\n\t                    y = +p[6];\n\t                }\n\t                sp += p.shift() + p;\n\t            }\n\t            subpaths.end = sp;\n\t            point = istotal ? len : subpath ? subpaths : findDotsAtSegment(x, y, p[0], p[1], p[2], p[3], p[4], p[5], 1);\n\t            return point;\n\t        }, null, Snap._.clone);\n\t    }\n\t    var getTotalLength = getLengthFactory(1),\n\t        getPointAtLength = getLengthFactory(),\n\t        getSubpathsAtLength = getLengthFactory(0, 1);\n\t    function findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {\n\t        var t1 = 1 - t,\n\t            t13 = pow(t1, 3),\n\t            t12 = pow(t1, 2),\n\t            t2 = t * t,\n\t            t3 = t2 * t,\n\t            x = t13 * p1x + t12 * 3 * t * c1x + t1 * 3 * t * t * c2x + t3 * p2x,\n\t            y = t13 * p1y + t12 * 3 * t * c1y + t1 * 3 * t * t * c2y + t3 * p2y,\n\t            mx = p1x + 2 * t * (c1x - p1x) + t2 * (c2x - 2 * c1x + p1x),\n\t            my = p1y + 2 * t * (c1y - p1y) + t2 * (c2y - 2 * c1y + p1y),\n\t            nx = c1x + 2 * t * (c2x - c1x) + t2 * (p2x - 2 * c2x + c1x),\n\t            ny = c1y + 2 * t * (c2y - c1y) + t2 * (p2y - 2 * c2y + c1y),\n\t            ax = t1 * p1x + t * c1x,\n\t            ay = t1 * p1y + t * c1y,\n\t            cx = t1 * c2x + t * p2x,\n\t            cy = t1 * c2y + t * p2y,\n\t            alpha = (90 - math.atan2(mx - nx, my - ny) * 180 / PI);\n\t        // (mx > nx || my < ny) && (alpha += 180);\n\t        return {\n\t            x: x,\n\t            y: y,\n\t            m: {x: mx, y: my},\n\t            n: {x: nx, y: ny},\n\t            start: {x: ax, y: ay},\n\t            end: {x: cx, y: cy},\n\t            alpha: alpha\n\t        };\n\t    }\n\t    function bezierBBox(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {\n\t        if (!Snap.is(p1x, \"array\")) {\n\t            p1x = [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y];\n\t        }\n\t        var bbox = curveDim.apply(null, p1x);\n\t        return box(\n\t            bbox.min.x,\n\t            bbox.min.y,\n\t            bbox.max.x - bbox.min.x,\n\t            bbox.max.y - bbox.min.y\n\t        );\n\t    }\n\t    function isPointInsideBBox(bbox, x, y) {\n\t        return  x >= bbox.x &&\n\t                x <= bbox.x + bbox.width &&\n\t                y >= bbox.y &&\n\t                y <= bbox.y + bbox.height;\n\t    }\n\t    function isBBoxIntersect(bbox1, bbox2) {\n\t        bbox1 = box(bbox1);\n\t        bbox2 = box(bbox2);\n\t        return isPointInsideBBox(bbox2, bbox1.x, bbox1.y)\n\t            || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y)\n\t            || isPointInsideBBox(bbox2, bbox1.x, bbox1.y2)\n\t            || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y2)\n\t            || isPointInsideBBox(bbox1, bbox2.x, bbox2.y)\n\t            || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y)\n\t            || isPointInsideBBox(bbox1, bbox2.x, bbox2.y2)\n\t            || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y2)\n\t            || (bbox1.x < bbox2.x2 && bbox1.x > bbox2.x\n\t                || bbox2.x < bbox1.x2 && bbox2.x > bbox1.x)\n\t            && (bbox1.y < bbox2.y2 && bbox1.y > bbox2.y\n\t                || bbox2.y < bbox1.y2 && bbox2.y > bbox1.y);\n\t    }\n\t    function base3(t, p1, p2, p3, p4) {\n\t        var t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4,\n\t            t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;\n\t        return t * t2 - 3 * p1 + 3 * p2;\n\t    }\n\t    function bezlen(x1, y1, x2, y2, x3, y3, x4, y4, z) {\n\t        if (z == null) {\n\t            z = 1;\n\t        }\n\t        z = z > 1 ? 1 : z < 0 ? 0 : z;\n\t        var z2 = z / 2,\n\t            n = 12,\n\t            Tvalues = [-.1252,.1252,-.3678,.3678,-.5873,.5873,-.7699,.7699,-.9041,.9041,-.9816,.9816],\n\t            Cvalues = [0.2491,0.2491,0.2335,0.2335,0.2032,0.2032,0.1601,0.1601,0.1069,0.1069,0.0472,0.0472],\n\t            sum = 0;\n\t        for (var i = 0; i < n; i++) {\n\t            var ct = z2 * Tvalues[i] + z2,\n\t                xbase = base3(ct, x1, x2, x3, x4),\n\t                ybase = base3(ct, y1, y2, y3, y4),\n\t                comb = xbase * xbase + ybase * ybase;\n\t            sum += Cvalues[i] * math.sqrt(comb);\n\t        }\n\t        return z2 * sum;\n\t    }\n\t    function getTotLen(x1, y1, x2, y2, x3, y3, x4, y4, ll) {\n\t        if (ll < 0 || bezlen(x1, y1, x2, y2, x3, y3, x4, y4) < ll) {\n\t            return;\n\t        }\n\t        var t = 1,\n\t            step = t / 2,\n\t            t2 = t - step,\n\t            l,\n\t            e = .01;\n\t        l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);\n\t        while (abs(l - ll) > e) {\n\t            step /= 2;\n\t            t2 += (l < ll ? 1 : -1) * step;\n\t            l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);\n\t        }\n\t        return t2;\n\t    }\n\t    function intersect(x1, y1, x2, y2, x3, y3, x4, y4) {\n\t        if (\n\t            mmax(x1, x2) < mmin(x3, x4) ||\n\t            mmin(x1, x2) > mmax(x3, x4) ||\n\t            mmax(y1, y2) < mmin(y3, y4) ||\n\t            mmin(y1, y2) > mmax(y3, y4)\n\t        ) {\n\t            return;\n\t        }\n\t        var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),\n\t            ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),\n\t            denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n\t\n\t        if (!denominator) {\n\t            return;\n\t        }\n\t        var px = nx / denominator,\n\t            py = ny / denominator,\n\t            px2 = +px.toFixed(2),\n\t            py2 = +py.toFixed(2);\n\t        if (\n\t            px2 < +mmin(x1, x2).toFixed(2) ||\n\t            px2 > +mmax(x1, x2).toFixed(2) ||\n\t            px2 < +mmin(x3, x4).toFixed(2) ||\n\t            px2 > +mmax(x3, x4).toFixed(2) ||\n\t            py2 < +mmin(y1, y2).toFixed(2) ||\n\t            py2 > +mmax(y1, y2).toFixed(2) ||\n\t            py2 < +mmin(y3, y4).toFixed(2) ||\n\t            py2 > +mmax(y3, y4).toFixed(2)\n\t        ) {\n\t            return;\n\t        }\n\t        return {x: px, y: py};\n\t    }\n\t    function inter(bez1, bez2) {\n\t        return interHelper(bez1, bez2);\n\t    }\n\t    function interCount(bez1, bez2) {\n\t        return interHelper(bez1, bez2, 1);\n\t    }\n\t    function interHelper(bez1, bez2, justCount) {\n\t        var bbox1 = bezierBBox(bez1),\n\t            bbox2 = bezierBBox(bez2);\n\t        if (!isBBoxIntersect(bbox1, bbox2)) {\n\t            return justCount ? 0 : [];\n\t        }\n\t        var l1 = bezlen.apply(0, bez1),\n\t            l2 = bezlen.apply(0, bez2),\n\t            n1 = ~~(l1 / 8),\n\t            n2 = ~~(l2 / 8),\n\t            dots1 = [],\n\t            dots2 = [],\n\t            xy = {},\n\t            res = justCount ? 0 : [];\n\t        for (var i = 0; i < n1 + 1; i++) {\n\t            var p = findDotsAtSegment.apply(0, bez1.concat(i / n1));\n\t            dots1.push({x: p.x, y: p.y, t: i / n1});\n\t        }\n\t        for (i = 0; i < n2 + 1; i++) {\n\t            p = findDotsAtSegment.apply(0, bez2.concat(i / n2));\n\t            dots2.push({x: p.x, y: p.y, t: i / n2});\n\t        }\n\t        for (i = 0; i < n1; i++) {\n\t            for (var j = 0; j < n2; j++) {\n\t                var di = dots1[i],\n\t                    di1 = dots1[i + 1],\n\t                    dj = dots2[j],\n\t                    dj1 = dots2[j + 1],\n\t                    ci = abs(di1.x - di.x) < .001 ? \"y\" : \"x\",\n\t                    cj = abs(dj1.x - dj.x) < .001 ? \"y\" : \"x\",\n\t                    is = intersect(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y);\n\t                if (is) {\n\t                    if (xy[is.x.toFixed(4)] == is.y.toFixed(4)) {\n\t                        continue;\n\t                    }\n\t                    xy[is.x.toFixed(4)] = is.y.toFixed(4);\n\t                    var t1 = di.t + abs((is[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t),\n\t                        t2 = dj.t + abs((is[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);\n\t                    if (t1 >= 0 && t1 <= 1 && t2 >= 0 && t2 <= 1) {\n\t                        if (justCount) {\n\t                            res++;\n\t                        } else {\n\t                            res.push({\n\t                                x: is.x,\n\t                                y: is.y,\n\t                                t1: t1,\n\t                                t2: t2\n\t                            });\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        return res;\n\t    }\n\t    function pathIntersection(path1, path2) {\n\t        return interPathHelper(path1, path2);\n\t    }\n\t    function pathIntersectionNumber(path1, path2) {\n\t        return interPathHelper(path1, path2, 1);\n\t    }\n\t    function interPathHelper(path1, path2, justCount) {\n\t        path1 = path2curve(path1);\n\t        path2 = path2curve(path2);\n\t        var x1, y1, x2, y2, x1m, y1m, x2m, y2m, bez1, bez2,\n\t            res = justCount ? 0 : [];\n\t        for (var i = 0, ii = path1.length; i < ii; i++) {\n\t            var pi = path1[i];\n\t            if (pi[0] == \"M\") {\n\t                x1 = x1m = pi[1];\n\t                y1 = y1m = pi[2];\n\t            } else {\n\t                if (pi[0] == \"C\") {\n\t                    bez1 = [x1, y1].concat(pi.slice(1));\n\t                    x1 = bez1[6];\n\t                    y1 = bez1[7];\n\t                } else {\n\t                    bez1 = [x1, y1, x1, y1, x1m, y1m, x1m, y1m];\n\t                    x1 = x1m;\n\t                    y1 = y1m;\n\t                }\n\t                for (var j = 0, jj = path2.length; j < jj; j++) {\n\t                    var pj = path2[j];\n\t                    if (pj[0] == \"M\") {\n\t                        x2 = x2m = pj[1];\n\t                        y2 = y2m = pj[2];\n\t                    } else {\n\t                        if (pj[0] == \"C\") {\n\t                            bez2 = [x2, y2].concat(pj.slice(1));\n\t                            x2 = bez2[6];\n\t                            y2 = bez2[7];\n\t                        } else {\n\t                            bez2 = [x2, y2, x2, y2, x2m, y2m, x2m, y2m];\n\t                            x2 = x2m;\n\t                            y2 = y2m;\n\t                        }\n\t                        var intr = interHelper(bez1, bez2, justCount);\n\t                        if (justCount) {\n\t                            res += intr;\n\t                        } else {\n\t                            for (var k = 0, kk = intr.length; k < kk; k++) {\n\t                                intr[k].segment1 = i;\n\t                                intr[k].segment2 = j;\n\t                                intr[k].bez1 = bez1;\n\t                                intr[k].bez2 = bez2;\n\t                            }\n\t                            res = res.concat(intr);\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        return res;\n\t    }\n\t    function isPointInsidePath(path, x, y) {\n\t        var bbox = pathBBox(path);\n\t        return isPointInsideBBox(bbox, x, y) &&\n\t               interPathHelper(path, [[\"M\", x, y], [\"H\", bbox.x2 + 10]], 1) % 2 == 1;\n\t    }\n\t    function pathBBox(path) {\n\t        var pth = paths(path);\n\t        if (pth.bbox) {\n\t            return clone(pth.bbox);\n\t        }\n\t        if (!path) {\n\t            return box();\n\t        }\n\t        path = path2curve(path);\n\t        var x = 0,\n\t            y = 0,\n\t            X = [],\n\t            Y = [],\n\t            p;\n\t        for (var i = 0, ii = path.length; i < ii; i++) {\n\t            p = path[i];\n\t            if (p[0] == \"M\") {\n\t                x = p[1];\n\t                y = p[2];\n\t                X.push(x);\n\t                Y.push(y);\n\t            } else {\n\t                var dim = curveDim(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);\n\t                X = X.concat(dim.min.x, dim.max.x);\n\t                Y = Y.concat(dim.min.y, dim.max.y);\n\t                x = p[5];\n\t                y = p[6];\n\t            }\n\t        }\n\t        var xmin = mmin.apply(0, X),\n\t            ymin = mmin.apply(0, Y),\n\t            xmax = mmax.apply(0, X),\n\t            ymax = mmax.apply(0, Y),\n\t            bb = box(xmin, ymin, xmax - xmin, ymax - ymin);\n\t        pth.bbox = clone(bb);\n\t        return bb;\n\t    }\n\t    function rectPath(x, y, w, h, r) {\n\t        if (r) {\n\t            return [\n\t                [\"M\", +x + (+r), y],\n\t                [\"l\", w - r * 2, 0],\n\t                [\"a\", r, r, 0, 0, 1, r, r],\n\t                [\"l\", 0, h - r * 2],\n\t                [\"a\", r, r, 0, 0, 1, -r, r],\n\t                [\"l\", r * 2 - w, 0],\n\t                [\"a\", r, r, 0, 0, 1, -r, -r],\n\t                [\"l\", 0, r * 2 - h],\n\t                [\"a\", r, r, 0, 0, 1, r, -r],\n\t                [\"z\"]\n\t            ];\n\t        }\n\t        var res = [[\"M\", x, y], [\"l\", w, 0], [\"l\", 0, h], [\"l\", -w, 0], [\"z\"]];\n\t        res.toString = toString;\n\t        return res;\n\t    }\n\t    function ellipsePath(x, y, rx, ry, a) {\n\t        if (a == null && ry == null) {\n\t            ry = rx;\n\t        }\n\t        x = +x;\n\t        y = +y;\n\t        rx = +rx;\n\t        ry = +ry;\n\t        if (a != null) {\n\t            var rad = Math.PI / 180,\n\t                x1 = x + rx * Math.cos(-ry * rad),\n\t                x2 = x + rx * Math.cos(-a * rad),\n\t                y1 = y + rx * Math.sin(-ry * rad),\n\t                y2 = y + rx * Math.sin(-a * rad),\n\t                res = [[\"M\", x1, y1], [\"A\", rx, rx, 0, +(a - ry > 180), 0, x2, y2]];\n\t        } else {\n\t            res = [\n\t                [\"M\", x, y],\n\t                [\"m\", 0, -ry],\n\t                [\"a\", rx, ry, 0, 1, 1, 0, 2 * ry],\n\t                [\"a\", rx, ry, 0, 1, 1, 0, -2 * ry],\n\t                [\"z\"]\n\t            ];\n\t        }\n\t        res.toString = toString;\n\t        return res;\n\t    }\n\t    var unit2px = Snap._unit2px,\n\t        getPath = {\n\t        path: function (el) {\n\t            return el.attr(\"path\");\n\t        },\n\t        circle: function (el) {\n\t            var attr = unit2px(el);\n\t            return ellipsePath(attr.cx, attr.cy, attr.r);\n\t        },\n\t        ellipse: function (el) {\n\t            var attr = unit2px(el);\n\t            return ellipsePath(attr.cx || 0, attr.cy || 0, attr.rx, attr.ry);\n\t        },\n\t        rect: function (el) {\n\t            var attr = unit2px(el);\n\t            return rectPath(attr.x || 0, attr.y || 0, attr.width, attr.height, attr.rx, attr.ry);\n\t        },\n\t        image: function (el) {\n\t            var attr = unit2px(el);\n\t            return rectPath(attr.x || 0, attr.y || 0, attr.width, attr.height);\n\t        },\n\t        line: function (el) {\n\t            return \"M\" + [el.attr(\"x1\") || 0, el.attr(\"y1\") || 0, el.attr(\"x2\"), el.attr(\"y2\")];\n\t        },\n\t        polyline: function (el) {\n\t            return \"M\" + el.attr(\"points\");\n\t        },\n\t        polygon: function (el) {\n\t            return \"M\" + el.attr(\"points\") + \"z\";\n\t        },\n\t        deflt: function (el) {\n\t            var bbox = el.node.getBBox();\n\t            return rectPath(bbox.x, bbox.y, bbox.width, bbox.height);\n\t        }\n\t    };\n\t    function pathToRelative(pathArray) {\n\t        var pth = paths(pathArray),\n\t            lowerCase = String.prototype.toLowerCase;\n\t        if (pth.rel) {\n\t            return pathClone(pth.rel);\n\t        }\n\t        if (!Snap.is(pathArray, \"array\") || !Snap.is(pathArray && pathArray[0], \"array\")) {\n\t            pathArray = Snap.parsePathString(pathArray);\n\t        }\n\t        var res = [],\n\t            x = 0,\n\t            y = 0,\n\t            mx = 0,\n\t            my = 0,\n\t            start = 0;\n\t        if (pathArray[0][0] == \"M\") {\n\t            x = pathArray[0][1];\n\t            y = pathArray[0][2];\n\t            mx = x;\n\t            my = y;\n\t            start++;\n\t            res.push([\"M\", x, y]);\n\t        }\n\t        for (var i = start, ii = pathArray.length; i < ii; i++) {\n\t            var r = res[i] = [],\n\t                pa = pathArray[i];\n\t            if (pa[0] != lowerCase.call(pa[0])) {\n\t                r[0] = lowerCase.call(pa[0]);\n\t                switch (r[0]) {\n\t                    case \"a\":\n\t                        r[1] = pa[1];\n\t                        r[2] = pa[2];\n\t                        r[3] = pa[3];\n\t                        r[4] = pa[4];\n\t                        r[5] = pa[5];\n\t                        r[6] = +(pa[6] - x).toFixed(3);\n\t                        r[7] = +(pa[7] - y).toFixed(3);\n\t                        break;\n\t                    case \"v\":\n\t                        r[1] = +(pa[1] - y).toFixed(3);\n\t                        break;\n\t                    case \"m\":\n\t                        mx = pa[1];\n\t                        my = pa[2];\n\t                    default:\n\t                        for (var j = 1, jj = pa.length; j < jj; j++) {\n\t                            r[j] = +(pa[j] - ((j % 2) ? x : y)).toFixed(3);\n\t                        }\n\t                }\n\t            } else {\n\t                r = res[i] = [];\n\t                if (pa[0] == \"m\") {\n\t                    mx = pa[1] + x;\n\t                    my = pa[2] + y;\n\t                }\n\t                for (var k = 0, kk = pa.length; k < kk; k++) {\n\t                    res[i][k] = pa[k];\n\t                }\n\t            }\n\t            var len = res[i].length;\n\t            switch (res[i][0]) {\n\t                case \"z\":\n\t                    x = mx;\n\t                    y = my;\n\t                    break;\n\t                case \"h\":\n\t                    x += +res[i][len - 1];\n\t                    break;\n\t                case \"v\":\n\t                    y += +res[i][len - 1];\n\t                    break;\n\t                default:\n\t                    x += +res[i][len - 2];\n\t                    y += +res[i][len - 1];\n\t            }\n\t        }\n\t        res.toString = toString;\n\t        pth.rel = pathClone(res);\n\t        return res;\n\t    }\n\t    function pathToAbsolute(pathArray) {\n\t        var pth = paths(pathArray);\n\t        if (pth.abs) {\n\t            return pathClone(pth.abs);\n\t        }\n\t        if (!is(pathArray, \"array\") || !is(pathArray && pathArray[0], \"array\")) { // rough assumption\n\t            pathArray = Snap.parsePathString(pathArray);\n\t        }\n\t        if (!pathArray || !pathArray.length) {\n\t            return [[\"M\", 0, 0]];\n\t        }\n\t        var res = [],\n\t            x = 0,\n\t            y = 0,\n\t            mx = 0,\n\t            my = 0,\n\t            start = 0,\n\t            pa0;\n\t        if (pathArray[0][0] == \"M\") {\n\t            x = +pathArray[0][1];\n\t            y = +pathArray[0][2];\n\t            mx = x;\n\t            my = y;\n\t            start++;\n\t            res[0] = [\"M\", x, y];\n\t        }\n\t        var crz = pathArray.length == 3 &&\n\t            pathArray[0][0] == \"M\" &&\n\t            pathArray[1][0].toUpperCase() == \"R\" &&\n\t            pathArray[2][0].toUpperCase() == \"Z\";\n\t        for (var r, pa, i = start, ii = pathArray.length; i < ii; i++) {\n\t            res.push(r = []);\n\t            pa = pathArray[i];\n\t            pa0 = pa[0];\n\t            if (pa0 != pa0.toUpperCase()) {\n\t                r[0] = pa0.toUpperCase();\n\t                switch (r[0]) {\n\t                    case \"A\":\n\t                        r[1] = pa[1];\n\t                        r[2] = pa[2];\n\t                        r[3] = pa[3];\n\t                        r[4] = pa[4];\n\t                        r[5] = pa[5];\n\t                        r[6] = +pa[6] + x;\n\t                        r[7] = +pa[7] + y;\n\t                        break;\n\t                    case \"V\":\n\t                        r[1] = +pa[1] + y;\n\t                        break;\n\t                    case \"H\":\n\t                        r[1] = +pa[1] + x;\n\t                        break;\n\t                    case \"R\":\n\t                        var dots = [x, y].concat(pa.slice(1));\n\t                        for (var j = 2, jj = dots.length; j < jj; j++) {\n\t                            dots[j] = +dots[j] + x;\n\t                            dots[++j] = +dots[j] + y;\n\t                        }\n\t                        res.pop();\n\t                        res = res.concat(catmullRom2bezier(dots, crz));\n\t                        break;\n\t                    case \"O\":\n\t                        res.pop();\n\t                        dots = ellipsePath(x, y, pa[1], pa[2]);\n\t                        dots.push(dots[0]);\n\t                        res = res.concat(dots);\n\t                        break;\n\t                    case \"U\":\n\t                        res.pop();\n\t                        res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));\n\t                        r = [\"U\"].concat(res[res.length - 1].slice(-2));\n\t                        break;\n\t                    case \"M\":\n\t                        mx = +pa[1] + x;\n\t                        my = +pa[2] + y;\n\t                    default:\n\t                        for (j = 1, jj = pa.length; j < jj; j++) {\n\t                            r[j] = +pa[j] + ((j % 2) ? x : y);\n\t                        }\n\t                }\n\t            } else if (pa0 == \"R\") {\n\t                dots = [x, y].concat(pa.slice(1));\n\t                res.pop();\n\t                res = res.concat(catmullRom2bezier(dots, crz));\n\t                r = [\"R\"].concat(pa.slice(-2));\n\t            } else if (pa0 == \"O\") {\n\t                res.pop();\n\t                dots = ellipsePath(x, y, pa[1], pa[2]);\n\t                dots.push(dots[0]);\n\t                res = res.concat(dots);\n\t            } else if (pa0 == \"U\") {\n\t                res.pop();\n\t                res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));\n\t                r = [\"U\"].concat(res[res.length - 1].slice(-2));\n\t            } else {\n\t                for (var k = 0, kk = pa.length; k < kk; k++) {\n\t                    r[k] = pa[k];\n\t                }\n\t            }\n\t            pa0 = pa0.toUpperCase();\n\t            if (pa0 != \"O\") {\n\t                switch (r[0]) {\n\t                    case \"Z\":\n\t                        x = +mx;\n\t                        y = +my;\n\t                        break;\n\t                    case \"H\":\n\t                        x = r[1];\n\t                        break;\n\t                    case \"V\":\n\t                        y = r[1];\n\t                        break;\n\t                    case \"M\":\n\t                        mx = r[r.length - 2];\n\t                        my = r[r.length - 1];\n\t                    default:\n\t                        x = r[r.length - 2];\n\t                        y = r[r.length - 1];\n\t                }\n\t            }\n\t        }\n\t        res.toString = toString;\n\t        pth.abs = pathClone(res);\n\t        return res;\n\t    }\n\t    function l2c(x1, y1, x2, y2) {\n\t        return [x1, y1, x2, y2, x2, y2];\n\t    }\n\t    function q2c(x1, y1, ax, ay, x2, y2) {\n\t        var _13 = 1 / 3,\n\t            _23 = 2 / 3;\n\t        return [\n\t                _13 * x1 + _23 * ax,\n\t                _13 * y1 + _23 * ay,\n\t                _13 * x2 + _23 * ax,\n\t                _13 * y2 + _23 * ay,\n\t                x2,\n\t                y2\n\t            ];\n\t    }\n\t    function a2c(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {\n\t        // for more information of where this math came from visit:\n\t        // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n\t        var _120 = PI * 120 / 180,\n\t            rad = PI / 180 * (+angle || 0),\n\t            res = [],\n\t            xy,\n\t            rotate = Snap._.cacher(function (x, y, rad) {\n\t                var X = x * math.cos(rad) - y * math.sin(rad),\n\t                    Y = x * math.sin(rad) + y * math.cos(rad);\n\t                return {x: X, y: Y};\n\t            });\n\t        if (!recursive) {\n\t            xy = rotate(x1, y1, -rad);\n\t            x1 = xy.x;\n\t            y1 = xy.y;\n\t            xy = rotate(x2, y2, -rad);\n\t            x2 = xy.x;\n\t            y2 = xy.y;\n\t            var cos = math.cos(PI / 180 * angle),\n\t                sin = math.sin(PI / 180 * angle),\n\t                x = (x1 - x2) / 2,\n\t                y = (y1 - y2) / 2;\n\t            var h = (x * x) / (rx * rx) + (y * y) / (ry * ry);\n\t            if (h > 1) {\n\t                h = math.sqrt(h);\n\t                rx = h * rx;\n\t                ry = h * ry;\n\t            }\n\t            var rx2 = rx * rx,\n\t                ry2 = ry * ry,\n\t                k = (large_arc_flag == sweep_flag ? -1 : 1) *\n\t                    math.sqrt(abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x))),\n\t                cx = k * rx * y / ry + (x1 + x2) / 2,\n\t                cy = k * -ry * x / rx + (y1 + y2) / 2,\n\t                f1 = math.asin(((y1 - cy) / ry).toFixed(9)),\n\t                f2 = math.asin(((y2 - cy) / ry).toFixed(9));\n\t\n\t            f1 = x1 < cx ? PI - f1 : f1;\n\t            f2 = x2 < cx ? PI - f2 : f2;\n\t            f1 < 0 && (f1 = PI * 2 + f1);\n\t            f2 < 0 && (f2 = PI * 2 + f2);\n\t            if (sweep_flag && f1 > f2) {\n\t                f1 = f1 - PI * 2;\n\t            }\n\t            if (!sweep_flag && f2 > f1) {\n\t                f2 = f2 - PI * 2;\n\t            }\n\t        } else {\n\t            f1 = recursive[0];\n\t            f2 = recursive[1];\n\t            cx = recursive[2];\n\t            cy = recursive[3];\n\t        }\n\t        var df = f2 - f1;\n\t        if (abs(df) > _120) {\n\t            var f2old = f2,\n\t                x2old = x2,\n\t                y2old = y2;\n\t            f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);\n\t            x2 = cx + rx * math.cos(f2);\n\t            y2 = cy + ry * math.sin(f2);\n\t            res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);\n\t        }\n\t        df = f2 - f1;\n\t        var c1 = math.cos(f1),\n\t            s1 = math.sin(f1),\n\t            c2 = math.cos(f2),\n\t            s2 = math.sin(f2),\n\t            t = math.tan(df / 4),\n\t            hx = 4 / 3 * rx * t,\n\t            hy = 4 / 3 * ry * t,\n\t            m1 = [x1, y1],\n\t            m2 = [x1 + hx * s1, y1 - hy * c1],\n\t            m3 = [x2 + hx * s2, y2 - hy * c2],\n\t            m4 = [x2, y2];\n\t        m2[0] = 2 * m1[0] - m2[0];\n\t        m2[1] = 2 * m1[1] - m2[1];\n\t        if (recursive) {\n\t            return [m2, m3, m4].concat(res);\n\t        } else {\n\t            res = [m2, m3, m4].concat(res).join().split(\",\");\n\t            var newres = [];\n\t            for (var i = 0, ii = res.length; i < ii; i++) {\n\t                newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;\n\t            }\n\t            return newres;\n\t        }\n\t    }\n\t    function findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {\n\t        var t1 = 1 - t;\n\t        return {\n\t            x: pow(t1, 3) * p1x + pow(t1, 2) * 3 * t * c1x + t1 * 3 * t * t * c2x + pow(t, 3) * p2x,\n\t            y: pow(t1, 3) * p1y + pow(t1, 2) * 3 * t * c1y + t1 * 3 * t * t * c2y + pow(t, 3) * p2y\n\t        };\n\t    }\n\t\n\t    // Returns bounding box of cubic bezier curve.\n\t    // Source: http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html\n\t    // Original version: NISHIO Hirokazu\n\t    // Modifications: https://github.com/timo22345\n\t    function curveDim(x0, y0, x1, y1, x2, y2, x3, y3) {\n\t        var tvalues = [],\n\t            bounds = [[], []],\n\t            a, b, c, t, t1, t2, b2ac, sqrtb2ac;\n\t        for (var i = 0; i < 2; ++i) {\n\t            if (i == 0) {\n\t                b = 6 * x0 - 12 * x1 + 6 * x2;\n\t                a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;\n\t                c = 3 * x1 - 3 * x0;\n\t            } else {\n\t                b = 6 * y0 - 12 * y1 + 6 * y2;\n\t                a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;\n\t                c = 3 * y1 - 3 * y0;\n\t            }\n\t            if (abs(a) < 1e-12) {\n\t                if (abs(b) < 1e-12) {\n\t                    continue;\n\t                }\n\t                t = -c / b;\n\t                if (0 < t && t < 1) {\n\t                    tvalues.push(t);\n\t                }\n\t                continue;\n\t            }\n\t            b2ac = b * b - 4 * c * a;\n\t            sqrtb2ac = math.sqrt(b2ac);\n\t            if (b2ac < 0) {\n\t                continue;\n\t            }\n\t            t1 = (-b + sqrtb2ac) / (2 * a);\n\t            if (0 < t1 && t1 < 1) {\n\t                tvalues.push(t1);\n\t            }\n\t            t2 = (-b - sqrtb2ac) / (2 * a);\n\t            if (0 < t2 && t2 < 1) {\n\t                tvalues.push(t2);\n\t            }\n\t        }\n\t\n\t        var x, y, j = tvalues.length,\n\t            jlen = j,\n\t            mt;\n\t        while (j--) {\n\t            t = tvalues[j];\n\t            mt = 1 - t;\n\t            bounds[0][j] = (mt * mt * mt * x0) + (3 * mt * mt * t * x1) + (3 * mt * t * t * x2) + (t * t * t * x3);\n\t            bounds[1][j] = (mt * mt * mt * y0) + (3 * mt * mt * t * y1) + (3 * mt * t * t * y2) + (t * t * t * y3);\n\t        }\n\t\n\t        bounds[0][jlen] = x0;\n\t        bounds[1][jlen] = y0;\n\t        bounds[0][jlen + 1] = x3;\n\t        bounds[1][jlen + 1] = y3;\n\t        bounds[0].length = bounds[1].length = jlen + 2;\n\t\n\t\n\t        return {\n\t          min: {x: mmin.apply(0, bounds[0]), y: mmin.apply(0, bounds[1])},\n\t          max: {x: mmax.apply(0, bounds[0]), y: mmax.apply(0, bounds[1])}\n\t        };\n\t    }\n\t\n\t    function path2curve(path, path2) {\n\t        var pth = !path2 && paths(path);\n\t        if (!path2 && pth.curve) {\n\t            return pathClone(pth.curve);\n\t        }\n\t        var p = pathToAbsolute(path),\n\t            p2 = path2 && pathToAbsolute(path2),\n\t            attrs = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null},\n\t            attrs2 = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null},\n\t            processPath = function (path, d, pcom) {\n\t                var nx, ny;\n\t                if (!path) {\n\t                    return [\"C\", d.x, d.y, d.x, d.y, d.x, d.y];\n\t                }\n\t                !(path[0] in {T: 1, Q: 1}) && (d.qx = d.qy = null);\n\t                switch (path[0]) {\n\t                    case \"M\":\n\t                        d.X = path[1];\n\t                        d.Y = path[2];\n\t                        break;\n\t                    case \"A\":\n\t                        path = [\"C\"].concat(a2c.apply(0, [d.x, d.y].concat(path.slice(1))));\n\t                        break;\n\t                    case \"S\":\n\t                        if (pcom == \"C\" || pcom == \"S\") { // In \"S\" case we have to take into account, if the previous command is C/S.\n\t                            nx = d.x * 2 - d.bx;          // And reflect the previous\n\t                            ny = d.y * 2 - d.by;          // command's control point relative to the current point.\n\t                        }\n\t                        else {                            // or some else or nothing\n\t                            nx = d.x;\n\t                            ny = d.y;\n\t                        }\n\t                        path = [\"C\", nx, ny].concat(path.slice(1));\n\t                        break;\n\t                    case \"T\":\n\t                        if (pcom == \"Q\" || pcom == \"T\") { // In \"T\" case we have to take into account, if the previous command is Q/T.\n\t                            d.qx = d.x * 2 - d.qx;        // And make a reflection similar\n\t                            d.qy = d.y * 2 - d.qy;        // to case \"S\".\n\t                        }\n\t                        else {                            // or something else or nothing\n\t                            d.qx = d.x;\n\t                            d.qy = d.y;\n\t                        }\n\t                        path = [\"C\"].concat(q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));\n\t                        break;\n\t                    case \"Q\":\n\t                        d.qx = path[1];\n\t                        d.qy = path[2];\n\t                        path = [\"C\"].concat(q2c(d.x, d.y, path[1], path[2], path[3], path[4]));\n\t                        break;\n\t                    case \"L\":\n\t                        path = [\"C\"].concat(l2c(d.x, d.y, path[1], path[2]));\n\t                        break;\n\t                    case \"H\":\n\t                        path = [\"C\"].concat(l2c(d.x, d.y, path[1], d.y));\n\t                        break;\n\t                    case \"V\":\n\t                        path = [\"C\"].concat(l2c(d.x, d.y, d.x, path[1]));\n\t                        break;\n\t                    case \"Z\":\n\t                        path = [\"C\"].concat(l2c(d.x, d.y, d.X, d.Y));\n\t                        break;\n\t                }\n\t                return path;\n\t            },\n\t            fixArc = function (pp, i) {\n\t                if (pp[i].length > 7) {\n\t                    pp[i].shift();\n\t                    var pi = pp[i];\n\t                    while (pi.length) {\n\t                        pcoms1[i] = \"A\"; // if created multiple C:s, their original seg is saved\n\t                        p2 && (pcoms2[i] = \"A\"); // the same as above\n\t                        pp.splice(i++, 0, [\"C\"].concat(pi.splice(0, 6)));\n\t                    }\n\t                    pp.splice(i, 1);\n\t                    ii = mmax(p.length, p2 && p2.length || 0);\n\t                }\n\t            },\n\t            fixM = function (path1, path2, a1, a2, i) {\n\t                if (path1 && path2 && path1[i][0] == \"M\" && path2[i][0] != \"M\") {\n\t                    path2.splice(i, 0, [\"M\", a2.x, a2.y]);\n\t                    a1.bx = 0;\n\t                    a1.by = 0;\n\t                    a1.x = path1[i][1];\n\t                    a1.y = path1[i][2];\n\t                    ii = mmax(p.length, p2 && p2.length || 0);\n\t                }\n\t            },\n\t            pcoms1 = [], // path commands of original path p\n\t            pcoms2 = [], // path commands of original path p2\n\t            pfirst = \"\", // temporary holder for original path command\n\t            pcom = \"\"; // holder for previous path command of original path\n\t        for (var i = 0, ii = mmax(p.length, p2 && p2.length || 0); i < ii; i++) {\n\t            p[i] && (pfirst = p[i][0]); // save current path command\n\t\n\t            if (pfirst != \"C\") // C is not saved yet, because it may be result of conversion\n\t            {\n\t                pcoms1[i] = pfirst; // Save current path command\n\t                i && ( pcom = pcoms1[i - 1]); // Get previous path command pcom\n\t            }\n\t            p[i] = processPath(p[i], attrs, pcom); // Previous path command is inputted to processPath\n\t\n\t            if (pcoms1[i] != \"A\" && pfirst == \"C\") pcoms1[i] = \"C\"; // A is the only command\n\t            // which may produce multiple C:s\n\t            // so we have to make sure that C is also C in original path\n\t\n\t            fixArc(p, i); // fixArc adds also the right amount of A:s to pcoms1\n\t\n\t            if (p2) { // the same procedures is done to p2\n\t                p2[i] && (pfirst = p2[i][0]);\n\t                if (pfirst != \"C\") {\n\t                    pcoms2[i] = pfirst;\n\t                    i && (pcom = pcoms2[i - 1]);\n\t                }\n\t                p2[i] = processPath(p2[i], attrs2, pcom);\n\t\n\t                if (pcoms2[i] != \"A\" && pfirst == \"C\") {\n\t                    pcoms2[i] = \"C\";\n\t                }\n\t\n\t                fixArc(p2, i);\n\t            }\n\t            fixM(p, p2, attrs, attrs2, i);\n\t            fixM(p2, p, attrs2, attrs, i);\n\t            var seg = p[i],\n\t                seg2 = p2 && p2[i],\n\t                seglen = seg.length,\n\t                seg2len = p2 && seg2.length;\n\t            attrs.x = seg[seglen - 2];\n\t            attrs.y = seg[seglen - 1];\n\t            attrs.bx = toFloat(seg[seglen - 4]) || attrs.x;\n\t            attrs.by = toFloat(seg[seglen - 3]) || attrs.y;\n\t            attrs2.bx = p2 && (toFloat(seg2[seg2len - 4]) || attrs2.x);\n\t            attrs2.by = p2 && (toFloat(seg2[seg2len - 3]) || attrs2.y);\n\t            attrs2.x = p2 && seg2[seg2len - 2];\n\t            attrs2.y = p2 && seg2[seg2len - 1];\n\t        }\n\t        if (!p2) {\n\t            pth.curve = pathClone(p);\n\t        }\n\t        return p2 ? [p, p2] : p;\n\t    }\n\t    function mapPath(path, matrix) {\n\t        if (!matrix) {\n\t            return path;\n\t        }\n\t        var x, y, i, j, ii, jj, pathi;\n\t        path = path2curve(path);\n\t        for (i = 0, ii = path.length; i < ii; i++) {\n\t            pathi = path[i];\n\t            for (j = 1, jj = pathi.length; j < jj; j += 2) {\n\t                x = matrix.x(pathi[j], pathi[j + 1]);\n\t                y = matrix.y(pathi[j], pathi[j + 1]);\n\t                pathi[j] = x;\n\t                pathi[j + 1] = y;\n\t            }\n\t        }\n\t        return path;\n\t    }\n\t\n\t    // http://schepers.cc/getting-to-the-point\n\t    function catmullRom2bezier(crp, z) {\n\t        var d = [];\n\t        for (var i = 0, iLen = crp.length; iLen - 2 * !z > i; i += 2) {\n\t            var p = [\n\t                        {x: +crp[i - 2], y: +crp[i - 1]},\n\t                        {x: +crp[i],     y: +crp[i + 1]},\n\t                        {x: +crp[i + 2], y: +crp[i + 3]},\n\t                        {x: +crp[i + 4], y: +crp[i + 5]}\n\t                    ];\n\t            if (z) {\n\t                if (!i) {\n\t                    p[0] = {x: +crp[iLen - 2], y: +crp[iLen - 1]};\n\t                } else if (iLen - 4 == i) {\n\t                    p[3] = {x: +crp[0], y: +crp[1]};\n\t                } else if (iLen - 2 == i) {\n\t                    p[2] = {x: +crp[0], y: +crp[1]};\n\t                    p[3] = {x: +crp[2], y: +crp[3]};\n\t                }\n\t            } else {\n\t                if (iLen - 4 == i) {\n\t                    p[3] = p[2];\n\t                } else if (!i) {\n\t                    p[0] = {x: +crp[i], y: +crp[i + 1]};\n\t                }\n\t            }\n\t            d.push([\"C\",\n\t                  (-p[0].x + 6 * p[1].x + p[2].x) / 6,\n\t                  (-p[0].y + 6 * p[1].y + p[2].y) / 6,\n\t                  (p[1].x + 6 * p[2].x - p[3].x) / 6,\n\t                  (p[1].y + 6*p[2].y - p[3].y) / 6,\n\t                  p[2].x,\n\t                  p[2].y\n\t            ]);\n\t        }\n\t\n\t        return d;\n\t    }\n\t\n\t    // export\n\t    Snap.path = paths;\n\t\n\t    /*\\\n\t     * Snap.path.getTotalLength\n\t     [ method ]\n\t     **\n\t     * Returns the length of the given path in pixels\n\t     **\n\t     - path (string) SVG path string\n\t     **\n\t     = (number) length\n\t    \\*/\n\t    Snap.path.getTotalLength = getTotalLength;\n\t    /*\\\n\t     * Snap.path.getPointAtLength\n\t     [ method ]\n\t     **\n\t     * Returns the coordinates of the point located at the given length along the given path\n\t     **\n\t     - path (string) SVG path string\n\t     - length (number) length, in pixels, from the start of the path, excluding non-rendering jumps\n\t     **\n\t     = (object) representation of the point:\n\t     o {\n\t     o     x: (number) x coordinate,\n\t     o     y: (number) y coordinate,\n\t     o     alpha: (number) angle of derivative\n\t     o }\n\t    \\*/\n\t    Snap.path.getPointAtLength = getPointAtLength;\n\t    /*\\\n\t     * Snap.path.getSubpath\n\t     [ method ]\n\t     **\n\t     * Returns the subpath of a given path between given start and end lengths\n\t     **\n\t     - path (string) SVG path string\n\t     - from (number) length, in pixels, from the start of the path to the start of the segment\n\t     - to (number) length, in pixels, from the start of the path to the end of the segment\n\t     **\n\t     = (string) path string definition for the segment\n\t    \\*/\n\t    Snap.path.getSubpath = function (path, from, to) {\n\t        if (this.getTotalLength(path) - to < 1e-6) {\n\t            return getSubpathsAtLength(path, from).end;\n\t        }\n\t        var a = getSubpathsAtLength(path, to, 1);\n\t        return from ? getSubpathsAtLength(a, from).end : a;\n\t    };\n\t    /*\\\n\t     * Element.getTotalLength\n\t     [ method ]\n\t     **\n\t     * Returns the length of the path in pixels (only works for `path` elements)\n\t     = (number) length\n\t    \\*/\n\t    elproto.getTotalLength = function () {\n\t        if (this.node.getTotalLength) {\n\t            return this.node.getTotalLength();\n\t        }\n\t    };\n\t    // SIERRA Element.getPointAtLength()/Element.getTotalLength(): If a <path> is broken into different segments, is the jump distance to the new coordinates set by the _M_ or _m_ commands calculated as part of the path's total length?\n\t    /*\\\n\t     * Element.getPointAtLength\n\t     [ method ]\n\t     **\n\t     * Returns coordinates of the point located at the given length on the given path (only works for `path` elements)\n\t     **\n\t     - length (number) length, in pixels, from the start of the path, excluding non-rendering jumps\n\t     **\n\t     = (object) representation of the point:\n\t     o {\n\t     o     x: (number) x coordinate,\n\t     o     y: (number) y coordinate,\n\t     o     alpha: (number) angle of derivative\n\t     o }\n\t    \\*/\n\t    elproto.getPointAtLength = function (length) {\n\t        return getPointAtLength(this.attr(\"d\"), length);\n\t    };\n\t    // SIERRA Element.getSubpath(): Similar to the problem for Element.getPointAtLength(). Unclear how this would work for a segmented path. Overall, the concept of _subpath_ and what I'm calling a _segment_ (series of non-_M_ or _Z_ commands) is unclear.\n\t    /*\\\n\t     * Element.getSubpath\n\t     [ method ]\n\t     **\n\t     * Returns subpath of a given element from given start and end lengths (only works for `path` elements)\n\t     **\n\t     - from (number) length, in pixels, from the start of the path to the start of the segment\n\t     - to (number) length, in pixels, from the start of the path to the end of the segment\n\t     **\n\t     = (string) path string definition for the segment\n\t    \\*/\n\t    elproto.getSubpath = function (from, to) {\n\t        return Snap.path.getSubpath(this.attr(\"d\"), from, to);\n\t    };\n\t    Snap._.box = box;\n\t    /*\\\n\t     * Snap.path.findDotsAtSegment\n\t     [ method ]\n\t     **\n\t     * Utility method\n\t     **\n\t     * Finds dot coordinates on the given cubic bezir curve at the given t\n\t     - p1x (number) x of the first point of the curve\n\t     - p1y (number) y of the first point of the curve\n\t     - c1x (number) x of the first anchor of the curve\n\t     - c1y (number) y of the first anchor of the curve\n\t     - c2x (number) x of the second anchor of the curve\n\t     - c2y (number) y of the second anchor of the curve\n\t     - p2x (number) x of the second point of the curve\n\t     - p2y (number) y of the second point of the curve\n\t     - t (number) position on the curve (0..1)\n\t     = (object) point information in format:\n\t     o {\n\t     o     x: (number) x coordinate of the point,\n\t     o     y: (number) y coordinate of the point,\n\t     o     m: {\n\t     o         x: (number) x coordinate of the left anchor,\n\t     o         y: (number) y coordinate of the left anchor\n\t     o     },\n\t     o     n: {\n\t     o         x: (number) x coordinate of the right anchor,\n\t     o         y: (number) y coordinate of the right anchor\n\t     o     },\n\t     o     start: {\n\t     o         x: (number) x coordinate of the start of the curve,\n\t     o         y: (number) y coordinate of the start of the curve\n\t     o     },\n\t     o     end: {\n\t     o         x: (number) x coordinate of the end of the curve,\n\t     o         y: (number) y coordinate of the end of the curve\n\t     o     },\n\t     o     alpha: (number) angle of the curve derivative at the point\n\t     o }\n\t    \\*/\n\t    Snap.path.findDotsAtSegment = findDotsAtSegment;\n\t    /*\\\n\t     * Snap.path.bezierBBox\n\t     [ method ]\n\t     **\n\t     * Utility method\n\t     **\n\t     * Returns the bounding box of a given cubic bezir curve\n\t     - p1x (number) x of the first point of the curve\n\t     - p1y (number) y of the first point of the curve\n\t     - c1x (number) x of the first anchor of the curve\n\t     - c1y (number) y of the first anchor of the curve\n\t     - c2x (number) x of the second anchor of the curve\n\t     - c2y (number) y of the second anchor of the curve\n\t     - p2x (number) x of the second point of the curve\n\t     - p2y (number) y of the second point of the curve\n\t     * or\n\t     - bez (array) array of six points for bezir curve\n\t     = (object) bounding box\n\t     o {\n\t     o     x: (number) x coordinate of the left top point of the box,\n\t     o     y: (number) y coordinate of the left top point of the box,\n\t     o     x2: (number) x coordinate of the right bottom point of the box,\n\t     o     y2: (number) y coordinate of the right bottom point of the box,\n\t     o     width: (number) width of the box,\n\t     o     height: (number) height of the box\n\t     o }\n\t    \\*/\n\t    Snap.path.bezierBBox = bezierBBox;\n\t    /*\\\n\t     * Snap.path.isPointInsideBBox\n\t     [ method ]\n\t     **\n\t     * Utility method\n\t     **\n\t     * Returns `true` if given point is inside bounding box\n\t     - bbox (string) bounding box\n\t     - x (string) x coordinate of the point\n\t     - y (string) y coordinate of the point\n\t     = (boolean) `true` if point is inside\n\t    \\*/\n\t    Snap.path.isPointInsideBBox = isPointInsideBBox;\n\t    Snap.closest = function (x, y, X, Y) {\n\t        var r = 100,\n\t            b = box(x - r / 2, y - r / 2, r, r),\n\t            inside = [],\n\t            getter = X[0].hasOwnProperty(\"x\") ? function (i) {\n\t                return {\n\t                    x: X[i].x,\n\t                    y: X[i].y\n\t                };\n\t            } : function (i) {\n\t                return {\n\t                    x: X[i],\n\t                    y: Y[i]\n\t                };\n\t            },\n\t            found = 0;\n\t        while (r <= 1e6 && !found) {\n\t            for (var i = 0, ii = X.length; i < ii; i++) {\n\t                var xy = getter(i);\n\t                if (isPointInsideBBox(b, xy.x, xy.y)) {\n\t                    found++;\n\t                    inside.push(xy);\n\t                    break;\n\t                }\n\t            }\n\t            if (!found) {\n\t                r *= 2;\n\t                b = box(x - r / 2, y - r / 2, r, r)\n\t            }\n\t        }\n\t        if (r == 1e6) {\n\t            return;\n\t        }\n\t        var len = Infinity,\n\t            res;\n\t        for (i = 0, ii = inside.length; i < ii; i++) {\n\t            var l = Snap.len(x, y, inside[i].x, inside[i].y);\n\t            if (len > l) {\n\t                len = l;\n\t                inside[i].len = l;\n\t                res = inside[i];\n\t            }\n\t        }\n\t        return res;\n\t    };\n\t    /*\\\n\t     * Snap.path.isBBoxIntersect\n\t     [ method ]\n\t     **\n\t     * Utility method\n\t     **\n\t     * Returns `true` if two bounding boxes intersect\n\t     - bbox1 (string) first bounding box\n\t     - bbox2 (string) second bounding box\n\t     = (boolean) `true` if bounding boxes intersect\n\t    \\*/\n\t    Snap.path.isBBoxIntersect = isBBoxIntersect;\n\t    /*\\\n\t     * Snap.path.intersection\n\t     [ method ]\n\t     **\n\t     * Utility method\n\t     **\n\t     * Finds intersections of two paths\n\t     - path1 (string) path string\n\t     - path2 (string) path string\n\t     = (array) dots of intersection\n\t     o [\n\t     o     {\n\t     o         x: (number) x coordinate of the point,\n\t     o         y: (number) y coordinate of the point,\n\t     o         t1: (number) t value for segment of path1,\n\t     o         t2: (number) t value for segment of path2,\n\t     o         segment1: (number) order number for segment of path1,\n\t     o         segment2: (number) order number for segment of path2,\n\t     o         bez1: (array) eight coordinates representing bezir curve for the segment of path1,\n\t     o         bez2: (array) eight coordinates representing bezir curve for the segment of path2\n\t     o     }\n\t     o ]\n\t    \\*/\n\t    Snap.path.intersection = pathIntersection;\n\t    Snap.path.intersectionNumber = pathIntersectionNumber;\n\t    /*\\\n\t     * Snap.path.isPointInside\n\t     [ method ]\n\t     **\n\t     * Utility method\n\t     **\n\t     * Returns `true` if given point is inside a given closed path.\n\t     *\n\t     * Note: fill mode doesnt affect the result of this method.\n\t     - path (string) path string\n\t     - x (number) x of the point\n\t     - y (number) y of the point\n\t     = (boolean) `true` if point is inside the path\n\t    \\*/\n\t    Snap.path.isPointInside = isPointInsidePath;\n\t    /*\\\n\t     * Snap.path.getBBox\n\t     [ method ]\n\t     **\n\t     * Utility method\n\t     **\n\t     * Returns the bounding box of a given path\n\t     - path (string) path string\n\t     = (object) bounding box\n\t     o {\n\t     o     x: (number) x coordinate of the left top point of the box,\n\t     o     y: (number) y coordinate of the left top point of the box,\n\t     o     x2: (number) x coordinate of the right bottom point of the box,\n\t     o     y2: (number) y coordinate of the right bottom point of the box,\n\t     o     width: (number) width of the box,\n\t     o     height: (number) height of the box\n\t     o }\n\t    \\*/\n\t    Snap.path.getBBox = pathBBox;\n\t    Snap.path.get = getPath;\n\t    /*\\\n\t     * Snap.path.toRelative\n\t     [ method ]\n\t     **\n\t     * Utility method\n\t     **\n\t     * Converts path coordinates into relative values\n\t     - path (string) path string\n\t     = (array) path string\n\t    \\*/\n\t    Snap.path.toRelative = pathToRelative;\n\t    /*\\\n\t     * Snap.path.toAbsolute\n\t     [ method ]\n\t     **\n\t     * Utility method\n\t     **\n\t     * Converts path coordinates into absolute values\n\t     - path (string) path string\n\t     = (array) path string\n\t    \\*/\n\t    Snap.path.toAbsolute = pathToAbsolute;\n\t    /*\\\n\t     * Snap.path.toCubic\n\t     [ method ]\n\t     **\n\t     * Utility method\n\t     **\n\t     * Converts path to a new path where all segments are cubic bezir curves\n\t     - pathString (string|array) path string or array of segments\n\t     = (array) array of segments\n\t    \\*/\n\t    Snap.path.toCubic = path2curve;\n\t    /*\\\n\t     * Snap.path.map\n\t     [ method ]\n\t     **\n\t     * Transform the path string with the given matrix\n\t     - path (string) path string\n\t     - matrix (object) see @Matrix\n\t     = (string) transformed path string\n\t    \\*/\n\t    Snap.path.map = mapPath;\n\t    Snap.path.toString = toString;\n\t    Snap.path.clone = pathClone;\n\t});\n\t\n\t// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n\t//\n\t// Licensed under the Apache License, Version 2.0 (the \"License\");\n\t// you may not use this file except in compliance with the License.\n\t// You may obtain a copy of the License at\n\t//\n\t// http://www.apache.org/licenses/LICENSE-2.0\n\t//\n\t// Unless required by applicable law or agreed to in writing, software\n\t// distributed under the License is distributed on an \"AS IS\" BASIS,\n\t// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t// See the License for the specific language governing permissions and\n\t// limitations under the License.\n\tSnap.plugin(function (Snap, Element, Paper, glob) {\n\t    var mmax = Math.max,\n\t        mmin = Math.min;\n\t\n\t    // Set\n\t    var Set = function (items) {\n\t        this.items = [];\n\t\tthis.bindings = {};\n\t        this.length = 0;\n\t        this.type = \"set\";\n\t        if (items) {\n\t            for (var i = 0, ii = items.length; i < ii; i++) {\n\t                if (items[i]) {\n\t                    this[this.items.length] = this.items[this.items.length] = items[i];\n\t                    this.length++;\n\t                }\n\t            }\n\t        }\n\t    },\n\t    setproto = Set.prototype;\n\t    /*\\\n\t     * Set.push\n\t     [ method ]\n\t     **\n\t     * Adds each argument to the current set\n\t     = (object) original element\n\t    \\*/\n\t    setproto.push = function () {\n\t        var item,\n\t            len;\n\t        for (var i = 0, ii = arguments.length; i < ii; i++) {\n\t            item = arguments[i];\n\t            if (item) {\n\t                len = this.items.length;\n\t                this[len] = this.items[len] = item;\n\t                this.length++;\n\t            }\n\t        }\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Set.pop\n\t     [ method ]\n\t     **\n\t     * Removes last element and returns it\n\t     = (object) element\n\t    \\*/\n\t    setproto.pop = function () {\n\t        this.length && delete this[this.length--];\n\t        return this.items.pop();\n\t    };\n\t    /*\\\n\t     * Set.forEach\n\t     [ method ]\n\t     **\n\t     * Executes given function for each element in the set\n\t     *\n\t     * If the function returns `false`, the loop stops running.\n\t     **\n\t     - callback (function) function to run\n\t     - thisArg (object) context object for the callback\n\t     = (object) Set object\n\t    \\*/\n\t    setproto.forEach = function (callback, thisArg) {\n\t        for (var i = 0, ii = this.items.length; i < ii; i++) {\n\t            if (callback.call(thisArg, this.items[i], i) === false) {\n\t                return this;\n\t            }\n\t        }\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Set.animate\n\t     [ method ]\n\t     **\n\t     * Animates each element in set in sync.\n\t     *\n\t     **\n\t     - attrs (object) key-value pairs of destination attributes\n\t     - duration (number) duration of the animation in milliseconds\n\t     - easing (function) #optional easing function from @mina or custom\n\t     - callback (function) #optional callback function that executes when the animation ends\n\t     * or\n\t     - animation (array) array of animation parameter for each element in set in format `[attrs, duration, easing, callback]`\n\t     > Usage\n\t     | // animate all elements in set to radius 10\n\t     | set.animate({r: 10}, 500, mina.easein);\n\t     | // or\n\t     | // animate first element to radius 10, but second to radius 20 and in different time\n\t     | set.animate([{r: 10}, 500, mina.easein], [{r: 20}, 1500, mina.easein]);\n\t     = (Element) the current element\n\t    \\*/\n\t    setproto.animate = function (attrs, ms, easing, callback) {\n\t        if (typeof easing == \"function\" && !easing.length) {\n\t            callback = easing;\n\t            easing = mina.linear;\n\t        }\n\t        if (attrs instanceof Snap._.Animation) {\n\t            callback = attrs.callback;\n\t            easing = attrs.easing;\n\t            ms = easing.dur;\n\t            attrs = attrs.attr;\n\t        }\n\t        var args = arguments;\n\t        if (Snap.is(attrs, \"array\") && Snap.is(args[args.length - 1], \"array\")) {\n\t            var each = true;\n\t        }\n\t        var begin,\n\t            handler = function () {\n\t                if (begin) {\n\t                    this.b = begin;\n\t                } else {\n\t                    begin = this.b;\n\t                }\n\t            },\n\t            cb = 0,\n\t            set = this,\n\t            callbacker = callback && function () {\n\t                if (++cb == set.length) {\n\t                    callback.call(this);\n\t                }\n\t            };\n\t        return this.forEach(function (el, i) {\n\t            eve.once(\"snap.animcreated.\" + el.id, handler);\n\t            if (each) {\n\t                args[i] && el.animate.apply(el, args[i]);\n\t            } else {\n\t                el.animate(attrs, ms, easing, callbacker);\n\t            }\n\t        });\n\t    };\n\t    setproto.remove = function () {\n\t        while (this.length) {\n\t            this.pop().remove();\n\t        }\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Set.bind\n\t     [ method ]\n\t     **\n\t     * Specifies how to handle a specific attribute when applied\n\t     * to a set.\n\t     *\n\t     **\n\t     - attr (string) attribute name\n\t     - callback (function) function to run\n\t     * or\n\t     - attr (string) attribute name\n\t     - element (Element) specific element in the set to apply the attribute to\n\t     * or\n\t     - attr (string) attribute name\n\t     - element (Element) specific element in the set to apply the attribute to\n\t     - eattr (string) attribute on the element to bind the attribute to\n\t     = (object) Set object\n\t    \\*/\n\t    setproto.bind = function (attr, a, b) {\n\t        var data = {};\n\t        if (typeof a == \"function\") {\n\t            this.bindings[attr] = a;\n\t        } else {\n\t            var aname = b || attr;\n\t            this.bindings[attr] = function (v) {\n\t                data[aname] = v;\n\t                a.attr(data);\n\t            };\n\t        }\n\t        return this;\n\t    };\n\t    setproto.attr = function (value) {\n\t        var unbound = {};\n\t        for (var k in value) {\n\t            if (this.bindings[k]) {\n\t                this.bindings[k](value[k]);\n\t            } else {\n\t                unbound[k] = value[k];\n\t            }\n\t        }\n\t        for (var i = 0, ii = this.items.length; i < ii; i++) {\n\t            this.items[i].attr(unbound);\n\t        }\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Set.clear\n\t     [ method ]\n\t     **\n\t     * Removes all elements from the set\n\t    \\*/\n\t    setproto.clear = function () {\n\t        while (this.length) {\n\t            this.pop();\n\t        }\n\t    };\n\t    /*\\\n\t     * Set.splice\n\t     [ method ]\n\t     **\n\t     * Removes range of elements from the set\n\t     **\n\t     - index (number) position of the deletion\n\t     - count (number) number of element to remove\n\t     - insertion (object) #optional elements to insert\n\t     = (object) set elements that were deleted\n\t    \\*/\n\t    setproto.splice = function (index, count, insertion) {\n\t        index = index < 0 ? mmax(this.length + index, 0) : index;\n\t        count = mmax(0, mmin(this.length - index, count));\n\t        var tail = [],\n\t            todel = [],\n\t            args = [],\n\t            i;\n\t        for (i = 2; i < arguments.length; i++) {\n\t            args.push(arguments[i]);\n\t        }\n\t        for (i = 0; i < count; i++) {\n\t            todel.push(this[index + i]);\n\t        }\n\t        for (; i < this.length - index; i++) {\n\t            tail.push(this[index + i]);\n\t        }\n\t        var arglen = args.length;\n\t        for (i = 0; i < arglen + tail.length; i++) {\n\t            this.items[index + i] = this[index + i] = i < arglen ? args[i] : tail[i - arglen];\n\t        }\n\t        i = this.items.length = this.length -= count - arglen;\n\t        while (this[i]) {\n\t            delete this[i++];\n\t        }\n\t        return new Set(todel);\n\t    };\n\t    /*\\\n\t     * Set.exclude\n\t     [ method ]\n\t     **\n\t     * Removes given element from the set\n\t     **\n\t     - element (object) element to remove\n\t     = (boolean) `true` if object was found and removed from the set\n\t    \\*/\n\t    setproto.exclude = function (el) {\n\t        for (var i = 0, ii = this.length; i < ii; i++) if (this[i] == el) {\n\t            this.splice(i, 1);\n\t            return true;\n\t        }\n\t        return false;\n\t    };\n\t    setproto.insertAfter = function (el) {\n\t        var i = this.items.length;\n\t        while (i--) {\n\t            this.items[i].insertAfter(el);\n\t        }\n\t        return this;\n\t    };\n\t    setproto.getBBox = function () {\n\t        var x = [],\n\t            y = [],\n\t            x2 = [],\n\t            y2 = [];\n\t        for (var i = this.items.length; i--;) if (!this.items[i].removed) {\n\t            var box = this.items[i].getBBox();\n\t            x.push(box.x);\n\t            y.push(box.y);\n\t            x2.push(box.x + box.width);\n\t            y2.push(box.y + box.height);\n\t        }\n\t        x = mmin.apply(0, x);\n\t        y = mmin.apply(0, y);\n\t        x2 = mmax.apply(0, x2);\n\t        y2 = mmax.apply(0, y2);\n\t        return {\n\t            x: x,\n\t            y: y,\n\t            x2: x2,\n\t            y2: y2,\n\t            width: x2 - x,\n\t            height: y2 - y,\n\t            cx: x + (x2 - x) / 2,\n\t            cy: y + (y2 - y) / 2\n\t        };\n\t    };\n\t    setproto.clone = function (s) {\n\t        s = new Set;\n\t        for (var i = 0, ii = this.items.length; i < ii; i++) {\n\t            s.push(this.items[i].clone());\n\t        }\n\t        return s;\n\t    };\n\t    setproto.toString = function () {\n\t        return \"Snap\\u2018s set\";\n\t    };\n\t    setproto.type = \"set\";\n\t    // export\n\t    Snap.Set = Set;\n\t    Snap.set = function () {\n\t        var set = new Set;\n\t        if (arguments.length) {\n\t            set.push.apply(set, Array.prototype.slice.call(arguments, 0));\n\t        }\n\t        return set;\n\t    };\n\t});\n\t\n\t// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n\t//\n\t// Licensed under the Apache License, Version 2.0 (the \"License\");\n\t// you may not use this file except in compliance with the License.\n\t// You may obtain a copy of the License at\n\t//\n\t// http://www.apache.org/licenses/LICENSE-2.0\n\t//\n\t// Unless required by applicable law or agreed to in writing, software\n\t// distributed under the License is distributed on an \"AS IS\" BASIS,\n\t// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t// See the License for the specific language governing permissions and\n\t// limitations under the License.\n\tSnap.plugin(function (Snap, Element, Paper, glob) {\n\t    var names = {},\n\t        reUnit = /[a-z]+$/i,\n\t        Str = String;\n\t    names.stroke = names.fill = \"colour\";\n\t    function getEmpty(item) {\n\t        var l = item[0];\n\t        switch (l.toLowerCase()) {\n\t            case \"t\": return [l, 0, 0];\n\t            case \"m\": return [l, 1, 0, 0, 1, 0, 0];\n\t            case \"r\": if (item.length == 4) {\n\t                return [l, 0, item[2], item[3]];\n\t            } else {\n\t                return [l, 0];\n\t            }\n\t            case \"s\": if (item.length == 5) {\n\t                return [l, 1, 1, item[3], item[4]];\n\t            } else if (item.length == 3) {\n\t                return [l, 1, 1];\n\t            } else {\n\t                return [l, 1];\n\t            }\n\t        }\n\t    }\n\t    function equaliseTransform(t1, t2, getBBox) {\n\t        t2 = Str(t2).replace(/\\.{3}|\\u2026/g, t1);\n\t        t1 = Snap.parseTransformString(t1) || [];\n\t        t2 = Snap.parseTransformString(t2) || [];\n\t        var maxlength = Math.max(t1.length, t2.length),\n\t            from = [],\n\t            to = [],\n\t            i = 0, j, jj,\n\t            tt1, tt2;\n\t        for (; i < maxlength; i++) {\n\t            tt1 = t1[i] || getEmpty(t2[i]);\n\t            tt2 = t2[i] || getEmpty(tt1);\n\t            if ((tt1[0] != tt2[0]) ||\n\t                (tt1[0].toLowerCase() == \"r\" && (tt1[2] != tt2[2] || tt1[3] != tt2[3])) ||\n\t                (tt1[0].toLowerCase() == \"s\" && (tt1[3] != tt2[3] || tt1[4] != tt2[4]))\n\t                ) {\n\t                    t1 = Snap._.transform2matrix(t1, getBBox());\n\t                    t2 = Snap._.transform2matrix(t2, getBBox());\n\t                    from = [[\"m\", t1.a, t1.b, t1.c, t1.d, t1.e, t1.f]];\n\t                    to = [[\"m\", t2.a, t2.b, t2.c, t2.d, t2.e, t2.f]];\n\t                    break;\n\t            }\n\t            from[i] = [];\n\t            to[i] = [];\n\t            for (j = 0, jj = Math.max(tt1.length, tt2.length); j < jj; j++) {\n\t                j in tt1 && (from[i][j] = tt1[j]);\n\t                j in tt2 && (to[i][j] = tt2[j]);\n\t            }\n\t        }\n\t        return {\n\t            from: path2array(from),\n\t            to: path2array(to),\n\t            f: getPath(from)\n\t        };\n\t    }\n\t    function getNumber(val) {\n\t        return val;\n\t    }\n\t    function getUnit(unit) {\n\t        return function (val) {\n\t            return +val.toFixed(3) + unit;\n\t        };\n\t    }\n\t    function getViewBox(val) {\n\t        return val.join(\" \");\n\t    }\n\t    function getColour(clr) {\n\t        return Snap.rgb(clr[0], clr[1], clr[2]);\n\t    }\n\t    function getPath(path) {\n\t        var k = 0, i, ii, j, jj, out, a, b = [];\n\t        for (i = 0, ii = path.length; i < ii; i++) {\n\t            out = \"[\";\n\t            a = ['\"' + path[i][0] + '\"'];\n\t            for (j = 1, jj = path[i].length; j < jj; j++) {\n\t                a[j] = \"val[\" + (k++) + \"]\";\n\t            }\n\t            out += a + \"]\";\n\t            b[i] = out;\n\t        }\n\t        return Function(\"val\", \"return Snap.path.toString.call([\" + b + \"])\");\n\t    }\n\t    function path2array(path) {\n\t        var out = [];\n\t        for (var i = 0, ii = path.length; i < ii; i++) {\n\t            for (var j = 1, jj = path[i].length; j < jj; j++) {\n\t                out.push(path[i][j]);\n\t            }\n\t        }\n\t        return out;\n\t    }\n\t    function isNumeric(obj) {\n\t        return isFinite(parseFloat(obj));\n\t    }\n\t    function arrayEqual(arr1, arr2) {\n\t        if (!Snap.is(arr1, \"array\") || !Snap.is(arr2, \"array\")) {\n\t            return false;\n\t        }\n\t        return arr1.toString() == arr2.toString();\n\t    }\n\t    Element.prototype.equal = function (name, b) {\n\t        return eve(\"snap.util.equal\", this, name, b).firstDefined();\n\t    };\n\t    eve.on(\"snap.util.equal\", function (name, b) {\n\t        var A, B, a = Str(this.attr(name) || \"\"),\n\t            el = this;\n\t        if (isNumeric(a) && isNumeric(b)) {\n\t            return {\n\t                from: parseFloat(a),\n\t                to: parseFloat(b),\n\t                f: getNumber\n\t            };\n\t        }\n\t        if (names[name] == \"colour\") {\n\t            A = Snap.color(a);\n\t            B = Snap.color(b);\n\t            return {\n\t                from: [A.r, A.g, A.b, A.opacity],\n\t                to: [B.r, B.g, B.b, B.opacity],\n\t                f: getColour\n\t            };\n\t        }\n\t        if (name == \"viewBox\") {\n\t            A = this.attr(name).vb.split(\" \").map(Number);\n\t            B = b.split(\" \").map(Number);\n\t            return {\n\t                from: A,\n\t                to: B,\n\t                f: getViewBox\n\t            };\n\t        }\n\t        if (name == \"transform\" || name == \"gradientTransform\" || name == \"patternTransform\") {\n\t            if (b instanceof Snap.Matrix) {\n\t                b = b.toTransformString();\n\t            }\n\t            if (!Snap._.rgTransform.test(b)) {\n\t                b = Snap._.svgTransform2string(b);\n\t            }\n\t            return equaliseTransform(a, b, function () {\n\t                return el.getBBox(1);\n\t            });\n\t        }\n\t        if (name == \"d\" || name == \"path\") {\n\t            A = Snap.path.toCubic(a, b);\n\t            return {\n\t                from: path2array(A[0]),\n\t                to: path2array(A[1]),\n\t                f: getPath(A[0])\n\t            };\n\t        }\n\t        if (name == \"points\") {\n\t            A = Str(a).split(Snap._.separator);\n\t            B = Str(b).split(Snap._.separator);\n\t            return {\n\t                from: A,\n\t                to: B,\n\t                f: function (val) { return val; }\n\t            };\n\t        }\n\t        var aUnit = a.match(reUnit),\n\t            bUnit = Str(b).match(reUnit);\n\t        if (aUnit && arrayEqual(aUnit, bUnit)) {\n\t            return {\n\t                from: parseFloat(a),\n\t                to: parseFloat(b),\n\t                f: getUnit(aUnit)\n\t            };\n\t        } else {\n\t            return {\n\t                from: this.asPX(name),\n\t                to: this.asPX(name, b),\n\t                f: getNumber\n\t            };\n\t        }\n\t    });\n\t});\n\t\n\t// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n\t//\n\t// Licensed under the Apache License, Version 2.0 (the \"License\");\n\t// you may not use this file except in compliance with the License.\n\t// You may obtain a copy of the License at\n\t//\n\t// http://www.apache.org/licenses/LICENSE-2.0\n\t//\n\t// Unless required by applicable law or agreed to in writing, software\n\t// distributed under the License is distributed on an \"AS IS\" BASIS,\n\t// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t// See the License for the specific language governing permissions and\n\t// limitations under the License.\n\tSnap.plugin(function (Snap, Element, Paper, glob) {\n\t    var elproto = Element.prototype,\n\t    has = \"hasOwnProperty\",\n\t    supportsTouch = \"createTouch\" in glob.doc,\n\t    events = [\n\t        \"click\", \"dblclick\", \"mousedown\", \"mousemove\", \"mouseout\",\n\t        \"mouseover\", \"mouseup\", \"touchstart\", \"touchmove\", \"touchend\",\n\t        \"touchcancel\"\n\t    ],\n\t    touchMap = {\n\t        mousedown: \"touchstart\",\n\t        mousemove: \"touchmove\",\n\t        mouseup: \"touchend\"\n\t    },\n\t    getScroll = function (xy, el) {\n\t        var name = xy == \"y\" ? \"scrollTop\" : \"scrollLeft\",\n\t            doc = el && el.node ? el.node.ownerDocument : glob.doc;\n\t        return doc[name in doc.documentElement ? \"documentElement\" : \"body\"][name];\n\t    },\n\t    preventDefault = function () {\n\t        this.returnValue = false;\n\t    },\n\t    preventTouch = function () {\n\t        return this.originalEvent.preventDefault();\n\t    },\n\t    stopPropagation = function () {\n\t        this.cancelBubble = true;\n\t    },\n\t    stopTouch = function () {\n\t        return this.originalEvent.stopPropagation();\n\t    },\n\t    addEvent = function (obj, type, fn, element) {\n\t        var realName = supportsTouch && touchMap[type] ? touchMap[type] : type,\n\t            f = function (e) {\n\t                var scrollY = getScroll(\"y\", element),\n\t                    scrollX = getScroll(\"x\", element);\n\t                if (supportsTouch && touchMap[has](type)) {\n\t                    for (var i = 0, ii = e.targetTouches && e.targetTouches.length; i < ii; i++) {\n\t                        if (e.targetTouches[i].target == obj || obj.contains(e.targetTouches[i].target)) {\n\t                            var olde = e;\n\t                            e = e.targetTouches[i];\n\t                            e.originalEvent = olde;\n\t                            e.preventDefault = preventTouch;\n\t                            e.stopPropagation = stopTouch;\n\t                            break;\n\t                        }\n\t                    }\n\t                }\n\t                var x = e.clientX + scrollX,\n\t                    y = e.clientY + scrollY;\n\t                return fn.call(element, e, x, y);\n\t            };\n\t\n\t        if (type !== realName) {\n\t            obj.addEventListener(type, f, false);\n\t        }\n\t\n\t        obj.addEventListener(realName, f, false);\n\t\n\t        return function () {\n\t            if (type !== realName) {\n\t                obj.removeEventListener(type, f, false);\n\t            }\n\t\n\t            obj.removeEventListener(realName, f, false);\n\t            return true;\n\t        };\n\t    },\n\t    drag = [],\n\t    dragMove = function (e) {\n\t        var x = e.clientX,\n\t            y = e.clientY,\n\t            scrollY = getScroll(\"y\"),\n\t            scrollX = getScroll(\"x\"),\n\t            dragi,\n\t            j = drag.length;\n\t        while (j--) {\n\t            dragi = drag[j];\n\t            if (supportsTouch) {\n\t                var i = e.touches && e.touches.length,\n\t                    touch;\n\t                while (i--) {\n\t                    touch = e.touches[i];\n\t                    if (touch.identifier == dragi.el._drag.id || dragi.el.node.contains(touch.target)) {\n\t                        x = touch.clientX;\n\t                        y = touch.clientY;\n\t                        (e.originalEvent ? e.originalEvent : e).preventDefault();\n\t                        break;\n\t                    }\n\t                }\n\t            } else {\n\t                e.preventDefault();\n\t            }\n\t            var node = dragi.el.node,\n\t                o,\n\t                next = node.nextSibling,\n\t                parent = node.parentNode,\n\t                display = node.style.display;\n\t            // glob.win.opera && parent.removeChild(node);\n\t            // node.style.display = \"none\";\n\t            // o = dragi.el.paper.getElementByPoint(x, y);\n\t            // node.style.display = display;\n\t            // glob.win.opera && (next ? parent.insertBefore(node, next) : parent.appendChild(node));\n\t            // o && eve(\"snap.drag.over.\" + dragi.el.id, dragi.el, o);\n\t            x += scrollX;\n\t            y += scrollY;\n\t            eve(\"snap.drag.move.\" + dragi.el.id, dragi.move_scope || dragi.el, x - dragi.el._drag.x, y - dragi.el._drag.y, x, y, e);\n\t        }\n\t    },\n\t    dragUp = function (e) {\n\t        Snap.unmousemove(dragMove).unmouseup(dragUp);\n\t        var i = drag.length,\n\t            dragi;\n\t        while (i--) {\n\t            dragi = drag[i];\n\t            dragi.el._drag = {};\n\t            eve(\"snap.drag.end.\" + dragi.el.id, dragi.end_scope || dragi.start_scope || dragi.move_scope || dragi.el, e);\n\t            eve.off(\"snap.drag.*.\" + dragi.el.id);\n\t        }\n\t        drag = [];\n\t    };\n\t    /*\\\n\t     * Element.click\n\t     [ method ]\n\t     **\n\t     * Adds a click event handler to the element\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t    /*\\\n\t     * Element.unclick\n\t     [ method ]\n\t     **\n\t     * Removes a click event handler from the element\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t\n\t    /*\\\n\t     * Element.dblclick\n\t     [ method ]\n\t     **\n\t     * Adds a double click event handler to the element\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t    /*\\\n\t     * Element.undblclick\n\t     [ method ]\n\t     **\n\t     * Removes a double click event handler from the element\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t\n\t    /*\\\n\t     * Element.mousedown\n\t     [ method ]\n\t     **\n\t     * Adds a mousedown event handler to the element\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t    /*\\\n\t     * Element.unmousedown\n\t     [ method ]\n\t     **\n\t     * Removes a mousedown event handler from the element\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t\n\t    /*\\\n\t     * Element.mousemove\n\t     [ method ]\n\t     **\n\t     * Adds a mousemove event handler to the element\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t    /*\\\n\t     * Element.unmousemove\n\t     [ method ]\n\t     **\n\t     * Removes a mousemove event handler from the element\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t\n\t    /*\\\n\t     * Element.mouseout\n\t     [ method ]\n\t     **\n\t     * Adds a mouseout event handler to the element\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t    /*\\\n\t     * Element.unmouseout\n\t     [ method ]\n\t     **\n\t     * Removes a mouseout event handler from the element\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t\n\t    /*\\\n\t     * Element.mouseover\n\t     [ method ]\n\t     **\n\t     * Adds a mouseover event handler to the element\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t    /*\\\n\t     * Element.unmouseover\n\t     [ method ]\n\t     **\n\t     * Removes a mouseover event handler from the element\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t\n\t    /*\\\n\t     * Element.mouseup\n\t     [ method ]\n\t     **\n\t     * Adds a mouseup event handler to the element\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t    /*\\\n\t     * Element.unmouseup\n\t     [ method ]\n\t     **\n\t     * Removes a mouseup event handler from the element\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t\n\t    /*\\\n\t     * Element.touchstart\n\t     [ method ]\n\t     **\n\t     * Adds a touchstart event handler to the element\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t    /*\\\n\t     * Element.untouchstart\n\t     [ method ]\n\t     **\n\t     * Removes a touchstart event handler from the element\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t\n\t    /*\\\n\t     * Element.touchmove\n\t     [ method ]\n\t     **\n\t     * Adds a touchmove event handler to the element\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t    /*\\\n\t     * Element.untouchmove\n\t     [ method ]\n\t     **\n\t     * Removes a touchmove event handler from the element\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t\n\t    /*\\\n\t     * Element.touchend\n\t     [ method ]\n\t     **\n\t     * Adds a touchend event handler to the element\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t    /*\\\n\t     * Element.untouchend\n\t     [ method ]\n\t     **\n\t     * Removes a touchend event handler from the element\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t\n\t    /*\\\n\t     * Element.touchcancel\n\t     [ method ]\n\t     **\n\t     * Adds a touchcancel event handler to the element\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t    /*\\\n\t     * Element.untouchcancel\n\t     [ method ]\n\t     **\n\t     * Removes a touchcancel event handler from the element\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t    for (var i = events.length; i--;) {\n\t        (function (eventName) {\n\t            Snap[eventName] = elproto[eventName] = function (fn, scope) {\n\t                if (Snap.is(fn, \"function\")) {\n\t                    this.events = this.events || [];\n\t                    this.events.push({\n\t                        name: eventName,\n\t                        f: fn,\n\t                        unbind: addEvent(this.node || document, eventName, fn, scope || this)\n\t                    });\n\t                } else {\n\t                    for (var i = 0, ii = this.events.length; i < ii; i++) if (this.events[i].name == eventName) {\n\t                        try {\n\t                            this.events[i].f.call(this);\n\t                        } catch (e) {}\n\t                    }\n\t                }\n\t                return this;\n\t            };\n\t            Snap[\"un\" + eventName] =\n\t            elproto[\"un\" + eventName] = function (fn) {\n\t                var events = this.events || [],\n\t                    l = events.length;\n\t                while (l--) if (events[l].name == eventName &&\n\t                               (events[l].f == fn || !fn)) {\n\t                    events[l].unbind();\n\t                    events.splice(l, 1);\n\t                    !events.length && delete this.events;\n\t                    return this;\n\t                }\n\t                return this;\n\t            };\n\t        })(events[i]);\n\t    }\n\t    /*\\\n\t     * Element.hover\n\t     [ method ]\n\t     **\n\t     * Adds hover event handlers to the element\n\t     - f_in (function) handler for hover in\n\t     - f_out (function) handler for hover out\n\t     - icontext (object) #optional context for hover in handler\n\t     - ocontext (object) #optional context for hover out handler\n\t     = (object) @Element\n\t    \\*/\n\t    elproto.hover = function (f_in, f_out, scope_in, scope_out) {\n\t        return this.mouseover(f_in, scope_in).mouseout(f_out, scope_out || scope_in);\n\t    };\n\t    /*\\\n\t     * Element.unhover\n\t     [ method ]\n\t     **\n\t     * Removes hover event handlers from the element\n\t     - f_in (function) handler for hover in\n\t     - f_out (function) handler for hover out\n\t     = (object) @Element\n\t    \\*/\n\t    elproto.unhover = function (f_in, f_out) {\n\t        return this.unmouseover(f_in).unmouseout(f_out);\n\t    };\n\t    var draggable = [];\n\t    // SIERRA unclear what _context_ refers to for starting, ending, moving the drag gesture.\n\t    // SIERRA Element.drag(): _x position of the mouse_: Where are the x/y values offset from?\n\t    // SIERRA Element.drag(): much of this member's doc appears to be duplicated for some reason.\n\t    // SIERRA Unclear about this sentence: _Additionally following drag events will be triggered: drag.start.<id> on start, drag.end.<id> on end and drag.move.<id> on every move._ Is there a global _drag_ object to which you can assign handlers keyed by an element's ID?\n\t    /*\\\n\t     * Element.drag\n\t     [ method ]\n\t     **\n\t     * Adds event handlers for an element's drag gesture\n\t     **\n\t     - onmove (function) handler for moving\n\t     - onstart (function) handler for drag start\n\t     - onend (function) handler for drag end\n\t     - mcontext (object) #optional context for moving handler\n\t     - scontext (object) #optional context for drag start handler\n\t     - econtext (object) #optional context for drag end handler\n\t     * Additionaly following `drag` events are triggered: `drag.start.<id>` on start,\n\t     * `drag.end.<id>` on end and `drag.move.<id>` on every move. When element is dragged over another element\n\t     * `drag.over.<id>` fires as well.\n\t     *\n\t     * Start event and start handler are called in specified context or in context of the element with following parameters:\n\t     o x (number) x position of the mouse\n\t     o y (number) y position of the mouse\n\t     o event (object) DOM event object\n\t     * Move event and move handler are called in specified context or in context of the element with following parameters:\n\t     o dx (number) shift by x from the start point\n\t     o dy (number) shift by y from the start point\n\t     o x (number) x position of the mouse\n\t     o y (number) y position of the mouse\n\t     o event (object) DOM event object\n\t     * End event and end handler are called in specified context or in context of the element with following parameters:\n\t     o event (object) DOM event object\n\t     = (object) @Element\n\t    \\*/\n\t    elproto.drag = function (onmove, onstart, onend, move_scope, start_scope, end_scope) {\n\t        var el = this;\n\t        if (!arguments.length) {\n\t            var origTransform;\n\t            return el.drag(function (dx, dy) {\n\t                this.attr({\n\t                    transform: origTransform + (origTransform ? \"T\" : \"t\") + [dx, dy]\n\t                });\n\t            }, function () {\n\t                origTransform = this.transform().local;\n\t            });\n\t        }\n\t        function start(e, x, y) {\n\t            (e.originalEvent || e).preventDefault();\n\t            el._drag.x = x;\n\t            el._drag.y = y;\n\t            el._drag.id = e.identifier;\n\t            !drag.length && Snap.mousemove(dragMove).mouseup(dragUp);\n\t            drag.push({el: el, move_scope: move_scope, start_scope: start_scope, end_scope: end_scope});\n\t            onstart && eve.on(\"snap.drag.start.\" + el.id, onstart);\n\t            onmove && eve.on(\"snap.drag.move.\" + el.id, onmove);\n\t            onend && eve.on(\"snap.drag.end.\" + el.id, onend);\n\t            eve(\"snap.drag.start.\" + el.id, start_scope || move_scope || el, x, y, e);\n\t        }\n\t        function init(e, x, y) {\n\t            eve(\"snap.draginit.\" + el.id, el, e, x, y);\n\t        }\n\t        eve.on(\"snap.draginit.\" + el.id, start);\n\t        el._drag = {};\n\t        draggable.push({el: el, start: start, init: init});\n\t        el.mousedown(init);\n\t        return el;\n\t    };\n\t    /*\n\t     * Element.onDragOver\n\t     [ method ]\n\t     **\n\t     * Shortcut to assign event handler for `drag.over.<id>` event, where `id` is the element's `id` (see @Element.id)\n\t     - f (function) handler for event, first argument would be the element you are dragging over\n\t    \\*/\n\t    // elproto.onDragOver = function (f) {\n\t    //     f ? eve.on(\"snap.drag.over.\" + this.id, f) : eve.unbind(\"snap.drag.over.\" + this.id);\n\t    // };\n\t    /*\\\n\t     * Element.undrag\n\t     [ method ]\n\t     **\n\t     * Removes all drag event handlers from the given element\n\t    \\*/\n\t    elproto.undrag = function () {\n\t        var i = draggable.length;\n\t        while (i--) if (draggable[i].el == this) {\n\t            this.unmousedown(draggable[i].init);\n\t            draggable.splice(i, 1);\n\t            eve.unbind(\"snap.drag.*.\" + this.id);\n\t            eve.unbind(\"snap.draginit.\" + this.id);\n\t        }\n\t        !draggable.length && Snap.unmousemove(dragMove).unmouseup(dragUp);\n\t        return this;\n\t    };\n\t});\n\t\n\t// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n\t//\n\t// Licensed under the Apache License, Version 2.0 (the \"License\");\n\t// you may not use this file except in compliance with the License.\n\t// You may obtain a copy of the License at\n\t//\n\t// http://www.apache.org/licenses/LICENSE-2.0\n\t//\n\t// Unless required by applicable law or agreed to in writing, software\n\t// distributed under the License is distributed on an \"AS IS\" BASIS,\n\t// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t// See the License for the specific language governing permissions and\n\t// limitations under the License.\n\tSnap.plugin(function (Snap, Element, Paper, glob) {\n\t    var elproto = Element.prototype,\n\t        pproto = Paper.prototype,\n\t        rgurl = /^\\s*url\\((.+)\\)/,\n\t        Str = String,\n\t        $ = Snap._.$;\n\t    Snap.filter = {};\n\t    /*\\\n\t     * Paper.filter\n\t     [ method ]\n\t     **\n\t     * Creates a `<filter>` element\n\t     **\n\t     - filstr (string) SVG fragment of filter provided as a string\n\t     = (object) @Element\n\t     * Note: It is recommended to use filters embedded into the page inside an empty SVG element.\n\t     > Usage\n\t     | var f = paper.filter('<feGaussianBlur stdDeviation=\"2\"/>'),\n\t     |     c = paper.circle(10, 10, 10).attr({\n\t     |         filter: f\n\t     |     });\n\t    \\*/\n\t    pproto.filter = function (filstr) {\n\t        var paper = this;\n\t        if (paper.type != \"svg\") {\n\t            paper = paper.paper;\n\t        }\n\t        var f = Snap.parse(Str(filstr)),\n\t            id = Snap._.id(),\n\t            width = paper.node.offsetWidth,\n\t            height = paper.node.offsetHeight,\n\t            filter = $(\"filter\");\n\t        $(filter, {\n\t            id: id,\n\t            filterUnits: \"userSpaceOnUse\"\n\t        });\n\t        filter.appendChild(f.node);\n\t        paper.defs.appendChild(filter);\n\t        return new Element(filter);\n\t    };\n\t\n\t    eve.on(\"snap.util.getattr.filter\", function () {\n\t        eve.stop();\n\t        var p = $(this.node, \"filter\");\n\t        if (p) {\n\t            var match = Str(p).match(rgurl);\n\t            return match && Snap.select(match[1]);\n\t        }\n\t    });\n\t    eve.on(\"snap.util.attr.filter\", function (value) {\n\t        if (value instanceof Element && value.type == \"filter\") {\n\t            eve.stop();\n\t            var id = value.node.id;\n\t            if (!id) {\n\t                $(value.node, {id: value.id});\n\t                id = value.id;\n\t            }\n\t            $(this.node, {\n\t                filter: Snap.url(id)\n\t            });\n\t        }\n\t        if (!value || value == \"none\") {\n\t            eve.stop();\n\t            this.node.removeAttribute(\"filter\");\n\t        }\n\t    });\n\t    /*\\\n\t     * Snap.filter.blur\n\t     [ method ]\n\t     **\n\t     * Returns an SVG markup string for the blur filter\n\t     **\n\t     - x (number) amount of horizontal blur, in pixels\n\t     - y (number) #optional amount of vertical blur, in pixels\n\t     = (string) filter representation\n\t     > Usage\n\t     | var f = paper.filter(Snap.filter.blur(5, 10)),\n\t     |     c = paper.circle(10, 10, 10).attr({\n\t     |         filter: f\n\t     |     });\n\t    \\*/\n\t    Snap.filter.blur = function (x, y) {\n\t        if (x == null) {\n\t            x = 2;\n\t        }\n\t        var def = y == null ? x : [x, y];\n\t        return Snap.format('\\<feGaussianBlur stdDeviation=\"{def}\"/>', {\n\t            def: def\n\t        });\n\t    };\n\t    Snap.filter.blur.toString = function () {\n\t        return this();\n\t    };\n\t    /*\\\n\t     * Snap.filter.shadow\n\t     [ method ]\n\t     **\n\t     * Returns an SVG markup string for the shadow filter\n\t     **\n\t     - dx (number) #optional horizontal shift of the shadow, in pixels\n\t     - dy (number) #optional vertical shift of the shadow, in pixels\n\t     - blur (number) #optional amount of blur\n\t     - color (string) #optional color of the shadow\n\t     - opacity (number) #optional `0..1` opacity of the shadow\n\t     * or\n\t     - dx (number) #optional horizontal shift of the shadow, in pixels\n\t     - dy (number) #optional vertical shift of the shadow, in pixels\n\t     - color (string) #optional color of the shadow\n\t     - opacity (number) #optional `0..1` opacity of the shadow\n\t     * which makes blur default to `4`. Or\n\t     - dx (number) #optional horizontal shift of the shadow, in pixels\n\t     - dy (number) #optional vertical shift of the shadow, in pixels\n\t     - opacity (number) #optional `0..1` opacity of the shadow\n\t     = (string) filter representation\n\t     > Usage\n\t     | var f = paper.filter(Snap.filter.shadow(0, 2, 3)),\n\t     |     c = paper.circle(10, 10, 10).attr({\n\t     |         filter: f\n\t     |     });\n\t    \\*/\n\t    Snap.filter.shadow = function (dx, dy, blur, color, opacity) {\n\t        if (typeof blur == \"string\") {\n\t            color = blur;\n\t            opacity = color;\n\t            blur = 4;\n\t        }\n\t        if (typeof color != \"string\") {\n\t            opacity = color;\n\t            color = \"#000\";\n\t        }\n\t        color = color || \"#000\";\n\t        if (blur == null) {\n\t            blur = 4;\n\t        }\n\t        if (opacity == null) {\n\t            opacity = 1;\n\t        }\n\t        if (dx == null) {\n\t            dx = 0;\n\t            dy = 2;\n\t        }\n\t        if (dy == null) {\n\t            dy = dx;\n\t        }\n\t        color = Snap.color(color);\n\t        return Snap.format('<feGaussianBlur in=\"SourceAlpha\" stdDeviation=\"{blur}\"/><feOffset dx=\"{dx}\" dy=\"{dy}\" result=\"offsetblur\"/><feFlood flood-color=\"{color}\"/><feComposite in2=\"offsetblur\" operator=\"in\"/><feComponentTransfer><feFuncA type=\"linear\" slope=\"{opacity}\"/></feComponentTransfer><feMerge><feMergeNode/><feMergeNode in=\"SourceGraphic\"/></feMerge>', {\n\t            color: color,\n\t            dx: dx,\n\t            dy: dy,\n\t            blur: blur,\n\t            opacity: opacity\n\t        });\n\t    };\n\t    Snap.filter.shadow.toString = function () {\n\t        return this();\n\t    };\n\t    /*\\\n\t     * Snap.filter.grayscale\n\t     [ method ]\n\t     **\n\t     * Returns an SVG markup string for the grayscale filter\n\t     **\n\t     - amount (number) amount of filter (`0..1`)\n\t     = (string) filter representation\n\t    \\*/\n\t    Snap.filter.grayscale = function (amount) {\n\t        if (amount == null) {\n\t            amount = 1;\n\t        }\n\t        return Snap.format('<feColorMatrix type=\"matrix\" values=\"{a} {b} {c} 0 0 {d} {e} {f} 0 0 {g} {b} {h} 0 0 0 0 0 1 0\"/>', {\n\t            a: 0.2126 + 0.7874 * (1 - amount),\n\t            b: 0.7152 - 0.7152 * (1 - amount),\n\t            c: 0.0722 - 0.0722 * (1 - amount),\n\t            d: 0.2126 - 0.2126 * (1 - amount),\n\t            e: 0.7152 + 0.2848 * (1 - amount),\n\t            f: 0.0722 - 0.0722 * (1 - amount),\n\t            g: 0.2126 - 0.2126 * (1 - amount),\n\t            h: 0.0722 + 0.9278 * (1 - amount)\n\t        });\n\t    };\n\t    Snap.filter.grayscale.toString = function () {\n\t        return this();\n\t    };\n\t    /*\\\n\t     * Snap.filter.sepia\n\t     [ method ]\n\t     **\n\t     * Returns an SVG markup string for the sepia filter\n\t     **\n\t     - amount (number) amount of filter (`0..1`)\n\t     = (string) filter representation\n\t    \\*/\n\t    Snap.filter.sepia = function (amount) {\n\t        if (amount == null) {\n\t            amount = 1;\n\t        }\n\t        return Snap.format('<feColorMatrix type=\"matrix\" values=\"{a} {b} {c} 0 0 {d} {e} {f} 0 0 {g} {h} {i} 0 0 0 0 0 1 0\"/>', {\n\t            a: 0.393 + 0.607 * (1 - amount),\n\t            b: 0.769 - 0.769 * (1 - amount),\n\t            c: 0.189 - 0.189 * (1 - amount),\n\t            d: 0.349 - 0.349 * (1 - amount),\n\t            e: 0.686 + 0.314 * (1 - amount),\n\t            f: 0.168 - 0.168 * (1 - amount),\n\t            g: 0.272 - 0.272 * (1 - amount),\n\t            h: 0.534 - 0.534 * (1 - amount),\n\t            i: 0.131 + 0.869 * (1 - amount)\n\t        });\n\t    };\n\t    Snap.filter.sepia.toString = function () {\n\t        return this();\n\t    };\n\t    /*\\\n\t     * Snap.filter.saturate\n\t     [ method ]\n\t     **\n\t     * Returns an SVG markup string for the saturate filter\n\t     **\n\t     - amount (number) amount of filter (`0..1`)\n\t     = (string) filter representation\n\t    \\*/\n\t    Snap.filter.saturate = function (amount) {\n\t        if (amount == null) {\n\t            amount = 1;\n\t        }\n\t        return Snap.format('<feColorMatrix type=\"saturate\" values=\"{amount}\"/>', {\n\t            amount: 1 - amount\n\t        });\n\t    };\n\t    Snap.filter.saturate.toString = function () {\n\t        return this();\n\t    };\n\t    /*\\\n\t     * Snap.filter.hueRotate\n\t     [ method ]\n\t     **\n\t     * Returns an SVG markup string for the hue-rotate filter\n\t     **\n\t     - angle (number) angle of rotation\n\t     = (string) filter representation\n\t    \\*/\n\t    Snap.filter.hueRotate = function (angle) {\n\t        angle = angle || 0;\n\t        return Snap.format('<feColorMatrix type=\"hueRotate\" values=\"{angle}\"/>', {\n\t            angle: angle\n\t        });\n\t    };\n\t    Snap.filter.hueRotate.toString = function () {\n\t        return this();\n\t    };\n\t    /*\\\n\t     * Snap.filter.invert\n\t     [ method ]\n\t     **\n\t     * Returns an SVG markup string for the invert filter\n\t     **\n\t     - amount (number) amount of filter (`0..1`)\n\t     = (string) filter representation\n\t    \\*/\n\t    Snap.filter.invert = function (amount) {\n\t        if (amount == null) {\n\t            amount = 1;\n\t        }\n\t//        <feColorMatrix type=\"matrix\" values=\"-1 0 0 0 1  0 -1 0 0 1  0 0 -1 0 1  0 0 0 1 0\" color-interpolation-filters=\"sRGB\"/>\n\t        return Snap.format('<feComponentTransfer><feFuncR type=\"table\" tableValues=\"{amount} {amount2}\"/><feFuncG type=\"table\" tableValues=\"{amount} {amount2}\"/><feFuncB type=\"table\" tableValues=\"{amount} {amount2}\"/></feComponentTransfer>', {\n\t            amount: amount,\n\t            amount2: 1 - amount\n\t        });\n\t    };\n\t    Snap.filter.invert.toString = function () {\n\t        return this();\n\t    };\n\t    /*\\\n\t     * Snap.filter.brightness\n\t     [ method ]\n\t     **\n\t     * Returns an SVG markup string for the brightness filter\n\t     **\n\t     - amount (number) amount of filter (`0..1`)\n\t     = (string) filter representation\n\t    \\*/\n\t    Snap.filter.brightness = function (amount) {\n\t        if (amount == null) {\n\t            amount = 1;\n\t        }\n\t        return Snap.format('<feComponentTransfer><feFuncR type=\"linear\" slope=\"{amount}\"/><feFuncG type=\"linear\" slope=\"{amount}\"/><feFuncB type=\"linear\" slope=\"{amount}\"/></feComponentTransfer>', {\n\t            amount: amount\n\t        });\n\t    };\n\t    Snap.filter.brightness.toString = function () {\n\t        return this();\n\t    };\n\t    /*\\\n\t     * Snap.filter.contrast\n\t     [ method ]\n\t     **\n\t     * Returns an SVG markup string for the contrast filter\n\t     **\n\t     - amount (number) amount of filter (`0..1`)\n\t     = (string) filter representation\n\t    \\*/\n\t    Snap.filter.contrast = function (amount) {\n\t        if (amount == null) {\n\t            amount = 1;\n\t        }\n\t        return Snap.format('<feComponentTransfer><feFuncR type=\"linear\" slope=\"{amount}\" intercept=\"{amount2}\"/><feFuncG type=\"linear\" slope=\"{amount}\" intercept=\"{amount2}\"/><feFuncB type=\"linear\" slope=\"{amount}\" intercept=\"{amount2}\"/></feComponentTransfer>', {\n\t            amount: amount,\n\t            amount2: .5 - amount / 2\n\t        });\n\t    };\n\t    Snap.filter.contrast.toString = function () {\n\t        return this();\n\t    };\n\t});\n\t\n\t// Copyright (c) 2014 Adobe Systems Incorporated. All rights reserved.\n\t//\n\t// Licensed under the Apache License, Version 2.0 (the \"License\");\n\t// you may not use this file except in compliance with the License.\n\t// You may obtain a copy of the License at\n\t//\n\t// http://www.apache.org/licenses/LICENSE-2.0\n\t//\n\t// Unless required by applicable law or agreed to in writing, software\n\t// distributed under the License is distributed on an \"AS IS\" BASIS,\n\t// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t// See the License for the specific language governing permissions and\n\t// limitations under the License.\n\tSnap.plugin(function (Snap, Element, Paper, glob, Fragment) {\n\t    var box = Snap._.box,\n\t        is = Snap.is,\n\t        firstLetter = /^[^a-z]*([tbmlrc])/i,\n\t        toString = function () {\n\t            return \"T\" + this.dx + \",\" + this.dy;\n\t        };\n\t    /*\\\n\t     * Element.getAlign\n\t     [ method ]\n\t     **\n\t     * Returns shift needed to align the element relatively to given element.\n\t     * If no elements specified, parent `<svg>` container will be used.\n\t     - el (object) @optional alignment element\n\t     - way (string) one of six values: `\"top\"`, `\"middle\"`, `\"bottom\"`, `\"left\"`, `\"center\"`, `\"right\"`\n\t     = (object|string) Object in format `{dx: , dy: }` also has a string representation as a transformation string\n\t     > Usage\n\t     | el.transform(el.getAlign(el2, \"top\"));\n\t     * or\n\t     | var dy = el.getAlign(el2, \"top\").dy;\n\t    \\*/\n\t    Element.prototype.getAlign = function (el, way) {\n\t        if (way == null && is(el, \"string\")) {\n\t            way = el;\n\t            el = null;\n\t        }\n\t        el = el || this.paper;\n\t        var bx = el.getBBox ? el.getBBox() : box(el),\n\t            bb = this.getBBox(),\n\t            out = {};\n\t        way = way && way.match(firstLetter);\n\t        way = way ? way[1].toLowerCase() : \"c\";\n\t        switch (way) {\n\t            case \"t\":\n\t                out.dx = 0;\n\t                out.dy = bx.y - bb.y;\n\t            break;\n\t            case \"b\":\n\t                out.dx = 0;\n\t                out.dy = bx.y2 - bb.y2;\n\t            break;\n\t            case \"m\":\n\t                out.dx = 0;\n\t                out.dy = bx.cy - bb.cy;\n\t            break;\n\t            case \"l\":\n\t                out.dx = bx.x - bb.x;\n\t                out.dy = 0;\n\t            break;\n\t            case \"r\":\n\t                out.dx = bx.x2 - bb.x2;\n\t                out.dy = 0;\n\t            break;\n\t            default:\n\t                out.dx = bx.cx - bb.cx;\n\t                out.dy = 0;\n\t            break;\n\t        }\n\t        out.toString = toString;\n\t        return out;\n\t    };\n\t    /*\\\n\t     * Element.align\n\t     [ method ]\n\t     **\n\t     * Aligns the element relatively to given one via transformation.\n\t     * If no elements specified, parent `<svg>` container will be used.\n\t     - el (object) @optional alignment element\n\t     - way (string) one of six values: `\"top\"`, `\"middle\"`, `\"bottom\"`, `\"left\"`, `\"center\"`, `\"right\"`\n\t     = (object) this element\n\t     > Usage\n\t     | el.align(el2, \"top\");\n\t     * or\n\t     | el.align(\"middle\");\n\t    \\*/\n\t    Element.prototype.align = function (el, way) {\n\t        return this.transform(\"...\" + this.getAlign(el, way));\n\t    };\n\t});\n\t\n\tmodule.exports = Snap\n\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// 42ace024cef72e25dd3f.worker.js"," \t// Copied from https://github.com/facebook/react/blob/bef45b0/src/shared/utils/canDefineProperty.js\r\n \tvar canDefineProperty = false;\r\n \ttry {\r\n \t\tObject.defineProperty({}, \"x\", {\r\n \t\t\tget: function() {}\r\n \t\t});\r\n \t\tcanDefineProperty = true;\r\n \t} catch(x) {\r\n \t\t// IE will fail on defineProperty\r\n \t}\r\n \t\r\n \tvar hotApplyOnUpdate = true;\r\n \tvar hotCurrentHash = \"42ace024cef72e25dd3f\"; // eslint-disable-line no-unused-vars\r\n \tvar hotCurrentModuleData = {};\r\n \tvar hotCurrentParents = []; // eslint-disable-line no-unused-vars\r\n \t\r\n \tfunction hotCreateRequire(moduleId) { // eslint-disable-line no-unused-vars\r\n \t\tvar me = installedModules[moduleId];\r\n \t\tif(!me) return __webpack_require__;\r\n \t\tvar fn = function(request) {\r\n \t\t\tif(me.hot.active) {\r\n \t\t\t\tif(installedModules[request]) {\r\n \t\t\t\t\tif(installedModules[request].parents.indexOf(moduleId) < 0)\r\n \t\t\t\t\t\tinstalledModules[request].parents.push(moduleId);\r\n \t\t\t\t\tif(me.children.indexOf(request) < 0)\r\n \t\t\t\t\t\tme.children.push(request);\r\n \t\t\t\t} else hotCurrentParents = [moduleId];\r\n \t\t\t} else {\r\n \t\t\t\tconsole.warn(\"[HMR] unexpected require(\" + request + \") from disposed module \" + moduleId);\r\n \t\t\t\thotCurrentParents = [];\r\n \t\t\t}\r\n \t\t\treturn __webpack_require__(request);\r\n \t\t};\r\n \t\tfor(var name in __webpack_require__) {\r\n \t\t\tif(Object.prototype.hasOwnProperty.call(__webpack_require__, name)) {\r\n \t\t\t\tif(canDefineProperty) {\r\n \t\t\t\t\tObject.defineProperty(fn, name, (function(name) {\r\n \t\t\t\t\t\treturn {\r\n \t\t\t\t\t\t\tconfigurable: true,\r\n \t\t\t\t\t\t\tenumerable: true,\r\n \t\t\t\t\t\t\tget: function() {\r\n \t\t\t\t\t\t\t\treturn __webpack_require__[name];\r\n \t\t\t\t\t\t\t},\r\n \t\t\t\t\t\t\tset: function(value) {\r\n \t\t\t\t\t\t\t\t__webpack_require__[name] = value;\r\n \t\t\t\t\t\t\t}\r\n \t\t\t\t\t\t};\r\n \t\t\t\t\t}(name)));\r\n \t\t\t\t} else {\r\n \t\t\t\t\tfn[name] = __webpack_require__[name];\r\n \t\t\t\t}\r\n \t\t\t}\r\n \t\t}\r\n \t\r\n \t\tfunction ensure(chunkId, callback) {\r\n \t\t\tif(hotStatus === \"ready\")\r\n \t\t\t\thotSetStatus(\"prepare\");\r\n \t\t\thotChunksLoading++;\r\n \t\t\t__webpack_require__.e(chunkId, function() {\r\n \t\t\t\ttry {\r\n \t\t\t\t\tcallback.call(null, fn);\r\n \t\t\t\t} finally {\r\n \t\t\t\t\tfinishChunkLoading();\r\n \t\t\t\t}\r\n \t\r\n \t\t\t\tfunction finishChunkLoading() {\r\n \t\t\t\t\thotChunksLoading--;\r\n \t\t\t\t\tif(hotStatus === \"prepare\") {\r\n \t\t\t\t\t\tif(!hotWaitingFilesMap[chunkId]) {\r\n \t\t\t\t\t\t\thotEnsureUpdateChunk(chunkId);\r\n \t\t\t\t\t\t}\r\n \t\t\t\t\t\tif(hotChunksLoading === 0 && hotWaitingFiles === 0) {\r\n \t\t\t\t\t\t\thotUpdateDownloaded();\r\n \t\t\t\t\t\t}\r\n \t\t\t\t\t}\r\n \t\t\t\t}\r\n \t\t\t});\r\n \t\t}\r\n \t\tif(canDefineProperty) {\r\n \t\t\tObject.defineProperty(fn, \"e\", {\r\n \t\t\t\tenumerable: true,\r\n \t\t\t\tvalue: ensure\r\n \t\t\t});\r\n \t\t} else {\r\n \t\t\tfn.e = ensure;\r\n \t\t}\r\n \t\treturn fn;\r\n \t}\r\n \t\r\n \tfunction hotCreateModule(moduleId) { // eslint-disable-line no-unused-vars\r\n \t\tvar hot = {\r\n \t\t\t// private stuff\r\n \t\t\t_acceptedDependencies: {},\r\n \t\t\t_declinedDependencies: {},\r\n \t\t\t_selfAccepted: false,\r\n \t\t\t_selfDeclined: false,\r\n \t\t\t_disposeHandlers: [],\r\n \t\r\n \t\t\t// Module API\r\n \t\t\tactive: true,\r\n \t\t\taccept: function(dep, callback) {\r\n \t\t\t\tif(typeof dep === \"undefined\")\r\n \t\t\t\t\thot._selfAccepted = true;\r\n \t\t\t\telse if(typeof dep === \"function\")\r\n \t\t\t\t\thot._selfAccepted = dep;\r\n \t\t\t\telse if(typeof dep === \"object\")\r\n \t\t\t\t\tfor(var i = 0; i < dep.length; i++)\r\n \t\t\t\t\t\thot._acceptedDependencies[dep[i]] = callback;\r\n \t\t\t\telse\r\n \t\t\t\t\thot._acceptedDependencies[dep] = callback;\r\n \t\t\t},\r\n \t\t\tdecline: function(dep) {\r\n \t\t\t\tif(typeof dep === \"undefined\")\r\n \t\t\t\t\thot._selfDeclined = true;\r\n \t\t\t\telse if(typeof dep === \"number\")\r\n \t\t\t\t\thot._declinedDependencies[dep] = true;\r\n \t\t\t\telse\r\n \t\t\t\t\tfor(var i = 0; i < dep.length; i++)\r\n \t\t\t\t\t\thot._declinedDependencies[dep[i]] = true;\r\n \t\t\t},\r\n \t\t\tdispose: function(callback) {\r\n \t\t\t\thot._disposeHandlers.push(callback);\r\n \t\t\t},\r\n \t\t\taddDisposeHandler: function(callback) {\r\n \t\t\t\thot._disposeHandlers.push(callback);\r\n \t\t\t},\r\n \t\t\tremoveDisposeHandler: function(callback) {\r\n \t\t\t\tvar idx = hot._disposeHandlers.indexOf(callback);\r\n \t\t\t\tif(idx >= 0) hot._disposeHandlers.splice(idx, 1);\r\n \t\t\t},\r\n \t\r\n \t\t\t// Management API\r\n \t\t\tcheck: hotCheck,\r\n \t\t\tapply: hotApply,\r\n \t\t\tstatus: function(l) {\r\n \t\t\t\tif(!l) return hotStatus;\r\n \t\t\t\thotStatusHandlers.push(l);\r\n \t\t\t},\r\n \t\t\taddStatusHandler: function(l) {\r\n \t\t\t\thotStatusHandlers.push(l);\r\n \t\t\t},\r\n \t\t\tremoveStatusHandler: function(l) {\r\n \t\t\t\tvar idx = hotStatusHandlers.indexOf(l);\r\n \t\t\t\tif(idx >= 0) hotStatusHandlers.splice(idx, 1);\r\n \t\t\t},\r\n \t\r\n \t\t\t//inherit from previous dispose call\r\n \t\t\tdata: hotCurrentModuleData[moduleId]\r\n \t\t};\r\n \t\treturn hot;\r\n \t}\r\n \t\r\n \tvar hotStatusHandlers = [];\r\n \tvar hotStatus = \"idle\";\r\n \t\r\n \tfunction hotSetStatus(newStatus) {\r\n \t\thotStatus = newStatus;\r\n \t\tfor(var i = 0; i < hotStatusHandlers.length; i++)\r\n \t\t\thotStatusHandlers[i].call(null, newStatus);\r\n \t}\r\n \t\r\n \t// while downloading\r\n \tvar hotWaitingFiles = 0;\r\n \tvar hotChunksLoading = 0;\r\n \tvar hotWaitingFilesMap = {};\r\n \tvar hotRequestedFilesMap = {};\r\n \tvar hotAvailibleFilesMap = {};\r\n \tvar hotCallback;\r\n \t\r\n \t// The update info\r\n \tvar hotUpdate, hotUpdateNewHash;\r\n \t\r\n \tfunction toModuleId(id) {\r\n \t\tvar isNumber = (+id) + \"\" === id;\r\n \t\treturn isNumber ? +id : id;\r\n \t}\r\n \t\r\n \tfunction hotCheck(apply, callback) {\r\n \t\tif(hotStatus !== \"idle\") throw new Error(\"check() is only allowed in idle status\");\r\n \t\tif(typeof apply === \"function\") {\r\n \t\t\thotApplyOnUpdate = false;\r\n \t\t\tcallback = apply;\r\n \t\t} else {\r\n \t\t\thotApplyOnUpdate = apply;\r\n \t\t\tcallback = callback || function(err) {\r\n \t\t\t\tif(err) throw err;\r\n \t\t\t};\r\n \t\t}\r\n \t\thotSetStatus(\"check\");\r\n \t\thotDownloadManifest(function(err, update) {\r\n \t\t\tif(err) return callback(err);\r\n \t\t\tif(!update) {\r\n \t\t\t\thotSetStatus(\"idle\");\r\n \t\t\t\tcallback(null, null);\r\n \t\t\t\treturn;\r\n \t\t\t}\r\n \t\r\n \t\t\thotRequestedFilesMap = {};\r\n \t\t\thotAvailibleFilesMap = {};\r\n \t\t\thotWaitingFilesMap = {};\r\n \t\t\tfor(var i = 0; i < update.c.length; i++)\r\n \t\t\t\thotAvailibleFilesMap[update.c[i]] = true;\r\n \t\t\thotUpdateNewHash = update.h;\r\n \t\r\n \t\t\thotSetStatus(\"prepare\");\r\n \t\t\thotCallback = callback;\r\n \t\t\thotUpdate = {};\r\n \t\t\tvar chunkId = 0;\r\n \t\t\t{ // eslint-disable-line no-lone-blocks\r\n \t\t\t\t/*globals chunkId */\r\n \t\t\t\thotEnsureUpdateChunk(chunkId);\r\n \t\t\t}\r\n \t\t\tif(hotStatus === \"prepare\" && hotChunksLoading === 0 && hotWaitingFiles === 0) {\r\n \t\t\t\thotUpdateDownloaded();\r\n \t\t\t}\r\n \t\t});\r\n \t}\r\n \t\r\n \tfunction hotAddUpdateChunk(chunkId, moreModules) { // eslint-disable-line no-unused-vars\r\n \t\tif(!hotAvailibleFilesMap[chunkId] || !hotRequestedFilesMap[chunkId])\r\n \t\t\treturn;\r\n \t\thotRequestedFilesMap[chunkId] = false;\r\n \t\tfor(var moduleId in moreModules) {\r\n \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\r\n \t\t\t\thotUpdate[moduleId] = moreModules[moduleId];\r\n \t\t\t}\r\n \t\t}\r\n \t\tif(--hotWaitingFiles === 0 && hotChunksLoading === 0) {\r\n \t\t\thotUpdateDownloaded();\r\n \t\t}\r\n \t}\r\n \t\r\n \tfunction hotEnsureUpdateChunk(chunkId) {\r\n \t\tif(!hotAvailibleFilesMap[chunkId]) {\r\n \t\t\thotWaitingFilesMap[chunkId] = true;\r\n \t\t} else {\r\n \t\t\thotRequestedFilesMap[chunkId] = true;\r\n \t\t\thotWaitingFiles++;\r\n \t\t\thotDownloadUpdateChunk(chunkId);\r\n \t\t}\r\n \t}\r\n \t\r\n \tfunction hotUpdateDownloaded() {\r\n \t\thotSetStatus(\"ready\");\r\n \t\tvar callback = hotCallback;\r\n \t\thotCallback = null;\r\n \t\tif(!callback) return;\r\n \t\tif(hotApplyOnUpdate) {\r\n \t\t\thotApply(hotApplyOnUpdate, callback);\r\n \t\t} else {\r\n \t\t\tvar outdatedModules = [];\r\n \t\t\tfor(var id in hotUpdate) {\r\n \t\t\t\tif(Object.prototype.hasOwnProperty.call(hotUpdate, id)) {\r\n \t\t\t\t\toutdatedModules.push(toModuleId(id));\r\n \t\t\t\t}\r\n \t\t\t}\r\n \t\t\tcallback(null, outdatedModules);\r\n \t\t}\r\n \t}\r\n \t\r\n \tfunction hotApply(options, callback) {\r\n \t\tif(hotStatus !== \"ready\") throw new Error(\"apply() is only allowed in ready status\");\r\n \t\tif(typeof options === \"function\") {\r\n \t\t\tcallback = options;\r\n \t\t\toptions = {};\r\n \t\t} else if(options && typeof options === \"object\") {\r\n \t\t\tcallback = callback || function(err) {\r\n \t\t\t\tif(err) throw err;\r\n \t\t\t};\r\n \t\t} else {\r\n \t\t\toptions = {};\r\n \t\t\tcallback = callback || function(err) {\r\n \t\t\t\tif(err) throw err;\r\n \t\t\t};\r\n \t\t}\r\n \t\r\n \t\tfunction getAffectedStuff(module) {\r\n \t\t\tvar outdatedModules = [module];\r\n \t\t\tvar outdatedDependencies = {};\r\n \t\r\n \t\t\tvar queue = outdatedModules.slice();\r\n \t\t\twhile(queue.length > 0) {\r\n \t\t\t\tvar moduleId = queue.pop();\r\n \t\t\t\tvar module = installedModules[moduleId];\r\n \t\t\t\tif(!module || module.hot._selfAccepted)\r\n \t\t\t\t\tcontinue;\r\n \t\t\t\tif(module.hot._selfDeclined) {\r\n \t\t\t\t\treturn new Error(\"Aborted because of self decline: \" + moduleId);\r\n \t\t\t\t}\r\n \t\t\t\tif(moduleId === 0) {\r\n \t\t\t\t\treturn;\r\n \t\t\t\t}\r\n \t\t\t\tfor(var i = 0; i < module.parents.length; i++) {\r\n \t\t\t\t\tvar parentId = module.parents[i];\r\n \t\t\t\t\tvar parent = installedModules[parentId];\r\n \t\t\t\t\tif(parent.hot._declinedDependencies[moduleId]) {\r\n \t\t\t\t\t\treturn new Error(\"Aborted because of declined dependency: \" + moduleId + \" in \" + parentId);\r\n \t\t\t\t\t}\r\n \t\t\t\t\tif(outdatedModules.indexOf(parentId) >= 0) continue;\r\n \t\t\t\t\tif(parent.hot._acceptedDependencies[moduleId]) {\r\n \t\t\t\t\t\tif(!outdatedDependencies[parentId])\r\n \t\t\t\t\t\t\toutdatedDependencies[parentId] = [];\r\n \t\t\t\t\t\taddAllToSet(outdatedDependencies[parentId], [moduleId]);\r\n \t\t\t\t\t\tcontinue;\r\n \t\t\t\t\t}\r\n \t\t\t\t\tdelete outdatedDependencies[parentId];\r\n \t\t\t\t\toutdatedModules.push(parentId);\r\n \t\t\t\t\tqueue.push(parentId);\r\n \t\t\t\t}\r\n \t\t\t}\r\n \t\r\n \t\t\treturn [outdatedModules, outdatedDependencies];\r\n \t\t}\r\n \t\r\n \t\tfunction addAllToSet(a, b) {\r\n \t\t\tfor(var i = 0; i < b.length; i++) {\r\n \t\t\t\tvar item = b[i];\r\n \t\t\t\tif(a.indexOf(item) < 0)\r\n \t\t\t\t\ta.push(item);\r\n \t\t\t}\r\n \t\t}\r\n \t\r\n \t\t// at begin all updates modules are outdated\r\n \t\t// the \"outdated\" status can propagate to parents if they don't accept the children\r\n \t\tvar outdatedDependencies = {};\r\n \t\tvar outdatedModules = [];\r\n \t\tvar appliedUpdate = {};\r\n \t\tfor(var id in hotUpdate) {\r\n \t\t\tif(Object.prototype.hasOwnProperty.call(hotUpdate, id)) {\r\n \t\t\t\tvar moduleId = toModuleId(id);\r\n \t\t\t\tvar result = getAffectedStuff(moduleId);\r\n \t\t\t\tif(!result) {\r\n \t\t\t\t\tif(options.ignoreUnaccepted)\r\n \t\t\t\t\t\tcontinue;\r\n \t\t\t\t\thotSetStatus(\"abort\");\r\n \t\t\t\t\treturn callback(new Error(\"Aborted because \" + moduleId + \" is not accepted\"));\r\n \t\t\t\t}\r\n \t\t\t\tif(result instanceof Error) {\r\n \t\t\t\t\thotSetStatus(\"abort\");\r\n \t\t\t\t\treturn callback(result);\r\n \t\t\t\t}\r\n \t\t\t\tappliedUpdate[moduleId] = hotUpdate[moduleId];\r\n \t\t\t\taddAllToSet(outdatedModules, result[0]);\r\n \t\t\t\tfor(var moduleId in result[1]) {\r\n \t\t\t\t\tif(Object.prototype.hasOwnProperty.call(result[1], moduleId)) {\r\n \t\t\t\t\t\tif(!outdatedDependencies[moduleId])\r\n \t\t\t\t\t\t\toutdatedDependencies[moduleId] = [];\r\n \t\t\t\t\t\taddAllToSet(outdatedDependencies[moduleId], result[1][moduleId]);\r\n \t\t\t\t\t}\r\n \t\t\t\t}\r\n \t\t\t}\r\n \t\t}\r\n \t\r\n \t\t// Store self accepted outdated modules to require them later by the module system\r\n \t\tvar outdatedSelfAcceptedModules = [];\r\n \t\tfor(var i = 0; i < outdatedModules.length; i++) {\r\n \t\t\tvar moduleId = outdatedModules[i];\r\n \t\t\tif(installedModules[moduleId] && installedModules[moduleId].hot._selfAccepted)\r\n \t\t\t\toutdatedSelfAcceptedModules.push({\r\n \t\t\t\t\tmodule: moduleId,\r\n \t\t\t\t\terrorHandler: installedModules[moduleId].hot._selfAccepted\r\n \t\t\t\t});\r\n \t\t}\r\n \t\r\n \t\t// Now in \"dispose\" phase\r\n \t\thotSetStatus(\"dispose\");\r\n \t\tvar queue = outdatedModules.slice();\r\n \t\twhile(queue.length > 0) {\r\n \t\t\tvar moduleId = queue.pop();\r\n \t\t\tvar module = installedModules[moduleId];\r\n \t\t\tif(!module) continue;\r\n \t\r\n \t\t\tvar data = {};\r\n \t\r\n \t\t\t// Call dispose handlers\r\n \t\t\tvar disposeHandlers = module.hot._disposeHandlers;\r\n \t\t\tfor(var j = 0; j < disposeHandlers.length; j++) {\r\n \t\t\t\tvar cb = disposeHandlers[j];\r\n \t\t\t\tcb(data);\r\n \t\t\t}\r\n \t\t\thotCurrentModuleData[moduleId] = data;\r\n \t\r\n \t\t\t// disable module (this disables requires from this module)\r\n \t\t\tmodule.hot.active = false;\r\n \t\r\n \t\t\t// remove module from cache\r\n \t\t\tdelete installedModules[moduleId];\r\n \t\r\n \t\t\t// remove \"parents\" references from all children\r\n \t\t\tfor(var j = 0; j < module.children.length; j++) {\r\n \t\t\t\tvar child = installedModules[module.children[j]];\r\n \t\t\t\tif(!child) continue;\r\n \t\t\t\tvar idx = child.parents.indexOf(moduleId);\r\n \t\t\t\tif(idx >= 0) {\r\n \t\t\t\t\tchild.parents.splice(idx, 1);\r\n \t\t\t\t}\r\n \t\t\t}\r\n \t\t}\r\n \t\r\n \t\t// remove outdated dependency from module children\r\n \t\tfor(var moduleId in outdatedDependencies) {\r\n \t\t\tif(Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) {\r\n \t\t\t\tvar module = installedModules[moduleId];\r\n \t\t\t\tvar moduleOutdatedDependencies = outdatedDependencies[moduleId];\r\n \t\t\t\tfor(var j = 0; j < moduleOutdatedDependencies.length; j++) {\r\n \t\t\t\t\tvar dependency = moduleOutdatedDependencies[j];\r\n \t\t\t\t\tvar idx = module.children.indexOf(dependency);\r\n \t\t\t\t\tif(idx >= 0) module.children.splice(idx, 1);\r\n \t\t\t\t}\r\n \t\t\t}\r\n \t\t}\r\n \t\r\n \t\t// Not in \"apply\" phase\r\n \t\thotSetStatus(\"apply\");\r\n \t\r\n \t\thotCurrentHash = hotUpdateNewHash;\r\n \t\r\n \t\t// insert new code\r\n \t\tfor(var moduleId in appliedUpdate) {\r\n \t\t\tif(Object.prototype.hasOwnProperty.call(appliedUpdate, moduleId)) {\r\n \t\t\t\tmodules[moduleId] = appliedUpdate[moduleId];\r\n \t\t\t}\r\n \t\t}\r\n \t\r\n \t\t// call accept handlers\r\n \t\tvar error = null;\r\n \t\tfor(var moduleId in outdatedDependencies) {\r\n \t\t\tif(Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) {\r\n \t\t\t\tvar module = installedModules[moduleId];\r\n \t\t\t\tvar moduleOutdatedDependencies = outdatedDependencies[moduleId];\r\n \t\t\t\tvar callbacks = [];\r\n \t\t\t\tfor(var i = 0; i < moduleOutdatedDependencies.length; i++) {\r\n \t\t\t\t\tvar dependency = moduleOutdatedDependencies[i];\r\n \t\t\t\t\tvar cb = module.hot._acceptedDependencies[dependency];\r\n \t\t\t\t\tif(callbacks.indexOf(cb) >= 0) continue;\r\n \t\t\t\t\tcallbacks.push(cb);\r\n \t\t\t\t}\r\n \t\t\t\tfor(var i = 0; i < callbacks.length; i++) {\r\n \t\t\t\t\tvar cb = callbacks[i];\r\n \t\t\t\t\ttry {\r\n \t\t\t\t\t\tcb(outdatedDependencies);\r\n \t\t\t\t\t} catch(err) {\r\n \t\t\t\t\t\tif(!error)\r\n \t\t\t\t\t\t\terror = err;\r\n \t\t\t\t\t}\r\n \t\t\t\t}\r\n \t\t\t}\r\n \t\t}\r\n \t\r\n \t\t// Load self accepted modules\r\n \t\tfor(var i = 0; i < outdatedSelfAcceptedModules.length; i++) {\r\n \t\t\tvar item = outdatedSelfAcceptedModules[i];\r\n \t\t\tvar moduleId = item.module;\r\n \t\t\thotCurrentParents = [moduleId];\r\n \t\t\ttry {\r\n \t\t\t\t__webpack_require__(moduleId);\r\n \t\t\t} catch(err) {\r\n \t\t\t\tif(typeof item.errorHandler === \"function\") {\r\n \t\t\t\t\ttry {\r\n \t\t\t\t\t\titem.errorHandler(err);\r\n \t\t\t\t\t} catch(err) {\r\n \t\t\t\t\t\tif(!error)\r\n \t\t\t\t\t\t\terror = err;\r\n \t\t\t\t\t}\r\n \t\t\t\t} else if(!error)\r\n \t\t\t\t\terror = err;\r\n \t\t\t}\r\n \t\t}\r\n \t\r\n \t\t// handle errors in accept handlers and self accepted module load\r\n \t\tif(error) {\r\n \t\t\thotSetStatus(\"fail\");\r\n \t\t\treturn callback(error);\r\n \t\t}\r\n \t\r\n \t\thotSetStatus(\"idle\");\r\n \t\tcallback(null, outdatedModules);\r\n \t}\r\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false,\n \t\t\thot: hotCreateModule(moduleId),\n \t\t\tparents: hotCurrentParents,\n \t\t\tchildren: []\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, hotCreateRequire(moduleId));\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// __webpack_hash__\n \t__webpack_require__.h = function() { return hotCurrentHash; };\n\n \t// Load entry module and return exports\n \treturn hotCreateRequire(0)(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 42ace024cef72e25dd3f","import { rawPathsToClipperPaths, union, xor } from '../mesh';\n\n\nself.onmessage = (event) => {\n\n    const jobs = [];\n\n    let { settings, opIndex, op, geometry, openGeometry, tabGeometry, documents } = event.data;\n\n    const docsWithImages = []\n\n    function matchColor(filterColor, color) {\n        if (!filterColor)\n            return true;\n        if (!color)\n            return false;\n        return filterColor[0] == color[0] && filterColor[1] == color[1] && filterColor[2] == color[2] && filterColor[3] == color[3];\n    }\n\n    function examineDocTree(isTab, id) {\n        let doc = documents.find(d => d.id === id);\n        if (doc.rawPaths) {\n            jobs.push((cb) => {\n                if (isTab) {\n                    tabGeometry = union(tabGeometry, rawPathsToClipperPaths(doc.rawPaths, doc.scale[0], doc.scale[1], doc.translate[0], doc.translate[1]));\n                } else if (matchColor(op.filterFillColor, doc.fillColor) && matchColor(op.filterStrokeColor, doc.strokeColor)) {\n                    let isClosed = false;\n                    for (let rawPath of doc.rawPaths)\n                        if (rawPath.length >= 4 && rawPath[0] == rawPath[rawPath.length - 2] && rawPath[1] == rawPath[rawPath.length - 1])\n                            isClosed = true;\n                    let clipperPaths = rawPathsToClipperPaths(doc.rawPaths, doc.scale[0], doc.scale[1], doc.translate[0], doc.translate[1]);\n                    if (isClosed)\n                        geometry = xor(geometry, clipperPaths);\n                    else if (!op.filterFillColor)\n                        openGeometry = openGeometry.concat(clipperPaths);\n                }\n                cb()\n            })\n        }\n        if (doc.type === 'image' && !isTab) {\n            docsWithImages.push(doc)\n        }\n        for (let child of doc.children)\n            examineDocTree(isTab, child);\n    }\n    for (let id of op.documents)\n        examineDocTree(false, id);\n    for (let id of op.tabDocuments)\n        examineDocTree(true, id);\n\n    let chunk = 100 / jobs.length;\n    var percent = 0;\n\n    while (jobs.length) {\n        try {\n            let job = jobs.shift()\n            if (job) job(() => {\n                percent = percent + chunk\n                postMessage({ event: \"onProgress\", percent: parseInt(percent) })\n            });\n        } catch (error) {\n            console.error(error)\n            postMessage({ event: \"onError\", message: \"Something wrong has happened, sorry.\", level: \"error\", error: error.toString() })\n        }\n    }\n\n    postMessage({ event: \"onDone\", settings, opIndex, op, geometry, openGeometry, tabGeometry, docsWithImages })\n    self.close();\n}\n\n\n// WEBPACK FOOTER //\n// ./lib/workers/cam-preflight.js","/*\n * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors\n * http://code.google.com/p/poly2tri/\n * \n * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors\n * https://github.com/r3mi/poly2tri.js\n * \n * All rights reserved.\n * \n * Distributed under the 3-clause BSD License, see LICENSE.txt\n */\n\n\"use strict\";\n\n/**\n * The following functions operate on \"Point\" or any \"Point like\" object with {x,y},\n * as defined by the {@link XY} type\n * ([duck typing]{@link http://en.wikipedia.org/wiki/Duck_typing}).\n * @module\n * @private\n */\n\n/**\n * poly2tri.js supports using custom point class instead of {@linkcode Point}.\n * Any \"Point like\" object with <code>{x, y}</code> attributes is supported\n * to initialize the SweepContext polylines and points\n * ([duck typing]{@link http://en.wikipedia.org/wiki/Duck_typing}).\n *\n * poly2tri.js might add extra fields to the point objects when computing the\n * triangulation : they are prefixed with <code>_p2t_</code> to avoid collisions\n * with fields in the custom class.\n *\n * @example\n *      var contour = [{x:100, y:100}, {x:100, y:300}, {x:300, y:300}, {x:300, y:100}];\n *      var swctx = new poly2tri.SweepContext(contour);\n *\n * @typedef {Object} XY\n * @property {number} x - x coordinate\n * @property {number} y - y coordinate\n */\n\n\n/**\n * Point pretty printing : prints x and y coordinates.\n * @example\n *      xy.toStringBase({x:5, y:42})\n *      //  \"(5;42)\"\n * @protected\n * @param {!XY} p - point object with {x,y}\n * @returns {string} <code>\"(x;y)\"</code>\n */\nfunction toStringBase(p) {\n    return (\"(\" + p.x + \";\" + p.y + \")\");\n}\n\n/**\n * Point pretty printing. Delegates to the point's custom \"toString()\" method if exists,\n * else simply prints x and y coordinates.\n * @example\n *      xy.toString({x:5, y:42})\n *      //  \"(5;42)\"\n * @example\n *      xy.toString({x:5,y:42,toString:function() {return this.x+\":\"+this.y;}})\n *      //  \"5:42\"\n * @param {!XY} p - point object with {x,y}\n * @returns {string} <code>\"(x;y)\"</code>\n */\nfunction toString(p) {\n    // Try a custom toString first, and fallback to own implementation if none\n    var s = p.toString();\n    return (s === '[object Object]' ? toStringBase(p) : s);\n}\n\n\n/**\n * Compare two points component-wise. Ordered by y axis first, then x axis.\n * @param {!XY} a - point object with {x,y}\n * @param {!XY} b - point object with {x,y}\n * @return {number} <code>&lt; 0</code> if <code>a &lt; b</code>,\n *         <code>&gt; 0</code> if <code>a &gt; b</code>, \n *         <code>0</code> otherwise.\n */\nfunction compare(a, b) {\n    if (a.y === b.y) {\n        return a.x - b.x;\n    } else {\n        return a.y - b.y;\n    }\n}\n\n/**\n * Test two Point objects for equality.\n * @param {!XY} a - point object with {x,y}\n * @param {!XY} b - point object with {x,y}\n * @return {boolean} <code>True</code> if <code>a == b</code>, <code>false</code> otherwise.\n */\nfunction equals(a, b) {\n    return a.x === b.x && a.y === b.y;\n}\n\n\nmodule.exports = {\n    toString: toString,\n    toStringBase: toStringBase,\n    compare: compare,\n    equals: equals\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/poly2tri/src/xy.js\n// module id = 1\n// module chunks = 0","/*\n * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors\n * http://code.google.com/p/poly2tri/\n * \n * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors\n * https://github.com/r3mi/poly2tri.js\n * \n * All rights reserved.\n * \n * Distributed under the 3-clause BSD License, see LICENSE.txt\n */\n\n/* jshint maxcomplexity:11 */\n\n\"use strict\";\n\n\n/*\n * Note\n * ====\n * the structure of this JavaScript version of poly2tri intentionally follows\n * as closely as possible the structure of the reference C++ version, to make it \n * easier to keep the 2 versions in sync.\n */\n\n\n// -------------------------------------------------------------------------Node\n\n/**\n * Advancing front node\n * @constructor\n * @private\n * @struct\n * @param {!XY} p - Point\n * @param {Triangle=} t triangle (optional)\n */\nvar Node = function(p, t) {\n    /** @type {XY} */\n    this.point = p;\n\n    /** @type {Triangle|null} */\n    this.triangle = t || null;\n\n    /** @type {Node|null} */\n    this.next = null;\n    /** @type {Node|null} */\n    this.prev = null;\n\n    /** @type {number} */\n    this.value = p.x;\n};\n\n// ---------------------------------------------------------------AdvancingFront\n/**\n * @constructor\n * @private\n * @struct\n * @param {Node} head\n * @param {Node} tail\n */\nvar AdvancingFront = function(head, tail) {\n    /** @type {Node} */\n    this.head_ = head;\n    /** @type {Node} */\n    this.tail_ = tail;\n    /** @type {Node} */\n    this.search_node_ = head;\n};\n\n/** @return {Node} */\nAdvancingFront.prototype.head = function() {\n    return this.head_;\n};\n\n/** @param {Node} node */\nAdvancingFront.prototype.setHead = function(node) {\n    this.head_ = node;\n};\n\n/** @return {Node} */\nAdvancingFront.prototype.tail = function() {\n    return this.tail_;\n};\n\n/** @param {Node} node */\nAdvancingFront.prototype.setTail = function(node) {\n    this.tail_ = node;\n};\n\n/** @return {Node} */\nAdvancingFront.prototype.search = function() {\n    return this.search_node_;\n};\n\n/** @param {Node} node */\nAdvancingFront.prototype.setSearch = function(node) {\n    this.search_node_ = node;\n};\n\n/** @return {Node} */\nAdvancingFront.prototype.findSearchNode = function(/*x*/) {\n    // TODO: implement BST index\n    return this.search_node_;\n};\n\n/**\n * @param {number} x value\n * @return {Node}\n */\nAdvancingFront.prototype.locateNode = function(x) {\n    var node = this.search_node_;\n\n    /* jshint boss:true */\n    if (x < node.value) {\n        while (node = node.prev) {\n            if (x >= node.value) {\n                this.search_node_ = node;\n                return node;\n            }\n        }\n    } else {\n        while (node = node.next) {\n            if (x < node.value) {\n                this.search_node_ = node.prev;\n                return node.prev;\n            }\n        }\n    }\n    return null;\n};\n\n/**\n * @param {!XY} point - Point\n * @return {Node}\n */\nAdvancingFront.prototype.locatePoint = function(point) {\n    var px = point.x;\n    var node = this.findSearchNode(px);\n    var nx = node.point.x;\n\n    if (px === nx) {\n        // Here we are comparing point references, not values\n        if (point !== node.point) {\n            // We might have two nodes with same x value for a short time\n            if (point === node.prev.point) {\n                node = node.prev;\n            } else if (point === node.next.point) {\n                node = node.next;\n            } else {\n                throw new Error('poly2tri Invalid AdvancingFront.locatePoint() call');\n            }\n        }\n    } else if (px < nx) {\n        /* jshint boss:true */\n        while (node = node.prev) {\n            if (point === node.point) {\n                break;\n            }\n        }\n    } else {\n        while (node = node.next) {\n            if (point === node.point) {\n                break;\n            }\n        }\n    }\n\n    if (node) {\n        this.search_node_ = node;\n    }\n    return node;\n};\n\n\n// ----------------------------------------------------------------------Exports\n\nmodule.exports = AdvancingFront;\nmodule.exports.Node = Node;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/poly2tri/src/advancingfront.js\n// module id = 2\n// module chunks = 0","/*\n * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors\n * http://code.google.com/p/poly2tri/\n * \n * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors\n * https://github.com/r3mi/poly2tri.js\n * \n * All rights reserved.\n * \n * Distributed under the 3-clause BSD License, see LICENSE.txt\n */\n\n\"use strict\";\n\n/*\n * Class added in the JavaScript version (was not present in the c++ version)\n */\n\nvar xy = require('./xy');\n\n/**\n * Custom exception class to indicate invalid Point values\n * @constructor\n * @public\n * @extends Error\n * @struct\n * @param {string=} message - error message\n * @param {Array.<XY>=} points - invalid points\n */\nvar PointError = function(message, points) {\n    this.name = \"PointError\";\n    /**\n     * Invalid points\n     * @public\n     * @type {Array.<XY>}\n     */\n    this.points = points = points || [];\n    /**\n     * Error message\n     * @public\n     * @type {string}\n     */\n    this.message = message || \"Invalid Points!\";\n    for (var i = 0; i < points.length; i++) {\n        this.message += \" \" + xy.toString(points[i]);\n    }\n};\nPointError.prototype = new Error();\nPointError.prototype.constructor = PointError;\n\n\nmodule.exports = PointError;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/poly2tri/src/pointerror.js\n// module id = 3\n// module chunks = 0","/*\n * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors\n * http://code.google.com/p/poly2tri/\n * \n * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors\n * https://github.com/r3mi/poly2tri.js\n *\n * All rights reserved.\n * \n * Distributed under the 3-clause BSD License, see LICENSE.txt\n */\n\n/* jshint maxcomplexity:10 */\n\n\"use strict\";\n\n\n/*\n * Note\n * ====\n * the structure of this JavaScript version of poly2tri intentionally follows\n * as closely as possible the structure of the reference C++ version, to make it \n * easier to keep the 2 versions in sync.\n */\n\nvar xy = require(\"./xy\");\n\n\n// ---------------------------------------------------------------------Triangle\n/**\n * Triangle class.<br>\n * Triangle-based data structures are known to have better performance than\n * quad-edge structures.\n * See: J. Shewchuk, \"Triangle: Engineering a 2D Quality Mesh Generator and\n * Delaunay Triangulator\", \"Triangulations in CGAL\"\n *\n * @constructor\n * @struct\n * @param {!XY} pa  point object with {x,y}\n * @param {!XY} pb  point object with {x,y}\n * @param {!XY} pc  point object with {x,y}\n */\nvar Triangle = function(a, b, c) {\n    /**\n     * Triangle points\n     * @private\n     * @type {Array.<XY>}\n     */\n    this.points_ = [a, b, c];\n\n    /**\n     * Neighbor list\n     * @private\n     * @type {Array.<Triangle>}\n     */\n    this.neighbors_ = [null, null, null];\n\n    /**\n     * Has this triangle been marked as an interior triangle?\n     * @private\n     * @type {boolean}\n     */\n    this.interior_ = false;\n\n    /**\n     * Flags to determine if an edge is a Constrained edge\n     * @private\n     * @type {Array.<boolean>}\n     */\n    this.constrained_edge = [false, false, false];\n\n    /**\n     * Flags to determine if an edge is a Delauney edge\n     * @private\n     * @type {Array.<boolean>}\n     */\n    this.delaunay_edge = [false, false, false];\n};\n\nvar p2s = xy.toString;\n/**\n * For pretty printing ex. <code>\"[(5;42)(10;20)(21;30)]\"</code>.\n * @public\n * @return {string}\n */\nTriangle.prototype.toString = function() {\n    return (\"[\" + p2s(this.points_[0]) + p2s(this.points_[1]) + p2s(this.points_[2]) + \"]\");\n};\n\n/**\n * Get one vertice of the triangle.\n * The output triangles of a triangulation have vertices which are references\n * to the initial input points (not copies): any custom fields in the\n * initial points can be retrieved in the output triangles.\n * @example\n *      var contour = [{x:100, y:100, id:1}, {x:100, y:300, id:2}, {x:300, y:300, id:3}];\n *      var swctx = new poly2tri.SweepContext(contour);\n *      swctx.triangulate();\n *      var triangles = swctx.getTriangles();\n *      typeof triangles[0].getPoint(0).id\n *      //  \"number\"\n * @param {number} index - vertice index: 0, 1 or 2\n * @public\n * @returns {XY}\n */\nTriangle.prototype.getPoint = function(index) {\n    return this.points_[index];\n};\n\n/**\n * For backward compatibility\n * @function\n * @deprecated use {@linkcode Triangle#getPoint} instead\n */\nTriangle.prototype.GetPoint = Triangle.prototype.getPoint;\n\n/**\n * Get all 3 vertices of the triangle as an array\n * @public\n * @return {Array.<XY>}\n */\n// Method added in the JavaScript version (was not present in the c++ version)\nTriangle.prototype.getPoints = function() {\n    return this.points_;\n};\n\n/**\n * @private\n * @param {number} index\n * @returns {?Triangle}\n */\nTriangle.prototype.getNeighbor = function(index) {\n    return this.neighbors_[index];\n};\n\n/**\n * Test if this Triangle contains the Point object given as parameter as one of its vertices.\n * Only point references are compared, not values.\n * @public\n * @param {XY} point - point object with {x,y}\n * @return {boolean} <code>True</code> if the Point object is of the Triangle's vertices,\n *         <code>false</code> otherwise.\n */\nTriangle.prototype.containsPoint = function(point) {\n    var points = this.points_;\n    // Here we are comparing point references, not values\n    return (point === points[0] || point === points[1] || point === points[2]);\n};\n\n/**\n * Test if this Triangle contains the Edge object given as parameter as its\n * bounding edges. Only point references are compared, not values.\n * @private\n * @param {Edge} edge\n * @return {boolean} <code>True</code> if the Edge object is of the Triangle's bounding\n *         edges, <code>false</code> otherwise.\n */\nTriangle.prototype.containsEdge = function(edge) {\n    return this.containsPoint(edge.p) && this.containsPoint(edge.q);\n};\n\n/**\n * Test if this Triangle contains the two Point objects given as parameters among its vertices.\n * Only point references are compared, not values.\n * @param {XY} p1 - point object with {x,y}\n * @param {XY} p2 - point object with {x,y}\n * @return {boolean}\n */\nTriangle.prototype.containsPoints = function(p1, p2) {\n    return this.containsPoint(p1) && this.containsPoint(p2);\n};\n\n/**\n * Has this triangle been marked as an interior triangle?\n * @returns {boolean}\n */\nTriangle.prototype.isInterior = function() {\n    return this.interior_;\n};\n\n/**\n * Mark this triangle as an interior triangle\n * @private\n * @param {boolean} interior\n * @returns {Triangle} this\n */\nTriangle.prototype.setInterior = function(interior) {\n    this.interior_ = interior;\n    return this;\n};\n\n/**\n * Update neighbor pointers.\n * @private\n * @param {XY} p1 - point object with {x,y}\n * @param {XY} p2 - point object with {x,y}\n * @param {Triangle} t Triangle object.\n * @throws {Error} if can't find objects\n */\nTriangle.prototype.markNeighborPointers = function(p1, p2, t) {\n    var points = this.points_;\n    // Here we are comparing point references, not values\n    if ((p1 === points[2] && p2 === points[1]) || (p1 === points[1] && p2 === points[2])) {\n        this.neighbors_[0] = t;\n    } else if ((p1 === points[0] && p2 === points[2]) || (p1 === points[2] && p2 === points[0])) {\n        this.neighbors_[1] = t;\n    } else if ((p1 === points[0] && p2 === points[1]) || (p1 === points[1] && p2 === points[0])) {\n        this.neighbors_[2] = t;\n    } else {\n        throw new Error('poly2tri Invalid Triangle.markNeighborPointers() call');\n    }\n};\n\n/**\n * Exhaustive search to update neighbor pointers\n * @private\n * @param {!Triangle} t\n */\nTriangle.prototype.markNeighbor = function(t) {\n    var points = this.points_;\n    if (t.containsPoints(points[1], points[2])) {\n        this.neighbors_[0] = t;\n        t.markNeighborPointers(points[1], points[2], this);\n    } else if (t.containsPoints(points[0], points[2])) {\n        this.neighbors_[1] = t;\n        t.markNeighborPointers(points[0], points[2], this);\n    } else if (t.containsPoints(points[0], points[1])) {\n        this.neighbors_[2] = t;\n        t.markNeighborPointers(points[0], points[1], this);\n    }\n};\n\n\nTriangle.prototype.clearNeighbors = function() {\n    this.neighbors_[0] = null;\n    this.neighbors_[1] = null;\n    this.neighbors_[2] = null;\n};\n\nTriangle.prototype.clearDelaunayEdges = function() {\n    this.delaunay_edge[0] = false;\n    this.delaunay_edge[1] = false;\n    this.delaunay_edge[2] = false;\n};\n\n/**\n * Returns the point clockwise to the given point.\n * @private\n * @param {XY} p - point object with {x,y}\n */\nTriangle.prototype.pointCW = function(p) {\n    var points = this.points_;\n    // Here we are comparing point references, not values\n    if (p === points[0]) {\n        return points[2];\n    } else if (p === points[1]) {\n        return points[0];\n    } else if (p === points[2]) {\n        return points[1];\n    } else {\n        return null;\n    }\n};\n\n/**\n * Returns the point counter-clockwise to the given point.\n * @private\n * @param {XY} p - point object with {x,y}\n */\nTriangle.prototype.pointCCW = function(p) {\n    var points = this.points_;\n    // Here we are comparing point references, not values\n    if (p === points[0]) {\n        return points[1];\n    } else if (p === points[1]) {\n        return points[2];\n    } else if (p === points[2]) {\n        return points[0];\n    } else {\n        return null;\n    }\n};\n\n/**\n * Returns the neighbor clockwise to given point.\n * @private\n * @param {XY} p - point object with {x,y}\n */\nTriangle.prototype.neighborCW = function(p) {\n    // Here we are comparing point references, not values\n    if (p === this.points_[0]) {\n        return this.neighbors_[1];\n    } else if (p === this.points_[1]) {\n        return this.neighbors_[2];\n    } else {\n        return this.neighbors_[0];\n    }\n};\n\n/**\n * Returns the neighbor counter-clockwise to given point.\n * @private\n * @param {XY} p - point object with {x,y}\n */\nTriangle.prototype.neighborCCW = function(p) {\n    // Here we are comparing point references, not values\n    if (p === this.points_[0]) {\n        return this.neighbors_[2];\n    } else if (p === this.points_[1]) {\n        return this.neighbors_[0];\n    } else {\n        return this.neighbors_[1];\n    }\n};\n\nTriangle.prototype.getConstrainedEdgeCW = function(p) {\n    // Here we are comparing point references, not values\n    if (p === this.points_[0]) {\n        return this.constrained_edge[1];\n    } else if (p === this.points_[1]) {\n        return this.constrained_edge[2];\n    } else {\n        return this.constrained_edge[0];\n    }\n};\n\nTriangle.prototype.getConstrainedEdgeCCW = function(p) {\n    // Here we are comparing point references, not values\n    if (p === this.points_[0]) {\n        return this.constrained_edge[2];\n    } else if (p === this.points_[1]) {\n        return this.constrained_edge[0];\n    } else {\n        return this.constrained_edge[1];\n    }\n};\n\n// Additional check from Java version (see issue #88)\nTriangle.prototype.getConstrainedEdgeAcross = function(p) {\n    // Here we are comparing point references, not values\n    if (p === this.points_[0]) {\n        return this.constrained_edge[0];\n    } else if (p === this.points_[1]) {\n        return this.constrained_edge[1];\n    } else {\n        return this.constrained_edge[2];\n    }\n};\n\nTriangle.prototype.setConstrainedEdgeCW = function(p, ce) {\n    // Here we are comparing point references, not values\n    if (p === this.points_[0]) {\n        this.constrained_edge[1] = ce;\n    } else if (p === this.points_[1]) {\n        this.constrained_edge[2] = ce;\n    } else {\n        this.constrained_edge[0] = ce;\n    }\n};\n\nTriangle.prototype.setConstrainedEdgeCCW = function(p, ce) {\n    // Here we are comparing point references, not values\n    if (p === this.points_[0]) {\n        this.constrained_edge[2] = ce;\n    } else if (p === this.points_[1]) {\n        this.constrained_edge[0] = ce;\n    } else {\n        this.constrained_edge[1] = ce;\n    }\n};\n\nTriangle.prototype.getDelaunayEdgeCW = function(p) {\n    // Here we are comparing point references, not values\n    if (p === this.points_[0]) {\n        return this.delaunay_edge[1];\n    } else if (p === this.points_[1]) {\n        return this.delaunay_edge[2];\n    } else {\n        return this.delaunay_edge[0];\n    }\n};\n\nTriangle.prototype.getDelaunayEdgeCCW = function(p) {\n    // Here we are comparing point references, not values\n    if (p === this.points_[0]) {\n        return this.delaunay_edge[2];\n    } else if (p === this.points_[1]) {\n        return this.delaunay_edge[0];\n    } else {\n        return this.delaunay_edge[1];\n    }\n};\n\nTriangle.prototype.setDelaunayEdgeCW = function(p, e) {\n    // Here we are comparing point references, not values\n    if (p === this.points_[0]) {\n        this.delaunay_edge[1] = e;\n    } else if (p === this.points_[1]) {\n        this.delaunay_edge[2] = e;\n    } else {\n        this.delaunay_edge[0] = e;\n    }\n};\n\nTriangle.prototype.setDelaunayEdgeCCW = function(p, e) {\n    // Here we are comparing point references, not values\n    if (p === this.points_[0]) {\n        this.delaunay_edge[2] = e;\n    } else if (p === this.points_[1]) {\n        this.delaunay_edge[0] = e;\n    } else {\n        this.delaunay_edge[1] = e;\n    }\n};\n\n/**\n * The neighbor across to given point.\n * @private\n * @param {XY} p - point object with {x,y}\n * @returns {Triangle}\n */\nTriangle.prototype.neighborAcross = function(p) {\n    // Here we are comparing point references, not values\n    if (p === this.points_[0]) {\n        return this.neighbors_[0];\n    } else if (p === this.points_[1]) {\n        return this.neighbors_[1];\n    } else {\n        return this.neighbors_[2];\n    }\n};\n\n/**\n * @private\n * @param {!Triangle} t Triangle object.\n * @param {XY} p - point object with {x,y}\n */\nTriangle.prototype.oppositePoint = function(t, p) {\n    var cw = t.pointCW(p);\n    return this.pointCW(cw);\n};\n\n/**\n * Legalize triangle by rotating clockwise around oPoint\n * @private\n * @param {XY} opoint - point object with {x,y}\n * @param {XY} npoint - point object with {x,y}\n * @throws {Error} if oPoint can not be found\n */\nTriangle.prototype.legalize = function(opoint, npoint) {\n    var points = this.points_;\n    // Here we are comparing point references, not values\n    if (opoint === points[0]) {\n        points[1] = points[0];\n        points[0] = points[2];\n        points[2] = npoint;\n    } else if (opoint === points[1]) {\n        points[2] = points[1];\n        points[1] = points[0];\n        points[0] = npoint;\n    } else if (opoint === points[2]) {\n        points[0] = points[2];\n        points[2] = points[1];\n        points[1] = npoint;\n    } else {\n        throw new Error('poly2tri Invalid Triangle.legalize() call');\n    }\n};\n\n/**\n * Returns the index of a point in the triangle. \n * The point *must* be a reference to one of the triangle's vertices.\n * @private\n * @param {XY} p - point object with {x,y}\n * @returns {number} index 0, 1 or 2\n * @throws {Error} if p can not be found\n */\nTriangle.prototype.index = function(p) {\n    var points = this.points_;\n    // Here we are comparing point references, not values\n    if (p === points[0]) {\n        return 0;\n    } else if (p === points[1]) {\n        return 1;\n    } else if (p === points[2]) {\n        return 2;\n    } else {\n        throw new Error('poly2tri Invalid Triangle.index() call');\n    }\n};\n\n/**\n * @private\n * @param {XY} p1 - point object with {x,y}\n * @param {XY} p2 - point object with {x,y}\n * @return {number} index 0, 1 or 2, or -1 if errror\n */\nTriangle.prototype.edgeIndex = function(p1, p2) {\n    var points = this.points_;\n    // Here we are comparing point references, not values\n    if (p1 === points[0]) {\n        if (p2 === points[1]) {\n            return 2;\n        } else if (p2 === points[2]) {\n            return 1;\n        }\n    } else if (p1 === points[1]) {\n        if (p2 === points[2]) {\n            return 0;\n        } else if (p2 === points[0]) {\n            return 2;\n        }\n    } else if (p1 === points[2]) {\n        if (p2 === points[0]) {\n            return 1;\n        } else if (p2 === points[1]) {\n            return 0;\n        }\n    }\n    return -1;\n};\n\n/**\n * Mark an edge of this triangle as constrained.\n * @private\n * @param {number} index - edge index\n */\nTriangle.prototype.markConstrainedEdgeByIndex = function(index) {\n    this.constrained_edge[index] = true;\n};\n/**\n * Mark an edge of this triangle as constrained.\n * @private\n * @param {Edge} edge instance\n */\nTriangle.prototype.markConstrainedEdgeByEdge = function(edge) {\n    this.markConstrainedEdgeByPoints(edge.p, edge.q);\n};\n/**\n * Mark an edge of this triangle as constrained.\n * This method takes two Point instances defining the edge of the triangle.\n * @private\n * @param {XY} p - point object with {x,y}\n * @param {XY} q - point object with {x,y}\n */\nTriangle.prototype.markConstrainedEdgeByPoints = function(p, q) {\n    var points = this.points_;\n    // Here we are comparing point references, not values        \n    if ((q === points[0] && p === points[1]) || (q === points[1] && p === points[0])) {\n        this.constrained_edge[2] = true;\n    } else if ((q === points[0] && p === points[2]) || (q === points[2] && p === points[0])) {\n        this.constrained_edge[1] = true;\n    } else if ((q === points[1] && p === points[2]) || (q === points[2] && p === points[1])) {\n        this.constrained_edge[0] = true;\n    }\n};\n\n\n// ---------------------------------------------------------Exports (public API)\n\nmodule.exports = Triangle;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/poly2tri/src/triangle.js\n// module id = 4\n// module chunks = 0","// Copyright 2014-2016 Todd Fleming\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n// \n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n// \n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n// TODO: pass React elements to alertFn\n\n\"use strict\";\n\nimport ClipperLib from 'clipper-lib';\nimport SweepContext from 'poly2tri/src/sweepcontext';\n\nexport const inchToClipperScale = 1270000000;\nexport const mmToClipperScale = inchToClipperScale / 25.4; // 50000000;\nexport const clipperToCppScale = 1 / 128; // Prevent overflow for coordinates up to ~1000 mm\nexport const cleanPolyDist = 100;\nexport const arcTolerance = 10000;\n\n// Linearize a cubic bezier. Returns ['L', x2, y2, x3, y3, ...]. The return value doesn't\n// include (p1x, p1y); it's part of the previous segment.\nfunction linearizeCubicBezier(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, minNumSegments, minSegmentLength) {\n    function bez(p0, p1, p2, p3, t) {\n        return (1 - t) * (1 - t) * (1 - t) * p0 + 3 * (1 - t) * (1 - t) * t * p1 + 3 * (1 - t) * t * t * p2 + t * t * t * p3;\n    }\n\n    if (p1x == c1x && p1y == c1y && p2x == c2x && p2y == c2y)\n        return ['L', p2x, p2y];\n\n    let numSegments = minNumSegments;\n    while (true) {\n        let x = p1x;\n        let y = p1y;\n        let result = ['L'];\n        for (let i = 1; i <= numSegments; ++i) {\n            let t = 1.0 * i / numSegments;\n            let nextX = bez(p1x, c1x, c2x, p2x, t);\n            let nextY = bez(p1y, c1y, c2y, p2y, t);\n            if ((nextX - x) * (nextX - x) + (nextY - y) * (nextY - y) > minSegmentLength * minSegmentLength) {\n                numSegments *= 2;\n                result = null;\n                break;\n            }\n            result.push(nextX, nextY);\n            x = nextX;\n            y = nextY;\n        }\n        if (result)\n            return result;\n    }\n}\n\n// Linearize a path. Both the input path and the returned path are in snap.svg's format.\n// Calls alertFn with an error message and returns null if there's a problem.\nfunction linearizeSnapPath(path, minNumSegments, minSegmentLength, alertFn) {\n    if (path.length < 2 || path[0].length != 3 || path[0][0] != 'M') {\n        alertFn('Path does not begin with M')\n        return null;\n    }\n    let x = path[0][1];\n    let y = path[0][2];\n    let result = [path[0]];\n    for (let i = 1; i < path.length; ++i) {\n        let subpath = path[i];\n        if (subpath[0] == 'C' && subpath.length == 7) {\n            result.push(linearizeCubicBezier(\n                x, y, subpath[1], subpath[2], subpath[3], subpath[4], subpath[5], subpath[6], minNumSegments, minSegmentLength));\n            x = subpath[5];\n            y = subpath[6];\n        } else if (subpath[0] == 'M' && subpath.length == 3) {\n            result.push(subpath);\n            x = subpath[1];\n            y = subpath[2];\n        } else {\n            alertFn('Subpath has an unknown prefix: ' + subpath[0]);\n            return null;\n        }\n    }\n    return result;\n};\n\n// Get linear paths (snap format) from an SVG element. Calls alertFn with an \n// error message and returns null if there's a problem.\nfunction elementToLinearSnapPaths(element, minNumSegments, minSegmentLength, alertFn) {\n    let path = null;\n    let Snap = require('snapsvg-cjs');\n    let snapElement = Snap(element);\n\n    if (snapElement.type == 'path')\n        path = snapElement.attr('d');\n    else if (snapElement.type == 'rect') {\n        let x = Number(snapElement.attr('x'));\n        let y = Number(snapElement.attr('y'));\n        let w = Number(snapElement.attr('width'));\n        let h = Number(snapElement.attr('height'));\n        path = 'm' + x + ',' + y + ' ' + w + ',' + 0 + ' ' + 0 + ',' + h + ' ' + (-w) + ',' + 0 + ' ' + 0 + ',' + (-h) + ' ';\n    }\n    else {\n        alertFn('<b>' + snapElement.type + \"</b> is not supported; try Inkscape's <strong>Object to Path</strong> command\");\n        return null;\n    }\n\n    if (snapElement.attr('clip-path') != '') {\n        alertFn('clip-path is not supported');\n        return null;\n    }\n\n    if (snapElement.attr('mask') != '') {\n        alertFn('mask is not supported');\n        return null;\n    }\n\n    if (path == null) {\n        alertFn('path is missing');\n        return;\n    }\n\n    path = Snap.path.map(path, snapElement.transform().globalMatrix);\n    path = Snap.parsePathString(path);\n    path = linearizeSnapPath(path, minNumSegments, minSegmentLength, alertFn);\n    return path;\n};\n\n// Convert a path in snap.svg format to [[x0, y0, x1, y1, ...], ...].\n// Result is in mm. Returns multiple paths. Only supports linear paths.\n// Calls alertFn with an error message and returns null if there's a problem.\nfunction snapPathToRawPaths(snapPath, pxPerInch, alertFn) {\n    let factor = 25.4 / pxPerInch;\n    if (snapPath.length < 2 || snapPath[0].length != 3 || snapPath[0][0] != 'M') {\n        alertFn('Path does not begin with M');\n        return null;\n    }\n    let currentPath = [snapPath[0][1] * factor, snapPath[0][2] * factor];\n    let result = [currentPath];\n    for (let i = 1; i < snapPath.length; ++i) {\n        let subpath = snapPath[i];\n        if (subpath[0] == 'M' && subpath.length == 3) {\n            currentPath = [subpath[1] * factor, subpath[2] * factor];\n            result.push(currentPath);\n        } else if (subpath[0] == 'L') {\n            for (let j = 0; j < (subpath.length - 1) / 2; ++j)\n                currentPath.push(subpath[1 + j * 2] * factor, subpath[2 + j * 2] * factor);\n        } else {\n            alertFn('Subpath has a non-linear prefix: ' + subpath[0]);\n            return null;\n        }\n    }\n    return result;\n};\n\n// Convert a path in an SVG element to [[x0, y0, x1, y1, ...], ...].\n// Result is in mm. Returns multiple paths. Converts curves.\n// Calls alertFn with an error message and returns null if there's a problem.\nexport function elementToRawPaths(element, pxPerInch, minNumSegments, minSegmentLength, alertFn) {\n    let path = elementToLinearSnapPaths(element, minNumSegments, minSegmentLength, alertFn);\n    if (path !== null)\n        return snapPathToRawPaths(path, pxPerInch, alertFn);\n    return null;\n}\n\n// [[[x0, y0, x1, y1, ...], ...], ...]\nexport function flipY(allRawPaths, deltaY) {\n    for (let rawPaths of allRawPaths)\n        for (let rawPath of rawPaths)\n            for (let i = 0; i < rawPath.length; i += 2)\n                rawPath[i + 1] = deltaY - rawPath[i + 1];\n}\n\nexport function hasClosedRawPaths(rawPaths) {\n    for (let path of rawPaths)\n        if (path.length >= 4 && path[0] == path[path.length - 2] && path[1] == path[path.length - 1])\n            return true;\n    return false;\n}\n\nexport function filterClosedRawPaths(rawPaths) {\n    let result = [];\n    for (let path of rawPaths)\n        if (path.length >= 4 && path[0] == path[path.length - 2] && path[1] == path[path.length - 1])\n            result.push(path);\n    return result;\n}\n\nexport function rawPathsToClipperPaths(rawPaths, scaleX, scaleY, translateX, translateY) {\n    let result = rawPaths.map(p => {\n        let result = [];\n        for (let i = 0; i < p.length; i += 2)\n            result.push({ X: (p[i] * scaleX + translateX) * mmToClipperScale, Y: (p[i + 1] * scaleY + translateY) * mmToClipperScale });\n        return result;\n    });\n    if (hasClosedRawPaths(rawPaths)) {\n        result = ClipperLib.Clipper.CleanPolygons(result, cleanPolyDist);\n        result = ClipperLib.Clipper.SimplifyPolygons(result, ClipperLib.PolyFillType.pftEvenOdd);\n    }\n    return result;\n}\n\nfunction clipperPathsToPolyTree(paths) {\n    let c = new ClipperLib.Clipper();\n    c.AddPaths(paths, ClipperLib.PolyType.ptSubject, true);\n    let polyTree = new ClipperLib.PolyTree();\n    c.Execute(ClipperLib.ClipType.ctUnion, polyTree, ClipperLib.PolyFillType.pftEvenOdd, ClipperLib.PolyFillType.pftEvenOdd);\n    return polyTree;\n}\n\nfunction triangulatePolyTree(polyTree) {\n    let result = [];\n    let pointToVertex = point => ({ x: point.X / mmToClipperScale, y: point.Y / mmToClipperScale });\n    let contourToVertexes = path => path.map(pointToVertex);\n    let nodesToVertexes = nodes => nodes.map(node => contourToVertexes(node.Contour()));\n    let processNode = node => {\n        let vertexes = contourToVertexes(node.Contour());\n        let holes = nodesToVertexes(node.Childs());\n        let context = new SweepContext(vertexes);\n        context.addHoles(holes);\n        context.triangulate();\n        let triangles = context.getTriangles();\n        for (let t of triangles) {\n            let p = t.getPoints();\n            result.push(\n                p[0].x, p[0].y,\n                p[1].x, p[1].y,\n                p[2].x, p[2].y);\n        }\n        for (let hole of node.Childs()) {\n            for (let next of hole.Childs()) {\n                processNode(next);\n            }\n        }\n    };\n    for (let node of polyTree.Childs()) {\n        processNode(node);\n    }\n    return result;\n}\n\nexport function triangulateRawPaths(rawPaths) {\n    return triangulatePolyTree(clipperPathsToPolyTree(rawPathsToClipperPaths(rawPaths, 1, 1, 0, 0)));\n}\n\n// Convert Clipper paths to C. Returns [double** cPaths, int cNumPaths, int* cPathSizes].\nexport function clipperPathsToCPaths(memoryBlocks, clipperPaths) {\n    let doubleSize = 8;\n\n    let cPaths = Module._malloc(clipperPaths.length * 4);\n    memoryBlocks.push(cPaths);\n    let cPathsBase = cPaths >> 2;\n\n    let cPathSizes = Module._malloc(clipperPaths.length * 4);\n    memoryBlocks.push(cPathSizes);\n    let cPathSizesBase = cPathSizes >> 2;\n\n    for (let i = 0; i < clipperPaths.length; ++i) {\n        let clipperPath = clipperPaths[i];\n\n        let cPath = Module._malloc(clipperPath.length * 2 * doubleSize + 4);\n        memoryBlocks.push(cPath);\n        if (cPath & 4)\n            cPath += 4;\n        //console.log(\"-> \" + cPath.toString(16));\n        let pathArray = new Float64Array(Module.HEAPU32.buffer, Module.HEAPU32.byteOffset + cPath);\n\n        for (let j = 0; j < clipperPath.length; ++j) {\n            let point = clipperPath[j];\n            pathArray[j * 2] = point.X * clipperToCppScale;\n            pathArray[j * 2 + 1] = point.Y * clipperToCppScale;\n        }\n\n        Module.HEAPU32[cPathsBase + i] = cPath;\n        Module.HEAPU32[cPathSizesBase + i] = clipperPath.length;\n    }\n\n    return [cPaths, clipperPaths.length, cPathSizes];\n}\n\n// Convert C paths to Clipper paths. double**& cPathsRef, int& cNumPathsRef, int*& cPathSizesRef\n// Each point has X, Y (stride = 2).\nexport function cPathsToClipperPaths(memoryBlocks, cPathsRef, cNumPathsRef, cPathSizesRef) {\n    let cPaths = Module.HEAPU32[cPathsRef >> 2];\n    memoryBlocks.push(cPaths);\n    let cPathsBase = cPaths >> 2;\n\n    let cNumPaths = Module.HEAPU32[cNumPathsRef >> 2];\n\n    let cPathSizes = Module.HEAPU32[cPathSizesRef >> 2];\n    memoryBlocks.push(cPathSizes);\n    let cPathSizesBase = cPathSizes >> 2;\n\n    let clipperPaths = [];\n    for (let i = 0; i < cNumPaths; ++i) {\n        let pathSize = Module.HEAPU32[cPathSizesBase + i];\n        let cPath = Module.HEAPU32[cPathsBase + i];\n        // cPath contains value to pass to Module._free(). The aligned version contains the actual data.\n        memoryBlocks.push(cPath);\n        if (cPath & 4)\n            cPath += 4;\n        let pathArray = new Float64Array(Module.HEAPU32.buffer, Module.HEAPU32.byteOffset + cPath);\n\n        let clipperPath = [];\n        clipperPaths.push(clipperPath);\n        for (let j = 0; j < pathSize; ++j)\n            clipperPath.push({\n                X: pathArray[j * 2] / clipperToCppScale,\n                Y: pathArray[j * 2 + 1] / clipperToCppScale,\n            });\n    }\n\n    return clipperPaths;\n}\n\n// Convert C paths to array of CamPath. double**& cPathsRef, int& cNumPathsRef, int*& cPathSizesRef\n// Each point has X, Y, Z (stride = 3).\nexport function cPathsToCamPaths(memoryBlocks, cPathsRef, cNumPathsRef, cPathSizesRef) {\n    let cPaths = Module.HEAPU32[cPathsRef >> 2];\n    memoryBlocks.push(cPaths);\n    let cPathsBase = cPaths >> 2;\n\n    let cNumPaths = Module.HEAPU32[cNumPathsRef >> 2];\n\n    let cPathSizes = Module.HEAPU32[cPathSizesRef >> 2];\n    memoryBlocks.push(cPathSizes);\n    let cPathSizesBase = cPathSizes >> 2;\n\n    let convertedPaths = [];\n    for (let i = 0; i < cNumPaths; ++i) {\n        let pathSize = Module.HEAPU32[cPathSizesBase + i];\n        let cPath = Module.HEAPU32[cPathsBase + i];\n        // cPath contains value to pass to Module._free(). The aligned version contains the actual data.\n        memoryBlocks.push(cPath);\n        if (cPath & 4)\n            cPath += 4;\n        let pathArray = new Float64Array(Module.HEAPU32.buffer, Module.HEAPU32.byteOffset + cPath);\n\n        let convertedPath = [];\n        convertedPaths.push({ path: convertedPath, safeToClose: false });\n        for (let j = 0; j < pathSize; ++j)\n            convertedPath.push({\n                X: pathArray[j * 3] / clipperToCppScale,\n                Y: pathArray[j * 3 + 1] / clipperToCppScale,\n                Z: pathArray[j * 3 + 2] / clipperToCppScale,\n            });\n\n        //console.log('got: path', i, ':', pathArray[0], pathArray[1], pathArray[2]);\n    }\n\n    return convertedPaths;\n}\n\nexport function clipperBounds(paths) {\n    let minX = Number.MAX_VALUE;\n    let minY = Number.MAX_VALUE;\n    let maxX = -Number.MAX_VALUE;\n    let maxY = -Number.MAX_VALUE;\n    for (let path of paths) {\n        for (let pt of path) {\n            minX = Math.min(minX, pt.X);\n            maxX = Math.max(maxX, pt.X);\n            minY = Math.min(minY, pt.Y);\n            maxY = Math.max(maxY, pt.Y);\n        }\n    }\n    return { minX, minY, maxX, maxY };\n}\n\n// Clip Clipper geometry. clipType is a ClipperLib.ClipType constant. Returns new geometry.\nexport function clip(paths1, paths2, clipType) {\n    var clipper = new ClipperLib.Clipper();\n    clipper.AddPaths(paths1, ClipperLib.PolyType.ptSubject, true);\n    clipper.AddPaths(paths2, ClipperLib.PolyType.ptClip, true);\n    var result = [];\n    clipper.Execute(clipType, result, ClipperLib.PolyFillType.pftEvenOdd, ClipperLib.PolyFillType.pftEvenOdd);\n    return result;\n}\n\n// Return union of two Clipper geometries. Returns new geometry.\nexport function union(paths1, paths2) {\n    return clip(paths1, paths2, ClipperLib.ClipType.ctUnion);\n}\n\n// Return difference between two Clipper geometries. Returns new geometry.\nexport function diff(paths1, paths2) {\n    return clip(paths1, paths2, ClipperLib.ClipType.ctDifference);\n}\n\n// Return xor of two Clipper geometries. Returns new geometry.\nexport function xor(paths1, paths2) {\n    return clip(paths1, paths2, ClipperLib.ClipType.ctXor);\n}\n\n// Offset Clipper geometries by amount (positive expands, negative shrinks). Returns new geometry.\nexport function offset(paths, amount, joinType, endType) {\n    if (joinType === undefined)\n        joinType = ClipperLib.JoinType.jtRound;\n    if (endType === undefined)\n        endType = ClipperLib.EndType.etClosedPolygon;\n\n    // bug workaround: join types are swapped in ClipperLib 6.1.3.2\n    if (joinType === ClipperLib.JoinType.jtSquare)\n        joinType = ClipperLib.JoinType.jtMiter;\n    else if (joinType === ClipperLib.JoinType.jtMiter)\n        joinType = ClipperLib.JoinType.jtSquare;\n\n    var co = new ClipperLib.ClipperOffset(2, arcTolerance);\n    co.AddPaths(paths, joinType, endType);\n    var offsetted = [];\n    co.Execute(offsetted, amount);\n    return offsetted;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/mesh.js","// rev 482\n/********************************************************************************\n *                                                                              *\n * Author    :  Angus Johnson                                                   *\n * Version   :  6.2.1                                                          *\n * Date      :  31 October 2014                                                 *\n * Website   :  http://www.angusj.com                                           *\n * Copyright :  Angus Johnson 2010-2014                                         *\n *                                                                              *\n * License:                                                                     *\n * Use, modification & distribution is subject to Boost Software License Ver 1. *\n * http://www.boost.org/LICENSE_1_0.txt                                         *\n *                                                                              *\n * Attributions:                                                                *\n * The code in this library is an extension of Bala Vatti's clipping algorithm: *\n * \"A generic solution to polygon clipping\"                                     *\n * Communications of the ACM, Vol 35, Issue 7 (July 1992) pp 56-63.             *\n * http://portal.acm.org/citation.cfm?id=129906                                 *\n *                                                                              *\n * Computer graphics and geometric modeling: implementation and algorithms      *\n * By Max K. Agoston                                                            *\n * Springer; 1 edition (January 4, 2005)                                        *\n * http://books.google.com/books?q=vatti+clipping+agoston                       *\n *                                                                              *\n * See also:                                                                    *\n * \"Polygon Offsetting by Computing Winding Numbers\"                            *\n * Paper no. DETC2005-85513 pp. 565-575                                         *\n * ASME 2005 International Design Engineering Technical Conferences             *\n * and Computers and Information in Engineering Conference (IDETC/CIE2005)      *\n * September 24-28, 2005 , Long Beach, California, USA                          *\n * http://www.me.berkeley.edu/~mcmains/pubs/DAC05OffsetPolygon.pdf              *\n *                                                                              *\n *******************************************************************************/\n/*******************************************************************************\n *                                                                              *\n * Author    :  Timo                                                            *\n * Version   :  6.2.1.0                                                         *\n * Date      :  17 June 2016                                                 *\n *                                                                              *\n * This is a translation of the C# Clipper library to Javascript.               *\n * Int128 struct of C# is implemented using JSBN of Tom Wu.                     *\n * Because Javascript lacks support for 64-bit integers, the space              *\n * is a little more restricted than in C# version.                              *\n *                                                                              *\n * C# version has support for coordinate space:                                 *\n * +-4611686018427387903 ( sqrt(2^127 -1)/2 )                                   *\n * while Javascript version has support for space:                              *\n * +-4503599627370495 ( sqrt(2^106 -1)/2 )                                      *\n *                                                                              *\n * Tom Wu's JSBN proved to be the fastest big integer library:                  *\n * http://jsperf.com/big-integer-library-test                                   *\n *                                                                              *\n * This class can be made simpler when (if ever) 64-bit integer support comes.  *\n *                                                                              *\n *******************************************************************************/\n/*******************************************************************************\n *                                                                              *\n * Basic JavaScript BN library - subset useful for RSA encryption.              *\n * http://www-cs-students.stanford.edu/~tjw/jsbn/                               *\n * Copyright (c) 2005  Tom Wu                                                   *\n * All Rights Reserved.                                                         *\n * See \"LICENSE\" for details:                                                   *\n * http://www-cs-students.stanford.edu/~tjw/jsbn/LICENSE                        *\n *                                                                              *\n *******************************************************************************/\n(function ()\n{\n  \"use strict\";\n  //use_int32: When enabled 32bit ints are used instead of 64bit ints. This\n  //improve performance but coordinate values are limited to the range +/- 46340\n  var use_int32 = false;\n  //use_xyz: adds a Z member to IntPoint. Adds a minor cost to performance.\n  var use_xyz = false;\n  //UseLines: Enables open path clipping. Adds a very minor cost to performance.\n  var use_lines = true;\n\n  var ClipperLib = {};\n  var isNode = false;\n  if (typeof module !== 'undefined' && module.exports)\n  {\n    module.exports = ClipperLib;\n    isNode = true;\n  }\n  else\n  {\n    if (typeof define === 'function' && define.amd) {\n      define(ClipperLib);\n    }\n    if (typeof (document) !== \"undefined\") window.ClipperLib = ClipperLib;\n    else self['ClipperLib'] = ClipperLib;\n  }\n  var navigator_appName;\n  if (!isNode)\n  {\n    var nav = navigator.userAgent.toString().toLowerCase();\n    navigator_appName = navigator.appName;\n  }\n  else\n  {\n    var nav = \"chrome\"; // Node.js uses Chrome's V8 engine\n    navigator_appName = \"Netscape\"; // Firefox, Chrome and Safari returns \"Netscape\", so Node.js should also\n  }\n  // Browser test to speedup performance critical functions\n  var browser = {};\n  if (nav.indexOf(\"chrome\") != -1 && nav.indexOf(\"chromium\") == -1) browser.chrome = 1;\n  else browser.chrome = 0;\n  if (nav.indexOf(\"chromium\") != -1) browser.chromium = 1;\n  else browser.chromium = 0;\n  if (nav.indexOf(\"safari\") != -1 && nav.indexOf(\"chrome\") == -1 && nav.indexOf(\"chromium\") == -1) browser.safari = 1;\n  else browser.safari = 0;\n  if (nav.indexOf(\"firefox\") != -1) browser.firefox = 1;\n  else browser.firefox = 0;\n  if (nav.indexOf(\"firefox/17\") != -1) browser.firefox17 = 1;\n  else browser.firefox17 = 0;\n  if (nav.indexOf(\"firefox/15\") != -1) browser.firefox15 = 1;\n  else browser.firefox15 = 0;\n  if (nav.indexOf(\"firefox/3\") != -1) browser.firefox3 = 1;\n  else browser.firefox3 = 0;\n  if (nav.indexOf(\"opera\") != -1) browser.opera = 1;\n  else browser.opera = 0;\n  if (nav.indexOf(\"msie 10\") != -1) browser.msie10 = 1;\n  else browser.msie10 = 0;\n  if (nav.indexOf(\"msie 9\") != -1) browser.msie9 = 1;\n  else browser.msie9 = 0;\n  if (nav.indexOf(\"msie 8\") != -1) browser.msie8 = 1;\n  else browser.msie8 = 0;\n  if (nav.indexOf(\"msie 7\") != -1) browser.msie7 = 1;\n  else browser.msie7 = 0;\n  if (nav.indexOf(\"msie \") != -1) browser.msie = 1;\n  else browser.msie = 0;\n  ClipperLib.biginteger_used = null;\n\n  // Copyright (c) 2005  Tom Wu\n  // All Rights Reserved.\n  // See \"LICENSE\" for details.\n  // Basic JavaScript BN library - subset useful for RSA encryption.\n  // Bits per digit\n  var dbits;\n  // JavaScript engine analysis\n  var canary = 0xdeadbeefcafe;\n  var j_lm = ((canary & 0xffffff) == 0xefcafe);\n  // (public) Constructor\n  function BigInteger(a, b, c)\n  {\n    // This test variable can be removed,\n    // but at least for performance tests it is useful piece of knowledge\n    // This is the only ClipperLib related variable in BigInteger library\n    ClipperLib.biginteger_used = 1;\n    if (a != null)\n      if (\"number\" == typeof a && \"undefined\" == typeof (b)) this.fromInt(a); // faster conversion\n      else if (\"number\" == typeof a) this.fromNumber(a, b, c);\n    else if (b == null && \"string\" != typeof a) this.fromString(a, 256);\n    else this.fromString(a, b);\n  }\n  // return new, unset BigInteger\n  function nbi()\n  {\n    return new BigInteger(null,undefined,undefined);\n  }\n  // am: Compute w_j += (x*this_i), propagate carries,\n  // c is initial carry, returns final carry.\n  // c < 3*dvalue, x < 2*dvalue, this_i < dvalue\n  // We need to select the fastest one that works in this environment.\n  // am1: use a single mult and divide to get the high bits,\n  // max digit bits should be 26 because\n  // max internal value = 2*dvalue^2-2*dvalue (< 2^53)\n  function am1(i, x, w, j, c, n)\n  {\n    while (--n >= 0)\n    {\n      var v = x * this[i++] + w[j] + c;\n      c = Math.floor(v / 0x4000000);\n      w[j++] = v & 0x3ffffff;\n    }\n    return c;\n  }\n  // am2 avoids a big mult-and-extract completely.\n  // Max digit bits should be <= 30 because we do bitwise ops\n  // on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)\n  function am2(i, x, w, j, c, n)\n  {\n    var xl = x & 0x7fff,\n      xh = x >> 15;\n    while (--n >= 0)\n    {\n      var l = this[i] & 0x7fff;\n      var h = this[i++] >> 15;\n      var m = xh * l + h * xl;\n      l = xl * l + ((m & 0x7fff) << 15) + w[j] + (c & 0x3fffffff);\n      c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);\n      w[j++] = l & 0x3fffffff;\n    }\n    return c;\n  }\n  // Alternately, set max digit bits to 28 since some\n  // browsers slow down when dealing with 32-bit numbers.\n  function am3(i, x, w, j, c, n)\n  {\n    var xl = x & 0x3fff,\n      xh = x >> 14;\n    while (--n >= 0)\n    {\n      var l = this[i] & 0x3fff;\n      var h = this[i++] >> 14;\n      var m = xh * l + h * xl;\n      l = xl * l + ((m & 0x3fff) << 14) + w[j] + c;\n      c = (l >> 28) + (m >> 14) + xh * h;\n      w[j++] = l & 0xfffffff;\n    }\n    return c;\n  }\n  if (j_lm && (navigator_appName == \"Microsoft Internet Explorer\"))\n  {\n    BigInteger.prototype.am = am2;\n    dbits = 30;\n  }\n  else if (j_lm && (navigator_appName != \"Netscape\"))\n  {\n    BigInteger.prototype.am = am1;\n    dbits = 26;\n  }\n  else\n  { // Mozilla/Netscape seems to prefer am3\n    BigInteger.prototype.am = am3;\n    dbits = 28;\n  }\n  BigInteger.prototype.DB = dbits;\n  BigInteger.prototype.DM = ((1 << dbits) - 1);\n  BigInteger.prototype.DV = (1 << dbits);\n  var BI_FP = 52;\n  BigInteger.prototype.FV = Math.pow(2, BI_FP);\n  BigInteger.prototype.F1 = BI_FP - dbits;\n  BigInteger.prototype.F2 = 2 * dbits - BI_FP;\n  // Digit conversions\n  var BI_RM = \"0123456789abcdefghijklmnopqrstuvwxyz\";\n  var BI_RC = new Array();\n  var rr, vv;\n  rr = \"0\".charCodeAt(0);\n  for (vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;\n  rr = \"a\".charCodeAt(0);\n  for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\n  rr = \"A\".charCodeAt(0);\n  for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\n\n  function int2char(n)\n  {\n    return BI_RM.charAt(n);\n  }\n\n  function intAt(s, i)\n  {\n    var c = BI_RC[s.charCodeAt(i)];\n    return (c == null) ? -1 : c;\n  }\n  // (protected) copy this to r\n  function bnpCopyTo(r)\n  {\n    for (var i = this.t - 1; i >= 0; --i) r[i] = this[i];\n    r.t = this.t;\n    r.s = this.s;\n  }\n  // (protected) set from integer value x, -DV <= x < DV\n  function bnpFromInt(x)\n  {\n    this.t = 1;\n    this.s = (x < 0) ? -1 : 0;\n    if (x > 0) this[0] = x;\n    else if (x < -1) this[0] = x + this.DV;\n    else this.t = 0;\n  }\n  // return bigint initialized to value\n  function nbv(i)\n  {\n    var r = nbi();\n    r.fromInt(i);\n    return r;\n  }\n  // (protected) set from string and radix\n  function bnpFromString(s, b)\n  {\n    var k;\n    if (b == 16) k = 4;\n    else if (b == 8) k = 3;\n    else if (b == 256) k = 8; // byte array\n    else if (b == 2) k = 1;\n    else if (b == 32) k = 5;\n    else if (b == 4) k = 2;\n    else\n    {\n      this.fromRadix(s, b);\n      return;\n    }\n    this.t = 0;\n    this.s = 0;\n    var i = s.length,\n      mi = false,\n      sh = 0;\n    while (--i >= 0)\n    {\n      var x = (k == 8) ? s[i] & 0xff : intAt(s, i);\n      if (x < 0)\n      {\n        if (s.charAt(i) == \"-\") mi = true;\n        continue;\n      }\n      mi = false;\n      if (sh == 0)\n        this[this.t++] = x;\n      else if (sh + k > this.DB)\n      {\n        this[this.t - 1] |= (x & ((1 << (this.DB - sh)) - 1)) << sh;\n        this[this.t++] = (x >> (this.DB - sh));\n      }\n      else\n        this[this.t - 1] |= x << sh;\n      sh += k;\n      if (sh >= this.DB) sh -= this.DB;\n    }\n    if (k == 8 && (s[0] & 0x80) != 0)\n    {\n      this.s = -1;\n      if (sh > 0) this[this.t - 1] |= ((1 << (this.DB - sh)) - 1) << sh;\n    }\n    this.clamp();\n    if (mi) BigInteger.ZERO.subTo(this, this);\n  }\n  // (protected) clamp off excess high words\n  function bnpClamp()\n  {\n    var c = this.s & this.DM;\n    while (this.t > 0 && this[this.t - 1] == c)--this.t;\n  }\n  // (public) return string representation in given radix\n  function bnToString(b)\n  {\n    if (this.s < 0) return \"-\" + this.negate().toString(b);\n    var k;\n    if (b == 16) k = 4;\n    else if (b == 8) k = 3;\n    else if (b == 2) k = 1;\n    else if (b == 32) k = 5;\n    else if (b == 4) k = 2;\n    else return this.toRadix(b);\n    var km = (1 << k) - 1,\n      d, m = false,\n      r = \"\",\n      i = this.t;\n    var p = this.DB - (i * this.DB) % k;\n    if (i-- > 0)\n    {\n      if (p < this.DB && (d = this[i] >> p) > 0)\n      {\n        m = true;\n        r = int2char(d);\n      }\n      while (i >= 0)\n      {\n        if (p < k)\n        {\n          d = (this[i] & ((1 << p) - 1)) << (k - p);\n          d |= this[--i] >> (p += this.DB - k);\n        }\n        else\n        {\n          d = (this[i] >> (p -= k)) & km;\n          if (p <= 0)\n          {\n            p += this.DB;\n            --i;\n          }\n        }\n        if (d > 0) m = true;\n        if (m) r += int2char(d);\n      }\n    }\n    return m ? r : \"0\";\n  }\n  // (public) -this\n  function bnNegate()\n  {\n    var r = nbi();\n    BigInteger.ZERO.subTo(this, r);\n    return r;\n  }\n  // (public) |this|\n  function bnAbs()\n  {\n    return (this.s < 0) ? this.negate() : this;\n  }\n  // (public) return + if this > a, - if this < a, 0 if equal\n  function bnCompareTo(a)\n  {\n    var r = this.s - a.s;\n    if (r != 0) return r;\n    var i = this.t;\n    r = i - a.t;\n    if (r != 0) return (this.s < 0) ? -r : r;\n    while (--i >= 0)\n      if ((r = this[i] - a[i]) != 0) return r;\n    return 0;\n  }\n  // returns bit length of the integer x\n  function nbits(x)\n  {\n    var r = 1,\n      t;\n    if ((t = x >>> 16) != 0)\n    {\n      x = t;\n      r += 16;\n    }\n    if ((t = x >> 8) != 0)\n    {\n      x = t;\n      r += 8;\n    }\n    if ((t = x >> 4) != 0)\n    {\n      x = t;\n      r += 4;\n    }\n    if ((t = x >> 2) != 0)\n    {\n      x = t;\n      r += 2;\n    }\n    if ((t = x >> 1) != 0)\n    {\n      x = t;\n      r += 1;\n    }\n    return r;\n  }\n  // (public) return the number of bits in \"this\"\n  function bnBitLength()\n  {\n    if (this.t <= 0) return 0;\n    return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ (this.s & this.DM));\n  }\n  // (protected) r = this << n*DB\n  function bnpDLShiftTo(n, r)\n  {\n    var i;\n    for (i = this.t - 1; i >= 0; --i) r[i + n] = this[i];\n    for (i = n - 1; i >= 0; --i) r[i] = 0;\n    r.t = this.t + n;\n    r.s = this.s;\n  }\n  // (protected) r = this >> n*DB\n  function bnpDRShiftTo(n, r)\n  {\n    for (var i = n; i < this.t; ++i) r[i - n] = this[i];\n    r.t = Math.max(this.t - n, 0);\n    r.s = this.s;\n  }\n  // (protected) r = this << n\n  function bnpLShiftTo(n, r)\n  {\n    var bs = n % this.DB;\n    var cbs = this.DB - bs;\n    var bm = (1 << cbs) - 1;\n    var ds = Math.floor(n / this.DB),\n      c = (this.s << bs) & this.DM,\n      i;\n    for (i = this.t - 1; i >= 0; --i)\n    {\n      r[i + ds + 1] = (this[i] >> cbs) | c;\n      c = (this[i] & bm) << bs;\n    }\n    for (i = ds - 1; i >= 0; --i) r[i] = 0;\n    r[ds] = c;\n    r.t = this.t + ds + 1;\n    r.s = this.s;\n    r.clamp();\n  }\n  // (protected) r = this >> n\n  function bnpRShiftTo(n, r)\n  {\n    r.s = this.s;\n    var ds = Math.floor(n / this.DB);\n    if (ds >= this.t)\n    {\n      r.t = 0;\n      return;\n    }\n    var bs = n % this.DB;\n    var cbs = this.DB - bs;\n    var bm = (1 << bs) - 1;\n    r[0] = this[ds] >> bs;\n    for (var i = ds + 1; i < this.t; ++i)\n    {\n      r[i - ds - 1] |= (this[i] & bm) << cbs;\n      r[i - ds] = this[i] >> bs;\n    }\n    if (bs > 0) r[this.t - ds - 1] |= (this.s & bm) << cbs;\n    r.t = this.t - ds;\n    r.clamp();\n  }\n  // (protected) r = this - a\n  function bnpSubTo(a, r)\n  {\n    var i = 0,\n      c = 0,\n      m = Math.min(a.t, this.t);\n    while (i < m)\n    {\n      c += this[i] - a[i];\n      r[i++] = c & this.DM;\n      c >>= this.DB;\n    }\n    if (a.t < this.t)\n    {\n      c -= a.s;\n      while (i < this.t)\n      {\n        c += this[i];\n        r[i++] = c & this.DM;\n        c >>= this.DB;\n      }\n      c += this.s;\n    }\n    else\n    {\n      c += this.s;\n      while (i < a.t)\n      {\n        c -= a[i];\n        r[i++] = c & this.DM;\n        c >>= this.DB;\n      }\n      c -= a.s;\n    }\n    r.s = (c < 0) ? -1 : 0;\n    if (c < -1) r[i++] = this.DV + c;\n    else if (c > 0) r[i++] = c;\n    r.t = i;\n    r.clamp();\n  }\n  // (protected) r = this * a, r != this,a (HAC 14.12)\n  // \"this\" should be the larger one if appropriate.\n  function bnpMultiplyTo(a, r)\n  {\n    var x = this.abs(),\n      y = a.abs();\n    var i = x.t;\n    r.t = i + y.t;\n    while (--i >= 0) r[i] = 0;\n    for (i = 0; i < y.t; ++i) r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);\n    r.s = 0;\n    r.clamp();\n    if (this.s != a.s) BigInteger.ZERO.subTo(r, r);\n  }\n  // (protected) r = this^2, r != this (HAC 14.16)\n  function bnpSquareTo(r)\n  {\n    var x = this.abs();\n    var i = r.t = 2 * x.t;\n    while (--i >= 0) r[i] = 0;\n    for (i = 0; i < x.t - 1; ++i)\n    {\n      var c = x.am(i, x[i], r, 2 * i, 0, 1);\n      if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV)\n      {\n        r[i + x.t] -= x.DV;\n        r[i + x.t + 1] = 1;\n      }\n    }\n    if (r.t > 0) r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);\n    r.s = 0;\n    r.clamp();\n  }\n  // (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)\n  // r != q, this != m.  q or r may be null.\n  function bnpDivRemTo(m, q, r)\n  {\n    var pm = m.abs();\n    if (pm.t <= 0) return;\n    var pt = this.abs();\n    if (pt.t < pm.t)\n    {\n      if (q != null) q.fromInt(0);\n      if (r != null) this.copyTo(r);\n      return;\n    }\n    if (r == null) r = nbi();\n    var y = nbi(),\n      ts = this.s,\n      ms = m.s;\n    var nsh = this.DB - nbits(pm[pm.t - 1]); // normalize modulus\n    if (nsh > 0)\n    {\n      pm.lShiftTo(nsh, y);\n      pt.lShiftTo(nsh, r);\n    }\n    else\n    {\n      pm.copyTo(y);\n      pt.copyTo(r);\n    }\n    var ys = y.t;\n    var y0 = y[ys - 1];\n    if (y0 == 0) return;\n    var yt = y0 * (1 << this.F1) + ((ys > 1) ? y[ys - 2] >> this.F2 : 0);\n    var d1 = this.FV / yt,\n      d2 = (1 << this.F1) / yt,\n      e = 1 << this.F2;\n    var i = r.t,\n      j = i - ys,\n      t = (q == null) ? nbi() : q;\n    y.dlShiftTo(j, t);\n    if (r.compareTo(t) >= 0)\n    {\n      r[r.t++] = 1;\n      r.subTo(t, r);\n    }\n    BigInteger.ONE.dlShiftTo(ys, t);\n    t.subTo(y, y); // \"negative\" y so we can replace sub with am later\n    while (y.t < ys) y[y.t++] = 0;\n    while (--j >= 0)\n    {\n      // Estimate quotient digit\n      var qd = (r[--i] == y0) ? this.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);\n      if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd)\n      { // Try it out\n        y.dlShiftTo(j, t);\n        r.subTo(t, r);\n        while (r[i] < --qd) r.subTo(t, r);\n      }\n    }\n    if (q != null)\n    {\n      r.drShiftTo(ys, q);\n      if (ts != ms) BigInteger.ZERO.subTo(q, q);\n    }\n    r.t = ys;\n    r.clamp();\n    if (nsh > 0) r.rShiftTo(nsh, r); // Denormalize remainder\n    if (ts < 0) BigInteger.ZERO.subTo(r, r);\n  }\n  // (public) this mod a\n  function bnMod(a)\n  {\n    var r = nbi();\n    this.abs().divRemTo(a, null, r);\n    if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r, r);\n    return r;\n  }\n  // Modular reduction using \"classic\" algorithm\n  function Classic(m)\n  {\n    this.m = m;\n  }\n\n  function cConvert(x)\n  {\n    if (x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);\n    else return x;\n  }\n\n  function cRevert(x)\n  {\n    return x;\n  }\n\n  function cReduce(x)\n  {\n    x.divRemTo(this.m, null, x);\n  }\n\n  function cMulTo(x, y, r)\n  {\n    x.multiplyTo(y, r);\n    this.reduce(r);\n  }\n\n  function cSqrTo(x, r)\n  {\n    x.squareTo(r);\n    this.reduce(r);\n  }\n  Classic.prototype.convert = cConvert;\n  Classic.prototype.revert = cRevert;\n  Classic.prototype.reduce = cReduce;\n  Classic.prototype.mulTo = cMulTo;\n  Classic.prototype.sqrTo = cSqrTo;\n  // (protected) return \"-1/this % 2^DB\"; useful for Mont. reduction\n  // justification:\n  //         xy == 1 (mod m)\n  //         xy =  1+km\n  //   xy(2-xy) = (1+km)(1-km)\n  // x[y(2-xy)] = 1-k^2m^2\n  // x[y(2-xy)] == 1 (mod m^2)\n  // if y is 1/x mod m, then y(2-xy) is 1/x mod m^2\n  // should reduce x and y(2-xy) by m^2 at each step to keep size bounded.\n  // JS multiply \"overflows\" differently from C/C++, so care is needed here.\n  function bnpInvDigit()\n  {\n    if (this.t < 1) return 0;\n    var x = this[0];\n    if ((x & 1) == 0) return 0;\n    var y = x & 3; // y == 1/x mod 2^2\n    y = (y * (2 - (x & 0xf) * y)) & 0xf; // y == 1/x mod 2^4\n    y = (y * (2 - (x & 0xff) * y)) & 0xff; // y == 1/x mod 2^8\n    y = (y * (2 - (((x & 0xffff) * y) & 0xffff))) & 0xffff; // y == 1/x mod 2^16\n    // last step - calculate inverse mod DV directly;\n    // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints\n    y = (y * (2 - x * y % this.DV)) % this.DV; // y == 1/x mod 2^dbits\n    // we really want the negative inverse, and -DV < y < DV\n    return (y > 0) ? this.DV - y : -y;\n  }\n  // Montgomery reduction\n  function Montgomery(m)\n  {\n    this.m = m;\n    this.mp = m.invDigit();\n    this.mpl = this.mp & 0x7fff;\n    this.mph = this.mp >> 15;\n    this.um = (1 << (m.DB - 15)) - 1;\n    this.mt2 = 2 * m.t;\n  }\n  // xR mod m\n  function montConvert(x)\n  {\n    var r = nbi();\n    x.abs().dlShiftTo(this.m.t, r);\n    r.divRemTo(this.m, null, r);\n    if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r, r);\n    return r;\n  }\n  // x/R mod m\n  function montRevert(x)\n  {\n    var r = nbi();\n    x.copyTo(r);\n    this.reduce(r);\n    return r;\n  }\n  // x = x/R mod m (HAC 14.32)\n  function montReduce(x)\n  {\n    while (x.t <= this.mt2) // pad x so am has enough room later\n      x[x.t++] = 0;\n    for (var i = 0; i < this.m.t; ++i)\n    {\n      // faster way of calculating u0 = x[i]*mp mod DV\n      var j = x[i] & 0x7fff;\n      var u0 = (j * this.mpl + (((j * this.mph + (x[i] >> 15) * this.mpl) & this.um) << 15)) & x.DM;\n      // use am to combine the multiply-shift-add into one call\n      j = i + this.m.t;\n      x[j] += this.m.am(0, u0, x, i, 0, this.m.t);\n      // propagate carry\n      while (x[j] >= x.DV)\n      {\n        x[j] -= x.DV;\n        x[++j]++;\n      }\n    }\n    x.clamp();\n    x.drShiftTo(this.m.t, x);\n    if (x.compareTo(this.m) >= 0) x.subTo(this.m, x);\n  }\n  // r = \"x^2/R mod m\"; x != r\n  function montSqrTo(x, r)\n  {\n    x.squareTo(r);\n    this.reduce(r);\n  }\n  // r = \"xy/R mod m\"; x,y != r\n  function montMulTo(x, y, r)\n  {\n    x.multiplyTo(y, r);\n    this.reduce(r);\n  }\n  Montgomery.prototype.convert = montConvert;\n  Montgomery.prototype.revert = montRevert;\n  Montgomery.prototype.reduce = montReduce;\n  Montgomery.prototype.mulTo = montMulTo;\n  Montgomery.prototype.sqrTo = montSqrTo;\n  // (protected) true iff this is even\n  function bnpIsEven()\n  {\n    return ((this.t > 0) ? (this[0] & 1) : this.s) == 0;\n  }\n  // (protected) this^e, e < 2^32, doing sqr and mul with \"r\" (HAC 14.79)\n  function bnpExp(e, z)\n  {\n    if (e > 0xffffffff || e < 1) return BigInteger.ONE;\n    var r = nbi(),\n      r2 = nbi(),\n      g = z.convert(this),\n      i = nbits(e) - 1;\n    g.copyTo(r);\n    while (--i >= 0)\n    {\n      z.sqrTo(r, r2);\n      if ((e & (1 << i)) > 0) z.mulTo(r2, g, r);\n      else\n      {\n        var t = r;\n        r = r2;\n        r2 = t;\n      }\n    }\n    return z.revert(r);\n  }\n  // (public) this^e % m, 0 <= e < 2^32\n  function bnModPowInt(e, m)\n  {\n    var z;\n    if (e < 256 || m.isEven()) z = new Classic(m);\n    else z = new Montgomery(m);\n    return this.exp(e, z);\n  }\n  // protected\n  BigInteger.prototype.copyTo = bnpCopyTo;\n  BigInteger.prototype.fromInt = bnpFromInt;\n  BigInteger.prototype.fromString = bnpFromString;\n  BigInteger.prototype.clamp = bnpClamp;\n  BigInteger.prototype.dlShiftTo = bnpDLShiftTo;\n  BigInteger.prototype.drShiftTo = bnpDRShiftTo;\n  BigInteger.prototype.lShiftTo = bnpLShiftTo;\n  BigInteger.prototype.rShiftTo = bnpRShiftTo;\n  BigInteger.prototype.subTo = bnpSubTo;\n  BigInteger.prototype.multiplyTo = bnpMultiplyTo;\n  BigInteger.prototype.squareTo = bnpSquareTo;\n  BigInteger.prototype.divRemTo = bnpDivRemTo;\n  BigInteger.prototype.invDigit = bnpInvDigit;\n  BigInteger.prototype.isEven = bnpIsEven;\n  BigInteger.prototype.exp = bnpExp;\n  // public\n  BigInteger.prototype.toString = bnToString;\n  BigInteger.prototype.negate = bnNegate;\n  BigInteger.prototype.abs = bnAbs;\n  BigInteger.prototype.compareTo = bnCompareTo;\n  BigInteger.prototype.bitLength = bnBitLength;\n  BigInteger.prototype.mod = bnMod;\n  BigInteger.prototype.modPowInt = bnModPowInt;\n  // \"constants\"\n  BigInteger.ZERO = nbv(0);\n  BigInteger.ONE = nbv(1);\n  // Copyright (c) 2005-2009  Tom Wu\n  // All Rights Reserved.\n  // See \"LICENSE\" for details.\n  // Extended JavaScript BN functions, required for RSA private ops.\n  // Version 1.1: new BigInteger(\"0\", 10) returns \"proper\" zero\n  // Version 1.2: square() API, isProbablePrime fix\n  // (public)\n  function bnClone()\n  {\n    var r = nbi();\n    this.copyTo(r);\n    return r;\n  }\n  // (public) return value as integer\n  function bnIntValue()\n  {\n    if (this.s < 0)\n    {\n      if (this.t == 1) return this[0] - this.DV;\n      else if (this.t == 0) return -1;\n    }\n    else if (this.t == 1) return this[0];\n    else if (this.t == 0) return 0;\n    // assumes 16 < DB < 32\n    return ((this[1] & ((1 << (32 - this.DB)) - 1)) << this.DB) | this[0];\n  }\n  // (public) return value as byte\n  function bnByteValue()\n  {\n    return (this.t == 0) ? this.s : (this[0] << 24) >> 24;\n  }\n  // (public) return value as short (assumes DB>=16)\n  function bnShortValue()\n  {\n    return (this.t == 0) ? this.s : (this[0] << 16) >> 16;\n  }\n  // (protected) return x s.t. r^x < DV\n  function bnpChunkSize(r)\n  {\n    return Math.floor(Math.LN2 * this.DB / Math.log(r));\n  }\n  // (public) 0 if this == 0, 1 if this > 0\n  function bnSigNum()\n  {\n    if (this.s < 0) return -1;\n    else if (this.t <= 0 || (this.t == 1 && this[0] <= 0)) return 0;\n    else return 1;\n  }\n  // (protected) convert to radix string\n  function bnpToRadix(b)\n  {\n    if (b == null) b = 10;\n    if (this.signum() == 0 || b < 2 || b > 36) return \"0\";\n    var cs = this.chunkSize(b);\n    var a = Math.pow(b, cs);\n    var d = nbv(a),\n      y = nbi(),\n      z = nbi(),\n      r = \"\";\n    this.divRemTo(d, y, z);\n    while (y.signum() > 0)\n    {\n      r = (a + z.intValue()).toString(b).substr(1) + r;\n      y.divRemTo(d, y, z);\n    }\n    return z.intValue().toString(b) + r;\n  }\n  // (protected) convert from radix string\n  function bnpFromRadix(s, b)\n  {\n    this.fromInt(0);\n    if (b == null) b = 10;\n    var cs = this.chunkSize(b);\n    var d = Math.pow(b, cs),\n      mi = false,\n      j = 0,\n      w = 0;\n    for (var i = 0; i < s.length; ++i)\n    {\n      var x = intAt(s, i);\n      if (x < 0)\n      {\n        if (s.charAt(i) == \"-\" && this.signum() == 0) mi = true;\n        continue;\n      }\n      w = b * w + x;\n      if (++j >= cs)\n      {\n        this.dMultiply(d);\n        this.dAddOffset(w, 0);\n        j = 0;\n        w = 0;\n      }\n    }\n    if (j > 0)\n    {\n      this.dMultiply(Math.pow(b, j));\n      this.dAddOffset(w, 0);\n    }\n    if (mi) BigInteger.ZERO.subTo(this, this);\n  }\n  // (protected) alternate constructor\n  function bnpFromNumber(a, b, c)\n  {\n    if (\"number\" == typeof b)\n    {\n      // new BigInteger(int,int,RNG)\n      if (a < 2) this.fromInt(1);\n      else\n      {\n        this.fromNumber(a, c);\n        if (!this.testBit(a - 1)) // force MSB set\n          this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);\n        if (this.isEven()) this.dAddOffset(1, 0); // force odd\n        while (!this.isProbablePrime(b))\n        {\n          this.dAddOffset(2, 0);\n          if (this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);\n        }\n      }\n    }\n    else\n    {\n      // new BigInteger(int,RNG)\n      var x = new Array(),\n        t = a & 7;\n      x.length = (a >> 3) + 1;\n      b.nextBytes(x);\n      if (t > 0) x[0] &= ((1 << t) - 1);\n      else x[0] = 0;\n      this.fromString(x, 256);\n    }\n  }\n  // (public) convert to bigendian byte array\n  function bnToByteArray()\n  {\n    var i = this.t,\n      r = new Array();\n    r[0] = this.s;\n    var p = this.DB - (i * this.DB) % 8,\n      d, k = 0;\n    if (i-- > 0)\n    {\n      if (p < this.DB && (d = this[i] >> p) != (this.s & this.DM) >> p)\n        r[k++] = d | (this.s << (this.DB - p));\n      while (i >= 0)\n      {\n        if (p < 8)\n        {\n          d = (this[i] & ((1 << p) - 1)) << (8 - p);\n          d |= this[--i] >> (p += this.DB - 8);\n        }\n        else\n        {\n          d = (this[i] >> (p -= 8)) & 0xff;\n          if (p <= 0)\n          {\n            p += this.DB;\n            --i;\n          }\n        }\n        if ((d & 0x80) != 0) d |= -256;\n        if (k == 0 && (this.s & 0x80) != (d & 0x80))++k;\n        if (k > 0 || d != this.s) r[k++] = d;\n      }\n    }\n    return r;\n  }\n\n  function bnEquals(a)\n  {\n    return (this.compareTo(a) == 0);\n  }\n\n  function bnMin(a)\n  {\n    return (this.compareTo(a) < 0) ? this : a;\n  }\n\n  function bnMax(a)\n  {\n    return (this.compareTo(a) > 0) ? this : a;\n  }\n  // (protected) r = this op a (bitwise)\n  function bnpBitwiseTo(a, op, r)\n  {\n    var i, f, m = Math.min(a.t, this.t);\n    for (i = 0; i < m; ++i) r[i] = op(this[i], a[i]);\n    if (a.t < this.t)\n    {\n      f = a.s & this.DM;\n      for (i = m; i < this.t; ++i) r[i] = op(this[i], f);\n      r.t = this.t;\n    }\n    else\n    {\n      f = this.s & this.DM;\n      for (i = m; i < a.t; ++i) r[i] = op(f, a[i]);\n      r.t = a.t;\n    }\n    r.s = op(this.s, a.s);\n    r.clamp();\n  }\n  // (public) this & a\n  function op_and(x, y)\n  {\n    return x & y;\n  }\n\n  function bnAnd(a)\n  {\n    var r = nbi();\n    this.bitwiseTo(a, op_and, r);\n    return r;\n  }\n  // (public) this | a\n  function op_or(x, y)\n  {\n    return x | y;\n  }\n\n  function bnOr(a)\n  {\n    var r = nbi();\n    this.bitwiseTo(a, op_or, r);\n    return r;\n  }\n  // (public) this ^ a\n  function op_xor(x, y)\n  {\n    return x ^ y;\n  }\n\n  function bnXor(a)\n  {\n    var r = nbi();\n    this.bitwiseTo(a, op_xor, r);\n    return r;\n  }\n  // (public) this & ~a\n  function op_andnot(x, y)\n  {\n    return x & ~y;\n  }\n\n  function bnAndNot(a)\n  {\n    var r = nbi();\n    this.bitwiseTo(a, op_andnot, r);\n    return r;\n  }\n  // (public) ~this\n  function bnNot()\n  {\n    var r = nbi();\n    for (var i = 0; i < this.t; ++i) r[i] = this.DM & ~this[i];\n    r.t = this.t;\n    r.s = ~this.s;\n    return r;\n  }\n  // (public) this << n\n  function bnShiftLeft(n)\n  {\n    var r = nbi();\n    if (n < 0) this.rShiftTo(-n, r);\n    else this.lShiftTo(n, r);\n    return r;\n  }\n  // (public) this >> n\n  function bnShiftRight(n)\n  {\n    var r = nbi();\n    if (n < 0) this.lShiftTo(-n, r);\n    else this.rShiftTo(n, r);\n    return r;\n  }\n  // return index of lowest 1-bit in x, x < 2^31\n  function lbit(x)\n  {\n    if (x == 0) return -1;\n    var r = 0;\n    if ((x & 0xffff) == 0)\n    {\n      x >>= 16;\n      r += 16;\n    }\n    if ((x & 0xff) == 0)\n    {\n      x >>= 8;\n      r += 8;\n    }\n    if ((x & 0xf) == 0)\n    {\n      x >>= 4;\n      r += 4;\n    }\n    if ((x & 3) == 0)\n    {\n      x >>= 2;\n      r += 2;\n    }\n    if ((x & 1) == 0)++r;\n    return r;\n  }\n  // (public) returns index of lowest 1-bit (or -1 if none)\n  function bnGetLowestSetBit()\n  {\n    for (var i = 0; i < this.t; ++i)\n      if (this[i] != 0) return i * this.DB + lbit(this[i]);\n    if (this.s < 0) return this.t * this.DB;\n    return -1;\n  }\n  // return number of 1 bits in x\n  function cbit(x)\n  {\n    var r = 0;\n    while (x != 0)\n    {\n      x &= x - 1;\n      ++r;\n    }\n    return r;\n  }\n  // (public) return number of set bits\n  function bnBitCount()\n  {\n    var r = 0,\n      x = this.s & this.DM;\n    for (var i = 0; i < this.t; ++i) r += cbit(this[i] ^ x);\n    return r;\n  }\n  // (public) true iff nth bit is set\n  function bnTestBit(n)\n  {\n    var j = Math.floor(n / this.DB);\n    if (j >= this.t) return (this.s != 0);\n    return ((this[j] & (1 << (n % this.DB))) != 0);\n  }\n  // (protected) this op (1<<n)\n  function bnpChangeBit(n, op)\n  {\n    var r = BigInteger.ONE.shiftLeft(n);\n    this.bitwiseTo(r, op, r);\n    return r;\n  }\n  // (public) this | (1<<n)\n  function bnSetBit(n)\n  {\n    return this.changeBit(n, op_or);\n  }\n  // (public) this & ~(1<<n)\n  function bnClearBit(n)\n  {\n    return this.changeBit(n, op_andnot);\n  }\n  // (public) this ^ (1<<n)\n  function bnFlipBit(n)\n  {\n    return this.changeBit(n, op_xor);\n  }\n  // (protected) r = this + a\n  function bnpAddTo(a, r)\n  {\n    var i = 0,\n      c = 0,\n      m = Math.min(a.t, this.t);\n    while (i < m)\n    {\n      c += this[i] + a[i];\n      r[i++] = c & this.DM;\n      c >>= this.DB;\n    }\n    if (a.t < this.t)\n    {\n      c += a.s;\n      while (i < this.t)\n      {\n        c += this[i];\n        r[i++] = c & this.DM;\n        c >>= this.DB;\n      }\n      c += this.s;\n    }\n    else\n    {\n      c += this.s;\n      while (i < a.t)\n      {\n        c += a[i];\n        r[i++] = c & this.DM;\n        c >>= this.DB;\n      }\n      c += a.s;\n    }\n    r.s = (c < 0) ? -1 : 0;\n    if (c > 0) r[i++] = c;\n    else if (c < -1) r[i++] = this.DV + c;\n    r.t = i;\n    r.clamp();\n  }\n  // (public) this + a\n  function bnAdd(a)\n  {\n    var r = nbi();\n    this.addTo(a, r);\n    return r;\n  }\n  // (public) this - a\n  function bnSubtract(a)\n  {\n    var r = nbi();\n    this.subTo(a, r);\n    return r;\n  }\n  // (public) this * a\n  function bnMultiply(a)\n  {\n    var r = nbi();\n    this.multiplyTo(a, r);\n    return r;\n  }\n  // (public) this^2\n  function bnSquare()\n  {\n    var r = nbi();\n    this.squareTo(r);\n    return r;\n  }\n  // (public) this / a\n  function bnDivide(a)\n  {\n    var r = nbi();\n    this.divRemTo(a, r, null);\n    return r;\n  }\n  // (public) this % a\n  function bnRemainder(a)\n  {\n    var r = nbi();\n    this.divRemTo(a, null, r);\n    return r;\n  }\n  // (public) [this/a,this%a]\n  function bnDivideAndRemainder(a)\n  {\n    var q = nbi(),\n      r = nbi();\n    this.divRemTo(a, q, r);\n    return new Array(q, r);\n  }\n  // (protected) this *= n, this >= 0, 1 < n < DV\n  function bnpDMultiply(n)\n  {\n    this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);\n    ++this.t;\n    this.clamp();\n  }\n  // (protected) this += n << w words, this >= 0\n  function bnpDAddOffset(n, w)\n  {\n    if (n == 0) return;\n    while (this.t <= w) this[this.t++] = 0;\n    this[w] += n;\n    while (this[w] >= this.DV)\n    {\n      this[w] -= this.DV;\n      if (++w >= this.t) this[this.t++] = 0;\n      ++this[w];\n    }\n  }\n  // A \"null\" reducer\n  function NullExp()\n  {}\n\n  function nNop(x)\n  {\n    return x;\n  }\n\n  function nMulTo(x, y, r)\n  {\n    x.multiplyTo(y, r);\n  }\n\n  function nSqrTo(x, r)\n  {\n    x.squareTo(r);\n  }\n  NullExp.prototype.convert = nNop;\n  NullExp.prototype.revert = nNop;\n  NullExp.prototype.mulTo = nMulTo;\n  NullExp.prototype.sqrTo = nSqrTo;\n  // (public) this^e\n  function bnPow(e)\n  {\n    return this.exp(e, new NullExp());\n  }\n  // (protected) r = lower n words of \"this * a\", a.t <= n\n  // \"this\" should be the larger one if appropriate.\n  function bnpMultiplyLowerTo(a, n, r)\n  {\n    var i = Math.min(this.t + a.t, n);\n    r.s = 0; // assumes a,this >= 0\n    r.t = i;\n    while (i > 0) r[--i] = 0;\n    var j;\n    for (j = r.t - this.t; i < j; ++i) r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);\n    for (j = Math.min(a.t, n); i < j; ++i) this.am(0, a[i], r, i, 0, n - i);\n    r.clamp();\n  }\n  // (protected) r = \"this * a\" without lower n words, n > 0\n  // \"this\" should be the larger one if appropriate.\n  function bnpMultiplyUpperTo(a, n, r)\n  {\n    --n;\n    var i = r.t = this.t + a.t - n;\n    r.s = 0; // assumes a,this >= 0\n    while (--i >= 0) r[i] = 0;\n    for (i = Math.max(n - this.t, 0); i < a.t; ++i)\n      r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n);\n    r.clamp();\n    r.drShiftTo(1, r);\n  }\n  // Barrett modular reduction\n  function Barrett(m)\n  {\n    // setup Barrett\n    this.r2 = nbi();\n    this.q3 = nbi();\n    BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);\n    this.mu = this.r2.divide(m);\n    this.m = m;\n  }\n\n  function barrettConvert(x)\n  {\n    if (x.s < 0 || x.t > 2 * this.m.t) return x.mod(this.m);\n    else if (x.compareTo(this.m) < 0) return x;\n    else\n    {\n      var r = nbi();\n      x.copyTo(r);\n      this.reduce(r);\n      return r;\n    }\n  }\n\n  function barrettRevert(x)\n  {\n    return x;\n  }\n  // x = x mod m (HAC 14.42)\n  function barrettReduce(x)\n  {\n    x.drShiftTo(this.m.t - 1, this.r2);\n    if (x.t > this.m.t + 1)\n    {\n      x.t = this.m.t + 1;\n      x.clamp();\n    }\n    this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);\n    this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);\n    while (x.compareTo(this.r2) < 0) x.dAddOffset(1, this.m.t + 1);\n    x.subTo(this.r2, x);\n    while (x.compareTo(this.m) >= 0) x.subTo(this.m, x);\n  }\n  // r = x^2 mod m; x != r\n  function barrettSqrTo(x, r)\n  {\n    x.squareTo(r);\n    this.reduce(r);\n  }\n  // r = x*y mod m; x,y != r\n  function barrettMulTo(x, y, r)\n  {\n    x.multiplyTo(y, r);\n    this.reduce(r);\n  }\n  Barrett.prototype.convert = barrettConvert;\n  Barrett.prototype.revert = barrettRevert;\n  Barrett.prototype.reduce = barrettReduce;\n  Barrett.prototype.mulTo = barrettMulTo;\n  Barrett.prototype.sqrTo = barrettSqrTo;\n  // (public) this^e % m (HAC 14.85)\n  function bnModPow(e, m)\n  {\n    var i = e.bitLength(),\n      k, r = nbv(1),\n      z;\n    if (i <= 0) return r;\n    else if (i < 18) k = 1;\n    else if (i < 48) k = 3;\n    else if (i < 144) k = 4;\n    else if (i < 768) k = 5;\n    else k = 6;\n    if (i < 8)\n      z = new Classic(m);\n    else if (m.isEven())\n      z = new Barrett(m);\n    else\n      z = new Montgomery(m);\n    // precomputation\n    var g = new Array(),\n      n = 3,\n      k1 = k - 1,\n      km = (1 << k) - 1;\n    g[1] = z.convert(this);\n    if (k > 1)\n    {\n      var g2 = nbi();\n      z.sqrTo(g[1], g2);\n      while (n <= km)\n      {\n        g[n] = nbi();\n        z.mulTo(g2, g[n - 2], g[n]);\n        n += 2;\n      }\n    }\n    var j = e.t - 1,\n      w, is1 = true,\n      r2 = nbi(),\n      t;\n    i = nbits(e[j]) - 1;\n    while (j >= 0)\n    {\n      if (i >= k1) w = (e[j] >> (i - k1)) & km;\n      else\n      {\n        w = (e[j] & ((1 << (i + 1)) - 1)) << (k1 - i);\n        if (j > 0) w |= e[j - 1] >> (this.DB + i - k1);\n      }\n      n = k;\n      while ((w & 1) == 0)\n      {\n        w >>= 1;\n        --n;\n      }\n      if ((i -= n) < 0)\n      {\n        i += this.DB;\n        --j;\n      }\n      if (is1)\n      { // ret == 1, don't bother squaring or multiplying it\n        g[w].copyTo(r);\n        is1 = false;\n      }\n      else\n      {\n        while (n > 1)\n        {\n          z.sqrTo(r, r2);\n          z.sqrTo(r2, r);\n          n -= 2;\n        }\n        if (n > 0) z.sqrTo(r, r2);\n        else\n        {\n          t = r;\n          r = r2;\n          r2 = t;\n        }\n        z.mulTo(r2, g[w], r);\n      }\n      while (j >= 0 && (e[j] & (1 << i)) == 0)\n      {\n        z.sqrTo(r, r2);\n        t = r;\n        r = r2;\n        r2 = t;\n        if (--i < 0)\n        {\n          i = this.DB - 1;\n          --j;\n        }\n      }\n    }\n    return z.revert(r);\n  }\n  // (public) gcd(this,a) (HAC 14.54)\n  function bnGCD(a)\n  {\n    var x = (this.s < 0) ? this.negate() : this.clone();\n    var y = (a.s < 0) ? a.negate() : a.clone();\n    if (x.compareTo(y) < 0)\n    {\n      var t = x;\n      x = y;\n      y = t;\n    }\n    var i = x.getLowestSetBit(),\n      g = y.getLowestSetBit();\n    if (g < 0) return x;\n    if (i < g) g = i;\n    if (g > 0)\n    {\n      x.rShiftTo(g, x);\n      y.rShiftTo(g, y);\n    }\n    while (x.signum() > 0)\n    {\n      if ((i = x.getLowestSetBit()) > 0) x.rShiftTo(i, x);\n      if ((i = y.getLowestSetBit()) > 0) y.rShiftTo(i, y);\n      if (x.compareTo(y) >= 0)\n      {\n        x.subTo(y, x);\n        x.rShiftTo(1, x);\n      }\n      else\n      {\n        y.subTo(x, y);\n        y.rShiftTo(1, y);\n      }\n    }\n    if (g > 0) y.lShiftTo(g, y);\n    return y;\n  }\n  // (protected) this % n, n < 2^26\n  function bnpModInt(n)\n  {\n    if (n <= 0) return 0;\n    var d = this.DV % n,\n      r = (this.s < 0) ? n - 1 : 0;\n    if (this.t > 0)\n      if (d == 0) r = this[0] % n;\n      else\n        for (var i = this.t - 1; i >= 0; --i) r = (d * r + this[i]) % n;\n    return r;\n  }\n  // (public) 1/this % m (HAC 14.61)\n  function bnModInverse(m)\n  {\n    var ac = m.isEven();\n    if ((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO;\n    var u = m.clone(),\n      v = this.clone();\n    var a = nbv(1),\n      b = nbv(0),\n      c = nbv(0),\n      d = nbv(1);\n    while (u.signum() != 0)\n    {\n      while (u.isEven())\n      {\n        u.rShiftTo(1, u);\n        if (ac)\n        {\n          if (!a.isEven() || !b.isEven())\n          {\n            a.addTo(this, a);\n            b.subTo(m, b);\n          }\n          a.rShiftTo(1, a);\n        }\n        else if (!b.isEven()) b.subTo(m, b);\n        b.rShiftTo(1, b);\n      }\n      while (v.isEven())\n      {\n        v.rShiftTo(1, v);\n        if (ac)\n        {\n          if (!c.isEven() || !d.isEven())\n          {\n            c.addTo(this, c);\n            d.subTo(m, d);\n          }\n          c.rShiftTo(1, c);\n        }\n        else if (!d.isEven()) d.subTo(m, d);\n        d.rShiftTo(1, d);\n      }\n      if (u.compareTo(v) >= 0)\n      {\n        u.subTo(v, u);\n        if (ac) a.subTo(c, a);\n        b.subTo(d, b);\n      }\n      else\n      {\n        v.subTo(u, v);\n        if (ac) c.subTo(a, c);\n        d.subTo(b, d);\n      }\n    }\n    if (v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;\n    if (d.compareTo(m) >= 0) return d.subtract(m);\n    if (d.signum() < 0) d.addTo(m, d);\n    else return d;\n    if (d.signum() < 0) return d.add(m);\n    else return d;\n  }\n  var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];\n  var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];\n  // (public) test primality with certainty >= 1-.5^t\n  function bnIsProbablePrime(t)\n  {\n    var i, x = this.abs();\n    if (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1])\n    {\n      for (i = 0; i < lowprimes.length; ++i)\n        if (x[0] == lowprimes[i]) return true;\n      return false;\n    }\n    if (x.isEven()) return false;\n    i = 1;\n    while (i < lowprimes.length)\n    {\n      var m = lowprimes[i],\n        j = i + 1;\n      while (j < lowprimes.length && m < lplim) m *= lowprimes[j++];\n      m = x.modInt(m);\n      while (i < j)\n        if (m % lowprimes[i++] == 0) return false;\n    }\n    return x.millerRabin(t);\n  }\n  // (protected) true if probably prime (HAC 4.24, Miller-Rabin)\n  function bnpMillerRabin(t)\n  {\n    var n1 = this.subtract(BigInteger.ONE);\n    var k = n1.getLowestSetBit();\n    if (k <= 0) return false;\n    var r = n1.shiftRight(k);\n    t = (t + 1) >> 1;\n    if (t > lowprimes.length) t = lowprimes.length;\n    var a = nbi();\n    for (var i = 0; i < t; ++i)\n    {\n      //Pick bases at random, instead of starting at 2\n      a.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);\n      var y = a.modPow(r, this);\n      if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0)\n      {\n        var j = 1;\n        while (j++ < k && y.compareTo(n1) != 0)\n        {\n          y = y.modPowInt(2, this);\n          if (y.compareTo(BigInteger.ONE) == 0) return false;\n        }\n        if (y.compareTo(n1) != 0) return false;\n      }\n    }\n    return true;\n  }\n  // protected\n  BigInteger.prototype.chunkSize = bnpChunkSize;\n  BigInteger.prototype.toRadix = bnpToRadix;\n  BigInteger.prototype.fromRadix = bnpFromRadix;\n  BigInteger.prototype.fromNumber = bnpFromNumber;\n  BigInteger.prototype.bitwiseTo = bnpBitwiseTo;\n  BigInteger.prototype.changeBit = bnpChangeBit;\n  BigInteger.prototype.addTo = bnpAddTo;\n  BigInteger.prototype.dMultiply = bnpDMultiply;\n  BigInteger.prototype.dAddOffset = bnpDAddOffset;\n  BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;\n  BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;\n  BigInteger.prototype.modInt = bnpModInt;\n  BigInteger.prototype.millerRabin = bnpMillerRabin;\n  // public\n  BigInteger.prototype.clone = bnClone;\n  BigInteger.prototype.intValue = bnIntValue;\n  BigInteger.prototype.byteValue = bnByteValue;\n  BigInteger.prototype.shortValue = bnShortValue;\n  BigInteger.prototype.signum = bnSigNum;\n  BigInteger.prototype.toByteArray = bnToByteArray;\n  BigInteger.prototype.equals = bnEquals;\n  BigInteger.prototype.min = bnMin;\n  BigInteger.prototype.max = bnMax;\n  BigInteger.prototype.and = bnAnd;\n  BigInteger.prototype.or = bnOr;\n  BigInteger.prototype.xor = bnXor;\n  BigInteger.prototype.andNot = bnAndNot;\n  BigInteger.prototype.not = bnNot;\n  BigInteger.prototype.shiftLeft = bnShiftLeft;\n  BigInteger.prototype.shiftRight = bnShiftRight;\n  BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;\n  BigInteger.prototype.bitCount = bnBitCount;\n  BigInteger.prototype.testBit = bnTestBit;\n  BigInteger.prototype.setBit = bnSetBit;\n  BigInteger.prototype.clearBit = bnClearBit;\n  BigInteger.prototype.flipBit = bnFlipBit;\n  BigInteger.prototype.add = bnAdd;\n  BigInteger.prototype.subtract = bnSubtract;\n  BigInteger.prototype.multiply = bnMultiply;\n  BigInteger.prototype.divide = bnDivide;\n  BigInteger.prototype.remainder = bnRemainder;\n  BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;\n  BigInteger.prototype.modPow = bnModPow;\n  BigInteger.prototype.modInverse = bnModInverse;\n  BigInteger.prototype.pow = bnPow;\n  BigInteger.prototype.gcd = bnGCD;\n  BigInteger.prototype.isProbablePrime = bnIsProbablePrime;\n  // JSBN-specific extension\n  BigInteger.prototype.square = bnSquare;\n  var Int128 = BigInteger;\n  // BigInteger interfaces not implemented in jsbn:\n  // BigInteger(int signum, byte[] magnitude)\n  // double doubleValue()\n  // float floatValue()\n  // int hashCode()\n  // long longValue()\n  // static BigInteger valueOf(long val)\n  // Helper functions to make BigInteger functions callable with two parameters\n  // as in original C# Clipper\n  Int128.prototype.IsNegative = function ()\n  {\n    if (this.compareTo(Int128.ZERO) == -1) return true;\n    else return false;\n  };\n  Int128.op_Equality = function (val1, val2)\n  {\n    if (val1.compareTo(val2) == 0) return true;\n    else return false;\n  };\n  Int128.op_Inequality = function (val1, val2)\n  {\n    if (val1.compareTo(val2) != 0) return true;\n    else return false;\n  };\n  Int128.op_GreaterThan = function (val1, val2)\n  {\n    if (val1.compareTo(val2) > 0) return true;\n    else return false;\n  };\n  Int128.op_LessThan = function (val1, val2)\n  {\n    if (val1.compareTo(val2) < 0) return true;\n    else return false;\n  };\n  Int128.op_Addition = function (lhs, rhs)\n  {\n    return new Int128(lhs).add(new Int128(rhs));\n  };\n  Int128.op_Subtraction = function (lhs, rhs)\n  {\n    return new Int128(lhs).subtract(new Int128(rhs));\n  };\n  Int128.Int128Mul = function (lhs, rhs)\n  {\n    return new Int128(lhs).multiply(new Int128(rhs));\n  };\n  Int128.op_Division = function (lhs, rhs)\n  {\n    return lhs.divide(rhs);\n  };\n  Int128.prototype.ToDouble = function ()\n  {\n    return parseFloat(this.toString()); // This could be something faster\n  };\n  // end of Int128 section\n  /*\n  // Uncomment the following two lines if you want to use Int128 outside ClipperLib\n  if (typeof(document) !== \"undefined\") window.Int128 = Int128;\n  else self.Int128 = Int128;\n  */\n\n\n  // ---------------------------------------------\n  // Here starts the actual Clipper library:\n  // Helper function to support Inheritance in Javascript\n\tvar Inherit = function (ce, ce2)\n\t{\n\t\tvar p;\n\t\tif (typeof (Object.getOwnPropertyNames) == 'undefined')\n\t\t{\n\t\t\tfor (p in ce2.prototype)\n\t\t\t\tif (typeof (ce.prototype[p]) == 'undefined' || ce.prototype[p] == Object.prototype[p]) ce.prototype[p] = ce2.prototype[p];\n\t\t\tfor (p in ce2)\n\t\t\t\tif (typeof (ce[p]) == 'undefined') ce[p] = ce2[p];\n\t\t\tce.$baseCtor = ce2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar props = Object.getOwnPropertyNames(ce2.prototype);\n\t\t\tfor (var i = 0; i < props.length; i++)\n\t\t\t\tif (typeof (Object.getOwnPropertyDescriptor(ce.prototype, props[i])) == 'undefined') Object.defineProperty(ce.prototype, props[i], Object.getOwnPropertyDescriptor(ce2.prototype, props[i]));\n\t\t\tfor (p in ce2)\n\t\t\t\tif (typeof (ce[p]) == 'undefined') ce[p] = ce2[p];\n\t\t\tce.$baseCtor = ce2;\n\t\t}\n\t};\n  ClipperLib.Path = function ()\n  {\n    return [];\n  };\n  ClipperLib.Paths = function ()\n  {\n    return []; // Was previously [[]], but caused problems when pushed\n  };\n  // Preserves the calling way of original C# Clipper\n  // Is essential due to compatibility, because DoublePoint is public class in original C# version\n  ClipperLib.DoublePoint = function ()\n  {\n    var a = arguments;\n    this.X = 0;\n    this.Y = 0;\n    // public DoublePoint(DoublePoint dp)\n    // public DoublePoint(IntPoint ip)\n    if (a.length == 1)\n    {\n      this.X = a[0].X;\n      this.Y = a[0].Y;\n    }\n    else if (a.length == 2)\n    {\n      this.X = a[0];\n      this.Y = a[1];\n    }\n  }; // This is internal faster function when called without arguments\n  ClipperLib.DoublePoint0 = function ()\n  {\n    this.X = 0;\n    this.Y = 0;\n  };\n  // This is internal faster function when called with 1 argument (dp or ip)\n  ClipperLib.DoublePoint1 = function (dp)\n  {\n    this.X = dp.X;\n    this.Y = dp.Y;\n  };\n  // This is internal faster function when called with 2 arguments (x and y)\n  ClipperLib.DoublePoint2 = function (x, y)\n  {\n    this.X = x;\n    this.Y = y;\n  };\n  // PolyTree & PolyNode start\n  // -------------------------------\n  ClipperLib.PolyNode = function ()\n  {\n    this.m_Parent = null;\n    this.m_polygon = new ClipperLib.Path();\n    this.m_Index = 0;\n    this.m_jointype = 0;\n    this.m_endtype = 0;\n    this.m_Childs = [];\n    this.IsOpen = false;\n  };\n  ClipperLib.PolyNode.prototype.IsHoleNode = function ()\n  {\n    var result = true;\n    var node = this.m_Parent;\n    while (node !== null)\n    {\n      result = !result;\n      node = node.m_Parent;\n    }\n    return result;\n  };\n  ClipperLib.PolyNode.prototype.ChildCount = function ()\n  {\n    return this.m_Childs.length;\n  };\n  ClipperLib.PolyNode.prototype.Contour = function ()\n  {\n    return this.m_polygon;\n  };\n  ClipperLib.PolyNode.prototype.AddChild = function (Child)\n  {\n    var cnt = this.m_Childs.length;\n    this.m_Childs.push(Child);\n    Child.m_Parent = this;\n    Child.m_Index = cnt;\n  };\n  ClipperLib.PolyNode.prototype.GetNext = function ()\n  {\n    if (this.m_Childs.length > 0)\n      return this.m_Childs[0];\n    else\n      return this.GetNextSiblingUp();\n  };\n  ClipperLib.PolyNode.prototype.GetNextSiblingUp = function ()\n  {\n    if (this.m_Parent === null)\n      return null;\n    else if (this.m_Index == this.m_Parent.m_Childs.length - 1)\n      return this.m_Parent.GetNextSiblingUp();\n    else\n      return this.m_Parent.m_Childs[this.m_Index + 1];\n  };\n  ClipperLib.PolyNode.prototype.Childs = function ()\n  {\n    return this.m_Childs;\n  };\n  ClipperLib.PolyNode.prototype.Parent = function ()\n  {\n    return this.m_Parent;\n  };\n  ClipperLib.PolyNode.prototype.IsHole = function ()\n  {\n    return this.IsHoleNode();\n  };\n  // PolyTree : PolyNode\n  ClipperLib.PolyTree = function ()\n  {\n    this.m_AllPolys = [];\n    ClipperLib.PolyNode.call(this);\n  };\n  ClipperLib.PolyTree.prototype.Clear = function ()\n  {\n    for (var i = 0, ilen = this.m_AllPolys.length; i < ilen; i++)\n      this.m_AllPolys[i] = null;\n    this.m_AllPolys.length = 0;\n    this.m_Childs.length = 0;\n  };\n  ClipperLib.PolyTree.prototype.GetFirst = function ()\n  {\n    if (this.m_Childs.length > 0)\n      return this.m_Childs[0];\n    else\n      return null;\n  };\n  ClipperLib.PolyTree.prototype.Total = function ()\n  {\n\t\tvar result = this.m_AllPolys.length;\n\t\t//with negative offsets, ignore the hidden outer polygon ...\n\t\tif (result > 0 && this.m_Childs[0] != this.m_AllPolys[0]) result--;\n\t\treturn result;\n  };\n  Inherit(ClipperLib.PolyTree, ClipperLib.PolyNode);\n  // -------------------------------\n  // PolyTree & PolyNode end\n  ClipperLib.Math_Abs_Int64 = ClipperLib.Math_Abs_Int32 = ClipperLib.Math_Abs_Double = function (a)\n  {\n    return Math.abs(a);\n  };\n  ClipperLib.Math_Max_Int32_Int32 = function (a, b)\n  {\n    return Math.max(a, b);\n  };\n  /*\n  -----------------------------------\n  cast_32 speedtest: http://jsperf.com/truncate-float-to-integer/2\n  -----------------------------------\n  */\n  if (browser.msie || browser.opera || browser.safari) ClipperLib.Cast_Int32 = function (a)\n  {\n    return a | 0;\n  };\n  else ClipperLib.Cast_Int32 = function (a)\n  { // eg. browser.chrome || browser.chromium || browser.firefox\n    return~~ a;\n  };\n  /*\n  --------------------------\n  cast_64 speedtests: http://jsperf.com/truncate-float-to-integer\n  Chrome: bitwise_not_floor\n  Firefox17: toInteger (typeof test)\n  IE9: bitwise_or_floor\n  IE7 and IE8: to_parseint\n  Chromium: to_floor_or_ceil\n  Firefox3: to_floor_or_ceil\n  Firefox15: to_floor_or_ceil\n  Opera: to_floor_or_ceil\n  Safari: to_floor_or_ceil\n  --------------------------\n  */\n  if (browser.chrome) ClipperLib.Cast_Int64 = function (a)\n  {\n    if (a < -2147483648 || a > 2147483647)\n      return a < 0 ? Math.ceil(a) : Math.floor(a);\n    else return~~ a;\n  };\n  else if (browser.firefox && typeof (Number.toInteger) == \"function\") ClipperLib.Cast_Int64 = function (a)\n  {\n    return Number.toInteger(a);\n  };\n  else if (browser.msie7 || browser.msie8) ClipperLib.Cast_Int64 = function (a)\n  {\n    return parseInt(a, 10);\n  };\n  else if (browser.msie) ClipperLib.Cast_Int64 = function (a)\n  {\n    if (a < -2147483648 || a > 2147483647)\n      return a < 0 ? Math.ceil(a) : Math.floor(a);\n    return a | 0;\n  };\n  // eg. browser.chromium || browser.firefox || browser.opera || browser.safari\n  else ClipperLib.Cast_Int64 = function (a)\n  {\n    return a < 0 ? Math.ceil(a) : Math.floor(a);\n  };\n  ClipperLib.Clear = function (a)\n  {\n    a.length = 0;\n  };\n  //ClipperLib.MaxSteps = 64; // How many steps at maximum in arc in BuildArc() function\n  ClipperLib.PI = 3.141592653589793;\n  ClipperLib.PI2 = 2 * 3.141592653589793;\n  ClipperLib.IntPoint = function ()\n  {\n    var a = arguments,\n      alen = a.length;\n    this.X = 0;\n    this.Y = 0;\n    if (use_xyz)\n    {\n      this.Z = 0;\n      if (alen == 3) // public IntPoint(cInt x, cInt y, cInt z = 0)\n      {\n        this.X = a[0];\n        this.Y = a[1];\n        this.Z = a[2];\n      }\n      else if (alen == 2) // public IntPoint(cInt x, cInt y)\n      {\n        this.X = a[0];\n        this.Y = a[1];\n        this.Z = 0;\n      }\n      else if (alen == 1)\n      {\n        if (a[0] instanceof ClipperLib.DoublePoint) // public IntPoint(DoublePoint dp)\n        {\n          var dp = a[0];\n          this.X = ClipperLib.Clipper.Round(dp.X);\n          this.Y = ClipperLib.Clipper.Round(dp.Y);\n          this.Z = 0;\n        }\n        else // public IntPoint(IntPoint pt)\n        {\n          var pt = a[0];\n          if (typeof (pt.Z) == \"undefined\") pt.Z = 0;\n          this.X = pt.X;\n          this.Y = pt.Y;\n          this.Z = pt.Z;\n        }\n      }\n      else // public IntPoint()\n      {\n        this.X = 0;\n        this.Y = 0;\n        this.Z = 0;\n      }\n    }\n    else // if (!use_xyz)\n    {\n      if (alen == 2) // public IntPoint(cInt X, cInt Y)\n      {\n        this.X = a[0];\n        this.Y = a[1];\n      }\n      else if (alen == 1)\n      {\n        if (a[0] instanceof ClipperLib.DoublePoint) // public IntPoint(DoublePoint dp)\n        {\n          var dp = a[0];\n          this.X = ClipperLib.Clipper.Round(dp.X);\n          this.Y = ClipperLib.Clipper.Round(dp.Y);\n        }\n        else // public IntPoint(IntPoint pt)\n        {\n          var pt = a[0];\n          this.X = pt.X;\n          this.Y = pt.Y;\n        }\n      }\n      else // public IntPoint(IntPoint pt)\n      {\n        this.X = 0;\n        this.Y = 0;\n      }\n    }\n  };\n  ClipperLib.IntPoint.op_Equality = function (a, b)\n  {\n    //return a == b;\n    return a.X == b.X && a.Y == b.Y;\n  };\n  ClipperLib.IntPoint.op_Inequality = function (a, b)\n  {\n    //return a != b;\n    return a.X != b.X || a.Y != b.Y;\n  };\n  /*\n  ClipperLib.IntPoint.prototype.Equals = function (obj)\n  {\n    if (obj === null)\n        return false;\n    if (obj instanceof ClipperLib.IntPoint)\n    {\n        var a = Cast(obj, ClipperLib.IntPoint);\n        return (this.X == a.X) && (this.Y == a.Y);\n    }\n    else\n        return false;\n  };\n*/\n  if (use_xyz)\n  {\n    ClipperLib.IntPoint0 = function ()\n    {\n      this.X = 0;\n      this.Y = 0;\n      this.Z = 0;\n    };\n    ClipperLib.IntPoint1 = function (pt)\n    {\n      this.X = pt.X;\n      this.Y = pt.Y;\n      this.Z = pt.Z;\n    };\n    ClipperLib.IntPoint1dp = function (dp)\n    {\n      this.X = ClipperLib.Clipper.Round(dp.X);\n      this.Y = ClipperLib.Clipper.Round(dp.Y);\n      this.Z = 0;\n    };\n    ClipperLib.IntPoint2 = function (x, y)\n    {\n      this.X = x;\n      this.Y = y;\n      this.Z = 0;\n    };\n    ClipperLib.IntPoint3 = function (x, y, z)\n    {\n      this.X = x;\n      this.Y = y;\n      this.Z = z;\n    };\n  }\n  else // if (!use_xyz)\n  {\n    ClipperLib.IntPoint0 = function ()\n    {\n      this.X = 0;\n      this.Y = 0;\n    };\n    ClipperLib.IntPoint1 = function (pt)\n    {\n      this.X = pt.X;\n      this.Y = pt.Y;\n    };\n    ClipperLib.IntPoint1dp = function (dp)\n    {\n      this.X = ClipperLib.Clipper.Round(dp.X);\n      this.Y = ClipperLib.Clipper.Round(dp.Y);\n    };\n    ClipperLib.IntPoint2 = function (x, y)\n    {\n      this.X = x;\n      this.Y = y;\n    };\n  }\n  ClipperLib.IntRect = function ()\n  {\n    var a = arguments,\n      alen = a.length;\n    if (alen == 4) // function (l, t, r, b)\n    {\n      this.left = a[0];\n      this.top = a[1];\n      this.right = a[2];\n      this.bottom = a[3];\n    }\n    else if (alen == 1) // function (ir)\n    {\n      this.left = ir.left;\n      this.top = ir.top;\n      this.right = ir.right;\n      this.bottom = ir.bottom;\n    }\n    else // function ()\n    {\n      this.left = 0;\n      this.top = 0;\n      this.right = 0;\n      this.bottom = 0;\n    }\n  };\n  ClipperLib.IntRect0 = function ()\n  {\n    this.left = 0;\n    this.top = 0;\n    this.right = 0;\n    this.bottom = 0;\n  };\n  ClipperLib.IntRect1 = function (ir)\n  {\n    this.left = ir.left;\n    this.top = ir.top;\n    this.right = ir.right;\n    this.bottom = ir.bottom;\n  };\n  ClipperLib.IntRect4 = function (l, t, r, b)\n  {\n    this.left = l;\n    this.top = t;\n    this.right = r;\n    this.bottom = b;\n  };\n  ClipperLib.ClipType = {\n    ctIntersection: 0,\n    ctUnion: 1,\n    ctDifference: 2,\n    ctXor: 3\n  };\n  ClipperLib.PolyType = {\n    ptSubject: 0,\n    ptClip: 1\n  };\n  ClipperLib.PolyFillType = {\n    pftEvenOdd: 0,\n    pftNonZero: 1,\n    pftPositive: 2,\n    pftNegative: 3\n  };\n  ClipperLib.JoinType = {\n    jtSquare: 0,\n    jtRound: 1,\n    jtMiter: 2\n  };\n  ClipperLib.EndType = {\n    etOpenSquare: 0,\n    etOpenRound: 1,\n    etOpenButt: 2,\n    etClosedLine: 3,\n    etClosedPolygon: 4\n  };\n  ClipperLib.EdgeSide = {\n    esLeft: 0,\n    esRight: 1\n  };\n  ClipperLib.Direction = {\n    dRightToLeft: 0,\n    dLeftToRight: 1\n  };\n  ClipperLib.TEdge = function ()\n  {\n    this.Bot = new ClipperLib.IntPoint();\n    this.Curr = new ClipperLib.IntPoint();\n    this.Top = new ClipperLib.IntPoint();\n    this.Delta = new ClipperLib.IntPoint();\n    this.Dx = 0;\n    this.PolyTyp = ClipperLib.PolyType.ptSubject;\n    this.Side = ClipperLib.EdgeSide.esLeft;\n    this.WindDelta = 0;\n    this.WindCnt = 0;\n    this.WindCnt2 = 0;\n    this.OutIdx = 0;\n    this.Next = null;\n    this.Prev = null;\n    this.NextInLML = null;\n    this.NextInAEL = null;\n    this.PrevInAEL = null;\n    this.NextInSEL = null;\n    this.PrevInSEL = null;\n  };\n  ClipperLib.IntersectNode = function ()\n  {\n    this.Edge1 = null;\n    this.Edge2 = null;\n    this.Pt = new ClipperLib.IntPoint();\n  };\n  ClipperLib.MyIntersectNodeSort = function () {};\n  ClipperLib.MyIntersectNodeSort.Compare = function (node1, node2)\n  {\n    var i = node2.Pt.Y - node1.Pt.Y;\n    if (i > 0) return 1;\n    else if (i < 0) return -1;\n    else return 0;\n  };\n\n  ClipperLib.LocalMinima = function ()\n  {\n    this.Y = 0;\n    this.LeftBound = null;\n    this.RightBound = null;\n    this.Next = null;\n  };\n  ClipperLib.Scanbeam = function ()\n  {\n    this.Y = 0;\n    this.Next = null;\n  };\n  ClipperLib.OutRec = function ()\n  {\n    this.Idx = 0;\n    this.IsHole = false;\n    this.IsOpen = false;\n    this.FirstLeft = null;\n    this.Pts = null;\n    this.BottomPt = null;\n    this.PolyNode = null;\n  };\n  ClipperLib.OutPt = function ()\n  {\n    this.Idx = 0;\n    this.Pt = new ClipperLib.IntPoint();\n    this.Next = null;\n    this.Prev = null;\n  };\n  ClipperLib.Join = function ()\n  {\n    this.OutPt1 = null;\n    this.OutPt2 = null;\n    this.OffPt = new ClipperLib.IntPoint();\n  };\n  ClipperLib.ClipperBase = function ()\n  {\n    this.m_MinimaList = null;\n    this.m_CurrentLM = null;\n    this.m_edges = new Array();\n    this.m_UseFullRange = false;\n    this.m_HasOpenPaths = false;\n    this.PreserveCollinear = false;\n    this.m_MinimaList = null;\n    this.m_CurrentLM = null;\n    this.m_UseFullRange = false;\n    this.m_HasOpenPaths = false;\n  };\n  // Ranges are in original C# too high for Javascript (in current state 2013 september):\n  // protected const double horizontal = -3.4E+38;\n  // internal const cInt loRange = 0x3FFFFFFF; // = 1073741823 = sqrt(2^63 -1)/2\n  // internal const cInt hiRange = 0x3FFFFFFFFFFFFFFFL; // = 4611686018427387903 = sqrt(2^127 -1)/2\n  // So had to adjust them to more suitable for Javascript.\n  // If JS some day supports truly 64-bit integers, then these ranges can be as in C#\n  // and biginteger library can be more simpler (as then 128bit can be represented as two 64bit numbers)\n  ClipperLib.ClipperBase.horizontal = -9007199254740992; //-2^53\n  ClipperLib.ClipperBase.Skip = -2;\n  ClipperLib.ClipperBase.Unassigned = -1;\n  ClipperLib.ClipperBase.tolerance = 1E-20;\n  if (use_int32)\n  {\n    ClipperLib.ClipperBase.loRange = 0x7FFF;\n    ClipperLib.ClipperBase.hiRange = 0x7FFF;\n  }\n  else\n  {\n    ClipperLib.ClipperBase.loRange = 47453132; // sqrt(2^53 -1)/2\n    ClipperLib.ClipperBase.hiRange = 4503599627370495; // sqrt(2^106 -1)/2\n  }\n\n  ClipperLib.ClipperBase.near_zero = function (val)\n  {\n    return (val > -ClipperLib.ClipperBase.tolerance) && (val < ClipperLib.ClipperBase.tolerance);\n  };\n  ClipperLib.ClipperBase.IsHorizontal = function (e)\n  {\n    return e.Delta.Y === 0;\n  };\n  ClipperLib.ClipperBase.prototype.PointIsVertex = function (pt, pp)\n  {\n    var pp2 = pp;\n    do {\n      if (ClipperLib.IntPoint.op_Equality(pp2.Pt, pt))\n        return true;\n      pp2 = pp2.Next;\n    }\n    while (pp2 != pp)\n    return false;\n  };\n  ClipperLib.ClipperBase.prototype.PointOnLineSegment = function (pt, linePt1, linePt2, UseFullRange)\n  {\n    if (UseFullRange)\n      return ((pt.X == linePt1.X) && (pt.Y == linePt1.Y)) ||\n        ((pt.X == linePt2.X) && (pt.Y == linePt2.Y)) ||\n        (((pt.X > linePt1.X) == (pt.X < linePt2.X)) &&\n        ((pt.Y > linePt1.Y) == (pt.Y < linePt2.Y)) &&\n        (Int128.op_Equality(Int128.Int128Mul((pt.X - linePt1.X), (linePt2.Y - linePt1.Y)),\n          Int128.Int128Mul((linePt2.X - linePt1.X), (pt.Y - linePt1.Y)))));\n    else\n      return ((pt.X == linePt1.X) && (pt.Y == linePt1.Y)) || ((pt.X == linePt2.X) && (pt.Y == linePt2.Y)) || (((pt.X > linePt1.X) == (pt.X < linePt2.X)) && ((pt.Y > linePt1.Y) == (pt.Y < linePt2.Y)) && ((pt.X - linePt1.X) * (linePt2.Y - linePt1.Y) == (linePt2.X - linePt1.X) * (pt.Y - linePt1.Y)));\n  };\n  ClipperLib.ClipperBase.prototype.PointOnPolygon = function (pt, pp, UseFullRange)\n  {\n    var pp2 = pp;\n    while (true)\n    {\n      if (this.PointOnLineSegment(pt, pp2.Pt, pp2.Next.Pt, UseFullRange))\n        return true;\n      pp2 = pp2.Next;\n      if (pp2 == pp)\n        break;\n    }\n    return false;\n  };\n  ClipperLib.ClipperBase.prototype.SlopesEqual = ClipperLib.ClipperBase.SlopesEqual = function ()\n  {\n    var a = arguments,\n      alen = a.length;\n    var e1, e2, pt1, pt2, pt3, pt4, UseFullRange;\n    if (alen == 3) // function (e1, e2, UseFullRange)\n    {\n      e1 = a[0];\n      e2 = a[1];\n      UseFullRange = a[2];\n      if (UseFullRange)\n        return Int128.op_Equality(Int128.Int128Mul(e1.Delta.Y, e2.Delta.X), Int128.Int128Mul(e1.Delta.X, e2.Delta.Y));\n      else\n        return ClipperLib.Cast_Int64((e1.Delta.Y) * (e2.Delta.X)) == ClipperLib.Cast_Int64((e1.Delta.X) * (e2.Delta.Y));\n    }\n    else if (alen == 4) // function (pt1, pt2, pt3, UseFullRange)\n    {\n      pt1 = a[0];\n      pt2 = a[1];\n      pt3 = a[2];\n      UseFullRange = a[3];\n      if (UseFullRange)\n        return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt2.X - pt3.X), Int128.Int128Mul(pt1.X - pt2.X, pt2.Y - pt3.Y));\n      else\n        return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt2.X - pt3.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt2.Y - pt3.Y)) === 0;\n    }\n    else // function (pt1, pt2, pt3, pt4, UseFullRange)\n    {\n      pt1 = a[0];\n      pt2 = a[1];\n      pt3 = a[2];\n      pt4 = a[3];\n      UseFullRange = a[4];\n      if (UseFullRange)\n        return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt3.X - pt4.X), Int128.Int128Mul(pt1.X - pt2.X, pt3.Y - pt4.Y));\n      else\n        return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt3.X - pt4.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt3.Y - pt4.Y)) === 0;\n    }\n  };\n  ClipperLib.ClipperBase.SlopesEqual3 = function (e1, e2, UseFullRange)\n  {\n    if (UseFullRange)\n      return Int128.op_Equality(Int128.Int128Mul(e1.Delta.Y, e2.Delta.X), Int128.Int128Mul(e1.Delta.X, e2.Delta.Y));\n    else\n      return ClipperLib.Cast_Int64((e1.Delta.Y) * (e2.Delta.X)) == ClipperLib.Cast_Int64((e1.Delta.X) * (e2.Delta.Y));\n  };\n  ClipperLib.ClipperBase.SlopesEqual4 = function (pt1, pt2, pt3, UseFullRange)\n  {\n    if (UseFullRange)\n      return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt2.X - pt3.X), Int128.Int128Mul(pt1.X - pt2.X, pt2.Y - pt3.Y));\n    else\n      return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt2.X - pt3.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt2.Y - pt3.Y)) === 0;\n  };\n  ClipperLib.ClipperBase.SlopesEqual5 = function (pt1, pt2, pt3, pt4, UseFullRange)\n  {\n    if (UseFullRange)\n      return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt3.X - pt4.X), Int128.Int128Mul(pt1.X - pt2.X, pt3.Y - pt4.Y));\n    else\n      return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt3.X - pt4.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt3.Y - pt4.Y)) === 0;\n  };\n  ClipperLib.ClipperBase.prototype.Clear = function ()\n  {\n    this.DisposeLocalMinimaList();\n    for (var i = 0, ilen = this.m_edges.length; i < ilen; ++i)\n    {\n      for (var j = 0, jlen = this.m_edges[i].length; j < jlen; ++j)\n        this.m_edges[i][j] = null;\n      ClipperLib.Clear(this.m_edges[i]);\n    }\n    ClipperLib.Clear(this.m_edges);\n    this.m_UseFullRange = false;\n    this.m_HasOpenPaths = false;\n  };\n  ClipperLib.ClipperBase.prototype.DisposeLocalMinimaList = function ()\n  {\n    while (this.m_MinimaList !== null)\n    {\n      var tmpLm = this.m_MinimaList.Next;\n      this.m_MinimaList = null;\n      this.m_MinimaList = tmpLm;\n    }\n    this.m_CurrentLM = null;\n  };\n  ClipperLib.ClipperBase.prototype.RangeTest = function (Pt, useFullRange)\n  {\n    if (useFullRange.Value)\n    {\n      if (Pt.X > ClipperLib.ClipperBase.hiRange || Pt.Y > ClipperLib.ClipperBase.hiRange || -Pt.X > ClipperLib.ClipperBase.hiRange || -Pt.Y > ClipperLib.ClipperBase.hiRange)\n        ClipperLib.Error(\"Coordinate outside allowed range in RangeTest().\");\n    }\n    else if (Pt.X > ClipperLib.ClipperBase.loRange || Pt.Y > ClipperLib.ClipperBase.loRange || -Pt.X > ClipperLib.ClipperBase.loRange || -Pt.Y > ClipperLib.ClipperBase.loRange)\n    {\n      useFullRange.Value = true;\n      this.RangeTest(Pt, useFullRange);\n    }\n  };\n  ClipperLib.ClipperBase.prototype.InitEdge = function (e, eNext, ePrev, pt)\n  {\n    e.Next = eNext;\n    e.Prev = ePrev;\n    //e.Curr = pt;\n    e.Curr.X = pt.X;\n    e.Curr.Y = pt.Y;\n    e.OutIdx = -1;\n  };\n  ClipperLib.ClipperBase.prototype.InitEdge2 = function (e, polyType)\n  {\n    if (e.Curr.Y >= e.Next.Curr.Y)\n    {\n      //e.Bot = e.Curr;\n      e.Bot.X = e.Curr.X;\n      e.Bot.Y = e.Curr.Y;\n      //e.Top = e.Next.Curr;\n      e.Top.X = e.Next.Curr.X;\n      e.Top.Y = e.Next.Curr.Y;\n    }\n    else\n    {\n      //e.Top = e.Curr;\n      e.Top.X = e.Curr.X;\n      e.Top.Y = e.Curr.Y;\n      //e.Bot = e.Next.Curr;\n      e.Bot.X = e.Next.Curr.X;\n      e.Bot.Y = e.Next.Curr.Y;\n    }\n    this.SetDx(e);\n    e.PolyTyp = polyType;\n  };\n  ClipperLib.ClipperBase.prototype.FindNextLocMin = function (E)\n  {\n    var E2;\n    for (;;)\n    {\n      while (ClipperLib.IntPoint.op_Inequality(E.Bot, E.Prev.Bot) || ClipperLib.IntPoint.op_Equality(E.Curr, E.Top))\n        E = E.Next;\n      if (E.Dx != ClipperLib.ClipperBase.horizontal && E.Prev.Dx != ClipperLib.ClipperBase.horizontal)\n        break;\n      while (E.Prev.Dx == ClipperLib.ClipperBase.horizontal)\n        E = E.Prev;\n      E2 = E;\n      while (E.Dx == ClipperLib.ClipperBase.horizontal)\n        E = E.Next;\n      if (E.Top.Y == E.Prev.Bot.Y)\n        continue;\n      //ie just an intermediate horz.\n      if (E2.Prev.Bot.X < E.Bot.X)\n        E = E2;\n      break;\n    }\n    return E;\n  };\n  ClipperLib.ClipperBase.prototype.ProcessBound = function (E, LeftBoundIsForward)\n  {\n    var EStart;\n    var Result = E;\n    var Horz;\n\n      if (Result.OutIdx == ClipperLib.ClipperBase.Skip)\n      {\n        //check if there are edges beyond the skip edge in the bound and if so\n        //create another LocMin and calling ProcessBound once more ...\n        E = Result;\n        if (LeftBoundIsForward)\n        {\n          while (E.Top.Y == E.Next.Bot.Y) E = E.Next;\n          while (E != Result && E.Dx == ClipperLib.ClipperBase.horizontal) E = E.Prev;\n        }\n        else\n        {\n          while (E.Top.Y == E.Prev.Bot.Y) E = E.Prev;\n          while (E != Result && E.Dx == ClipperLib.ClipperBase.horizontal) E = E.Next;\n        }\n        if (E == Result)\n        {\n          if (LeftBoundIsForward) Result = E.Next;\n          else Result = E.Prev;\n        }\n        else\n        {\n          //there are more edges in the bound beyond result starting with E\n          if (LeftBoundIsForward)\n            E = Result.Next;\n          else\n            E = Result.Prev;\n          var locMin = new ClipperLib.LocalMinima();\n          locMin.Next = null;\n          locMin.Y = E.Bot.Y;\n          locMin.LeftBound = null;\n          locMin.RightBound = E;\n          E.WindDelta = 0;\n          Result = this.ProcessBound(E, LeftBoundIsForward);\n          this.InsertLocalMinima(locMin);\n        }\n        return Result;\n      }\n\n      if (E.Dx == ClipperLib.ClipperBase.horizontal)\n      {\n        //We need to be careful with open paths because this may not be a\n        //true local minima (ie E may be following a skip edge).\n        //Also, consecutive horz. edges may start heading left before going right.\n        if (LeftBoundIsForward) EStart = E.Prev;\n        else EStart = E.Next;\n        if (EStart.OutIdx != ClipperLib.ClipperBase.Skip)\n        {\n          if (EStart.Dx == ClipperLib.ClipperBase.horizontal) //ie an adjoining horizontal skip edge\n          {\n            if (EStart.Bot.X != E.Bot.X && EStart.Top.X != E.Bot.X)\n              this.ReverseHorizontal(E);\n          }\n          else if (EStart.Bot.X != E.Bot.X)\n            this.ReverseHorizontal(E);\n        }\n      }\n\n      EStart = E;\n      if (LeftBoundIsForward)\n      {\n        while (Result.Top.Y == Result.Next.Bot.Y && Result.Next.OutIdx != ClipperLib.ClipperBase.Skip)\n          Result = Result.Next;\n        if (Result.Dx == ClipperLib.ClipperBase.horizontal && Result.Next.OutIdx != ClipperLib.ClipperBase.Skip)\n        {\n          //nb: at the top of a bound, horizontals are added to the bound\n          //only when the preceding edge attaches to the horizontal's left vertex\n          //unless a Skip edge is encountered when that becomes the top divide\n          Horz = Result;\n          while (Horz.Prev.Dx == ClipperLib.ClipperBase.horizontal)\n            Horz = Horz.Prev;\n          if (Horz.Prev.Top.X == Result.Next.Top.X)\n          {\n            if (!LeftBoundIsForward)\n              Result = Horz.Prev;\n          }\n          else if (Horz.Prev.Top.X > Result.Next.Top.X)\n            Result = Horz.Prev;\n        }\n        while (E != Result)\n        {\n          E.NextInLML = E.Next;\n          if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Prev.Top.X)\n            this.ReverseHorizontal(E);\n          E = E.Next;\n        }\n        if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Prev.Top.X)\n          this.ReverseHorizontal(E);\n        Result = Result.Next;\n        //move to the edge just beyond current bound\n      }\n      else\n      {\n        while (Result.Top.Y == Result.Prev.Bot.Y && Result.Prev.OutIdx != ClipperLib.ClipperBase.Skip)\n          Result = Result.Prev;\n        if (Result.Dx == ClipperLib.ClipperBase.horizontal && Result.Prev.OutIdx != ClipperLib.ClipperBase.Skip)\n        {\n          Horz = Result;\n          while (Horz.Next.Dx == ClipperLib.ClipperBase.horizontal)\n            Horz = Horz.Next;\n          if (Horz.Next.Top.X == Result.Prev.Top.X)\n          {\n            if (!LeftBoundIsForward)\n              Result = Horz.Next;\n          }\n          else if (Horz.Next.Top.X > Result.Prev.Top.X)\n            Result = Horz.Next;\n        }\n        while (E != Result)\n        {\n          E.NextInLML = E.Prev;\n          if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Next.Top.X)\n            this.ReverseHorizontal(E);\n          E = E.Prev;\n        }\n        if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Next.Top.X)\n          this.ReverseHorizontal(E);\n        Result = Result.Prev;\n        //move to the edge just beyond current bound\n      }\n\n    return Result;\n  };\n\n  ClipperLib.ClipperBase.prototype.AddPath = function (pg, polyType, Closed)\n  {\n    if (use_lines)\n    {\n      if (!Closed && polyType == ClipperLib.PolyType.ptClip)\n        ClipperLib.Error(\"AddPath: Open paths must be subject.\");\n    }\n    else\n    {\n      if (!Closed)\n        ClipperLib.Error(\"AddPath: Open paths have been disabled.\");\n    }\n    var highI = pg.length - 1;\n    if (Closed)\n      while (highI > 0 && (ClipperLib.IntPoint.op_Equality(pg[highI], pg[0])))\n    --highI;\n    while (highI > 0 && (ClipperLib.IntPoint.op_Equality(pg[highI], pg[highI - 1])))\n    --highI;\n    if ((Closed && highI < 2) || (!Closed && highI < 1))\n      return false;\n    //create a new edge array ...\n    var edges = new Array();\n    for (var i = 0; i <= highI; i++)\n      edges.push(new ClipperLib.TEdge());\n    var IsFlat = true;\n    //1. Basic (first) edge initialization ...\n\n    //edges[1].Curr = pg[1];\n    edges[1].Curr.X = pg[1].X;\n    edges[1].Curr.Y = pg[1].Y;\n\n    var $1 = {Value: this.m_UseFullRange};\n    this.RangeTest(pg[0], $1);\n    this.m_UseFullRange = $1.Value;\n\n    $1.Value = this.m_UseFullRange;\n    this.RangeTest(pg[highI], $1);\n    this.m_UseFullRange = $1.Value;\n\n    this.InitEdge(edges[0], edges[1], edges[highI], pg[0]);\n    this.InitEdge(edges[highI], edges[0], edges[highI - 1], pg[highI]);\n    for (var i = highI - 1; i >= 1; --i)\n    {\n      $1.Value = this.m_UseFullRange;\n      this.RangeTest(pg[i], $1);\n      this.m_UseFullRange = $1.Value;\n\n      this.InitEdge(edges[i], edges[i + 1], edges[i - 1], pg[i]);\n    }\n\n    var eStart = edges[0];\n    //2. Remove duplicate vertices, and (when closed) collinear edges ...\n    var E = eStart,\n      eLoopStop = eStart;\n    for (;;)\n    {\n    //console.log(E.Next, eStart);\n    \t//nb: allows matching start and end points when not Closed ...\n      if (E.Curr == E.Next.Curr && (Closed || E.Next != eStart))\n      {\n        if (E == E.Next)\n          break;\n        if (E == eStart)\n          eStart = E.Next;\n        E = this.RemoveEdge(E);\n        eLoopStop = E;\n        continue;\n      }\n      if (E.Prev == E.Next)\n        break;\n      else if (Closed && ClipperLib.ClipperBase.SlopesEqual(E.Prev.Curr, E.Curr, E.Next.Curr, this.m_UseFullRange) && (!this.PreserveCollinear || !this.Pt2IsBetweenPt1AndPt3(E.Prev.Curr, E.Curr, E.Next.Curr)))\n      {\n        //Collinear edges are allowed for open paths but in closed paths\n        //the default is to merge adjacent collinear edges into a single edge.\n        //However, if the PreserveCollinear property is enabled, only overlapping\n        //collinear edges (ie spikes) will be removed from closed paths.\n        if (E == eStart)\n          eStart = E.Next;\n        E = this.RemoveEdge(E);\n        E = E.Prev;\n        eLoopStop = E;\n        continue;\n      }\n      E = E.Next;\n      if ((E == eLoopStop) || (!Closed && E.Next == eStart)) break;\n    }\n    if ((!Closed && (E == E.Next)) || (Closed && (E.Prev == E.Next)))\n      return false;\n    if (!Closed)\n    {\n      this.m_HasOpenPaths = true;\n      eStart.Prev.OutIdx = ClipperLib.ClipperBase.Skip;\n    }\n    //3. Do second stage of edge initialization ...\n    E = eStart;\n    do {\n      this.InitEdge2(E, polyType);\n      E = E.Next;\n      if (IsFlat && E.Curr.Y != eStart.Curr.Y)\n        IsFlat = false;\n    }\n    while (E != eStart)\n    //4. Finally, add edge bounds to LocalMinima list ...\n    //Totally flat paths must be handled differently when adding them\n    //to LocalMinima list to avoid endless loops etc ...\n    if (IsFlat)\n    {\n      if (Closed)\n        return false;\n      E.Prev.OutIdx = ClipperLib.ClipperBase.Skip;\n      if (E.Prev.Bot.X < E.Prev.Top.X)\n        this.ReverseHorizontal(E.Prev);\n      var locMin = new ClipperLib.LocalMinima();\n      locMin.Next = null;\n      locMin.Y = E.Bot.Y;\n      locMin.LeftBound = null;\n      locMin.RightBound = E;\n      locMin.RightBound.Side = ClipperLib.EdgeSide.esRight;\n      locMin.RightBound.WindDelta = 0;\n      while (E.Next.OutIdx != ClipperLib.ClipperBase.Skip)\n      {\n        E.NextInLML = E.Next;\n        if (E.Bot.X != E.Prev.Top.X)\n          this.ReverseHorizontal(E);\n        E = E.Next;\n      }\n      this.InsertLocalMinima(locMin);\n      this.m_edges.push(edges);\n      return true;\n    }\n    this.m_edges.push(edges);\n    var leftBoundIsForward;\n    var EMin = null;\n\n\t\t//workaround to avoid an endless loop in the while loop below when\n    //open paths have matching start and end points ...\n    if(ClipperLib.IntPoint.op_Equality(E.Prev.Bot, E.Prev.Top))\n    \tE = E.Next;\n\n    for (;;)\n    {\n      E = this.FindNextLocMin(E);\n      if (E == EMin)\n        break;\n      else if (EMin == null)\n        EMin = E;\n      //E and E.Prev now share a local minima (left aligned if horizontal).\n      //Compare their slopes to find which starts which bound ...\n      var locMin = new ClipperLib.LocalMinima();\n      locMin.Next = null;\n      locMin.Y = E.Bot.Y;\n      if (E.Dx < E.Prev.Dx)\n      {\n        locMin.LeftBound = E.Prev;\n        locMin.RightBound = E;\n        leftBoundIsForward = false;\n        //Q.nextInLML = Q.prev\n      }\n      else\n      {\n        locMin.LeftBound = E;\n        locMin.RightBound = E.Prev;\n        leftBoundIsForward = true;\n        //Q.nextInLML = Q.next\n      }\n      locMin.LeftBound.Side = ClipperLib.EdgeSide.esLeft;\n      locMin.RightBound.Side = ClipperLib.EdgeSide.esRight;\n      if (!Closed)\n        locMin.LeftBound.WindDelta = 0;\n      else if (locMin.LeftBound.Next == locMin.RightBound)\n        locMin.LeftBound.WindDelta = -1;\n      else\n        locMin.LeftBound.WindDelta = 1;\n      locMin.RightBound.WindDelta = -locMin.LeftBound.WindDelta;\n      E = this.ProcessBound(locMin.LeftBound, leftBoundIsForward);\n      if (E.OutIdx == ClipperLib.ClipperBase.Skip)\n      \tE = this.ProcessBound(E, leftBoundIsForward);\n      var E2 = this.ProcessBound(locMin.RightBound, !leftBoundIsForward);\n      if (E2.OutIdx == ClipperLib.ClipperBase.Skip) E2 = this.ProcessBound(E2, !leftBoundIsForward);\n      if (locMin.LeftBound.OutIdx == ClipperLib.ClipperBase.Skip)\n        locMin.LeftBound = null;\n      else if (locMin.RightBound.OutIdx == ClipperLib.ClipperBase.Skip)\n        locMin.RightBound = null;\n      this.InsertLocalMinima(locMin);\n      if (!leftBoundIsForward)\n        E = E2;\n    }\n    return true;\n  };\n  ClipperLib.ClipperBase.prototype.AddPaths = function (ppg, polyType, closed)\n  {\n    //  console.log(\"-------------------------------------------\");\n    //  console.log(JSON.stringify(ppg));\n    var result = false;\n    for (var i = 0, ilen = ppg.length; i < ilen; ++i)\n      if (this.AddPath(ppg[i], polyType, closed))\n        result = true;\n    return result;\n  };\n  //------------------------------------------------------------------------------\n  ClipperLib.ClipperBase.prototype.Pt2IsBetweenPt1AndPt3 = function (pt1, pt2, pt3)\n  {\n    if ((ClipperLib.IntPoint.op_Equality(pt1, pt3)) || (ClipperLib.IntPoint.op_Equality(pt1, pt2)) ||       (ClipperLib.IntPoint.op_Equality(pt3, pt2)))\n\n   //if ((pt1 == pt3) || (pt1 == pt2) || (pt3 == pt2))\n   return false;\n\n    else if (pt1.X != pt3.X)\n      return (pt2.X > pt1.X) == (pt2.X < pt3.X);\n    else\n      return (pt2.Y > pt1.Y) == (pt2.Y < pt3.Y);\n  };\n  ClipperLib.ClipperBase.prototype.RemoveEdge = function (e)\n  {\n    //removes e from double_linked_list (but without removing from memory)\n    e.Prev.Next = e.Next;\n    e.Next.Prev = e.Prev;\n    var result = e.Next;\n    e.Prev = null; //flag as removed (see ClipperBase.Clear)\n    return result;\n  };\n  ClipperLib.ClipperBase.prototype.SetDx = function (e)\n  {\n    e.Delta.X = (e.Top.X - e.Bot.X);\n    e.Delta.Y = (e.Top.Y - e.Bot.Y);\n    if (e.Delta.Y === 0) e.Dx = ClipperLib.ClipperBase.horizontal;\n    else e.Dx = (e.Delta.X) / (e.Delta.Y);\n  };\n  ClipperLib.ClipperBase.prototype.InsertLocalMinima = function (newLm)\n  {\n    if (this.m_MinimaList === null)\n    {\n      this.m_MinimaList = newLm;\n    }\n    else if (newLm.Y >= this.m_MinimaList.Y)\n    {\n      newLm.Next = this.m_MinimaList;\n      this.m_MinimaList = newLm;\n    }\n    else\n    {\n      var tmpLm = this.m_MinimaList;\n      while (tmpLm.Next !== null && (newLm.Y < tmpLm.Next.Y))\n        tmpLm = tmpLm.Next;\n      newLm.Next = tmpLm.Next;\n      tmpLm.Next = newLm;\n    }\n  };\n  ClipperLib.ClipperBase.prototype.PopLocalMinima = function ()\n  {\n    if (this.m_CurrentLM === null)\n      return;\n    this.m_CurrentLM = this.m_CurrentLM.Next;\n  };\n  ClipperLib.ClipperBase.prototype.ReverseHorizontal = function (e)\n  {\n    //swap horizontal edges' top and bottom x's so they follow the natural\n    //progression of the bounds - ie so their xbots will align with the\n    //adjoining lower edge. [Helpful in the ProcessHorizontal() method.]\n    var tmp = e.Top.X;\n    e.Top.X = e.Bot.X;\n    e.Bot.X = tmp;\n    if (use_xyz)\n    {\n      tmp = e.Top.Z;\n      e.Top.Z = e.Bot.Z;\n      e.Bot.Z = tmp;\n    }\n  };\n  ClipperLib.ClipperBase.prototype.Reset = function ()\n  {\n    this.m_CurrentLM = this.m_MinimaList;\n    if (this.m_CurrentLM == null)\n      return;\n    //ie nothing to process\n    //reset all edges ...\n    var lm = this.m_MinimaList;\n    while (lm != null)\n    {\n      var e = lm.LeftBound;\n      if (e != null)\n      {\n        //e.Curr = e.Bot;\n        e.Curr.X = e.Bot.X;\n        e.Curr.Y = e.Bot.Y;\n        e.Side = ClipperLib.EdgeSide.esLeft;\n        e.OutIdx = ClipperLib.ClipperBase.Unassigned;\n      }\n      e = lm.RightBound;\n      if (e != null)\n      {\n        //e.Curr = e.Bot;\n        e.Curr.X = e.Bot.X;\n        e.Curr.Y = e.Bot.Y;\n        e.Side = ClipperLib.EdgeSide.esRight;\n        e.OutIdx = ClipperLib.ClipperBase.Unassigned;\n      }\n      lm = lm.Next;\n    }\n  };\n  ClipperLib.Clipper = function (InitOptions) // public Clipper(int InitOptions = 0)\n  {\n    if (typeof (InitOptions) == \"undefined\") InitOptions = 0;\n    this.m_PolyOuts = null;\n    this.m_ClipType = ClipperLib.ClipType.ctIntersection;\n    this.m_Scanbeam = null;\n    this.m_ActiveEdges = null;\n    this.m_SortedEdges = null;\n    this.m_IntersectList = null;\n    this.m_IntersectNodeComparer = null;\n    this.m_ExecuteLocked = false;\n    this.m_ClipFillType = ClipperLib.PolyFillType.pftEvenOdd;\n    this.m_SubjFillType = ClipperLib.PolyFillType.pftEvenOdd;\n    this.m_Joins = null;\n    this.m_GhostJoins = null;\n    this.m_UsingPolyTree = false;\n    this.ReverseSolution = false;\n    this.StrictlySimple = false;\n    ClipperLib.ClipperBase.call(this);\n    this.m_Scanbeam = null;\n    this.m_ActiveEdges = null;\n    this.m_SortedEdges = null;\n    this.m_IntersectList = new Array();\n    this.m_IntersectNodeComparer = ClipperLib.MyIntersectNodeSort.Compare;\n    this.m_ExecuteLocked = false;\n    this.m_UsingPolyTree = false;\n    this.m_PolyOuts = new Array();\n    this.m_Joins = new Array();\n    this.m_GhostJoins = new Array();\n    this.ReverseSolution = (1 & InitOptions) !== 0;\n    this.StrictlySimple = (2 & InitOptions) !== 0;\n    this.PreserveCollinear = (4 & InitOptions) !== 0;\n    if (use_xyz)\n    {\n      this.ZFillFunction = null; // function (IntPoint vert1, IntPoint vert2, ref IntPoint intersectPt);\n    }\n  };\n  ClipperLib.Clipper.ioReverseSolution = 1;\n  ClipperLib.Clipper.ioStrictlySimple = 2;\n  ClipperLib.Clipper.ioPreserveCollinear = 4;\n\n  ClipperLib.Clipper.prototype.Clear = function ()\n  {\n    if (this.m_edges.length === 0)\n      return;\n    //avoids problems with ClipperBase destructor\n    this.DisposeAllPolyPts();\n    ClipperLib.ClipperBase.prototype.Clear.call(this);\n  };\n\n  ClipperLib.Clipper.prototype.DisposeScanbeamList = function ()\n  {\n    while (this.m_Scanbeam !== null)\n    {\n      var sb2 = this.m_Scanbeam.Next;\n      this.m_Scanbeam = null;\n      this.m_Scanbeam = sb2;\n    }\n  };\n  ClipperLib.Clipper.prototype.Reset = function ()\n  {\n    ClipperLib.ClipperBase.prototype.Reset.call(this);\n    this.m_Scanbeam = null;\n    this.m_ActiveEdges = null;\n    this.m_SortedEdges = null;\n\n    var lm = this.m_MinimaList;\n    while (lm !== null)\n    {\n      this.InsertScanbeam(lm.Y);\n      lm = lm.Next;\n    }\n  };\n  ClipperLib.Clipper.prototype.InsertScanbeam = function (Y)\n  {\n    if (this.m_Scanbeam === null)\n    {\n      this.m_Scanbeam = new ClipperLib.Scanbeam();\n      this.m_Scanbeam.Next = null;\n      this.m_Scanbeam.Y = Y;\n    }\n    else if (Y > this.m_Scanbeam.Y)\n    {\n      var newSb = new ClipperLib.Scanbeam();\n      newSb.Y = Y;\n      newSb.Next = this.m_Scanbeam;\n      this.m_Scanbeam = newSb;\n    }\n    else\n    {\n      var sb2 = this.m_Scanbeam;\n      while (sb2.Next !== null && (Y <= sb2.Next.Y))\n        sb2 = sb2.Next;\n      if (Y == sb2.Y)\n        return;\n      //ie ignores duplicates\n      var newSb = new ClipperLib.Scanbeam();\n      newSb.Y = Y;\n      newSb.Next = sb2.Next;\n      sb2.Next = newSb;\n    }\n  };\n  // ************************************\n  ClipperLib.Clipper.prototype.Execute = function ()\n  {\n    var a = arguments,\n      alen = a.length,\n      ispolytree = a[1] instanceof ClipperLib.PolyTree;\n    if (alen == 4 && !ispolytree) // function (clipType, solution, subjFillType, clipFillType)\n    {\n      var clipType = a[0],\n        solution = a[1],\n        subjFillType = a[2],\n        clipFillType = a[3];\n      if (this.m_ExecuteLocked)\n        return false;\n      if (this.m_HasOpenPaths)\n        ClipperLib.Error(\"Error: PolyTree struct is need for open path clipping.\");\n      this.m_ExecuteLocked = true;\n      ClipperLib.Clear(solution);\n      this.m_SubjFillType = subjFillType;\n      this.m_ClipFillType = clipFillType;\n      this.m_ClipType = clipType;\n      this.m_UsingPolyTree = false;\n      try\n      {\n        var succeeded = this.ExecuteInternal();\n        //build the return polygons ...\n        if (succeeded) this.BuildResult(solution);\n      }\n      finally\n      {\n        this.DisposeAllPolyPts();\n        this.m_ExecuteLocked = false;\n      }\n      return succeeded;\n    }\n    else if (alen == 4 && ispolytree) // function (clipType, polytree, subjFillType, clipFillType)\n    {\n      var clipType = a[0],\n        polytree = a[1],\n        subjFillType = a[2],\n        clipFillType = a[3];\n      if (this.m_ExecuteLocked)\n        return false;\n      this.m_ExecuteLocked = true;\n      this.m_SubjFillType = subjFillType;\n      this.m_ClipFillType = clipFillType;\n      this.m_ClipType = clipType;\n      this.m_UsingPolyTree = true;\n      try\n      {\n        var succeeded = this.ExecuteInternal();\n        //build the return polygons ...\n        if (succeeded) this.BuildResult2(polytree);\n      }\n      finally\n      {\n        this.DisposeAllPolyPts();\n        this.m_ExecuteLocked = false;\n      }\n      return succeeded;\n    }\n    else if (alen == 2 && !ispolytree) // function (clipType, solution)\n    {\n      var clipType = a[0],\n        solution = a[1];\n      return this.Execute(clipType, solution, ClipperLib.PolyFillType.pftEvenOdd, ClipperLib.PolyFillType.pftEvenOdd);\n    }\n    else if (alen == 2 && ispolytree) // function (clipType, polytree)\n    {\n      var clipType = a[0],\n        polytree = a[1];\n      return this.Execute(clipType, polytree, ClipperLib.PolyFillType.pftEvenOdd, ClipperLib.PolyFillType.pftEvenOdd);\n    }\n  };\n  ClipperLib.Clipper.prototype.FixHoleLinkage = function (outRec)\n  {\n    //skip if an outermost polygon or\n    //already already points to the correct FirstLeft ...\n    if (outRec.FirstLeft === null || (outRec.IsHole != outRec.FirstLeft.IsHole && outRec.FirstLeft.Pts !== null))\n      return;\n    var orfl = outRec.FirstLeft;\n    while (orfl !== null && ((orfl.IsHole == outRec.IsHole) || orfl.Pts === null))\n      orfl = orfl.FirstLeft;\n    outRec.FirstLeft = orfl;\n  };\n  ClipperLib.Clipper.prototype.ExecuteInternal = function ()\n  {\n    try\n    {\n      this.Reset();\n      if (this.m_CurrentLM === null)\n        return false;\n      var botY = this.PopScanbeam();\n      do {\n        this.InsertLocalMinimaIntoAEL(botY);\n        ClipperLib.Clear(this.m_GhostJoins);\n        this.ProcessHorizontals(false);\n        if (this.m_Scanbeam === null)\n          break;\n        var topY = this.PopScanbeam();\n        if (!this.ProcessIntersections(topY)) return false;\n\n        this.ProcessEdgesAtTopOfScanbeam(topY);\n        botY = topY;\n      }\n      while (this.m_Scanbeam !== null || this.m_CurrentLM !== null)\n      //fix orientations ...\n      for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n      {\n        var outRec = this.m_PolyOuts[i];\n        if (outRec.Pts === null || outRec.IsOpen)\n          continue;\n        if ((outRec.IsHole ^ this.ReverseSolution) == (this.Area(outRec) > 0))\n          this.ReversePolyPtLinks(outRec.Pts);\n      }\n      this.JoinCommonEdges();\n      for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n      {\n        var outRec = this.m_PolyOuts[i];\n        if (outRec.Pts !== null && !outRec.IsOpen)\n          this.FixupOutPolygon(outRec);\n      }\n      if (this.StrictlySimple)\n        this.DoSimplePolygons();\n      return true;\n    }\n    finally\n    {\n      ClipperLib.Clear(this.m_Joins);\n      ClipperLib.Clear(this.m_GhostJoins);\n    }\n  };\n  ClipperLib.Clipper.prototype.PopScanbeam = function ()\n  {\n    var Y = this.m_Scanbeam.Y;\n    this.m_Scanbeam = this.m_Scanbeam.Next;\n    return Y;\n  };\n\n  ClipperLib.Clipper.prototype.DisposeAllPolyPts = function ()\n  {\n    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; ++i)\n      this.DisposeOutRec(i);\n    ClipperLib.Clear(this.m_PolyOuts);\n  };\n  ClipperLib.Clipper.prototype.DisposeOutRec = function (index)\n  {\n    var outRec = this.m_PolyOuts[index];\n    outRec.Pts = null;\n    outRec = null;\n    this.m_PolyOuts[index] = null;\n  };\n\n  ClipperLib.Clipper.prototype.AddJoin = function (Op1, Op2, OffPt)\n  {\n    var j = new ClipperLib.Join();\n    j.OutPt1 = Op1;\n    j.OutPt2 = Op2;\n    //j.OffPt = OffPt;\n    j.OffPt.X = OffPt.X;\n    j.OffPt.Y = OffPt.Y;\n    this.m_Joins.push(j);\n  };\n  ClipperLib.Clipper.prototype.AddGhostJoin = function (Op, OffPt)\n  {\n    var j = new ClipperLib.Join();\n    j.OutPt1 = Op;\n    //j.OffPt = OffPt;\n    j.OffPt.X = OffPt.X;\n    j.OffPt.Y = OffPt.Y;\n    this.m_GhostJoins.push(j);\n  };\n  if (use_xyz)\n  {\n    ClipperLib.Clipper.prototype.SetZ = function (pt, e1, e2)\n    {\n      if (this.ZFillFunction !== null)\n      {\n        if (pt.Z != 0 || this.ZFillFunction === null) return;\n        else if (ClipperLib.IntPoint.op_Equality(pt, e1.Bot)) pt.Z = e1.Bot.Z;\n        else if (ClipperLib.IntPoint.op_Equality(pt, e1.Top)) pt.Z = e1.Top.Z;\n        else if (ClipperLib.IntPoint.op_Equality(pt, e2.Bot)) pt.Z = e2.Bot.Z;\n        else if (ClipperLib.IntPoint.op_Equality(pt, e2.Top)) pt.Z = e2.Top.Z;\n        else ZFillFunction(e1.Bot, e1.Top, e2.Bot, e2.Top, pt);\n      }\n    };\n\n    //------------------------------------------------------------------------------\n  }\n\n  ClipperLib.Clipper.prototype.InsertLocalMinimaIntoAEL = function (botY)\n  {\n    while (this.m_CurrentLM !== null && (this.m_CurrentLM.Y == botY))\n    {\n      var lb = this.m_CurrentLM.LeftBound;\n      var rb = this.m_CurrentLM.RightBound;\n      this.PopLocalMinima();\n      var Op1 = null;\n      if (lb === null)\n      {\n        this.InsertEdgeIntoAEL(rb, null);\n        this.SetWindingCount(rb);\n        if (this.IsContributing(rb))\n          Op1 = this.AddOutPt(rb, rb.Bot);\n      }\n      else if (rb == null)\n      {\n        this.InsertEdgeIntoAEL(lb, null);\n        this.SetWindingCount(lb);\n        if (this.IsContributing(lb))\n          Op1 = this.AddOutPt(lb, lb.Bot);\n        this.InsertScanbeam(lb.Top.Y);\n      }\n      else\n      {\n        this.InsertEdgeIntoAEL(lb, null);\n        this.InsertEdgeIntoAEL(rb, lb);\n        this.SetWindingCount(lb);\n        rb.WindCnt = lb.WindCnt;\n        rb.WindCnt2 = lb.WindCnt2;\n        if (this.IsContributing(lb))\n          Op1 = this.AddLocalMinPoly(lb, rb, lb.Bot);\n        this.InsertScanbeam(lb.Top.Y);\n      }\n      if (rb != null)\n      {\n        if (ClipperLib.ClipperBase.IsHorizontal(rb))\n          this.AddEdgeToSEL(rb);\n        else\n          this.InsertScanbeam(rb.Top.Y);\n      }\n      if (lb == null || rb == null) continue;\n      //if output polygons share an Edge with a horizontal rb, they'll need joining later ...\n      if (Op1 !== null && ClipperLib.ClipperBase.IsHorizontal(rb) && this.m_GhostJoins.length > 0 && rb.WindDelta !== 0)\n      {\n        for (var i = 0, ilen = this.m_GhostJoins.length; i < ilen; i++)\n        {\n          //if the horizontal Rb and a 'ghost' horizontal overlap, then convert\n          //the 'ghost' join to a real join ready for later ...\n          var j = this.m_GhostJoins[i];\n\n\t\t\t\t\tif (this.HorzSegmentsOverlap(j.OutPt1.Pt.X, j.OffPt.X, rb.Bot.X, rb.Top.X))\n            this.AddJoin(j.OutPt1, Op1, j.OffPt);\n        }\n      }\n      if (lb.OutIdx >= 0 && lb.PrevInAEL !== null &&\n        lb.PrevInAEL.Curr.X == lb.Bot.X &&\n        lb.PrevInAEL.OutIdx >= 0 &&\n        ClipperLib.ClipperBase.SlopesEqual(lb.PrevInAEL, lb, this.m_UseFullRange) &&\n        lb.WindDelta !== 0 && lb.PrevInAEL.WindDelta !== 0)\n      {\n        var Op2 = this.AddOutPt(lb.PrevInAEL, lb.Bot);\n        this.AddJoin(Op1, Op2, lb.Top);\n      }\n      if (lb.NextInAEL != rb)\n      {\n        if (rb.OutIdx >= 0 && rb.PrevInAEL.OutIdx >= 0 &&\n          ClipperLib.ClipperBase.SlopesEqual(rb.PrevInAEL, rb, this.m_UseFullRange) &&\n          rb.WindDelta !== 0 && rb.PrevInAEL.WindDelta !== 0)\n        {\n          var Op2 = this.AddOutPt(rb.PrevInAEL, rb.Bot);\n          this.AddJoin(Op1, Op2, rb.Top);\n        }\n        var e = lb.NextInAEL;\n        if (e !== null)\n          while (e != rb)\n          {\n            //nb: For calculating winding counts etc, IntersectEdges() assumes\n            //that param1 will be to the right of param2 ABOVE the intersection ...\n            this.IntersectEdges(rb, e, lb.Curr, false);\n            //order important here\n            e = e.NextInAEL;\n          }\n      }\n    }\n  };\n  ClipperLib.Clipper.prototype.InsertEdgeIntoAEL = function (edge, startEdge)\n  {\n    if (this.m_ActiveEdges === null)\n    {\n      edge.PrevInAEL = null;\n      edge.NextInAEL = null;\n      this.m_ActiveEdges = edge;\n    }\n    else if (startEdge === null && this.E2InsertsBeforeE1(this.m_ActiveEdges, edge))\n    {\n      edge.PrevInAEL = null;\n      edge.NextInAEL = this.m_ActiveEdges;\n      this.m_ActiveEdges.PrevInAEL = edge;\n      this.m_ActiveEdges = edge;\n    }\n    else\n    {\n      if (startEdge === null)\n        startEdge = this.m_ActiveEdges;\n      while (startEdge.NextInAEL !== null && !this.E2InsertsBeforeE1(startEdge.NextInAEL, edge))\n        startEdge = startEdge.NextInAEL;\n      edge.NextInAEL = startEdge.NextInAEL;\n      if (startEdge.NextInAEL !== null)\n        startEdge.NextInAEL.PrevInAEL = edge;\n      edge.PrevInAEL = startEdge;\n      startEdge.NextInAEL = edge;\n    }\n  };\n  ClipperLib.Clipper.prototype.E2InsertsBeforeE1 = function (e1, e2)\n  {\n    if (e2.Curr.X == e1.Curr.X)\n    {\n      if (e2.Top.Y > e1.Top.Y)\n        return e2.Top.X < ClipperLib.Clipper.TopX(e1, e2.Top.Y);\n      else\n        return e1.Top.X > ClipperLib.Clipper.TopX(e2, e1.Top.Y);\n    }\n    else\n      return e2.Curr.X < e1.Curr.X;\n  };\n  ClipperLib.Clipper.prototype.IsEvenOddFillType = function (edge)\n  {\n    if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)\n      return this.m_SubjFillType == ClipperLib.PolyFillType.pftEvenOdd;\n    else\n      return this.m_ClipFillType == ClipperLib.PolyFillType.pftEvenOdd;\n  };\n  ClipperLib.Clipper.prototype.IsEvenOddAltFillType = function (edge)\n  {\n    if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)\n      return this.m_ClipFillType == ClipperLib.PolyFillType.pftEvenOdd;\n    else\n      return this.m_SubjFillType == ClipperLib.PolyFillType.pftEvenOdd;\n  };\n  ClipperLib.Clipper.prototype.IsContributing = function (edge)\n  {\n    var pft, pft2;\n    if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)\n    {\n      pft = this.m_SubjFillType;\n      pft2 = this.m_ClipFillType;\n    }\n    else\n    {\n      pft = this.m_ClipFillType;\n      pft2 = this.m_SubjFillType;\n    }\n    switch (pft)\n    {\n    case ClipperLib.PolyFillType.pftEvenOdd:\n      if (edge.WindDelta === 0 && edge.WindCnt != 1)\n        return false;\n      break;\n    case ClipperLib.PolyFillType.pftNonZero:\n      if (Math.abs(edge.WindCnt) != 1)\n        return false;\n      break;\n    case ClipperLib.PolyFillType.pftPositive:\n      if (edge.WindCnt != 1)\n        return false;\n      break;\n    default:\n      if (edge.WindCnt != -1)\n        return false;\n      break;\n    }\n    switch (this.m_ClipType)\n    {\n    case ClipperLib.ClipType.ctIntersection:\n      switch (pft2)\n      {\n      case ClipperLib.PolyFillType.pftEvenOdd:\n      case ClipperLib.PolyFillType.pftNonZero:\n        return (edge.WindCnt2 !== 0);\n      case ClipperLib.PolyFillType.pftPositive:\n        return (edge.WindCnt2 > 0);\n      default:\n        return (edge.WindCnt2 < 0);\n      }\n    case ClipperLib.ClipType.ctUnion:\n      switch (pft2)\n      {\n      case ClipperLib.PolyFillType.pftEvenOdd:\n      case ClipperLib.PolyFillType.pftNonZero:\n        return (edge.WindCnt2 === 0);\n      case ClipperLib.PolyFillType.pftPositive:\n        return (edge.WindCnt2 <= 0);\n      default:\n        return (edge.WindCnt2 >= 0);\n      }\n    case ClipperLib.ClipType.ctDifference:\n      if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)\n        switch (pft2)\n        {\n        case ClipperLib.PolyFillType.pftEvenOdd:\n        case ClipperLib.PolyFillType.pftNonZero:\n          return (edge.WindCnt2 === 0);\n        case ClipperLib.PolyFillType.pftPositive:\n          return (edge.WindCnt2 <= 0);\n        default:\n          return (edge.WindCnt2 >= 0);\n        }\n      else\n        switch (pft2)\n        {\n        case ClipperLib.PolyFillType.pftEvenOdd:\n        case ClipperLib.PolyFillType.pftNonZero:\n          return (edge.WindCnt2 !== 0);\n        case ClipperLib.PolyFillType.pftPositive:\n          return (edge.WindCnt2 > 0);\n        default:\n          return (edge.WindCnt2 < 0);\n        }\n    case ClipperLib.ClipType.ctXor:\n      if (edge.WindDelta === 0)\n        switch (pft2)\n        {\n        case ClipperLib.PolyFillType.pftEvenOdd:\n        case ClipperLib.PolyFillType.pftNonZero:\n          return (edge.WindCnt2 === 0);\n        case ClipperLib.PolyFillType.pftPositive:\n          return (edge.WindCnt2 <= 0);\n        default:\n          return (edge.WindCnt2 >= 0);\n        }\n      else\n        return true;\n    }\n    return true;\n  };\n  ClipperLib.Clipper.prototype.SetWindingCount = function (edge)\n  {\n    var e = edge.PrevInAEL;\n    //find the edge of the same polytype that immediately preceeds 'edge' in AEL\n    while (e !== null && ((e.PolyTyp != edge.PolyTyp) || (e.WindDelta === 0)))\n      e = e.PrevInAEL;\n    if (e === null)\n    {\n      edge.WindCnt = (edge.WindDelta === 0 ? 1 : edge.WindDelta);\n      edge.WindCnt2 = 0;\n      e = this.m_ActiveEdges;\n      //ie get ready to calc WindCnt2\n    }\n    else if (edge.WindDelta === 0 && this.m_ClipType != ClipperLib.ClipType.ctUnion)\n    {\n      edge.WindCnt = 1;\n      edge.WindCnt2 = e.WindCnt2;\n      e = e.NextInAEL;\n      //ie get ready to calc WindCnt2\n    }\n    else if (this.IsEvenOddFillType(edge))\n    {\n      //EvenOdd filling ...\n      if (edge.WindDelta === 0)\n      {\n        //are we inside a subj polygon ...\n        var Inside = true;\n        var e2 = e.PrevInAEL;\n        while (e2 !== null)\n        {\n          if (e2.PolyTyp == e.PolyTyp && e2.WindDelta !== 0)\n            Inside = !Inside;\n          e2 = e2.PrevInAEL;\n        }\n        edge.WindCnt = (Inside ? 0 : 1);\n      }\n      else\n      {\n        edge.WindCnt = edge.WindDelta;\n      }\n      edge.WindCnt2 = e.WindCnt2;\n      e = e.NextInAEL;\n      //ie get ready to calc WindCnt2\n    }\n    else\n    {\n      //nonZero, Positive or Negative filling ...\n      if (e.WindCnt * e.WindDelta < 0)\n      {\n        //prev edge is 'decreasing' WindCount (WC) toward zero\n        //so we're outside the previous polygon ...\n        if (Math.abs(e.WindCnt) > 1)\n        {\n          //outside prev poly but still inside another.\n          //when reversing direction of prev poly use the same WC\n          if (e.WindDelta * edge.WindDelta < 0)\n            edge.WindCnt = e.WindCnt;\n          else\n            edge.WindCnt = e.WindCnt + edge.WindDelta;\n        }\n        else\n          edge.WindCnt = (edge.WindDelta === 0 ? 1 : edge.WindDelta);\n      }\n      else\n      {\n        //prev edge is 'increasing' WindCount (WC) away from zero\n        //so we're inside the previous polygon ...\n        if (edge.WindDelta === 0)\n          edge.WindCnt = (e.WindCnt < 0 ? e.WindCnt - 1 : e.WindCnt + 1);\n        else if (e.WindDelta * edge.WindDelta < 0)\n          edge.WindCnt = e.WindCnt;\n        else\n          edge.WindCnt = e.WindCnt + edge.WindDelta;\n      }\n      edge.WindCnt2 = e.WindCnt2;\n      e = e.NextInAEL;\n      //ie get ready to calc WindCnt2\n    }\n    //update WindCnt2 ...\n    if (this.IsEvenOddAltFillType(edge))\n    {\n      //EvenOdd filling ...\n      while (e != edge)\n      {\n        if (e.WindDelta !== 0)\n          edge.WindCnt2 = (edge.WindCnt2 === 0 ? 1 : 0);\n        e = e.NextInAEL;\n      }\n    }\n    else\n    {\n      //nonZero, Positive or Negative filling ...\n      while (e != edge)\n      {\n        edge.WindCnt2 += e.WindDelta;\n        e = e.NextInAEL;\n      }\n    }\n  };\n  ClipperLib.Clipper.prototype.AddEdgeToSEL = function (edge)\n  {\n    //SEL pointers in PEdge are reused to build a list of horizontal edges.\n    //However, we don't need to worry about order with horizontal edge processing.\n    if (this.m_SortedEdges === null)\n    {\n      this.m_SortedEdges = edge;\n      edge.PrevInSEL = null;\n      edge.NextInSEL = null;\n    }\n    else\n    {\n      edge.NextInSEL = this.m_SortedEdges;\n      edge.PrevInSEL = null;\n      this.m_SortedEdges.PrevInSEL = edge;\n      this.m_SortedEdges = edge;\n    }\n  };\n  ClipperLib.Clipper.prototype.CopyAELToSEL = function ()\n  {\n    var e = this.m_ActiveEdges;\n    this.m_SortedEdges = e;\n    while (e !== null)\n    {\n      e.PrevInSEL = e.PrevInAEL;\n      e.NextInSEL = e.NextInAEL;\n      e = e.NextInAEL;\n    }\n  };\n  ClipperLib.Clipper.prototype.SwapPositionsInAEL = function (edge1, edge2)\n  {\n    //check that one or other edge hasn't already been removed from AEL ...\n    if (edge1.NextInAEL == edge1.PrevInAEL || edge2.NextInAEL == edge2.PrevInAEL)\n      return;\n    if (edge1.NextInAEL == edge2)\n    {\n      var next = edge2.NextInAEL;\n      if (next !== null)\n        next.PrevInAEL = edge1;\n      var prev = edge1.PrevInAEL;\n      if (prev !== null)\n        prev.NextInAEL = edge2;\n      edge2.PrevInAEL = prev;\n      edge2.NextInAEL = edge1;\n      edge1.PrevInAEL = edge2;\n      edge1.NextInAEL = next;\n    }\n    else if (edge2.NextInAEL == edge1)\n    {\n      var next = edge1.NextInAEL;\n      if (next !== null)\n        next.PrevInAEL = edge2;\n      var prev = edge2.PrevInAEL;\n      if (prev !== null)\n        prev.NextInAEL = edge1;\n      edge1.PrevInAEL = prev;\n      edge1.NextInAEL = edge2;\n      edge2.PrevInAEL = edge1;\n      edge2.NextInAEL = next;\n    }\n    else\n    {\n      var next = edge1.NextInAEL;\n      var prev = edge1.PrevInAEL;\n      edge1.NextInAEL = edge2.NextInAEL;\n      if (edge1.NextInAEL !== null)\n        edge1.NextInAEL.PrevInAEL = edge1;\n      edge1.PrevInAEL = edge2.PrevInAEL;\n      if (edge1.PrevInAEL !== null)\n        edge1.PrevInAEL.NextInAEL = edge1;\n      edge2.NextInAEL = next;\n      if (edge2.NextInAEL !== null)\n        edge2.NextInAEL.PrevInAEL = edge2;\n      edge2.PrevInAEL = prev;\n      if (edge2.PrevInAEL !== null)\n        edge2.PrevInAEL.NextInAEL = edge2;\n    }\n    if (edge1.PrevInAEL === null)\n      this.m_ActiveEdges = edge1;\n    else if (edge2.PrevInAEL === null)\n      this.m_ActiveEdges = edge2;\n  };\n  ClipperLib.Clipper.prototype.SwapPositionsInSEL = function (edge1, edge2)\n  {\n    if (edge1.NextInSEL === null && edge1.PrevInSEL === null)\n      return;\n    if (edge2.NextInSEL === null && edge2.PrevInSEL === null)\n      return;\n    if (edge1.NextInSEL == edge2)\n    {\n      var next = edge2.NextInSEL;\n      if (next !== null)\n        next.PrevInSEL = edge1;\n      var prev = edge1.PrevInSEL;\n      if (prev !== null)\n        prev.NextInSEL = edge2;\n      edge2.PrevInSEL = prev;\n      edge2.NextInSEL = edge1;\n      edge1.PrevInSEL = edge2;\n      edge1.NextInSEL = next;\n    }\n    else if (edge2.NextInSEL == edge1)\n    {\n      var next = edge1.NextInSEL;\n      if (next !== null)\n        next.PrevInSEL = edge2;\n      var prev = edge2.PrevInSEL;\n      if (prev !== null)\n        prev.NextInSEL = edge1;\n      edge1.PrevInSEL = prev;\n      edge1.NextInSEL = edge2;\n      edge2.PrevInSEL = edge1;\n      edge2.NextInSEL = next;\n    }\n    else\n    {\n      var next = edge1.NextInSEL;\n      var prev = edge1.PrevInSEL;\n      edge1.NextInSEL = edge2.NextInSEL;\n      if (edge1.NextInSEL !== null)\n        edge1.NextInSEL.PrevInSEL = edge1;\n      edge1.PrevInSEL = edge2.PrevInSEL;\n      if (edge1.PrevInSEL !== null)\n        edge1.PrevInSEL.NextInSEL = edge1;\n      edge2.NextInSEL = next;\n      if (edge2.NextInSEL !== null)\n        edge2.NextInSEL.PrevInSEL = edge2;\n      edge2.PrevInSEL = prev;\n      if (edge2.PrevInSEL !== null)\n        edge2.PrevInSEL.NextInSEL = edge2;\n    }\n    if (edge1.PrevInSEL === null)\n      this.m_SortedEdges = edge1;\n    else if (edge2.PrevInSEL === null)\n      this.m_SortedEdges = edge2;\n  };\n  ClipperLib.Clipper.prototype.AddLocalMaxPoly = function (e1, e2, pt)\n  {\n    this.AddOutPt(e1, pt);\n    if (e2.WindDelta == 0) this.AddOutPt(e2, pt);\n    if (e1.OutIdx == e2.OutIdx)\n    {\n      e1.OutIdx = -1;\n      e2.OutIdx = -1;\n    }\n    else if (e1.OutIdx < e2.OutIdx)\n      this.AppendPolygon(e1, e2);\n    else\n      this.AppendPolygon(e2, e1);\n  };\n  ClipperLib.Clipper.prototype.AddLocalMinPoly = function (e1, e2, pt)\n  {\n    var result;\n    var e, prevE;\n    if (ClipperLib.ClipperBase.IsHorizontal(e2) || (e1.Dx > e2.Dx))\n    {\n      result = this.AddOutPt(e1, pt);\n      e2.OutIdx = e1.OutIdx;\n      e1.Side = ClipperLib.EdgeSide.esLeft;\n      e2.Side = ClipperLib.EdgeSide.esRight;\n      e = e1;\n      if (e.PrevInAEL == e2)\n        prevE = e2.PrevInAEL;\n      else\n        prevE = e.PrevInAEL;\n    }\n    else\n    {\n      result = this.AddOutPt(e2, pt);\n      e1.OutIdx = e2.OutIdx;\n      e1.Side = ClipperLib.EdgeSide.esRight;\n      e2.Side = ClipperLib.EdgeSide.esLeft;\n      e = e2;\n      if (e.PrevInAEL == e1)\n        prevE = e1.PrevInAEL;\n      else\n        prevE = e.PrevInAEL;\n    }\n    if (prevE !== null && prevE.OutIdx >= 0 && (ClipperLib.Clipper.TopX(prevE, pt.Y) == ClipperLib.Clipper.TopX(e, pt.Y)) && ClipperLib.ClipperBase.SlopesEqual(e, prevE, this.m_UseFullRange) && (e.WindDelta !== 0) && (prevE.WindDelta !== 0))\n    {\n      var outPt = this.AddOutPt(prevE, pt);\n      this.AddJoin(result, outPt, e.Top);\n    }\n    return result;\n  };\n  ClipperLib.Clipper.prototype.CreateOutRec = function ()\n  {\n    var result = new ClipperLib.OutRec();\n    result.Idx = -1;\n    result.IsHole = false;\n    result.IsOpen = false;\n    result.FirstLeft = null;\n    result.Pts = null;\n    result.BottomPt = null;\n    result.PolyNode = null;\n    this.m_PolyOuts.push(result);\n    result.Idx = this.m_PolyOuts.length - 1;\n    return result;\n  };\n  ClipperLib.Clipper.prototype.AddOutPt = function (e, pt)\n  {\n    var ToFront = (e.Side == ClipperLib.EdgeSide.esLeft);\n    if (e.OutIdx < 0)\n    {\n      var outRec = this.CreateOutRec();\n      outRec.IsOpen = (e.WindDelta === 0);\n      var newOp = new ClipperLib.OutPt();\n      outRec.Pts = newOp;\n      newOp.Idx = outRec.Idx;\n      //newOp.Pt = pt;\n      newOp.Pt.X = pt.X;\n      newOp.Pt.Y = pt.Y;\n      newOp.Next = newOp;\n      newOp.Prev = newOp;\n      if (!outRec.IsOpen)\n        this.SetHoleState(e, outRec);\n      e.OutIdx = outRec.Idx;\n      //nb: do this after SetZ !\n      return newOp;\n    }\n    else\n    {\n      var outRec = this.m_PolyOuts[e.OutIdx];\n      //OutRec.Pts is the 'Left-most' point & OutRec.Pts.Prev is the 'Right-most'\n      var op = outRec.Pts;\n      if (ToFront && ClipperLib.IntPoint.op_Equality(pt, op.Pt))\n        return op;\n      else if (!ToFront && ClipperLib.IntPoint.op_Equality(pt, op.Prev.Pt))\n        return op.Prev;\n      var newOp = new ClipperLib.OutPt();\n      newOp.Idx = outRec.Idx;\n      //newOp.Pt = pt;\n      newOp.Pt.X = pt.X;\n      newOp.Pt.Y = pt.Y;\n      newOp.Next = op;\n      newOp.Prev = op.Prev;\n      newOp.Prev.Next = newOp;\n      op.Prev = newOp;\n      if (ToFront)\n        outRec.Pts = newOp;\n      return newOp;\n    }\n  };\n  ClipperLib.Clipper.prototype.SwapPoints = function (pt1, pt2)\n  {\n    var tmp = new ClipperLib.IntPoint(pt1.Value);\n    //pt1.Value = pt2.Value;\n    pt1.Value.X = pt2.Value.X;\n    pt1.Value.Y = pt2.Value.Y;\n    //pt2.Value = tmp;\n    pt2.Value.X = tmp.X;\n    pt2.Value.Y = tmp.Y;\n  };\n  ClipperLib.Clipper.prototype.HorzSegmentsOverlap = function (seg1a, seg1b, seg2a, seg2b)\n\t{\n\t\tvar tmp;\n\t\tif (seg1a > seg1b)\n\t\t{\n\t\t\ttmp = seg1a;\n\t\t\tseg1a = seg1b;\n\t\t\tseg1b = tmp;\n\t\t}\n\t\tif (seg2a > seg2b)\n\t\t{\n\t\t\ttmp = seg2a;\n\t\t\tseg2a = seg2b;\n\t\t\tseg2b = tmp;\n\t\t}\n\t\treturn (seg1a < seg2b) && (seg2a < seg1b);\n\t}\n\n  ClipperLib.Clipper.prototype.SetHoleState = function (e, outRec)\n  {\n    var isHole = false;\n    var e2 = e.PrevInAEL;\n    while (e2 !== null)\n    {\n      if (e2.OutIdx >= 0 && e2.WindDelta != 0)\n      {\n        isHole = !isHole;\n        if (outRec.FirstLeft === null)\n          outRec.FirstLeft = this.m_PolyOuts[e2.OutIdx];\n      }\n      e2 = e2.PrevInAEL;\n    }\n    if (isHole)\n      outRec.IsHole = true;\n  };\n  ClipperLib.Clipper.prototype.GetDx = function (pt1, pt2)\n  {\n    if (pt1.Y == pt2.Y)\n      return ClipperLib.ClipperBase.horizontal;\n    else\n      return (pt2.X - pt1.X) / (pt2.Y - pt1.Y);\n  };\n  ClipperLib.Clipper.prototype.FirstIsBottomPt = function (btmPt1, btmPt2)\n  {\n    var p = btmPt1.Prev;\n    while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt1.Pt)) && (p != btmPt1))\n      p = p.Prev;\n    var dx1p = Math.abs(this.GetDx(btmPt1.Pt, p.Pt));\n    p = btmPt1.Next;\n    while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt1.Pt)) && (p != btmPt1))\n      p = p.Next;\n    var dx1n = Math.abs(this.GetDx(btmPt1.Pt, p.Pt));\n    p = btmPt2.Prev;\n    while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt2.Pt)) && (p != btmPt2))\n      p = p.Prev;\n    var dx2p = Math.abs(this.GetDx(btmPt2.Pt, p.Pt));\n    p = btmPt2.Next;\n    while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt2.Pt)) && (p != btmPt2))\n      p = p.Next;\n    var dx2n = Math.abs(this.GetDx(btmPt2.Pt, p.Pt));\n    return (dx1p >= dx2p && dx1p >= dx2n) || (dx1n >= dx2p && dx1n >= dx2n);\n  };\n  ClipperLib.Clipper.prototype.GetBottomPt = function (pp)\n  {\n    var dups = null;\n    var p = pp.Next;\n    while (p != pp)\n    {\n      if (p.Pt.Y > pp.Pt.Y)\n      {\n        pp = p;\n        dups = null;\n      }\n      else if (p.Pt.Y == pp.Pt.Y && p.Pt.X <= pp.Pt.X)\n      {\n        if (p.Pt.X < pp.Pt.X)\n        {\n          dups = null;\n          pp = p;\n        }\n        else\n        {\n          if (p.Next != pp && p.Prev != pp)\n            dups = p;\n        }\n      }\n      p = p.Next;\n    }\n    if (dups !== null)\n    {\n      //there appears to be at least 2 vertices at bottomPt so ...\n      while (dups != p)\n      {\n        if (!this.FirstIsBottomPt(p, dups))\n          pp = dups;\n        dups = dups.Next;\n        while (ClipperLib.IntPoint.op_Inequality(dups.Pt, pp.Pt))\n          dups = dups.Next;\n      }\n    }\n    return pp;\n  };\n  ClipperLib.Clipper.prototype.GetLowermostRec = function (outRec1, outRec2)\n  {\n    //work out which polygon fragment has the correct hole state ...\n    if (outRec1.BottomPt === null)\n      outRec1.BottomPt = this.GetBottomPt(outRec1.Pts);\n    if (outRec2.BottomPt === null)\n      outRec2.BottomPt = this.GetBottomPt(outRec2.Pts);\n    var bPt1 = outRec1.BottomPt;\n    var bPt2 = outRec2.BottomPt;\n    if (bPt1.Pt.Y > bPt2.Pt.Y)\n      return outRec1;\n    else if (bPt1.Pt.Y < bPt2.Pt.Y)\n      return outRec2;\n    else if (bPt1.Pt.X < bPt2.Pt.X)\n      return outRec1;\n    else if (bPt1.Pt.X > bPt2.Pt.X)\n      return outRec2;\n    else if (bPt1.Next == bPt1)\n      return outRec2;\n    else if (bPt2.Next == bPt2)\n      return outRec1;\n    else if (this.FirstIsBottomPt(bPt1, bPt2))\n      return outRec1;\n    else\n      return outRec2;\n  };\n  ClipperLib.Clipper.prototype.Param1RightOfParam2 = function (outRec1, outRec2)\n  {\n    do {\n      outRec1 = outRec1.FirstLeft;\n      if (outRec1 == outRec2)\n        return true;\n    }\n    while (outRec1 !== null)\n    return false;\n  };\n  ClipperLib.Clipper.prototype.GetOutRec = function (idx)\n  {\n    var outrec = this.m_PolyOuts[idx];\n    while (outrec != this.m_PolyOuts[outrec.Idx])\n      outrec = this.m_PolyOuts[outrec.Idx];\n    return outrec;\n  };\n  ClipperLib.Clipper.prototype.AppendPolygon = function (e1, e2)\n  {\n    //get the start and ends of both output polygons ...\n    var outRec1 = this.m_PolyOuts[e1.OutIdx];\n    var outRec2 = this.m_PolyOuts[e2.OutIdx];\n    var holeStateRec;\n    if (this.Param1RightOfParam2(outRec1, outRec2))\n      holeStateRec = outRec2;\n    else if (this.Param1RightOfParam2(outRec2, outRec1))\n      holeStateRec = outRec1;\n    else\n      holeStateRec = this.GetLowermostRec(outRec1, outRec2);\n    var p1_lft = outRec1.Pts;\n    var p1_rt = p1_lft.Prev;\n    var p2_lft = outRec2.Pts;\n    var p2_rt = p2_lft.Prev;\n    var side;\n    //join e2 poly onto e1 poly and delete pointers to e2 ...\n    if (e1.Side == ClipperLib.EdgeSide.esLeft)\n    {\n      if (e2.Side == ClipperLib.EdgeSide.esLeft)\n      {\n        //z y x a b c\n        this.ReversePolyPtLinks(p2_lft);\n        p2_lft.Next = p1_lft;\n        p1_lft.Prev = p2_lft;\n        p1_rt.Next = p2_rt;\n        p2_rt.Prev = p1_rt;\n        outRec1.Pts = p2_rt;\n      }\n      else\n      {\n        //x y z a b c\n        p2_rt.Next = p1_lft;\n        p1_lft.Prev = p2_rt;\n        p2_lft.Prev = p1_rt;\n        p1_rt.Next = p2_lft;\n        outRec1.Pts = p2_lft;\n      }\n      side = ClipperLib.EdgeSide.esLeft;\n    }\n    else\n    {\n      if (e2.Side == ClipperLib.EdgeSide.esRight)\n      {\n        //a b c z y x\n        this.ReversePolyPtLinks(p2_lft);\n        p1_rt.Next = p2_rt;\n        p2_rt.Prev = p1_rt;\n        p2_lft.Next = p1_lft;\n        p1_lft.Prev = p2_lft;\n      }\n      else\n      {\n        //a b c x y z\n        p1_rt.Next = p2_lft;\n        p2_lft.Prev = p1_rt;\n        p1_lft.Prev = p2_rt;\n        p2_rt.Next = p1_lft;\n      }\n      side = ClipperLib.EdgeSide.esRight;\n    }\n    outRec1.BottomPt = null;\n    if (holeStateRec == outRec2)\n    {\n      if (outRec2.FirstLeft != outRec1)\n        outRec1.FirstLeft = outRec2.FirstLeft;\n      outRec1.IsHole = outRec2.IsHole;\n    }\n    outRec2.Pts = null;\n    outRec2.BottomPt = null;\n    outRec2.FirstLeft = outRec1;\n    var OKIdx = e1.OutIdx;\n    var ObsoleteIdx = e2.OutIdx;\n    e1.OutIdx = -1;\n    //nb: safe because we only get here via AddLocalMaxPoly\n    e2.OutIdx = -1;\n    var e = this.m_ActiveEdges;\n    while (e !== null)\n    {\n      if (e.OutIdx == ObsoleteIdx)\n      {\n        e.OutIdx = OKIdx;\n        e.Side = side;\n        break;\n      }\n      e = e.NextInAEL;\n    }\n    outRec2.Idx = outRec1.Idx;\n  };\n  ClipperLib.Clipper.prototype.ReversePolyPtLinks = function (pp)\n  {\n    if (pp === null)\n      return;\n    var pp1;\n    var pp2;\n    pp1 = pp;\n    do {\n      pp2 = pp1.Next;\n      pp1.Next = pp1.Prev;\n      pp1.Prev = pp2;\n      pp1 = pp2;\n    }\n    while (pp1 != pp)\n  };\n  ClipperLib.Clipper.SwapSides = function (edge1, edge2)\n  {\n    var side = edge1.Side;\n    edge1.Side = edge2.Side;\n    edge2.Side = side;\n  };\n  ClipperLib.Clipper.SwapPolyIndexes = function (edge1, edge2)\n  {\n    var outIdx = edge1.OutIdx;\n    edge1.OutIdx = edge2.OutIdx;\n    edge2.OutIdx = outIdx;\n  };\n  ClipperLib.Clipper.prototype.IntersectEdges = function (e1, e2, pt)\n  {\n    //e1 will be to the left of e2 BELOW the intersection. Therefore e1 is before\n    //e2 in AEL except when e1 is being inserted at the intersection point ...\n    var e1Contributing = (e1.OutIdx >= 0);\n    var e2Contributing = (e2.OutIdx >= 0);\n\n    if (use_xyz)\n    \tthis.SetZ(pt, e1, e2);\n\n    if (use_lines)\n    {\n      //if either edge is on an OPEN path ...\n      if (e1.WindDelta === 0 || e2.WindDelta === 0)\n      {\n        //ignore subject-subject open path intersections UNLESS they\n        //are both open paths, AND they are both 'contributing maximas' ...\n\t\t\t\tif (e1.WindDelta == 0 && e2.WindDelta == 0) return;\n        //if intersecting a subj line with a subj poly ...\n        else if (e1.PolyTyp == e2.PolyTyp &&\n          e1.WindDelta != e2.WindDelta && this.m_ClipType == ClipperLib.ClipType.ctUnion)\n        {\n          if (e1.WindDelta === 0)\n          {\n            if (e2Contributing)\n            {\n              this.AddOutPt(e1, pt);\n              if (e1Contributing)\n                e1.OutIdx = -1;\n            }\n          }\n          else\n          {\n            if (e1Contributing)\n            {\n              this.AddOutPt(e2, pt);\n              if (e2Contributing)\n                e2.OutIdx = -1;\n            }\n          }\n        }\n        else if (e1.PolyTyp != e2.PolyTyp)\n        {\n          if ((e1.WindDelta === 0) && Math.abs(e2.WindCnt) == 1 &&\n            (this.m_ClipType != ClipperLib.ClipType.ctUnion || e2.WindCnt2 === 0))\n          {\n            this.AddOutPt(e1, pt);\n            if (e1Contributing)\n              e1.OutIdx = -1;\n          }\n          else if ((e2.WindDelta === 0) && (Math.abs(e1.WindCnt) == 1) &&\n            (this.m_ClipType != ClipperLib.ClipType.ctUnion || e1.WindCnt2 === 0))\n          {\n            this.AddOutPt(e2, pt);\n            if (e2Contributing)\n              e2.OutIdx = -1;\n          }\n        }\n        return;\n      }\n    }\n    //update winding counts...\n    //assumes that e1 will be to the Right of e2 ABOVE the intersection\n    if (e1.PolyTyp == e2.PolyTyp)\n    {\n      if (this.IsEvenOddFillType(e1))\n      {\n        var oldE1WindCnt = e1.WindCnt;\n        e1.WindCnt = e2.WindCnt;\n        e2.WindCnt = oldE1WindCnt;\n      }\n      else\n      {\n        if (e1.WindCnt + e2.WindDelta === 0)\n          e1.WindCnt = -e1.WindCnt;\n        else\n          e1.WindCnt += e2.WindDelta;\n        if (e2.WindCnt - e1.WindDelta === 0)\n          e2.WindCnt = -e2.WindCnt;\n        else\n          e2.WindCnt -= e1.WindDelta;\n      }\n    }\n    else\n    {\n      if (!this.IsEvenOddFillType(e2))\n        e1.WindCnt2 += e2.WindDelta;\n      else\n        e1.WindCnt2 = (e1.WindCnt2 === 0) ? 1 : 0;\n      if (!this.IsEvenOddFillType(e1))\n        e2.WindCnt2 -= e1.WindDelta;\n      else\n        e2.WindCnt2 = (e2.WindCnt2 === 0) ? 1 : 0;\n    }\n    var e1FillType, e2FillType, e1FillType2, e2FillType2;\n    if (e1.PolyTyp == ClipperLib.PolyType.ptSubject)\n    {\n      e1FillType = this.m_SubjFillType;\n      e1FillType2 = this.m_ClipFillType;\n    }\n    else\n    {\n      e1FillType = this.m_ClipFillType;\n      e1FillType2 = this.m_SubjFillType;\n    }\n    if (e2.PolyTyp == ClipperLib.PolyType.ptSubject)\n    {\n      e2FillType = this.m_SubjFillType;\n      e2FillType2 = this.m_ClipFillType;\n    }\n    else\n    {\n      e2FillType = this.m_ClipFillType;\n      e2FillType2 = this.m_SubjFillType;\n    }\n    var e1Wc, e2Wc;\n    switch (e1FillType)\n    {\n    case ClipperLib.PolyFillType.pftPositive:\n      e1Wc = e1.WindCnt;\n      break;\n    case ClipperLib.PolyFillType.pftNegative:\n      e1Wc = -e1.WindCnt;\n      break;\n    default:\n      e1Wc = Math.abs(e1.WindCnt);\n      break;\n    }\n    switch (e2FillType)\n    {\n    case ClipperLib.PolyFillType.pftPositive:\n      e2Wc = e2.WindCnt;\n      break;\n    case ClipperLib.PolyFillType.pftNegative:\n      e2Wc = -e2.WindCnt;\n      break;\n    default:\n      e2Wc = Math.abs(e2.WindCnt);\n      break;\n    }\n    if (e1Contributing && e2Contributing)\n    {\n\t\t\tif ((e1Wc != 0 && e1Wc != 1) || (e2Wc != 0 && e2Wc != 1) ||\n\t\t\t(e1.PolyTyp != e2.PolyTyp && this.m_ClipType != ClipperLib.ClipType.ctXor))\n\t\t\t{\n\t\t\t\tthis.AddLocalMaxPoly(e1, e2, pt);\n\t\t\t}\n      else\n      {\n        this.AddOutPt(e1, pt);\n        this.AddOutPt(e2, pt);\n        ClipperLib.Clipper.SwapSides(e1, e2);\n        ClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n      }\n    }\n    else if (e1Contributing)\n    {\n      if (e2Wc === 0 || e2Wc == 1)\n      {\n        this.AddOutPt(e1, pt);\n        ClipperLib.Clipper.SwapSides(e1, e2);\n        ClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n      }\n    }\n    else if (e2Contributing)\n    {\n      if (e1Wc === 0 || e1Wc == 1)\n      {\n        this.AddOutPt(e2, pt);\n        ClipperLib.Clipper.SwapSides(e1, e2);\n        ClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n      }\n    }\n\t\telse if ( (e1Wc == 0 || e1Wc == 1) && (e2Wc == 0 || e2Wc == 1))\n    {\n      //neither edge is currently contributing ...\n      var e1Wc2, e2Wc2;\n      switch (e1FillType2)\n      {\n      case ClipperLib.PolyFillType.pftPositive:\n        e1Wc2 = e1.WindCnt2;\n        break;\n      case ClipperLib.PolyFillType.pftNegative:\n        e1Wc2 = -e1.WindCnt2;\n        break;\n      default:\n        e1Wc2 = Math.abs(e1.WindCnt2);\n        break;\n      }\n      switch (e2FillType2)\n      {\n      case ClipperLib.PolyFillType.pftPositive:\n        e2Wc2 = e2.WindCnt2;\n        break;\n      case ClipperLib.PolyFillType.pftNegative:\n        e2Wc2 = -e2.WindCnt2;\n        break;\n      default:\n        e2Wc2 = Math.abs(e2.WindCnt2);\n        break;\n      }\n      if (e1.PolyTyp != e2.PolyTyp)\n      {\n        this.AddLocalMinPoly(e1, e2, pt);\n      }\n      else if (e1Wc == 1 && e2Wc == 1)\n        switch (this.m_ClipType)\n        {\n        case ClipperLib.ClipType.ctIntersection:\n          if (e1Wc2 > 0 && e2Wc2 > 0)\n            this.AddLocalMinPoly(e1, e2, pt);\n          break;\n        case ClipperLib.ClipType.ctUnion:\n          if (e1Wc2 <= 0 && e2Wc2 <= 0)\n            this.AddLocalMinPoly(e1, e2, pt);\n          break;\n        case ClipperLib.ClipType.ctDifference:\n          if (((e1.PolyTyp == ClipperLib.PolyType.ptClip) && (e1Wc2 > 0) && (e2Wc2 > 0)) ||\n            ((e1.PolyTyp == ClipperLib.PolyType.ptSubject) && (e1Wc2 <= 0) && (e2Wc2 <= 0)))\n            this.AddLocalMinPoly(e1, e2, pt);\n          break;\n        case ClipperLib.ClipType.ctXor:\n          this.AddLocalMinPoly(e1, e2, pt);\n          break;\n        }\n      else\n        ClipperLib.Clipper.SwapSides(e1, e2);\n    }\n  };\n  ClipperLib.Clipper.prototype.DeleteFromAEL = function (e)\n  {\n    var AelPrev = e.PrevInAEL;\n    var AelNext = e.NextInAEL;\n    if (AelPrev === null && AelNext === null && (e != this.m_ActiveEdges))\n      return;\n    //already deleted\n    if (AelPrev !== null)\n      AelPrev.NextInAEL = AelNext;\n    else\n      this.m_ActiveEdges = AelNext;\n    if (AelNext !== null)\n      AelNext.PrevInAEL = AelPrev;\n    e.NextInAEL = null;\n    e.PrevInAEL = null;\n  };\n  ClipperLib.Clipper.prototype.DeleteFromSEL = function (e)\n  {\n    var SelPrev = e.PrevInSEL;\n    var SelNext = e.NextInSEL;\n    if (SelPrev === null && SelNext === null && (e != this.m_SortedEdges))\n      return;\n    //already deleted\n    if (SelPrev !== null)\n      SelPrev.NextInSEL = SelNext;\n    else\n      this.m_SortedEdges = SelNext;\n    if (SelNext !== null)\n      SelNext.PrevInSEL = SelPrev;\n    e.NextInSEL = null;\n    e.PrevInSEL = null;\n  };\n  ClipperLib.Clipper.prototype.UpdateEdgeIntoAEL = function (e)\n  {\n    if (e.NextInLML === null)\n      ClipperLib.Error(\"UpdateEdgeIntoAEL: invalid call\");\n    var AelPrev = e.PrevInAEL;\n    var AelNext = e.NextInAEL;\n    e.NextInLML.OutIdx = e.OutIdx;\n    if (AelPrev !== null)\n      AelPrev.NextInAEL = e.NextInLML;\n    else\n      this.m_ActiveEdges = e.NextInLML;\n    if (AelNext !== null)\n      AelNext.PrevInAEL = e.NextInLML;\n    e.NextInLML.Side = e.Side;\n    e.NextInLML.WindDelta = e.WindDelta;\n    e.NextInLML.WindCnt = e.WindCnt;\n    e.NextInLML.WindCnt2 = e.WindCnt2;\n    e = e.NextInLML;\n    //    e.Curr = e.Bot;\n    e.Curr.X = e.Bot.X;\n    e.Curr.Y = e.Bot.Y;\n    e.PrevInAEL = AelPrev;\n    e.NextInAEL = AelNext;\n    if (!ClipperLib.ClipperBase.IsHorizontal(e))\n      this.InsertScanbeam(e.Top.Y);\n    return e;\n  };\n  ClipperLib.Clipper.prototype.ProcessHorizontals = function (isTopOfScanbeam)\n  {\n    var horzEdge = this.m_SortedEdges;\n    while (horzEdge !== null)\n    {\n      this.DeleteFromSEL(horzEdge);\n      this.ProcessHorizontal(horzEdge, isTopOfScanbeam);\n      horzEdge = this.m_SortedEdges;\n    }\n  };\n  ClipperLib.Clipper.prototype.GetHorzDirection = function (HorzEdge, $var)\n  {\n    if (HorzEdge.Bot.X < HorzEdge.Top.X)\n    {\n        $var.Left = HorzEdge.Bot.X;\n        $var.Right = HorzEdge.Top.X;\n        $var.Dir = ClipperLib.Direction.dLeftToRight;\n    }\n    else\n    {\n        $var.Left = HorzEdge.Top.X;\n        $var.Right = HorzEdge.Bot.X;\n        $var.Dir = ClipperLib.Direction.dRightToLeft;\n    }\n  };\n  ClipperLib.Clipper.prototype.ProcessHorizontal = function (horzEdge, isTopOfScanbeam)\n  {\n    var $var = {Dir: null, Left: null, Right: null};\n    this.GetHorzDirection(horzEdge, $var);\n    var dir = $var.Dir;\n    var horzLeft = $var.Left;\n    var horzRight = $var.Right;\n\n    var eLastHorz = horzEdge,\n      eMaxPair = null;\n    while (eLastHorz.NextInLML !== null && ClipperLib.ClipperBase.IsHorizontal(eLastHorz.NextInLML))\n      eLastHorz = eLastHorz.NextInLML;\n    if (eLastHorz.NextInLML === null)\n      eMaxPair = this.GetMaximaPair(eLastHorz);\n    for (;;)\n    {\n      var IsLastHorz = (horzEdge == eLastHorz);\n      var e = this.GetNextInAEL(horzEdge, dir);\n      while (e !== null)\n      {\n        //Break if we've got to the end of an intermediate horizontal edge ...\n        //nb: Smaller Dx's are to the right of larger Dx's ABOVE the horizontal.\n        if (e.Curr.X == horzEdge.Top.X && horzEdge.NextInLML !== null && e.Dx < horzEdge.NextInLML.Dx)\n          break;\n        var eNext = this.GetNextInAEL(e, dir);\n        //saves eNext for later\n        if ((dir == ClipperLib.Direction.dLeftToRight && e.Curr.X <= horzRight) || (dir == ClipperLib.Direction.dRightToLeft && e.Curr.X >= horzLeft))\n        {\n          //so far we're still in range of the horizontal Edge  but make sure\n          //we're at the last of consec. horizontals when matching with eMaxPair\n          if (e == eMaxPair && IsLastHorz)\n          {\n\t\t\t\t\t\tif (horzEdge.OutIdx >= 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar op1 = this.AddOutPt(horzEdge, horzEdge.Top);\n\t\t\t\t\t\t\tvar eNextHorz = this.m_SortedEdges;\n\t\t\t\t\t\t\twhile (eNextHorz !== null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (eNextHorz.OutIdx >= 0 &&\n\t\t\t\t\t\t\t\t\tthis.HorzSegmentsOverlap(horzEdge.Bot.X,\n\t\t\t\t\t\t\t\t\thorzEdge.Top.X, eNextHorz.Bot.X, eNextHorz.Top.X))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tvar op2 = this.AddOutPt(eNextHorz, eNextHorz.Bot);\n\t\t\t\t\t\t\t\t\tthis.AddJoin(op2, op1, eNextHorz.Top);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\teNextHorz = eNextHorz.NextInSEL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis.AddGhostJoin(op1, horzEdge.Bot);\n\t\t\t\t\t\t\tthis.AddLocalMaxPoly(horzEdge, eMaxPair, horzEdge.Top);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.DeleteFromAEL(horzEdge);\n\t\t\t\t\t\tthis.DeleteFromAEL(eMaxPair);\n            return;\n          }\n          else if (dir == ClipperLib.Direction.dLeftToRight)\n          {\n            var Pt = new ClipperLib.IntPoint(e.Curr.X, horzEdge.Curr.Y);\n            this.IntersectEdges(horzEdge, e, Pt);\n          }\n          else\n          {\n            var Pt = new ClipperLib.IntPoint(e.Curr.X, horzEdge.Curr.Y);\n            this.IntersectEdges(e, horzEdge, Pt);\n          }\n          this.SwapPositionsInAEL(horzEdge, e);\n        }\n        else if ((dir == ClipperLib.Direction.dLeftToRight && e.Curr.X >= horzRight) || (dir == ClipperLib.Direction.dRightToLeft && e.Curr.X <= horzLeft))\n          break;\n        e = eNext;\n      }\n      //end while\n      if (horzEdge.NextInLML !== null && ClipperLib.ClipperBase.IsHorizontal(horzEdge.NextInLML))\n      {\n        horzEdge = this.UpdateEdgeIntoAEL(horzEdge);\n        if (horzEdge.OutIdx >= 0)\n          this.AddOutPt(horzEdge, horzEdge.Bot);\n\n          var $var = {Dir: dir, Left: horzLeft, Right: horzRight};\n          this.GetHorzDirection(horzEdge, $var);\n          dir = $var.Dir;\n          horzLeft = $var.Left;\n          horzRight = $var.Right;\n      }\n      else\n        break;\n    }\n    //end for (;;)\n    if (horzEdge.NextInLML !== null)\n    {\n      if (horzEdge.OutIdx >= 0)\n      {\n        var op1 = this.AddOutPt(horzEdge, horzEdge.Top);\n\t\t\t\tif (isTopOfScanbeam) this.AddGhostJoin(op1, horzEdge.Bot);\n        horzEdge = this.UpdateEdgeIntoAEL(horzEdge);\n        if (horzEdge.WindDelta === 0)\n          return;\n        //nb: HorzEdge is no longer horizontal here\n        var ePrev = horzEdge.PrevInAEL;\n        var eNext = horzEdge.NextInAEL;\n        if (ePrev !== null && ePrev.Curr.X == horzEdge.Bot.X &&\n          ePrev.Curr.Y == horzEdge.Bot.Y && ePrev.WindDelta !== 0 &&\n          (ePrev.OutIdx >= 0 && ePrev.Curr.Y > ePrev.Top.Y &&\n            ClipperLib.ClipperBase.SlopesEqual(horzEdge, ePrev, this.m_UseFullRange)))\n        {\n          var op2 = this.AddOutPt(ePrev, horzEdge.Bot);\n          this.AddJoin(op1, op2, horzEdge.Top);\n        }\n        else if (eNext !== null && eNext.Curr.X == horzEdge.Bot.X &&\n          eNext.Curr.Y == horzEdge.Bot.Y && eNext.WindDelta !== 0 &&\n          eNext.OutIdx >= 0 && eNext.Curr.Y > eNext.Top.Y &&\n          ClipperLib.ClipperBase.SlopesEqual(horzEdge, eNext, this.m_UseFullRange))\n        {\n          var op2 = this.AddOutPt(eNext, horzEdge.Bot);\n          this.AddJoin(op1, op2, horzEdge.Top);\n        }\n      }\n      else horzEdge = this.UpdateEdgeIntoAEL(horzEdge);\n    }\n  \telse\n    {\n      if (horzEdge.OutIdx >= 0)\n        this.AddOutPt(horzEdge, horzEdge.Top);\n      this.DeleteFromAEL(horzEdge);\n    }\n  };\n  ClipperLib.Clipper.prototype.GetNextInAEL = function (e, Direction)\n  {\n    return Direction == ClipperLib.Direction.dLeftToRight ? e.NextInAEL : e.PrevInAEL;\n  };\n  ClipperLib.Clipper.prototype.IsMinima = function (e)\n  {\n    return e !== null && (e.Prev.NextInLML != e) && (e.Next.NextInLML != e);\n  };\n  ClipperLib.Clipper.prototype.IsMaxima = function (e, Y)\n  {\n    return (e !== null && e.Top.Y == Y && e.NextInLML === null);\n  };\n  ClipperLib.Clipper.prototype.IsIntermediate = function (e, Y)\n  {\n    return (e.Top.Y == Y && e.NextInLML !== null);\n  };\n  ClipperLib.Clipper.prototype.GetMaximaPair = function (e)\n  {\n    var result = null;\n    if ((ClipperLib.IntPoint.op_Equality(e.Next.Top, e.Top)) && e.Next.NextInLML === null)\n      result = e.Next;\n    else if ((ClipperLib.IntPoint.op_Equality(e.Prev.Top, e.Top)) && e.Prev.NextInLML === null)\n      result = e.Prev;\n    if (result !== null && (result.OutIdx == -2 || (result.NextInAEL == result.PrevInAEL && !ClipperLib.ClipperBase.IsHorizontal(result))))\n      return null;\n    return result;\n  };\n\n  ClipperLib.Clipper.prototype.ProcessIntersections = function (topY)\n  {\n    if (this.m_ActiveEdges == null)\n      return true;\n    try\n    {\n      this.BuildIntersectList(topY);\n      if (this.m_IntersectList.length == 0)\n        return true;\n      if (this.m_IntersectList.length == 1 || this.FixupIntersectionOrder())\n        this.ProcessIntersectList();\n      else\n        return false;\n    }\n    catch ($$e2)\n    {\n      this.m_SortedEdges = null;\n      this.m_IntersectList.length = 0;\n      ClipperLib.Error(\"ProcessIntersections error\");\n    }\n    this.m_SortedEdges = null;\n    return true;\n  };\n  ClipperLib.Clipper.prototype.BuildIntersectList = function (topY)\n  {\n    if (this.m_ActiveEdges === null)\n      return;\n    //prepare for sorting ...\n    var e = this.m_ActiveEdges;\n    //console.log(JSON.stringify(JSON.decycle( e )));\n    this.m_SortedEdges = e;\n    while (e !== null)\n    {\n      e.PrevInSEL = e.PrevInAEL;\n      e.NextInSEL = e.NextInAEL;\n      e.Curr.X = ClipperLib.Clipper.TopX(e, topY);\n      e = e.NextInAEL;\n    }\n    //bubblesort ...\n    var isModified = true;\n    while (isModified && this.m_SortedEdges !== null)\n    {\n      isModified = false;\n      e = this.m_SortedEdges;\n      while (e.NextInSEL !== null)\n      {\n        var eNext = e.NextInSEL;\n        var pt = new ClipperLib.IntPoint();\n        //console.log(\"e.Curr.X: \" + e.Curr.X + \" eNext.Curr.X\" + eNext.Curr.X);\n        if (e.Curr.X > eNext.Curr.X)\n        {\n\t\t\t\t\tthis.IntersectPoint(e, eNext, pt);\n          var newNode = new ClipperLib.IntersectNode();\n          newNode.Edge1 = e;\n          newNode.Edge2 = eNext;\n          //newNode.Pt = pt;\n          newNode.Pt.X = pt.X;\n          newNode.Pt.Y = pt.Y;\n          this.m_IntersectList.push(newNode);\n          this.SwapPositionsInSEL(e, eNext);\n          isModified = true;\n        }\n        else\n          e = eNext;\n      }\n      if (e.PrevInSEL !== null)\n        e.PrevInSEL.NextInSEL = null;\n      else\n        break;\n    }\n    this.m_SortedEdges = null;\n  };\n  ClipperLib.Clipper.prototype.EdgesAdjacent = function (inode)\n  {\n    return (inode.Edge1.NextInSEL == inode.Edge2) || (inode.Edge1.PrevInSEL == inode.Edge2);\n  };\n  ClipperLib.Clipper.IntersectNodeSort = function (node1, node2)\n  {\n    //the following typecast is safe because the differences in Pt.Y will\n    //be limited to the height of the scanbeam.\n    return (node2.Pt.Y - node1.Pt.Y);\n  };\n  ClipperLib.Clipper.prototype.FixupIntersectionOrder = function ()\n  {\n    //pre-condition: intersections are sorted bottom-most first.\n    //Now it's crucial that intersections are made only between adjacent edges,\n    //so to ensure this the order of intersections may need adjusting ...\n    this.m_IntersectList.sort(this.m_IntersectNodeComparer);\n    this.CopyAELToSEL();\n    var cnt = this.m_IntersectList.length;\n    for (var i = 0; i < cnt; i++)\n    {\n      if (!this.EdgesAdjacent(this.m_IntersectList[i]))\n      {\n        var j = i + 1;\n        while (j < cnt && !this.EdgesAdjacent(this.m_IntersectList[j]))\n          j++;\n        if (j == cnt)\n          return false;\n        var tmp = this.m_IntersectList[i];\n        this.m_IntersectList[i] = this.m_IntersectList[j];\n        this.m_IntersectList[j] = tmp;\n      }\n      this.SwapPositionsInSEL(this.m_IntersectList[i].Edge1, this.m_IntersectList[i].Edge2);\n    }\n    return true;\n  };\n  ClipperLib.Clipper.prototype.ProcessIntersectList = function ()\n  {\n    for (var i = 0, ilen = this.m_IntersectList.length; i < ilen; i++)\n    {\n      var iNode = this.m_IntersectList[i];\n      this.IntersectEdges(iNode.Edge1, iNode.Edge2, iNode.Pt);\n      this.SwapPositionsInAEL(iNode.Edge1, iNode.Edge2);\n    }\n    this.m_IntersectList.length = 0;\n  };\n  /*\n  --------------------------------\n  Round speedtest: http://jsperf.com/fastest-round\n  --------------------------------\n  */\n  var R1 = function (a)\n  {\n    return a < 0 ? Math.ceil(a - 0.5) : Math.round(a)\n  };\n  var R2 = function (a)\n  {\n    return a < 0 ? Math.ceil(a - 0.5) : Math.floor(a + 0.5)\n  };\n  var R3 = function (a)\n  {\n    return a < 0 ? -Math.round(Math.abs(a)) : Math.round(a)\n  };\n  var R4 = function (a)\n  {\n    if (a < 0)\n    {\n      a -= 0.5;\n      return a < -2147483648 ? Math.ceil(a) : a | 0;\n    }\n    else\n    {\n      a += 0.5;\n      return a > 2147483647 ? Math.floor(a) : a | 0;\n    }\n  };\n  if (browser.msie) ClipperLib.Clipper.Round = R1;\n  else if (browser.chromium) ClipperLib.Clipper.Round = R3;\n  else if (browser.safari) ClipperLib.Clipper.Round = R4;\n  else ClipperLib.Clipper.Round = R2; // eg. browser.chrome || browser.firefox || browser.opera\n  ClipperLib.Clipper.TopX = function (edge, currentY)\n  {\n    //if (edge.Bot == edge.Curr) alert (\"edge.Bot = edge.Curr\");\n    //if (edge.Bot == edge.Top) alert (\"edge.Bot = edge.Top\");\n    if (currentY == edge.Top.Y)\n      return edge.Top.X;\n    return edge.Bot.X + ClipperLib.Clipper.Round(edge.Dx * (currentY - edge.Bot.Y));\n  };\n  ClipperLib.Clipper.prototype.IntersectPoint = function (edge1, edge2, ip)\n  {\n    ip.X = 0;\n    ip.Y = 0;\n    var b1, b2;\n    //nb: with very large coordinate values, it's possible for SlopesEqual() to\n    //return false but for the edge.Dx value be equal due to double precision rounding.\n    if (edge1.Dx == edge2.Dx)\n\t\t{\n\t\t\tip.Y = edge1.Curr.Y;\n\t\t\tip.X = ClipperLib.Clipper.TopX(edge1, ip.Y);\n\t\t\treturn;\n    }\n    if (edge1.Delta.X === 0)\n    {\n      ip.X = edge1.Bot.X;\n      if (ClipperLib.ClipperBase.IsHorizontal(edge2))\n      {\n        ip.Y = edge2.Bot.Y;\n      }\n      else\n      {\n        b2 = edge2.Bot.Y - (edge2.Bot.X / edge2.Dx);\n        ip.Y = ClipperLib.Clipper.Round(ip.X / edge2.Dx + b2);\n      }\n    }\n    else if (edge2.Delta.X === 0)\n    {\n      ip.X = edge2.Bot.X;\n      if (ClipperLib.ClipperBase.IsHorizontal(edge1))\n      {\n        ip.Y = edge1.Bot.Y;\n      }\n      else\n      {\n        b1 = edge1.Bot.Y - (edge1.Bot.X / edge1.Dx);\n        ip.Y = ClipperLib.Clipper.Round(ip.X / edge1.Dx + b1);\n      }\n    }\n    else\n    {\n      b1 = edge1.Bot.X - edge1.Bot.Y * edge1.Dx;\n      b2 = edge2.Bot.X - edge2.Bot.Y * edge2.Dx;\n      var q = (b2 - b1) / (edge1.Dx - edge2.Dx);\n      ip.Y = ClipperLib.Clipper.Round(q);\n      if (Math.abs(edge1.Dx) < Math.abs(edge2.Dx))\n        ip.X = ClipperLib.Clipper.Round(edge1.Dx * q + b1);\n      else\n        ip.X = ClipperLib.Clipper.Round(edge2.Dx * q + b2);\n    }\n    if (ip.Y < edge1.Top.Y || ip.Y < edge2.Top.Y)\n    {\n      if (edge1.Top.Y > edge2.Top.Y)\n      {\n        ip.Y = edge1.Top.Y;\n        ip.X = ClipperLib.Clipper.TopX(edge2, edge1.Top.Y);\n        return ip.X < edge1.Top.X;\n      }\n      else\n        ip.Y = edge2.Top.Y;\n      if (Math.abs(edge1.Dx) < Math.abs(edge2.Dx))\n        ip.X = ClipperLib.Clipper.TopX(edge1, ip.Y);\n      else\n        ip.X = ClipperLib.Clipper.TopX(edge2, ip.Y);\n    }\n\t\t//finally, don't allow 'ip' to be BELOW curr.Y (ie bottom of scanbeam) ...\n\t\tif (ip.Y > edge1.Curr.Y)\n\t\t{\n\t\t\tip.Y = edge1.Curr.Y;\n\t\t\t//better to use the more vertical edge to derive X ...\n\t\t\tif (Math.abs(edge1.Dx) > Math.abs(edge2.Dx))\n\t\t\t\tip.X = ClipperLib.Clipper.TopX(edge2, ip.Y);\n\t\t\telse\n\t\t\t\tip.X = ClipperLib.Clipper.TopX(edge1, ip.Y);\n\t\t}\n  };\n\n  ClipperLib.Clipper.prototype.ProcessEdgesAtTopOfScanbeam = function (topY)\n  {\n    var e = this.m_ActiveEdges;\n    while (e !== null)\n    {\n      //1. process maxima, treating them as if they're 'bent' horizontal edges,\n      //   but exclude maxima with horizontal edges. nb: e can't be a horizontal.\n      var IsMaximaEdge = this.IsMaxima(e, topY);\n      if (IsMaximaEdge)\n      {\n        var eMaxPair = this.GetMaximaPair(e);\n        IsMaximaEdge = (eMaxPair === null || !ClipperLib.ClipperBase.IsHorizontal(eMaxPair));\n      }\n      if (IsMaximaEdge)\n      {\n        var ePrev = e.PrevInAEL;\n        this.DoMaxima(e);\n        if (ePrev === null)\n          e = this.m_ActiveEdges;\n        else\n          e = ePrev.NextInAEL;\n      }\n      else\n      {\n        //2. promote horizontal edges, otherwise update Curr.X and Curr.Y ...\n        if (this.IsIntermediate(e, topY) && ClipperLib.ClipperBase.IsHorizontal(e.NextInLML))\n        {\n          e = this.UpdateEdgeIntoAEL(e);\n          if (e.OutIdx >= 0)\n            this.AddOutPt(e, e.Bot);\n          this.AddEdgeToSEL(e);\n        }\n        else\n        {\n          e.Curr.X = ClipperLib.Clipper.TopX(e, topY);\n          e.Curr.Y = topY;\n        }\n        if (this.StrictlySimple)\n        {\n          var ePrev = e.PrevInAEL;\n          if ((e.OutIdx >= 0) && (e.WindDelta !== 0) && ePrev !== null &&\n            (ePrev.OutIdx >= 0) && (ePrev.Curr.X == e.Curr.X) &&\n            (ePrev.WindDelta !== 0))\n          {\n           \tvar ip = new ClipperLib.IntPoint(e.Curr);\n\n\t\t\t\t\t\tif(use_xyz)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis.SetZ(ip, ePrev, e);\n\t\t\t\t\t\t}\n\n            var op = this.AddOutPt(ePrev, ip);\n            var op2 = this.AddOutPt(e, ip);\n            this.AddJoin(op, op2, ip);\n            //StrictlySimple (type-3) join\n          }\n        }\n        e = e.NextInAEL;\n      }\n    }\n    //3. Process horizontals at the Top of the scanbeam ...\n    this.ProcessHorizontals(true);\n    //4. Promote intermediate vertices ...\n    e = this.m_ActiveEdges;\n    while (e !== null)\n    {\n      if (this.IsIntermediate(e, topY))\n      {\n        var op = null;\n        if (e.OutIdx >= 0)\n          op = this.AddOutPt(e, e.Top);\n        e = this.UpdateEdgeIntoAEL(e);\n        //if output polygons share an edge, they'll need joining later ...\n        var ePrev = e.PrevInAEL;\n        var eNext = e.NextInAEL;\n        if (ePrev !== null && ePrev.Curr.X == e.Bot.X &&\n          ePrev.Curr.Y == e.Bot.Y && op !== null &&\n          ePrev.OutIdx >= 0 && ePrev.Curr.Y > ePrev.Top.Y &&\n          ClipperLib.ClipperBase.SlopesEqual(e, ePrev, this.m_UseFullRange) &&\n          (e.WindDelta !== 0) && (ePrev.WindDelta !== 0))\n        {\n          var op2 = this.AddOutPt(ePrev, e.Bot);\n          this.AddJoin(op, op2, e.Top);\n        }\n        else if (eNext !== null && eNext.Curr.X == e.Bot.X &&\n          eNext.Curr.Y == e.Bot.Y && op !== null &&\n          eNext.OutIdx >= 0 && eNext.Curr.Y > eNext.Top.Y &&\n          ClipperLib.ClipperBase.SlopesEqual(e, eNext, this.m_UseFullRange) &&\n          (e.WindDelta !== 0) && (eNext.WindDelta !== 0))\n        {\n          var op2 = this.AddOutPt(eNext, e.Bot);\n          this.AddJoin(op, op2, e.Top);\n        }\n      }\n      e = e.NextInAEL;\n    }\n  };\n  ClipperLib.Clipper.prototype.DoMaxima = function (e)\n  {\n    var eMaxPair = this.GetMaximaPair(e);\n    if (eMaxPair === null)\n    {\n      if (e.OutIdx >= 0)\n        this.AddOutPt(e, e.Top);\n      this.DeleteFromAEL(e);\n      return;\n    }\n    var eNext = e.NextInAEL;\n    var use_lines = true;\n    while (eNext !== null && eNext != eMaxPair)\n    {\n      this.IntersectEdges(e, eNext, e.Top);\n      this.SwapPositionsInAEL(e, eNext);\n      eNext = e.NextInAEL;\n    }\n    if (e.OutIdx == -1 && eMaxPair.OutIdx == -1)\n    {\n      this.DeleteFromAEL(e);\n      this.DeleteFromAEL(eMaxPair);\n    }\n    else if (e.OutIdx >= 0 && eMaxPair.OutIdx >= 0)\n    {\n    \tif (e.OutIdx >= 0) this.AddLocalMaxPoly(e, eMaxPair, e.Top);\n      this.DeleteFromAEL(e);\n      this.DeleteFromAEL(eMaxPair);\n    }\n    else if (use_lines && e.WindDelta === 0)\n    {\n      if (e.OutIdx >= 0)\n      {\n        this.AddOutPt(e, e.Top);\n        e.OutIdx = -1;\n      }\n      this.DeleteFromAEL(e);\n      if (eMaxPair.OutIdx >= 0)\n      {\n        this.AddOutPt(eMaxPair, e.Top);\n        eMaxPair.OutIdx = -1;\n      }\n      this.DeleteFromAEL(eMaxPair);\n    }\n    else\n      ClipperLib.Error(\"DoMaxima error\");\n  };\n  ClipperLib.Clipper.ReversePaths = function (polys)\n  {\n    for (var i = 0, len = polys.length; i < len; i++)\n      polys[i].reverse();\n  };\n  ClipperLib.Clipper.Orientation = function (poly)\n  {\n    return ClipperLib.Clipper.Area(poly) >= 0;\n  };\n  ClipperLib.Clipper.prototype.PointCount = function (pts)\n  {\n    if (pts === null)\n      return 0;\n    var result = 0;\n    var p = pts;\n    do {\n      result++;\n      p = p.Next;\n    }\n    while (p != pts)\n    return result;\n  };\n  ClipperLib.Clipper.prototype.BuildResult = function (polyg)\n  {\n    ClipperLib.Clear(polyg);\n    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n    {\n      var outRec = this.m_PolyOuts[i];\n      if (outRec.Pts === null)\n        continue;\n      var p = outRec.Pts.Prev;\n      var cnt = this.PointCount(p);\n      if (cnt < 2)\n        continue;\n      var pg = new Array(cnt);\n      for (var j = 0; j < cnt; j++)\n      {\n        pg[j] = p.Pt;\n        p = p.Prev;\n      }\n      polyg.push(pg);\n    }\n  };\n  ClipperLib.Clipper.prototype.BuildResult2 = function (polytree)\n  {\n    polytree.Clear();\n    //add each output polygon/contour to polytree ...\n    //polytree.m_AllPolys.set_Capacity(this.m_PolyOuts.length);\n    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n    {\n      var outRec = this.m_PolyOuts[i];\n      var cnt = this.PointCount(outRec.Pts);\n      if ((outRec.IsOpen && cnt < 2) || (!outRec.IsOpen && cnt < 3))\n        continue;\n      this.FixHoleLinkage(outRec);\n      var pn = new ClipperLib.PolyNode();\n      polytree.m_AllPolys.push(pn);\n      outRec.PolyNode = pn;\n      pn.m_polygon.length = cnt;\n      var op = outRec.Pts.Prev;\n      for (var j = 0; j < cnt; j++)\n      {\n        pn.m_polygon[j] = op.Pt;\n        op = op.Prev;\n      }\n    }\n    //fixup PolyNode links etc ...\n    //polytree.m_Childs.set_Capacity(this.m_PolyOuts.length);\n    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n    {\n      var outRec = this.m_PolyOuts[i];\n      if (outRec.PolyNode === null)\n        continue;\n      else if (outRec.IsOpen)\n      {\n        outRec.PolyNode.IsOpen = true;\n        polytree.AddChild(outRec.PolyNode);\n      }\n      else if (outRec.FirstLeft !== null && outRec.FirstLeft.PolyNode != null)\n        outRec.FirstLeft.PolyNode.AddChild(outRec.PolyNode);\n      else\n        polytree.AddChild(outRec.PolyNode);\n    }\n  };\n  ClipperLib.Clipper.prototype.FixupOutPolygon = function (outRec)\n  {\n    //FixupOutPolygon() - removes duplicate points and simplifies consecutive\n    //parallel edges by removing the middle vertex.\n    var lastOK = null;\n    outRec.BottomPt = null;\n    var pp = outRec.Pts;\n    for (;;)\n    {\n      if (pp.Prev == pp || pp.Prev == pp.Next)\n      {\n        outRec.Pts = null;\n        return;\n      }\n      //test for duplicate points and collinear edges ...\n      if ((ClipperLib.IntPoint.op_Equality(pp.Pt, pp.Next.Pt)) || (ClipperLib.IntPoint.op_Equality(pp.Pt, pp.Prev.Pt)) ||\n        (ClipperLib.ClipperBase.SlopesEqual(pp.Prev.Pt, pp.Pt, pp.Next.Pt, this.m_UseFullRange) &&\n          (!this.PreserveCollinear || !this.Pt2IsBetweenPt1AndPt3(pp.Prev.Pt, pp.Pt, pp.Next.Pt))))\n      {\n        lastOK = null;\n        pp.Prev.Next = pp.Next;\n        pp.Next.Prev = pp.Prev;\n        pp = pp.Prev;\n      }\n      else if (pp == lastOK)\n        break;\n      else\n      {\n        if (lastOK === null)\n          lastOK = pp;\n        pp = pp.Next;\n      }\n    }\n    outRec.Pts = pp;\n  };\n  ClipperLib.Clipper.prototype.DupOutPt = function (outPt, InsertAfter)\n  {\n    var result = new ClipperLib.OutPt();\n    //result.Pt = outPt.Pt;\n    result.Pt.X = outPt.Pt.X;\n    result.Pt.Y = outPt.Pt.Y;\n    result.Idx = outPt.Idx;\n    if (InsertAfter)\n    {\n      result.Next = outPt.Next;\n      result.Prev = outPt;\n      outPt.Next.Prev = result;\n      outPt.Next = result;\n    }\n    else\n    {\n      result.Prev = outPt.Prev;\n      result.Next = outPt;\n      outPt.Prev.Next = result;\n      outPt.Prev = result;\n    }\n    return result;\n  };\n  ClipperLib.Clipper.prototype.GetOverlap = function (a1, a2, b1, b2, $val)\n  {\n    if (a1 < a2)\n    {\n      if (b1 < b2)\n      {\n        $val.Left = Math.max(a1, b1);\n        $val.Right = Math.min(a2, b2);\n      }\n      else\n      {\n        $val.Left = Math.max(a1, b2);\n        $val.Right = Math.min(a2, b1);\n      }\n    }\n    else\n    {\n      if (b1 < b2)\n      {\n        $val.Left = Math.max(a2, b1);\n        $val.Right = Math.min(a1, b2);\n      }\n      else\n      {\n        $val.Left = Math.max(a2, b2);\n        $val.Right = Math.min(a1, b1);\n      }\n    }\n    return $val.Left < $val.Right;\n  };\n  ClipperLib.Clipper.prototype.JoinHorz = function (op1, op1b, op2, op2b, Pt, DiscardLeft)\n  {\n    var Dir1 = (op1.Pt.X > op1b.Pt.X ? ClipperLib.Direction.dRightToLeft : ClipperLib.Direction.dLeftToRight);\n    var Dir2 = (op2.Pt.X > op2b.Pt.X ? ClipperLib.Direction.dRightToLeft : ClipperLib.Direction.dLeftToRight);\n    if (Dir1 == Dir2)\n      return false;\n    //When DiscardLeft, we want Op1b to be on the Left of Op1, otherwise we\n    //want Op1b to be on the Right. (And likewise with Op2 and Op2b.)\n    //So, to facilitate this while inserting Op1b and Op2b ...\n    //when DiscardLeft, make sure we're AT or RIGHT of Pt before adding Op1b,\n    //otherwise make sure we're AT or LEFT of Pt. (Likewise with Op2b.)\n    if (Dir1 == ClipperLib.Direction.dLeftToRight)\n    {\n      while (op1.Next.Pt.X <= Pt.X &&\n        op1.Next.Pt.X >= op1.Pt.X && op1.Next.Pt.Y == Pt.Y)\n        op1 = op1.Next;\n      if (DiscardLeft && (op1.Pt.X != Pt.X))\n        op1 = op1.Next;\n      op1b = this.DupOutPt(op1, !DiscardLeft);\n      if (ClipperLib.IntPoint.op_Inequality(op1b.Pt, Pt))\n      {\n        op1 = op1b;\n        //op1.Pt = Pt;\n        op1.Pt.X = Pt.X;\n        op1.Pt.Y = Pt.Y;\n        op1b = this.DupOutPt(op1, !DiscardLeft);\n      }\n    }\n    else\n    {\n      while (op1.Next.Pt.X >= Pt.X &&\n        op1.Next.Pt.X <= op1.Pt.X && op1.Next.Pt.Y == Pt.Y)\n        op1 = op1.Next;\n      if (!DiscardLeft && (op1.Pt.X != Pt.X))\n        op1 = op1.Next;\n      op1b = this.DupOutPt(op1, DiscardLeft);\n      if (ClipperLib.IntPoint.op_Inequality(op1b.Pt, Pt))\n      {\n        op1 = op1b;\n        //op1.Pt = Pt;\n        op1.Pt.X = Pt.X;\n        op1.Pt.Y = Pt.Y;\n        op1b = this.DupOutPt(op1, DiscardLeft);\n      }\n    }\n    if (Dir2 == ClipperLib.Direction.dLeftToRight)\n    {\n      while (op2.Next.Pt.X <= Pt.X &&\n        op2.Next.Pt.X >= op2.Pt.X && op2.Next.Pt.Y == Pt.Y)\n        op2 = op2.Next;\n      if (DiscardLeft && (op2.Pt.X != Pt.X))\n        op2 = op2.Next;\n      op2b = this.DupOutPt(op2, !DiscardLeft);\n      if (ClipperLib.IntPoint.op_Inequality(op2b.Pt, Pt))\n      {\n        op2 = op2b;\n        //op2.Pt = Pt;\n        op2.Pt.X = Pt.X;\n        op2.Pt.Y = Pt.Y;\n        op2b = this.DupOutPt(op2, !DiscardLeft);\n      }\n    }\n    else\n    {\n      while (op2.Next.Pt.X >= Pt.X &&\n        op2.Next.Pt.X <= op2.Pt.X && op2.Next.Pt.Y == Pt.Y)\n        op2 = op2.Next;\n      if (!DiscardLeft && (op2.Pt.X != Pt.X))\n        op2 = op2.Next;\n      op2b = this.DupOutPt(op2, DiscardLeft);\n      if (ClipperLib.IntPoint.op_Inequality(op2b.Pt, Pt))\n      {\n        op2 = op2b;\n        //op2.Pt = Pt;\n        op2.Pt.X = Pt.X;\n        op2.Pt.Y = Pt.Y;\n        op2b = this.DupOutPt(op2, DiscardLeft);\n      }\n    }\n    if ((Dir1 == ClipperLib.Direction.dLeftToRight) == DiscardLeft)\n    {\n      op1.Prev = op2;\n      op2.Next = op1;\n      op1b.Next = op2b;\n      op2b.Prev = op1b;\n    }\n    else\n    {\n      op1.Next = op2;\n      op2.Prev = op1;\n      op1b.Prev = op2b;\n      op2b.Next = op1b;\n    }\n    return true;\n  };\n  ClipperLib.Clipper.prototype.JoinPoints = function (j, outRec1, outRec2)\n  {\n    var op1 = j.OutPt1,\n      op1b = new ClipperLib.OutPt();\n    var op2 = j.OutPt2,\n      op2b = new ClipperLib.OutPt();\n    //There are 3 kinds of joins for output polygons ...\n    //1. Horizontal joins where Join.OutPt1 & Join.OutPt2 are a vertices anywhere\n    //along (horizontal) collinear edges (& Join.OffPt is on the same horizontal).\n    //2. Non-horizontal joins where Join.OutPt1 & Join.OutPt2 are at the same\n    //location at the Bottom of the overlapping segment (& Join.OffPt is above).\n    //3. StrictlySimple joins where edges touch but are not collinear and where\n    //Join.OutPt1, Join.OutPt2 & Join.OffPt all share the same point.\n    var isHorizontal = (j.OutPt1.Pt.Y == j.OffPt.Y);\n    if (isHorizontal && (ClipperLib.IntPoint.op_Equality(j.OffPt, j.OutPt1.Pt)) && (ClipperLib.IntPoint.op_Equality(j.OffPt, j.OutPt2.Pt)))\n    {\n      //Strictly Simple join ...\n\t\t\tif (outRec1 != outRec2) return false;\n\n      op1b = j.OutPt1.Next;\n      while (op1b != op1 && (ClipperLib.IntPoint.op_Equality(op1b.Pt, j.OffPt)))\n        op1b = op1b.Next;\n      var reverse1 = (op1b.Pt.Y > j.OffPt.Y);\n      op2b = j.OutPt2.Next;\n      while (op2b != op2 && (ClipperLib.IntPoint.op_Equality(op2b.Pt, j.OffPt)))\n        op2b = op2b.Next;\n      var reverse2 = (op2b.Pt.Y > j.OffPt.Y);\n      if (reverse1 == reverse2)\n        return false;\n      if (reverse1)\n      {\n        op1b = this.DupOutPt(op1, false);\n        op2b = this.DupOutPt(op2, true);\n        op1.Prev = op2;\n        op2.Next = op1;\n        op1b.Next = op2b;\n        op2b.Prev = op1b;\n        j.OutPt1 = op1;\n        j.OutPt2 = op1b;\n        return true;\n      }\n      else\n      {\n        op1b = this.DupOutPt(op1, true);\n        op2b = this.DupOutPt(op2, false);\n        op1.Next = op2;\n        op2.Prev = op1;\n        op1b.Prev = op2b;\n        op2b.Next = op1b;\n        j.OutPt1 = op1;\n        j.OutPt2 = op1b;\n        return true;\n      }\n    }\n    else if (isHorizontal)\n    {\n      //treat horizontal joins differently to non-horizontal joins since with\n      //them we're not yet sure where the overlapping is. OutPt1.Pt & OutPt2.Pt\n      //may be anywhere along the horizontal edge.\n      op1b = op1;\n      while (op1.Prev.Pt.Y == op1.Pt.Y && op1.Prev != op1b && op1.Prev != op2)\n        op1 = op1.Prev;\n      while (op1b.Next.Pt.Y == op1b.Pt.Y && op1b.Next != op1 && op1b.Next != op2)\n        op1b = op1b.Next;\n      if (op1b.Next == op1 || op1b.Next == op2)\n        return false;\n      //a flat 'polygon'\n      op2b = op2;\n      while (op2.Prev.Pt.Y == op2.Pt.Y && op2.Prev != op2b && op2.Prev != op1b)\n        op2 = op2.Prev;\n      while (op2b.Next.Pt.Y == op2b.Pt.Y && op2b.Next != op2 && op2b.Next != op1)\n        op2b = op2b.Next;\n      if (op2b.Next == op2 || op2b.Next == op1)\n        return false;\n      //a flat 'polygon'\n      //Op1 -. Op1b & Op2 -. Op2b are the extremites of the horizontal edges\n\n      var $val = {Left: null, Right: null};\n      if (!this.GetOverlap(op1.Pt.X, op1b.Pt.X, op2.Pt.X, op2b.Pt.X, $val))\n        return false;\n      var Left = $val.Left;\n      var Right = $val.Right;\n\n      //DiscardLeftSide: when overlapping edges are joined, a spike will created\n      //which needs to be cleaned up. However, we don't want Op1 or Op2 caught up\n      //on the discard Side as either may still be needed for other joins ...\n      var Pt = new ClipperLib.IntPoint();\n      var DiscardLeftSide;\n      if (op1.Pt.X >= Left && op1.Pt.X <= Right)\n      {\n        //Pt = op1.Pt;\n        Pt.X = op1.Pt.X;\n        Pt.Y = op1.Pt.Y;\n        DiscardLeftSide = (op1.Pt.X > op1b.Pt.X);\n      }\n      else if (op2.Pt.X >= Left && op2.Pt.X <= Right)\n      {\n        //Pt = op2.Pt;\n        Pt.X = op2.Pt.X;\n        Pt.Y = op2.Pt.Y;\n        DiscardLeftSide = (op2.Pt.X > op2b.Pt.X);\n      }\n      else if (op1b.Pt.X >= Left && op1b.Pt.X <= Right)\n      {\n        //Pt = op1b.Pt;\n        Pt.X = op1b.Pt.X;\n        Pt.Y = op1b.Pt.Y;\n        DiscardLeftSide = op1b.Pt.X > op1.Pt.X;\n      }\n      else\n      {\n        //Pt = op2b.Pt;\n        Pt.X = op2b.Pt.X;\n        Pt.Y = op2b.Pt.Y;\n        DiscardLeftSide = (op2b.Pt.X > op2.Pt.X);\n      }\n      j.OutPt1 = op1;\n      j.OutPt2 = op2;\n      return this.JoinHorz(op1, op1b, op2, op2b, Pt, DiscardLeftSide);\n    }\n    else\n    {\n      //nb: For non-horizontal joins ...\n      //    1. Jr.OutPt1.Pt.Y == Jr.OutPt2.Pt.Y\n      //    2. Jr.OutPt1.Pt > Jr.OffPt.Y\n      //make sure the polygons are correctly oriented ...\n      op1b = op1.Next;\n      while ((ClipperLib.IntPoint.op_Equality(op1b.Pt, op1.Pt)) && (op1b != op1))\n        op1b = op1b.Next;\n      var Reverse1 = ((op1b.Pt.Y > op1.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual(op1.Pt, op1b.Pt, j.OffPt, this.m_UseFullRange));\n      if (Reverse1)\n      {\n        op1b = op1.Prev;\n        while ((ClipperLib.IntPoint.op_Equality(op1b.Pt, op1.Pt)) && (op1b != op1))\n          op1b = op1b.Prev;\n        if ((op1b.Pt.Y > op1.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual(op1.Pt, op1b.Pt, j.OffPt, this.m_UseFullRange))\n          return false;\n      }\n      op2b = op2.Next;\n      while ((ClipperLib.IntPoint.op_Equality(op2b.Pt, op2.Pt)) && (op2b != op2))\n        op2b = op2b.Next;\n      var Reverse2 = ((op2b.Pt.Y > op2.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual(op2.Pt, op2b.Pt, j.OffPt, this.m_UseFullRange));\n      if (Reverse2)\n      {\n        op2b = op2.Prev;\n        while ((ClipperLib.IntPoint.op_Equality(op2b.Pt, op2.Pt)) && (op2b != op2))\n          op2b = op2b.Prev;\n        if ((op2b.Pt.Y > op2.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual(op2.Pt, op2b.Pt, j.OffPt, this.m_UseFullRange))\n          return false;\n      }\n      if ((op1b == op1) || (op2b == op2) || (op1b == op2b) ||\n        ((outRec1 == outRec2) && (Reverse1 == Reverse2)))\n        return false;\n      if (Reverse1)\n      {\n        op1b = this.DupOutPt(op1, false);\n        op2b = this.DupOutPt(op2, true);\n        op1.Prev = op2;\n        op2.Next = op1;\n        op1b.Next = op2b;\n        op2b.Prev = op1b;\n        j.OutPt1 = op1;\n        j.OutPt2 = op1b;\n        return true;\n      }\n      else\n      {\n        op1b = this.DupOutPt(op1, true);\n        op2b = this.DupOutPt(op2, false);\n        op1.Next = op2;\n        op2.Prev = op1;\n        op1b.Prev = op2b;\n        op2b.Next = op1b;\n        j.OutPt1 = op1;\n        j.OutPt2 = op1b;\n        return true;\n      }\n    }\n  };\n  ClipperLib.Clipper.GetBounds = function (paths)\n  {\n    var i = 0,\n      cnt = paths.length;\n    while (i < cnt && paths[i].length == 0) i++;\n    if (i == cnt) return new ClipperLib.IntRect(0, 0, 0, 0);\n    var result = new ClipperLib.IntRect();\n    result.left = paths[i][0].X;\n    result.right = result.left;\n    result.top = paths[i][0].Y;\n    result.bottom = result.top;\n    for (; i < cnt; i++)\n      for (var j = 0, jlen = paths[i].length; j < jlen; j++)\n      {\n        if (paths[i][j].X < result.left) result.left = paths[i][j].X;\n        else if (paths[i][j].X > result.right) result.right = paths[i][j].X;\n        if (paths[i][j].Y < result.top) result.top = paths[i][j].Y;\n        else if (paths[i][j].Y > result.bottom) result.bottom = paths[i][j].Y;\n      }\n    return result;\n  }\n  ClipperLib.Clipper.prototype.GetBounds2 = function (ops)\n  {\n    var opStart = ops;\n    var result = new ClipperLib.IntRect();\n    result.left = ops.Pt.X;\n    result.right = ops.Pt.X;\n    result.top = ops.Pt.Y;\n    result.bottom = ops.Pt.Y;\n    ops = ops.Next;\n    while (ops != opStart)\n    {\n      if (ops.Pt.X < result.left)\n        result.left = ops.Pt.X;\n      if (ops.Pt.X > result.right)\n        result.right = ops.Pt.X;\n      if (ops.Pt.Y < result.top)\n        result.top = ops.Pt.Y;\n      if (ops.Pt.Y > result.bottom)\n        result.bottom = ops.Pt.Y;\n      ops = ops.Next;\n    }\n    return result;\n  };\n\n  ClipperLib.Clipper.PointInPolygon = function (pt, path)\n  {\n    //returns 0 if false, +1 if true, -1 if pt ON polygon boundary\n\t\t//See \"The Point in Polygon Problem for Arbitrary Polygons\" by Hormann & Agathos\n    //http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.88.5498&rep=rep1&type=pdf\n    var result = 0,\n      cnt = path.length;\n    if (cnt < 3)\n      return 0;\n    var ip = path[0];\n    for (var i = 1; i <= cnt; ++i)\n    {\n      var ipNext = (i == cnt ? path[0] : path[i]);\n      if (ipNext.Y == pt.Y)\n      {\n        if ((ipNext.X == pt.X) || (ip.Y == pt.Y && ((ipNext.X > pt.X) == (ip.X < pt.X))))\n          return -1;\n      }\n      if ((ip.Y < pt.Y) != (ipNext.Y < pt.Y))\n      {\n        if (ip.X >= pt.X)\n        {\n          if (ipNext.X > pt.X)\n            result = 1 - result;\n          else\n          {\n            var d = (ip.X - pt.X) * (ipNext.Y - pt.Y) - (ipNext.X - pt.X) * (ip.Y - pt.Y);\n            if (d == 0)\n              return -1;\n            else if ((d > 0) == (ipNext.Y > ip.Y))\n              result = 1 - result;\n          }\n        }\n        else\n        {\n          if (ipNext.X > pt.X)\n          {\n            var d = (ip.X - pt.X) * (ipNext.Y - pt.Y) - (ipNext.X - pt.X) * (ip.Y - pt.Y);\n            if (d == 0)\n              return -1;\n            else if ((d > 0) == (ipNext.Y > ip.Y))\n              result = 1 - result;\n          }\n        }\n      }\n      ip = ipNext;\n    }\n    return result;\n  };\n\n  ClipperLib.Clipper.prototype.PointInPolygon = function (pt, op)\n  {\n    //returns 0 if false, +1 if true, -1 if pt ON polygon boundary\n\t\t//See \"The Point in Polygon Problem for Arbitrary Polygons\" by Hormann & Agathos\n    //http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.88.5498&rep=rep1&type=pdf\n    var result = 0;\n    var startOp = op;\n\t\tvar ptx = pt.X, pty = pt.Y;\n    var poly0x = op.Pt.X, poly0y = op.Pt.Y;\n    do\n    {\n\t\t\top = op.Next;\n\t\t\tvar poly1x = op.Pt.X, poly1y = op.Pt.Y;\n      if (poly1y == pty)\n      {\n        if ((poly1x == ptx) || (poly0y == pty && ((poly1x > ptx) == (poly0x < ptx))))\n          return -1;\n      }\n      if ((poly0y < pty) != (poly1y < pty))\n      {\n        if (poly0x >= ptx)\n        {\n          if (poly1x > ptx)\n            result = 1 - result;\n          else\n          {\n            var d = (poly0x - ptx) * (poly1y - pty) - (poly1x - ptx) * (poly0y - pty);\n            if (d == 0)\n              return -1;\n            if ((d > 0) == (poly1y > poly0y))\n              result = 1 - result;\n          }\n        }\n        else\n        {\n          if (poly1x > ptx)\n          {\n            var d = (poly0x - ptx) * (poly1y - pty) - (poly1x - ptx) * (poly0y - pty);\n            if (d == 0)\n              return -1;\n            if ((d > 0) == (poly1y > poly0y))\n              result = 1 - result;\n          }\n        }\n      }\n      poly0x = poly1x;\n      poly0y = poly1y;\n    } while (startOp != op);\n\n    return result;\n  };\n\n  ClipperLib.Clipper.prototype.Poly2ContainsPoly1 = function (outPt1, outPt2)\n  {\n    var op = outPt1;\n    do\n    {\n\t\t\t//nb: PointInPolygon returns 0 if false, +1 if true, -1 if pt on polygon\n      var res = this.PointInPolygon(op.Pt, outPt2);\n      if (res >= 0)\n        return res > 0;\n      op = op.Next;\n    }\n    while (op != outPt1)\n    return true;\n  };\n  ClipperLib.Clipper.prototype.FixupFirstLefts1 = function (OldOutRec, NewOutRec)\n  {\n    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n    {\n\t\t\tvar outRec = this.m_PolyOuts[i];\n\t\t\tif (outRec.Pts == null || outRec.FirstLeft == null)\n\t\t\t\tcontinue;\n\t\t\tvar firstLeft = this.ParseFirstLeft(outRec.FirstLeft);\n\t\t\tif (firstLeft == OldOutRec)\n\t\t\t{\n        if (this.Poly2ContainsPoly1(outRec.Pts, NewOutRec.Pts))\n          outRec.FirstLeft = NewOutRec;\n      }\n    }\n  };\n  ClipperLib.Clipper.prototype.FixupFirstLefts2 = function (OldOutRec, NewOutRec)\n  {\n    for (var $i2 = 0, $t2 = this.m_PolyOuts, $l2 = $t2.length, outRec = $t2[$i2]; $i2 < $l2; $i2++, outRec = $t2[$i2])\n      if (outRec.FirstLeft == OldOutRec)\n        outRec.FirstLeft = NewOutRec;\n  };\n  ClipperLib.Clipper.ParseFirstLeft = function (FirstLeft)\n  {\n    while (FirstLeft != null && FirstLeft.Pts == null)\n      FirstLeft = FirstLeft.FirstLeft;\n    return FirstLeft;\n  };\n  ClipperLib.Clipper.prototype.JoinCommonEdges = function ()\n  {\n    for (var i = 0, ilen = this.m_Joins.length; i < ilen; i++)\n    {\n      var join = this.m_Joins[i];\n      var outRec1 = this.GetOutRec(join.OutPt1.Idx);\n      var outRec2 = this.GetOutRec(join.OutPt2.Idx);\n      if (outRec1.Pts == null || outRec2.Pts == null)\n        continue;\n      //get the polygon fragment with the correct hole state (FirstLeft)\n      //before calling JoinPoints() ...\n      var holeStateRec;\n      if (outRec1 == outRec2)\n        holeStateRec = outRec1;\n      else if (this.Param1RightOfParam2(outRec1, outRec2))\n        holeStateRec = outRec2;\n      else if (this.Param1RightOfParam2(outRec2, outRec1))\n        holeStateRec = outRec1;\n      else\n        holeStateRec = this.GetLowermostRec(outRec1, outRec2);\n\n      if (!this.JoinPoints(join, outRec1, outRec2)) continue;\n\n      if (outRec1 == outRec2)\n      {\n        //instead of joining two polygons, we've just created a new one by\n        //splitting one polygon into two.\n        outRec1.Pts = join.OutPt1;\n        outRec1.BottomPt = null;\n        outRec2 = this.CreateOutRec();\n        outRec2.Pts = join.OutPt2;\n        //update all OutRec2.Pts Idx's ...\n        this.UpdateOutPtIdxs(outRec2);\n        //We now need to check every OutRec.FirstLeft pointer. If it points\n        //to OutRec1 it may need to point to OutRec2 instead ...\n        if (this.m_UsingPolyTree)\n          for (var j = 0, jlen = this.m_PolyOuts.length; j < jlen - 1; j++)\n          {\n            var oRec = this.m_PolyOuts[j];\n            if (oRec.Pts == null || ClipperLib.Clipper.ParseFirstLeft(oRec.FirstLeft) != outRec1 || oRec.IsHole == outRec1.IsHole)\n              continue;\n            if (this.Poly2ContainsPoly1(oRec.Pts, join.OutPt2))\n              oRec.FirstLeft = outRec2;\n          }\n        if (this.Poly2ContainsPoly1(outRec2.Pts, outRec1.Pts))\n        {\n          //outRec2 is contained by outRec1 ...\n          outRec2.IsHole = !outRec1.IsHole;\n          outRec2.FirstLeft = outRec1;\n          //fixup FirstLeft pointers that may need reassigning to OutRec1\n          if (this.m_UsingPolyTree)\n            this.FixupFirstLefts2(outRec2, outRec1);\n          if ((outRec2.IsHole ^ this.ReverseSolution) == (this.Area(outRec2) > 0))\n            this.ReversePolyPtLinks(outRec2.Pts);\n        }\n        else if (this.Poly2ContainsPoly1(outRec1.Pts, outRec2.Pts))\n        {\n          //outRec1 is contained by outRec2 ...\n          outRec2.IsHole = outRec1.IsHole;\n          outRec1.IsHole = !outRec2.IsHole;\n          outRec2.FirstLeft = outRec1.FirstLeft;\n          outRec1.FirstLeft = outRec2;\n          //fixup FirstLeft pointers that may need reassigning to OutRec1\n          if (this.m_UsingPolyTree)\n            this.FixupFirstLefts2(outRec1, outRec2);\n          if ((outRec1.IsHole ^ this.ReverseSolution) == (this.Area(outRec1) > 0))\n            this.ReversePolyPtLinks(outRec1.Pts);\n        }\n        else\n        {\n          //the 2 polygons are completely separate ...\n          outRec2.IsHole = outRec1.IsHole;\n          outRec2.FirstLeft = outRec1.FirstLeft;\n          //fixup FirstLeft pointers that may need reassigning to OutRec2\n          if (this.m_UsingPolyTree)\n            this.FixupFirstLefts1(outRec1, outRec2);\n        }\n      }\n      else\n      {\n        //joined 2 polygons together ...\n        outRec2.Pts = null;\n        outRec2.BottomPt = null;\n        outRec2.Idx = outRec1.Idx;\n        outRec1.IsHole = holeStateRec.IsHole;\n        if (holeStateRec == outRec2)\n          outRec1.FirstLeft = outRec2.FirstLeft;\n        outRec2.FirstLeft = outRec1;\n        //fixup FirstLeft pointers that may need reassigning to OutRec1\n        if (this.m_UsingPolyTree)\n          this.FixupFirstLefts2(outRec2, outRec1);\n      }\n    }\n  };\n  ClipperLib.Clipper.prototype.UpdateOutPtIdxs = function (outrec)\n  {\n    var op = outrec.Pts;\n    do {\n      op.Idx = outrec.Idx;\n      op = op.Prev;\n    }\n    while (op != outrec.Pts)\n  };\n  ClipperLib.Clipper.prototype.DoSimplePolygons = function ()\n  {\n    var i = 0;\n    while (i < this.m_PolyOuts.length)\n    {\n      var outrec = this.m_PolyOuts[i++];\n      var op = outrec.Pts;\n\t\t\tif (op == null || outrec.IsOpen)\n\t\t\t\tcontinue;\n      do //for each Pt in Polygon until duplicate found do ...\n      {\n        var op2 = op.Next;\n        while (op2 != outrec.Pts)\n        {\n          if ((ClipperLib.IntPoint.op_Equality(op.Pt, op2.Pt)) && op2.Next != op && op2.Prev != op)\n          {\n            //split the polygon into two ...\n            var op3 = op.Prev;\n            var op4 = op2.Prev;\n            op.Prev = op4;\n            op4.Next = op;\n            op2.Prev = op3;\n            op3.Next = op2;\n            outrec.Pts = op;\n            var outrec2 = this.CreateOutRec();\n            outrec2.Pts = op2;\n            this.UpdateOutPtIdxs(outrec2);\n            if (this.Poly2ContainsPoly1(outrec2.Pts, outrec.Pts))\n            {\n              //OutRec2 is contained by OutRec1 ...\n              outrec2.IsHole = !outrec.IsHole;\n              outrec2.FirstLeft = outrec;\n\t\t\t\t\t\t\tif (this.m_UsingPolyTree) this.FixupFirstLefts2(outrec2, outrec);\n\n            }\n            else if (this.Poly2ContainsPoly1(outrec.Pts, outrec2.Pts))\n            {\n              //OutRec1 is contained by OutRec2 ...\n              outrec2.IsHole = outrec.IsHole;\n              outrec.IsHole = !outrec2.IsHole;\n              outrec2.FirstLeft = outrec.FirstLeft;\n              outrec.FirstLeft = outrec2;\n              if (this.m_UsingPolyTree) this.FixupFirstLefts2(outrec, outrec2);\n            }\n            else\n            {\n              //the 2 polygons are separate ...\n              outrec2.IsHole = outrec.IsHole;\n              outrec2.FirstLeft = outrec.FirstLeft;\n\t\t\t\t\t\t\tif (this.m_UsingPolyTree) this.FixupFirstLefts1(outrec, outrec2);\n            }\n            op2 = op;\n            //ie get ready for the next iteration\n          }\n          op2 = op2.Next;\n        }\n        op = op.Next;\n      }\n      while (op != outrec.Pts)\n    }\n  };\n  ClipperLib.Clipper.Area = function (poly)\n  {\n    var cnt = poly.length;\n    if (cnt < 3)\n      return 0;\n    var a = 0;\n    for (var i = 0, j = cnt - 1; i < cnt; ++i)\n    {\n      a += (poly[j].X + poly[i].X) * (poly[j].Y - poly[i].Y);\n      j = i;\n    }\n    return -a * 0.5;\n  };\n  ClipperLib.Clipper.prototype.Area = function (outRec)\n  {\n    var op = outRec.Pts;\n    if (op == null)\n      return 0;\n    var a = 0;\n    do {\n      a = a + (op.Prev.Pt.X + op.Pt.X) * (op.Prev.Pt.Y - op.Pt.Y);\n      op = op.Next;\n    }\n    while (op != outRec.Pts)\n    return a * 0.5;\n  };\n  ClipperLib.Clipper.SimplifyPolygon = function (poly, fillType)\n  {\n    var result = new Array();\n    var c = new ClipperLib.Clipper(0);\n    c.StrictlySimple = true;\n    c.AddPath(poly, ClipperLib.PolyType.ptSubject, true);\n    c.Execute(ClipperLib.ClipType.ctUnion, result, fillType, fillType);\n    return result;\n  };\n  ClipperLib.Clipper.SimplifyPolygons = function (polys, fillType)\n  {\n    if (typeof (fillType) == \"undefined\") fillType = ClipperLib.PolyFillType.pftEvenOdd;\n    var result = new Array();\n    var c = new ClipperLib.Clipper(0);\n    c.StrictlySimple = true;\n    c.AddPaths(polys, ClipperLib.PolyType.ptSubject, true);\n    c.Execute(ClipperLib.ClipType.ctUnion, result, fillType, fillType);\n    return result;\n  };\n  ClipperLib.Clipper.DistanceSqrd = function (pt1, pt2)\n  {\n    var dx = (pt1.X - pt2.X);\n    var dy = (pt1.Y - pt2.Y);\n    return (dx * dx + dy * dy);\n  };\n  ClipperLib.Clipper.DistanceFromLineSqrd = function (pt, ln1, ln2)\n  {\n    //The equation of a line in general form (Ax + By + C = 0)\n    //given 2 points (x,y) & (x,y) is ...\n    //(y - y)x + (x - x)y + (y - y)x - (x - x)y = 0\n    //A = (y - y); B = (x - x); C = (y - y)x - (x - x)y\n    //perpendicular distance of point (x,y) = (Ax + By + C)/Sqrt(A + B)\n    //see http://en.wikipedia.org/wiki/Perpendicular_distance\n    var A = ln1.Y - ln2.Y;\n    var B = ln2.X - ln1.X;\n    var C = A * ln1.X + B * ln1.Y;\n    C = A * pt.X + B * pt.Y - C;\n    return (C * C) / (A * A + B * B);\n  };\n\n\tClipperLib.Clipper.SlopesNearCollinear = function(pt1, pt2, pt3, distSqrd)\n\t{\n\t\t//this function is more accurate when the point that's GEOMETRICALLY\n\t\t//between the other 2 points is the one that's tested for distance.\n\t\t//nb: with 'spikes', either pt1 or pt3 is geometrically between the other pts\n\t\tif (Math.abs(pt1.X - pt2.X) > Math.abs(pt1.Y - pt2.Y))\n\t\t{\n\t\tif ((pt1.X > pt2.X) == (pt1.X < pt3.X))\n\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt1, pt2, pt3) < distSqrd;\n\t\telse if ((pt2.X > pt1.X) == (pt2.X < pt3.X))\n\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt2, pt1, pt3) < distSqrd;\n\t\t\t\telse\n\t\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt3, pt1, pt2) < distSqrd;\n\t\t}\n\t\telse\n\t\t{\n\t\tif ((pt1.Y > pt2.Y) == (pt1.Y < pt3.Y))\n\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt1, pt2, pt3) < distSqrd;\n\t\telse if ((pt2.Y > pt1.Y) == (pt2.Y < pt3.Y))\n\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt2, pt1, pt3) < distSqrd;\n\t\t\t\telse\n\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt3, pt1, pt2) < distSqrd;\n\t\t}\n\t}\n\n  ClipperLib.Clipper.PointsAreClose = function (pt1, pt2, distSqrd)\n  {\n    var dx = pt1.X - pt2.X;\n    var dy = pt1.Y - pt2.Y;\n    return ((dx * dx) + (dy * dy) <= distSqrd);\n  };\n  //------------------------------------------------------------------------------\n  ClipperLib.Clipper.ExcludeOp = function (op)\n  {\n    var result = op.Prev;\n    result.Next = op.Next;\n    op.Next.Prev = result;\n    result.Idx = 0;\n    return result;\n  };\n  ClipperLib.Clipper.CleanPolygon = function (path, distance)\n  {\n    if (typeof (distance) == \"undefined\") distance = 1.415;\n    //distance = proximity in units/pixels below which vertices will be stripped.\n    //Default ~= sqrt(2) so when adjacent vertices or semi-adjacent vertices have\n    //both x & y coords within 1 unit, then the second vertex will be stripped.\n    var cnt = path.length;\n    if (cnt == 0)\n      return new Array();\n    var outPts = new Array(cnt);\n    for (var i = 0; i < cnt; ++i)\n      outPts[i] = new ClipperLib.OutPt();\n    for (var i = 0; i < cnt; ++i)\n    {\n      outPts[i].Pt = path[i];\n      outPts[i].Next = outPts[(i + 1) % cnt];\n      outPts[i].Next.Prev = outPts[i];\n      outPts[i].Idx = 0;\n    }\n    var distSqrd = distance * distance;\n    var op = outPts[0];\n    while (op.Idx == 0 && op.Next != op.Prev)\n    {\n      if (ClipperLib.Clipper.PointsAreClose(op.Pt, op.Prev.Pt, distSqrd))\n      {\n        op = ClipperLib.Clipper.ExcludeOp(op);\n        cnt--;\n      }\n      else if (ClipperLib.Clipper.PointsAreClose(op.Prev.Pt, op.Next.Pt, distSqrd))\n      {\n        ClipperLib.Clipper.ExcludeOp(op.Next);\n        op = ClipperLib.Clipper.ExcludeOp(op);\n        cnt -= 2;\n      }\n      else if (ClipperLib.Clipper.SlopesNearCollinear(op.Prev.Pt, op.Pt, op.Next.Pt, distSqrd))\n      {\n        op = ClipperLib.Clipper.ExcludeOp(op);\n        cnt--;\n      }\n      else\n      {\n        op.Idx = 1;\n        op = op.Next;\n      }\n    }\n    if (cnt < 3)\n      cnt = 0;\n    var result = new Array(cnt);\n    for (var i = 0; i < cnt; ++i)\n    {\n      result[i] = new ClipperLib.IntPoint(op.Pt);\n      op = op.Next;\n    }\n    outPts = null;\n    return result;\n  };\n  ClipperLib.Clipper.CleanPolygons = function (polys, distance)\n  {\n    var result = new Array(polys.length);\n    for (var i = 0, ilen = polys.length; i < ilen; i++)\n      result[i] = ClipperLib.Clipper.CleanPolygon(polys[i], distance);\n    return result;\n  };\n  ClipperLib.Clipper.Minkowski = function (pattern, path, IsSum, IsClosed)\n  {\n    var delta = (IsClosed ? 1 : 0);\n    var polyCnt = pattern.length;\n    var pathCnt = path.length;\n    var result = new Array();\n    if (IsSum)\n      for (var i = 0; i < pathCnt; i++)\n      {\n        var p = new Array(polyCnt);\n        for (var j = 0, jlen = pattern.length, ip = pattern[j]; j < jlen; j++, ip = pattern[j])\n          p[j] = new ClipperLib.IntPoint(path[i].X + ip.X, path[i].Y + ip.Y);\n        result.push(p);\n      }\n    else\n      for (var i = 0; i < pathCnt; i++)\n      {\n        var p = new Array(polyCnt);\n        for (var j = 0, jlen = pattern.length, ip = pattern[j]; j < jlen; j++, ip = pattern[j])\n          p[j] = new ClipperLib.IntPoint(path[i].X - ip.X, path[i].Y - ip.Y);\n        result.push(p);\n      }\n    var quads = new Array();\n    for (var i = 0; i < pathCnt - 1 + delta; i++)\n      for (var j = 0; j < polyCnt; j++)\n      {\n        var quad = new Array();\n        quad.push(result[i % pathCnt][j % polyCnt]);\n        quad.push(result[(i + 1) % pathCnt][j % polyCnt]);\n        quad.push(result[(i + 1) % pathCnt][(j + 1) % polyCnt]);\n        quad.push(result[i % pathCnt][(j + 1) % polyCnt]);\n        if (!ClipperLib.Clipper.Orientation(quad))\n          quad.reverse();\n        quads.push(quad);\n      }\n\t\t\treturn quads;\n  };\n\n\tClipperLib.Clipper.MinkowskiSum = function(pattern, path_or_paths, pathIsClosed)\n\t{\n\t\tif(!(path_or_paths[0] instanceof Array))\n\t\t{\n\t\t\tvar path = path_or_paths;\n\t\t\tvar paths = ClipperLib.Clipper.Minkowski(pattern, path, true, pathIsClosed);\n\t\t\tvar c = new ClipperLib.Clipper();\n\t\t\tc.AddPaths(paths, ClipperLib.PolyType.ptSubject, true);\n\t\t\tc.Execute(ClipperLib.ClipType.ctUnion, paths, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);\n\t\t\treturn paths;\n\t\t}\n\t\telse\n\t\t{\n \t\t\tvar paths = path_or_paths;\n\t\t\tvar solution = new ClipperLib.Paths();\n\t\t\tvar c = new ClipperLib.Clipper();\n\t\t\tfor (var i = 0; i < paths.length; ++i)\n\t\t\t{\n\t\t\t\tvar tmp = ClipperLib.Clipper.Minkowski(pattern, paths[i], true, pathIsClosed);\n\t\t\t\tc.AddPaths(tmp, ClipperLib.PolyType.ptSubject, true);\n\t\t\t\tif (pathIsClosed)\n\t\t\t\t{\n\t\t\t\t\tvar path = ClipperLib.Clipper.TranslatePath(paths[i], pattern[0]);\n\t\t\t\t\tc.AddPath(path, ClipperLib.PolyType.ptClip, true);\n\t\t\t\t}\n\t\t\t}\n\t\t\tc.Execute(ClipperLib.ClipType.ctUnion, solution,\n\t\t\t\tClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);\n\t\t\treturn solution;\n\t\t}\n\t}\n\t//------------------------------------------------------------------------------\n\n\tClipperLib.Clipper.TranslatePath = function (path, delta)\n\t{\n\t\tvar outPath = new ClipperLib.Path();\n\t\tfor (var i = 0; i < path.length; i++)\n\t\t\toutPath.push(new ClipperLib.IntPoint(path[i].X + delta.X, path[i].Y + delta.Y));\n\t\treturn outPath;\n\t}\n\t//------------------------------------------------------------------------------\n\n\tClipperLib.Clipper.MinkowskiDiff = function (poly1, poly2)\n\t{\n\t\tvar paths = ClipperLib.Clipper.Minkowski(poly1, poly2, false, true);\n\t\tvar c = new ClipperLib.Clipper();\n\t\tc.AddPaths(paths, ClipperLib.PolyType.ptSubject, true);\n\t\tc.Execute(ClipperLib.ClipType.ctUnion, paths, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);\n\t\treturn paths;\n\t}\n\n  ClipperLib.Clipper.PolyTreeToPaths = function (polytree)\n  {\n    var result = new Array();\n    //result.set_Capacity(polytree.get_Total());\n    ClipperLib.Clipper.AddPolyNodeToPaths(polytree, ClipperLib.Clipper.NodeType.ntAny, result);\n    return result;\n  };\n  ClipperLib.Clipper.AddPolyNodeToPaths = function (polynode, nt, paths)\n  {\n    var match = true;\n    switch (nt)\n    {\n    case ClipperLib.Clipper.NodeType.ntOpen:\n      return;\n    case ClipperLib.Clipper.NodeType.ntClosed:\n      match = !polynode.IsOpen;\n      break;\n    default:\n      break;\n    }\n    if (polynode.m_polygon.length > 0 && match)\n      paths.push(polynode.m_polygon);\n    for (var $i3 = 0, $t3 = polynode.Childs(), $l3 = $t3.length, pn = $t3[$i3]; $i3 < $l3; $i3++, pn = $t3[$i3])\n      ClipperLib.Clipper.AddPolyNodeToPaths(pn, nt, paths);\n  };\n  ClipperLib.Clipper.OpenPathsFromPolyTree = function (polytree)\n  {\n    var result = new ClipperLib.Paths();\n    //result.set_Capacity(polytree.ChildCount());\n    for (var i = 0, ilen = polytree.ChildCount(); i < ilen; i++)\n      if (polytree.Childs()[i].IsOpen)\n        result.push(polytree.Childs()[i].m_polygon);\n    return result;\n  };\n  ClipperLib.Clipper.ClosedPathsFromPolyTree = function (polytree)\n  {\n    var result = new ClipperLib.Paths();\n    //result.set_Capacity(polytree.Total());\n    ClipperLib.Clipper.AddPolyNodeToPaths(polytree, ClipperLib.Clipper.NodeType.ntClosed, result);\n    return result;\n  };\n  Inherit(ClipperLib.Clipper, ClipperLib.ClipperBase);\n  ClipperLib.Clipper.NodeType = {\n    ntAny: 0,\n    ntOpen: 1,\n    ntClosed: 2\n  };\n  ClipperLib.ClipperOffset = function (miterLimit, arcTolerance)\n  {\n    if (typeof (miterLimit) == \"undefined\") miterLimit = 2;\n    if (typeof (arcTolerance) == \"undefined\") arcTolerance = ClipperLib.ClipperOffset.def_arc_tolerance;\n    this.m_destPolys = new ClipperLib.Paths();\n    this.m_srcPoly = new ClipperLib.Path();\n    this.m_destPoly = new ClipperLib.Path();\n    this.m_normals = new Array();\n    this.m_delta = 0;\n    this.m_sinA = 0;\n    this.m_sin = 0;\n    this.m_cos = 0;\n    this.m_miterLim = 0;\n    this.m_StepsPerRad = 0;\n    this.m_lowest = new ClipperLib.IntPoint();\n    this.m_polyNodes = new ClipperLib.PolyNode();\n    this.MiterLimit = miterLimit;\n    this.ArcTolerance = arcTolerance;\n    this.m_lowest.X = -1;\n  };\n  ClipperLib.ClipperOffset.two_pi = 6.28318530717959;\n  ClipperLib.ClipperOffset.def_arc_tolerance = 0.25;\n  ClipperLib.ClipperOffset.prototype.Clear = function ()\n  {\n    ClipperLib.Clear(this.m_polyNodes.Childs());\n    this.m_lowest.X = -1;\n  };\n  ClipperLib.ClipperOffset.Round = ClipperLib.Clipper.Round;\n  ClipperLib.ClipperOffset.prototype.AddPath = function (path, joinType, endType)\n  {\n    var highI = path.length - 1;\n    if (highI < 0)\n      return;\n    var newNode = new ClipperLib.PolyNode();\n    newNode.m_jointype = joinType;\n    newNode.m_endtype = endType;\n    //strip duplicate points from path and also get index to the lowest point ...\n    if (endType == ClipperLib.EndType.etClosedLine || endType == ClipperLib.EndType.etClosedPolygon)\n      while (highI > 0 && ClipperLib.IntPoint.op_Equality(path[0], path[highI]))\n        highI--;\n    //newNode.m_polygon.set_Capacity(highI + 1);\n    newNode.m_polygon.push(path[0]);\n    var j = 0,\n      k = 0;\n    for (var i = 1; i <= highI; i++)\n      if (ClipperLib.IntPoint.op_Inequality(newNode.m_polygon[j], path[i]))\n      {\n        j++;\n        newNode.m_polygon.push(path[i]);\n        if (path[i].Y > newNode.m_polygon[k].Y || (path[i].Y == newNode.m_polygon[k].Y && path[i].X < newNode.m_polygon[k].X))\n          k = j;\n      }\n    if (endType == ClipperLib.EndType.etClosedPolygon && j < 2) return;\n\n    this.m_polyNodes.AddChild(newNode);\n    //if this path's lowest pt is lower than all the others then update m_lowest\n    if (endType != ClipperLib.EndType.etClosedPolygon)\n      return;\n    if (this.m_lowest.X < 0)\n      this.m_lowest = new ClipperLib.IntPoint(this.m_polyNodes.ChildCount() - 1, k);\n    else\n    {\n      var ip = this.m_polyNodes.Childs()[this.m_lowest.X].m_polygon[this.m_lowest.Y];\n      if (newNode.m_polygon[k].Y > ip.Y || (newNode.m_polygon[k].Y == ip.Y && newNode.m_polygon[k].X < ip.X))\n        this.m_lowest = new ClipperLib.IntPoint(this.m_polyNodes.ChildCount() - 1, k);\n    }\n  };\n  ClipperLib.ClipperOffset.prototype.AddPaths = function (paths, joinType, endType)\n  {\n    for (var i = 0, ilen = paths.length; i < ilen; i++)\n      this.AddPath(paths[i], joinType, endType);\n  };\n  ClipperLib.ClipperOffset.prototype.FixOrientations = function ()\n  {\n    //fixup orientations of all closed paths if the orientation of the\n    //closed path with the lowermost vertex is wrong ...\n    if (this.m_lowest.X >= 0 && !ClipperLib.Clipper.Orientation(this.m_polyNodes.Childs()[this.m_lowest.X].m_polygon))\n    {\n      for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n      {\n        var node = this.m_polyNodes.Childs()[i];\n        if (node.m_endtype == ClipperLib.EndType.etClosedPolygon || (node.m_endtype == ClipperLib.EndType.etClosedLine && ClipperLib.Clipper.Orientation(node.m_polygon)))\n          node.m_polygon.reverse();\n      }\n    }\n    else\n    {\n      for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n      {\n        var node = this.m_polyNodes.Childs()[i];\n        if (node.m_endtype == ClipperLib.EndType.etClosedLine && !ClipperLib.Clipper.Orientation(node.m_polygon))\n          node.m_polygon.reverse();\n      }\n    }\n  };\n  ClipperLib.ClipperOffset.GetUnitNormal = function (pt1, pt2)\n  {\n    var dx = (pt2.X - pt1.X);\n    var dy = (pt2.Y - pt1.Y);\n    if ((dx == 0) && (dy == 0))\n      return new ClipperLib.DoublePoint(0, 0);\n    var f = 1 / Math.sqrt(dx * dx + dy * dy);\n    dx *= f;\n    dy *= f;\n    return new ClipperLib.DoublePoint(dy, -dx);\n  };\n  ClipperLib.ClipperOffset.prototype.DoOffset = function (delta)\n  {\n    this.m_destPolys = new Array();\n    this.m_delta = delta;\n    //if Zero offset, just copy any CLOSED polygons to m_p and return ...\n    if (ClipperLib.ClipperBase.near_zero(delta))\n    {\n      //this.m_destPolys.set_Capacity(this.m_polyNodes.ChildCount);\n      for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n      {\n        var node = this.m_polyNodes.Childs()[i];\n        if (node.m_endtype == ClipperLib.EndType.etClosedPolygon)\n          this.m_destPolys.push(node.m_polygon);\n      }\n      return;\n    }\n    //see offset_triginometry3.svg in the documentation folder ...\n    if (this.MiterLimit > 2)\n      this.m_miterLim = 2 / (this.MiterLimit * this.MiterLimit);\n    else\n      this.m_miterLim = 0.5;\n    var y;\n    if (this.ArcTolerance <= 0)\n      y = ClipperLib.ClipperOffset.def_arc_tolerance;\n    else if (this.ArcTolerance > Math.abs(delta) * ClipperLib.ClipperOffset.def_arc_tolerance)\n      y = Math.abs(delta) * ClipperLib.ClipperOffset.def_arc_tolerance;\n    else\n      y = this.ArcTolerance;\n    //see offset_triginometry2.svg in the documentation folder ...\n    var steps = 3.14159265358979 / Math.acos(1 - y / Math.abs(delta));\n    this.m_sin = Math.sin(ClipperLib.ClipperOffset.two_pi / steps);\n    this.m_cos = Math.cos(ClipperLib.ClipperOffset.two_pi / steps);\n    this.m_StepsPerRad = steps / ClipperLib.ClipperOffset.two_pi;\n    if (delta < 0)\n      this.m_sin = -this.m_sin;\n    //this.m_destPolys.set_Capacity(this.m_polyNodes.ChildCount * 2);\n    for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n    {\n      var node = this.m_polyNodes.Childs()[i];\n      this.m_srcPoly = node.m_polygon;\n      var len = this.m_srcPoly.length;\n      if (len == 0 || (delta <= 0 && (len < 3 || node.m_endtype != ClipperLib.EndType.etClosedPolygon)))\n        continue;\n      this.m_destPoly = new Array();\n      if (len == 1)\n      {\n        if (node.m_jointype == ClipperLib.JoinType.jtRound)\n        {\n          var X = 1,\n            Y = 0;\n          for (var j = 1; j <= steps; j++)\n          {\n            this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X + X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y + Y * delta)));\n            var X2 = X;\n            X = X * this.m_cos - this.m_sin * Y;\n            Y = X2 * this.m_sin + Y * this.m_cos;\n          }\n        }\n        else\n        {\n          var X = -1,\n            Y = -1;\n          for (var j = 0; j < 4; ++j)\n          {\n            this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X + X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y + Y * delta)));\n            if (X < 0)\n              X = 1;\n            else if (Y < 0)\n              Y = 1;\n            else\n              X = -1;\n          }\n        }\n        this.m_destPolys.push(this.m_destPoly);\n        continue;\n      }\n      //build m_normals ...\n      this.m_normals.length = 0;\n      //this.m_normals.set_Capacity(len);\n      for (var j = 0; j < len - 1; j++)\n        this.m_normals.push(ClipperLib.ClipperOffset.GetUnitNormal(this.m_srcPoly[j], this.m_srcPoly[j + 1]));\n      if (node.m_endtype == ClipperLib.EndType.etClosedLine || node.m_endtype == ClipperLib.EndType.etClosedPolygon)\n        this.m_normals.push(ClipperLib.ClipperOffset.GetUnitNormal(this.m_srcPoly[len - 1], this.m_srcPoly[0]));\n      else\n        this.m_normals.push(new ClipperLib.DoublePoint(this.m_normals[len - 2]));\n      if (node.m_endtype == ClipperLib.EndType.etClosedPolygon)\n      {\n        var k = len - 1;\n        for (var j = 0; j < len; j++)\n          k = this.OffsetPoint(j, k, node.m_jointype);\n        this.m_destPolys.push(this.m_destPoly);\n      }\n      else if (node.m_endtype == ClipperLib.EndType.etClosedLine)\n      {\n        var k = len - 1;\n        for (var j = 0; j < len; j++)\n          k = this.OffsetPoint(j, k, node.m_jointype);\n        this.m_destPolys.push(this.m_destPoly);\n        this.m_destPoly = new Array();\n        //re-build m_normals ...\n        var n = this.m_normals[len - 1];\n        for (var j = len - 1; j > 0; j--)\n          this.m_normals[j] = new ClipperLib.DoublePoint(-this.m_normals[j - 1].X, -this.m_normals[j - 1].Y);\n        this.m_normals[0] = new ClipperLib.DoublePoint(-n.X, -n.Y);\n        k = 0;\n        for (var j = len - 1; j >= 0; j--)\n          k = this.OffsetPoint(j, k, node.m_jointype);\n        this.m_destPolys.push(this.m_destPoly);\n      }\n      else\n      {\n        var k = 0;\n        for (var j = 1; j < len - 1; ++j)\n          k = this.OffsetPoint(j, k, node.m_jointype);\n        var pt1;\n        if (node.m_endtype == ClipperLib.EndType.etOpenButt)\n        {\n          var j = len - 1;\n          pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[j].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[j].Y * delta));\n          this.m_destPoly.push(pt1);\n          pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X - this.m_normals[j].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y - this.m_normals[j].Y * delta));\n          this.m_destPoly.push(pt1);\n        }\n        else\n        {\n          var j = len - 1;\n          k = len - 2;\n          this.m_sinA = 0;\n          this.m_normals[j] = new ClipperLib.DoublePoint(-this.m_normals[j].X, -this.m_normals[j].Y);\n          if (node.m_endtype == ClipperLib.EndType.etOpenSquare)\n            this.DoSquare(j, k);\n          else\n            this.DoRound(j, k);\n        }\n        //re-build m_normals ...\n        for (var j = len - 1; j > 0; j--)\n          this.m_normals[j] = new ClipperLib.DoublePoint(-this.m_normals[j - 1].X, -this.m_normals[j - 1].Y);\n        this.m_normals[0] = new ClipperLib.DoublePoint(-this.m_normals[1].X, -this.m_normals[1].Y);\n        k = len - 1;\n        for (var j = k - 1; j > 0; --j)\n          k = this.OffsetPoint(j, k, node.m_jointype);\n        if (node.m_endtype == ClipperLib.EndType.etOpenButt)\n        {\n          pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X - this.m_normals[0].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y - this.m_normals[0].Y * delta));\n          this.m_destPoly.push(pt1);\n          pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X + this.m_normals[0].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y + this.m_normals[0].Y * delta));\n          this.m_destPoly.push(pt1);\n        }\n        else\n        {\n          k = 1;\n          this.m_sinA = 0;\n          if (node.m_endtype == ClipperLib.EndType.etOpenSquare)\n            this.DoSquare(0, 1);\n          else\n            this.DoRound(0, 1);\n        }\n        this.m_destPolys.push(this.m_destPoly);\n      }\n    }\n  };\n  ClipperLib.ClipperOffset.prototype.Execute = function ()\n  {\n    var a = arguments,\n      ispolytree = a[0] instanceof ClipperLib.PolyTree;\n    if (!ispolytree) // function (solution, delta)\n    {\n      var solution = a[0],\n        delta = a[1];\n      ClipperLib.Clear(solution);\n      this.FixOrientations();\n      this.DoOffset(delta);\n      //now clean up 'corners' ...\n      var clpr = new ClipperLib.Clipper(0);\n      clpr.AddPaths(this.m_destPolys, ClipperLib.PolyType.ptSubject, true);\n      if (delta > 0)\n      {\n        clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftPositive, ClipperLib.PolyFillType.pftPositive);\n      }\n      else\n      {\n        var r = ClipperLib.Clipper.GetBounds(this.m_destPolys);\n        var outer = new ClipperLib.Path();\n        outer.push(new ClipperLib.IntPoint(r.left - 10, r.bottom + 10));\n        outer.push(new ClipperLib.IntPoint(r.right + 10, r.bottom + 10));\n        outer.push(new ClipperLib.IntPoint(r.right + 10, r.top - 10));\n        outer.push(new ClipperLib.IntPoint(r.left - 10, r.top - 10));\n        clpr.AddPath(outer, ClipperLib.PolyType.ptSubject, true);\n        clpr.ReverseSolution = true;\n        clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftNegative, ClipperLib.PolyFillType.pftNegative);\n        if (solution.length > 0)\n          solution.splice(0, 1);\n      }\n      //console.log(JSON.stringify(solution));\n    }\n    else // function (polytree, delta)\n    {\n      var solution = a[0],\n        delta = a[1];\n      solution.Clear();\n      this.FixOrientations();\n      this.DoOffset(delta);\n      //now clean up 'corners' ...\n      var clpr = new ClipperLib.Clipper(0);\n      clpr.AddPaths(this.m_destPolys, ClipperLib.PolyType.ptSubject, true);\n      if (delta > 0)\n      {\n        clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftPositive, ClipperLib.PolyFillType.pftPositive);\n      }\n      else\n      {\n        var r = ClipperLib.Clipper.GetBounds(this.m_destPolys);\n        var outer = new ClipperLib.Path();\n        outer.push(new ClipperLib.IntPoint(r.left - 10, r.bottom + 10));\n        outer.push(new ClipperLib.IntPoint(r.right + 10, r.bottom + 10));\n        outer.push(new ClipperLib.IntPoint(r.right + 10, r.top - 10));\n        outer.push(new ClipperLib.IntPoint(r.left - 10, r.top - 10));\n        clpr.AddPath(outer, ClipperLib.PolyType.ptSubject, true);\n        clpr.ReverseSolution = true;\n        clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftNegative, ClipperLib.PolyFillType.pftNegative);\n        //remove the outer PolyNode rectangle ...\n        if (solution.ChildCount() == 1 && solution.Childs()[0].ChildCount() > 0)\n        {\n          var outerNode = solution.Childs()[0];\n          //solution.Childs.set_Capacity(outerNode.ChildCount);\n          solution.Childs()[0] = outerNode.Childs()[0];\n          solution.Childs()[0].m_Parent = solution;\n          for (var i = 1; i < outerNode.ChildCount(); i++)\n            solution.AddChild(outerNode.Childs()[i]);\n        }\n        else\n          solution.Clear();\n      }\n    }\n  };\n  ClipperLib.ClipperOffset.prototype.OffsetPoint = function (j, k, jointype)\n  {\n\t\t//cross product ...\n\t\tthis.m_sinA = (this.m_normals[k].X * this.m_normals[j].Y - this.m_normals[j].X * this.m_normals[k].Y);\n\n\t\tif (Math.abs(this.m_sinA * this.m_delta) < 1.0)\n\t\t{\n\t\t\t//dot product ...\n\t\t\tvar cosA = (this.m_normals[k].X * this.m_normals[j].X + this.m_normals[j].Y * this.m_normals[k].Y);\n\t\t\tif (cosA > 0) // angle ==> 0 degrees\n\t\t\t{\n\t\t\t\tthis.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[k].X * this.m_delta),\n\t\t\t\t\tClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[k].Y * this.m_delta)));\n\t\t\t\treturn k;\n\t\t\t}\n\t\t\t//else angle ==> 180 degrees\n\t\t}\n    else if (this.m_sinA > 1)\n      this.m_sinA = 1.0;\n    else if (this.m_sinA < -1)\n      this.m_sinA = -1.0;\n    if (this.m_sinA * this.m_delta < 0)\n    {\n      this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[k].X * this.m_delta),\n        ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[k].Y * this.m_delta)));\n      this.m_destPoly.push(new ClipperLib.IntPoint(this.m_srcPoly[j]));\n      this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[j].X * this.m_delta),\n        ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[j].Y * this.m_delta)));\n    }\n    else\n      switch (jointype)\n      {\n      case ClipperLib.JoinType.jtMiter:\n        {\n          var r = 1 + (this.m_normals[j].X * this.m_normals[k].X + this.m_normals[j].Y * this.m_normals[k].Y);\n          if (r >= this.m_miterLim)\n            this.DoMiter(j, k, r);\n          else\n            this.DoSquare(j, k);\n          break;\n        }\n      case ClipperLib.JoinType.jtSquare:\n        this.DoSquare(j, k);\n        break;\n      case ClipperLib.JoinType.jtRound:\n        this.DoRound(j, k);\n        break;\n      }\n    k = j;\n    return k;\n  };\n  ClipperLib.ClipperOffset.prototype.DoSquare = function (j, k)\n  {\n    var dx = Math.tan(Math.atan2(this.m_sinA,\n      this.m_normals[k].X * this.m_normals[j].X + this.m_normals[k].Y * this.m_normals[j].Y) / 4);\n    this.m_destPoly.push(new ClipperLib.IntPoint(\n      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_delta * (this.m_normals[k].X - this.m_normals[k].Y * dx)),\n      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_delta * (this.m_normals[k].Y + this.m_normals[k].X * dx))));\n    this.m_destPoly.push(new ClipperLib.IntPoint(\n      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_delta * (this.m_normals[j].X + this.m_normals[j].Y * dx)),\n      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_delta * (this.m_normals[j].Y - this.m_normals[j].X * dx))));\n  };\n  ClipperLib.ClipperOffset.prototype.DoMiter = function (j, k, r)\n  {\n    var q = this.m_delta / r;\n    this.m_destPoly.push(new ClipperLib.IntPoint(\n      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + (this.m_normals[k].X + this.m_normals[j].X) * q),\n      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + (this.m_normals[k].Y + this.m_normals[j].Y) * q)));\n  };\n  ClipperLib.ClipperOffset.prototype.DoRound = function (j, k)\n  {\n    var a = Math.atan2(this.m_sinA,\n      this.m_normals[k].X * this.m_normals[j].X + this.m_normals[k].Y * this.m_normals[j].Y);\n\n    \tvar steps = Math.max(ClipperLib.Cast_Int32(ClipperLib.ClipperOffset.Round(this.m_StepsPerRad * Math.abs(a))), 1);\n\n    var X = this.m_normals[k].X,\n      Y = this.m_normals[k].Y,\n      X2;\n    for (var i = 0; i < steps; ++i)\n    {\n      this.m_destPoly.push(new ClipperLib.IntPoint(\n        ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + X * this.m_delta),\n        ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + Y * this.m_delta)));\n      X2 = X;\n      X = X * this.m_cos - this.m_sin * Y;\n      Y = X2 * this.m_sin + Y * this.m_cos;\n    }\n    this.m_destPoly.push(new ClipperLib.IntPoint(\n      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[j].X * this.m_delta),\n      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[j].Y * this.m_delta)));\n  };\n  ClipperLib.Error = function (message)\n  {\n    try\n    {\n      throw new Error(message);\n    }\n    catch (err)\n    {\n      alert(err.message);\n    }\n  };\n  // ---------------------------------\n  // JS extension by Timo 2013\n  ClipperLib.JS = {};\n  ClipperLib.JS.AreaOfPolygon = function (poly, scale)\n  {\n    if (!scale) scale = 1;\n    return ClipperLib.Clipper.Area(poly) / (scale * scale);\n  };\n  ClipperLib.JS.AreaOfPolygons = function (poly, scale)\n  {\n    if (!scale) scale = 1;\n    var area = 0;\n    for (var i = 0; i < poly.length; i++)\n    {\n      area += ClipperLib.Clipper.Area(poly[i]);\n    }\n    return area / (scale * scale);\n  };\n  ClipperLib.JS.BoundsOfPath = function (path, scale)\n  {\n    return ClipperLib.JS.BoundsOfPaths([path], scale);\n  };\n  ClipperLib.JS.BoundsOfPaths = function (paths, scale)\n  {\n    if (!scale) scale = 1;\n    var bounds = ClipperLib.Clipper.GetBounds(paths);\n    bounds.left /= scale;\n    bounds.bottom /= scale;\n    bounds.right /= scale;\n    bounds.top /= scale;\n    return bounds;\n  };\n  // Clean() joins vertices that are too near each other\n  // and causes distortion to offsetted polygons without cleaning\n  ClipperLib.JS.Clean = function (polygon, delta)\n  {\n    if (!(polygon instanceof Array)) return [];\n    var isPolygons = polygon[0] instanceof Array;\n    var polygon = ClipperLib.JS.Clone(polygon);\n    if (typeof delta != \"number\" || delta === null)\n    {\n      ClipperLib.Error(\"Delta is not a number in Clean().\");\n      return polygon;\n    }\n    if (polygon.length === 0 || (polygon.length == 1 && polygon[0].length === 0) || delta < 0) return polygon;\n    if (!isPolygons) polygon = [polygon];\n    var k_length = polygon.length;\n    var len, poly, result, d, p, j, i;\n    var results = [];\n    for (var k = 0; k < k_length; k++)\n    {\n      poly = polygon[k];\n      len = poly.length;\n      if (len === 0) continue;\n      else if (len < 3)\n      {\n        result = poly;\n        results.push(result);\n        continue;\n      }\n      result = poly;\n      d = delta * delta;\n      //d = Math.floor(c_delta * c_delta);\n      p = poly[0];\n      j = 1;\n      for (i = 1; i < len; i++)\n      {\n        if ((poly[i].X - p.X) * (poly[i].X - p.X) +\n          (poly[i].Y - p.Y) * (poly[i].Y - p.Y) <= d)\n          continue;\n        result[j] = poly[i];\n        p = poly[i];\n        j++;\n      }\n      p = poly[j - 1];\n      if ((poly[0].X - p.X) * (poly[0].X - p.X) +\n        (poly[0].Y - p.Y) * (poly[0].Y - p.Y) <= d)\n        j--;\n      if (j < len)\n        result.splice(j, len - j);\n      if (result.length) results.push(result);\n    }\n    if (!isPolygons && results.length) results = results[0];\n    else if (!isPolygons && results.length === 0) results = [];\n    else if (isPolygons && results.length === 0) results = [\n      []\n    ];\n    return results;\n  }\n  // Make deep copy of Polygons or Polygon\n  // so that also IntPoint objects are cloned and not only referenced\n  // This should be the fastest way\n  ClipperLib.JS.Clone = function (polygon)\n  {\n    if (!(polygon instanceof Array)) return [];\n    if (polygon.length === 0) return [];\n    else if (polygon.length == 1 && polygon[0].length === 0) return [[]];\n    var isPolygons = polygon[0] instanceof Array;\n    if (!isPolygons) polygon = [polygon];\n    var len = polygon.length,\n      plen, i, j, result;\n    var results = new Array(len);\n    for (i = 0; i < len; i++)\n    {\n      plen = polygon[i].length;\n      result = new Array(plen);\n      for (j = 0; j < plen; j++)\n      {\n        result[j] = {\n          X: polygon[i][j].X,\n          Y: polygon[i][j].Y\n        };\n      }\n      results[i] = result;\n    }\n    if (!isPolygons) results = results[0];\n    return results;\n  };\n  // Removes points that doesn't affect much to the visual appearance.\n  // If middle point is at or under certain distance (tolerance) of the line segment between\n  // start and end point, the middle point is removed.\n  ClipperLib.JS.Lighten = function (polygon, tolerance)\n  {\n    if (!(polygon instanceof Array)) return [];\n    if (typeof tolerance != \"number\" || tolerance === null)\n    {\n      ClipperLib.Error(\"Tolerance is not a number in Lighten().\")\n      return ClipperLib.JS.Clone(polygon);\n    }\n    if (polygon.length === 0 || (polygon.length == 1 && polygon[0].length === 0) || tolerance < 0)\n    {\n      return ClipperLib.JS.Clone(polygon);\n    }\n    if (!(polygon[0] instanceof Array)) polygon = [polygon];\n    var i, j, poly, k, poly2, plen, A, B, P, d, rem, addlast;\n    var bxax, byay, l, ax, ay;\n    var len = polygon.length;\n    var toleranceSq = tolerance * tolerance;\n    var results = [];\n    for (i = 0; i < len; i++)\n    {\n      poly = polygon[i];\n      plen = poly.length;\n      if (plen == 0) continue;\n      for (k = 0; k < 1000000; k++) // could be forever loop, but wiser to restrict max repeat count\n      {\n        poly2 = [];\n        plen = poly.length;\n        // the first have to added to the end, if first and last are not the same\n        // this way we ensure that also the actual last point can be removed if needed\n        if (poly[plen - 1].X != poly[0].X || poly[plen - 1].Y != poly[0].Y)\n        {\n          addlast = 1;\n          poly.push(\n          {\n            X: poly[0].X,\n            Y: poly[0].Y\n          });\n          plen = poly.length;\n        }\n        else addlast = 0;\n        rem = []; // Indexes of removed points\n        for (j = 0; j < plen - 2; j++)\n        {\n          A = poly[j]; // Start point of line segment\n          P = poly[j + 1]; // Middle point. This is the one to be removed.\n          B = poly[j + 2]; // End point of line segment\n          ax = A.X;\n          ay = A.Y;\n          bxax = B.X - ax;\n          byay = B.Y - ay;\n          if (bxax !== 0 || byay !== 0) // To avoid Nan, when A==P && P==B. And to avoid peaks (A==B && A!=P), which have lenght, but not area.\n          {\n            l = ((P.X - ax) * bxax + (P.Y - ay) * byay) / (bxax * bxax + byay * byay);\n            if (l > 1)\n            {\n              ax = B.X;\n              ay = B.Y;\n            }\n            else if (l > 0)\n            {\n              ax += bxax * l;\n              ay += byay * l;\n            }\n          }\n          bxax = P.X - ax;\n          byay = P.Y - ay;\n          d = bxax * bxax + byay * byay;\n          if (d <= toleranceSq)\n          {\n            rem[j + 1] = 1;\n            j++; // when removed, transfer the pointer to the next one\n          }\n        }\n        // add all unremoved points to poly2\n        poly2.push(\n        {\n          X: poly[0].X,\n          Y: poly[0].Y\n        });\n        for (j = 1; j < plen - 1; j++)\n          if (!rem[j]) poly2.push(\n          {\n            X: poly[j].X,\n            Y: poly[j].Y\n          });\n        poly2.push(\n        {\n          X: poly[plen - 1].X,\n          Y: poly[plen - 1].Y\n        });\n        // if the first point was added to the end, remove it\n        if (addlast) poly.pop();\n        // break, if there was not anymore removed points\n        if (!rem.length) break;\n        // else continue looping using poly2, to check if there are points to remove\n        else poly = poly2;\n      }\n      plen = poly2.length;\n      // remove duplicate from end, if needed\n      if (poly2[plen - 1].X == poly2[0].X && poly2[plen - 1].Y == poly2[0].Y)\n      {\n        poly2.pop();\n      }\n      if (poly2.length > 2) // to avoid two-point-polygons\n        results.push(poly2);\n    }\n    if (!(polygon[0] instanceof Array)) results = results[0];\n    if (typeof (results) == \"undefined\") results = [\n      []\n    ];\n    return results;\n  }\n  ClipperLib.JS.PerimeterOfPath = function (path, closed, scale)\n  {\n    if (typeof (path) == \"undefined\") return 0;\n    var sqrt = Math.sqrt;\n    var perimeter = 0.0;\n    var p1, p2, p1x = 0.0,\n      p1y = 0.0,\n      p2x = 0.0,\n      p2y = 0.0;\n    var j = path.length;\n    if (j < 2) return 0;\n    if (closed)\n    {\n      path[j] = path[0];\n      j++;\n    }\n    while (--j)\n    {\n      p1 = path[j];\n      p1x = p1.X;\n      p1y = p1.Y;\n      p2 = path[j - 1];\n      p2x = p2.X;\n      p2y = p2.Y;\n      perimeter += sqrt((p1x - p2x) * (p1x - p2x) + (p1y - p2y) * (p1y - p2y));\n    }\n    if (closed) path.pop();\n    return perimeter / scale;\n  };\n  ClipperLib.JS.PerimeterOfPaths = function (paths, closed, scale)\n  {\n    if (!scale) scale = 1;\n    var perimeter = 0;\n    for (var i = 0; i < paths.length; i++)\n    {\n      perimeter += ClipperLib.JS.PerimeterOfPath(paths[i], closed, scale);\n    }\n    return perimeter;\n  };\n  ClipperLib.JS.ScaleDownPath = function (path, scale)\n  {\n    var i, p;\n    if (!scale) scale = 1;\n    i = path.length;\n    while (i--)\n    {\n      p = path[i];\n      p.X = p.X / scale;\n      p.Y = p.Y / scale;\n    }\n  };\n  ClipperLib.JS.ScaleDownPaths = function (paths, scale)\n  {\n    var i, j, p;\n    if (!scale) scale = 1;\n    i = paths.length;\n    while (i--)\n    {\n      j = paths[i].length;\n      while (j--)\n      {\n        p = paths[i][j];\n        p.X = p.X / scale;\n        p.Y = p.Y / scale;\n      }\n    }\n  };\n  ClipperLib.JS.ScaleUpPath = function (path, scale)\n  {\n    var i, p, round = Math.round;\n    if (!scale) scale = 1;\n    i = path.length;\n    while (i--)\n    {\n      p = path[i];\n      p.X = round(p.X * scale);\n      p.Y = round(p.Y * scale);\n    }\n  };\n  ClipperLib.JS.ScaleUpPaths = function (paths, scale)\n  {\n    var i, j, p, round = Math.round;\n    if (!scale) scale = 1;\n    i = paths.length;\n    while (i--)\n    {\n      j = paths[i].length;\n      while (j--)\n      {\n        p = paths[i][j];\n        p.X = round(p.X * scale);\n        p.Y = round(p.Y * scale);\n      }\n    }\n  };\n  ClipperLib.ExPolygons = function ()\n  {\n    return [];\n  }\n  ClipperLib.ExPolygon = function ()\n  {\n    this.outer = null;\n    this.holes = null;\n  };\n  ClipperLib.JS.AddOuterPolyNodeToExPolygons = function (polynode, expolygons)\n  {\n    var ep = new ClipperLib.ExPolygon();\n    ep.outer = polynode.Contour();\n    var childs = polynode.Childs();\n    var ilen = childs.length;\n    ep.holes = new Array(ilen);\n    var node, n, i, j, childs2, jlen;\n    for (i = 0; i < ilen; i++)\n    {\n      node = childs[i];\n      ep.holes[i] = node.Contour();\n      //Add outer polygons contained by (nested within) holes ...\n      for (j = 0, childs2 = node.Childs(), jlen = childs2.length; j < jlen; j++)\n      {\n        n = childs2[j];\n        ClipperLib.JS.AddOuterPolyNodeToExPolygons(n, expolygons);\n      }\n    }\n    expolygons.push(ep);\n  };\n  ClipperLib.JS.ExPolygonsToPaths = function (expolygons)\n  {\n    var a, i, alen, ilen;\n    var paths = new ClipperLib.Paths();\n    for (a = 0, alen = expolygons.length; a < alen; a++)\n    {\n      paths.push(expolygons[a].outer);\n      for (i = 0, ilen = expolygons[a].holes.length; i < ilen; i++)\n      {\n        paths.push(expolygons[a].holes[i]);\n      }\n    }\n    return paths;\n  }\n  ClipperLib.JS.PolyTreeToExPolygons = function (polytree)\n  {\n    var expolygons = new ClipperLib.ExPolygons();\n    var node, i, childs, ilen;\n    for (i = 0, childs = polytree.Childs(), ilen = childs.length; i < ilen; i++)\n    {\n      node = childs[i];\n      ClipperLib.JS.AddOuterPolyNodeToExPolygons(node, expolygons);\n    }\n    return expolygons;\n  };\n})();\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/clipper-lib/clipper.js\n// module id = 6\n// module chunks = 0","// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n// \n// http://www.apache.org/licenses/LICENSE-2.0\n// \n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//  \\\\\n//  Eve 0.4.2 - JavaScript Events Library                       \\\\\n//  \\\\\n//  Author Dmitry Baranovskiy (http://dmitry.baranovskiy.com/)  \\\\\n//  \\\\\n\n(function (glob) {\n    var version = \"0.4.2\",\n        has = \"hasOwnProperty\",\n        separator = /[\\.\\/]/,\n        comaseparator = /\\s*,\\s*/,\n        wildcard = \"*\",\n        fun = function () {},\n        numsort = function (a, b) {\n            return a - b;\n        },\n        current_event,\n        stop,\n        events = {n: {}},\n        firstDefined = function () {\n            for (var i = 0, ii = this.length; i < ii; i++) {\n                if (typeof this[i] != \"undefined\") {\n                    return this[i];\n                }\n            }\n        },\n        lastDefined = function () {\n            var i = this.length;\n            while (--i) {\n                if (typeof this[i] != \"undefined\") {\n                    return this[i];\n                }\n            }\n        },\n    /*\\\n     * eve\n     [ method ]\n\n     * Fires event with given `name`, given scope and other parameters.\n\n     > Arguments\n\n     - name (string) name of the *event*, dot (`.`) or slash (`/`) separated\n     - scope (object) context for the event handlers\n     - varargs (...) the rest of arguments will be sent to event handlers\n\n     = (object) array of returned values from the listeners. Array has two methods `.firstDefined()` and `.lastDefined()` to get first or last not `undefined` value.\n    \\*/\n        eve = function (name, scope) {\n            name = String(name);\n            var e = events,\n                oldstop = stop,\n                args = Array.prototype.slice.call(arguments, 2),\n                listeners = eve.listeners(name),\n                z = 0,\n                f = false,\n                l,\n                indexed = [],\n                queue = {},\n                out = [],\n                ce = current_event,\n                errors = [];\n            out.firstDefined = firstDefined;\n            out.lastDefined = lastDefined;\n            current_event = name;\n            stop = 0;\n            for (var i = 0, ii = listeners.length; i < ii; i++) if (\"zIndex\" in listeners[i]) {\n                indexed.push(listeners[i].zIndex);\n                if (listeners[i].zIndex < 0) {\n                    queue[listeners[i].zIndex] = listeners[i];\n                }\n            }\n            indexed.sort(numsort);\n            while (indexed[z] < 0) {\n                l = queue[indexed[z++]];\n                out.push(l.apply(scope, args));\n                if (stop) {\n                    stop = oldstop;\n                    return out;\n                }\n            }\n            for (i = 0; i < ii; i++) {\n                l = listeners[i];\n                if (\"zIndex\" in l) {\n                    if (l.zIndex == indexed[z]) {\n                        out.push(l.apply(scope, args));\n                        if (stop) {\n                            break;\n                        }\n                        do {\n                            z++;\n                            l = queue[indexed[z]];\n                            l && out.push(l.apply(scope, args));\n                            if (stop) {\n                                break;\n                            }\n                        } while (l)\n                    } else {\n                        queue[l.zIndex] = l;\n                    }\n                } else {\n                    out.push(l.apply(scope, args));\n                    if (stop) {\n                        break;\n                    }\n                }\n            }\n            stop = oldstop;\n            current_event = ce;\n            return out;\n        };\n        // Undocumented. Debug only.\n        eve._events = events;\n    /*\\\n     * eve.listeners\n     [ method ]\n\n     * Internal method which gives you array of all event handlers that will be triggered by the given `name`.\n\n     > Arguments\n\n     - name (string) name of the event, dot (`.`) or slash (`/`) separated\n\n     = (array) array of event handlers\n    \\*/\n    eve.listeners = function (name) {\n        var names = name.split(separator),\n            e = events,\n            item,\n            items,\n            k,\n            i,\n            ii,\n            j,\n            jj,\n            nes,\n            es = [e],\n            out = [];\n        for (i = 0, ii = names.length; i < ii; i++) {\n            nes = [];\n            for (j = 0, jj = es.length; j < jj; j++) {\n                e = es[j].n;\n                items = [e[names[i]], e[wildcard]];\n                k = 2;\n                while (k--) {\n                    item = items[k];\n                    if (item) {\n                        nes.push(item);\n                        out = out.concat(item.f || []);\n                    }\n                }\n            }\n            es = nes;\n        }\n        return out;\n    };\n    \n    /*\\\n     * eve.on\n     [ method ]\n     **\n     * Binds given event handler with a given name. You can use wildcards `*` for the names:\n     | eve.on(\"*.under.*\", f);\n     | eve(\"mouse.under.floor\"); // triggers f\n     * Use @eve to trigger the listener.\n     **\n     > Arguments\n     **\n     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards\n     - f (function) event handler function\n     **\n     = (function) returned function accepts a single numeric parameter that represents z-index of the handler. It is an optional feature and only used when you need to ensure that some subset of handlers will be invoked in a given order, despite of the order of assignment. \n     > Example:\n     | eve.on(\"mouse\", eatIt)(2);\n     | eve.on(\"mouse\", scream);\n     | eve.on(\"mouse\", catchIt)(1);\n     * This will ensure that `catchIt` function will be called before `eatIt`.\n     *\n     * If you want to put your handler before non-indexed handlers, specify a negative value.\n     * Note: I assume most of the time you dont need to worry about z-index, but its nice to have this feature just in case.\n    \\*/\n    eve.on = function (name, f) {\n        name = String(name);\n        if (typeof f != \"function\") {\n            return function () {};\n        }\n        var names = name.split(comaseparator);\n        for (var i = 0, ii = names.length; i < ii; i++) {\n            (function (name) {\n                var names = name.split(separator),\n                    e = events,\n                    exist;\n                for (var i = 0, ii = names.length; i < ii; i++) {\n                    e = e.n;\n                    e = e.hasOwnProperty(names[i]) && e[names[i]] || (e[names[i]] = {n: {}});\n                }\n                e.f = e.f || [];\n                for (i = 0, ii = e.f.length; i < ii; i++) if (e.f[i] == f) {\n                    exist = true;\n                    break;\n                }\n                !exist && e.f.push(f);\n            }(names[i]));\n        }\n        return function (zIndex) {\n            if (+zIndex == +zIndex) {\n                f.zIndex = +zIndex;\n            }\n        };\n    };\n    /*\\\n     * eve.f\n     [ method ]\n     **\n     * Returns function that will fire given event with optional arguments.\n     * Arguments that will be passed to the result function will be also\n     * concated to the list of final arguments.\n     | el.onclick = eve.f(\"click\", 1, 2);\n     | eve.on(\"click\", function (a, b, c) {\n     |     console.log(a, b, c); // 1, 2, [event object]\n     | });\n     > Arguments\n     - event (string) event name\n     - varargs () and any other arguments\n     = (function) possible event handler function\n    \\*/\n    eve.f = function (event) {\n        var attrs = [].slice.call(arguments, 1);\n        return function () {\n            eve.apply(null, [event, null].concat(attrs).concat([].slice.call(arguments, 0)));\n        };\n    };\n    /*\\\n     * eve.stop\n     [ method ]\n     **\n     * Is used inside an event handler to stop the event, preventing any subsequent listeners from firing.\n    \\*/\n    eve.stop = function () {\n        stop = 1;\n    };\n    /*\\\n     * eve.nt\n     [ method ]\n     **\n     * Could be used inside event handler to figure out actual name of the event.\n     **\n     > Arguments\n     **\n     - subname (string) #optional subname of the event\n     **\n     = (string) name of the event, if `subname` is not specified\n     * or\n     = (boolean) `true`, if current events name contains `subname`\n    \\*/\n    eve.nt = function (subname) {\n        if (subname) {\n            return new RegExp(\"(?:\\\\.|\\\\/|^)\" + subname + \"(?:\\\\.|\\\\/|$)\").test(current_event);\n        }\n        return current_event;\n    };\n    /*\\\n     * eve.nts\n     [ method ]\n     **\n     * Could be used inside event handler to figure out actual name of the event.\n     **\n     **\n     = (array) names of the event\n    \\*/\n    eve.nts = function () {\n        return current_event.split(separator);\n    };\n    /*\\\n     * eve.off\n     [ method ]\n     **\n     * Removes given function from the list of event listeners assigned to given name.\n     * If no arguments specified all the events will be cleared.\n     **\n     > Arguments\n     **\n     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards\n     - f (function) event handler function\n    \\*/\n    /*\\\n     * eve.unbind\n     [ method ]\n     **\n     * See @eve.off\n    \\*/\n    eve.off = eve.unbind = function (name, f) {\n        if (!name) {\n            eve._events = events = {n: {}};\n            return;\n        }\n        var names = name.split(comaseparator);\n        if (names.length > 1) {\n            for (var i = 0, ii = names.length; i < ii; i++) {\n                eve.off(names[i], f);\n            }\n            return;\n        }\n        names = name.split(separator);\n        var e,\n            key,\n            splice,\n            i, ii, j, jj,\n            cur = [events];\n        for (i = 0, ii = names.length; i < ii; i++) {\n            for (j = 0; j < cur.length; j += splice.length - 2) {\n                splice = [j, 1];\n                e = cur[j].n;\n                if (names[i] != wildcard) {\n                    if (e[names[i]]) {\n                        splice.push(e[names[i]]);\n                    }\n                } else {\n                    for (key in e) if (e[has](key)) {\n                        splice.push(e[key]);\n                    }\n                }\n                cur.splice.apply(cur, splice);\n            }\n        }\n        for (i = 0, ii = cur.length; i < ii; i++) {\n            e = cur[i];\n            while (e.n) {\n                if (f) {\n                    if (e.f) {\n                        for (j = 0, jj = e.f.length; j < jj; j++) if (e.f[j] == f) {\n                            e.f.splice(j, 1);\n                            break;\n                        }\n                        !e.f.length && delete e.f;\n                    }\n                    for (key in e.n) if (e.n[has](key) && e.n[key].f) {\n                        var funcs = e.n[key].f;\n                        for (j = 0, jj = funcs.length; j < jj; j++) if (funcs[j] == f) {\n                            funcs.splice(j, 1);\n                            break;\n                        }\n                        !funcs.length && delete e.n[key].f;\n                    }\n                } else {\n                    delete e.f;\n                    for (key in e.n) if (e.n[has](key) && e.n[key].f) {\n                        delete e.n[key].f;\n                    }\n                }\n                e = e.n;\n            }\n        }\n    };\n    /*\\\n     * eve.once\n     [ method ]\n     **\n     * Binds given event handler with a given name to only run once then unbind itself.\n     | eve.once(\"login\", f);\n     | eve(\"login\"); // triggers f\n     | eve(\"login\"); // no listeners\n     * Use @eve to trigger the listener.\n     **\n     > Arguments\n     **\n     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards\n     - f (function) event handler function\n     **\n     = (function) same return function as @eve.on\n    \\*/\n    eve.once = function (name, f) {\n        var f2 = function () {\n            eve.unbind(name, f2);\n            return f.apply(this, arguments);\n        };\n        return eve.on(name, f2);\n    };\n    /*\\\n     * eve.version\n     [ property (string) ]\n     **\n     * Current version of the library.\n    \\*/\n    eve.version = version;\n    eve.toString = function () {\n        return \"You are running Eve \" + version;\n    };\n    (typeof module != \"undefined\" && module.exports) ? (module.exports = eve) : (typeof define === \"function\" && define.amd ? (define(\"eve\", [], function() { return eve; })) : (glob.eve = eve));\n})(this);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/eve/eve.js\n// module id = 7\n// module chunks = 0","/*\n * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors\n * http://code.google.com/p/poly2tri/\n *\n * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors\n * https://github.com/r3mi/poly2tri.js\n *\n * All rights reserved.\n *\n * Distributed under the 3-clause BSD License, see LICENSE.txt\n */\n\n\"use strict\";\n\n/*\n * Function added in the JavaScript version (was not present in the c++ version)\n */\n\n/**\n * assert and throw an exception.\n *\n * @private\n * @param {boolean} condition   the condition which is asserted\n * @param {string} message      the message which is display is condition is falsy\n */\nfunction assert(condition, message) {\n    if (!condition) {\n        throw new Error(message || \"Assert Failed\");\n    }\n}\nmodule.exports = assert;\n\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/poly2tri/src/assert.js\n// module id = 8\n// module chunks = 0","/*\n * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors\n * http://code.google.com/p/poly2tri/\n * \n * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors\n * https://github.com/r3mi/poly2tri.js\n * \n * All rights reserved.\n * \n * Distributed under the 3-clause BSD License, see LICENSE.txt\n */\n\n\"use strict\";\n\n\n/*\n * Note\n * ====\n * the structure of this JavaScript version of poly2tri intentionally follows\n * as closely as possible the structure of the reference C++ version, to make it \n * easier to keep the 2 versions in sync.\n */\n\nvar xy = require('./xy');\n\n// ------------------------------------------------------------------------Point\n/**\n * Construct a point\n * @example\n *      var point = new poly2tri.Point(150, 150);\n * @public\n * @constructor\n * @struct\n * @param {number=} x    coordinate (0 if undefined)\n * @param {number=} y    coordinate (0 if undefined)\n */\nvar Point = function(x, y) {\n    /**\n     * @type {number}\n     * @expose\n     */\n    this.x = +x || 0;\n    /**\n     * @type {number}\n     * @expose\n     */\n    this.y = +y || 0;\n\n    // All extra fields added to Point are prefixed with _p2t_\n    // to avoid collisions if custom Point class is used.\n\n    /**\n     * The edges this point constitutes an upper ending point\n     * @private\n     * @type {Array.<Edge>}\n     */\n    this._p2t_edge_list = null;\n};\n\n/**\n * For pretty printing\n * @example\n *      \"p=\" + new poly2tri.Point(5,42)\n *      //  \"p=(5;42)\"\n * @returns {string} <code>\"(x;y)\"</code>\n */\nPoint.prototype.toString = function() {\n    return xy.toStringBase(this);\n};\n\n/**\n * JSON output, only coordinates\n * @example\n *      JSON.stringify(new poly2tri.Point(1,2))\n *      //  '{\"x\":1,\"y\":2}'\n */\nPoint.prototype.toJSON = function() {\n    return { x: this.x, y: this.y };\n};\n\n/**\n * Creates a copy of this Point object.\n * @return {Point} new cloned point\n */\nPoint.prototype.clone = function() {\n    return new Point(this.x, this.y);\n};\n\n/**\n * Set this Point instance to the origo. <code>(0; 0)</code>\n * @return {Point} this (for chaining)\n */\nPoint.prototype.set_zero = function() {\n    this.x = 0.0;\n    this.y = 0.0;\n    return this; // for chaining\n};\n\n/**\n * Set the coordinates of this instance.\n * @param {number} x   coordinate\n * @param {number} y   coordinate\n * @return {Point} this (for chaining)\n */\nPoint.prototype.set = function(x, y) {\n    this.x = +x || 0;\n    this.y = +y || 0;\n    return this; // for chaining\n};\n\n/**\n * Negate this Point instance. (component-wise)\n * @return {Point} this (for chaining)\n */\nPoint.prototype.negate = function() {\n    this.x = -this.x;\n    this.y = -this.y;\n    return this; // for chaining\n};\n\n/**\n * Add another Point object to this instance. (component-wise)\n * @param {!Point} n - Point object.\n * @return {Point} this (for chaining)\n */\nPoint.prototype.add = function(n) {\n    this.x += n.x;\n    this.y += n.y;\n    return this; // for chaining\n};\n\n/**\n * Subtract this Point instance with another point given. (component-wise)\n * @param {!Point} n - Point object.\n * @return {Point} this (for chaining)\n */\nPoint.prototype.sub = function(n) {\n    this.x -= n.x;\n    this.y -= n.y;\n    return this; // for chaining\n};\n\n/**\n * Multiply this Point instance by a scalar. (component-wise)\n * @param {number} s   scalar.\n * @return {Point} this (for chaining)\n */\nPoint.prototype.mul = function(s) {\n    this.x *= s;\n    this.y *= s;\n    return this; // for chaining\n};\n\n/**\n * Return the distance of this Point instance from the origo.\n * @return {number} distance\n */\nPoint.prototype.length = function() {\n    return Math.sqrt(this.x * this.x + this.y * this.y);\n};\n\n/**\n * Normalize this Point instance (as a vector).\n * @return {number} The original distance of this instance from the origo.\n */\nPoint.prototype.normalize = function() {\n    var len = this.length();\n    this.x /= len;\n    this.y /= len;\n    return len;\n};\n\n/**\n * Test this Point object with another for equality.\n * @param {!XY} p - any \"Point like\" object with {x,y}\n * @return {boolean} <code>true</code> if same x and y coordinates, <code>false</code> otherwise.\n */\nPoint.prototype.equals = function(p) {\n    return this.x === p.x && this.y === p.y;\n};\n\n\n// -----------------------------------------------------Point (\"static\" methods)\n\n/**\n * Negate a point component-wise and return the result as a new Point object.\n * @param {!XY} p - any \"Point like\" object with {x,y}\n * @return {Point} the resulting Point object.\n */\nPoint.negate = function(p) {\n    return new Point(-p.x, -p.y);\n};\n\n/**\n * Add two points component-wise and return the result as a new Point object.\n * @param {!XY} a - any \"Point like\" object with {x,y}\n * @param {!XY} b - any \"Point like\" object with {x,y}\n * @return {Point} the resulting Point object.\n */\nPoint.add = function(a, b) {\n    return new Point(a.x + b.x, a.y + b.y);\n};\n\n/**\n * Subtract two points component-wise and return the result as a new Point object.\n * @param {!XY} a - any \"Point like\" object with {x,y}\n * @param {!XY} b - any \"Point like\" object with {x,y}\n * @return {Point} the resulting Point object.\n */\nPoint.sub = function(a, b) {\n    return new Point(a.x - b.x, a.y - b.y);\n};\n\n/**\n * Multiply a point by a scalar and return the result as a new Point object.\n * @param {number} s - the scalar\n * @param {!XY} p - any \"Point like\" object with {x,y}\n * @return {Point} the resulting Point object.\n */\nPoint.mul = function(s, p) {\n    return new Point(s * p.x, s * p.y);\n};\n\n/**\n * Perform the cross product on either two points (this produces a scalar)\n * or a point and a scalar (this produces a point).\n * This function requires two parameters, either may be a Point object or a\n * number.\n * @param  {XY|number} a - Point object or scalar.\n * @param  {XY|number} b - Point object or scalar.\n * @return {Point|number} a Point object or a number, depending on the parameters.\n */\nPoint.cross = function(a, b) {\n    if (typeof(a) === 'number') {\n        if (typeof(b) === 'number') {\n            return a * b;\n        } else {\n            return new Point(-a * b.y, a * b.x);\n        }\n    } else {\n        if (typeof(b) === 'number') {\n            return new Point(b * a.y, -b * a.x);\n        } else {\n            return a.x * b.y - a.y * b.x;\n        }\n    }\n};\n\n\n// -----------------------------------------------------------------\"Point-Like\"\n/*\n * The following functions operate on \"Point\" or any \"Point like\" object \n * with {x,y} (duck typing).\n */\n\nPoint.toString = xy.toString;\nPoint.compare = xy.compare;\nPoint.cmp = xy.compare; // backward compatibility\nPoint.equals = xy.equals;\n\n/**\n * Peform the dot product on two vectors.\n * @public\n * @param {!XY} a - any \"Point like\" object with {x,y}\n * @param {!XY} b - any \"Point like\" object with {x,y}\n * @return {number} The dot product\n */\nPoint.dot = function(a, b) {\n    return a.x * b.x + a.y * b.y;\n};\n\n\n// ---------------------------------------------------------Exports (public API)\n\nmodule.exports = Point;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/poly2tri/src/point.js\n// module id = 9\n// module chunks = 0","/*\n * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors\n * http://code.google.com/p/poly2tri/\n * \n * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors\n * https://github.com/r3mi/poly2tri.js\n * \n * All rights reserved.\n * \n * Distributed under the 3-clause BSD License, see LICENSE.txt\n */\n\n/* jshint latedef:nofunc, maxcomplexity:9 */\n\n\"use strict\";\n\n/**\n * This 'Sweep' module is present in order to keep this JavaScript version\n * as close as possible to the reference C++ version, even though almost all\n * functions could be declared as methods on the {@linkcode module:sweepcontext~SweepContext} object.\n * @module\n * @private\n */\n\n/*\n * Note\n * ====\n * the structure of this JavaScript version of poly2tri intentionally follows\n * as closely as possible the structure of the reference C++ version, to make it \n * easier to keep the 2 versions in sync.\n */\n\nvar assert = require('./assert');\nvar PointError = require('./pointerror');\nvar Triangle = require('./triangle');\nvar Node = require('./advancingfront').Node;\n\n\n// ------------------------------------------------------------------------utils\n\nvar utils = require('./utils');\n\n/** @const */\nvar EPSILON = utils.EPSILON;\n\n/** @const */\nvar Orientation = utils.Orientation;\n/** @const */\nvar orient2d = utils.orient2d;\n/** @const */\nvar inScanArea = utils.inScanArea;\n/** @const */\nvar isAngleObtuse = utils.isAngleObtuse;\n\n\n// ------------------------------------------------------------------------Sweep\n\n/**\n * Triangulate the polygon with holes and Steiner points.\n * Do this AFTER you've added the polyline, holes, and Steiner points\n * @private\n * @param {!SweepContext} tcx - SweepContext object\n */\nfunction triangulate(tcx) {\n    tcx.initTriangulation();\n    tcx.createAdvancingFront();\n    // Sweep points; build mesh\n    sweepPoints(tcx);\n    // Clean up\n    finalizationPolygon(tcx);\n}\n\n/**\n * Start sweeping the Y-sorted point set from bottom to top\n * @param {!SweepContext} tcx - SweepContext object\n */\nfunction sweepPoints(tcx) {\n    var i, len = tcx.pointCount();\n    for (i = 1; i < len; ++i) {\n        var point = tcx.getPoint(i);\n        var node = pointEvent(tcx, point);\n        var edges = point._p2t_edge_list;\n        for (var j = 0; edges && j < edges.length; ++j) {\n            edgeEventByEdge(tcx, edges[j], node);\n        }\n    }\n}\n\n/**\n * @param {!SweepContext} tcx - SweepContext object\n */\nfunction finalizationPolygon(tcx) {\n    // Get an Internal triangle to start with\n    var t = tcx.front().head().next.triangle;\n    var p = tcx.front().head().next.point;\n    while (!t.getConstrainedEdgeCW(p)) {\n        t = t.neighborCCW(p);\n    }\n\n    // Collect interior triangles constrained by edges\n    tcx.meshClean(t);\n}\n\n/**\n * Find closes node to the left of the new point and\n * create a new triangle. If needed new holes and basins\n * will be filled to.\n * @param {!SweepContext} tcx - SweepContext object\n * @param {!XY} point   Point\n */\nfunction pointEvent(tcx, point) {\n    var node = tcx.locateNode(point);\n    var new_node = newFrontTriangle(tcx, point, node);\n\n    // Only need to check +epsilon since point never have smaller\n    // x value than node due to how we fetch nodes from the front\n    if (point.x <= node.point.x + (EPSILON)) {\n        fill(tcx, node);\n    }\n\n    //tcx.AddNode(new_node);\n\n    fillAdvancingFront(tcx, new_node);\n    return new_node;\n}\n\nfunction edgeEventByEdge(tcx, edge, node) {\n    tcx.edge_event.constrained_edge = edge;\n    tcx.edge_event.right = (edge.p.x > edge.q.x);\n\n    if (isEdgeSideOfTriangle(node.triangle, edge.p, edge.q)) {\n        return;\n    }\n\n    // For now we will do all needed filling\n    // TODO: integrate with flip process might give some better performance\n    //       but for now this avoid the issue with cases that needs both flips and fills\n    fillEdgeEvent(tcx, edge, node);\n    edgeEventByPoints(tcx, edge.p, edge.q, node.triangle, edge.q);\n}\n\nfunction edgeEventByPoints(tcx, ep, eq, triangle, point) {\n    if (isEdgeSideOfTriangle(triangle, ep, eq)) {\n        return;\n    }\n\n    var p1 = triangle.pointCCW(point);\n    var o1 = orient2d(eq, p1, ep);\n    if (o1 === Orientation.COLLINEAR) {\n        // TODO integrate here changes from C++ version\n        // (C++ repo revision 09880a869095 dated March 8, 2011)\n        throw new PointError('poly2tri EdgeEvent: Collinear not supported!', [eq, p1, ep]);\n    }\n\n    var p2 = triangle.pointCW(point);\n    var o2 = orient2d(eq, p2, ep);\n    if (o2 === Orientation.COLLINEAR) {\n        // TODO integrate here changes from C++ version\n        // (C++ repo revision 09880a869095 dated March 8, 2011)\n        throw new PointError('poly2tri EdgeEvent: Collinear not supported!', [eq, p2, ep]);\n    }\n\n    if (o1 === o2) {\n        // Need to decide if we are rotating CW or CCW to get to a triangle\n        // that will cross edge\n        if (o1 === Orientation.CW) {\n            triangle = triangle.neighborCCW(point);\n        } else {\n            triangle = triangle.neighborCW(point);\n        }\n        edgeEventByPoints(tcx, ep, eq, triangle, point);\n    } else {\n        // This triangle crosses constraint so lets flippin start!\n        flipEdgeEvent(tcx, ep, eq, triangle, point);\n    }\n}\n\nfunction isEdgeSideOfTriangle(triangle, ep, eq) {\n    var index = triangle.edgeIndex(ep, eq);\n    if (index !== -1) {\n        triangle.markConstrainedEdgeByIndex(index);\n        var t = triangle.getNeighbor(index);\n        if (t) {\n            t.markConstrainedEdgeByPoints(ep, eq);\n        }\n        return true;\n    }\n    return false;\n}\n\n/**\n * Creates a new front triangle and legalize it\n * @param {!SweepContext} tcx - SweepContext object\n */\nfunction newFrontTriangle(tcx, point, node) {\n    var triangle = new Triangle(point, node.point, node.next.point);\n\n    triangle.markNeighbor(node.triangle);\n    tcx.addToMap(triangle);\n\n    var new_node = new Node(point);\n    new_node.next = node.next;\n    new_node.prev = node;\n    node.next.prev = new_node;\n    node.next = new_node;\n\n    if (!legalize(tcx, triangle)) {\n        tcx.mapTriangleToNodes(triangle);\n    }\n\n    return new_node;\n}\n\n/**\n * Adds a triangle to the advancing front to fill a hole.\n * @param {!SweepContext} tcx - SweepContext object\n * @param node - middle node, that is the bottom of the hole\n */\nfunction fill(tcx, node) {\n    var triangle = new Triangle(node.prev.point, node.point, node.next.point);\n\n    // TODO: should copy the constrained_edge value from neighbor triangles\n    //       for now constrained_edge values are copied during the legalize\n    triangle.markNeighbor(node.prev.triangle);\n    triangle.markNeighbor(node.triangle);\n\n    tcx.addToMap(triangle);\n\n    // Update the advancing front\n    node.prev.next = node.next;\n    node.next.prev = node.prev;\n\n\n    // If it was legalized the triangle has already been mapped\n    if (!legalize(tcx, triangle)) {\n        tcx.mapTriangleToNodes(triangle);\n    }\n\n    //tcx.removeNode(node);\n}\n\n/**\n * Fills holes in the Advancing Front\n * @param {!SweepContext} tcx - SweepContext object\n */\nfunction fillAdvancingFront(tcx, n) {\n    // Fill right holes\n    var node = n.next;\n    while (node.next) {\n        // TODO integrate here changes from C++ version\n        // (C++ repo revision acf81f1f1764 dated April 7, 2012)\n        if (isAngleObtuse(node.point, node.next.point, node.prev.point)) {\n            break;\n        }\n        fill(tcx, node);\n        node = node.next;\n    }\n\n    // Fill left holes\n    node = n.prev;\n    while (node.prev) {\n        // TODO integrate here changes from C++ version\n        // (C++ repo revision acf81f1f1764 dated April 7, 2012)\n        if (isAngleObtuse(node.point, node.next.point, node.prev.point)) {\n            break;\n        }\n        fill(tcx, node);\n        node = node.prev;\n    }\n\n    // Fill right basins\n    if (n.next && n.next.next) {\n        if (isBasinAngleRight(n)) {\n            fillBasin(tcx, n);\n        }\n    }\n}\n\n/**\n * The basin angle is decided against the horizontal line [1,0].\n * @param {Node} node\n * @return {boolean} true if angle < 3*/4\n */\nfunction isBasinAngleRight(node) {\n    var ax = node.point.x - node.next.next.point.x;\n    var ay = node.point.y - node.next.next.point.y;\n    assert(ay >= 0, \"unordered y\");\n    return (ax >= 0 || Math.abs(ax) < ay);\n}\n\n/**\n * Returns true if triangle was legalized\n * @param {!SweepContext} tcx - SweepContext object\n * @return {boolean}\n */\nfunction legalize(tcx, t) {\n    // To legalize a triangle we start by finding if any of the three edges\n    // violate the Delaunay condition\n    for (var i = 0; i < 3; ++i) {\n        if (t.delaunay_edge[i]) {\n            continue;\n        }\n        var ot = t.getNeighbor(i);\n        if (ot) {\n            var p = t.getPoint(i);\n            var op = ot.oppositePoint(t, p);\n            var oi = ot.index(op);\n\n            // If this is a Constrained Edge or a Delaunay Edge(only during recursive legalization)\n            // then we should not try to legalize\n            if (ot.constrained_edge[oi] || ot.delaunay_edge[oi]) {\n                t.constrained_edge[i] = ot.constrained_edge[oi];\n                continue;\n            }\n\n            var inside = inCircle(p, t.pointCCW(p), t.pointCW(p), op);\n            if (inside) {\n                // Lets mark this shared edge as Delaunay\n                t.delaunay_edge[i] = true;\n                ot.delaunay_edge[oi] = true;\n\n                // Lets rotate shared edge one vertex CW to legalize it\n                rotateTrianglePair(t, p, ot, op);\n\n                // We now got one valid Delaunay Edge shared by two triangles\n                // This gives us 4 new edges to check for Delaunay\n\n                // Make sure that triangle to node mapping is done only one time for a specific triangle\n                var not_legalized = !legalize(tcx, t);\n                if (not_legalized) {\n                    tcx.mapTriangleToNodes(t);\n                }\n\n                not_legalized = !legalize(tcx, ot);\n                if (not_legalized) {\n                    tcx.mapTriangleToNodes(ot);\n                }\n                // Reset the Delaunay edges, since they only are valid Delaunay edges\n                // until we add a new triangle or point.\n                // XXX: need to think about this. Can these edges be tried after we\n                //      return to previous recursive level?\n                t.delaunay_edge[i] = false;\n                ot.delaunay_edge[oi] = false;\n\n                // If triangle have been legalized no need to check the other edges since\n                // the recursive legalization will handles those so we can end here.\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\n/**\n * <b>Requirement</b>:<br>\n * 1. a,b and c form a triangle.<br>\n * 2. a and d is know to be on opposite side of bc<br>\n * <pre>\n *                a\n *                +\n *               / \\\n *              /   \\\n *            b/     \\c\n *            +-------+\n *           /    d    \\\n *          /           \\\n * </pre>\n * <b>Fact</b>: d has to be in area B to have a chance to be inside the circle formed by\n *  a,b and c<br>\n *  d is outside B if orient2d(a,b,d) or orient2d(c,a,d) is CW<br>\n *  This preknowledge gives us a way to optimize the incircle test\n * @param pa - triangle point, opposite d\n * @param pb - triangle point\n * @param pc - triangle point\n * @param pd - point opposite a\n * @return {boolean} true if d is inside circle, false if on circle edge\n */\nfunction inCircle(pa, pb, pc, pd) {\n    var adx = pa.x - pd.x;\n    var ady = pa.y - pd.y;\n    var bdx = pb.x - pd.x;\n    var bdy = pb.y - pd.y;\n\n    var adxbdy = adx * bdy;\n    var bdxady = bdx * ady;\n    var oabd = adxbdy - bdxady;\n    if (oabd <= 0) {\n        return false;\n    }\n\n    var cdx = pc.x - pd.x;\n    var cdy = pc.y - pd.y;\n\n    var cdxady = cdx * ady;\n    var adxcdy = adx * cdy;\n    var ocad = cdxady - adxcdy;\n    if (ocad <= 0) {\n        return false;\n    }\n\n    var bdxcdy = bdx * cdy;\n    var cdxbdy = cdx * bdy;\n\n    var alift = adx * adx + ady * ady;\n    var blift = bdx * bdx + bdy * bdy;\n    var clift = cdx * cdx + cdy * cdy;\n\n    var det = alift * (bdxcdy - cdxbdy) + blift * ocad + clift * oabd;\n    return det > 0;\n}\n\n/**\n * Rotates a triangle pair one vertex CW\n *<pre>\n *       n2                    n2\n *  P +-----+             P +-----+\n *    | t  /|               |\\  t |\n *    |   / |               | \\   |\n *  n1|  /  |n3           n1|  \\  |n3\n *    | /   |    after CW   |   \\ |\n *    |/ oT |               | oT \\|\n *    +-----+ oP            +-----+\n *       n4                    n4\n * </pre>\n */\nfunction rotateTrianglePair(t, p, ot, op) {\n    var n1, n2, n3, n4;\n    n1 = t.neighborCCW(p);\n    n2 = t.neighborCW(p);\n    n3 = ot.neighborCCW(op);\n    n4 = ot.neighborCW(op);\n\n    var ce1, ce2, ce3, ce4;\n    ce1 = t.getConstrainedEdgeCCW(p);\n    ce2 = t.getConstrainedEdgeCW(p);\n    ce3 = ot.getConstrainedEdgeCCW(op);\n    ce4 = ot.getConstrainedEdgeCW(op);\n\n    var de1, de2, de3, de4;\n    de1 = t.getDelaunayEdgeCCW(p);\n    de2 = t.getDelaunayEdgeCW(p);\n    de3 = ot.getDelaunayEdgeCCW(op);\n    de4 = ot.getDelaunayEdgeCW(op);\n\n    t.legalize(p, op);\n    ot.legalize(op, p);\n\n    // Remap delaunay_edge\n    ot.setDelaunayEdgeCCW(p, de1);\n    t.setDelaunayEdgeCW(p, de2);\n    t.setDelaunayEdgeCCW(op, de3);\n    ot.setDelaunayEdgeCW(op, de4);\n\n    // Remap constrained_edge\n    ot.setConstrainedEdgeCCW(p, ce1);\n    t.setConstrainedEdgeCW(p, ce2);\n    t.setConstrainedEdgeCCW(op, ce3);\n    ot.setConstrainedEdgeCW(op, ce4);\n\n    // Remap neighbors\n    // XXX: might optimize the markNeighbor by keeping track of\n    //      what side should be assigned to what neighbor after the\n    //      rotation. Now mark neighbor does lots of testing to find\n    //      the right side.\n    t.clearNeighbors();\n    ot.clearNeighbors();\n    if (n1) {\n        ot.markNeighbor(n1);\n    }\n    if (n2) {\n        t.markNeighbor(n2);\n    }\n    if (n3) {\n        t.markNeighbor(n3);\n    }\n    if (n4) {\n        ot.markNeighbor(n4);\n    }\n    t.markNeighbor(ot);\n}\n\n/**\n * Fills a basin that has formed on the Advancing Front to the right\n * of given node.<br>\n * First we decide a left,bottom and right node that forms the\n * boundaries of the basin. Then we do a reqursive fill.\n *\n * @param {!SweepContext} tcx - SweepContext object\n * @param node - starting node, this or next node will be left node\n */\nfunction fillBasin(tcx, node) {\n    if (orient2d(node.point, node.next.point, node.next.next.point) === Orientation.CCW) {\n        tcx.basin.left_node = node.next.next;\n    } else {\n        tcx.basin.left_node = node.next;\n    }\n\n    // Find the bottom and right node\n    tcx.basin.bottom_node = tcx.basin.left_node;\n    while (tcx.basin.bottom_node.next && tcx.basin.bottom_node.point.y >= tcx.basin.bottom_node.next.point.y) {\n        tcx.basin.bottom_node = tcx.basin.bottom_node.next;\n    }\n    if (tcx.basin.bottom_node === tcx.basin.left_node) {\n        // No valid basin\n        return;\n    }\n\n    tcx.basin.right_node = tcx.basin.bottom_node;\n    while (tcx.basin.right_node.next && tcx.basin.right_node.point.y < tcx.basin.right_node.next.point.y) {\n        tcx.basin.right_node = tcx.basin.right_node.next;\n    }\n    if (tcx.basin.right_node === tcx.basin.bottom_node) {\n        // No valid basins\n        return;\n    }\n\n    tcx.basin.width = tcx.basin.right_node.point.x - tcx.basin.left_node.point.x;\n    tcx.basin.left_highest = tcx.basin.left_node.point.y > tcx.basin.right_node.point.y;\n\n    fillBasinReq(tcx, tcx.basin.bottom_node);\n}\n\n/**\n * Recursive algorithm to fill a Basin with triangles\n *\n * @param {!SweepContext} tcx - SweepContext object\n * @param node - bottom_node\n */\nfunction fillBasinReq(tcx, node) {\n    // if shallow stop filling\n    if (isShallow(tcx, node)) {\n        return;\n    }\n\n    fill(tcx, node);\n\n    var o;\n    if (node.prev === tcx.basin.left_node && node.next === tcx.basin.right_node) {\n        return;\n    } else if (node.prev === tcx.basin.left_node) {\n        o = orient2d(node.point, node.next.point, node.next.next.point);\n        if (o === Orientation.CW) {\n            return;\n        }\n        node = node.next;\n    } else if (node.next === tcx.basin.right_node) {\n        o = orient2d(node.point, node.prev.point, node.prev.prev.point);\n        if (o === Orientation.CCW) {\n            return;\n        }\n        node = node.prev;\n    } else {\n        // Continue with the neighbor node with lowest Y value\n        if (node.prev.point.y < node.next.point.y) {\n            node = node.prev;\n        } else {\n            node = node.next;\n        }\n    }\n\n    fillBasinReq(tcx, node);\n}\n\nfunction isShallow(tcx, node) {\n    var height;\n    if (tcx.basin.left_highest) {\n        height = tcx.basin.left_node.point.y - node.point.y;\n    } else {\n        height = tcx.basin.right_node.point.y - node.point.y;\n    }\n\n    // if shallow stop filling\n    if (tcx.basin.width > height) {\n        return true;\n    }\n    return false;\n}\n\nfunction fillEdgeEvent(tcx, edge, node) {\n    if (tcx.edge_event.right) {\n        fillRightAboveEdgeEvent(tcx, edge, node);\n    } else {\n        fillLeftAboveEdgeEvent(tcx, edge, node);\n    }\n}\n\nfunction fillRightAboveEdgeEvent(tcx, edge, node) {\n    while (node.next.point.x < edge.p.x) {\n        // Check if next node is below the edge\n        if (orient2d(edge.q, node.next.point, edge.p) === Orientation.CCW) {\n            fillRightBelowEdgeEvent(tcx, edge, node);\n        } else {\n            node = node.next;\n        }\n    }\n}\n\nfunction fillRightBelowEdgeEvent(tcx, edge, node) {\n    if (node.point.x < edge.p.x) {\n        if (orient2d(node.point, node.next.point, node.next.next.point) === Orientation.CCW) {\n            // Concave\n            fillRightConcaveEdgeEvent(tcx, edge, node);\n        } else {\n            // Convex\n            fillRightConvexEdgeEvent(tcx, edge, node);\n            // Retry this one\n            fillRightBelowEdgeEvent(tcx, edge, node);\n        }\n    }\n}\n\nfunction fillRightConcaveEdgeEvent(tcx, edge, node) {\n    fill(tcx, node.next);\n    if (node.next.point !== edge.p) {\n        // Next above or below edge?\n        if (orient2d(edge.q, node.next.point, edge.p) === Orientation.CCW) {\n            // Below\n            if (orient2d(node.point, node.next.point, node.next.next.point) === Orientation.CCW) {\n                // Next is concave\n                fillRightConcaveEdgeEvent(tcx, edge, node);\n            } else {\n                // Next is convex\n                /* jshint noempty:false */\n            }\n        }\n    }\n}\n\nfunction fillRightConvexEdgeEvent(tcx, edge, node) {\n    // Next concave or convex?\n    if (orient2d(node.next.point, node.next.next.point, node.next.next.next.point) === Orientation.CCW) {\n        // Concave\n        fillRightConcaveEdgeEvent(tcx, edge, node.next);\n    } else {\n        // Convex\n        // Next above or below edge?\n        if (orient2d(edge.q, node.next.next.point, edge.p) === Orientation.CCW) {\n            // Below\n            fillRightConvexEdgeEvent(tcx, edge, node.next);\n        } else {\n            // Above\n            /* jshint noempty:false */\n        }\n    }\n}\n\nfunction fillLeftAboveEdgeEvent(tcx, edge, node) {\n    while (node.prev.point.x > edge.p.x) {\n        // Check if next node is below the edge\n        if (orient2d(edge.q, node.prev.point, edge.p) === Orientation.CW) {\n            fillLeftBelowEdgeEvent(tcx, edge, node);\n        } else {\n            node = node.prev;\n        }\n    }\n}\n\nfunction fillLeftBelowEdgeEvent(tcx, edge, node) {\n    if (node.point.x > edge.p.x) {\n        if (orient2d(node.point, node.prev.point, node.prev.prev.point) === Orientation.CW) {\n            // Concave\n            fillLeftConcaveEdgeEvent(tcx, edge, node);\n        } else {\n            // Convex\n            fillLeftConvexEdgeEvent(tcx, edge, node);\n            // Retry this one\n            fillLeftBelowEdgeEvent(tcx, edge, node);\n        }\n    }\n}\n\nfunction fillLeftConvexEdgeEvent(tcx, edge, node) {\n    // Next concave or convex?\n    if (orient2d(node.prev.point, node.prev.prev.point, node.prev.prev.prev.point) === Orientation.CW) {\n        // Concave\n        fillLeftConcaveEdgeEvent(tcx, edge, node.prev);\n    } else {\n        // Convex\n        // Next above or below edge?\n        if (orient2d(edge.q, node.prev.prev.point, edge.p) === Orientation.CW) {\n            // Below\n            fillLeftConvexEdgeEvent(tcx, edge, node.prev);\n        } else {\n            // Above\n            /* jshint noempty:false */\n        }\n    }\n}\n\nfunction fillLeftConcaveEdgeEvent(tcx, edge, node) {\n    fill(tcx, node.prev);\n    if (node.prev.point !== edge.p) {\n        // Next above or below edge?\n        if (orient2d(edge.q, node.prev.point, edge.p) === Orientation.CW) {\n            // Below\n            if (orient2d(node.point, node.prev.point, node.prev.prev.point) === Orientation.CW) {\n                // Next is concave\n                fillLeftConcaveEdgeEvent(tcx, edge, node);\n            } else {\n                // Next is convex\n                /* jshint noempty:false */\n            }\n        }\n    }\n}\n\nfunction flipEdgeEvent(tcx, ep, eq, t, p) {\n    var ot = t.neighborAcross(p);\n    assert(ot, \"FLIP failed due to missing triangle!\");\n\n    var op = ot.oppositePoint(t, p);\n\n    // Additional check from Java version (see issue #88)\n    if (t.getConstrainedEdgeAcross(p)) {\n        var index = t.index(p);\n        throw new PointError(\"poly2tri Intersecting Constraints\",\n                [p, op, t.getPoint((index + 1) % 3), t.getPoint((index + 2) % 3)]);\n    }\n\n    if (inScanArea(p, t.pointCCW(p), t.pointCW(p), op)) {\n        // Lets rotate shared edge one vertex CW\n        rotateTrianglePair(t, p, ot, op);\n        tcx.mapTriangleToNodes(t);\n        tcx.mapTriangleToNodes(ot);\n\n        // XXX: in the original C++ code for the next 2 lines, we are\n        // comparing point values (and not pointers). In this JavaScript\n        // code, we are comparing point references (pointers). This works\n        // because we can't have 2 different points with the same values.\n        // But to be really equivalent, we should use \"Point.equals\" here.\n        if (p === eq && op === ep) {\n            if (eq === tcx.edge_event.constrained_edge.q && ep === tcx.edge_event.constrained_edge.p) {\n                t.markConstrainedEdgeByPoints(ep, eq);\n                ot.markConstrainedEdgeByPoints(ep, eq);\n                legalize(tcx, t);\n                legalize(tcx, ot);\n            } else {\n                // XXX: I think one of the triangles should be legalized here?\n                /* jshint noempty:false */\n            }\n        } else {\n            var o = orient2d(eq, op, ep);\n            t = nextFlipTriangle(tcx, o, t, ot, p, op);\n            flipEdgeEvent(tcx, ep, eq, t, p);\n        }\n    } else {\n        var newP = nextFlipPoint(ep, eq, ot, op);\n        flipScanEdgeEvent(tcx, ep, eq, t, ot, newP);\n        edgeEventByPoints(tcx, ep, eq, t, p);\n    }\n}\n\n/**\n * After a flip we have two triangles and know that only one will still be\n * intersecting the edge. So decide which to contiune with and legalize the other\n *\n * @param {!SweepContext} tcx - SweepContext object\n * @param o - should be the result of an orient2d( eq, op, ep )\n * @param t - triangle 1\n * @param ot - triangle 2\n * @param p - a point shared by both triangles\n * @param op - another point shared by both triangles\n * @return returns the triangle still intersecting the edge\n */\nfunction nextFlipTriangle(tcx, o, t, ot, p, op) {\n    var edge_index;\n    if (o === Orientation.CCW) {\n        // ot is not crossing edge after flip\n        edge_index = ot.edgeIndex(p, op);\n        ot.delaunay_edge[edge_index] = true;\n        legalize(tcx, ot);\n        ot.clearDelaunayEdges();\n        return t;\n    }\n\n    // t is not crossing edge after flip\n    edge_index = t.edgeIndex(p, op);\n\n    t.delaunay_edge[edge_index] = true;\n    legalize(tcx, t);\n    t.clearDelaunayEdges();\n    return ot;\n}\n\n/**\n * When we need to traverse from one triangle to the next we need\n * the point in current triangle that is the opposite point to the next\n * triangle.\n */\nfunction nextFlipPoint(ep, eq, ot, op) {\n    var o2d = orient2d(eq, op, ep);\n    if (o2d === Orientation.CW) {\n        // Right\n        return ot.pointCCW(op);\n    } else if (o2d === Orientation.CCW) {\n        // Left\n        return ot.pointCW(op);\n    } else {\n        throw new PointError(\"poly2tri [Unsupported] nextFlipPoint: opposing point on constrained edge!\", [eq, op, ep]);\n    }\n}\n\n/**\n * Scan part of the FlipScan algorithm<br>\n * When a triangle pair isn't flippable we will scan for the next\n * point that is inside the flip triangle scan area. When found\n * we generate a new flipEdgeEvent\n *\n * @param {!SweepContext} tcx - SweepContext object\n * @param ep - last point on the edge we are traversing\n * @param eq - first point on the edge we are traversing\n * @param {!Triangle} flip_triangle - the current triangle sharing the point eq with edge\n * @param t\n * @param p\n */\nfunction flipScanEdgeEvent(tcx, ep, eq, flip_triangle, t, p) {\n    var ot = t.neighborAcross(p);\n    assert(ot, \"FLIP failed due to missing triangle\");\n\n    var op = ot.oppositePoint(t, p);\n\n    if (inScanArea(eq, flip_triangle.pointCCW(eq), flip_triangle.pointCW(eq), op)) {\n        // flip with new edge op.eq\n        flipEdgeEvent(tcx, eq, op, ot, op);\n    } else {\n        var newP = nextFlipPoint(ep, eq, ot, op);\n        flipScanEdgeEvent(tcx, ep, eq, flip_triangle, ot, newP);\n    }\n}\n\n\n// ----------------------------------------------------------------------Exports\n\nexports.triangulate = triangulate;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/poly2tri/src/sweep.js\n// module id = 10\n// module chunks = 0","/*\n * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors\n * http://code.google.com/p/poly2tri/\n * \n * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors\n * https://github.com/r3mi/poly2tri.js\n * \n * All rights reserved.\n * \n * Distributed under the 3-clause BSD License, see LICENSE.txt\n */\n\n/* jshint maxcomplexity:6 */\n\n\"use strict\";\n\n\n/*\n * Note\n * ====\n * the structure of this JavaScript version of poly2tri intentionally follows\n * as closely as possible the structure of the reference C++ version, to make it \n * easier to keep the 2 versions in sync.\n */\n\nvar PointError = require('./pointerror');\nvar Point = require('./point');\nvar Triangle = require('./triangle');\nvar sweep = require('./sweep');\nvar AdvancingFront = require('./advancingfront');\nvar Node = AdvancingFront.Node;\n\n\n// ------------------------------------------------------------------------utils\n\n/**\n * Initial triangle factor, seed triangle will extend 30% of\n * PointSet width to both left and right.\n * @private\n * @const\n */\nvar kAlpha = 0.3;\n\n\n// -------------------------------------------------------------------------Edge\n/**\n * Represents a simple polygon's edge\n * @constructor\n * @struct\n * @private\n * @param {Point} p1\n * @param {Point} p2\n * @throw {PointError} if p1 is same as p2\n */\nvar Edge = function(p1, p2) {\n    this.p = p1;\n    this.q = p2;\n\n    if (p1.y > p2.y) {\n        this.q = p1;\n        this.p = p2;\n    } else if (p1.y === p2.y) {\n        if (p1.x > p2.x) {\n            this.q = p1;\n            this.p = p2;\n        } else if (p1.x === p2.x) {\n            throw new PointError('poly2tri Invalid Edge constructor: repeated points!', [p1]);\n        }\n    }\n\n    if (!this.q._p2t_edge_list) {\n        this.q._p2t_edge_list = [];\n    }\n    this.q._p2t_edge_list.push(this);\n};\n\n\n// ------------------------------------------------------------------------Basin\n/**\n * @constructor\n * @struct\n * @private\n */\nvar Basin = function() {\n    /** @type {Node} */\n    this.left_node = null;\n    /** @type {Node} */\n    this.bottom_node = null;\n    /** @type {Node} */\n    this.right_node = null;\n    /** @type {number} */\n    this.width = 0.0;\n    /** @type {boolean} */\n    this.left_highest = false;\n};\n\nBasin.prototype.clear = function() {\n    this.left_node = null;\n    this.bottom_node = null;\n    this.right_node = null;\n    this.width = 0.0;\n    this.left_highest = false;\n};\n\n// --------------------------------------------------------------------EdgeEvent\n/**\n * @constructor\n * @struct\n * @private\n */\nvar EdgeEvent = function() {\n    /** @type {Edge} */\n    this.constrained_edge = null;\n    /** @type {boolean} */\n    this.right = false;\n};\n\n// ----------------------------------------------------SweepContext (public API)\n/**\n * SweepContext constructor option\n * @typedef {Object} SweepContextOptions\n * @property {boolean=} cloneArrays - if <code>true</code>, do a shallow copy of the Array parameters\n *                  (contour, holes). Points inside arrays are never copied.\n *                  Default is <code>false</code> : keep a reference to the array arguments,\n *                  who will be modified in place.\n */\n/**\n * Constructor for the triangulation context.\n * It accepts a simple polyline (with non repeating points), \n * which defines the constrained edges.\n *\n * @example\n *          var contour = [\n *              new poly2tri.Point(100, 100),\n *              new poly2tri.Point(100, 300),\n *              new poly2tri.Point(300, 300),\n *              new poly2tri.Point(300, 100)\n *          ];\n *          var swctx = new poly2tri.SweepContext(contour, {cloneArrays: true});\n * @example\n *          var contour = [{x:100, y:100}, {x:100, y:300}, {x:300, y:300}, {x:300, y:100}];\n *          var swctx = new poly2tri.SweepContext(contour, {cloneArrays: true});\n * @constructor\n * @public\n * @struct\n * @param {Array.<XY>} contour - array of point objects. The points can be either {@linkcode Point} instances,\n *          or any \"Point like\" custom class with <code>{x, y}</code> attributes.\n * @param {SweepContextOptions=} options - constructor options\n */\nvar SweepContext = function(contour, options) {\n    options = options || {};\n    this.triangles_ = [];\n    this.map_ = [];\n    this.points_ = (options.cloneArrays ? contour.slice(0) : contour);\n    this.edge_list = [];\n\n    // Bounding box of all points. Computed at the start of the triangulation, \n    // it is stored in case it is needed by the caller.\n    this.pmin_ = this.pmax_ = null;\n\n    /**\n     * Advancing front\n     * @private\n     * @type {AdvancingFront}\n     */\n    this.front_ = null;\n\n    /**\n     * head point used with advancing front\n     * @private\n     * @type {Point}\n     */\n    this.head_ = null;\n\n    /**\n     * tail point used with advancing front\n     * @private\n     * @type {Point}\n     */\n    this.tail_ = null;\n\n    /**\n     * @private\n     * @type {Node}\n     */\n    this.af_head_ = null;\n    /**\n     * @private\n     * @type {Node}\n     */\n    this.af_middle_ = null;\n    /**\n     * @private\n     * @type {Node}\n     */\n    this.af_tail_ = null;\n\n    this.basin = new Basin();\n    this.edge_event = new EdgeEvent();\n\n    this.initEdges(this.points_);\n};\n\n\n/**\n * Add a hole to the constraints\n * @example\n *      var swctx = new poly2tri.SweepContext(contour);\n *      var hole = [\n *          new poly2tri.Point(200, 200),\n *          new poly2tri.Point(200, 250),\n *          new poly2tri.Point(250, 250)\n *      ];\n *      swctx.addHole(hole);\n * @example\n *      var swctx = new poly2tri.SweepContext(contour);\n *      swctx.addHole([{x:200, y:200}, {x:200, y:250}, {x:250, y:250}]);\n * @public\n * @param {Array.<XY>} polyline - array of \"Point like\" objects with {x,y}\n */\nSweepContext.prototype.addHole = function(polyline) {\n    this.initEdges(polyline);\n    var i, len = polyline.length;\n    for (i = 0; i < len; i++) {\n        this.points_.push(polyline[i]);\n    }\n    return this; // for chaining\n};\n\n/**\n * For backward compatibility\n * @function\n * @deprecated use {@linkcode SweepContext#addHole} instead\n */\nSweepContext.prototype.AddHole = SweepContext.prototype.addHole;\n\n\n/**\n * Add several holes to the constraints\n * @example\n *      var swctx = new poly2tri.SweepContext(contour);\n *      var holes = [\n *          [ new poly2tri.Point(200, 200), new poly2tri.Point(200, 250), new poly2tri.Point(250, 250) ],\n *          [ new poly2tri.Point(300, 300), new poly2tri.Point(300, 350), new poly2tri.Point(350, 350) ]\n *      ];\n *      swctx.addHoles(holes);\n * @example\n *      var swctx = new poly2tri.SweepContext(contour);\n *      var holes = [\n *          [{x:200, y:200}, {x:200, y:250}, {x:250, y:250}],\n *          [{x:300, y:300}, {x:300, y:350}, {x:350, y:350}]\n *      ];\n *      swctx.addHoles(holes);\n * @public\n * @param {Array.<Array.<XY>>} holes - array of array of \"Point like\" objects with {x,y}\n */\n// Method added in the JavaScript version (was not present in the c++ version)\nSweepContext.prototype.addHoles = function(holes) {\n    var i, len = holes.length;\n    for (i = 0; i < len; i++) {\n        this.initEdges(holes[i]);\n    }\n    this.points_ = this.points_.concat.apply(this.points_, holes);\n    return this; // for chaining\n};\n\n\n/**\n * Add a Steiner point to the constraints\n * @example\n *      var swctx = new poly2tri.SweepContext(contour);\n *      var point = new poly2tri.Point(150, 150);\n *      swctx.addPoint(point);\n * @example\n *      var swctx = new poly2tri.SweepContext(contour);\n *      swctx.addPoint({x:150, y:150});\n * @public\n * @param {XY} point - any \"Point like\" object with {x,y}\n */\nSweepContext.prototype.addPoint = function(point) {\n    this.points_.push(point);\n    return this; // for chaining\n};\n\n/**\n * For backward compatibility\n * @function\n * @deprecated use {@linkcode SweepContext#addPoint} instead\n */\nSweepContext.prototype.AddPoint = SweepContext.prototype.addPoint;\n\n\n/**\n * Add several Steiner points to the constraints\n * @example\n *      var swctx = new poly2tri.SweepContext(contour);\n *      var points = [\n *          new poly2tri.Point(150, 150),\n *          new poly2tri.Point(200, 250),\n *          new poly2tri.Point(250, 250)\n *      ];\n *      swctx.addPoints(points);\n * @example\n *      var swctx = new poly2tri.SweepContext(contour);\n *      swctx.addPoints([{x:150, y:150}, {x:200, y:250}, {x:250, y:250}]);\n * @public\n * @param {Array.<XY>} points - array of \"Point like\" object with {x,y}\n */\n// Method added in the JavaScript version (was not present in the c++ version)\nSweepContext.prototype.addPoints = function(points) {\n    this.points_ = this.points_.concat(points);\n    return this; // for chaining\n};\n\n\n/**\n * Triangulate the polygon with holes and Steiner points.\n * Do this AFTER you've added the polyline, holes, and Steiner points\n * @example\n *      var swctx = new poly2tri.SweepContext(contour);\n *      swctx.triangulate();\n *      var triangles = swctx.getTriangles();\n * @public\n */\n// Shortcut method for sweep.triangulate(SweepContext).\n// Method added in the JavaScript version (was not present in the c++ version)\nSweepContext.prototype.triangulate = function() {\n    sweep.triangulate(this);\n    return this; // for chaining\n};\n\n\n/**\n * Get the bounding box of the provided constraints (contour, holes and \n * Steinter points). Warning : these values are not available if the triangulation \n * has not been done yet.\n * @public\n * @returns {{min:Point,max:Point}} object with 'min' and 'max' Point\n */\n// Method added in the JavaScript version (was not present in the c++ version)\nSweepContext.prototype.getBoundingBox = function() {\n    return {min: this.pmin_, max: this.pmax_};\n};\n\n/**\n * Get result of triangulation.\n * The output triangles have vertices which are references\n * to the initial input points (not copies): any custom fields in the\n * initial points can be retrieved in the output triangles.\n * @example\n *      var swctx = new poly2tri.SweepContext(contour);\n *      swctx.triangulate();\n *      var triangles = swctx.getTriangles();\n * @example\n *      var contour = [{x:100, y:100, id:1}, {x:100, y:300, id:2}, {x:300, y:300, id:3}];\n *      var swctx = new poly2tri.SweepContext(contour);\n *      swctx.triangulate();\n *      var triangles = swctx.getTriangles();\n *      typeof triangles[0].getPoint(0).id\n *      //  \"number\"\n * @public\n * @returns {array<Triangle>}   array of triangles\n */\nSweepContext.prototype.getTriangles = function() {\n    return this.triangles_;\n};\n\n/**\n * For backward compatibility\n * @function\n * @deprecated use {@linkcode SweepContext#getTriangles} instead\n */\nSweepContext.prototype.GetTriangles = SweepContext.prototype.getTriangles;\n\n\n// ---------------------------------------------------SweepContext (private API)\n\n/** @private */\nSweepContext.prototype.front = function() {\n    return this.front_;\n};\n\n/** @private */\nSweepContext.prototype.pointCount = function() {\n    return this.points_.length;\n};\n\n/** @private */\nSweepContext.prototype.head = function() {\n    return this.head_;\n};\n\n/** @private */\nSweepContext.prototype.setHead = function(p1) {\n    this.head_ = p1;\n};\n\n/** @private */\nSweepContext.prototype.tail = function() {\n    return this.tail_;\n};\n\n/** @private */\nSweepContext.prototype.setTail = function(p1) {\n    this.tail_ = p1;\n};\n\n/** @private */\nSweepContext.prototype.getMap = function() {\n    return this.map_;\n};\n\n/** @private */\nSweepContext.prototype.initTriangulation = function() {\n    var xmax = this.points_[0].x;\n    var xmin = this.points_[0].x;\n    var ymax = this.points_[0].y;\n    var ymin = this.points_[0].y;\n\n    // Calculate bounds\n    var i, len = this.points_.length;\n    for (i = 1; i < len; i++) {\n        var p = this.points_[i];\n        /* jshint expr:true */\n        (p.x > xmax) && (xmax = p.x);\n        (p.x < xmin) && (xmin = p.x);\n        (p.y > ymax) && (ymax = p.y);\n        (p.y < ymin) && (ymin = p.y);\n    }\n    this.pmin_ = new Point(xmin, ymin);\n    this.pmax_ = new Point(xmax, ymax);\n\n    var dx = kAlpha * (xmax - xmin);\n    var dy = kAlpha * (ymax - ymin);\n    this.head_ = new Point(xmax + dx, ymin - dy);\n    this.tail_ = new Point(xmin - dx, ymin - dy);\n\n    // Sort points along y-axis\n    this.points_.sort(Point.compare);\n};\n\n/** @private */\nSweepContext.prototype.initEdges = function(polyline) {\n    var i, len = polyline.length;\n    for (i = 0; i < len; ++i) {\n        this.edge_list.push(new Edge(polyline[i], polyline[(i + 1) % len]));\n    }\n};\n\n/** @private */\nSweepContext.prototype.getPoint = function(index) {\n    return this.points_[index];\n};\n\n/** @private */\nSweepContext.prototype.addToMap = function(triangle) {\n    this.map_.push(triangle);\n};\n\n/** @private */\nSweepContext.prototype.locateNode = function(point) {\n    return this.front_.locateNode(point.x);\n};\n\n/** @private */\nSweepContext.prototype.createAdvancingFront = function() {\n    var head;\n    var middle;\n    var tail;\n    // Initial triangle\n    var triangle = new Triangle(this.points_[0], this.tail_, this.head_);\n\n    this.map_.push(triangle);\n\n    head = new Node(triangle.getPoint(1), triangle);\n    middle = new Node(triangle.getPoint(0), triangle);\n    tail = new Node(triangle.getPoint(2));\n\n    this.front_ = new AdvancingFront(head, tail);\n\n    head.next = middle;\n    middle.next = tail;\n    middle.prev = head;\n    tail.prev = middle;\n};\n\n/** @private */\nSweepContext.prototype.removeNode = function(node) {\n    // do nothing\n    /* jshint unused:false */\n};\n\n/** @private */\nSweepContext.prototype.mapTriangleToNodes = function(t) {\n    for (var i = 0; i < 3; ++i) {\n        if (!t.getNeighbor(i)) {\n            var n = this.front_.locatePoint(t.pointCW(t.getPoint(i)));\n            if (n) {\n                n.triangle = t;\n            }\n        }\n    }\n};\n\n/** @private */\nSweepContext.prototype.removeFromMap = function(triangle) {\n    var i, map = this.map_, len = map.length;\n    for (i = 0; i < len; i++) {\n        if (map[i] === triangle) {\n            map.splice(i, 1);\n            break;\n        }\n    }\n};\n\n/**\n * Do a depth first traversal to collect triangles\n * @private\n * @param {Triangle} triangle start\n */\nSweepContext.prototype.meshClean = function(triangle) {\n    // New implementation avoids recursive calls and use a loop instead.\n    // Cf. issues # 57, 65 and 69.\n    var triangles = [triangle], t, i;\n    /* jshint boss:true */\n    while (t = triangles.pop()) {\n        if (!t.isInterior()) {\n            t.setInterior(true);\n            this.triangles_.push(t);\n            for (i = 0; i < 3; i++) {\n                if (!t.constrained_edge[i]) {\n                    triangles.push(t.getNeighbor(i));\n                }\n            }\n        }\n    }\n};\n\n// ----------------------------------------------------------------------Exports\n\nmodule.exports = SweepContext;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/poly2tri/src/sweepcontext.js\n// module id = 11\n// module chunks = 0","/*\n * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors\n * http://code.google.com/p/poly2tri/\n * \n * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors\n * https://github.com/r3mi/poly2tri.js\n * \n * All rights reserved.\n * \n * Distributed under the 3-clause BSD License, see LICENSE.txt\n */\n\n\"use strict\";\n\n/**\n * Precision to detect repeated or collinear points\n * @private\n * @const {number}\n * @default\n */\nvar EPSILON = 1e-12;\nexports.EPSILON = EPSILON;\n\n/**\n * @private\n * @enum {number}\n * @readonly\n */\nvar Orientation = {\n    \"CW\": 1,\n    \"CCW\": -1,\n    \"COLLINEAR\": 0\n};\nexports.Orientation = Orientation;\n\n\n/**\n * Formula to calculate signed area<br>\n * Positive if CCW<br>\n * Negative if CW<br>\n * 0 if collinear<br>\n * <pre>\n * A[P1,P2,P3]  =  (x1*y2 - y1*x2) + (x2*y3 - y2*x3) + (x3*y1 - y3*x1)\n *              =  (x1-x3)*(y2-y3) - (y1-y3)*(x2-x3)\n * </pre>\n *\n * @private\n * @param {!XY} pa  point object with {x,y}\n * @param {!XY} pb  point object with {x,y}\n * @param {!XY} pc  point object with {x,y}\n * @return {Orientation}\n */\nfunction orient2d(pa, pb, pc) {\n    var detleft = (pa.x - pc.x) * (pb.y - pc.y);\n    var detright = (pa.y - pc.y) * (pb.x - pc.x);\n    var val = detleft - detright;\n    if (val > -(EPSILON) && val < (EPSILON)) {\n        return Orientation.COLLINEAR;\n    } else if (val > 0) {\n        return Orientation.CCW;\n    } else {\n        return Orientation.CW;\n    }\n}\nexports.orient2d = orient2d;\n\n\n/**\n *\n * @private\n * @param {!XY} pa  point object with {x,y}\n * @param {!XY} pb  point object with {x,y}\n * @param {!XY} pc  point object with {x,y}\n * @param {!XY} pd  point object with {x,y}\n * @return {boolean}\n */\nfunction inScanArea(pa, pb, pc, pd) {\n    var oadb = (pa.x - pb.x) * (pd.y - pb.y) - (pd.x - pb.x) * (pa.y - pb.y);\n    if (oadb >= -EPSILON) {\n        return false;\n    }\n\n    var oadc = (pa.x - pc.x) * (pd.y - pc.y) - (pd.x - pc.x) * (pa.y - pc.y);\n    if (oadc <= EPSILON) {\n        return false;\n    }\n    return true;\n}\nexports.inScanArea = inScanArea;\n\n\n/**\n * Check if the angle between (pa,pb) and (pa,pc) is obtuse i.e. (angle > /2 || angle < -/2)\n *\n * @private\n * @param {!XY} pa  point object with {x,y}\n * @param {!XY} pb  point object with {x,y}\n * @param {!XY} pc  point object with {x,y}\n * @return {boolean} true if angle is obtuse\n */\nfunction isAngleObtuse(pa, pb, pc) {\n    var ax = pb.x - pa.x;\n    var ay = pb.y - pa.y;\n    var bx = pc.x - pa.x;\n    var by = pc.y - pa.y;\n    return (ax * bx + ay * by) < 0;\n}\nexports.isAngleObtuse = isAngleObtuse;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/poly2tri/src/utils.js\n// module id = 12\n// module chunks = 0","window.eve = require('eve')\n\n// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nvar mina = (function (eve) {\n    var animations = {},\n    requestAnimFrame = window.requestAnimationFrame       ||\n                       window.webkitRequestAnimationFrame ||\n                       window.mozRequestAnimationFrame    ||\n                       window.oRequestAnimationFrame      ||\n                       window.msRequestAnimationFrame     ||\n                       function (callback) {\n                           setTimeout(callback, 16);\n                       },\n    isArray = Array.isArray || function (a) {\n        return a instanceof Array ||\n            Object.prototype.toString.call(a) == \"[object Array]\";\n    },\n    idgen = 0,\n    idprefix = \"M\" + (+new Date).toString(36),\n    ID = function () {\n        return idprefix + (idgen++).toString(36);\n    },\n    diff = function (a, b, A, B) {\n        if (isArray(a)) {\n            res = [];\n            for (var i = 0, ii = a.length; i < ii; i++) {\n                res[i] = diff(a[i], b, A[i], B);\n            }\n            return res;\n        }\n        var dif = (A - a) / (B - b);\n        return function (bb) {\n            return a + dif * (bb - b);\n        };\n    },\n    timer = Date.now || function () {\n        return +new Date;\n    },\n    sta = function (val) {\n        var a = this;\n        if (val == null) {\n            return a.s;\n        }\n        var ds = a.s - val;\n        a.b += a.dur * ds;\n        a.B += a.dur * ds;\n        a.s = val;\n    },\n    speed = function (val) {\n        var a = this;\n        if (val == null) {\n            return a.spd;\n        }\n        a.spd = val;\n    },\n    duration = function (val) {\n        var a = this;\n        if (val == null) {\n            return a.dur;\n        }\n        a.s = a.s * val / a.dur;\n        a.dur = val;\n    },\n    stopit = function () {\n        var a = this;\n        delete animations[a.id];\n        a.update();\n        eve(\"mina.stop.\" + a.id, a);\n    },\n    pause = function () {\n        var a = this;\n        if (a.pdif) {\n            return;\n        }\n        delete animations[a.id];\n        a.update();\n        a.pdif = a.get() - a.b;\n    },\n    resume = function () {\n        var a = this;\n        if (!a.pdif) {\n            return;\n        }\n        a.b = a.get() - a.pdif;\n        delete a.pdif;\n        animations[a.id] = a;\n    },\n    update = function () {\n        var a = this,\n            res;\n        if (isArray(a.start)) {\n            res = [];\n            for (var j = 0, jj = a.start.length; j < jj; j++) {\n                res[j] = +a.start[j] +\n                    (a.end[j] - a.start[j]) * a.easing(a.s);\n            }\n        } else {\n            res = +a.start + (a.end - a.start) * a.easing(a.s);\n        }\n        a.set(res);\n    },\n    frame = function () {\n        var len = 0;\n        for (var i in animations) if (animations.hasOwnProperty(i)) {\n            var a = animations[i],\n                b = a.get(),\n                res;\n            len++;\n            a.s = (b - a.b) / (a.dur / a.spd);\n            if (a.s >= 1) {\n                delete animations[i];\n                a.s = 1;\n                len--;\n                (function (a) {\n                    setTimeout(function () {\n                        eve(\"mina.finish.\" + a.id, a);\n                    });\n                }(a));\n            }\n            a.update();\n        }\n        len && requestAnimFrame(frame);\n    },\n    /*\\\n     * mina\n     [ method ]\n     **\n     * Generic animation of numbers\n     **\n     - a (number) start _slave_ number\n     - A (number) end _slave_ number\n     - b (number) start _master_ number (start time in general case)\n     - B (number) end _master_ number (end time in gereal case)\n     - get (function) getter of _master_ number (see @mina.time)\n     - set (function) setter of _slave_ number\n     - easing (function) #optional easing function, default is @mina.linear\n     = (object) animation descriptor\n     o {\n     o         id (string) animation id,\n     o         start (number) start _slave_ number,\n     o         end (number) end _slave_ number,\n     o         b (number) start _master_ number,\n     o         s (number) animation status (0..1),\n     o         dur (number) animation duration,\n     o         spd (number) animation speed,\n     o         get (function) getter of _master_ number (see @mina.time),\n     o         set (function) setter of _slave_ number,\n     o         easing (function) easing function, default is @mina.linear,\n     o         status (function) status getter/setter,\n     o         speed (function) speed getter/setter,\n     o         duration (function) duration getter/setter,\n     o         stop (function) animation stopper\n     o         pause (function) pauses the animation\n     o         resume (function) resumes the animation\n     o         update (function) calles setter with the right value of the animation\n     o }\n    \\*/\n    mina = function (a, A, b, B, get, set, easing) {\n        var anim = {\n            id: ID(),\n            start: a,\n            end: A,\n            b: b,\n            s: 0,\n            dur: B - b,\n            spd: 1,\n            get: get,\n            set: set,\n            easing: easing || mina.linear,\n            status: sta,\n            speed: speed,\n            duration: duration,\n            stop: stopit,\n            pause: pause,\n            resume: resume,\n            update: update\n        };\n        animations[anim.id] = anim;\n        var len = 0, i;\n        for (i in animations) if (animations.hasOwnProperty(i)) {\n            len++;\n            if (len == 2) {\n                break;\n            }\n        }\n        len == 1 && requestAnimFrame(frame);\n        return anim;\n    };\n    /*\\\n     * mina.time\n     [ method ]\n     **\n     * Returns the current time. Equivalent to:\n     | function () {\n     |     return (new Date).getTime();\n     | }\n    \\*/\n    mina.time = timer;\n    /*\\\n     * mina.getById\n     [ method ]\n     **\n     * Returns an animation by its id\n     - id (string) animation's id\n     = (object) See @mina\n    \\*/\n    mina.getById = function (id) {\n        return animations[id] || null;\n    };\n\n    /*\\\n     * mina.linear\n     [ method ]\n     **\n     * Default linear easing\n     - n (number) input 0..1\n     = (number) output 0..1\n    \\*/\n    mina.linear = function (n) {\n        return n;\n    };\n    /*\\\n     * mina.easeout\n     [ method ]\n     **\n     * Easeout easing\n     - n (number) input 0..1\n     = (number) output 0..1\n    \\*/\n    mina.easeout = function (n) {\n        return Math.pow(n, 1.7);\n    };\n    /*\\\n     * mina.easein\n     [ method ]\n     **\n     * Easein easing\n     - n (number) input 0..1\n     = (number) output 0..1\n    \\*/\n    mina.easein = function (n) {\n        return Math.pow(n, .48);\n    };\n    /*\\\n     * mina.easeinout\n     [ method ]\n     **\n     * Easeinout easing\n     - n (number) input 0..1\n     = (number) output 0..1\n    \\*/\n    mina.easeinout = function (n) {\n        if (n == 1) {\n            return 1;\n        }\n        if (n == 0) {\n            return 0;\n        }\n        var q = .48 - n / 1.04,\n            Q = Math.sqrt(.1734 + q * q),\n            x = Q - q,\n            X = Math.pow(Math.abs(x), 1 / 3) * (x < 0 ? -1 : 1),\n            y = -Q - q,\n            Y = Math.pow(Math.abs(y), 1 / 3) * (y < 0 ? -1 : 1),\n            t = X + Y + .5;\n        return (1 - t) * 3 * t * t + t * t * t;\n    };\n    /*\\\n     * mina.backin\n     [ method ]\n     **\n     * Backin easing\n     - n (number) input 0..1\n     = (number) output 0..1\n    \\*/\n    mina.backin = function (n) {\n        if (n == 1) {\n            return 1;\n        }\n        var s = 1.70158;\n        return n * n * ((s + 1) * n - s);\n    };\n    /*\\\n     * mina.backout\n     [ method ]\n     **\n     * Backout easing\n     - n (number) input 0..1\n     = (number) output 0..1\n    \\*/\n    mina.backout = function (n) {\n        if (n == 0) {\n            return 0;\n        }\n        n = n - 1;\n        var s = 1.70158;\n        return n * n * ((s + 1) * n + s) + 1;\n    };\n    /*\\\n     * mina.elastic\n     [ method ]\n     **\n     * Elastic easing\n     - n (number) input 0..1\n     = (number) output 0..1\n    \\*/\n    mina.elastic = function (n) {\n        if (n == !!n) {\n            return n;\n        }\n        return Math.pow(2, -10 * n) * Math.sin((n - .075) *\n            (2 * Math.PI) / .3) + 1;\n    };\n    /*\\\n     * mina.bounce\n     [ method ]\n     **\n     * Bounce easing\n     - n (number) input 0..1\n     = (number) output 0..1\n    \\*/\n    mina.bounce = function (n) {\n        var s = 7.5625,\n            p = 2.75,\n            l;\n        if (n < (1 / p)) {\n            l = s * n * n;\n        } else {\n            if (n < (2 / p)) {\n                n -= (1.5 / p);\n                l = s * n * n + .75;\n            } else {\n                if (n < (2.5 / p)) {\n                    n -= (2.25 / p);\n                    l = s * n * n + .9375;\n                } else {\n                    n -= (2.625 / p);\n                    l = s * n * n + .984375;\n                }\n            }\n        }\n        return l;\n    };\n    window.mina = mina;\n    return mina;\n})(typeof eve == \"undefined\" ? function () {} : eve);\n// Copyright (c) 2013 - 2015 Adobe Systems Incorporated. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nvar Snap = (function(root) {\nSnap.version = \"0.4.0\";\n/*\\\n * Snap\n [ method ]\n **\n * Creates a drawing surface or wraps existing SVG element.\n **\n - width (number|string) width of surface\n - height (number|string) height of surface\n * or\n - DOM (SVGElement) element to be wrapped into Snap structure\n * or\n - array (array) array of elements (will return set of elements)\n * or\n - query (string) CSS query selector\n = (object) @Element\n\\*/\nfunction Snap(w, h) {\n    if (w) {\n        if (w.nodeType) {\n            return wrap(w);\n        }\n        if (is(w, \"array\") && Snap.set) {\n            return Snap.set.apply(Snap, w);\n        }\n        if (w instanceof Element) {\n            return w;\n        }\n        if (h == null) {\n            w = glob.doc.querySelector(String(w));\n            return wrap(w);\n        }\n    }\n    w = w == null ? \"100%\" : w;\n    h = h == null ? \"100%\" : h;\n    return new Paper(w, h);\n}\nSnap.toString = function () {\n    return \"Snap v\" + this.version;\n};\nSnap._ = {};\nvar glob = {\n    win: root.window,\n    doc: root.window.document\n};\nSnap._.glob = glob;\nvar has = \"hasOwnProperty\",\n    Str = String,\n    toFloat = parseFloat,\n    toInt = parseInt,\n    math = Math,\n    mmax = math.max,\n    mmin = math.min,\n    abs = math.abs,\n    pow = math.pow,\n    PI = math.PI,\n    round = math.round,\n    E = \"\",\n    S = \" \",\n    objectToString = Object.prototype.toString,\n    ISURL = /^url\\(['\"]?([^\\)]+?)['\"]?\\)$/i,\n    colourRegExp = /^\\s*((#[a-f\\d]{6})|(#[a-f\\d]{3})|rgba?\\(\\s*([\\d\\.]+%?\\s*,\\s*[\\d\\.]+%?\\s*,\\s*[\\d\\.]+%?(?:\\s*,\\s*[\\d\\.]+%?)?)\\s*\\)|hsba?\\(\\s*([\\d\\.]+(?:deg|\\xb0|%)?\\s*,\\s*[\\d\\.]+%?\\s*,\\s*[\\d\\.]+(?:%?\\s*,\\s*[\\d\\.]+)?%?)\\s*\\)|hsla?\\(\\s*([\\d\\.]+(?:deg|\\xb0|%)?\\s*,\\s*[\\d\\.]+%?\\s*,\\s*[\\d\\.]+(?:%?\\s*,\\s*[\\d\\.]+)?%?)\\s*\\))\\s*$/i,\n    bezierrg = /^(?:cubic-)?bezier\\(([^,]+),([^,]+),([^,]+),([^\\)]+)\\)/,\n    reURLValue = /^url\\(#?([^)]+)\\)$/,\n    separator = Snap._.separator = /[,\\s]+/,\n    whitespace = /[\\s]/g,\n    commaSpaces = /[\\s]*,[\\s]*/,\n    hsrg = {hs: 1, rg: 1},\n    pathCommand = /([a-z])[\\s,]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[\\s]*,?[\\s]*)+)/ig,\n    tCommand = /([rstm])[\\s,]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[\\s]*,?[\\s]*)+)/ig,\n    pathValues = /(-?\\d*\\.?\\d*(?:e[\\-+]?\\\\d+)?)[\\s]*,?[\\s]*/ig,\n    idgen = 0,\n    idprefix = \"S\" + (+new Date).toString(36),\n    ID = function (el) {\n        return (el && el.type ? el.type : E) + idprefix + (idgen++).toString(36);\n    },\n    xlink = \"http://www.w3.org/1999/xlink\",\n    xmlns = \"http://www.w3.org/2000/svg\",\n    hub = {},\n    URL = Snap.url = function (url) {\n        return \"url('#\" + url + \"')\";\n    };\n\nfunction $(el, attr) {\n    if (attr) {\n        if (el == \"#text\") {\n            el = glob.doc.createTextNode(attr.text || attr[\"#text\"] || \"\");\n        }\n        if (el == \"#comment\") {\n            el = glob.doc.createComment(attr.text || attr[\"#text\"] || \"\");\n        }\n        if (typeof el == \"string\") {\n            el = $(el);\n        }\n        if (typeof attr == \"string\") {\n            if (el.nodeType == 1) {\n                if (attr.substring(0, 6) == \"xlink:\") {\n                    return el.getAttributeNS(xlink, attr.substring(6));\n                }\n                if (attr.substring(0, 4) == \"xml:\") {\n                    return el.getAttributeNS(xmlns, attr.substring(4));\n                }\n                return el.getAttribute(attr);\n            } else if (attr == \"text\") {\n                return el.nodeValue;\n            } else {\n                return null;\n            }\n        }\n        if (el.nodeType == 1) {\n            for (var key in attr) if (attr[has](key)) {\n                var val = Str(attr[key]);\n                if (val) {\n                    if (key.substring(0, 6) == \"xlink:\") {\n                        el.setAttributeNS(xlink, key.substring(6), val);\n                    } else if (key.substring(0, 4) == \"xml:\") {\n                        el.setAttributeNS(xmlns, key.substring(4), val);\n                    } else {\n                        el.setAttribute(key, val);\n                    }\n                } else {\n                    el.removeAttribute(key);\n                }\n            }\n        } else if (\"text\" in attr) {\n            el.nodeValue = attr.text;\n        }\n    } else {\n        el = glob.doc.createElementNS(xmlns, el);\n    }\n    return el;\n}\nSnap._.$ = $;\nSnap._.id = ID;\nfunction getAttrs(el) {\n    var attrs = el.attributes,\n        name,\n        out = {};\n    for (var i = 0; i < attrs.length; i++) {\n        if (attrs[i].namespaceURI == xlink) {\n            name = \"xlink:\";\n        } else {\n            name = \"\";\n        }\n        name += attrs[i].name;\n        out[name] = attrs[i].textContent;\n    }\n    return out;\n}\nfunction is(o, type) {\n    type = Str.prototype.toLowerCase.call(type);\n    if (type == \"finite\") {\n        return isFinite(o);\n    }\n    if (type == \"array\" &&\n        (o instanceof Array || Array.isArray && Array.isArray(o))) {\n        return true;\n    }\n    return  (type == \"null\" && o === null) ||\n            (type == typeof o && o !== null) ||\n            (type == \"object\" && o === Object(o)) ||\n            objectToString.call(o).slice(8, -1).toLowerCase() == type;\n}\n/*\\\n * Snap.format\n [ method ]\n **\n * Replaces construction of type `{<name>}` to the corresponding argument\n **\n - token (string) string to format\n - json (object) object which properties are used as a replacement\n = (string) formatted string\n > Usage\n | // this draws a rectangular shape equivalent to \"M10,20h40v50h-40z\"\n | paper.path(Snap.format(\"M{x},{y}h{dim.width}v{dim.height}h{dim['negative width']}z\", {\n |     x: 10,\n |     y: 20,\n |     dim: {\n |         width: 40,\n |         height: 50,\n |         \"negative width\": -40\n |     }\n | }));\n\\*/\nSnap.format = (function () {\n    var tokenRegex = /\\{([^\\}]+)\\}/g,\n        objNotationRegex = /(?:(?:^|\\.)(.+?)(?=\\[|\\.|$|\\()|\\[('|\")(.+?)\\2\\])(\\(\\))?/g, // matches .xxxxx or [\"xxxxx\"] to run over object properties\n        replacer = function (all, key, obj) {\n            var res = obj;\n            key.replace(objNotationRegex, function (all, name, quote, quotedName, isFunc) {\n                name = name || quotedName;\n                if (res) {\n                    if (name in res) {\n                        res = res[name];\n                    }\n                    typeof res == \"function\" && isFunc && (res = res());\n                }\n            });\n            res = (res == null || res == obj ? all : res) + \"\";\n            return res;\n        };\n    return function (str, obj) {\n        return Str(str).replace(tokenRegex, function (all, key) {\n            return replacer(all, key, obj);\n        });\n    };\n})();\nfunction clone(obj) {\n    if (typeof obj == \"function\" || Object(obj) !== obj) {\n        return obj;\n    }\n    var res = new obj.constructor;\n    for (var key in obj) if (obj[has](key)) {\n        res[key] = clone(obj[key]);\n    }\n    return res;\n}\nSnap._.clone = clone;\nfunction repush(array, item) {\n    for (var i = 0, ii = array.length; i < ii; i++) if (array[i] === item) {\n        return array.push(array.splice(i, 1)[0]);\n    }\n}\nfunction cacher(f, scope, postprocessor) {\n    function newf() {\n        var arg = Array.prototype.slice.call(arguments, 0),\n            args = arg.join(\"\\u2400\"),\n            cache = newf.cache = newf.cache || {},\n            count = newf.count = newf.count || [];\n        if (cache[has](args)) {\n            repush(count, args);\n            return postprocessor ? postprocessor(cache[args]) : cache[args];\n        }\n        count.length >= 1e3 && delete cache[count.shift()];\n        count.push(args);\n        cache[args] = f.apply(scope, arg);\n        return postprocessor ? postprocessor(cache[args]) : cache[args];\n    }\n    return newf;\n}\nSnap._.cacher = cacher;\nfunction angle(x1, y1, x2, y2, x3, y3) {\n    if (x3 == null) {\n        var x = x1 - x2,\n            y = y1 - y2;\n        if (!x && !y) {\n            return 0;\n        }\n        return (180 + math.atan2(-y, -x) * 180 / PI + 360) % 360;\n    } else {\n        return angle(x1, y1, x3, y3) - angle(x2, y2, x3, y3);\n    }\n}\nfunction rad(deg) {\n    return deg % 360 * PI / 180;\n}\nfunction deg(rad) {\n    return rad * 180 / PI % 360;\n}\nfunction x_y() {\n    return this.x + S + this.y;\n}\nfunction x_y_w_h() {\n    return this.x + S + this.y + S + this.width + \" \\xd7 \" + this.height;\n}\n\n/*\\\n * Snap.rad\n [ method ]\n **\n * Transform angle to radians\n - deg (number) angle in degrees\n = (number) angle in radians\n\\*/\nSnap.rad = rad;\n/*\\\n * Snap.deg\n [ method ]\n **\n * Transform angle to degrees\n - rad (number) angle in radians\n = (number) angle in degrees\n\\*/\nSnap.deg = deg;\n/*\\\n * Snap.sin\n [ method ]\n **\n * Equivalent to `Math.sin()` only works with degrees, not radians.\n - angle (number) angle in degrees\n = (number) sin\n\\*/\nSnap.sin = function (angle) {\n    return math.sin(Snap.rad(angle));\n};\n/*\\\n * Snap.tan\n [ method ]\n **\n * Equivalent to `Math.tan()` only works with degrees, not radians.\n - angle (number) angle in degrees\n = (number) tan\n\\*/\nSnap.tan = function (angle) {\n    return math.tan(Snap.rad(angle));\n};\n/*\\\n * Snap.cos\n [ method ]\n **\n * Equivalent to `Math.cos()` only works with degrees, not radians.\n - angle (number) angle in degrees\n = (number) cos\n\\*/\nSnap.cos = function (angle) {\n    return math.cos(Snap.rad(angle));\n};\n/*\\\n * Snap.asin\n [ method ]\n **\n * Equivalent to `Math.asin()` only works with degrees, not radians.\n - num (number) value\n = (number) asin in degrees\n\\*/\nSnap.asin = function (num) {\n    return Snap.deg(math.asin(num));\n};\n/*\\\n * Snap.acos\n [ method ]\n **\n * Equivalent to `Math.acos()` only works with degrees, not radians.\n - num (number) value\n = (number) acos in degrees\n\\*/\nSnap.acos = function (num) {\n    return Snap.deg(math.acos(num));\n};\n/*\\\n * Snap.atan\n [ method ]\n **\n * Equivalent to `Math.atan()` only works with degrees, not radians.\n - num (number) value\n = (number) atan in degrees\n\\*/\nSnap.atan = function (num) {\n    return Snap.deg(math.atan(num));\n};\n/*\\\n * Snap.atan2\n [ method ]\n **\n * Equivalent to `Math.atan2()` only works with degrees, not radians.\n - num (number) value\n = (number) atan2 in degrees\n\\*/\nSnap.atan2 = function (num) {\n    return Snap.deg(math.atan2(num));\n};\n/*\\\n * Snap.angle\n [ method ]\n **\n * Returns an angle between two or three points\n > Parameters\n - x1 (number) x coord of first point\n - y1 (number) y coord of first point\n - x2 (number) x coord of second point\n - y2 (number) y coord of second point\n - x3 (number) #optional x coord of third point\n - y3 (number) #optional y coord of third point\n = (number) angle in degrees\n\\*/\nSnap.angle = angle;\n/*\\\n * Snap.len\n [ method ]\n **\n * Returns distance between two points\n > Parameters\n - x1 (number) x coord of first point\n - y1 (number) y coord of first point\n - x2 (number) x coord of second point\n - y2 (number) y coord of second point\n = (number) distance\n\\*/\nSnap.len = function (x1, y1, x2, y2) {\n    return Math.sqrt(Snap.len2(x1, y1, x2, y2));\n};\n/*\\\n * Snap.len2\n [ method ]\n **\n * Returns squared distance between two points\n > Parameters\n - x1 (number) x coord of first point\n - y1 (number) y coord of first point\n - x2 (number) x coord of second point\n - y2 (number) y coord of second point\n = (number) distance\n\\*/\nSnap.len2 = function (x1, y1, x2, y2) {\n    return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);\n};\n/*\\\n * Snap.closestPoint\n [ method ]\n **\n * Returns closest point to a given one on a given path.\n > Parameters\n - path (Element) path element\n - x (number) x coord of a point\n - y (number) y coord of a point\n = (object) in format\n {\n    x (number) x coord of the point on the path\n    y (number) y coord of the point on the path\n    length (number) length of the path to the point\n    distance (number) distance from the given point to the path\n }\n\\*/\n// Copied from http://bl.ocks.org/mbostock/8027637\nSnap.closestPoint = function (path, x, y) {\n    function distance2(p) {\n        var dx = p.x - x,\n            dy = p.y - y;\n        return dx * dx + dy * dy;\n    }\n    var pathNode = path.node,\n        pathLength = pathNode.getTotalLength(),\n        precision = pathLength / pathNode.pathSegList.numberOfItems * .125,\n        best,\n        bestLength,\n        bestDistance = Infinity;\n\n    // linear scan for coarse approximation\n    for (var scan, scanLength = 0, scanDistance; scanLength <= pathLength; scanLength += precision) {\n        if ((scanDistance = distance2(scan = pathNode.getPointAtLength(scanLength))) < bestDistance) {\n            best = scan, bestLength = scanLength, bestDistance = scanDistance;\n        }\n    }\n\n    // binary search for precise estimate\n    precision *= .5;\n    while (precision > .5) {\n        var before,\n            after,\n            beforeLength,\n            afterLength,\n            beforeDistance,\n            afterDistance;\n        if ((beforeLength = bestLength - precision) >= 0 && (beforeDistance = distance2(before = pathNode.getPointAtLength(beforeLength))) < bestDistance) {\n            best = before, bestLength = beforeLength, bestDistance = beforeDistance;\n        } else if ((afterLength = bestLength + precision) <= pathLength && (afterDistance = distance2(after = pathNode.getPointAtLength(afterLength))) < bestDistance) {\n            best = after, bestLength = afterLength, bestDistance = afterDistance;\n        } else {\n            precision *= .5;\n        }\n    }\n\n    best = {\n        x: best.x,\n        y: best.y,\n        length: bestLength,\n        distance: Math.sqrt(bestDistance)\n    };\n    return best;\n}\n/*\\\n * Snap.is\n [ method ]\n **\n * Handy replacement for the `typeof` operator\n - o () any object or primitive\n - type (string) name of the type, e.g., `string`, `function`, `number`, etc.\n = (boolean) `true` if given value is of given type\n\\*/\nSnap.is = is;\n/*\\\n * Snap.snapTo\n [ method ]\n **\n * Snaps given value to given grid\n - values (array|number) given array of values or step of the grid\n - value (number) value to adjust\n - tolerance (number) #optional maximum distance to the target value that would trigger the snap. Default is `10`.\n = (number) adjusted value\n\\*/\nSnap.snapTo = function (values, value, tolerance) {\n    tolerance = is(tolerance, \"finite\") ? tolerance : 10;\n    if (is(values, \"array\")) {\n        var i = values.length;\n        while (i--) if (abs(values[i] - value) <= tolerance) {\n            return values[i];\n        }\n    } else {\n        values = +values;\n        var rem = value % values;\n        if (rem < tolerance) {\n            return value - rem;\n        }\n        if (rem > values - tolerance) {\n            return value - rem + values;\n        }\n    }\n    return value;\n};\n// Colour\n/*\\\n * Snap.getRGB\n [ method ]\n **\n * Parses color string as RGB object\n - color (string) color string in one of the following formats:\n # <ul>\n #     <li>Color name (<code>red</code>, <code>green</code>, <code>cornflowerblue</code>, etc)</li>\n #     <li>#  shortened HTML color: (<code>#000</code>, <code>#fc0</code>, etc.)</li>\n #     <li>#  full length HTML color: (<code>#000000</code>, <code>#bd2300</code>)</li>\n #     <li>rgb(, , )  red, green and blue channels values: (<code>rgb(200,&nbsp;100,&nbsp;0)</code>)</li>\n #     <li>rgba(, , , )  also with opacity</li>\n #     <li>rgb(%, %, %)  same as above, but in %: (<code>rgb(100%,&nbsp;175%,&nbsp;0%)</code>)</li>\n #     <li>rgba(%, %, %, %)  also with opacity</li>\n #     <li>hsb(, , )  hue, saturation and brightness values: (<code>hsb(0.5,&nbsp;0.25,&nbsp;1)</code>)</li>\n #     <li>hsba(, , , )  also with opacity</li>\n #     <li>hsb(%, %, %)  same as above, but in %</li>\n #     <li>hsba(%, %, %, %)  also with opacity</li>\n #     <li>hsl(, , )  hue, saturation and luminosity values: (<code>hsb(0.5,&nbsp;0.25,&nbsp;0.5)</code>)</li>\n #     <li>hsla(, , , )  also with opacity</li>\n #     <li>hsl(%, %, %)  same as above, but in %</li>\n #     <li>hsla(%, %, %, %)  also with opacity</li>\n # </ul>\n * Note that `%` can be used any time: `rgb(20%, 255, 50%)`.\n = (object) RGB object in the following format:\n o {\n o     r (number) red,\n o     g (number) green,\n o     b (number) blue,\n o     hex (string) color in HTML/CSS format: #,\n o     error (boolean) true if string can't be parsed\n o }\n\\*/\nSnap.getRGB = cacher(function (colour) {\n    if (!colour || !!((colour = Str(colour)).indexOf(\"-\") + 1)) {\n        return {r: -1, g: -1, b: -1, hex: \"none\", error: 1, toString: rgbtoString};\n    }\n    if (colour == \"none\") {\n        return {r: -1, g: -1, b: -1, hex: \"none\", toString: rgbtoString};\n    }\n    !(hsrg[has](colour.toLowerCase().substring(0, 2)) || colour.charAt() == \"#\") && (colour = toHex(colour));\n    if (!colour) {\n        return {r: -1, g: -1, b: -1, hex: \"none\", error: 1, toString: rgbtoString};\n    }\n    var res,\n        red,\n        green,\n        blue,\n        opacity,\n        t,\n        values,\n        rgb = colour.match(colourRegExp);\n    if (rgb) {\n        if (rgb[2]) {\n            blue = toInt(rgb[2].substring(5), 16);\n            green = toInt(rgb[2].substring(3, 5), 16);\n            red = toInt(rgb[2].substring(1, 3), 16);\n        }\n        if (rgb[3]) {\n            blue = toInt((t = rgb[3].charAt(3)) + t, 16);\n            green = toInt((t = rgb[3].charAt(2)) + t, 16);\n            red = toInt((t = rgb[3].charAt(1)) + t, 16);\n        }\n        if (rgb[4]) {\n            values = rgb[4].split(commaSpaces);\n            red = toFloat(values[0]);\n            values[0].slice(-1) == \"%\" && (red *= 2.55);\n            green = toFloat(values[1]);\n            values[1].slice(-1) == \"%\" && (green *= 2.55);\n            blue = toFloat(values[2]);\n            values[2].slice(-1) == \"%\" && (blue *= 2.55);\n            rgb[1].toLowerCase().slice(0, 4) == \"rgba\" && (opacity = toFloat(values[3]));\n            values[3] && values[3].slice(-1) == \"%\" && (opacity /= 100);\n        }\n        if (rgb[5]) {\n            values = rgb[5].split(commaSpaces);\n            red = toFloat(values[0]);\n            values[0].slice(-1) == \"%\" && (red /= 100);\n            green = toFloat(values[1]);\n            values[1].slice(-1) == \"%\" && (green /= 100);\n            blue = toFloat(values[2]);\n            values[2].slice(-1) == \"%\" && (blue /= 100);\n            (values[0].slice(-3) == \"deg\" || values[0].slice(-1) == \"\\xb0\") && (red /= 360);\n            rgb[1].toLowerCase().slice(0, 4) == \"hsba\" && (opacity = toFloat(values[3]));\n            values[3] && values[3].slice(-1) == \"%\" && (opacity /= 100);\n            return Snap.hsb2rgb(red, green, blue, opacity);\n        }\n        if (rgb[6]) {\n            values = rgb[6].split(commaSpaces);\n            red = toFloat(values[0]);\n            values[0].slice(-1) == \"%\" && (red /= 100);\n            green = toFloat(values[1]);\n            values[1].slice(-1) == \"%\" && (green /= 100);\n            blue = toFloat(values[2]);\n            values[2].slice(-1) == \"%\" && (blue /= 100);\n            (values[0].slice(-3) == \"deg\" || values[0].slice(-1) == \"\\xb0\") && (red /= 360);\n            rgb[1].toLowerCase().slice(0, 4) == \"hsla\" && (opacity = toFloat(values[3]));\n            values[3] && values[3].slice(-1) == \"%\" && (opacity /= 100);\n            return Snap.hsl2rgb(red, green, blue, opacity);\n        }\n        red = mmin(math.round(red), 255);\n        green = mmin(math.round(green), 255);\n        blue = mmin(math.round(blue), 255);\n        opacity = mmin(mmax(opacity, 0), 1);\n        rgb = {r: red, g: green, b: blue, toString: rgbtoString};\n        rgb.hex = \"#\" + (16777216 | blue | (green << 8) | (red << 16)).toString(16).slice(1);\n        rgb.opacity = is(opacity, \"finite\") ? opacity : 1;\n        return rgb;\n    }\n    return {r: -1, g: -1, b: -1, hex: \"none\", error: 1, toString: rgbtoString};\n}, Snap);\n/*\\\n * Snap.hsb\n [ method ]\n **\n * Converts HSB values to a hex representation of the color\n - h (number) hue\n - s (number) saturation\n - b (number) value or brightness\n = (string) hex representation of the color\n\\*/\nSnap.hsb = cacher(function (h, s, b) {\n    return Snap.hsb2rgb(h, s, b).hex;\n});\n/*\\\n * Snap.hsl\n [ method ]\n **\n * Converts HSL values to a hex representation of the color\n - h (number) hue\n - s (number) saturation\n - l (number) luminosity\n = (string) hex representation of the color\n\\*/\nSnap.hsl = cacher(function (h, s, l) {\n    return Snap.hsl2rgb(h, s, l).hex;\n});\n/*\\\n * Snap.rgb\n [ method ]\n **\n * Converts RGB values to a hex representation of the color\n - r (number) red\n - g (number) green\n - b (number) blue\n = (string) hex representation of the color\n\\*/\nSnap.rgb = cacher(function (r, g, b, o) {\n    if (is(o, \"finite\")) {\n        var round = math.round;\n        return \"rgba(\" + [round(r), round(g), round(b), +o.toFixed(2)] + \")\";\n    }\n    return \"#\" + (16777216 | b | (g << 8) | (r << 16)).toString(16).slice(1);\n});\nvar toHex = function (color) {\n    var i = glob.doc.getElementsByTagName(\"head\")[0] || glob.doc.getElementsByTagName(\"svg\")[0],\n        red = \"rgb(255, 0, 0)\";\n    toHex = cacher(function (color) {\n        if (color.toLowerCase() == \"red\") {\n            return red;\n        }\n        i.style.color = red;\n        i.style.color = color;\n        var out = glob.doc.defaultView.getComputedStyle(i, E).getPropertyValue(\"color\");\n        return out == red ? null : out;\n    });\n    return toHex(color);\n},\nhsbtoString = function () {\n    return \"hsb(\" + [this.h, this.s, this.b] + \")\";\n},\nhsltoString = function () {\n    return \"hsl(\" + [this.h, this.s, this.l] + \")\";\n},\nrgbtoString = function () {\n    return this.opacity == 1 || this.opacity == null ?\n            this.hex :\n            \"rgba(\" + [this.r, this.g, this.b, this.opacity] + \")\";\n},\nprepareRGB = function (r, g, b) {\n    if (g == null && is(r, \"object\") && \"r\" in r && \"g\" in r && \"b\" in r) {\n        b = r.b;\n        g = r.g;\n        r = r.r;\n    }\n    if (g == null && is(r, string)) {\n        var clr = Snap.getRGB(r);\n        r = clr.r;\n        g = clr.g;\n        b = clr.b;\n    }\n    if (r > 1 || g > 1 || b > 1) {\n        r /= 255;\n        g /= 255;\n        b /= 255;\n    }\n\n    return [r, g, b];\n},\npackageRGB = function (r, g, b, o) {\n    r = math.round(r * 255);\n    g = math.round(g * 255);\n    b = math.round(b * 255);\n    var rgb = {\n        r: r,\n        g: g,\n        b: b,\n        opacity: is(o, \"finite\") ? o : 1,\n        hex: Snap.rgb(r, g, b),\n        toString: rgbtoString\n    };\n    is(o, \"finite\") && (rgb.opacity = o);\n    return rgb;\n};\n/*\\\n * Snap.color\n [ method ]\n **\n * Parses the color string and returns an object featuring the color's component values\n - clr (string) color string in one of the supported formats (see @Snap.getRGB)\n = (object) Combined RGB/HSB object in the following format:\n o {\n o     r (number) red,\n o     g (number) green,\n o     b (number) blue,\n o     hex (string) color in HTML/CSS format: #,\n o     error (boolean) `true` if string can't be parsed,\n o     h (number) hue,\n o     s (number) saturation,\n o     v (number) value (brightness),\n o     l (number) lightness\n o }\n\\*/\nSnap.color = function (clr) {\n    var rgb;\n    if (is(clr, \"object\") && \"h\" in clr && \"s\" in clr && \"b\" in clr) {\n        rgb = Snap.hsb2rgb(clr);\n        clr.r = rgb.r;\n        clr.g = rgb.g;\n        clr.b = rgb.b;\n        clr.opacity = 1;\n        clr.hex = rgb.hex;\n    } else if (is(clr, \"object\") && \"h\" in clr && \"s\" in clr && \"l\" in clr) {\n        rgb = Snap.hsl2rgb(clr);\n        clr.r = rgb.r;\n        clr.g = rgb.g;\n        clr.b = rgb.b;\n        clr.opacity = 1;\n        clr.hex = rgb.hex;\n    } else {\n        if (is(clr, \"string\")) {\n            clr = Snap.getRGB(clr);\n        }\n        if (is(clr, \"object\") && \"r\" in clr && \"g\" in clr && \"b\" in clr && !(\"error\" in clr)) {\n            rgb = Snap.rgb2hsl(clr);\n            clr.h = rgb.h;\n            clr.s = rgb.s;\n            clr.l = rgb.l;\n            rgb = Snap.rgb2hsb(clr);\n            clr.v = rgb.b;\n        } else {\n            clr = {hex: \"none\"};\n            clr.r = clr.g = clr.b = clr.h = clr.s = clr.v = clr.l = -1;\n            clr.error = 1;\n        }\n    }\n    clr.toString = rgbtoString;\n    return clr;\n};\n/*\\\n * Snap.hsb2rgb\n [ method ]\n **\n * Converts HSB values to an RGB object\n - h (number) hue\n - s (number) saturation\n - v (number) value or brightness\n = (object) RGB object in the following format:\n o {\n o     r (number) red,\n o     g (number) green,\n o     b (number) blue,\n o     hex (string) color in HTML/CSS format: #\n o }\n\\*/\nSnap.hsb2rgb = function (h, s, v, o) {\n    if (is(h, \"object\") && \"h\" in h && \"s\" in h && \"b\" in h) {\n        v = h.b;\n        s = h.s;\n        o = h.o;\n        h = h.h;\n    }\n    h *= 360;\n    var R, G, B, X, C;\n    h = (h % 360) / 60;\n    C = v * s;\n    X = C * (1 - abs(h % 2 - 1));\n    R = G = B = v - C;\n\n    h = ~~h;\n    R += [C, X, 0, 0, X, C][h];\n    G += [X, C, C, X, 0, 0][h];\n    B += [0, 0, X, C, C, X][h];\n    return packageRGB(R, G, B, o);\n};\n/*\\\n * Snap.hsl2rgb\n [ method ]\n **\n * Converts HSL values to an RGB object\n - h (number) hue\n - s (number) saturation\n - l (number) luminosity\n = (object) RGB object in the following format:\n o {\n o     r (number) red,\n o     g (number) green,\n o     b (number) blue,\n o     hex (string) color in HTML/CSS format: #\n o }\n\\*/\nSnap.hsl2rgb = function (h, s, l, o) {\n    if (is(h, \"object\") && \"h\" in h && \"s\" in h && \"l\" in h) {\n        l = h.l;\n        s = h.s;\n        h = h.h;\n    }\n    if (h > 1 || s > 1 || l > 1) {\n        h /= 360;\n        s /= 100;\n        l /= 100;\n    }\n    h *= 360;\n    var R, G, B, X, C;\n    h = (h % 360) / 60;\n    C = 2 * s * (l < .5 ? l : 1 - l);\n    X = C * (1 - abs(h % 2 - 1));\n    R = G = B = l - C / 2;\n\n    h = ~~h;\n    R += [C, X, 0, 0, X, C][h];\n    G += [X, C, C, X, 0, 0][h];\n    B += [0, 0, X, C, C, X][h];\n    return packageRGB(R, G, B, o);\n};\n/*\\\n * Snap.rgb2hsb\n [ method ]\n **\n * Converts RGB values to an HSB object\n - r (number) red\n - g (number) green\n - b (number) blue\n = (object) HSB object in the following format:\n o {\n o     h (number) hue,\n o     s (number) saturation,\n o     b (number) brightness\n o }\n\\*/\nSnap.rgb2hsb = function (r, g, b) {\n    b = prepareRGB(r, g, b);\n    r = b[0];\n    g = b[1];\n    b = b[2];\n\n    var H, S, V, C;\n    V = mmax(r, g, b);\n    C = V - mmin(r, g, b);\n    H = (C == 0 ? null :\n         V == r ? (g - b) / C :\n         V == g ? (b - r) / C + 2 :\n                  (r - g) / C + 4\n        );\n    H = ((H + 360) % 6) * 60 / 360;\n    S = C == 0 ? 0 : C / V;\n    return {h: H, s: S, b: V, toString: hsbtoString};\n};\n/*\\\n * Snap.rgb2hsl\n [ method ]\n **\n * Converts RGB values to an HSL object\n - r (number) red\n - g (number) green\n - b (number) blue\n = (object) HSL object in the following format:\n o {\n o     h (number) hue,\n o     s (number) saturation,\n o     l (number) luminosity\n o }\n\\*/\nSnap.rgb2hsl = function (r, g, b) {\n    b = prepareRGB(r, g, b);\n    r = b[0];\n    g = b[1];\n    b = b[2];\n\n    var H, S, L, M, m, C;\n    M = mmax(r, g, b);\n    m = mmin(r, g, b);\n    C = M - m;\n    H = (C == 0 ? null :\n         M == r ? (g - b) / C :\n         M == g ? (b - r) / C + 2 :\n                  (r - g) / C + 4);\n    H = ((H + 360) % 6) * 60 / 360;\n    L = (M + m) / 2;\n    S = (C == 0 ? 0 :\n         L < .5 ? C / (2 * L) :\n                  C / (2 - 2 * L));\n    return {h: H, s: S, l: L, toString: hsltoString};\n};\n\n// Transformations\n/*\\\n * Snap.parsePathString\n [ method ]\n **\n * Utility method\n **\n * Parses given path string into an array of arrays of path segments\n - pathString (string|array) path string or array of segments (in the last case it is returned straight away)\n = (array) array of segments\n\\*/\nSnap.parsePathString = function (pathString) {\n    if (!pathString) {\n        return null;\n    }\n    var pth = Snap.path(pathString);\n    if (pth.arr) {\n        return Snap.path.clone(pth.arr);\n    }\n\n    var paramCounts = {a: 7, c: 6, o: 2, h: 1, l: 2, m: 2, r: 4, q: 4, s: 4, t: 2, v: 1, u: 3, z: 0},\n        data = [];\n    if (is(pathString, \"array\") && is(pathString[0], \"array\")) { // rough assumption\n        data = Snap.path.clone(pathString);\n    }\n    if (!data.length) {\n        Str(pathString).replace(pathCommand, function (a, b, c) {\n            var params = [],\n                name = b.toLowerCase();\n            c.replace(pathValues, function (a, b) {\n                b && params.push(+b);\n            });\n            if (name == \"m\" && params.length > 2) {\n                data.push([b].concat(params.splice(0, 2)));\n                name = \"l\";\n                b = b == \"m\" ? \"l\" : \"L\";\n            }\n            if (name == \"o\" && params.length == 1) {\n                data.push([b, params[0]]);\n            }\n            if (name == \"r\") {\n                data.push([b].concat(params));\n            } else while (params.length >= paramCounts[name]) {\n                data.push([b].concat(params.splice(0, paramCounts[name])));\n                if (!paramCounts[name]) {\n                    break;\n                }\n            }\n        });\n    }\n    data.toString = Snap.path.toString;\n    pth.arr = Snap.path.clone(data);\n    return data;\n};\n/*\\\n * Snap.parseTransformString\n [ method ]\n **\n * Utility method\n **\n * Parses given transform string into an array of transformations\n - TString (string|array) transform string or array of transformations (in the last case it is returned straight away)\n = (array) array of transformations\n\\*/\nvar parseTransformString = Snap.parseTransformString = function (TString) {\n    if (!TString) {\n        return null;\n    }\n    var paramCounts = {r: 3, s: 4, t: 2, m: 6},\n        data = [];\n    if (is(TString, \"array\") && is(TString[0], \"array\")) { // rough assumption\n        data = Snap.path.clone(TString);\n    }\n    if (!data.length) {\n        Str(TString).replace(tCommand, function (a, b, c) {\n            var params = [],\n                name = b.toLowerCase();\n            c.replace(pathValues, function (a, b) {\n                b && params.push(+b);\n            });\n            data.push([b].concat(params));\n        });\n    }\n    data.toString = Snap.path.toString;\n    return data;\n};\nfunction svgTransform2string(tstr) {\n    var res = [];\n    tstr = tstr.replace(/(?:^|\\s)(\\w+)\\(([^)]+)\\)/g, function (all, name, params) {\n        params = params.split(/\\s*,\\s*|\\s+/);\n        if (name == \"rotate\" && params.length == 1) {\n            params.push(0, 0);\n        }\n        if (name == \"scale\") {\n            if (params.length > 2) {\n                params = params.slice(0, 2);\n            } else if (params.length == 2) {\n                params.push(0, 0);\n            }\n            if (params.length == 1) {\n                params.push(params[0], 0, 0);\n            }\n        }\n        if (name == \"skewX\") {\n            res.push([\"m\", 1, 0, math.tan(rad(params[0])), 1, 0, 0]);\n        } else if (name == \"skewY\") {\n            res.push([\"m\", 1, math.tan(rad(params[0])), 0, 1, 0, 0]);\n        } else {\n            res.push([name.charAt(0)].concat(params));\n        }\n        return all;\n    });\n    return res;\n}\nSnap._.svgTransform2string = svgTransform2string;\nSnap._.rgTransform = /^[a-z][\\s]*-?\\.?\\d/i;\nfunction transform2matrix(tstr, bbox) {\n    var tdata = parseTransformString(tstr),\n        m = new Snap.Matrix;\n    if (tdata) {\n        for (var i = 0, ii = tdata.length; i < ii; i++) {\n            var t = tdata[i],\n                tlen = t.length,\n                command = Str(t[0]).toLowerCase(),\n                absolute = t[0] != command,\n                inver = absolute ? m.invert() : 0,\n                x1,\n                y1,\n                x2,\n                y2,\n                bb;\n            if (command == \"t\" && tlen == 2){\n                m.translate(t[1], 0);\n            } else if (command == \"t\" && tlen == 3) {\n                if (absolute) {\n                    x1 = inver.x(0, 0);\n                    y1 = inver.y(0, 0);\n                    x2 = inver.x(t[1], t[2]);\n                    y2 = inver.y(t[1], t[2]);\n                    m.translate(x2 - x1, y2 - y1);\n                } else {\n                    m.translate(t[1], t[2]);\n                }\n            } else if (command == \"r\") {\n                if (tlen == 2) {\n                    bb = bb || bbox;\n                    m.rotate(t[1], bb.x + bb.width / 2, bb.y + bb.height / 2);\n                } else if (tlen == 4) {\n                    if (absolute) {\n                        x2 = inver.x(t[2], t[3]);\n                        y2 = inver.y(t[2], t[3]);\n                        m.rotate(t[1], x2, y2);\n                    } else {\n                        m.rotate(t[1], t[2], t[3]);\n                    }\n                }\n            } else if (command == \"s\") {\n                if (tlen == 2 || tlen == 3) {\n                    bb = bb || bbox;\n                    m.scale(t[1], t[tlen - 1], bb.x + bb.width / 2, bb.y + bb.height / 2);\n                } else if (tlen == 4) {\n                    if (absolute) {\n                        x2 = inver.x(t[2], t[3]);\n                        y2 = inver.y(t[2], t[3]);\n                        m.scale(t[1], t[1], x2, y2);\n                    } else {\n                        m.scale(t[1], t[1], t[2], t[3]);\n                    }\n                } else if (tlen == 5) {\n                    if (absolute) {\n                        x2 = inver.x(t[3], t[4]);\n                        y2 = inver.y(t[3], t[4]);\n                        m.scale(t[1], t[2], x2, y2);\n                    } else {\n                        m.scale(t[1], t[2], t[3], t[4]);\n                    }\n                }\n            } else if (command == \"m\" && tlen == 7) {\n                m.add(t[1], t[2], t[3], t[4], t[5], t[6]);\n            }\n        }\n    }\n    return m;\n}\nSnap._.transform2matrix = transform2matrix;\nSnap._unit2px = unit2px;\nvar contains = glob.doc.contains || glob.doc.compareDocumentPosition ?\n    function (a, b) {\n        var adown = a.nodeType == 9 ? a.documentElement : a,\n            bup = b && b.parentNode;\n            return a == bup || !!(bup && bup.nodeType == 1 && (\n                adown.contains ?\n                    adown.contains(bup) :\n                    a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16\n            ));\n    } :\n    function (a, b) {\n        if (b) {\n            while (b) {\n                b = b.parentNode;\n                if (b == a) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    };\nfunction getSomeDefs(el) {\n    var p = (el.node.ownerSVGElement && wrap(el.node.ownerSVGElement)) ||\n            (el.node.parentNode && wrap(el.node.parentNode)) ||\n            Snap.select(\"svg\") ||\n            Snap(0, 0),\n        pdefs = p.select(\"defs\"),\n        defs  = pdefs == null ? false : pdefs.node;\n    if (!defs) {\n        defs = make(\"defs\", p.node).node;\n    }\n    return defs;\n}\nfunction getSomeSVG(el) {\n    return el.node.ownerSVGElement && wrap(el.node.ownerSVGElement) || Snap.select(\"svg\");\n}\nSnap._.getSomeDefs = getSomeDefs;\nSnap._.getSomeSVG = getSomeSVG;\nfunction unit2px(el, name, value) {\n    var svg = getSomeSVG(el).node,\n        out = {},\n        mgr = svg.querySelector(\".svg---mgr\");\n    if (!mgr) {\n        mgr = $(\"rect\");\n        $(mgr, {x: -9e9, y: -9e9, width: 10, height: 10, \"class\": \"svg---mgr\", fill: \"none\"});\n        svg.appendChild(mgr);\n    }\n    function getW(val) {\n        if (val == null) {\n            return E;\n        }\n        if (val == +val) {\n            return val;\n        }\n        $(mgr, {width: val});\n        try {\n            return mgr.getBBox().width;\n        } catch (e) {\n            return 0;\n        }\n    }\n    function getH(val) {\n        if (val == null) {\n            return E;\n        }\n        if (val == +val) {\n            return val;\n        }\n        $(mgr, {height: val});\n        try {\n            return mgr.getBBox().height;\n        } catch (e) {\n            return 0;\n        }\n    }\n    function set(nam, f) {\n        if (name == null) {\n            out[nam] = f(el.attr(nam) || 0);\n        } else if (nam == name) {\n            out = f(value == null ? el.attr(nam) || 0 : value);\n        }\n    }\n    switch (el.type) {\n        case \"rect\":\n            set(\"rx\", getW);\n            set(\"ry\", getH);\n        case \"image\":\n            set(\"width\", getW);\n            set(\"height\", getH);\n        case \"text\":\n            set(\"x\", getW);\n            set(\"y\", getH);\n        break;\n        case \"circle\":\n            set(\"cx\", getW);\n            set(\"cy\", getH);\n            set(\"r\", getW);\n        break;\n        case \"ellipse\":\n            set(\"cx\", getW);\n            set(\"cy\", getH);\n            set(\"rx\", getW);\n            set(\"ry\", getH);\n        break;\n        case \"line\":\n            set(\"x1\", getW);\n            set(\"x2\", getW);\n            set(\"y1\", getH);\n            set(\"y2\", getH);\n        break;\n        case \"marker\":\n            set(\"refX\", getW);\n            set(\"markerWidth\", getW);\n            set(\"refY\", getH);\n            set(\"markerHeight\", getH);\n        break;\n        case \"radialGradient\":\n            set(\"fx\", getW);\n            set(\"fy\", getH);\n        break;\n        case \"tspan\":\n            set(\"dx\", getW);\n            set(\"dy\", getH);\n        break;\n        default:\n            set(name, getW);\n    }\n    svg.removeChild(mgr);\n    return out;\n}\n/*\\\n * Snap.select\n [ method ]\n **\n * Wraps a DOM element specified by CSS selector as @Element\n - query (string) CSS selector of the element\n = (Element) the current element\n\\*/\nSnap.select = function (query) {\n    query = Str(query).replace(/([^\\\\]):/g, \"$1\\\\:\");\n    return wrap(glob.doc.querySelector(query));\n};\n/*\\\n * Snap.selectAll\n [ method ]\n **\n * Wraps DOM elements specified by CSS selector as set or array of @Element\n - query (string) CSS selector of the element\n = (Element) the current element\n\\*/\nSnap.selectAll = function (query) {\n    var nodelist = glob.doc.querySelectorAll(query),\n        set = (Snap.set || Array)();\n    for (var i = 0; i < nodelist.length; i++) {\n        set.push(wrap(nodelist[i]));\n    }\n    return set;\n};\n\nfunction add2group(list) {\n    if (!is(list, \"array\")) {\n        list = Array.prototype.slice.call(arguments, 0);\n    }\n    var i = 0,\n        j = 0,\n        node = this.node;\n    while (this[i]) delete this[i++];\n    for (i = 0; i < list.length; i++) {\n        if (list[i].type == \"set\") {\n            list[i].forEach(function (el) {\n                node.appendChild(el.node);\n            });\n        } else {\n            node.appendChild(list[i].node);\n        }\n    }\n    var children = node.childNodes;\n    for (i = 0; i < children.length; i++) {\n        this[j++] = wrap(children[i]);\n    }\n    return this;\n}\n// Hub garbage collector every 10s\nsetInterval(function () {\n    for (var key in hub) if (hub[has](key)) {\n        var el = hub[key],\n            node = el.node;\n        if (el.type != \"svg\" && !node.ownerSVGElement || el.type == \"svg\" && (!node.parentNode || \"ownerSVGElement\" in node.parentNode && !node.ownerSVGElement)) {\n            delete hub[key];\n        }\n    }\n}, 1e4);\nfunction Element(el) {\n    if (el.snap in hub) {\n        return hub[el.snap];\n    }\n    var svg;\n    try {\n        svg = el.ownerSVGElement;\n    } catch(e) {}\n    /*\\\n     * Element.node\n     [ property (object) ]\n     **\n     * Gives you a reference to the DOM object, so you can assign event handlers or just mess around.\n     > Usage\n     | // draw a circle at coordinate 10,10 with radius of 10\n     | var c = paper.circle(10, 10, 10);\n     | c.node.onclick = function () {\n     |     c.attr(\"fill\", \"red\");\n     | };\n    \\*/\n    this.node = el;\n    if (svg) {\n        this.paper = new Paper(svg);\n    }\n    /*\\\n     * Element.type\n     [ property (string) ]\n     **\n     * SVG tag name of the given element.\n    \\*/\n    this.type = el.tagName || el.nodeName;\n    var id = this.id = ID(this);\n    this.anims = {};\n    this._ = {\n        transform: []\n    };\n    el.snap = id;\n    hub[id] = this;\n    if (this.type == \"g\") {\n        this.add = add2group;\n    }\n    if (this.type in {g: 1, mask: 1, pattern: 1, symbol: 1}) {\n        for (var method in Paper.prototype) if (Paper.prototype[has](method)) {\n            this[method] = Paper.prototype[method];\n        }\n    }\n}\n   /*\\\n     * Element.attr\n     [ method ]\n     **\n     * Gets or sets given attributes of the element.\n     **\n     - params (object) contains key-value pairs of attributes you want to set\n     * or\n     - param (string) name of the attribute\n     = (Element) the current element\n     * or\n     = (string) value of attribute\n     > Usage\n     | el.attr({\n     |     fill: \"#fc0\",\n     |     stroke: \"#000\",\n     |     strokeWidth: 2, // CamelCase...\n     |     \"fill-opacity\": 0.5, // or dash-separated names\n     |     width: \"*=2\" // prefixed values\n     | });\n     | console.log(el.attr(\"fill\")); // #fc0\n     * Prefixed values in format `\"+=10\"` supported. All four operations\n     * (`+`, `-`, `*` and `/`) could be used. Optionally you can use units for `+`\n     * and `-`: `\"+=2em\"`.\n    \\*/\n    Element.prototype.attr = function (params, value) {\n        var el = this,\n            node = el.node;\n        if (!params) {\n            if (node.nodeType != 1) {\n                return {\n                    text: node.nodeValue\n                };\n            }\n            var attr = node.attributes,\n                out = {};\n            for (var i = 0, ii = attr.length; i < ii; i++) {\n                out[attr[i].nodeName] = attr[i].nodeValue;\n            }\n            return out;\n        }\n        if (is(params, \"string\")) {\n            if (arguments.length > 1) {\n                var json = {};\n                json[params] = value;\n                params = json;\n            } else {\n                return eve(\"snap.util.getattr.\" + params, el).firstDefined();\n            }\n        }\n        for (var att in params) {\n            if (params[has](att)) {\n                eve(\"snap.util.attr.\" + att, el, params[att]);\n            }\n        }\n        return el;\n    };\n/*\\\n * Snap.parse\n [ method ]\n **\n * Parses SVG fragment and converts it into a @Fragment\n **\n - svg (string) SVG string\n = (Fragment) the @Fragment\n\\*/\nSnap.parse = function (svg) {\n    var f = glob.doc.createDocumentFragment(),\n        full = true,\n        div = glob.doc.createElement(\"div\");\n    svg = Str(svg);\n    if (!svg.match(/^\\s*<\\s*svg(?:\\s|>)/)) {\n        svg = \"<svg>\" + svg + \"</svg>\";\n        full = false;\n    }\n    div.innerHTML = svg;\n    svg = div.getElementsByTagName(\"svg\")[0];\n    if (svg) {\n        if (full) {\n            f = svg;\n        } else {\n            while (svg.firstChild) {\n                f.appendChild(svg.firstChild);\n            }\n        }\n    }\n    return new Fragment(f);\n};\nfunction Fragment(frag) {\n    this.node = frag;\n}\n/*\\\n * Snap.fragment\n [ method ]\n **\n * Creates a DOM fragment from a given list of elements or strings\n **\n - varargs () SVG string\n = (Fragment) the @Fragment\n\\*/\nSnap.fragment = function () {\n    var args = Array.prototype.slice.call(arguments, 0),\n        f = glob.doc.createDocumentFragment();\n    for (var i = 0, ii = args.length; i < ii; i++) {\n        var item = args[i];\n        if (item.node && item.node.nodeType) {\n            f.appendChild(item.node);\n        }\n        if (item.nodeType) {\n            f.appendChild(item);\n        }\n        if (typeof item == \"string\") {\n            f.appendChild(Snap.parse(item).node);\n        }\n    }\n    return new Fragment(f);\n};\n\nfunction make(name, parent) {\n    var res = $(name);\n    parent.appendChild(res);\n    var el = wrap(res);\n    return el;\n}\nfunction Paper(w, h) {\n    var res,\n        desc,\n        defs,\n        proto = Paper.prototype;\n    if (w && w.tagName == \"svg\") {\n        if (w.snap in hub) {\n            return hub[w.snap];\n        }\n        var doc = w.ownerDocument;\n        res = new Element(w);\n        desc = w.getElementsByTagName(\"desc\")[0];\n        defs = w.getElementsByTagName(\"defs\")[0];\n        if (!desc) {\n            desc = $(\"desc\");\n            desc.appendChild(doc.createTextNode(\"Created with Snap\"));\n            res.node.appendChild(desc);\n        }\n        if (!defs) {\n            defs = $(\"defs\");\n            res.node.appendChild(defs);\n        }\n        res.defs = defs;\n        for (var key in proto) if (proto[has](key)) {\n            res[key] = proto[key];\n        }\n        res.paper = res.root = res;\n    } else {\n        res = make(\"svg\", glob.doc.body);\n        $(res.node, {\n            height: h,\n            version: 1.1,\n            width: w,\n            xmlns: xmlns\n        });\n    }\n    return res;\n}\nfunction wrap(dom) {\n    if (!dom) {\n        return dom;\n    }\n    if (dom instanceof Element || dom instanceof Fragment) {\n        return dom;\n    }\n    if (dom.tagName && dom.tagName.toLowerCase() == \"svg\") {\n        return new Paper(dom);\n    }\n    if (dom.tagName && dom.tagName.toLowerCase() == \"object\" && dom.type == \"image/svg+xml\") {\n        return new Paper(dom.contentDocument.getElementsByTagName(\"svg\")[0]);\n    }\n    return new Element(dom);\n}\n\nSnap._.make = make;\nSnap._.wrap = wrap;\n/*\\\n * Paper.el\n [ method ]\n **\n * Creates an element on paper with a given name and no attributes\n **\n - name (string) tag name\n - attr (object) attributes\n = (Element) the current element\n > Usage\n | var c = paper.circle(10, 10, 10); // is the same as...\n | var c = paper.el(\"circle\").attr({\n |     cx: 10,\n |     cy: 10,\n |     r: 10\n | });\n | // and the same as\n | var c = paper.el(\"circle\", {\n |     cx: 10,\n |     cy: 10,\n |     r: 10\n | });\n\\*/\nPaper.prototype.el = function (name, attr) {\n    var el = make(name, this.node);\n    attr && el.attr(attr);\n    return el;\n};\n/*\\\n * Element.children\n [ method ]\n **\n * Returns array of all the children of the element.\n = (array) array of Elements\n\\*/\nElement.prototype.children = function () {\n    var out = [],\n        ch = this.node.childNodes;\n    for (var i = 0, ii = ch.length; i < ii; i++) {\n        out[i] = Snap(ch[i]);\n    }\n    return out;\n};\nfunction jsonFiller(root, o) {\n    for (var i = 0, ii = root.length; i < ii; i++) {\n        var item = {\n                type: root[i].type,\n                attr: root[i].attr()\n            },\n            children = root[i].children();\n        o.push(item);\n        if (children.length) {\n            jsonFiller(children, item.childNodes = []);\n        }\n    }\n}\n/*\\\n * Element.toJSON\n [ method ]\n **\n * Returns object representation of the given element and all its children.\n = (object) in format\n o {\n o     type (string) this.type,\n o     attr (object) attributes map,\n o     childNodes (array) optional array of children in the same format\n o }\n\\*/\nElement.prototype.toJSON = function () {\n    var out = [];\n    jsonFiller([this], out);\n    return out[0];\n};\n// default\neve.on(\"snap.util.getattr\", function () {\n    var att = eve.nt();\n    att = att.substring(att.lastIndexOf(\".\") + 1);\n    var css = att.replace(/[A-Z]/g, function (letter) {\n        return \"-\" + letter.toLowerCase();\n    });\n    if (cssAttr[has](css)) {\n        return this.node.ownerDocument.defaultView.getComputedStyle(this.node, null).getPropertyValue(css);\n    } else {\n        return $(this.node, att);\n    }\n});\nvar cssAttr = {\n    \"alignment-baseline\": 0,\n    \"baseline-shift\": 0,\n    \"clip\": 0,\n    \"clip-path\": 0,\n    \"clip-rule\": 0,\n    \"color\": 0,\n    \"color-interpolation\": 0,\n    \"color-interpolation-filters\": 0,\n    \"color-profile\": 0,\n    \"color-rendering\": 0,\n    \"cursor\": 0,\n    \"direction\": 0,\n    \"display\": 0,\n    \"dominant-baseline\": 0,\n    \"enable-background\": 0,\n    \"fill\": 0,\n    \"fill-opacity\": 0,\n    \"fill-rule\": 0,\n    \"filter\": 0,\n    \"flood-color\": 0,\n    \"flood-opacity\": 0,\n    \"font\": 0,\n    \"font-family\": 0,\n    \"font-size\": 0,\n    \"font-size-adjust\": 0,\n    \"font-stretch\": 0,\n    \"font-style\": 0,\n    \"font-variant\": 0,\n    \"font-weight\": 0,\n    \"glyph-orientation-horizontal\": 0,\n    \"glyph-orientation-vertical\": 0,\n    \"image-rendering\": 0,\n    \"kerning\": 0,\n    \"letter-spacing\": 0,\n    \"lighting-color\": 0,\n    \"marker\": 0,\n    \"marker-end\": 0,\n    \"marker-mid\": 0,\n    \"marker-start\": 0,\n    \"mask\": 0,\n    \"opacity\": 0,\n    \"overflow\": 0,\n    \"pointer-events\": 0,\n    \"shape-rendering\": 0,\n    \"stop-color\": 0,\n    \"stop-opacity\": 0,\n    \"stroke\": 0,\n    \"stroke-dasharray\": 0,\n    \"stroke-dashoffset\": 0,\n    \"stroke-linecap\": 0,\n    \"stroke-linejoin\": 0,\n    \"stroke-miterlimit\": 0,\n    \"stroke-opacity\": 0,\n    \"stroke-width\": 0,\n    \"text-anchor\": 0,\n    \"text-decoration\": 0,\n    \"text-rendering\": 0,\n    \"unicode-bidi\": 0,\n    \"visibility\": 0,\n    \"word-spacing\": 0,\n    \"writing-mode\": 0\n};\n\neve.on(\"snap.util.attr\", function (value) {\n    var att = eve.nt(),\n        attr = {};\n    att = att.substring(att.lastIndexOf(\".\") + 1);\n    attr[att] = value;\n    var style = att.replace(/-(\\w)/gi, function (all, letter) {\n            return letter.toUpperCase();\n        }),\n        css = att.replace(/[A-Z]/g, function (letter) {\n            return \"-\" + letter.toLowerCase();\n        });\n    if (cssAttr[has](css)) {\n        this.node.style[style] = value == null ? E : value;\n    } else {\n        $(this.node, attr);\n    }\n});\n(function (proto) {}(Paper.prototype));\n\n// simple ajax\n/*\\\n * Snap.ajax\n [ method ]\n **\n * Simple implementation of Ajax\n **\n - url (string) URL\n - postData (object|string) data for post request\n - callback (function) callback\n - scope (object) #optional scope of callback\n * or\n - url (string) URL\n - callback (function) callback\n - scope (object) #optional scope of callback\n = (XMLHttpRequest) the XMLHttpRequest object, just in case\n\\*/\nSnap.ajax = function (url, postData, callback, scope){\n    var req = new XMLHttpRequest,\n        id = ID();\n    if (req) {\n        if (is(postData, \"function\")) {\n            scope = callback;\n            callback = postData;\n            postData = null;\n        } else if (is(postData, \"object\")) {\n            var pd = [];\n            for (var key in postData) if (postData.hasOwnProperty(key)) {\n                pd.push(encodeURIComponent(key) + \"=\" + encodeURIComponent(postData[key]));\n            }\n            postData = pd.join(\"&\");\n        }\n        req.open((postData ? \"POST\" : \"GET\"), url, true);\n        if (postData) {\n            req.setRequestHeader(\"X-Requested-With\", \"XMLHttpRequest\");\n            req.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\");\n        }\n        if (callback) {\n            eve.once(\"snap.ajax.\" + id + \".0\", callback);\n            eve.once(\"snap.ajax.\" + id + \".200\", callback);\n            eve.once(\"snap.ajax.\" + id + \".304\", callback);\n        }\n        req.onreadystatechange = function() {\n            if (req.readyState != 4) return;\n            eve(\"snap.ajax.\" + id + \".\" + req.status, scope, req);\n        };\n        if (req.readyState == 4) {\n            return req;\n        }\n        req.send(postData);\n        return req;\n    }\n};\n/*\\\n * Snap.load\n [ method ]\n **\n * Loads external SVG file as a @Fragment (see @Snap.ajax for more advanced AJAX)\n **\n - url (string) URL\n - callback (function) callback\n - scope (object) #optional scope of callback\n\\*/\nSnap.load = function (url, callback, scope) {\n    Snap.ajax(url, function (req) {\n        var f = Snap.parse(req.responseText);\n        scope ? callback.call(scope, f) : callback(f);\n    });\n};\nvar getOffset = function (elem) {\n    var box = elem.getBoundingClientRect(),\n        doc = elem.ownerDocument,\n        body = doc.body,\n        docElem = doc.documentElement,\n        clientTop = docElem.clientTop || body.clientTop || 0, clientLeft = docElem.clientLeft || body.clientLeft || 0,\n        top  = box.top  + (g.win.pageYOffset || docElem.scrollTop || body.scrollTop ) - clientTop,\n        left = box.left + (g.win.pageXOffset || docElem.scrollLeft || body.scrollLeft) - clientLeft;\n    return {\n        y: top,\n        x: left\n    };\n};\n/*\\\n * Snap.getElementByPoint\n [ method ]\n **\n * Returns you topmost element under given point.\n **\n = (object) Snap element object\n - x (number) x coordinate from the top left corner of the window\n - y (number) y coordinate from the top left corner of the window\n > Usage\n | Snap.getElementByPoint(mouseX, mouseY).attr({stroke: \"#f00\"});\n\\*/\nSnap.getElementByPoint = function (x, y) {\n    var paper = this,\n        svg = paper.canvas,\n        target = glob.doc.elementFromPoint(x, y);\n    if (glob.win.opera && target.tagName == \"svg\") {\n        var so = getOffset(target),\n            sr = target.createSVGRect();\n        sr.x = x - so.x;\n        sr.y = y - so.y;\n        sr.width = sr.height = 1;\n        var hits = target.getIntersectionList(sr, null);\n        if (hits.length) {\n            target = hits[hits.length - 1];\n        }\n    }\n    if (!target) {\n        return null;\n    }\n    return wrap(target);\n};\n/*\\\n * Snap.plugin\n [ method ]\n **\n * Let you write plugins. You pass in a function with five arguments, like this:\n | Snap.plugin(function (Snap, Element, Paper, global, Fragment) {\n |     Snap.newmethod = function () {};\n |     Element.prototype.newmethod = function () {};\n |     Paper.prototype.newmethod = function () {};\n | });\n * Inside the function you have access to all main objects (and their\n * prototypes). This allow you to extend anything you want.\n **\n - f (function) your plugin body\n\\*/\nSnap.plugin = function (f) {\n    f(Snap, Element, Paper, glob, Fragment);\n};\nglob.win.Snap = Snap;\nreturn Snap;\n}(window || this));\n\n// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nSnap.plugin(function (Snap, Element, Paper, glob, Fragment) {\n    var elproto = Element.prototype,\n        is = Snap.is,\n        Str = String,\n        unit2px = Snap._unit2px,\n        $ = Snap._.$,\n        make = Snap._.make,\n        getSomeDefs = Snap._.getSomeDefs,\n        has = \"hasOwnProperty\",\n        wrap = Snap._.wrap;\n    /*\\\n     * Element.getBBox\n     [ method ]\n     **\n     * Returns the bounding box descriptor for the given element\n     **\n     = (object) bounding box descriptor:\n     o {\n     o     cx: (number) x of the center,\n     o     cy: (number) x of the center,\n     o     h: (number) height,\n     o     height: (number) height,\n     o     path: (string) path command for the box,\n     o     r0: (number) radius of a circle that fully encloses the box,\n     o     r1: (number) radius of the smallest circle that can be enclosed,\n     o     r2: (number) radius of the largest circle that can be enclosed,\n     o     vb: (string) box as a viewbox command,\n     o     w: (number) width,\n     o     width: (number) width,\n     o     x2: (number) x of the right side,\n     o     x: (number) x of the left side,\n     o     y2: (number) y of the bottom edge,\n     o     y: (number) y of the top edge\n     o }\n    \\*/\n    elproto.getBBox = function (isWithoutTransform) {\n        if (!Snap.Matrix || !Snap.path) {\n            return this.node.getBBox();\n        }\n        var el = this,\n            m = new Snap.Matrix;\n        if (el.removed) {\n            return Snap._.box();\n        }\n        while (el.type == \"use\") {\n            if (!isWithoutTransform) {\n                m = m.add(el.transform().localMatrix.translate(el.attr(\"x\") || 0, el.attr(\"y\") || 0));\n            }\n            if (el.original) {\n                el = el.original;\n            } else {\n                var href = el.attr(\"xlink:href\");\n                el = el.original = el.node.ownerDocument.getElementById(href.substring(href.indexOf(\"#\") + 1));\n            }\n        }\n        var _ = el._,\n            pathfinder = Snap.path.get[el.type] || Snap.path.get.deflt;\n        try {\n            if (isWithoutTransform) {\n                _.bboxwt = pathfinder ? Snap.path.getBBox(el.realPath = pathfinder(el)) : Snap._.box(el.node.getBBox());\n                return Snap._.box(_.bboxwt);\n            } else {\n                el.realPath = pathfinder(el);\n                el.matrix = el.transform().localMatrix;\n                _.bbox = Snap.path.getBBox(Snap.path.map(el.realPath, m.add(el.matrix)));\n                return Snap._.box(_.bbox);\n            }\n        } catch (e) {\n            // Firefox doesnt give you bbox of hidden element\n            return Snap._.box();\n        }\n    };\n    var propString = function () {\n        return this.string;\n    };\n    function extractTransform(el, tstr) {\n        if (tstr == null) {\n            var doReturn = true;\n            if (el.type == \"linearGradient\" || el.type == \"radialGradient\") {\n                tstr = el.node.getAttribute(\"gradientTransform\");\n            } else if (el.type == \"pattern\") {\n                tstr = el.node.getAttribute(\"patternTransform\");\n            } else {\n                tstr = el.node.getAttribute(\"transform\");\n            }\n            if (!tstr) {\n                return new Snap.Matrix;\n            }\n            tstr = Snap._.svgTransform2string(tstr);\n        } else {\n            if (!Snap._.rgTransform.test(tstr)) {\n                tstr = Snap._.svgTransform2string(tstr);\n            } else {\n                tstr = Str(tstr).replace(/\\.{3}|\\u2026/g, el._.transform || E);\n            }\n            if (is(tstr, \"array\")) {\n                tstr = Snap.path ? Snap.path.toString.call(tstr) : Str(tstr);\n            }\n            el._.transform = tstr;\n        }\n        var m = Snap._.transform2matrix(tstr, el.getBBox(1));\n        if (doReturn) {\n            return m;\n        } else {\n            el.matrix = m;\n        }\n    }\n    /*\\\n     * Element.transform\n     [ method ]\n     **\n     * Gets or sets transformation of the element\n     **\n     - tstr (string) transform string in Snap or SVG format\n     = (Element) the current element\n     * or\n     = (object) transformation descriptor:\n     o {\n     o     string (string) transform string,\n     o     globalMatrix (Matrix) matrix of all transformations applied to element or its parents,\n     o     localMatrix (Matrix) matrix of transformations applied only to the element,\n     o     diffMatrix (Matrix) matrix of difference between global and local transformations,\n     o     global (string) global transformation as string,\n     o     local (string) local transformation as string,\n     o     toString (function) returns `string` property\n     o }\n    \\*/\n    elproto.transform = function (tstr) {\n        var _ = this._;\n        if (tstr == null) {\n            var papa = this,\n                global = new Snap.Matrix(this.node.getCTM()),\n                local = extractTransform(this),\n                ms = [local],\n                m = new Snap.Matrix,\n                i,\n                localString = local.toTransformString(),\n                string = Str(local) == Str(this.matrix) ?\n                            Str(_.transform) : localString;\n            while (papa.type != \"svg\" && (papa = papa.parent())) {\n                ms.push(extractTransform(papa));\n            }\n            i = ms.length;\n            while (i--) {\n                m.add(ms[i]);\n            }\n            return {\n                string: string,\n                globalMatrix: global,\n                totalMatrix: m,\n                localMatrix: local,\n                diffMatrix: global.clone().add(local.invert()),\n                global: global.toTransformString(),\n                total: m.toTransformString(),\n                local: localString,\n                toString: propString\n            };\n        }\n        if (tstr instanceof Snap.Matrix) {\n            this.matrix = tstr;\n            this._.transform = tstr.toTransformString();\n        } else {\n            extractTransform(this, tstr);\n        }\n\n        if (this.node) {\n            if (this.type == \"linearGradient\" || this.type == \"radialGradient\") {\n                $(this.node, {gradientTransform: this.matrix});\n            } else if (this.type == \"pattern\") {\n                $(this.node, {patternTransform: this.matrix});\n            } else {\n                $(this.node, {transform: this.matrix});\n            }\n        }\n\n        return this;\n    };\n    /*\\\n     * Element.parent\n     [ method ]\n     **\n     * Returns the element's parent\n     **\n     = (Element) the parent element\n    \\*/\n    elproto.parent = function () {\n        return wrap(this.node.parentNode);\n    };\n    /*\\\n     * Element.append\n     [ method ]\n     **\n     * Appends the given element to current one\n     **\n     - el (Element|Set) element to append\n     = (Element) the parent element\n    \\*/\n    /*\\\n     * Element.add\n     [ method ]\n     **\n     * See @Element.append\n    \\*/\n    elproto.append = elproto.add = function (el) {\n        if (el) {\n            if (el.type == \"set\") {\n                var it = this;\n                el.forEach(function (el) {\n                    it.add(el);\n                });\n                return this;\n            }\n            el = wrap(el);\n            this.node.appendChild(el.node);\n            el.paper = this.paper;\n        }\n        return this;\n    };\n    /*\\\n     * Element.appendTo\n     [ method ]\n     **\n     * Appends the current element to the given one\n     **\n     - el (Element) parent element to append to\n     = (Element) the child element\n    \\*/\n    elproto.appendTo = function (el) {\n        if (el) {\n            el = wrap(el);\n            el.append(this);\n        }\n        return this;\n    };\n    /*\\\n     * Element.prepend\n     [ method ]\n     **\n     * Prepends the given element to the current one\n     **\n     - el (Element) element to prepend\n     = (Element) the parent element\n    \\*/\n    elproto.prepend = function (el) {\n        if (el) {\n            if (el.type == \"set\") {\n                var it = this,\n                    first;\n                el.forEach(function (el) {\n                    if (first) {\n                        first.after(el);\n                    } else {\n                        it.prepend(el);\n                    }\n                    first = el;\n                });\n                return this;\n            }\n            el = wrap(el);\n            var parent = el.parent();\n            this.node.insertBefore(el.node, this.node.firstChild);\n            this.add && this.add();\n            el.paper = this.paper;\n            this.parent() && this.parent().add();\n            parent && parent.add();\n        }\n        return this;\n    };\n    /*\\\n     * Element.prependTo\n     [ method ]\n     **\n     * Prepends the current element to the given one\n     **\n     - el (Element) parent element to prepend to\n     = (Element) the child element\n    \\*/\n    elproto.prependTo = function (el) {\n        el = wrap(el);\n        el.prepend(this);\n        return this;\n    };\n    /*\\\n     * Element.before\n     [ method ]\n     **\n     * Inserts given element before the current one\n     **\n     - el (Element) element to insert\n     = (Element) the parent element\n    \\*/\n    elproto.before = function (el) {\n        if (el.type == \"set\") {\n            var it = this;\n            el.forEach(function (el) {\n                var parent = el.parent();\n                it.node.parentNode.insertBefore(el.node, it.node);\n                parent && parent.add();\n            });\n            this.parent().add();\n            return this;\n        }\n        el = wrap(el);\n        var parent = el.parent();\n        this.node.parentNode.insertBefore(el.node, this.node);\n        this.parent() && this.parent().add();\n        parent && parent.add();\n        el.paper = this.paper;\n        return this;\n    };\n    /*\\\n     * Element.after\n     [ method ]\n     **\n     * Inserts given element after the current one\n     **\n     - el (Element) element to insert\n     = (Element) the parent element\n    \\*/\n    elproto.after = function (el) {\n        el = wrap(el);\n        var parent = el.parent();\n        if (this.node.nextSibling) {\n            this.node.parentNode.insertBefore(el.node, this.node.nextSibling);\n        } else {\n            this.node.parentNode.appendChild(el.node);\n        }\n        this.parent() && this.parent().add();\n        parent && parent.add();\n        el.paper = this.paper;\n        return this;\n    };\n    /*\\\n     * Element.insertBefore\n     [ method ]\n     **\n     * Inserts the element after the given one\n     **\n     - el (Element) element next to whom insert to\n     = (Element) the parent element\n    \\*/\n    elproto.insertBefore = function (el) {\n        el = wrap(el);\n        var parent = this.parent();\n        el.node.parentNode.insertBefore(this.node, el.node);\n        this.paper = el.paper;\n        parent && parent.add();\n        el.parent() && el.parent().add();\n        return this;\n    };\n    /*\\\n     * Element.insertAfter\n     [ method ]\n     **\n     * Inserts the element after the given one\n     **\n     - el (Element) element next to whom insert to\n     = (Element) the parent element\n    \\*/\n    elproto.insertAfter = function (el) {\n        el = wrap(el);\n        var parent = this.parent();\n        el.node.parentNode.insertBefore(this.node, el.node.nextSibling);\n        this.paper = el.paper;\n        parent && parent.add();\n        el.parent() && el.parent().add();\n        return this;\n    };\n    /*\\\n     * Element.remove\n     [ method ]\n     **\n     * Removes element from the DOM\n     = (Element) the detached element\n    \\*/\n    elproto.remove = function () {\n        var parent = this.parent();\n        this.node.parentNode && this.node.parentNode.removeChild(this.node);\n        delete this.paper;\n        this.removed = true;\n        parent && parent.add();\n        return this;\n    };\n    /*\\\n     * Element.select\n     [ method ]\n     **\n     * Gathers the nested @Element matching the given set of CSS selectors\n     **\n     - query (string) CSS selector\n     = (Element) result of query selection\n    \\*/\n    elproto.select = function (query) {\n        query = Str(query).replace(/([^\\\\]):/g, \"$1\\\\:\");\n        return wrap(this.node.querySelector(query));\n    };\n    /*\\\n     * Element.selectAll\n     [ method ]\n     **\n     * Gathers nested @Element objects matching the given set of CSS selectors\n     **\n     - query (string) CSS selector\n     = (Set|array) result of query selection\n    \\*/\n    elproto.selectAll = function (query) {\n        var nodelist = this.node.querySelectorAll(query),\n            set = (Snap.set || Array)();\n        for (var i = 0; i < nodelist.length; i++) {\n            set.push(wrap(nodelist[i]));\n        }\n        return set;\n    };\n    /*\\\n     * Element.asPX\n     [ method ]\n     **\n     * Returns given attribute of the element as a `px` value (not %, em, etc.)\n     **\n     - attr (string) attribute name\n     - value (string) #optional attribute value\n     = (Element) result of query selection\n    \\*/\n    elproto.asPX = function (attr, value) {\n        if (value == null) {\n            value = this.attr(attr);\n        }\n        return +unit2px(this, attr, value);\n    };\n    // SIERRA Element.use(): I suggest adding a note about how to access the original element the returned <use> instantiates. It's a part of SVG with which ordinary web developers may be least familiar.\n    /*\\\n     * Element.use\n     [ method ]\n     **\n     * Creates a `<use>` element linked to the current element\n     **\n     = (Element) the `<use>` element\n    \\*/\n    elproto.use = function () {\n        var use,\n            id = this.node.id;\n        if (!id) {\n            id = this.id;\n            $(this.node, {\n                id: id\n            });\n        }\n        if (this.type == \"linearGradient\" || this.type == \"radialGradient\" ||\n            this.type == \"pattern\") {\n            use = make(this.type, this.node.parentNode);\n        } else {\n            use = make(\"use\", this.node.parentNode);\n        }\n        $(use.node, {\n            \"xlink:href\": \"#\" + id\n        });\n        use.original = this;\n        return use;\n    };\n    function fixids(el) {\n        var els = el.selectAll(\"*\"),\n            it,\n            url = /^\\s*url\\((\"|'|)(.*)\\1\\)\\s*$/,\n            ids = [],\n            uses = {};\n        function urltest(it, name) {\n            var val = $(it.node, name);\n            val = val && val.match(url);\n            val = val && val[2];\n            if (val && val.charAt() == \"#\") {\n                val = val.substring(1);\n            } else {\n                return;\n            }\n            if (val) {\n                uses[val] = (uses[val] || []).concat(function (id) {\n                    var attr = {};\n                    attr[name] = URL(id);\n                    $(it.node, attr);\n                });\n            }\n        }\n        function linktest(it) {\n            var val = $(it.node, \"xlink:href\");\n            if (val && val.charAt() == \"#\") {\n                val = val.substring(1);\n            } else {\n                return;\n            }\n            if (val) {\n                uses[val] = (uses[val] || []).concat(function (id) {\n                    it.attr(\"xlink:href\", \"#\" + id);\n                });\n            }\n        }\n        for (var i = 0, ii = els.length; i < ii; i++) {\n            it = els[i];\n            urltest(it, \"fill\");\n            urltest(it, \"stroke\");\n            urltest(it, \"filter\");\n            urltest(it, \"mask\");\n            urltest(it, \"clip-path\");\n            linktest(it);\n            var oldid = $(it.node, \"id\");\n            if (oldid) {\n                $(it.node, {id: it.id});\n                ids.push({\n                    old: oldid,\n                    id: it.id\n                });\n            }\n        }\n        for (i = 0, ii = ids.length; i < ii; i++) {\n            var fs = uses[ids[i].old];\n            if (fs) {\n                for (var j = 0, jj = fs.length; j < jj; j++) {\n                    fs[j](ids[i].id);\n                }\n            }\n        }\n    }\n    /*\\\n     * Element.clone\n     [ method ]\n     **\n     * Creates a clone of the element and inserts it after the element\n     **\n     = (Element) the clone\n    \\*/\n    elproto.clone = function () {\n        var clone = wrap(this.node.cloneNode(true));\n        if ($(clone.node, \"id\")) {\n            $(clone.node, {id: clone.id});\n        }\n        fixids(clone);\n        clone.insertAfter(this);\n        return clone;\n    };\n    /*\\\n     * Element.toDefs\n     [ method ]\n     **\n     * Moves element to the shared `<defs>` area\n     **\n     = (Element) the element\n    \\*/\n    elproto.toDefs = function () {\n        var defs = getSomeDefs(this);\n        defs.appendChild(this.node);\n        return this;\n    };\n    /*\\\n     * Element.toPattern\n     [ method ]\n     **\n     * Creates a `<pattern>` element from the current element\n     **\n     * To create a pattern you have to specify the pattern rect:\n     - x (string|number)\n     - y (string|number)\n     - width (string|number)\n     - height (string|number)\n     = (Element) the `<pattern>` element\n     * You can use pattern later on as an argument for `fill` attribute:\n     | var p = paper.path(\"M10-5-10,15M15,0,0,15M0-5-20,15\").attr({\n     |         fill: \"none\",\n     |         stroke: \"#bada55\",\n     |         strokeWidth: 5\n     |     }).pattern(0, 0, 10, 10),\n     |     c = paper.circle(200, 200, 100);\n     | c.attr({\n     |     fill: p\n     | });\n    \\*/\n    elproto.pattern = elproto.toPattern = function (x, y, width, height) {\n        var p = make(\"pattern\", getSomeDefs(this));\n        if (x == null) {\n            x = this.getBBox();\n        }\n        if (is(x, \"object\") && \"x\" in x) {\n            y = x.y;\n            width = x.width;\n            height = x.height;\n            x = x.x;\n        }\n        $(p.node, {\n            x: x,\n            y: y,\n            width: width,\n            height: height,\n            patternUnits: \"userSpaceOnUse\",\n            id: p.id,\n            viewBox: [x, y, width, height].join(\" \")\n        });\n        p.node.appendChild(this.node);\n        return p;\n    };\n// SIERRA Element.marker(): clarify what a reference point is. E.g., helps you offset the object from its edge such as when centering it over a path.\n// SIERRA Element.marker(): I suggest the method should accept default reference point values.  Perhaps centered with (refX = width/2) and (refY = height/2)? Also, couldn't it assume the element's current _width_ and _height_? And please specify what _x_ and _y_ mean: offsets? If so, from where?  Couldn't they also be assigned default values?\n    /*\\\n     * Element.marker\n     [ method ]\n     **\n     * Creates a `<marker>` element from the current element\n     **\n     * To create a marker you have to specify the bounding rect and reference point:\n     - x (number)\n     - y (number)\n     - width (number)\n     - height (number)\n     - refX (number)\n     - refY (number)\n     = (Element) the `<marker>` element\n     * You can specify the marker later as an argument for `marker-start`, `marker-end`, `marker-mid`, and `marker` attributes. The `marker` attribute places the marker at every point along the path, and `marker-mid` places them at every point except the start and end.\n    \\*/\n    // TODO add usage for markers\n    elproto.marker = function (x, y, width, height, refX, refY) {\n        var p = make(\"marker\", getSomeDefs(this));\n        if (x == null) {\n            x = this.getBBox();\n        }\n        if (is(x, \"object\") && \"x\" in x) {\n            y = x.y;\n            width = x.width;\n            height = x.height;\n            refX = x.refX || x.cx;\n            refY = x.refY || x.cy;\n            x = x.x;\n        }\n        $(p.node, {\n            viewBox: [x, y, width, height].join(\" \"),\n            markerWidth: width,\n            markerHeight: height,\n            orient: \"auto\",\n            refX: refX || 0,\n            refY: refY || 0,\n            id: p.id\n        });\n        p.node.appendChild(this.node);\n        return p;\n    };\n    // animation\n    function slice(from, to, f) {\n        return function (arr) {\n            var res = arr.slice(from, to);\n            if (res.length == 1) {\n                res = res[0];\n            }\n            return f ? f(res) : res;\n        };\n    }\n    var Animation = function (attr, ms, easing, callback) {\n        if (typeof easing == \"function\" && !easing.length) {\n            callback = easing;\n            easing = mina.linear;\n        }\n        this.attr = attr;\n        this.dur = ms;\n        easing && (this.easing = easing);\n        callback && (this.callback = callback);\n    };\n    Snap._.Animation = Animation;\n    /*\\\n     * Snap.animation\n     [ method ]\n     **\n     * Creates an animation object\n     **\n     - attr (object) attributes of final destination\n     - duration (number) duration of the animation, in milliseconds\n     - easing (function) #optional one of easing functions of @mina or custom one\n     - callback (function) #optional callback function that fires when animation ends\n     = (object) animation object\n    \\*/\n    Snap.animation = function (attr, ms, easing, callback) {\n        return new Animation(attr, ms, easing, callback);\n    };\n    /*\\\n     * Element.inAnim\n     [ method ]\n     **\n     * Returns a set of animations that may be able to manipulate the current element\n     **\n     = (object) in format:\n     o {\n     o     anim (object) animation object,\n     o     mina (object) @mina object,\n     o     curStatus (number) 0..1  status of the animation: 0  just started, 1  just finished,\n     o     status (function) gets or sets the status of the animation,\n     o     stop (function) stops the animation\n     o }\n    \\*/\n    elproto.inAnim = function () {\n        var el = this,\n            res = [];\n        for (var id in el.anims) if (el.anims[has](id)) {\n            (function (a) {\n                res.push({\n                    anim: new Animation(a._attrs, a.dur, a.easing, a._callback),\n                    mina: a,\n                    curStatus: a.status(),\n                    status: function (val) {\n                        return a.status(val);\n                    },\n                    stop: function () {\n                        a.stop();\n                    }\n                });\n            }(el.anims[id]));\n        }\n        return res;\n    };\n    /*\\\n     * Snap.animate\n     [ method ]\n     **\n     * Runs generic animation of one number into another with a caring function\n     **\n     - from (number|array) number or array of numbers\n     - to (number|array) number or array of numbers\n     - setter (function) caring function that accepts one number argument\n     - duration (number) duration, in milliseconds\n     - easing (function) #optional easing function from @mina or custom\n     - callback (function) #optional callback function to execute when animation ends\n     = (object) animation object in @mina format\n     o {\n     o     id (string) animation id, consider it read-only,\n     o     duration (function) gets or sets the duration of the animation,\n     o     easing (function) easing,\n     o     speed (function) gets or sets the speed of the animation,\n     o     status (function) gets or sets the status of the animation,\n     o     stop (function) stops the animation\n     o }\n     | var rect = Snap().rect(0, 0, 10, 10);\n     | Snap.animate(0, 10, function (val) {\n     |     rect.attr({\n     |         x: val\n     |     });\n     | }, 1000);\n     | // in given context is equivalent to\n     | rect.animate({x: 10}, 1000);\n    \\*/\n    Snap.animate = function (from, to, setter, ms, easing, callback) {\n        if (typeof easing == \"function\" && !easing.length) {\n            callback = easing;\n            easing = mina.linear;\n        }\n        var now = mina.time(),\n            anim = mina(from, to, now, now + ms, mina.time, setter, easing);\n        callback && eve.once(\"mina.finish.\" + anim.id, callback);\n        return anim;\n    };\n    /*\\\n     * Element.stop\n     [ method ]\n     **\n     * Stops all the animations for the current element\n     **\n     = (Element) the current element\n    \\*/\n    elproto.stop = function () {\n        var anims = this.inAnim();\n        for (var i = 0, ii = anims.length; i < ii; i++) {\n            anims[i].stop();\n        }\n        return this;\n    };\n    /*\\\n     * Element.animate\n     [ method ]\n     **\n     * Animates the given attributes of the element\n     **\n     - attrs (object) key-value pairs of destination attributes\n     - duration (number) duration of the animation in milliseconds\n     - easing (function) #optional easing function from @mina or custom\n     - callback (function) #optional callback function that executes when the animation ends\n     = (Element) the current element\n    \\*/\n    elproto.animate = function (attrs, ms, easing, callback) {\n        if (typeof easing == \"function\" && !easing.length) {\n            callback = easing;\n            easing = mina.linear;\n        }\n        if (attrs instanceof Animation) {\n            callback = attrs.callback;\n            easing = attrs.easing;\n            ms = easing.dur;\n            attrs = attrs.attr;\n        }\n        var fkeys = [], tkeys = [], keys = {}, from, to, f, eq,\n            el = this;\n        for (var key in attrs) if (attrs[has](key)) {\n            if (el.equal) {\n                eq = el.equal(key, Str(attrs[key]));\n                from = eq.from;\n                to = eq.to;\n                f = eq.f;\n            } else {\n                from = +el.attr(key);\n                to = +attrs[key];\n            }\n            var len = is(from, \"array\") ? from.length : 1;\n            keys[key] = slice(fkeys.length, fkeys.length + len, f);\n            fkeys = fkeys.concat(from);\n            tkeys = tkeys.concat(to);\n        }\n        var now = mina.time(),\n            anim = mina(fkeys, tkeys, now, now + ms, mina.time, function (val) {\n                var attr = {};\n                for (var key in keys) if (keys[has](key)) {\n                    attr[key] = keys[key](val);\n                }\n                el.attr(attr);\n            }, easing);\n        el.anims[anim.id] = anim;\n        anim._attrs = attrs;\n        anim._callback = callback;\n        eve(\"snap.animcreated.\" + el.id, anim);\n        eve.once(\"mina.finish.\" + anim.id, function () {\n            delete el.anims[anim.id];\n            callback && callback.call(el);\n        });\n        eve.once(\"mina.stop.\" + anim.id, function () {\n            delete el.anims[anim.id];\n        });\n        return el;\n    };\n    var eldata = {};\n    /*\\\n     * Element.data\n     [ method ]\n     **\n     * Adds or retrieves given value associated with given key. (Dont confuse\n     * with `data-` attributes)\n     *\n     * See also @Element.removeData\n     - key (string) key to store data\n     - value (any) #optional value to store\n     = (object) @Element\n     * or, if value is not specified:\n     = (any) value\n     > Usage\n     | for (var i = 0, i < 5, i++) {\n     |     paper.circle(10 + 15 * i, 10, 10)\n     |          .attr({fill: \"#000\"})\n     |          .data(\"i\", i)\n     |          .click(function () {\n     |             alert(this.data(\"i\"));\n     |          });\n     | }\n    \\*/\n    elproto.data = function (key, value) {\n        var data = eldata[this.id] = eldata[this.id] || {};\n        if (arguments.length == 0){\n            eve(\"snap.data.get.\" + this.id, this, data, null);\n            return data;\n        }\n        if (arguments.length == 1) {\n            if (Snap.is(key, \"object\")) {\n                for (var i in key) if (key[has](i)) {\n                    this.data(i, key[i]);\n                }\n                return this;\n            }\n            eve(\"snap.data.get.\" + this.id, this, data[key], key);\n            return data[key];\n        }\n        data[key] = value;\n        eve(\"snap.data.set.\" + this.id, this, value, key);\n        return this;\n    };\n    /*\\\n     * Element.removeData\n     [ method ]\n     **\n     * Removes value associated with an element by given key.\n     * If key is not provided, removes all the data of the element.\n     - key (string) #optional key\n     = (object) @Element\n    \\*/\n    elproto.removeData = function (key) {\n        if (key == null) {\n            eldata[this.id] = {};\n        } else {\n            eldata[this.id] && delete eldata[this.id][key];\n        }\n        return this;\n    };\n    /*\\\n     * Element.outerSVG\n     [ method ]\n     **\n     * Returns SVG code for the element, equivalent to HTML's `outerHTML`.\n     *\n     * See also @Element.innerSVG\n     = (string) SVG code for the element\n    \\*/\n    /*\\\n     * Element.toString\n     [ method ]\n     **\n     * See @Element.outerSVG\n    \\*/\n    elproto.outerSVG = elproto.toString = toString(1);\n    /*\\\n     * Element.innerSVG\n     [ method ]\n     **\n     * Returns SVG code for the element's contents, equivalent to HTML's `innerHTML`\n     = (string) SVG code for the element\n    \\*/\n    elproto.innerSVG = toString();\n    function toString(type) {\n        return function () {\n            var res = type ? \"<\" + this.type : \"\",\n                attr = this.node.attributes,\n                chld = this.node.childNodes;\n            if (type) {\n                for (var i = 0, ii = attr.length; i < ii; i++) {\n                    res += \" \" + attr[i].name + '=\"' +\n                            attr[i].value.replace(/\"/g, '\\\\\"') + '\"';\n                }\n            }\n            if (chld.length) {\n                type && (res += \">\");\n                for (i = 0, ii = chld.length; i < ii; i++) {\n                    if (chld[i].nodeType == 3) {\n                        res += chld[i].nodeValue;\n                    } else if (chld[i].nodeType == 1) {\n                        res += wrap(chld[i]).toString();\n                    }\n                }\n                type && (res += \"</\" + this.type + \">\");\n            } else {\n                type && (res += \"/>\");\n            }\n            return res;\n        };\n    }\n    elproto.toDataURL = function () {\n        if (window && window.btoa) {\n            var bb = this.getBBox(),\n                svg = Snap.format('<svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"{width}\" height=\"{height}\" viewBox=\"{x} {y} {width} {height}\">{contents}</svg>', {\n                x: +bb.x.toFixed(3),\n                y: +bb.y.toFixed(3),\n                width: +bb.width.toFixed(3),\n                height: +bb.height.toFixed(3),\n                contents: this.outerSVG()\n            });\n            return \"data:image/svg+xml;base64,\" + btoa(unescape(encodeURIComponent(svg)));\n        }\n    };\n    /*\\\n     * Fragment.select\n     [ method ]\n     **\n     * See @Element.select\n    \\*/\n    Fragment.prototype.select = elproto.select;\n    /*\\\n     * Fragment.selectAll\n     [ method ]\n     **\n     * See @Element.selectAll\n    \\*/\n    Fragment.prototype.selectAll = elproto.selectAll;\n});\n\n// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nSnap.plugin(function (Snap, Element, Paper, glob, Fragment) {\n    var objectToString = Object.prototype.toString,\n        Str = String,\n        math = Math,\n        E = \"\";\n    function Matrix(a, b, c, d, e, f) {\n        if (b == null && objectToString.call(a) == \"[object SVGMatrix]\") {\n            this.a = a.a;\n            this.b = a.b;\n            this.c = a.c;\n            this.d = a.d;\n            this.e = a.e;\n            this.f = a.f;\n            return;\n        }\n        if (a != null) {\n            this.a = +a;\n            this.b = +b;\n            this.c = +c;\n            this.d = +d;\n            this.e = +e;\n            this.f = +f;\n        } else {\n            this.a = 1;\n            this.b = 0;\n            this.c = 0;\n            this.d = 1;\n            this.e = 0;\n            this.f = 0;\n        }\n    }\n    (function (matrixproto) {\n        /*\\\n         * Matrix.add\n         [ method ]\n         **\n         * Adds the given matrix to existing one\n         - a (number)\n         - b (number)\n         - c (number)\n         - d (number)\n         - e (number)\n         - f (number)\n         * or\n         - matrix (object) @Matrix\n        \\*/\n        matrixproto.add = function (a, b, c, d, e, f) {\n            var out = [[], [], []],\n                m = [[this.a, this.c, this.e], [this.b, this.d, this.f], [0, 0, 1]],\n                matrix = [[a, c, e], [b, d, f], [0, 0, 1]],\n                x, y, z, res;\n\n            if (a && a instanceof Matrix) {\n                matrix = [[a.a, a.c, a.e], [a.b, a.d, a.f], [0, 0, 1]];\n            }\n\n            for (x = 0; x < 3; x++) {\n                for (y = 0; y < 3; y++) {\n                    res = 0;\n                    for (z = 0; z < 3; z++) {\n                        res += m[x][z] * matrix[z][y];\n                    }\n                    out[x][y] = res;\n                }\n            }\n            this.a = out[0][0];\n            this.b = out[1][0];\n            this.c = out[0][1];\n            this.d = out[1][1];\n            this.e = out[0][2];\n            this.f = out[1][2];\n            return this;\n        };\n        /*\\\n         * Matrix.invert\n         [ method ]\n         **\n         * Returns an inverted version of the matrix\n         = (object) @Matrix\n        \\*/\n        matrixproto.invert = function () {\n            var me = this,\n                x = me.a * me.d - me.b * me.c;\n            return new Matrix(me.d / x, -me.b / x, -me.c / x, me.a / x, (me.c * me.f - me.d * me.e) / x, (me.b * me.e - me.a * me.f) / x);\n        };\n        /*\\\n         * Matrix.clone\n         [ method ]\n         **\n         * Returns a copy of the matrix\n         = (object) @Matrix\n        \\*/\n        matrixproto.clone = function () {\n            return new Matrix(this.a, this.b, this.c, this.d, this.e, this.f);\n        };\n        /*\\\n         * Matrix.translate\n         [ method ]\n         **\n         * Translate the matrix\n         - x (number) horizontal offset distance\n         - y (number) vertical offset distance\n        \\*/\n        matrixproto.translate = function (x, y) {\n            return this.add(1, 0, 0, 1, x, y);\n        };\n        /*\\\n         * Matrix.scale\n         [ method ]\n         **\n         * Scales the matrix\n         - x (number) amount to be scaled, with `1` resulting in no change\n         - y (number) #optional amount to scale along the vertical axis. (Otherwise `x` applies to both axes.)\n         - cx (number) #optional horizontal origin point from which to scale\n         - cy (number) #optional vertical origin point from which to scale\n         * Default cx, cy is the middle point of the element.\n        \\*/\n        matrixproto.scale = function (x, y, cx, cy) {\n            y == null && (y = x);\n            (cx || cy) && this.add(1, 0, 0, 1, cx, cy);\n            this.add(x, 0, 0, y, 0, 0);\n            (cx || cy) && this.add(1, 0, 0, 1, -cx, -cy);\n            return this;\n        };\n        /*\\\n         * Matrix.rotate\n         [ method ]\n         **\n         * Rotates the matrix\n         - a (number) angle of rotation, in degrees\n         - x (number) horizontal origin point from which to rotate\n         - y (number) vertical origin point from which to rotate\n        \\*/\n        matrixproto.rotate = function (a, x, y) {\n            a = Snap.rad(a);\n            x = x || 0;\n            y = y || 0;\n            var cos = +math.cos(a).toFixed(9),\n                sin = +math.sin(a).toFixed(9);\n            this.add(cos, sin, -sin, cos, x, y);\n            return this.add(1, 0, 0, 1, -x, -y);\n        };\n        /*\\\n         * Matrix.x\n         [ method ]\n         **\n         * Returns x coordinate for given point after transformation described by the matrix. See also @Matrix.y\n         - x (number)\n         - y (number)\n         = (number) x\n        \\*/\n        matrixproto.x = function (x, y) {\n            return x * this.a + y * this.c + this.e;\n        };\n        /*\\\n         * Matrix.y\n         [ method ]\n         **\n         * Returns y coordinate for given point after transformation described by the matrix. See also @Matrix.x\n         - x (number)\n         - y (number)\n         = (number) y\n        \\*/\n        matrixproto.y = function (x, y) {\n            return x * this.b + y * this.d + this.f;\n        };\n        matrixproto.get = function (i) {\n            return +this[Str.fromCharCode(97 + i)].toFixed(4);\n        };\n        matrixproto.toString = function () {\n            return \"matrix(\" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)].join() + \")\";\n        };\n        matrixproto.offset = function () {\n            return [this.e.toFixed(4), this.f.toFixed(4)];\n        };\n        function norm(a) {\n            return a[0] * a[0] + a[1] * a[1];\n        }\n        function normalize(a) {\n            var mag = math.sqrt(norm(a));\n            a[0] && (a[0] /= mag);\n            a[1] && (a[1] /= mag);\n        }\n        /*\\\n         * Matrix.determinant\n         [ method ]\n         **\n         * Finds determinant of the given matrix.\n         = (number) determinant\n        \\*/\n        matrixproto.determinant = function () {\n            return this.a * this.d - this.b * this.c;\n        };\n        /*\\\n         * Matrix.split\n         [ method ]\n         **\n         * Splits matrix into primitive transformations\n         = (object) in format:\n         o dx (number) translation by x\n         o dy (number) translation by y\n         o scalex (number) scale by x\n         o scaley (number) scale by y\n         o shear (number) shear\n         o rotate (number) rotation in deg\n         o isSimple (boolean) could it be represented via simple transformations\n        \\*/\n        matrixproto.split = function () {\n            var out = {};\n            // translation\n            out.dx = this.e;\n            out.dy = this.f;\n\n            // scale and shear\n            var row = [[this.a, this.c], [this.b, this.d]];\n            out.scalex = math.sqrt(norm(row[0]));\n            normalize(row[0]);\n\n            out.shear = row[0][0] * row[1][0] + row[0][1] * row[1][1];\n            row[1] = [row[1][0] - row[0][0] * out.shear, row[1][1] - row[0][1] * out.shear];\n\n            out.scaley = math.sqrt(norm(row[1]));\n            normalize(row[1]);\n            out.shear /= out.scaley;\n\n            if (this.determinant() < 0) {\n                out.scalex = -out.scalex;\n            }\n\n            // rotation\n            var sin = -row[0][1],\n                cos = row[1][1];\n            if (cos < 0) {\n                out.rotate = Snap.deg(math.acos(cos));\n                if (sin < 0) {\n                    out.rotate = 360 - out.rotate;\n                }\n            } else {\n                out.rotate = Snap.deg(math.asin(sin));\n            }\n\n            out.isSimple = !+out.shear.toFixed(9) && (out.scalex.toFixed(9) == out.scaley.toFixed(9) || !out.rotate);\n            out.isSuperSimple = !+out.shear.toFixed(9) && out.scalex.toFixed(9) == out.scaley.toFixed(9) && !out.rotate;\n            out.noRotation = !+out.shear.toFixed(9) && !out.rotate;\n            return out;\n        };\n        /*\\\n         * Matrix.toTransformString\n         [ method ]\n         **\n         * Returns transform string that represents given matrix\n         = (string) transform string\n        \\*/\n        matrixproto.toTransformString = function (shorter) {\n            var s = shorter || this.split();\n            if (!+s.shear.toFixed(9)) {\n                s.scalex = +s.scalex.toFixed(4);\n                s.scaley = +s.scaley.toFixed(4);\n                s.rotate = +s.rotate.toFixed(4);\n                return  (s.dx || s.dy ? \"t\" + [+s.dx.toFixed(4), +s.dy.toFixed(4)] : E) +\n                        (s.scalex != 1 || s.scaley != 1 ? \"s\" + [s.scalex, s.scaley, 0, 0] : E) +\n                        (s.rotate ? \"r\" + [+s.rotate.toFixed(4), 0, 0] : E);\n            } else {\n                return \"m\" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)];\n            }\n        };\n    })(Matrix.prototype);\n    /*\\\n     * Snap.Matrix\n     [ method ]\n     **\n     * Matrix constructor, extend on your own risk.\n     * To create matrices use @Snap.matrix.\n    \\*/\n    Snap.Matrix = Matrix;\n    /*\\\n     * Snap.matrix\n     [ method ]\n     **\n     * Utility method\n     **\n     * Returns a matrix based on the given parameters\n     - a (number)\n     - b (number)\n     - c (number)\n     - d (number)\n     - e (number)\n     - f (number)\n     * or\n     - svgMatrix (SVGMatrix)\n     = (object) @Matrix\n    \\*/\n    Snap.matrix = function (a, b, c, d, e, f) {\n        return new Matrix(a, b, c, d, e, f);\n    };\n});\n// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nSnap.plugin(function (Snap, Element, Paper, glob, Fragment) {\n    var has = \"hasOwnProperty\",\n        make = Snap._.make,\n        wrap = Snap._.wrap,\n        is = Snap.is,\n        getSomeDefs = Snap._.getSomeDefs,\n        reURLValue = /^url\\(#?([^)]+)\\)$/,\n        $ = Snap._.$,\n        URL = Snap.url,\n        Str = String,\n        separator = Snap._.separator,\n        E = \"\";\n    // Attributes event handlers\n    eve.on(\"snap.util.attr.mask\", function (value) {\n        if (value instanceof Element || value instanceof Fragment) {\n            eve.stop();\n            if (value instanceof Fragment && value.node.childNodes.length == 1) {\n                value = value.node.firstChild;\n                getSomeDefs(this).appendChild(value);\n                value = wrap(value);\n            }\n            if (value.type == \"mask\") {\n                var mask = value;\n            } else {\n                mask = make(\"mask\", getSomeDefs(this));\n                mask.node.appendChild(value.node);\n            }\n            !mask.node.id && $(mask.node, {\n                id: mask.id\n            });\n            $(this.node, {\n                mask: URL(mask.id)\n            });\n        }\n    });\n    (function (clipIt) {\n        eve.on(\"snap.util.attr.clip\", clipIt);\n        eve.on(\"snap.util.attr.clip-path\", clipIt);\n        eve.on(\"snap.util.attr.clipPath\", clipIt);\n    }(function (value) {\n        if (value instanceof Element || value instanceof Fragment) {\n            eve.stop();\n            if (value.type == \"clipPath\") {\n                var clip = value;\n            } else {\n                clip = make(\"clipPath\", getSomeDefs(this));\n                clip.node.appendChild(value.node);\n                !clip.node.id && $(clip.node, {\n                    id: clip.id\n                });\n            }\n            $(this.node, {\n                \"clip-path\": URL(clip.node.id || clip.id)\n            });\n        }\n    }));\n    function fillStroke(name) {\n        return function (value) {\n            eve.stop();\n            if (value instanceof Fragment && value.node.childNodes.length == 1 &&\n                (value.node.firstChild.tagName == \"radialGradient\" ||\n                value.node.firstChild.tagName == \"linearGradient\" ||\n                value.node.firstChild.tagName == \"pattern\")) {\n                value = value.node.firstChild;\n                getSomeDefs(this).appendChild(value);\n                value = wrap(value);\n            }\n            if (value instanceof Element) {\n                if (value.type == \"radialGradient\" || value.type == \"linearGradient\"\n                   || value.type == \"pattern\") {\n                    if (!value.node.id) {\n                        $(value.node, {\n                            id: value.id\n                        });\n                    }\n                    var fill = URL(value.node.id);\n                } else {\n                    fill = value.attr(name);\n                }\n            } else {\n                fill = Snap.color(value);\n                if (fill.error) {\n                    var grad = Snap(getSomeDefs(this).ownerSVGElement).gradient(value);\n                    if (grad) {\n                        if (!grad.node.id) {\n                            $(grad.node, {\n                                id: grad.id\n                            });\n                        }\n                        fill = URL(grad.node.id);\n                    } else {\n                        fill = value;\n                    }\n                } else {\n                    fill = Str(fill);\n                }\n            }\n            var attrs = {};\n            attrs[name] = fill;\n            $(this.node, attrs);\n            this.node.style[name] = E;\n        };\n    }\n    eve.on(\"snap.util.attr.fill\", fillStroke(\"fill\"));\n    eve.on(\"snap.util.attr.stroke\", fillStroke(\"stroke\"));\n    var gradrg = /^([lr])(?:\\(([^)]*)\\))?(.*)$/i;\n    eve.on(\"snap.util.grad.parse\", function parseGrad(string) {\n        string = Str(string);\n        var tokens = string.match(gradrg);\n        if (!tokens) {\n            return null;\n        }\n        var type = tokens[1],\n            params = tokens[2],\n            stops = tokens[3];\n        params = params.split(/\\s*,\\s*/).map(function (el) {\n            return +el == el ? +el : el;\n        });\n        if (params.length == 1 && params[0] == 0) {\n            params = [];\n        }\n        stops = stops.split(\"-\");\n        stops = stops.map(function (el) {\n            el = el.split(\":\");\n            var out = {\n                color: el[0]\n            };\n            if (el[1]) {\n                out.offset = parseFloat(el[1]);\n            }\n            return out;\n        });\n        return {\n            type: type,\n            params: params,\n            stops: stops\n        };\n    });\n\n    eve.on(\"snap.util.attr.d\", function (value) {\n        eve.stop();\n        if (is(value, \"array\") && is(value[0], \"array\")) {\n            value = Snap.path.toString.call(value);\n        }\n        value = Str(value);\n        if (value.match(/[ruo]/i)) {\n            value = Snap.path.toAbsolute(value);\n        }\n        $(this.node, {d: value});\n    })(-1);\n    eve.on(\"snap.util.attr.#text\", function (value) {\n        eve.stop();\n        value = Str(value);\n        var txt = glob.doc.createTextNode(value);\n        while (this.node.firstChild) {\n            this.node.removeChild(this.node.firstChild);\n        }\n        this.node.appendChild(txt);\n    })(-1);\n    eve.on(\"snap.util.attr.path\", function (value) {\n        eve.stop();\n        this.attr({d: value});\n    })(-1);\n    eve.on(\"snap.util.attr.class\", function (value) {\n        eve.stop();\n        this.node.className.baseVal = value;\n    })(-1);\n    eve.on(\"snap.util.attr.viewBox\", function (value) {\n        var vb;\n        if (is(value, \"object\") && \"x\" in value) {\n            vb = [value.x, value.y, value.width, value.height].join(\" \");\n        } else if (is(value, \"array\")) {\n            vb = value.join(\" \");\n        } else {\n            vb = value;\n        }\n        $(this.node, {\n            viewBox: vb\n        });\n        eve.stop();\n    })(-1);\n    eve.on(\"snap.util.attr.transform\", function (value) {\n        this.transform(value);\n        eve.stop();\n    })(-1);\n    eve.on(\"snap.util.attr.r\", function (value) {\n        if (this.type == \"rect\") {\n            eve.stop();\n            $(this.node, {\n                rx: value,\n                ry: value\n            });\n        }\n    })(-1);\n    eve.on(\"snap.util.attr.textpath\", function (value) {\n        eve.stop();\n        if (this.type == \"text\") {\n            var id, tp, node;\n            if (!value && this.textPath) {\n                tp = this.textPath;\n                while (tp.node.firstChild) {\n                    this.node.appendChild(tp.node.firstChild);\n                }\n                tp.remove();\n                delete this.textPath;\n                return;\n            }\n            if (is(value, \"string\")) {\n                var defs = getSomeDefs(this),\n                    path = wrap(defs.parentNode).path(value);\n                defs.appendChild(path.node);\n                id = path.id;\n                path.attr({id: id});\n            } else {\n                value = wrap(value);\n                if (value instanceof Element) {\n                    id = value.attr(\"id\");\n                    if (!id) {\n                        id = value.id;\n                        value.attr({id: id});\n                    }\n                }\n            }\n            if (id) {\n                tp = this.textPath;\n                node = this.node;\n                if (tp) {\n                    tp.attr({\"xlink:href\": \"#\" + id});\n                } else {\n                    tp = $(\"textPath\", {\n                        \"xlink:href\": \"#\" + id\n                    });\n                    while (node.firstChild) {\n                        tp.appendChild(node.firstChild);\n                    }\n                    node.appendChild(tp);\n                    this.textPath = wrap(tp);\n                }\n            }\n        }\n    })(-1);\n    eve.on(\"snap.util.attr.text\", function (value) {\n        if (this.type == \"text\") {\n            var i = 0,\n                node = this.node,\n                tuner = function (chunk) {\n                    var out = $(\"tspan\");\n                    if (is(chunk, \"array\")) {\n                        for (var i = 0; i < chunk.length; i++) {\n                            out.appendChild(tuner(chunk[i]));\n                        }\n                    } else {\n                        out.appendChild(glob.doc.createTextNode(chunk));\n                    }\n                    out.normalize && out.normalize();\n                    return out;\n                };\n            while (node.firstChild) {\n                node.removeChild(node.firstChild);\n            }\n            var tuned = tuner(value);\n            while (tuned.firstChild) {\n                node.appendChild(tuned.firstChild);\n            }\n        }\n        eve.stop();\n    })(-1);\n    function setFontSize(value) {\n        eve.stop();\n        if (value == +value) {\n            value += \"px\";\n        }\n        this.node.style.fontSize = value;\n    }\n    eve.on(\"snap.util.attr.fontSize\", setFontSize)(-1);\n    eve.on(\"snap.util.attr.font-size\", setFontSize)(-1);\n\n\n    eve.on(\"snap.util.getattr.transform\", function () {\n        eve.stop();\n        return this.transform();\n    })(-1);\n    eve.on(\"snap.util.getattr.textpath\", function () {\n        eve.stop();\n        return this.textPath;\n    })(-1);\n    // Markers\n    (function () {\n        function getter(end) {\n            return function () {\n                eve.stop();\n                var style = glob.doc.defaultView.getComputedStyle(this.node, null).getPropertyValue(\"marker-\" + end);\n                if (style == \"none\") {\n                    return style;\n                } else {\n                    return Snap(glob.doc.getElementById(style.match(reURLValue)[1]));\n                }\n            };\n        }\n        function setter(end) {\n            return function (value) {\n                eve.stop();\n                var name = \"marker\" + end.charAt(0).toUpperCase() + end.substring(1);\n                if (value == \"\" || !value) {\n                    this.node.style[name] = \"none\";\n                    return;\n                }\n                if (value.type == \"marker\") {\n                    var id = value.node.id;\n                    if (!id) {\n                        $(value.node, {id: value.id});\n                    }\n                    this.node.style[name] = URL(id);\n                    return;\n                }\n            };\n        }\n        eve.on(\"snap.util.getattr.marker-end\", getter(\"end\"))(-1);\n        eve.on(\"snap.util.getattr.markerEnd\", getter(\"end\"))(-1);\n        eve.on(\"snap.util.getattr.marker-start\", getter(\"start\"))(-1);\n        eve.on(\"snap.util.getattr.markerStart\", getter(\"start\"))(-1);\n        eve.on(\"snap.util.getattr.marker-mid\", getter(\"mid\"))(-1);\n        eve.on(\"snap.util.getattr.markerMid\", getter(\"mid\"))(-1);\n        eve.on(\"snap.util.attr.marker-end\", setter(\"end\"))(-1);\n        eve.on(\"snap.util.attr.markerEnd\", setter(\"end\"))(-1);\n        eve.on(\"snap.util.attr.marker-start\", setter(\"start\"))(-1);\n        eve.on(\"snap.util.attr.markerStart\", setter(\"start\"))(-1);\n        eve.on(\"snap.util.attr.marker-mid\", setter(\"mid\"))(-1);\n        eve.on(\"snap.util.attr.markerMid\", setter(\"mid\"))(-1);\n    }());\n    eve.on(\"snap.util.getattr.r\", function () {\n        if (this.type == \"rect\" && $(this.node, \"rx\") == $(this.node, \"ry\")) {\n            eve.stop();\n            return $(this.node, \"rx\");\n        }\n    })(-1);\n    function textExtract(node) {\n        var out = [];\n        var children = node.childNodes;\n        for (var i = 0, ii = children.length; i < ii; i++) {\n            var chi = children[i];\n            if (chi.nodeType == 3) {\n                out.push(chi.nodeValue);\n            }\n            if (chi.tagName == \"tspan\") {\n                if (chi.childNodes.length == 1 && chi.firstChild.nodeType == 3) {\n                    out.push(chi.firstChild.nodeValue);\n                } else {\n                    out.push(textExtract(chi));\n                }\n            }\n        }\n        return out;\n    }\n    eve.on(\"snap.util.getattr.text\", function () {\n        if (this.type == \"text\" || this.type == \"tspan\") {\n            eve.stop();\n            var out = textExtract(this.node);\n            return out.length == 1 ? out[0] : out;\n        }\n    })(-1);\n    eve.on(\"snap.util.getattr.#text\", function () {\n        return this.node.textContent;\n    })(-1);\n    eve.on(\"snap.util.getattr.viewBox\", function () {\n        eve.stop();\n        var vb = $(this.node, \"viewBox\");\n        if (vb) {\n            vb = vb.split(separator);\n            return Snap._.box(+vb[0], +vb[1], +vb[2], +vb[3]);\n        } else {\n            return;\n        }\n    })(-1);\n    eve.on(\"snap.util.getattr.points\", function () {\n        var p = $(this.node, \"points\");\n        eve.stop();\n        if (p) {\n            return p.split(separator);\n        } else {\n            return;\n        }\n    })(-1);\n    eve.on(\"snap.util.getattr.path\", function () {\n        var p = $(this.node, \"d\");\n        eve.stop();\n        return p;\n    })(-1);\n    eve.on(\"snap.util.getattr.class\", function () {\n        return this.node.className.baseVal;\n    })(-1);\n    function getFontSize() {\n        eve.stop();\n        return this.node.style.fontSize;\n    }\n    eve.on(\"snap.util.getattr.fontSize\", getFontSize)(-1);\n    eve.on(\"snap.util.getattr.font-size\", getFontSize)(-1);\n});\n\n// Copyright (c) 2014 Adobe Systems Incorporated. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nSnap.plugin(function (Snap, Element, Paper, glob, Fragment) {\n    var rgNotSpace = /\\S+/g,\n        rgBadSpace = /[\\t\\r\\n\\f]/g,\n        rgTrim = /(^\\s+|\\s+$)/g,\n        Str = String,\n        elproto = Element.prototype;\n    /*\\\n     * Element.addClass\n     [ method ]\n     **\n     * Adds given class name or list of class names to the element.\n     - value (string) class name or space separated list of class names\n     **\n     = (Element) original element.\n    \\*/\n    elproto.addClass = function (value) {\n        var classes = Str(value || \"\").match(rgNotSpace) || [],\n            elem = this.node,\n            className = elem.className.baseVal,\n            curClasses = className.match(rgNotSpace) || [],\n            j,\n            pos,\n            clazz,\n            finalValue;\n\n        if (classes.length) {\n            j = 0;\n            while ((clazz = classes[j++])) {\n                pos = curClasses.indexOf(clazz);\n                if (!~pos) {\n                    curClasses.push(clazz);\n                }\n            }\n\n            finalValue = curClasses.join(\" \");\n            if (className != finalValue) {\n                elem.className.baseVal = finalValue;\n            }\n        }\n        return this;\n    };\n    /*\\\n     * Element.removeClass\n     [ method ]\n     **\n     * Removes given class name or list of class names from the element.\n     - value (string) class name or space separated list of class names\n     **\n     = (Element) original element.\n    \\*/\n    elproto.removeClass = function (value) {\n        var classes = Str(value || \"\").match(rgNotSpace) || [],\n            elem = this.node,\n            className = elem.className.baseVal,\n            curClasses = className.match(rgNotSpace) || [],\n            j,\n            pos,\n            clazz,\n            finalValue;\n        if (curClasses.length) {\n            j = 0;\n            while ((clazz = classes[j++])) {\n                pos = curClasses.indexOf(clazz);\n                if (~pos) {\n                    curClasses.splice(pos, 1);\n                }\n            }\n\n            finalValue = curClasses.join(\" \");\n            if (className != finalValue) {\n                elem.className.baseVal = finalValue;\n            }\n        }\n        return this;\n    };\n    /*\\\n     * Element.hasClass\n     [ method ]\n     **\n     * Checks if the element has a given class name in the list of class names applied to it.\n     - value (string) class name\n     **\n     = (boolean) `true` if the element has given class\n    \\*/\n    elproto.hasClass = function (value) {\n        var elem = this.node,\n            className = elem.className.baseVal,\n            curClasses = className.match(rgNotSpace) || [];\n        return !!~curClasses.indexOf(value);\n    };\n    /*\\\n     * Element.toggleClass\n     [ method ]\n     **\n     * Add or remove one or more classes from the element, depending on either\n     * the classs presence or the value of the `flag` argument.\n     - value (string) class name or space separated list of class names\n     - flag (boolean) value to determine whether the class should be added or removed\n     **\n     = (Element) original element.\n    \\*/\n    elproto.toggleClass = function (value, flag) {\n        if (flag != null) {\n            if (flag) {\n                return this.addClass(value);\n            } else {\n                return this.removeClass(value);\n            }\n        }\n        var classes = (value || \"\").match(rgNotSpace) || [],\n            elem = this.node,\n            className = elem.className.baseVal,\n            curClasses = className.match(rgNotSpace) || [],\n            j,\n            pos,\n            clazz,\n            finalValue;\n        j = 0;\n        while ((clazz = classes[j++])) {\n            pos = curClasses.indexOf(clazz);\n            if (~pos) {\n                curClasses.splice(pos, 1);\n            } else {\n                curClasses.push(clazz);\n            }\n        }\n\n        finalValue = curClasses.join(\" \");\n        if (className != finalValue) {\n            elem.className.baseVal = finalValue;\n        }\n        return this;\n    };\n});\n\n// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nSnap.plugin(function (Snap, Element, Paper, glob, Fragment) {\n    var operators = {\n            \"+\": function (x, y) {\n                    return x + y;\n                },\n            \"-\": function (x, y) {\n                    return x - y;\n                },\n            \"/\": function (x, y) {\n                    return x / y;\n                },\n            \"*\": function (x, y) {\n                    return x * y;\n                }\n        },\n        Str = String,\n        reUnit = /[a-z]+$/i,\n        reAddon = /^\\s*([+\\-\\/*])\\s*=\\s*([\\d.eE+\\-]+)\\s*([^\\d\\s]+)?\\s*$/;\n    function getNumber(val) {\n        return val;\n    }\n    function getUnit(unit) {\n        return function (val) {\n            return +val.toFixed(3) + unit;\n        };\n    }\n    eve.on(\"snap.util.attr\", function (val) {\n        var plus = Str(val).match(reAddon);\n        if (plus) {\n            var evnt = eve.nt(),\n                name = evnt.substring(evnt.lastIndexOf(\".\") + 1),\n                a = this.attr(name),\n                atr = {};\n            eve.stop();\n            var unit = plus[3] || \"\",\n                aUnit = a.match(reUnit),\n                op = operators[plus[1]];\n            if (aUnit && aUnit == unit) {\n                val = op(parseFloat(a), +plus[2]);\n            } else {\n                a = this.asPX(name);\n                val = op(this.asPX(name), this.asPX(name, plus[2] + unit));\n            }\n            if (isNaN(a) || isNaN(val)) {\n                return;\n            }\n            atr[name] = val;\n            this.attr(atr);\n        }\n    })(-10);\n    eve.on(\"snap.util.equal\", function (name, b) {\n        var A, B, a = Str(this.attr(name) || \"\"),\n            el = this,\n            bplus = Str(b).match(reAddon);\n        if (bplus) {\n            eve.stop();\n            var unit = bplus[3] || \"\",\n                aUnit = a.match(reUnit),\n                op = operators[bplus[1]];\n            if (aUnit && aUnit == unit) {\n                return {\n                    from: parseFloat(a),\n                    to: op(parseFloat(a), +bplus[2]),\n                    f: getUnit(aUnit)\n                };\n            } else {\n                a = this.asPX(name);\n                return {\n                    from: a,\n                    to: op(a, this.asPX(name, bplus[2] + unit)),\n                    f: getNumber\n                };\n            }\n        }\n    })(-10);\n});\n// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nSnap.plugin(function (Snap, Element, Paper, glob, Fragment) {\n    var proto = Paper.prototype,\n        is = Snap.is;\n    /*\\\n     * Paper.rect\n     [ method ]\n     *\n     * Draws a rectangle\n     **\n     - x (number) x coordinate of the top left corner\n     - y (number) y coordinate of the top left corner\n     - width (number) width\n     - height (number) height\n     - rx (number) #optional horizontal radius for rounded corners, default is 0\n     - ry (number) #optional vertical radius for rounded corners, default is rx or 0\n     = (object) the `rect` element\n     **\n     > Usage\n     | // regular rectangle\n     | var c = paper.rect(10, 10, 50, 50);\n     | // rectangle with rounded corners\n     | var c = paper.rect(40, 40, 50, 50, 10);\n    \\*/\n    proto.rect = function (x, y, w, h, rx, ry) {\n        var attr;\n        if (ry == null) {\n            ry = rx;\n        }\n        if (is(x, \"object\") && x == \"[object Object]\") {\n            attr = x;\n        } else if (x != null) {\n            attr = {\n                x: x,\n                y: y,\n                width: w,\n                height: h\n            };\n            if (rx != null) {\n                attr.rx = rx;\n                attr.ry = ry;\n            }\n        }\n        return this.el(\"rect\", attr);\n    };\n    /*\\\n     * Paper.circle\n     [ method ]\n     **\n     * Draws a circle\n     **\n     - x (number) x coordinate of the centre\n     - y (number) y coordinate of the centre\n     - r (number) radius\n     = (object) the `circle` element\n     **\n     > Usage\n     | var c = paper.circle(50, 50, 40);\n    \\*/\n    proto.circle = function (cx, cy, r) {\n        var attr;\n        if (is(cx, \"object\") && cx == \"[object Object]\") {\n            attr = cx;\n        } else if (cx != null) {\n            attr = {\n                cx: cx,\n                cy: cy,\n                r: r\n            };\n        }\n        return this.el(\"circle\", attr);\n    };\n\n    var preload = (function () {\n        function onerror() {\n            this.parentNode.removeChild(this);\n        }\n        return function (src, f) {\n            var img = glob.doc.createElement(\"img\"),\n                body = glob.doc.body;\n            img.style.cssText = \"position:absolute;left:-9999em;top:-9999em\";\n            img.onload = function () {\n                f.call(img);\n                img.onload = img.onerror = null;\n                body.removeChild(img);\n            };\n            img.onerror = onerror;\n            body.appendChild(img);\n            img.src = src;\n        };\n    }());\n\n    /*\\\n     * Paper.image\n     [ method ]\n     **\n     * Places an image on the surface\n     **\n     - src (string) URI of the source image\n     - x (number) x offset position\n     - y (number) y offset position\n     - width (number) width of the image\n     - height (number) height of the image\n     = (object) the `image` element\n     * or\n     = (object) Snap element object with type `image`\n     **\n     > Usage\n     | var c = paper.image(\"apple.png\", 10, 10, 80, 80);\n    \\*/\n    proto.image = function (src, x, y, width, height) {\n        var el = this.el(\"image\");\n        if (is(src, \"object\") && \"src\" in src) {\n            el.attr(src);\n        } else if (src != null) {\n            var set = {\n                \"xlink:href\": src,\n                preserveAspectRatio: \"none\"\n            };\n            if (x != null && y != null) {\n                set.x = x;\n                set.y = y;\n            }\n            if (width != null && height != null) {\n                set.width = width;\n                set.height = height;\n            } else {\n                preload(src, function () {\n                    Snap._.$(el.node, {\n                        width: this.offsetWidth,\n                        height: this.offsetHeight\n                    });\n                });\n            }\n            Snap._.$(el.node, set);\n        }\n        return el;\n    };\n    /*\\\n     * Paper.ellipse\n     [ method ]\n     **\n     * Draws an ellipse\n     **\n     - x (number) x coordinate of the centre\n     - y (number) y coordinate of the centre\n     - rx (number) horizontal radius\n     - ry (number) vertical radius\n     = (object) the `ellipse` element\n     **\n     > Usage\n     | var c = paper.ellipse(50, 50, 40, 20);\n    \\*/\n    proto.ellipse = function (cx, cy, rx, ry) {\n        var attr;\n        if (is(cx, \"object\") && cx == \"[object Object]\") {\n            attr = cx;\n        } else if (cx != null) {\n            attr ={\n                cx: cx,\n                cy: cy,\n                rx: rx,\n                ry: ry\n            };\n        }\n        return this.el(\"ellipse\", attr);\n    };\n    // SIERRA Paper.path(): Unclear from the link what a Catmull-Rom curveto is, and why it would make life any easier.\n    /*\\\n     * Paper.path\n     [ method ]\n     **\n     * Creates a `<path>` element using the given string as the path's definition\n     - pathString (string) #optional path string in SVG format\n     * Path string consists of one-letter commands, followed by comma seprarated arguments in numerical form. Example:\n     | \"M10,20L30,40\"\n     * This example features two commands: `M`, with arguments `(10, 20)` and `L` with arguments `(30, 40)`. Uppercase letter commands express coordinates in absolute terms, while lowercase commands express them in relative terms from the most recently declared coordinates.\n     *\n     # <p>Here is short list of commands available, for more details see <a href=\"http://www.w3.org/TR/SVG/paths.html#PathData\" title=\"Details of a path's data attribute's format are described in the SVG specification.\">SVG path string format</a> or <a href=\"https://developer.mozilla.org/en/SVG/Tutorial/Paths\">article about path strings at MDN</a>.</p>\n     # <table><thead><tr><th>Command</th><th>Name</th><th>Parameters</th></tr></thead><tbody>\n     # <tr><td>M</td><td>moveto</td><td>(x y)+</td></tr>\n     # <tr><td>Z</td><td>closepath</td><td>(none)</td></tr>\n     # <tr><td>L</td><td>lineto</td><td>(x y)+</td></tr>\n     # <tr><td>H</td><td>horizontal lineto</td><td>x+</td></tr>\n     # <tr><td>V</td><td>vertical lineto</td><td>y+</td></tr>\n     # <tr><td>C</td><td>curveto</td><td>(x1 y1 x2 y2 x y)+</td></tr>\n     # <tr><td>S</td><td>smooth curveto</td><td>(x2 y2 x y)+</td></tr>\n     # <tr><td>Q</td><td>quadratic Bzier curveto</td><td>(x1 y1 x y)+</td></tr>\n     # <tr><td>T</td><td>smooth quadratic Bzier curveto</td><td>(x y)+</td></tr>\n     # <tr><td>A</td><td>elliptical arc</td><td>(rx ry x-axis-rotation large-arc-flag sweep-flag x y)+</td></tr>\n     # <tr><td>R</td><td><a href=\"http://en.wikipedia.org/wiki/CatmullRom_spline#Catmull.E2.80.93Rom_spline\">Catmull-Rom curveto</a>*</td><td>x1 y1 (x y)+</td></tr></tbody></table>\n     * * _Catmull-Rom curveto_ is a not standard SVG command and added to make life easier.\n     * Note: there is a special case when a path consists of only three commands: `M10,10Rz`. In this case the path connects back to its starting point.\n     > Usage\n     | var c = paper.path(\"M10 10L90 90\");\n     | // draw a diagonal line:\n     | // move to 10,10, line to 90,90\n    \\*/\n    proto.path = function (d) {\n        var attr;\n        if (is(d, \"object\") && !is(d, \"array\")) {\n            attr = d;\n        } else if (d) {\n            attr = {d: d};\n        }\n        return this.el(\"path\", attr);\n    };\n    /*\\\n     * Paper.g\n     [ method ]\n     **\n     * Creates a group element\n     **\n     - varargs () #optional elements to nest within the group\n     = (object) the `g` element\n     **\n     > Usage\n     | var c1 = paper.circle(),\n     |     c2 = paper.rect(),\n     |     g = paper.g(c2, c1); // note that the order of elements is different\n     * or\n     | var c1 = paper.circle(),\n     |     c2 = paper.rect(),\n     |     g = paper.g();\n     | g.add(c2, c1);\n    \\*/\n    /*\\\n     * Paper.group\n     [ method ]\n     **\n     * See @Paper.g\n    \\*/\n    proto.group = proto.g = function (first) {\n        var attr,\n            el = this.el(\"g\");\n        if (arguments.length == 1 && first && !first.type) {\n            el.attr(first);\n        } else if (arguments.length) {\n            el.add(Array.prototype.slice.call(arguments, 0));\n        }\n        return el;\n    };\n    /*\\\n     * Paper.svg\n     [ method ]\n     **\n     * Creates a nested SVG element.\n     - x (number) @optional X of the element\n     - y (number) @optional Y of the element\n     - width (number) @optional width of the element\n     - height (number) @optional height of the element\n     - vbx (number) @optional viewbox X\n     - vby (number) @optional viewbox Y\n     - vbw (number) @optional viewbox width\n     - vbh (number) @optional viewbox height\n     **\n     = (object) the `svg` element\n     **\n    \\*/\n    proto.svg = function (x, y, width, height, vbx, vby, vbw, vbh) {\n        var attrs = {};\n        if (is(x, \"object\") && y == null) {\n            attrs = x;\n        } else {\n            if (x != null) {\n                attrs.x = x;\n            }\n            if (y != null) {\n                attrs.y = y;\n            }\n            if (width != null) {\n                attrs.width = width;\n            }\n            if (height != null) {\n                attrs.height = height;\n            }\n            if (vbx != null && vby != null && vbw != null && vbh != null) {\n                attrs.viewBox = [vbx, vby, vbw, vbh];\n            }\n        }\n        return this.el(\"svg\", attrs);\n    };\n    /*\\\n     * Paper.mask\n     [ method ]\n     **\n     * Equivalent in behaviour to @Paper.g, except its a mask.\n     **\n     = (object) the `mask` element\n     **\n    \\*/\n    proto.mask = function (first) {\n        var attr,\n            el = this.el(\"mask\");\n        if (arguments.length == 1 && first && !first.type) {\n            el.attr(first);\n        } else if (arguments.length) {\n            el.add(Array.prototype.slice.call(arguments, 0));\n        }\n        return el;\n    };\n    /*\\\n     * Paper.ptrn\n     [ method ]\n     **\n     * Equivalent in behaviour to @Paper.g, except its a pattern.\n     - x (number) @optional X of the element\n     - y (number) @optional Y of the element\n     - width (number) @optional width of the element\n     - height (number) @optional height of the element\n     - vbx (number) @optional viewbox X\n     - vby (number) @optional viewbox Y\n     - vbw (number) @optional viewbox width\n     - vbh (number) @optional viewbox height\n     **\n     = (object) the `pattern` element\n     **\n    \\*/\n    proto.ptrn = function (x, y, width, height, vx, vy, vw, vh) {\n        if (is(x, \"object\")) {\n            var attr = x;\n        } else {\n            attr = {patternUnits: \"userSpaceOnUse\"};\n            if (x) {\n                attr.x = x;\n            }\n            if (y) {\n                attr.y = y;\n            }\n            if (width != null) {\n                attr.width = width;\n            }\n            if (height != null) {\n                attr.height = height;\n            }\n            if (vx != null && vy != null && vw != null && vh != null) {\n                attr.viewBox = [vx, vy, vw, vh];\n            } else {\n                attr.viewBox = [x || 0, y || 0, width || 0, height || 0];\n            }\n        }\n        return this.el(\"pattern\", attr);\n    };\n    /*\\\n     * Paper.use\n     [ method ]\n     **\n     * Creates a <use> element.\n     - id (string) @optional id of element to link\n     * or\n     - id (Element) @optional element to link\n     **\n     = (object) the `use` element\n     **\n    \\*/\n    proto.use = function (id) {\n        if (id != null) {\n            if (id instanceof Element) {\n                if (!id.attr(\"id\")) {\n                    id.attr({id: Snap._.id(id)});\n                }\n                id = id.attr(\"id\");\n            }\n            if (String(id).charAt() == \"#\") {\n                id = id.substring(1);\n            }\n            return this.el(\"use\", {\"xlink:href\": \"#\" + id});\n        } else {\n            return Element.prototype.use.call(this);\n        }\n    };\n    /*\\\n     * Paper.symbol\n     [ method ]\n     **\n     * Creates a <symbol> element.\n     - vbx (number) @optional viewbox X\n     - vby (number) @optional viewbox Y\n     - vbw (number) @optional viewbox width\n     - vbh (number) @optional viewbox height\n     = (object) the `symbol` element\n     **\n    \\*/\n    proto.symbol = function (vx, vy, vw, vh) {\n        var attr = {};\n        if (vx != null && vy != null && vw != null && vh != null) {\n            attr.viewBox = [vx, vy, vw, vh];\n        }\n\n        return this.el(\"symbol\", attr);\n    };\n    /*\\\n     * Paper.text\n     [ method ]\n     **\n     * Draws a text string\n     **\n     - x (number) x coordinate position\n     - y (number) y coordinate position\n     - text (string|array) The text string to draw or array of strings to nest within separate `<tspan>` elements\n     = (object) the `text` element\n     **\n     > Usage\n     | var t1 = paper.text(50, 50, \"Snap\");\n     | var t2 = paper.text(50, 50, [\"S\",\"n\",\"a\",\"p\"]);\n     | // Text path usage\n     | t1.attr({textpath: \"M10,10L100,100\"});\n     | // or\n     | var pth = paper.path(\"M10,10L100,100\");\n     | t1.attr({textpath: pth});\n    \\*/\n    proto.text = function (x, y, text) {\n        var attr = {};\n        if (is(x, \"object\")) {\n            attr = x;\n        } else if (x != null) {\n            attr = {\n                x: x,\n                y: y,\n                text: text || \"\"\n            };\n        }\n        return this.el(\"text\", attr);\n    };\n    /*\\\n     * Paper.line\n     [ method ]\n     **\n     * Draws a line\n     **\n     - x1 (number) x coordinate position of the start\n     - y1 (number) y coordinate position of the start\n     - x2 (number) x coordinate position of the end\n     - y2 (number) y coordinate position of the end\n     = (object) the `line` element\n     **\n     > Usage\n     | var t1 = paper.line(50, 50, 100, 100);\n    \\*/\n    proto.line = function (x1, y1, x2, y2) {\n        var attr = {};\n        if (is(x1, \"object\")) {\n            attr = x1;\n        } else if (x1 != null) {\n            attr = {\n                x1: x1,\n                x2: x2,\n                y1: y1,\n                y2: y2\n            };\n        }\n        return this.el(\"line\", attr);\n    };\n    /*\\\n     * Paper.polyline\n     [ method ]\n     **\n     * Draws a polyline\n     **\n     - points (array) array of points\n     * or\n     - varargs () points\n     = (object) the `polyline` element\n     **\n     > Usage\n     | var p1 = paper.polyline([10, 10, 100, 100]);\n     | var p2 = paper.polyline(10, 10, 100, 100);\n    \\*/\n    proto.polyline = function (points) {\n        if (arguments.length > 1) {\n            points = Array.prototype.slice.call(arguments, 0);\n        }\n        var attr = {};\n        if (is(points, \"object\") && !is(points, \"array\")) {\n            attr = points;\n        } else if (points != null) {\n            attr = {points: points};\n        }\n        return this.el(\"polyline\", attr);\n    };\n    /*\\\n     * Paper.polygon\n     [ method ]\n     **\n     * Draws a polygon. See @Paper.polyline\n    \\*/\n    proto.polygon = function (points) {\n        if (arguments.length > 1) {\n            points = Array.prototype.slice.call(arguments, 0);\n        }\n        var attr = {};\n        if (is(points, \"object\") && !is(points, \"array\")) {\n            attr = points;\n        } else if (points != null) {\n            attr = {points: points};\n        }\n        return this.el(\"polygon\", attr);\n    };\n    // gradients\n    (function () {\n        var $ = Snap._.$;\n        // gradients' helpers\n        function Gstops() {\n            return this.selectAll(\"stop\");\n        }\n        function GaddStop(color, offset) {\n            var stop = $(\"stop\"),\n                attr = {\n                    offset: +offset + \"%\"\n                };\n            color = Snap.color(color);\n            attr[\"stop-color\"] = color.hex;\n            if (color.opacity < 1) {\n                attr[\"stop-opacity\"] = color.opacity;\n            }\n            $(stop, attr);\n            this.node.appendChild(stop);\n            return this;\n        }\n        function GgetBBox() {\n            if (this.type == \"linearGradient\") {\n                var x1 = $(this.node, \"x1\") || 0,\n                    x2 = $(this.node, \"x2\") || 1,\n                    y1 = $(this.node, \"y1\") || 0,\n                    y2 = $(this.node, \"y2\") || 0;\n                return Snap._.box(x1, y1, math.abs(x2 - x1), math.abs(y2 - y1));\n            } else {\n                var cx = this.node.cx || .5,\n                    cy = this.node.cy || .5,\n                    r = this.node.r || 0;\n                return Snap._.box(cx - r, cy - r, r * 2, r * 2);\n            }\n        }\n        function gradient(defs, str) {\n            var grad = eve(\"snap.util.grad.parse\", null, str).firstDefined(),\n                el;\n            if (!grad) {\n                return null;\n            }\n            grad.params.unshift(defs);\n            if (grad.type.toLowerCase() == \"l\") {\n                el = gradientLinear.apply(0, grad.params);\n            } else {\n                el = gradientRadial.apply(0, grad.params);\n            }\n            if (grad.type != grad.type.toLowerCase()) {\n                $(el.node, {\n                    gradientUnits: \"userSpaceOnUse\"\n                });\n            }\n            var stops = grad.stops,\n                len = stops.length,\n                start = 0,\n                j = 0;\n            function seed(i, end) {\n                var step = (end - start) / (i - j);\n                for (var k = j; k < i; k++) {\n                    stops[k].offset = +(+start + step * (k - j)).toFixed(2);\n                }\n                j = i;\n                start = end;\n            }\n            len--;\n            for (var i = 0; i < len; i++) if (\"offset\" in stops[i]) {\n                seed(i, stops[i].offset);\n            }\n            stops[len].offset = stops[len].offset || 100;\n            seed(len, stops[len].offset);\n            for (i = 0; i <= len; i++) {\n                var stop = stops[i];\n                el.addStop(stop.color, stop.offset);\n            }\n            return el;\n        }\n        function gradientLinear(defs, x1, y1, x2, y2) {\n            var el = Snap._.make(\"linearGradient\", defs);\n            el.stops = Gstops;\n            el.addStop = GaddStop;\n            el.getBBox = GgetBBox;\n            if (x1 != null) {\n                $(el.node, {\n                    x1: x1,\n                    y1: y1,\n                    x2: x2,\n                    y2: y2\n                });\n            }\n            return el;\n        }\n        function gradientRadial(defs, cx, cy, r, fx, fy) {\n            var el = Snap._.make(\"radialGradient\", defs);\n            el.stops = Gstops;\n            el.addStop = GaddStop;\n            el.getBBox = GgetBBox;\n            if (cx != null) {\n                $(el.node, {\n                    cx: cx,\n                    cy: cy,\n                    r: r\n                });\n            }\n            if (fx != null && fy != null) {\n                $(el.node, {\n                    fx: fx,\n                    fy: fy\n                });\n            }\n            return el;\n        }\n        /*\\\n         * Paper.gradient\n         [ method ]\n         **\n         * Creates a gradient element\n         **\n         - gradient (string) gradient descriptor\n         > Gradient Descriptor\n         * The gradient descriptor is an expression formatted as\n         * follows: `<type>(<coords>)<colors>`.  The `<type>` can be\n         * either linear or radial.  The uppercase `L` or `R` letters\n         * indicate absolute coordinates offset from the SVG surface.\n         * Lowercase `l` or `r` letters indicate coordinates\n         * calculated relative to the element to which the gradient is\n         * applied.  Coordinates specify a linear gradient vector as\n         * `x1`, `y1`, `x2`, `y2`, or a radial gradient as `cx`, `cy`,\n         * `r` and optional `fx`, `fy` specifying a focal point away\n         * from the center of the circle. Specify `<colors>` as a list\n         * of dash-separated CSS color values.  Each color may be\n         * followed by a custom offset value, separated with a colon\n         * character.\n         > Examples\n         * Linear gradient, relative from top-left corner to bottom-right\n         * corner, from black through red to white:\n         | var g = paper.gradient(\"l(0, 0, 1, 1)#000-#f00-#fff\");\n         * Linear gradient, absolute from (0, 0) to (100, 100), from black\n         * through red at 25% to white:\n         | var g = paper.gradient(\"L(0, 0, 100, 100)#000-#f00:25-#fff\");\n         * Radial gradient, relative from the center of the element with radius\n         * half the width, from black to white:\n         | var g = paper.gradient(\"r(0.5, 0.5, 0.5)#000-#fff\");\n         * To apply the gradient:\n         | paper.circle(50, 50, 40).attr({\n         |     fill: g\n         | });\n         = (object) the `gradient` element\n        \\*/\n        proto.gradient = function (str) {\n            return gradient(this.defs, str);\n        };\n        proto.gradientLinear = function (x1, y1, x2, y2) {\n            return gradientLinear(this.defs, x1, y1, x2, y2);\n        };\n        proto.gradientRadial = function (cx, cy, r, fx, fy) {\n            return gradientRadial(this.defs, cx, cy, r, fx, fy);\n        };\n        /*\\\n         * Paper.toString\n         [ method ]\n         **\n         * Returns SVG code for the @Paper\n         = (string) SVG code for the @Paper\n        \\*/\n        proto.toString = function () {\n            var doc = this.node.ownerDocument,\n                f = doc.createDocumentFragment(),\n                d = doc.createElement(\"div\"),\n                svg = this.node.cloneNode(true),\n                res;\n            f.appendChild(d);\n            d.appendChild(svg);\n            Snap._.$(svg, {xmlns: \"http://www.w3.org/2000/svg\"});\n            res = d.innerHTML;\n            f.removeChild(f.firstChild);\n            return res;\n        };\n        /*\\\n         * Paper.toDataURL\n         [ method ]\n         **\n         * Returns SVG code for the @Paper as Data URI string.\n         = (string) Data URI string\n        \\*/\n        proto.toDataURL = function () {\n            if (window && window.btoa) {\n                return \"data:image/svg+xml;base64,\" + btoa(unescape(encodeURIComponent(this)));\n            }\n        };\n        /*\\\n         * Paper.clear\n         [ method ]\n         **\n         * Removes all child nodes of the paper, except <defs>.\n        \\*/\n        proto.clear = function () {\n            var node = this.node.firstChild,\n                next;\n            while (node) {\n                next = node.nextSibling;\n                if (node.tagName != \"defs\") {\n                    node.parentNode.removeChild(node);\n                } else {\n                    proto.clear.call({node: node});\n                }\n                node = next;\n            }\n        };\n    }());\n});\n\n// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nSnap.plugin(function (Snap, Element, Paper, glob) {\n    var elproto = Element.prototype,\n        is = Snap.is,\n        clone = Snap._.clone,\n        has = \"hasOwnProperty\",\n        p2s = /,?([a-z]),?/gi,\n        toFloat = parseFloat,\n        math = Math,\n        PI = math.PI,\n        mmin = math.min,\n        mmax = math.max,\n        pow = math.pow,\n        abs = math.abs;\n    function paths(ps) {\n        var p = paths.ps = paths.ps || {};\n        if (p[ps]) {\n            p[ps].sleep = 100;\n        } else {\n            p[ps] = {\n                sleep: 100\n            };\n        }\n        setTimeout(function () {\n            for (var key in p) if (p[has](key) && key != ps) {\n                p[key].sleep--;\n                !p[key].sleep && delete p[key];\n            }\n        });\n        return p[ps];\n    }\n    function box(x, y, width, height) {\n        if (x == null) {\n            x = y = width = height = 0;\n        }\n        if (y == null) {\n            y = x.y;\n            width = x.width;\n            height = x.height;\n            x = x.x;\n        }\n        return {\n            x: x,\n            y: y,\n            width: width,\n            w: width,\n            height: height,\n            h: height,\n            x2: x + width,\n            y2: y + height,\n            cx: x + width / 2,\n            cy: y + height / 2,\n            r1: math.min(width, height) / 2,\n            r2: math.max(width, height) / 2,\n            r0: math.sqrt(width * width + height * height) / 2,\n            path: rectPath(x, y, width, height),\n            vb: [x, y, width, height].join(\" \")\n        };\n    }\n    function toString() {\n        return this.join(\",\").replace(p2s, \"$1\");\n    }\n    function pathClone(pathArray) {\n        var res = clone(pathArray);\n        res.toString = toString;\n        return res;\n    }\n    function getPointAtSegmentLength(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length) {\n        if (length == null) {\n            return bezlen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y);\n        } else {\n            return findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y,\n                getTotLen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length));\n        }\n    }\n    function getLengthFactory(istotal, subpath) {\n        function O(val) {\n            return +(+val).toFixed(3);\n        }\n        return Snap._.cacher(function (path, length, onlystart) {\n            if (path instanceof Element) {\n                path = path.attr(\"d\");\n            }\n            path = path2curve(path);\n            var x, y, p, l, sp = \"\", subpaths = {}, point,\n                len = 0;\n            for (var i = 0, ii = path.length; i < ii; i++) {\n                p = path[i];\n                if (p[0] == \"M\") {\n                    x = +p[1];\n                    y = +p[2];\n                } else {\n                    l = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);\n                    if (len + l > length) {\n                        if (subpath && !subpaths.start) {\n                            point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);\n                            sp += [\n                                \"C\" + O(point.start.x),\n                                O(point.start.y),\n                                O(point.m.x),\n                                O(point.m.y),\n                                O(point.x),\n                                O(point.y)\n                            ];\n                            if (onlystart) {return sp;}\n                            subpaths.start = sp;\n                            sp = [\n                                \"M\" + O(point.x),\n                                O(point.y) + \"C\" + O(point.n.x),\n                                O(point.n.y),\n                                O(point.end.x),\n                                O(point.end.y),\n                                O(p[5]),\n                                O(p[6])\n                            ].join();\n                            len += l;\n                            x = +p[5];\n                            y = +p[6];\n                            continue;\n                        }\n                        if (!istotal && !subpath) {\n                            point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);\n                            return point;\n                        }\n                    }\n                    len += l;\n                    x = +p[5];\n                    y = +p[6];\n                }\n                sp += p.shift() + p;\n            }\n            subpaths.end = sp;\n            point = istotal ? len : subpath ? subpaths : findDotsAtSegment(x, y, p[0], p[1], p[2], p[3], p[4], p[5], 1);\n            return point;\n        }, null, Snap._.clone);\n    }\n    var getTotalLength = getLengthFactory(1),\n        getPointAtLength = getLengthFactory(),\n        getSubpathsAtLength = getLengthFactory(0, 1);\n    function findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {\n        var t1 = 1 - t,\n            t13 = pow(t1, 3),\n            t12 = pow(t1, 2),\n            t2 = t * t,\n            t3 = t2 * t,\n            x = t13 * p1x + t12 * 3 * t * c1x + t1 * 3 * t * t * c2x + t3 * p2x,\n            y = t13 * p1y + t12 * 3 * t * c1y + t1 * 3 * t * t * c2y + t3 * p2y,\n            mx = p1x + 2 * t * (c1x - p1x) + t2 * (c2x - 2 * c1x + p1x),\n            my = p1y + 2 * t * (c1y - p1y) + t2 * (c2y - 2 * c1y + p1y),\n            nx = c1x + 2 * t * (c2x - c1x) + t2 * (p2x - 2 * c2x + c1x),\n            ny = c1y + 2 * t * (c2y - c1y) + t2 * (p2y - 2 * c2y + c1y),\n            ax = t1 * p1x + t * c1x,\n            ay = t1 * p1y + t * c1y,\n            cx = t1 * c2x + t * p2x,\n            cy = t1 * c2y + t * p2y,\n            alpha = (90 - math.atan2(mx - nx, my - ny) * 180 / PI);\n        // (mx > nx || my < ny) && (alpha += 180);\n        return {\n            x: x,\n            y: y,\n            m: {x: mx, y: my},\n            n: {x: nx, y: ny},\n            start: {x: ax, y: ay},\n            end: {x: cx, y: cy},\n            alpha: alpha\n        };\n    }\n    function bezierBBox(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {\n        if (!Snap.is(p1x, \"array\")) {\n            p1x = [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y];\n        }\n        var bbox = curveDim.apply(null, p1x);\n        return box(\n            bbox.min.x,\n            bbox.min.y,\n            bbox.max.x - bbox.min.x,\n            bbox.max.y - bbox.min.y\n        );\n    }\n    function isPointInsideBBox(bbox, x, y) {\n        return  x >= bbox.x &&\n                x <= bbox.x + bbox.width &&\n                y >= bbox.y &&\n                y <= bbox.y + bbox.height;\n    }\n    function isBBoxIntersect(bbox1, bbox2) {\n        bbox1 = box(bbox1);\n        bbox2 = box(bbox2);\n        return isPointInsideBBox(bbox2, bbox1.x, bbox1.y)\n            || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y)\n            || isPointInsideBBox(bbox2, bbox1.x, bbox1.y2)\n            || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y2)\n            || isPointInsideBBox(bbox1, bbox2.x, bbox2.y)\n            || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y)\n            || isPointInsideBBox(bbox1, bbox2.x, bbox2.y2)\n            || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y2)\n            || (bbox1.x < bbox2.x2 && bbox1.x > bbox2.x\n                || bbox2.x < bbox1.x2 && bbox2.x > bbox1.x)\n            && (bbox1.y < bbox2.y2 && bbox1.y > bbox2.y\n                || bbox2.y < bbox1.y2 && bbox2.y > bbox1.y);\n    }\n    function base3(t, p1, p2, p3, p4) {\n        var t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4,\n            t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;\n        return t * t2 - 3 * p1 + 3 * p2;\n    }\n    function bezlen(x1, y1, x2, y2, x3, y3, x4, y4, z) {\n        if (z == null) {\n            z = 1;\n        }\n        z = z > 1 ? 1 : z < 0 ? 0 : z;\n        var z2 = z / 2,\n            n = 12,\n            Tvalues = [-.1252,.1252,-.3678,.3678,-.5873,.5873,-.7699,.7699,-.9041,.9041,-.9816,.9816],\n            Cvalues = [0.2491,0.2491,0.2335,0.2335,0.2032,0.2032,0.1601,0.1601,0.1069,0.1069,0.0472,0.0472],\n            sum = 0;\n        for (var i = 0; i < n; i++) {\n            var ct = z2 * Tvalues[i] + z2,\n                xbase = base3(ct, x1, x2, x3, x4),\n                ybase = base3(ct, y1, y2, y3, y4),\n                comb = xbase * xbase + ybase * ybase;\n            sum += Cvalues[i] * math.sqrt(comb);\n        }\n        return z2 * sum;\n    }\n    function getTotLen(x1, y1, x2, y2, x3, y3, x4, y4, ll) {\n        if (ll < 0 || bezlen(x1, y1, x2, y2, x3, y3, x4, y4) < ll) {\n            return;\n        }\n        var t = 1,\n            step = t / 2,\n            t2 = t - step,\n            l,\n            e = .01;\n        l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);\n        while (abs(l - ll) > e) {\n            step /= 2;\n            t2 += (l < ll ? 1 : -1) * step;\n            l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);\n        }\n        return t2;\n    }\n    function intersect(x1, y1, x2, y2, x3, y3, x4, y4) {\n        if (\n            mmax(x1, x2) < mmin(x3, x4) ||\n            mmin(x1, x2) > mmax(x3, x4) ||\n            mmax(y1, y2) < mmin(y3, y4) ||\n            mmin(y1, y2) > mmax(y3, y4)\n        ) {\n            return;\n        }\n        var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),\n            ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),\n            denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n\n        if (!denominator) {\n            return;\n        }\n        var px = nx / denominator,\n            py = ny / denominator,\n            px2 = +px.toFixed(2),\n            py2 = +py.toFixed(2);\n        if (\n            px2 < +mmin(x1, x2).toFixed(2) ||\n            px2 > +mmax(x1, x2).toFixed(2) ||\n            px2 < +mmin(x3, x4).toFixed(2) ||\n            px2 > +mmax(x3, x4).toFixed(2) ||\n            py2 < +mmin(y1, y2).toFixed(2) ||\n            py2 > +mmax(y1, y2).toFixed(2) ||\n            py2 < +mmin(y3, y4).toFixed(2) ||\n            py2 > +mmax(y3, y4).toFixed(2)\n        ) {\n            return;\n        }\n        return {x: px, y: py};\n    }\n    function inter(bez1, bez2) {\n        return interHelper(bez1, bez2);\n    }\n    function interCount(bez1, bez2) {\n        return interHelper(bez1, bez2, 1);\n    }\n    function interHelper(bez1, bez2, justCount) {\n        var bbox1 = bezierBBox(bez1),\n            bbox2 = bezierBBox(bez2);\n        if (!isBBoxIntersect(bbox1, bbox2)) {\n            return justCount ? 0 : [];\n        }\n        var l1 = bezlen.apply(0, bez1),\n            l2 = bezlen.apply(0, bez2),\n            n1 = ~~(l1 / 8),\n            n2 = ~~(l2 / 8),\n            dots1 = [],\n            dots2 = [],\n            xy = {},\n            res = justCount ? 0 : [];\n        for (var i = 0; i < n1 + 1; i++) {\n            var p = findDotsAtSegment.apply(0, bez1.concat(i / n1));\n            dots1.push({x: p.x, y: p.y, t: i / n1});\n        }\n        for (i = 0; i < n2 + 1; i++) {\n            p = findDotsAtSegment.apply(0, bez2.concat(i / n2));\n            dots2.push({x: p.x, y: p.y, t: i / n2});\n        }\n        for (i = 0; i < n1; i++) {\n            for (var j = 0; j < n2; j++) {\n                var di = dots1[i],\n                    di1 = dots1[i + 1],\n                    dj = dots2[j],\n                    dj1 = dots2[j + 1],\n                    ci = abs(di1.x - di.x) < .001 ? \"y\" : \"x\",\n                    cj = abs(dj1.x - dj.x) < .001 ? \"y\" : \"x\",\n                    is = intersect(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y);\n                if (is) {\n                    if (xy[is.x.toFixed(4)] == is.y.toFixed(4)) {\n                        continue;\n                    }\n                    xy[is.x.toFixed(4)] = is.y.toFixed(4);\n                    var t1 = di.t + abs((is[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t),\n                        t2 = dj.t + abs((is[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);\n                    if (t1 >= 0 && t1 <= 1 && t2 >= 0 && t2 <= 1) {\n                        if (justCount) {\n                            res++;\n                        } else {\n                            res.push({\n                                x: is.x,\n                                y: is.y,\n                                t1: t1,\n                                t2: t2\n                            });\n                        }\n                    }\n                }\n            }\n        }\n        return res;\n    }\n    function pathIntersection(path1, path2) {\n        return interPathHelper(path1, path2);\n    }\n    function pathIntersectionNumber(path1, path2) {\n        return interPathHelper(path1, path2, 1);\n    }\n    function interPathHelper(path1, path2, justCount) {\n        path1 = path2curve(path1);\n        path2 = path2curve(path2);\n        var x1, y1, x2, y2, x1m, y1m, x2m, y2m, bez1, bez2,\n            res = justCount ? 0 : [];\n        for (var i = 0, ii = path1.length; i < ii; i++) {\n            var pi = path1[i];\n            if (pi[0] == \"M\") {\n                x1 = x1m = pi[1];\n                y1 = y1m = pi[2];\n            } else {\n                if (pi[0] == \"C\") {\n                    bez1 = [x1, y1].concat(pi.slice(1));\n                    x1 = bez1[6];\n                    y1 = bez1[7];\n                } else {\n                    bez1 = [x1, y1, x1, y1, x1m, y1m, x1m, y1m];\n                    x1 = x1m;\n                    y1 = y1m;\n                }\n                for (var j = 0, jj = path2.length; j < jj; j++) {\n                    var pj = path2[j];\n                    if (pj[0] == \"M\") {\n                        x2 = x2m = pj[1];\n                        y2 = y2m = pj[2];\n                    } else {\n                        if (pj[0] == \"C\") {\n                            bez2 = [x2, y2].concat(pj.slice(1));\n                            x2 = bez2[6];\n                            y2 = bez2[7];\n                        } else {\n                            bez2 = [x2, y2, x2, y2, x2m, y2m, x2m, y2m];\n                            x2 = x2m;\n                            y2 = y2m;\n                        }\n                        var intr = interHelper(bez1, bez2, justCount);\n                        if (justCount) {\n                            res += intr;\n                        } else {\n                            for (var k = 0, kk = intr.length; k < kk; k++) {\n                                intr[k].segment1 = i;\n                                intr[k].segment2 = j;\n                                intr[k].bez1 = bez1;\n                                intr[k].bez2 = bez2;\n                            }\n                            res = res.concat(intr);\n                        }\n                    }\n                }\n            }\n        }\n        return res;\n    }\n    function isPointInsidePath(path, x, y) {\n        var bbox = pathBBox(path);\n        return isPointInsideBBox(bbox, x, y) &&\n               interPathHelper(path, [[\"M\", x, y], [\"H\", bbox.x2 + 10]], 1) % 2 == 1;\n    }\n    function pathBBox(path) {\n        var pth = paths(path);\n        if (pth.bbox) {\n            return clone(pth.bbox);\n        }\n        if (!path) {\n            return box();\n        }\n        path = path2curve(path);\n        var x = 0,\n            y = 0,\n            X = [],\n            Y = [],\n            p;\n        for (var i = 0, ii = path.length; i < ii; i++) {\n            p = path[i];\n            if (p[0] == \"M\") {\n                x = p[1];\n                y = p[2];\n                X.push(x);\n                Y.push(y);\n            } else {\n                var dim = curveDim(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);\n                X = X.concat(dim.min.x, dim.max.x);\n                Y = Y.concat(dim.min.y, dim.max.y);\n                x = p[5];\n                y = p[6];\n            }\n        }\n        var xmin = mmin.apply(0, X),\n            ymin = mmin.apply(0, Y),\n            xmax = mmax.apply(0, X),\n            ymax = mmax.apply(0, Y),\n            bb = box(xmin, ymin, xmax - xmin, ymax - ymin);\n        pth.bbox = clone(bb);\n        return bb;\n    }\n    function rectPath(x, y, w, h, r) {\n        if (r) {\n            return [\n                [\"M\", +x + (+r), y],\n                [\"l\", w - r * 2, 0],\n                [\"a\", r, r, 0, 0, 1, r, r],\n                [\"l\", 0, h - r * 2],\n                [\"a\", r, r, 0, 0, 1, -r, r],\n                [\"l\", r * 2 - w, 0],\n                [\"a\", r, r, 0, 0, 1, -r, -r],\n                [\"l\", 0, r * 2 - h],\n                [\"a\", r, r, 0, 0, 1, r, -r],\n                [\"z\"]\n            ];\n        }\n        var res = [[\"M\", x, y], [\"l\", w, 0], [\"l\", 0, h], [\"l\", -w, 0], [\"z\"]];\n        res.toString = toString;\n        return res;\n    }\n    function ellipsePath(x, y, rx, ry, a) {\n        if (a == null && ry == null) {\n            ry = rx;\n        }\n        x = +x;\n        y = +y;\n        rx = +rx;\n        ry = +ry;\n        if (a != null) {\n            var rad = Math.PI / 180,\n                x1 = x + rx * Math.cos(-ry * rad),\n                x2 = x + rx * Math.cos(-a * rad),\n                y1 = y + rx * Math.sin(-ry * rad),\n                y2 = y + rx * Math.sin(-a * rad),\n                res = [[\"M\", x1, y1], [\"A\", rx, rx, 0, +(a - ry > 180), 0, x2, y2]];\n        } else {\n            res = [\n                [\"M\", x, y],\n                [\"m\", 0, -ry],\n                [\"a\", rx, ry, 0, 1, 1, 0, 2 * ry],\n                [\"a\", rx, ry, 0, 1, 1, 0, -2 * ry],\n                [\"z\"]\n            ];\n        }\n        res.toString = toString;\n        return res;\n    }\n    var unit2px = Snap._unit2px,\n        getPath = {\n        path: function (el) {\n            return el.attr(\"path\");\n        },\n        circle: function (el) {\n            var attr = unit2px(el);\n            return ellipsePath(attr.cx, attr.cy, attr.r);\n        },\n        ellipse: function (el) {\n            var attr = unit2px(el);\n            return ellipsePath(attr.cx || 0, attr.cy || 0, attr.rx, attr.ry);\n        },\n        rect: function (el) {\n            var attr = unit2px(el);\n            return rectPath(attr.x || 0, attr.y || 0, attr.width, attr.height, attr.rx, attr.ry);\n        },\n        image: function (el) {\n            var attr = unit2px(el);\n            return rectPath(attr.x || 0, attr.y || 0, attr.width, attr.height);\n        },\n        line: function (el) {\n            return \"M\" + [el.attr(\"x1\") || 0, el.attr(\"y1\") || 0, el.attr(\"x2\"), el.attr(\"y2\")];\n        },\n        polyline: function (el) {\n            return \"M\" + el.attr(\"points\");\n        },\n        polygon: function (el) {\n            return \"M\" + el.attr(\"points\") + \"z\";\n        },\n        deflt: function (el) {\n            var bbox = el.node.getBBox();\n            return rectPath(bbox.x, bbox.y, bbox.width, bbox.height);\n        }\n    };\n    function pathToRelative(pathArray) {\n        var pth = paths(pathArray),\n            lowerCase = String.prototype.toLowerCase;\n        if (pth.rel) {\n            return pathClone(pth.rel);\n        }\n        if (!Snap.is(pathArray, \"array\") || !Snap.is(pathArray && pathArray[0], \"array\")) {\n            pathArray = Snap.parsePathString(pathArray);\n        }\n        var res = [],\n            x = 0,\n            y = 0,\n            mx = 0,\n            my = 0,\n            start = 0;\n        if (pathArray[0][0] == \"M\") {\n            x = pathArray[0][1];\n            y = pathArray[0][2];\n            mx = x;\n            my = y;\n            start++;\n            res.push([\"M\", x, y]);\n        }\n        for (var i = start, ii = pathArray.length; i < ii; i++) {\n            var r = res[i] = [],\n                pa = pathArray[i];\n            if (pa[0] != lowerCase.call(pa[0])) {\n                r[0] = lowerCase.call(pa[0]);\n                switch (r[0]) {\n                    case \"a\":\n                        r[1] = pa[1];\n                        r[2] = pa[2];\n                        r[3] = pa[3];\n                        r[4] = pa[4];\n                        r[5] = pa[5];\n                        r[6] = +(pa[6] - x).toFixed(3);\n                        r[7] = +(pa[7] - y).toFixed(3);\n                        break;\n                    case \"v\":\n                        r[1] = +(pa[1] - y).toFixed(3);\n                        break;\n                    case \"m\":\n                        mx = pa[1];\n                        my = pa[2];\n                    default:\n                        for (var j = 1, jj = pa.length; j < jj; j++) {\n                            r[j] = +(pa[j] - ((j % 2) ? x : y)).toFixed(3);\n                        }\n                }\n            } else {\n                r = res[i] = [];\n                if (pa[0] == \"m\") {\n                    mx = pa[1] + x;\n                    my = pa[2] + y;\n                }\n                for (var k = 0, kk = pa.length; k < kk; k++) {\n                    res[i][k] = pa[k];\n                }\n            }\n            var len = res[i].length;\n            switch (res[i][0]) {\n                case \"z\":\n                    x = mx;\n                    y = my;\n                    break;\n                case \"h\":\n                    x += +res[i][len - 1];\n                    break;\n                case \"v\":\n                    y += +res[i][len - 1];\n                    break;\n                default:\n                    x += +res[i][len - 2];\n                    y += +res[i][len - 1];\n            }\n        }\n        res.toString = toString;\n        pth.rel = pathClone(res);\n        return res;\n    }\n    function pathToAbsolute(pathArray) {\n        var pth = paths(pathArray);\n        if (pth.abs) {\n            return pathClone(pth.abs);\n        }\n        if (!is(pathArray, \"array\") || !is(pathArray && pathArray[0], \"array\")) { // rough assumption\n            pathArray = Snap.parsePathString(pathArray);\n        }\n        if (!pathArray || !pathArray.length) {\n            return [[\"M\", 0, 0]];\n        }\n        var res = [],\n            x = 0,\n            y = 0,\n            mx = 0,\n            my = 0,\n            start = 0,\n            pa0;\n        if (pathArray[0][0] == \"M\") {\n            x = +pathArray[0][1];\n            y = +pathArray[0][2];\n            mx = x;\n            my = y;\n            start++;\n            res[0] = [\"M\", x, y];\n        }\n        var crz = pathArray.length == 3 &&\n            pathArray[0][0] == \"M\" &&\n            pathArray[1][0].toUpperCase() == \"R\" &&\n            pathArray[2][0].toUpperCase() == \"Z\";\n        for (var r, pa, i = start, ii = pathArray.length; i < ii; i++) {\n            res.push(r = []);\n            pa = pathArray[i];\n            pa0 = pa[0];\n            if (pa0 != pa0.toUpperCase()) {\n                r[0] = pa0.toUpperCase();\n                switch (r[0]) {\n                    case \"A\":\n                        r[1] = pa[1];\n                        r[2] = pa[2];\n                        r[3] = pa[3];\n                        r[4] = pa[4];\n                        r[5] = pa[5];\n                        r[6] = +pa[6] + x;\n                        r[7] = +pa[7] + y;\n                        break;\n                    case \"V\":\n                        r[1] = +pa[1] + y;\n                        break;\n                    case \"H\":\n                        r[1] = +pa[1] + x;\n                        break;\n                    case \"R\":\n                        var dots = [x, y].concat(pa.slice(1));\n                        for (var j = 2, jj = dots.length; j < jj; j++) {\n                            dots[j] = +dots[j] + x;\n                            dots[++j] = +dots[j] + y;\n                        }\n                        res.pop();\n                        res = res.concat(catmullRom2bezier(dots, crz));\n                        break;\n                    case \"O\":\n                        res.pop();\n                        dots = ellipsePath(x, y, pa[1], pa[2]);\n                        dots.push(dots[0]);\n                        res = res.concat(dots);\n                        break;\n                    case \"U\":\n                        res.pop();\n                        res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));\n                        r = [\"U\"].concat(res[res.length - 1].slice(-2));\n                        break;\n                    case \"M\":\n                        mx = +pa[1] + x;\n                        my = +pa[2] + y;\n                    default:\n                        for (j = 1, jj = pa.length; j < jj; j++) {\n                            r[j] = +pa[j] + ((j % 2) ? x : y);\n                        }\n                }\n            } else if (pa0 == \"R\") {\n                dots = [x, y].concat(pa.slice(1));\n                res.pop();\n                res = res.concat(catmullRom2bezier(dots, crz));\n                r = [\"R\"].concat(pa.slice(-2));\n            } else if (pa0 == \"O\") {\n                res.pop();\n                dots = ellipsePath(x, y, pa[1], pa[2]);\n                dots.push(dots[0]);\n                res = res.concat(dots);\n            } else if (pa0 == \"U\") {\n                res.pop();\n                res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));\n                r = [\"U\"].concat(res[res.length - 1].slice(-2));\n            } else {\n                for (var k = 0, kk = pa.length; k < kk; k++) {\n                    r[k] = pa[k];\n                }\n            }\n            pa0 = pa0.toUpperCase();\n            if (pa0 != \"O\") {\n                switch (r[0]) {\n                    case \"Z\":\n                        x = +mx;\n                        y = +my;\n                        break;\n                    case \"H\":\n                        x = r[1];\n                        break;\n                    case \"V\":\n                        y = r[1];\n                        break;\n                    case \"M\":\n                        mx = r[r.length - 2];\n                        my = r[r.length - 1];\n                    default:\n                        x = r[r.length - 2];\n                        y = r[r.length - 1];\n                }\n            }\n        }\n        res.toString = toString;\n        pth.abs = pathClone(res);\n        return res;\n    }\n    function l2c(x1, y1, x2, y2) {\n        return [x1, y1, x2, y2, x2, y2];\n    }\n    function q2c(x1, y1, ax, ay, x2, y2) {\n        var _13 = 1 / 3,\n            _23 = 2 / 3;\n        return [\n                _13 * x1 + _23 * ax,\n                _13 * y1 + _23 * ay,\n                _13 * x2 + _23 * ax,\n                _13 * y2 + _23 * ay,\n                x2,\n                y2\n            ];\n    }\n    function a2c(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {\n        // for more information of where this math came from visit:\n        // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n        var _120 = PI * 120 / 180,\n            rad = PI / 180 * (+angle || 0),\n            res = [],\n            xy,\n            rotate = Snap._.cacher(function (x, y, rad) {\n                var X = x * math.cos(rad) - y * math.sin(rad),\n                    Y = x * math.sin(rad) + y * math.cos(rad);\n                return {x: X, y: Y};\n            });\n        if (!recursive) {\n            xy = rotate(x1, y1, -rad);\n            x1 = xy.x;\n            y1 = xy.y;\n            xy = rotate(x2, y2, -rad);\n            x2 = xy.x;\n            y2 = xy.y;\n            var cos = math.cos(PI / 180 * angle),\n                sin = math.sin(PI / 180 * angle),\n                x = (x1 - x2) / 2,\n                y = (y1 - y2) / 2;\n            var h = (x * x) / (rx * rx) + (y * y) / (ry * ry);\n            if (h > 1) {\n                h = math.sqrt(h);\n                rx = h * rx;\n                ry = h * ry;\n            }\n            var rx2 = rx * rx,\n                ry2 = ry * ry,\n                k = (large_arc_flag == sweep_flag ? -1 : 1) *\n                    math.sqrt(abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x))),\n                cx = k * rx * y / ry + (x1 + x2) / 2,\n                cy = k * -ry * x / rx + (y1 + y2) / 2,\n                f1 = math.asin(((y1 - cy) / ry).toFixed(9)),\n                f2 = math.asin(((y2 - cy) / ry).toFixed(9));\n\n            f1 = x1 < cx ? PI - f1 : f1;\n            f2 = x2 < cx ? PI - f2 : f2;\n            f1 < 0 && (f1 = PI * 2 + f1);\n            f2 < 0 && (f2 = PI * 2 + f2);\n            if (sweep_flag && f1 > f2) {\n                f1 = f1 - PI * 2;\n            }\n            if (!sweep_flag && f2 > f1) {\n                f2 = f2 - PI * 2;\n            }\n        } else {\n            f1 = recursive[0];\n            f2 = recursive[1];\n            cx = recursive[2];\n            cy = recursive[3];\n        }\n        var df = f2 - f1;\n        if (abs(df) > _120) {\n            var f2old = f2,\n                x2old = x2,\n                y2old = y2;\n            f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);\n            x2 = cx + rx * math.cos(f2);\n            y2 = cy + ry * math.sin(f2);\n            res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);\n        }\n        df = f2 - f1;\n        var c1 = math.cos(f1),\n            s1 = math.sin(f1),\n            c2 = math.cos(f2),\n            s2 = math.sin(f2),\n            t = math.tan(df / 4),\n            hx = 4 / 3 * rx * t,\n            hy = 4 / 3 * ry * t,\n            m1 = [x1, y1],\n            m2 = [x1 + hx * s1, y1 - hy * c1],\n            m3 = [x2 + hx * s2, y2 - hy * c2],\n            m4 = [x2, y2];\n        m2[0] = 2 * m1[0] - m2[0];\n        m2[1] = 2 * m1[1] - m2[1];\n        if (recursive) {\n            return [m2, m3, m4].concat(res);\n        } else {\n            res = [m2, m3, m4].concat(res).join().split(\",\");\n            var newres = [];\n            for (var i = 0, ii = res.length; i < ii; i++) {\n                newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;\n            }\n            return newres;\n        }\n    }\n    function findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {\n        var t1 = 1 - t;\n        return {\n            x: pow(t1, 3) * p1x + pow(t1, 2) * 3 * t * c1x + t1 * 3 * t * t * c2x + pow(t, 3) * p2x,\n            y: pow(t1, 3) * p1y + pow(t1, 2) * 3 * t * c1y + t1 * 3 * t * t * c2y + pow(t, 3) * p2y\n        };\n    }\n\n    // Returns bounding box of cubic bezier curve.\n    // Source: http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html\n    // Original version: NISHIO Hirokazu\n    // Modifications: https://github.com/timo22345\n    function curveDim(x0, y0, x1, y1, x2, y2, x3, y3) {\n        var tvalues = [],\n            bounds = [[], []],\n            a, b, c, t, t1, t2, b2ac, sqrtb2ac;\n        for (var i = 0; i < 2; ++i) {\n            if (i == 0) {\n                b = 6 * x0 - 12 * x1 + 6 * x2;\n                a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;\n                c = 3 * x1 - 3 * x0;\n            } else {\n                b = 6 * y0 - 12 * y1 + 6 * y2;\n                a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;\n                c = 3 * y1 - 3 * y0;\n            }\n            if (abs(a) < 1e-12) {\n                if (abs(b) < 1e-12) {\n                    continue;\n                }\n                t = -c / b;\n                if (0 < t && t < 1) {\n                    tvalues.push(t);\n                }\n                continue;\n            }\n            b2ac = b * b - 4 * c * a;\n            sqrtb2ac = math.sqrt(b2ac);\n            if (b2ac < 0) {\n                continue;\n            }\n            t1 = (-b + sqrtb2ac) / (2 * a);\n            if (0 < t1 && t1 < 1) {\n                tvalues.push(t1);\n            }\n            t2 = (-b - sqrtb2ac) / (2 * a);\n            if (0 < t2 && t2 < 1) {\n                tvalues.push(t2);\n            }\n        }\n\n        var x, y, j = tvalues.length,\n            jlen = j,\n            mt;\n        while (j--) {\n            t = tvalues[j];\n            mt = 1 - t;\n            bounds[0][j] = (mt * mt * mt * x0) + (3 * mt * mt * t * x1) + (3 * mt * t * t * x2) + (t * t * t * x3);\n            bounds[1][j] = (mt * mt * mt * y0) + (3 * mt * mt * t * y1) + (3 * mt * t * t * y2) + (t * t * t * y3);\n        }\n\n        bounds[0][jlen] = x0;\n        bounds[1][jlen] = y0;\n        bounds[0][jlen + 1] = x3;\n        bounds[1][jlen + 1] = y3;\n        bounds[0].length = bounds[1].length = jlen + 2;\n\n\n        return {\n          min: {x: mmin.apply(0, bounds[0]), y: mmin.apply(0, bounds[1])},\n          max: {x: mmax.apply(0, bounds[0]), y: mmax.apply(0, bounds[1])}\n        };\n    }\n\n    function path2curve(path, path2) {\n        var pth = !path2 && paths(path);\n        if (!path2 && pth.curve) {\n            return pathClone(pth.curve);\n        }\n        var p = pathToAbsolute(path),\n            p2 = path2 && pathToAbsolute(path2),\n            attrs = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null},\n            attrs2 = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null},\n            processPath = function (path, d, pcom) {\n                var nx, ny;\n                if (!path) {\n                    return [\"C\", d.x, d.y, d.x, d.y, d.x, d.y];\n                }\n                !(path[0] in {T: 1, Q: 1}) && (d.qx = d.qy = null);\n                switch (path[0]) {\n                    case \"M\":\n                        d.X = path[1];\n                        d.Y = path[2];\n                        break;\n                    case \"A\":\n                        path = [\"C\"].concat(a2c.apply(0, [d.x, d.y].concat(path.slice(1))));\n                        break;\n                    case \"S\":\n                        if (pcom == \"C\" || pcom == \"S\") { // In \"S\" case we have to take into account, if the previous command is C/S.\n                            nx = d.x * 2 - d.bx;          // And reflect the previous\n                            ny = d.y * 2 - d.by;          // command's control point relative to the current point.\n                        }\n                        else {                            // or some else or nothing\n                            nx = d.x;\n                            ny = d.y;\n                        }\n                        path = [\"C\", nx, ny].concat(path.slice(1));\n                        break;\n                    case \"T\":\n                        if (pcom == \"Q\" || pcom == \"T\") { // In \"T\" case we have to take into account, if the previous command is Q/T.\n                            d.qx = d.x * 2 - d.qx;        // And make a reflection similar\n                            d.qy = d.y * 2 - d.qy;        // to case \"S\".\n                        }\n                        else {                            // or something else or nothing\n                            d.qx = d.x;\n                            d.qy = d.y;\n                        }\n                        path = [\"C\"].concat(q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));\n                        break;\n                    case \"Q\":\n                        d.qx = path[1];\n                        d.qy = path[2];\n                        path = [\"C\"].concat(q2c(d.x, d.y, path[1], path[2], path[3], path[4]));\n                        break;\n                    case \"L\":\n                        path = [\"C\"].concat(l2c(d.x, d.y, path[1], path[2]));\n                        break;\n                    case \"H\":\n                        path = [\"C\"].concat(l2c(d.x, d.y, path[1], d.y));\n                        break;\n                    case \"V\":\n                        path = [\"C\"].concat(l2c(d.x, d.y, d.x, path[1]));\n                        break;\n                    case \"Z\":\n                        path = [\"C\"].concat(l2c(d.x, d.y, d.X, d.Y));\n                        break;\n                }\n                return path;\n            },\n            fixArc = function (pp, i) {\n                if (pp[i].length > 7) {\n                    pp[i].shift();\n                    var pi = pp[i];\n                    while (pi.length) {\n                        pcoms1[i] = \"A\"; // if created multiple C:s, their original seg is saved\n                        p2 && (pcoms2[i] = \"A\"); // the same as above\n                        pp.splice(i++, 0, [\"C\"].concat(pi.splice(0, 6)));\n                    }\n                    pp.splice(i, 1);\n                    ii = mmax(p.length, p2 && p2.length || 0);\n                }\n            },\n            fixM = function (path1, path2, a1, a2, i) {\n                if (path1 && path2 && path1[i][0] == \"M\" && path2[i][0] != \"M\") {\n                    path2.splice(i, 0, [\"M\", a2.x, a2.y]);\n                    a1.bx = 0;\n                    a1.by = 0;\n                    a1.x = path1[i][1];\n                    a1.y = path1[i][2];\n                    ii = mmax(p.length, p2 && p2.length || 0);\n                }\n            },\n            pcoms1 = [], // path commands of original path p\n            pcoms2 = [], // path commands of original path p2\n            pfirst = \"\", // temporary holder for original path command\n            pcom = \"\"; // holder for previous path command of original path\n        for (var i = 0, ii = mmax(p.length, p2 && p2.length || 0); i < ii; i++) {\n            p[i] && (pfirst = p[i][0]); // save current path command\n\n            if (pfirst != \"C\") // C is not saved yet, because it may be result of conversion\n            {\n                pcoms1[i] = pfirst; // Save current path command\n                i && ( pcom = pcoms1[i - 1]); // Get previous path command pcom\n            }\n            p[i] = processPath(p[i], attrs, pcom); // Previous path command is inputted to processPath\n\n            if (pcoms1[i] != \"A\" && pfirst == \"C\") pcoms1[i] = \"C\"; // A is the only command\n            // which may produce multiple C:s\n            // so we have to make sure that C is also C in original path\n\n            fixArc(p, i); // fixArc adds also the right amount of A:s to pcoms1\n\n            if (p2) { // the same procedures is done to p2\n                p2[i] && (pfirst = p2[i][0]);\n                if (pfirst != \"C\") {\n                    pcoms2[i] = pfirst;\n                    i && (pcom = pcoms2[i - 1]);\n                }\n                p2[i] = processPath(p2[i], attrs2, pcom);\n\n                if (pcoms2[i] != \"A\" && pfirst == \"C\") {\n                    pcoms2[i] = \"C\";\n                }\n\n                fixArc(p2, i);\n            }\n            fixM(p, p2, attrs, attrs2, i);\n            fixM(p2, p, attrs2, attrs, i);\n            var seg = p[i],\n                seg2 = p2 && p2[i],\n                seglen = seg.length,\n                seg2len = p2 && seg2.length;\n            attrs.x = seg[seglen - 2];\n            attrs.y = seg[seglen - 1];\n            attrs.bx = toFloat(seg[seglen - 4]) || attrs.x;\n            attrs.by = toFloat(seg[seglen - 3]) || attrs.y;\n            attrs2.bx = p2 && (toFloat(seg2[seg2len - 4]) || attrs2.x);\n            attrs2.by = p2 && (toFloat(seg2[seg2len - 3]) || attrs2.y);\n            attrs2.x = p2 && seg2[seg2len - 2];\n            attrs2.y = p2 && seg2[seg2len - 1];\n        }\n        if (!p2) {\n            pth.curve = pathClone(p);\n        }\n        return p2 ? [p, p2] : p;\n    }\n    function mapPath(path, matrix) {\n        if (!matrix) {\n            return path;\n        }\n        var x, y, i, j, ii, jj, pathi;\n        path = path2curve(path);\n        for (i = 0, ii = path.length; i < ii; i++) {\n            pathi = path[i];\n            for (j = 1, jj = pathi.length; j < jj; j += 2) {\n                x = matrix.x(pathi[j], pathi[j + 1]);\n                y = matrix.y(pathi[j], pathi[j + 1]);\n                pathi[j] = x;\n                pathi[j + 1] = y;\n            }\n        }\n        return path;\n    }\n\n    // http://schepers.cc/getting-to-the-point\n    function catmullRom2bezier(crp, z) {\n        var d = [];\n        for (var i = 0, iLen = crp.length; iLen - 2 * !z > i; i += 2) {\n            var p = [\n                        {x: +crp[i - 2], y: +crp[i - 1]},\n                        {x: +crp[i],     y: +crp[i + 1]},\n                        {x: +crp[i + 2], y: +crp[i + 3]},\n                        {x: +crp[i + 4], y: +crp[i + 5]}\n                    ];\n            if (z) {\n                if (!i) {\n                    p[0] = {x: +crp[iLen - 2], y: +crp[iLen - 1]};\n                } else if (iLen - 4 == i) {\n                    p[3] = {x: +crp[0], y: +crp[1]};\n                } else if (iLen - 2 == i) {\n                    p[2] = {x: +crp[0], y: +crp[1]};\n                    p[3] = {x: +crp[2], y: +crp[3]};\n                }\n            } else {\n                if (iLen - 4 == i) {\n                    p[3] = p[2];\n                } else if (!i) {\n                    p[0] = {x: +crp[i], y: +crp[i + 1]};\n                }\n            }\n            d.push([\"C\",\n                  (-p[0].x + 6 * p[1].x + p[2].x) / 6,\n                  (-p[0].y + 6 * p[1].y + p[2].y) / 6,\n                  (p[1].x + 6 * p[2].x - p[3].x) / 6,\n                  (p[1].y + 6*p[2].y - p[3].y) / 6,\n                  p[2].x,\n                  p[2].y\n            ]);\n        }\n\n        return d;\n    }\n\n    // export\n    Snap.path = paths;\n\n    /*\\\n     * Snap.path.getTotalLength\n     [ method ]\n     **\n     * Returns the length of the given path in pixels\n     **\n     - path (string) SVG path string\n     **\n     = (number) length\n    \\*/\n    Snap.path.getTotalLength = getTotalLength;\n    /*\\\n     * Snap.path.getPointAtLength\n     [ method ]\n     **\n     * Returns the coordinates of the point located at the given length along the given path\n     **\n     - path (string) SVG path string\n     - length (number) length, in pixels, from the start of the path, excluding non-rendering jumps\n     **\n     = (object) representation of the point:\n     o {\n     o     x: (number) x coordinate,\n     o     y: (number) y coordinate,\n     o     alpha: (number) angle of derivative\n     o }\n    \\*/\n    Snap.path.getPointAtLength = getPointAtLength;\n    /*\\\n     * Snap.path.getSubpath\n     [ method ]\n     **\n     * Returns the subpath of a given path between given start and end lengths\n     **\n     - path (string) SVG path string\n     - from (number) length, in pixels, from the start of the path to the start of the segment\n     - to (number) length, in pixels, from the start of the path to the end of the segment\n     **\n     = (string) path string definition for the segment\n    \\*/\n    Snap.path.getSubpath = function (path, from, to) {\n        if (this.getTotalLength(path) - to < 1e-6) {\n            return getSubpathsAtLength(path, from).end;\n        }\n        var a = getSubpathsAtLength(path, to, 1);\n        return from ? getSubpathsAtLength(a, from).end : a;\n    };\n    /*\\\n     * Element.getTotalLength\n     [ method ]\n     **\n     * Returns the length of the path in pixels (only works for `path` elements)\n     = (number) length\n    \\*/\n    elproto.getTotalLength = function () {\n        if (this.node.getTotalLength) {\n            return this.node.getTotalLength();\n        }\n    };\n    // SIERRA Element.getPointAtLength()/Element.getTotalLength(): If a <path> is broken into different segments, is the jump distance to the new coordinates set by the _M_ or _m_ commands calculated as part of the path's total length?\n    /*\\\n     * Element.getPointAtLength\n     [ method ]\n     **\n     * Returns coordinates of the point located at the given length on the given path (only works for `path` elements)\n     **\n     - length (number) length, in pixels, from the start of the path, excluding non-rendering jumps\n     **\n     = (object) representation of the point:\n     o {\n     o     x: (number) x coordinate,\n     o     y: (number) y coordinate,\n     o     alpha: (number) angle of derivative\n     o }\n    \\*/\n    elproto.getPointAtLength = function (length) {\n        return getPointAtLength(this.attr(\"d\"), length);\n    };\n    // SIERRA Element.getSubpath(): Similar to the problem for Element.getPointAtLength(). Unclear how this would work for a segmented path. Overall, the concept of _subpath_ and what I'm calling a _segment_ (series of non-_M_ or _Z_ commands) is unclear.\n    /*\\\n     * Element.getSubpath\n     [ method ]\n     **\n     * Returns subpath of a given element from given start and end lengths (only works for `path` elements)\n     **\n     - from (number) length, in pixels, from the start of the path to the start of the segment\n     - to (number) length, in pixels, from the start of the path to the end of the segment\n     **\n     = (string) path string definition for the segment\n    \\*/\n    elproto.getSubpath = function (from, to) {\n        return Snap.path.getSubpath(this.attr(\"d\"), from, to);\n    };\n    Snap._.box = box;\n    /*\\\n     * Snap.path.findDotsAtSegment\n     [ method ]\n     **\n     * Utility method\n     **\n     * Finds dot coordinates on the given cubic bezir curve at the given t\n     - p1x (number) x of the first point of the curve\n     - p1y (number) y of the first point of the curve\n     - c1x (number) x of the first anchor of the curve\n     - c1y (number) y of the first anchor of the curve\n     - c2x (number) x of the second anchor of the curve\n     - c2y (number) y of the second anchor of the curve\n     - p2x (number) x of the second point of the curve\n     - p2y (number) y of the second point of the curve\n     - t (number) position on the curve (0..1)\n     = (object) point information in format:\n     o {\n     o     x: (number) x coordinate of the point,\n     o     y: (number) y coordinate of the point,\n     o     m: {\n     o         x: (number) x coordinate of the left anchor,\n     o         y: (number) y coordinate of the left anchor\n     o     },\n     o     n: {\n     o         x: (number) x coordinate of the right anchor,\n     o         y: (number) y coordinate of the right anchor\n     o     },\n     o     start: {\n     o         x: (number) x coordinate of the start of the curve,\n     o         y: (number) y coordinate of the start of the curve\n     o     },\n     o     end: {\n     o         x: (number) x coordinate of the end of the curve,\n     o         y: (number) y coordinate of the end of the curve\n     o     },\n     o     alpha: (number) angle of the curve derivative at the point\n     o }\n    \\*/\n    Snap.path.findDotsAtSegment = findDotsAtSegment;\n    /*\\\n     * Snap.path.bezierBBox\n     [ method ]\n     **\n     * Utility method\n     **\n     * Returns the bounding box of a given cubic bezir curve\n     - p1x (number) x of the first point of the curve\n     - p1y (number) y of the first point of the curve\n     - c1x (number) x of the first anchor of the curve\n     - c1y (number) y of the first anchor of the curve\n     - c2x (number) x of the second anchor of the curve\n     - c2y (number) y of the second anchor of the curve\n     - p2x (number) x of the second point of the curve\n     - p2y (number) y of the second point of the curve\n     * or\n     - bez (array) array of six points for bezir curve\n     = (object) bounding box\n     o {\n     o     x: (number) x coordinate of the left top point of the box,\n     o     y: (number) y coordinate of the left top point of the box,\n     o     x2: (number) x coordinate of the right bottom point of the box,\n     o     y2: (number) y coordinate of the right bottom point of the box,\n     o     width: (number) width of the box,\n     o     height: (number) height of the box\n     o }\n    \\*/\n    Snap.path.bezierBBox = bezierBBox;\n    /*\\\n     * Snap.path.isPointInsideBBox\n     [ method ]\n     **\n     * Utility method\n     **\n     * Returns `true` if given point is inside bounding box\n     - bbox (string) bounding box\n     - x (string) x coordinate of the point\n     - y (string) y coordinate of the point\n     = (boolean) `true` if point is inside\n    \\*/\n    Snap.path.isPointInsideBBox = isPointInsideBBox;\n    Snap.closest = function (x, y, X, Y) {\n        var r = 100,\n            b = box(x - r / 2, y - r / 2, r, r),\n            inside = [],\n            getter = X[0].hasOwnProperty(\"x\") ? function (i) {\n                return {\n                    x: X[i].x,\n                    y: X[i].y\n                };\n            } : function (i) {\n                return {\n                    x: X[i],\n                    y: Y[i]\n                };\n            },\n            found = 0;\n        while (r <= 1e6 && !found) {\n            for (var i = 0, ii = X.length; i < ii; i++) {\n                var xy = getter(i);\n                if (isPointInsideBBox(b, xy.x, xy.y)) {\n                    found++;\n                    inside.push(xy);\n                    break;\n                }\n            }\n            if (!found) {\n                r *= 2;\n                b = box(x - r / 2, y - r / 2, r, r)\n            }\n        }\n        if (r == 1e6) {\n            return;\n        }\n        var len = Infinity,\n            res;\n        for (i = 0, ii = inside.length; i < ii; i++) {\n            var l = Snap.len(x, y, inside[i].x, inside[i].y);\n            if (len > l) {\n                len = l;\n                inside[i].len = l;\n                res = inside[i];\n            }\n        }\n        return res;\n    };\n    /*\\\n     * Snap.path.isBBoxIntersect\n     [ method ]\n     **\n     * Utility method\n     **\n     * Returns `true` if two bounding boxes intersect\n     - bbox1 (string) first bounding box\n     - bbox2 (string) second bounding box\n     = (boolean) `true` if bounding boxes intersect\n    \\*/\n    Snap.path.isBBoxIntersect = isBBoxIntersect;\n    /*\\\n     * Snap.path.intersection\n     [ method ]\n     **\n     * Utility method\n     **\n     * Finds intersections of two paths\n     - path1 (string) path string\n     - path2 (string) path string\n     = (array) dots of intersection\n     o [\n     o     {\n     o         x: (number) x coordinate of the point,\n     o         y: (number) y coordinate of the point,\n     o         t1: (number) t value for segment of path1,\n     o         t2: (number) t value for segment of path2,\n     o         segment1: (number) order number for segment of path1,\n     o         segment2: (number) order number for segment of path2,\n     o         bez1: (array) eight coordinates representing bezir curve for the segment of path1,\n     o         bez2: (array) eight coordinates representing bezir curve for the segment of path2\n     o     }\n     o ]\n    \\*/\n    Snap.path.intersection = pathIntersection;\n    Snap.path.intersectionNumber = pathIntersectionNumber;\n    /*\\\n     * Snap.path.isPointInside\n     [ method ]\n     **\n     * Utility method\n     **\n     * Returns `true` if given point is inside a given closed path.\n     *\n     * Note: fill mode doesnt affect the result of this method.\n     - path (string) path string\n     - x (number) x of the point\n     - y (number) y of the point\n     = (boolean) `true` if point is inside the path\n    \\*/\n    Snap.path.isPointInside = isPointInsidePath;\n    /*\\\n     * Snap.path.getBBox\n     [ method ]\n     **\n     * Utility method\n     **\n     * Returns the bounding box of a given path\n     - path (string) path string\n     = (object) bounding box\n     o {\n     o     x: (number) x coordinate of the left top point of the box,\n     o     y: (number) y coordinate of the left top point of the box,\n     o     x2: (number) x coordinate of the right bottom point of the box,\n     o     y2: (number) y coordinate of the right bottom point of the box,\n     o     width: (number) width of the box,\n     o     height: (number) height of the box\n     o }\n    \\*/\n    Snap.path.getBBox = pathBBox;\n    Snap.path.get = getPath;\n    /*\\\n     * Snap.path.toRelative\n     [ method ]\n     **\n     * Utility method\n     **\n     * Converts path coordinates into relative values\n     - path (string) path string\n     = (array) path string\n    \\*/\n    Snap.path.toRelative = pathToRelative;\n    /*\\\n     * Snap.path.toAbsolute\n     [ method ]\n     **\n     * Utility method\n     **\n     * Converts path coordinates into absolute values\n     - path (string) path string\n     = (array) path string\n    \\*/\n    Snap.path.toAbsolute = pathToAbsolute;\n    /*\\\n     * Snap.path.toCubic\n     [ method ]\n     **\n     * Utility method\n     **\n     * Converts path to a new path where all segments are cubic bezir curves\n     - pathString (string|array) path string or array of segments\n     = (array) array of segments\n    \\*/\n    Snap.path.toCubic = path2curve;\n    /*\\\n     * Snap.path.map\n     [ method ]\n     **\n     * Transform the path string with the given matrix\n     - path (string) path string\n     - matrix (object) see @Matrix\n     = (string) transformed path string\n    \\*/\n    Snap.path.map = mapPath;\n    Snap.path.toString = toString;\n    Snap.path.clone = pathClone;\n});\n\n// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nSnap.plugin(function (Snap, Element, Paper, glob) {\n    var mmax = Math.max,\n        mmin = Math.min;\n\n    // Set\n    var Set = function (items) {\n        this.items = [];\n\tthis.bindings = {};\n        this.length = 0;\n        this.type = \"set\";\n        if (items) {\n            for (var i = 0, ii = items.length; i < ii; i++) {\n                if (items[i]) {\n                    this[this.items.length] = this.items[this.items.length] = items[i];\n                    this.length++;\n                }\n            }\n        }\n    },\n    setproto = Set.prototype;\n    /*\\\n     * Set.push\n     [ method ]\n     **\n     * Adds each argument to the current set\n     = (object) original element\n    \\*/\n    setproto.push = function () {\n        var item,\n            len;\n        for (var i = 0, ii = arguments.length; i < ii; i++) {\n            item = arguments[i];\n            if (item) {\n                len = this.items.length;\n                this[len] = this.items[len] = item;\n                this.length++;\n            }\n        }\n        return this;\n    };\n    /*\\\n     * Set.pop\n     [ method ]\n     **\n     * Removes last element and returns it\n     = (object) element\n    \\*/\n    setproto.pop = function () {\n        this.length && delete this[this.length--];\n        return this.items.pop();\n    };\n    /*\\\n     * Set.forEach\n     [ method ]\n     **\n     * Executes given function for each element in the set\n     *\n     * If the function returns `false`, the loop stops running.\n     **\n     - callback (function) function to run\n     - thisArg (object) context object for the callback\n     = (object) Set object\n    \\*/\n    setproto.forEach = function (callback, thisArg) {\n        for (var i = 0, ii = this.items.length; i < ii; i++) {\n            if (callback.call(thisArg, this.items[i], i) === false) {\n                return this;\n            }\n        }\n        return this;\n    };\n    /*\\\n     * Set.animate\n     [ method ]\n     **\n     * Animates each element in set in sync.\n     *\n     **\n     - attrs (object) key-value pairs of destination attributes\n     - duration (number) duration of the animation in milliseconds\n     - easing (function) #optional easing function from @mina or custom\n     - callback (function) #optional callback function that executes when the animation ends\n     * or\n     - animation (array) array of animation parameter for each element in set in format `[attrs, duration, easing, callback]`\n     > Usage\n     | // animate all elements in set to radius 10\n     | set.animate({r: 10}, 500, mina.easein);\n     | // or\n     | // animate first element to radius 10, but second to radius 20 and in different time\n     | set.animate([{r: 10}, 500, mina.easein], [{r: 20}, 1500, mina.easein]);\n     = (Element) the current element\n    \\*/\n    setproto.animate = function (attrs, ms, easing, callback) {\n        if (typeof easing == \"function\" && !easing.length) {\n            callback = easing;\n            easing = mina.linear;\n        }\n        if (attrs instanceof Snap._.Animation) {\n            callback = attrs.callback;\n            easing = attrs.easing;\n            ms = easing.dur;\n            attrs = attrs.attr;\n        }\n        var args = arguments;\n        if (Snap.is(attrs, \"array\") && Snap.is(args[args.length - 1], \"array\")) {\n            var each = true;\n        }\n        var begin,\n            handler = function () {\n                if (begin) {\n                    this.b = begin;\n                } else {\n                    begin = this.b;\n                }\n            },\n            cb = 0,\n            set = this,\n            callbacker = callback && function () {\n                if (++cb == set.length) {\n                    callback.call(this);\n                }\n            };\n        return this.forEach(function (el, i) {\n            eve.once(\"snap.animcreated.\" + el.id, handler);\n            if (each) {\n                args[i] && el.animate.apply(el, args[i]);\n            } else {\n                el.animate(attrs, ms, easing, callbacker);\n            }\n        });\n    };\n    setproto.remove = function () {\n        while (this.length) {\n            this.pop().remove();\n        }\n        return this;\n    };\n    /*\\\n     * Set.bind\n     [ method ]\n     **\n     * Specifies how to handle a specific attribute when applied\n     * to a set.\n     *\n     **\n     - attr (string) attribute name\n     - callback (function) function to run\n     * or\n     - attr (string) attribute name\n     - element (Element) specific element in the set to apply the attribute to\n     * or\n     - attr (string) attribute name\n     - element (Element) specific element in the set to apply the attribute to\n     - eattr (string) attribute on the element to bind the attribute to\n     = (object) Set object\n    \\*/\n    setproto.bind = function (attr, a, b) {\n        var data = {};\n        if (typeof a == \"function\") {\n            this.bindings[attr] = a;\n        } else {\n            var aname = b || attr;\n            this.bindings[attr] = function (v) {\n                data[aname] = v;\n                a.attr(data);\n            };\n        }\n        return this;\n    };\n    setproto.attr = function (value) {\n        var unbound = {};\n        for (var k in value) {\n            if (this.bindings[k]) {\n                this.bindings[k](value[k]);\n            } else {\n                unbound[k] = value[k];\n            }\n        }\n        for (var i = 0, ii = this.items.length; i < ii; i++) {\n            this.items[i].attr(unbound);\n        }\n        return this;\n    };\n    /*\\\n     * Set.clear\n     [ method ]\n     **\n     * Removes all elements from the set\n    \\*/\n    setproto.clear = function () {\n        while (this.length) {\n            this.pop();\n        }\n    };\n    /*\\\n     * Set.splice\n     [ method ]\n     **\n     * Removes range of elements from the set\n     **\n     - index (number) position of the deletion\n     - count (number) number of element to remove\n     - insertion (object) #optional elements to insert\n     = (object) set elements that were deleted\n    \\*/\n    setproto.splice = function (index, count, insertion) {\n        index = index < 0 ? mmax(this.length + index, 0) : index;\n        count = mmax(0, mmin(this.length - index, count));\n        var tail = [],\n            todel = [],\n            args = [],\n            i;\n        for (i = 2; i < arguments.length; i++) {\n            args.push(arguments[i]);\n        }\n        for (i = 0; i < count; i++) {\n            todel.push(this[index + i]);\n        }\n        for (; i < this.length - index; i++) {\n            tail.push(this[index + i]);\n        }\n        var arglen = args.length;\n        for (i = 0; i < arglen + tail.length; i++) {\n            this.items[index + i] = this[index + i] = i < arglen ? args[i] : tail[i - arglen];\n        }\n        i = this.items.length = this.length -= count - arglen;\n        while (this[i]) {\n            delete this[i++];\n        }\n        return new Set(todel);\n    };\n    /*\\\n     * Set.exclude\n     [ method ]\n     **\n     * Removes given element from the set\n     **\n     - element (object) element to remove\n     = (boolean) `true` if object was found and removed from the set\n    \\*/\n    setproto.exclude = function (el) {\n        for (var i = 0, ii = this.length; i < ii; i++) if (this[i] == el) {\n            this.splice(i, 1);\n            return true;\n        }\n        return false;\n    };\n    setproto.insertAfter = function (el) {\n        var i = this.items.length;\n        while (i--) {\n            this.items[i].insertAfter(el);\n        }\n        return this;\n    };\n    setproto.getBBox = function () {\n        var x = [],\n            y = [],\n            x2 = [],\n            y2 = [];\n        for (var i = this.items.length; i--;) if (!this.items[i].removed) {\n            var box = this.items[i].getBBox();\n            x.push(box.x);\n            y.push(box.y);\n            x2.push(box.x + box.width);\n            y2.push(box.y + box.height);\n        }\n        x = mmin.apply(0, x);\n        y = mmin.apply(0, y);\n        x2 = mmax.apply(0, x2);\n        y2 = mmax.apply(0, y2);\n        return {\n            x: x,\n            y: y,\n            x2: x2,\n            y2: y2,\n            width: x2 - x,\n            height: y2 - y,\n            cx: x + (x2 - x) / 2,\n            cy: y + (y2 - y) / 2\n        };\n    };\n    setproto.clone = function (s) {\n        s = new Set;\n        for (var i = 0, ii = this.items.length; i < ii; i++) {\n            s.push(this.items[i].clone());\n        }\n        return s;\n    };\n    setproto.toString = function () {\n        return \"Snap\\u2018s set\";\n    };\n    setproto.type = \"set\";\n    // export\n    Snap.Set = Set;\n    Snap.set = function () {\n        var set = new Set;\n        if (arguments.length) {\n            set.push.apply(set, Array.prototype.slice.call(arguments, 0));\n        }\n        return set;\n    };\n});\n\n// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nSnap.plugin(function (Snap, Element, Paper, glob) {\n    var names = {},\n        reUnit = /[a-z]+$/i,\n        Str = String;\n    names.stroke = names.fill = \"colour\";\n    function getEmpty(item) {\n        var l = item[0];\n        switch (l.toLowerCase()) {\n            case \"t\": return [l, 0, 0];\n            case \"m\": return [l, 1, 0, 0, 1, 0, 0];\n            case \"r\": if (item.length == 4) {\n                return [l, 0, item[2], item[3]];\n            } else {\n                return [l, 0];\n            }\n            case \"s\": if (item.length == 5) {\n                return [l, 1, 1, item[3], item[4]];\n            } else if (item.length == 3) {\n                return [l, 1, 1];\n            } else {\n                return [l, 1];\n            }\n        }\n    }\n    function equaliseTransform(t1, t2, getBBox) {\n        t2 = Str(t2).replace(/\\.{3}|\\u2026/g, t1);\n        t1 = Snap.parseTransformString(t1) || [];\n        t2 = Snap.parseTransformString(t2) || [];\n        var maxlength = Math.max(t1.length, t2.length),\n            from = [],\n            to = [],\n            i = 0, j, jj,\n            tt1, tt2;\n        for (; i < maxlength; i++) {\n            tt1 = t1[i] || getEmpty(t2[i]);\n            tt2 = t2[i] || getEmpty(tt1);\n            if ((tt1[0] != tt2[0]) ||\n                (tt1[0].toLowerCase() == \"r\" && (tt1[2] != tt2[2] || tt1[3] != tt2[3])) ||\n                (tt1[0].toLowerCase() == \"s\" && (tt1[3] != tt2[3] || tt1[4] != tt2[4]))\n                ) {\n                    t1 = Snap._.transform2matrix(t1, getBBox());\n                    t2 = Snap._.transform2matrix(t2, getBBox());\n                    from = [[\"m\", t1.a, t1.b, t1.c, t1.d, t1.e, t1.f]];\n                    to = [[\"m\", t2.a, t2.b, t2.c, t2.d, t2.e, t2.f]];\n                    break;\n            }\n            from[i] = [];\n            to[i] = [];\n            for (j = 0, jj = Math.max(tt1.length, tt2.length); j < jj; j++) {\n                j in tt1 && (from[i][j] = tt1[j]);\n                j in tt2 && (to[i][j] = tt2[j]);\n            }\n        }\n        return {\n            from: path2array(from),\n            to: path2array(to),\n            f: getPath(from)\n        };\n    }\n    function getNumber(val) {\n        return val;\n    }\n    function getUnit(unit) {\n        return function (val) {\n            return +val.toFixed(3) + unit;\n        };\n    }\n    function getViewBox(val) {\n        return val.join(\" \");\n    }\n    function getColour(clr) {\n        return Snap.rgb(clr[0], clr[1], clr[2]);\n    }\n    function getPath(path) {\n        var k = 0, i, ii, j, jj, out, a, b = [];\n        for (i = 0, ii = path.length; i < ii; i++) {\n            out = \"[\";\n            a = ['\"' + path[i][0] + '\"'];\n            for (j = 1, jj = path[i].length; j < jj; j++) {\n                a[j] = \"val[\" + (k++) + \"]\";\n            }\n            out += a + \"]\";\n            b[i] = out;\n        }\n        return Function(\"val\", \"return Snap.path.toString.call([\" + b + \"])\");\n    }\n    function path2array(path) {\n        var out = [];\n        for (var i = 0, ii = path.length; i < ii; i++) {\n            for (var j = 1, jj = path[i].length; j < jj; j++) {\n                out.push(path[i][j]);\n            }\n        }\n        return out;\n    }\n    function isNumeric(obj) {\n        return isFinite(parseFloat(obj));\n    }\n    function arrayEqual(arr1, arr2) {\n        if (!Snap.is(arr1, \"array\") || !Snap.is(arr2, \"array\")) {\n            return false;\n        }\n        return arr1.toString() == arr2.toString();\n    }\n    Element.prototype.equal = function (name, b) {\n        return eve(\"snap.util.equal\", this, name, b).firstDefined();\n    };\n    eve.on(\"snap.util.equal\", function (name, b) {\n        var A, B, a = Str(this.attr(name) || \"\"),\n            el = this;\n        if (isNumeric(a) && isNumeric(b)) {\n            return {\n                from: parseFloat(a),\n                to: parseFloat(b),\n                f: getNumber\n            };\n        }\n        if (names[name] == \"colour\") {\n            A = Snap.color(a);\n            B = Snap.color(b);\n            return {\n                from: [A.r, A.g, A.b, A.opacity],\n                to: [B.r, B.g, B.b, B.opacity],\n                f: getColour\n            };\n        }\n        if (name == \"viewBox\") {\n            A = this.attr(name).vb.split(\" \").map(Number);\n            B = b.split(\" \").map(Number);\n            return {\n                from: A,\n                to: B,\n                f: getViewBox\n            };\n        }\n        if (name == \"transform\" || name == \"gradientTransform\" || name == \"patternTransform\") {\n            if (b instanceof Snap.Matrix) {\n                b = b.toTransformString();\n            }\n            if (!Snap._.rgTransform.test(b)) {\n                b = Snap._.svgTransform2string(b);\n            }\n            return equaliseTransform(a, b, function () {\n                return el.getBBox(1);\n            });\n        }\n        if (name == \"d\" || name == \"path\") {\n            A = Snap.path.toCubic(a, b);\n            return {\n                from: path2array(A[0]),\n                to: path2array(A[1]),\n                f: getPath(A[0])\n            };\n        }\n        if (name == \"points\") {\n            A = Str(a).split(Snap._.separator);\n            B = Str(b).split(Snap._.separator);\n            return {\n                from: A,\n                to: B,\n                f: function (val) { return val; }\n            };\n        }\n        var aUnit = a.match(reUnit),\n            bUnit = Str(b).match(reUnit);\n        if (aUnit && arrayEqual(aUnit, bUnit)) {\n            return {\n                from: parseFloat(a),\n                to: parseFloat(b),\n                f: getUnit(aUnit)\n            };\n        } else {\n            return {\n                from: this.asPX(name),\n                to: this.asPX(name, b),\n                f: getNumber\n            };\n        }\n    });\n});\n\n// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nSnap.plugin(function (Snap, Element, Paper, glob) {\n    var elproto = Element.prototype,\n    has = \"hasOwnProperty\",\n    supportsTouch = \"createTouch\" in glob.doc,\n    events = [\n        \"click\", \"dblclick\", \"mousedown\", \"mousemove\", \"mouseout\",\n        \"mouseover\", \"mouseup\", \"touchstart\", \"touchmove\", \"touchend\",\n        \"touchcancel\"\n    ],\n    touchMap = {\n        mousedown: \"touchstart\",\n        mousemove: \"touchmove\",\n        mouseup: \"touchend\"\n    },\n    getScroll = function (xy, el) {\n        var name = xy == \"y\" ? \"scrollTop\" : \"scrollLeft\",\n            doc = el && el.node ? el.node.ownerDocument : glob.doc;\n        return doc[name in doc.documentElement ? \"documentElement\" : \"body\"][name];\n    },\n    preventDefault = function () {\n        this.returnValue = false;\n    },\n    preventTouch = function () {\n        return this.originalEvent.preventDefault();\n    },\n    stopPropagation = function () {\n        this.cancelBubble = true;\n    },\n    stopTouch = function () {\n        return this.originalEvent.stopPropagation();\n    },\n    addEvent = function (obj, type, fn, element) {\n        var realName = supportsTouch && touchMap[type] ? touchMap[type] : type,\n            f = function (e) {\n                var scrollY = getScroll(\"y\", element),\n                    scrollX = getScroll(\"x\", element);\n                if (supportsTouch && touchMap[has](type)) {\n                    for (var i = 0, ii = e.targetTouches && e.targetTouches.length; i < ii; i++) {\n                        if (e.targetTouches[i].target == obj || obj.contains(e.targetTouches[i].target)) {\n                            var olde = e;\n                            e = e.targetTouches[i];\n                            e.originalEvent = olde;\n                            e.preventDefault = preventTouch;\n                            e.stopPropagation = stopTouch;\n                            break;\n                        }\n                    }\n                }\n                var x = e.clientX + scrollX,\n                    y = e.clientY + scrollY;\n                return fn.call(element, e, x, y);\n            };\n\n        if (type !== realName) {\n            obj.addEventListener(type, f, false);\n        }\n\n        obj.addEventListener(realName, f, false);\n\n        return function () {\n            if (type !== realName) {\n                obj.removeEventListener(type, f, false);\n            }\n\n            obj.removeEventListener(realName, f, false);\n            return true;\n        };\n    },\n    drag = [],\n    dragMove = function (e) {\n        var x = e.clientX,\n            y = e.clientY,\n            scrollY = getScroll(\"y\"),\n            scrollX = getScroll(\"x\"),\n            dragi,\n            j = drag.length;\n        while (j--) {\n            dragi = drag[j];\n            if (supportsTouch) {\n                var i = e.touches && e.touches.length,\n                    touch;\n                while (i--) {\n                    touch = e.touches[i];\n                    if (touch.identifier == dragi.el._drag.id || dragi.el.node.contains(touch.target)) {\n                        x = touch.clientX;\n                        y = touch.clientY;\n                        (e.originalEvent ? e.originalEvent : e).preventDefault();\n                        break;\n                    }\n                }\n            } else {\n                e.preventDefault();\n            }\n            var node = dragi.el.node,\n                o,\n                next = node.nextSibling,\n                parent = node.parentNode,\n                display = node.style.display;\n            // glob.win.opera && parent.removeChild(node);\n            // node.style.display = \"none\";\n            // o = dragi.el.paper.getElementByPoint(x, y);\n            // node.style.display = display;\n            // glob.win.opera && (next ? parent.insertBefore(node, next) : parent.appendChild(node));\n            // o && eve(\"snap.drag.over.\" + dragi.el.id, dragi.el, o);\n            x += scrollX;\n            y += scrollY;\n            eve(\"snap.drag.move.\" + dragi.el.id, dragi.move_scope || dragi.el, x - dragi.el._drag.x, y - dragi.el._drag.y, x, y, e);\n        }\n    },\n    dragUp = function (e) {\n        Snap.unmousemove(dragMove).unmouseup(dragUp);\n        var i = drag.length,\n            dragi;\n        while (i--) {\n            dragi = drag[i];\n            dragi.el._drag = {};\n            eve(\"snap.drag.end.\" + dragi.el.id, dragi.end_scope || dragi.start_scope || dragi.move_scope || dragi.el, e);\n            eve.off(\"snap.drag.*.\" + dragi.el.id);\n        }\n        drag = [];\n    };\n    /*\\\n     * Element.click\n     [ method ]\n     **\n     * Adds a click event handler to the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n    /*\\\n     * Element.unclick\n     [ method ]\n     **\n     * Removes a click event handler from the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n\n    /*\\\n     * Element.dblclick\n     [ method ]\n     **\n     * Adds a double click event handler to the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n    /*\\\n     * Element.undblclick\n     [ method ]\n     **\n     * Removes a double click event handler from the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n\n    /*\\\n     * Element.mousedown\n     [ method ]\n     **\n     * Adds a mousedown event handler to the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n    /*\\\n     * Element.unmousedown\n     [ method ]\n     **\n     * Removes a mousedown event handler from the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n\n    /*\\\n     * Element.mousemove\n     [ method ]\n     **\n     * Adds a mousemove event handler to the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n    /*\\\n     * Element.unmousemove\n     [ method ]\n     **\n     * Removes a mousemove event handler from the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n\n    /*\\\n     * Element.mouseout\n     [ method ]\n     **\n     * Adds a mouseout event handler to the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n    /*\\\n     * Element.unmouseout\n     [ method ]\n     **\n     * Removes a mouseout event handler from the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n\n    /*\\\n     * Element.mouseover\n     [ method ]\n     **\n     * Adds a mouseover event handler to the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n    /*\\\n     * Element.unmouseover\n     [ method ]\n     **\n     * Removes a mouseover event handler from the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n\n    /*\\\n     * Element.mouseup\n     [ method ]\n     **\n     * Adds a mouseup event handler to the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n    /*\\\n     * Element.unmouseup\n     [ method ]\n     **\n     * Removes a mouseup event handler from the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n\n    /*\\\n     * Element.touchstart\n     [ method ]\n     **\n     * Adds a touchstart event handler to the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n    /*\\\n     * Element.untouchstart\n     [ method ]\n     **\n     * Removes a touchstart event handler from the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n\n    /*\\\n     * Element.touchmove\n     [ method ]\n     **\n     * Adds a touchmove event handler to the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n    /*\\\n     * Element.untouchmove\n     [ method ]\n     **\n     * Removes a touchmove event handler from the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n\n    /*\\\n     * Element.touchend\n     [ method ]\n     **\n     * Adds a touchend event handler to the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n    /*\\\n     * Element.untouchend\n     [ method ]\n     **\n     * Removes a touchend event handler from the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n\n    /*\\\n     * Element.touchcancel\n     [ method ]\n     **\n     * Adds a touchcancel event handler to the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n    /*\\\n     * Element.untouchcancel\n     [ method ]\n     **\n     * Removes a touchcancel event handler from the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n    for (var i = events.length; i--;) {\n        (function (eventName) {\n            Snap[eventName] = elproto[eventName] = function (fn, scope) {\n                if (Snap.is(fn, \"function\")) {\n                    this.events = this.events || [];\n                    this.events.push({\n                        name: eventName,\n                        f: fn,\n                        unbind: addEvent(this.node || document, eventName, fn, scope || this)\n                    });\n                } else {\n                    for (var i = 0, ii = this.events.length; i < ii; i++) if (this.events[i].name == eventName) {\n                        try {\n                            this.events[i].f.call(this);\n                        } catch (e) {}\n                    }\n                }\n                return this;\n            };\n            Snap[\"un\" + eventName] =\n            elproto[\"un\" + eventName] = function (fn) {\n                var events = this.events || [],\n                    l = events.length;\n                while (l--) if (events[l].name == eventName &&\n                               (events[l].f == fn || !fn)) {\n                    events[l].unbind();\n                    events.splice(l, 1);\n                    !events.length && delete this.events;\n                    return this;\n                }\n                return this;\n            };\n        })(events[i]);\n    }\n    /*\\\n     * Element.hover\n     [ method ]\n     **\n     * Adds hover event handlers to the element\n     - f_in (function) handler for hover in\n     - f_out (function) handler for hover out\n     - icontext (object) #optional context for hover in handler\n     - ocontext (object) #optional context for hover out handler\n     = (object) @Element\n    \\*/\n    elproto.hover = function (f_in, f_out, scope_in, scope_out) {\n        return this.mouseover(f_in, scope_in).mouseout(f_out, scope_out || scope_in);\n    };\n    /*\\\n     * Element.unhover\n     [ method ]\n     **\n     * Removes hover event handlers from the element\n     - f_in (function) handler for hover in\n     - f_out (function) handler for hover out\n     = (object) @Element\n    \\*/\n    elproto.unhover = function (f_in, f_out) {\n        return this.unmouseover(f_in).unmouseout(f_out);\n    };\n    var draggable = [];\n    // SIERRA unclear what _context_ refers to for starting, ending, moving the drag gesture.\n    // SIERRA Element.drag(): _x position of the mouse_: Where are the x/y values offset from?\n    // SIERRA Element.drag(): much of this member's doc appears to be duplicated for some reason.\n    // SIERRA Unclear about this sentence: _Additionally following drag events will be triggered: drag.start.<id> on start, drag.end.<id> on end and drag.move.<id> on every move._ Is there a global _drag_ object to which you can assign handlers keyed by an element's ID?\n    /*\\\n     * Element.drag\n     [ method ]\n     **\n     * Adds event handlers for an element's drag gesture\n     **\n     - onmove (function) handler for moving\n     - onstart (function) handler for drag start\n     - onend (function) handler for drag end\n     - mcontext (object) #optional context for moving handler\n     - scontext (object) #optional context for drag start handler\n     - econtext (object) #optional context for drag end handler\n     * Additionaly following `drag` events are triggered: `drag.start.<id>` on start,\n     * `drag.end.<id>` on end and `drag.move.<id>` on every move. When element is dragged over another element\n     * `drag.over.<id>` fires as well.\n     *\n     * Start event and start handler are called in specified context or in context of the element with following parameters:\n     o x (number) x position of the mouse\n     o y (number) y position of the mouse\n     o event (object) DOM event object\n     * Move event and move handler are called in specified context or in context of the element with following parameters:\n     o dx (number) shift by x from the start point\n     o dy (number) shift by y from the start point\n     o x (number) x position of the mouse\n     o y (number) y position of the mouse\n     o event (object) DOM event object\n     * End event and end handler are called in specified context or in context of the element with following parameters:\n     o event (object) DOM event object\n     = (object) @Element\n    \\*/\n    elproto.drag = function (onmove, onstart, onend, move_scope, start_scope, end_scope) {\n        var el = this;\n        if (!arguments.length) {\n            var origTransform;\n            return el.drag(function (dx, dy) {\n                this.attr({\n                    transform: origTransform + (origTransform ? \"T\" : \"t\") + [dx, dy]\n                });\n            }, function () {\n                origTransform = this.transform().local;\n            });\n        }\n        function start(e, x, y) {\n            (e.originalEvent || e).preventDefault();\n            el._drag.x = x;\n            el._drag.y = y;\n            el._drag.id = e.identifier;\n            !drag.length && Snap.mousemove(dragMove).mouseup(dragUp);\n            drag.push({el: el, move_scope: move_scope, start_scope: start_scope, end_scope: end_scope});\n            onstart && eve.on(\"snap.drag.start.\" + el.id, onstart);\n            onmove && eve.on(\"snap.drag.move.\" + el.id, onmove);\n            onend && eve.on(\"snap.drag.end.\" + el.id, onend);\n            eve(\"snap.drag.start.\" + el.id, start_scope || move_scope || el, x, y, e);\n        }\n        function init(e, x, y) {\n            eve(\"snap.draginit.\" + el.id, el, e, x, y);\n        }\n        eve.on(\"snap.draginit.\" + el.id, start);\n        el._drag = {};\n        draggable.push({el: el, start: start, init: init});\n        el.mousedown(init);\n        return el;\n    };\n    /*\n     * Element.onDragOver\n     [ method ]\n     **\n     * Shortcut to assign event handler for `drag.over.<id>` event, where `id` is the element's `id` (see @Element.id)\n     - f (function) handler for event, first argument would be the element you are dragging over\n    \\*/\n    // elproto.onDragOver = function (f) {\n    //     f ? eve.on(\"snap.drag.over.\" + this.id, f) : eve.unbind(\"snap.drag.over.\" + this.id);\n    // };\n    /*\\\n     * Element.undrag\n     [ method ]\n     **\n     * Removes all drag event handlers from the given element\n    \\*/\n    elproto.undrag = function () {\n        var i = draggable.length;\n        while (i--) if (draggable[i].el == this) {\n            this.unmousedown(draggable[i].init);\n            draggable.splice(i, 1);\n            eve.unbind(\"snap.drag.*.\" + this.id);\n            eve.unbind(\"snap.draginit.\" + this.id);\n        }\n        !draggable.length && Snap.unmousemove(dragMove).unmouseup(dragUp);\n        return this;\n    };\n});\n\n// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nSnap.plugin(function (Snap, Element, Paper, glob) {\n    var elproto = Element.prototype,\n        pproto = Paper.prototype,\n        rgurl = /^\\s*url\\((.+)\\)/,\n        Str = String,\n        $ = Snap._.$;\n    Snap.filter = {};\n    /*\\\n     * Paper.filter\n     [ method ]\n     **\n     * Creates a `<filter>` element\n     **\n     - filstr (string) SVG fragment of filter provided as a string\n     = (object) @Element\n     * Note: It is recommended to use filters embedded into the page inside an empty SVG element.\n     > Usage\n     | var f = paper.filter('<feGaussianBlur stdDeviation=\"2\"/>'),\n     |     c = paper.circle(10, 10, 10).attr({\n     |         filter: f\n     |     });\n    \\*/\n    pproto.filter = function (filstr) {\n        var paper = this;\n        if (paper.type != \"svg\") {\n            paper = paper.paper;\n        }\n        var f = Snap.parse(Str(filstr)),\n            id = Snap._.id(),\n            width = paper.node.offsetWidth,\n            height = paper.node.offsetHeight,\n            filter = $(\"filter\");\n        $(filter, {\n            id: id,\n            filterUnits: \"userSpaceOnUse\"\n        });\n        filter.appendChild(f.node);\n        paper.defs.appendChild(filter);\n        return new Element(filter);\n    };\n\n    eve.on(\"snap.util.getattr.filter\", function () {\n        eve.stop();\n        var p = $(this.node, \"filter\");\n        if (p) {\n            var match = Str(p).match(rgurl);\n            return match && Snap.select(match[1]);\n        }\n    });\n    eve.on(\"snap.util.attr.filter\", function (value) {\n        if (value instanceof Element && value.type == \"filter\") {\n            eve.stop();\n            var id = value.node.id;\n            if (!id) {\n                $(value.node, {id: value.id});\n                id = value.id;\n            }\n            $(this.node, {\n                filter: Snap.url(id)\n            });\n        }\n        if (!value || value == \"none\") {\n            eve.stop();\n            this.node.removeAttribute(\"filter\");\n        }\n    });\n    /*\\\n     * Snap.filter.blur\n     [ method ]\n     **\n     * Returns an SVG markup string for the blur filter\n     **\n     - x (number) amount of horizontal blur, in pixels\n     - y (number) #optional amount of vertical blur, in pixels\n     = (string) filter representation\n     > Usage\n     | var f = paper.filter(Snap.filter.blur(5, 10)),\n     |     c = paper.circle(10, 10, 10).attr({\n     |         filter: f\n     |     });\n    \\*/\n    Snap.filter.blur = function (x, y) {\n        if (x == null) {\n            x = 2;\n        }\n        var def = y == null ? x : [x, y];\n        return Snap.format('\\<feGaussianBlur stdDeviation=\"{def}\"/>', {\n            def: def\n        });\n    };\n    Snap.filter.blur.toString = function () {\n        return this();\n    };\n    /*\\\n     * Snap.filter.shadow\n     [ method ]\n     **\n     * Returns an SVG markup string for the shadow filter\n     **\n     - dx (number) #optional horizontal shift of the shadow, in pixels\n     - dy (number) #optional vertical shift of the shadow, in pixels\n     - blur (number) #optional amount of blur\n     - color (string) #optional color of the shadow\n     - opacity (number) #optional `0..1` opacity of the shadow\n     * or\n     - dx (number) #optional horizontal shift of the shadow, in pixels\n     - dy (number) #optional vertical shift of the shadow, in pixels\n     - color (string) #optional color of the shadow\n     - opacity (number) #optional `0..1` opacity of the shadow\n     * which makes blur default to `4`. Or\n     - dx (number) #optional horizontal shift of the shadow, in pixels\n     - dy (number) #optional vertical shift of the shadow, in pixels\n     - opacity (number) #optional `0..1` opacity of the shadow\n     = (string) filter representation\n     > Usage\n     | var f = paper.filter(Snap.filter.shadow(0, 2, 3)),\n     |     c = paper.circle(10, 10, 10).attr({\n     |         filter: f\n     |     });\n    \\*/\n    Snap.filter.shadow = function (dx, dy, blur, color, opacity) {\n        if (typeof blur == \"string\") {\n            color = blur;\n            opacity = color;\n            blur = 4;\n        }\n        if (typeof color != \"string\") {\n            opacity = color;\n            color = \"#000\";\n        }\n        color = color || \"#000\";\n        if (blur == null) {\n            blur = 4;\n        }\n        if (opacity == null) {\n            opacity = 1;\n        }\n        if (dx == null) {\n            dx = 0;\n            dy = 2;\n        }\n        if (dy == null) {\n            dy = dx;\n        }\n        color = Snap.color(color);\n        return Snap.format('<feGaussianBlur in=\"SourceAlpha\" stdDeviation=\"{blur}\"/><feOffset dx=\"{dx}\" dy=\"{dy}\" result=\"offsetblur\"/><feFlood flood-color=\"{color}\"/><feComposite in2=\"offsetblur\" operator=\"in\"/><feComponentTransfer><feFuncA type=\"linear\" slope=\"{opacity}\"/></feComponentTransfer><feMerge><feMergeNode/><feMergeNode in=\"SourceGraphic\"/></feMerge>', {\n            color: color,\n            dx: dx,\n            dy: dy,\n            blur: blur,\n            opacity: opacity\n        });\n    };\n    Snap.filter.shadow.toString = function () {\n        return this();\n    };\n    /*\\\n     * Snap.filter.grayscale\n     [ method ]\n     **\n     * Returns an SVG markup string for the grayscale filter\n     **\n     - amount (number) amount of filter (`0..1`)\n     = (string) filter representation\n    \\*/\n    Snap.filter.grayscale = function (amount) {\n        if (amount == null) {\n            amount = 1;\n        }\n        return Snap.format('<feColorMatrix type=\"matrix\" values=\"{a} {b} {c} 0 0 {d} {e} {f} 0 0 {g} {b} {h} 0 0 0 0 0 1 0\"/>', {\n            a: 0.2126 + 0.7874 * (1 - amount),\n            b: 0.7152 - 0.7152 * (1 - amount),\n            c: 0.0722 - 0.0722 * (1 - amount),\n            d: 0.2126 - 0.2126 * (1 - amount),\n            e: 0.7152 + 0.2848 * (1 - amount),\n            f: 0.0722 - 0.0722 * (1 - amount),\n            g: 0.2126 - 0.2126 * (1 - amount),\n            h: 0.0722 + 0.9278 * (1 - amount)\n        });\n    };\n    Snap.filter.grayscale.toString = function () {\n        return this();\n    };\n    /*\\\n     * Snap.filter.sepia\n     [ method ]\n     **\n     * Returns an SVG markup string for the sepia filter\n     **\n     - amount (number) amount of filter (`0..1`)\n     = (string) filter representation\n    \\*/\n    Snap.filter.sepia = function (amount) {\n        if (amount == null) {\n            amount = 1;\n        }\n        return Snap.format('<feColorMatrix type=\"matrix\" values=\"{a} {b} {c} 0 0 {d} {e} {f} 0 0 {g} {h} {i} 0 0 0 0 0 1 0\"/>', {\n            a: 0.393 + 0.607 * (1 - amount),\n            b: 0.769 - 0.769 * (1 - amount),\n            c: 0.189 - 0.189 * (1 - amount),\n            d: 0.349 - 0.349 * (1 - amount),\n            e: 0.686 + 0.314 * (1 - amount),\n            f: 0.168 - 0.168 * (1 - amount),\n            g: 0.272 - 0.272 * (1 - amount),\n            h: 0.534 - 0.534 * (1 - amount),\n            i: 0.131 + 0.869 * (1 - amount)\n        });\n    };\n    Snap.filter.sepia.toString = function () {\n        return this();\n    };\n    /*\\\n     * Snap.filter.saturate\n     [ method ]\n     **\n     * Returns an SVG markup string for the saturate filter\n     **\n     - amount (number) amount of filter (`0..1`)\n     = (string) filter representation\n    \\*/\n    Snap.filter.saturate = function (amount) {\n        if (amount == null) {\n            amount = 1;\n        }\n        return Snap.format('<feColorMatrix type=\"saturate\" values=\"{amount}\"/>', {\n            amount: 1 - amount\n        });\n    };\n    Snap.filter.saturate.toString = function () {\n        return this();\n    };\n    /*\\\n     * Snap.filter.hueRotate\n     [ method ]\n     **\n     * Returns an SVG markup string for the hue-rotate filter\n     **\n     - angle (number) angle of rotation\n     = (string) filter representation\n    \\*/\n    Snap.filter.hueRotate = function (angle) {\n        angle = angle || 0;\n        return Snap.format('<feColorMatrix type=\"hueRotate\" values=\"{angle}\"/>', {\n            angle: angle\n        });\n    };\n    Snap.filter.hueRotate.toString = function () {\n        return this();\n    };\n    /*\\\n     * Snap.filter.invert\n     [ method ]\n     **\n     * Returns an SVG markup string for the invert filter\n     **\n     - amount (number) amount of filter (`0..1`)\n     = (string) filter representation\n    \\*/\n    Snap.filter.invert = function (amount) {\n        if (amount == null) {\n            amount = 1;\n        }\n//        <feColorMatrix type=\"matrix\" values=\"-1 0 0 0 1  0 -1 0 0 1  0 0 -1 0 1  0 0 0 1 0\" color-interpolation-filters=\"sRGB\"/>\n        return Snap.format('<feComponentTransfer><feFuncR type=\"table\" tableValues=\"{amount} {amount2}\"/><feFuncG type=\"table\" tableValues=\"{amount} {amount2}\"/><feFuncB type=\"table\" tableValues=\"{amount} {amount2}\"/></feComponentTransfer>', {\n            amount: amount,\n            amount2: 1 - amount\n        });\n    };\n    Snap.filter.invert.toString = function () {\n        return this();\n    };\n    /*\\\n     * Snap.filter.brightness\n     [ method ]\n     **\n     * Returns an SVG markup string for the brightness filter\n     **\n     - amount (number) amount of filter (`0..1`)\n     = (string) filter representation\n    \\*/\n    Snap.filter.brightness = function (amount) {\n        if (amount == null) {\n            amount = 1;\n        }\n        return Snap.format('<feComponentTransfer><feFuncR type=\"linear\" slope=\"{amount}\"/><feFuncG type=\"linear\" slope=\"{amount}\"/><feFuncB type=\"linear\" slope=\"{amount}\"/></feComponentTransfer>', {\n            amount: amount\n        });\n    };\n    Snap.filter.brightness.toString = function () {\n        return this();\n    };\n    /*\\\n     * Snap.filter.contrast\n     [ method ]\n     **\n     * Returns an SVG markup string for the contrast filter\n     **\n     - amount (number) amount of filter (`0..1`)\n     = (string) filter representation\n    \\*/\n    Snap.filter.contrast = function (amount) {\n        if (amount == null) {\n            amount = 1;\n        }\n        return Snap.format('<feComponentTransfer><feFuncR type=\"linear\" slope=\"{amount}\" intercept=\"{amount2}\"/><feFuncG type=\"linear\" slope=\"{amount}\" intercept=\"{amount2}\"/><feFuncB type=\"linear\" slope=\"{amount}\" intercept=\"{amount2}\"/></feComponentTransfer>', {\n            amount: amount,\n            amount2: .5 - amount / 2\n        });\n    };\n    Snap.filter.contrast.toString = function () {\n        return this();\n    };\n});\n\n// Copyright (c) 2014 Adobe Systems Incorporated. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nSnap.plugin(function (Snap, Element, Paper, glob, Fragment) {\n    var box = Snap._.box,\n        is = Snap.is,\n        firstLetter = /^[^a-z]*([tbmlrc])/i,\n        toString = function () {\n            return \"T\" + this.dx + \",\" + this.dy;\n        };\n    /*\\\n     * Element.getAlign\n     [ method ]\n     **\n     * Returns shift needed to align the element relatively to given element.\n     * If no elements specified, parent `<svg>` container will be used.\n     - el (object) @optional alignment element\n     - way (string) one of six values: `\"top\"`, `\"middle\"`, `\"bottom\"`, `\"left\"`, `\"center\"`, `\"right\"`\n     = (object|string) Object in format `{dx: , dy: }` also has a string representation as a transformation string\n     > Usage\n     | el.transform(el.getAlign(el2, \"top\"));\n     * or\n     | var dy = el.getAlign(el2, \"top\").dy;\n    \\*/\n    Element.prototype.getAlign = function (el, way) {\n        if (way == null && is(el, \"string\")) {\n            way = el;\n            el = null;\n        }\n        el = el || this.paper;\n        var bx = el.getBBox ? el.getBBox() : box(el),\n            bb = this.getBBox(),\n            out = {};\n        way = way && way.match(firstLetter);\n        way = way ? way[1].toLowerCase() : \"c\";\n        switch (way) {\n            case \"t\":\n                out.dx = 0;\n                out.dy = bx.y - bb.y;\n            break;\n            case \"b\":\n                out.dx = 0;\n                out.dy = bx.y2 - bb.y2;\n            break;\n            case \"m\":\n                out.dx = 0;\n                out.dy = bx.cy - bb.cy;\n            break;\n            case \"l\":\n                out.dx = bx.x - bb.x;\n                out.dy = 0;\n            break;\n            case \"r\":\n                out.dx = bx.x2 - bb.x2;\n                out.dy = 0;\n            break;\n            default:\n                out.dx = bx.cx - bb.cx;\n                out.dy = 0;\n            break;\n        }\n        out.toString = toString;\n        return out;\n    };\n    /*\\\n     * Element.align\n     [ method ]\n     **\n     * Aligns the element relatively to given one via transformation.\n     * If no elements specified, parent `<svg>` container will be used.\n     - el (object) @optional alignment element\n     - way (string) one of six values: `\"top\"`, `\"middle\"`, `\"bottom\"`, `\"left\"`, `\"center\"`, `\"right\"`\n     = (object) this element\n     > Usage\n     | el.align(el2, \"top\");\n     * or\n     | el.align(\"middle\");\n    \\*/\n    Element.prototype.align = function (el, way) {\n        return this.transform(\"...\" + this.getAlign(el, way));\n    };\n});\n\nmodule.exports = Snap\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/snapsvg-cjs/dist/snap.svg-cjs.js\n// module id = 13\n// module chunks = 0"],"sourceRoot":""}