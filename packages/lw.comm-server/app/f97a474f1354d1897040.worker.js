/******/ (function(modules) { // webpackBootstrap
/******/ 	var parentHotUpdateCallback = this["webpackHotUpdate"];
/******/ 	this["webpackHotUpdate"] = 
/******/ 	function webpackHotUpdateCallback(chunkId, moreModules) { // eslint-disable-line no-unused-vars
/******/ 		hotAddUpdateChunk(chunkId, moreModules);
/******/ 		if(parentHotUpdateCallback) parentHotUpdateCallback(chunkId, moreModules);
/******/ 	} ;
/******/ 	
/******/ 	function hotDownloadUpdateChunk(chunkId) { // eslint-disable-line no-unused-vars
/******/ 		importScripts(__webpack_require__.p + "" + chunkId + "." + hotCurrentHash + ".hot-update.js");
/******/ 	}
/******/ 	
/******/ 	function hotDownloadManifest(callback) { // eslint-disable-line no-unused-vars
/******/ 		return new Promise(function(resolve, reject) {
/******/ 			if(typeof XMLHttpRequest === "undefined")
/******/ 				return reject(new Error("No browser support"));
/******/ 			try {
/******/ 				var request = new XMLHttpRequest();
/******/ 				var requestPath = __webpack_require__.p + "" + hotCurrentHash + ".hot-update.json";
/******/ 				request.open("GET", requestPath, true);
/******/ 				request.timeout = 10000;
/******/ 				request.send(null);
/******/ 			} catch(err) {
/******/ 				return reject(err);
/******/ 			}
/******/ 			request.onreadystatechange = function() {
/******/ 				if(request.readyState !== 4) return;
/******/ 				if(request.status === 0) {
/******/ 					// timeout
/******/ 					reject(new Error("Manifest request to " + requestPath + " timed out."));
/******/ 				} else if(request.status === 404) {
/******/ 					// no update available
/******/ 					resolve();
/******/ 				} else if(request.status !== 200 && request.status !== 304) {
/******/ 					// other failure
/******/ 					reject(new Error("Manifest request to " + requestPath + " failed."));
/******/ 				} else {
/******/ 					// success
/******/ 					try {
/******/ 						var update = JSON.parse(request.responseText);
/******/ 					} catch(e) {
/******/ 						reject(e);
/******/ 						return;
/******/ 					}
/******/ 					resolve(update);
/******/ 				}
/******/ 			};
/******/ 		});
/******/ 	}
/******/ 	
/******/ 	function hotDisposeChunk(chunkId) { //eslint-disable-line no-unused-vars
/******/ 		delete installedChunks[chunkId];
/******/ 	}
/******/
/******/ 	
/******/ 	
/******/ 	var hotApplyOnUpdate = true;
/******/ 	var hotCurrentHash = "f97a474f1354d1897040"; // eslint-disable-line no-unused-vars
/******/ 	var hotCurrentModuleData = {};
/******/ 	var hotCurrentChildModule; // eslint-disable-line no-unused-vars
/******/ 	var hotCurrentParents = []; // eslint-disable-line no-unused-vars
/******/ 	var hotCurrentParentsTemp = []; // eslint-disable-line no-unused-vars
/******/ 	
/******/ 	function hotCreateRequire(moduleId) { // eslint-disable-line no-unused-vars
/******/ 		var me = installedModules[moduleId];
/******/ 		if(!me) return __webpack_require__;
/******/ 		var fn = function(request) {
/******/ 			if(me.hot.active) {
/******/ 				if(installedModules[request]) {
/******/ 					if(installedModules[request].parents.indexOf(moduleId) < 0)
/******/ 						installedModules[request].parents.push(moduleId);
/******/ 				} else {
/******/ 					hotCurrentParents = [moduleId];
/******/ 					hotCurrentChildModule = request;
/******/ 				}
/******/ 				if(me.children.indexOf(request) < 0)
/******/ 					me.children.push(request);
/******/ 			} else {
/******/ 				console.warn("[HMR] unexpected require(" + request + ") from disposed module " + moduleId);
/******/ 				hotCurrentParents = [];
/******/ 			}
/******/ 			return __webpack_require__(request);
/******/ 		};
/******/ 		var ObjectFactory = function ObjectFactory(name) {
/******/ 			return {
/******/ 				configurable: true,
/******/ 				enumerable: true,
/******/ 				get: function() {
/******/ 					return __webpack_require__[name];
/******/ 				},
/******/ 				set: function(value) {
/******/ 					__webpack_require__[name] = value;
/******/ 				}
/******/ 			};
/******/ 		};
/******/ 		for(var name in __webpack_require__) {
/******/ 			if(Object.prototype.hasOwnProperty.call(__webpack_require__, name) && name !== "e") {
/******/ 				Object.defineProperty(fn, name, ObjectFactory(name));
/******/ 			}
/******/ 		}
/******/ 		fn.e = function(chunkId) {
/******/ 			if(hotStatus === "ready")
/******/ 				hotSetStatus("prepare");
/******/ 			hotChunksLoading++;
/******/ 			return __webpack_require__.e(chunkId).then(finishChunkLoading, function(err) {
/******/ 				finishChunkLoading();
/******/ 				throw err;
/******/ 			});
/******/ 	
/******/ 			function finishChunkLoading() {
/******/ 				hotChunksLoading--;
/******/ 				if(hotStatus === "prepare") {
/******/ 					if(!hotWaitingFilesMap[chunkId]) {
/******/ 						hotEnsureUpdateChunk(chunkId);
/******/ 					}
/******/ 					if(hotChunksLoading === 0 && hotWaitingFiles === 0) {
/******/ 						hotUpdateDownloaded();
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 		return fn;
/******/ 	}
/******/ 	
/******/ 	function hotCreateModule(moduleId) { // eslint-disable-line no-unused-vars
/******/ 		var hot = {
/******/ 			// private stuff
/******/ 			_acceptedDependencies: {},
/******/ 			_declinedDependencies: {},
/******/ 			_selfAccepted: false,
/******/ 			_selfDeclined: false,
/******/ 			_disposeHandlers: [],
/******/ 			_main: hotCurrentChildModule !== moduleId,
/******/ 	
/******/ 			// Module API
/******/ 			active: true,
/******/ 			accept: function(dep, callback) {
/******/ 				if(typeof dep === "undefined")
/******/ 					hot._selfAccepted = true;
/******/ 				else if(typeof dep === "function")
/******/ 					hot._selfAccepted = dep;
/******/ 				else if(typeof dep === "object")
/******/ 					for(var i = 0; i < dep.length; i++)
/******/ 						hot._acceptedDependencies[dep[i]] = callback || function() {};
/******/ 				else
/******/ 					hot._acceptedDependencies[dep] = callback || function() {};
/******/ 			},
/******/ 			decline: function(dep) {
/******/ 				if(typeof dep === "undefined")
/******/ 					hot._selfDeclined = true;
/******/ 				else if(typeof dep === "object")
/******/ 					for(var i = 0; i < dep.length; i++)
/******/ 						hot._declinedDependencies[dep[i]] = true;
/******/ 				else
/******/ 					hot._declinedDependencies[dep] = true;
/******/ 			},
/******/ 			dispose: function(callback) {
/******/ 				hot._disposeHandlers.push(callback);
/******/ 			},
/******/ 			addDisposeHandler: function(callback) {
/******/ 				hot._disposeHandlers.push(callback);
/******/ 			},
/******/ 			removeDisposeHandler: function(callback) {
/******/ 				var idx = hot._disposeHandlers.indexOf(callback);
/******/ 				if(idx >= 0) hot._disposeHandlers.splice(idx, 1);
/******/ 			},
/******/ 	
/******/ 			// Management API
/******/ 			check: hotCheck,
/******/ 			apply: hotApply,
/******/ 			status: function(l) {
/******/ 				if(!l) return hotStatus;
/******/ 				hotStatusHandlers.push(l);
/******/ 			},
/******/ 			addStatusHandler: function(l) {
/******/ 				hotStatusHandlers.push(l);
/******/ 			},
/******/ 			removeStatusHandler: function(l) {
/******/ 				var idx = hotStatusHandlers.indexOf(l);
/******/ 				if(idx >= 0) hotStatusHandlers.splice(idx, 1);
/******/ 			},
/******/ 	
/******/ 			//inherit from previous dispose call
/******/ 			data: hotCurrentModuleData[moduleId]
/******/ 		};
/******/ 		hotCurrentChildModule = undefined;
/******/ 		return hot;
/******/ 	}
/******/ 	
/******/ 	var hotStatusHandlers = [];
/******/ 	var hotStatus = "idle";
/******/ 	
/******/ 	function hotSetStatus(newStatus) {
/******/ 		hotStatus = newStatus;
/******/ 		for(var i = 0; i < hotStatusHandlers.length; i++)
/******/ 			hotStatusHandlers[i].call(null, newStatus);
/******/ 	}
/******/ 	
/******/ 	// while downloading
/******/ 	var hotWaitingFiles = 0;
/******/ 	var hotChunksLoading = 0;
/******/ 	var hotWaitingFilesMap = {};
/******/ 	var hotRequestedFilesMap = {};
/******/ 	var hotAvailableFilesMap = {};
/******/ 	var hotDeferred;
/******/ 	
/******/ 	// The update info
/******/ 	var hotUpdate, hotUpdateNewHash;
/******/ 	
/******/ 	function toModuleId(id) {
/******/ 		var isNumber = (+id) + "" === id;
/******/ 		return isNumber ? +id : id;
/******/ 	}
/******/ 	
/******/ 	function hotCheck(apply) {
/******/ 		if(hotStatus !== "idle") throw new Error("check() is only allowed in idle status");
/******/ 		hotApplyOnUpdate = apply;
/******/ 		hotSetStatus("check");
/******/ 		return hotDownloadManifest().then(function(update) {
/******/ 			if(!update) {
/******/ 				hotSetStatus("idle");
/******/ 				return null;
/******/ 			}
/******/ 			hotRequestedFilesMap = {};
/******/ 			hotWaitingFilesMap = {};
/******/ 			hotAvailableFilesMap = update.c;
/******/ 			hotUpdateNewHash = update.h;
/******/ 	
/******/ 			hotSetStatus("prepare");
/******/ 			var promise = new Promise(function(resolve, reject) {
/******/ 				hotDeferred = {
/******/ 					resolve: resolve,
/******/ 					reject: reject
/******/ 				};
/******/ 			});
/******/ 			hotUpdate = {};
/******/ 			var chunkId = 0;
/******/ 			{ // eslint-disable-line no-lone-blocks
/******/ 				/*globals chunkId */
/******/ 				hotEnsureUpdateChunk(chunkId);
/******/ 			}
/******/ 			if(hotStatus === "prepare" && hotChunksLoading === 0 && hotWaitingFiles === 0) {
/******/ 				hotUpdateDownloaded();
/******/ 			}
/******/ 			return promise;
/******/ 		});
/******/ 	}
/******/ 	
/******/ 	function hotAddUpdateChunk(chunkId, moreModules) { // eslint-disable-line no-unused-vars
/******/ 		if(!hotAvailableFilesMap[chunkId] || !hotRequestedFilesMap[chunkId])
/******/ 			return;
/******/ 		hotRequestedFilesMap[chunkId] = false;
/******/ 		for(var moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				hotUpdate[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(--hotWaitingFiles === 0 && hotChunksLoading === 0) {
/******/ 			hotUpdateDownloaded();
/******/ 		}
/******/ 	}
/******/ 	
/******/ 	function hotEnsureUpdateChunk(chunkId) {
/******/ 		if(!hotAvailableFilesMap[chunkId]) {
/******/ 			hotWaitingFilesMap[chunkId] = true;
/******/ 		} else {
/******/ 			hotRequestedFilesMap[chunkId] = true;
/******/ 			hotWaitingFiles++;
/******/ 			hotDownloadUpdateChunk(chunkId);
/******/ 		}
/******/ 	}
/******/ 	
/******/ 	function hotUpdateDownloaded() {
/******/ 		hotSetStatus("ready");
/******/ 		var deferred = hotDeferred;
/******/ 		hotDeferred = null;
/******/ 		if(!deferred) return;
/******/ 		if(hotApplyOnUpdate) {
/******/ 			hotApply(hotApplyOnUpdate).then(function(result) {
/******/ 				deferred.resolve(result);
/******/ 			}, function(err) {
/******/ 				deferred.reject(err);
/******/ 			});
/******/ 		} else {
/******/ 			var outdatedModules = [];
/******/ 			for(var id in hotUpdate) {
/******/ 				if(Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
/******/ 					outdatedModules.push(toModuleId(id));
/******/ 				}
/******/ 			}
/******/ 			deferred.resolve(outdatedModules);
/******/ 		}
/******/ 	}
/******/ 	
/******/ 	function hotApply(options) {
/******/ 		if(hotStatus !== "ready") throw new Error("apply() is only allowed in ready status");
/******/ 		options = options || {};
/******/ 	
/******/ 		var cb;
/******/ 		var i;
/******/ 		var j;
/******/ 		var module;
/******/ 		var moduleId;
/******/ 	
/******/ 		function getAffectedStuff(updateModuleId) {
/******/ 			var outdatedModules = [updateModuleId];
/******/ 			var outdatedDependencies = {};
/******/ 	
/******/ 			var queue = outdatedModules.slice().map(function(id) {
/******/ 				return {
/******/ 					chain: [id],
/******/ 					id: id
/******/ 				};
/******/ 			});
/******/ 			while(queue.length > 0) {
/******/ 				var queueItem = queue.pop();
/******/ 				var moduleId = queueItem.id;
/******/ 				var chain = queueItem.chain;
/******/ 				module = installedModules[moduleId];
/******/ 				if(!module || module.hot._selfAccepted)
/******/ 					continue;
/******/ 				if(module.hot._selfDeclined) {
/******/ 					return {
/******/ 						type: "self-declined",
/******/ 						chain: chain,
/******/ 						moduleId: moduleId
/******/ 					};
/******/ 				}
/******/ 				if(module.hot._main) {
/******/ 					return {
/******/ 						type: "unaccepted",
/******/ 						chain: chain,
/******/ 						moduleId: moduleId
/******/ 					};
/******/ 				}
/******/ 				for(var i = 0; i < module.parents.length; i++) {
/******/ 					var parentId = module.parents[i];
/******/ 					var parent = installedModules[parentId];
/******/ 					if(!parent) continue;
/******/ 					if(parent.hot._declinedDependencies[moduleId]) {
/******/ 						return {
/******/ 							type: "declined",
/******/ 							chain: chain.concat([parentId]),
/******/ 							moduleId: moduleId,
/******/ 							parentId: parentId
/******/ 						};
/******/ 					}
/******/ 					if(outdatedModules.indexOf(parentId) >= 0) continue;
/******/ 					if(parent.hot._acceptedDependencies[moduleId]) {
/******/ 						if(!outdatedDependencies[parentId])
/******/ 							outdatedDependencies[parentId] = [];
/******/ 						addAllToSet(outdatedDependencies[parentId], [moduleId]);
/******/ 						continue;
/******/ 					}
/******/ 					delete outdatedDependencies[parentId];
/******/ 					outdatedModules.push(parentId);
/******/ 					queue.push({
/******/ 						chain: chain.concat([parentId]),
/******/ 						id: parentId
/******/ 					});
/******/ 				}
/******/ 			}
/******/ 	
/******/ 			return {
/******/ 				type: "accepted",
/******/ 				moduleId: updateModuleId,
/******/ 				outdatedModules: outdatedModules,
/******/ 				outdatedDependencies: outdatedDependencies
/******/ 			};
/******/ 		}
/******/ 	
/******/ 		function addAllToSet(a, b) {
/******/ 			for(var i = 0; i < b.length; i++) {
/******/ 				var item = b[i];
/******/ 				if(a.indexOf(item) < 0)
/******/ 					a.push(item);
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// at begin all updates modules are outdated
/******/ 		// the "outdated" status can propagate to parents if they don't accept the children
/******/ 		var outdatedDependencies = {};
/******/ 		var outdatedModules = [];
/******/ 		var appliedUpdate = {};
/******/ 	
/******/ 		var warnUnexpectedRequire = function warnUnexpectedRequire() {
/******/ 			console.warn("[HMR] unexpected require(" + result.moduleId + ") to disposed module");
/******/ 		};
/******/ 	
/******/ 		for(var id in hotUpdate) {
/******/ 			if(Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
/******/ 				moduleId = toModuleId(id);
/******/ 				var result;
/******/ 				if(hotUpdate[id]) {
/******/ 					result = getAffectedStuff(moduleId);
/******/ 				} else {
/******/ 					result = {
/******/ 						type: "disposed",
/******/ 						moduleId: id
/******/ 					};
/******/ 				}
/******/ 				var abortError = false;
/******/ 				var doApply = false;
/******/ 				var doDispose = false;
/******/ 				var chainInfo = "";
/******/ 				if(result.chain) {
/******/ 					chainInfo = "\nUpdate propagation: " + result.chain.join(" -> ");
/******/ 				}
/******/ 				switch(result.type) {
/******/ 					case "self-declined":
/******/ 						if(options.onDeclined)
/******/ 							options.onDeclined(result);
/******/ 						if(!options.ignoreDeclined)
/******/ 							abortError = new Error("Aborted because of self decline: " + result.moduleId + chainInfo);
/******/ 						break;
/******/ 					case "declined":
/******/ 						if(options.onDeclined)
/******/ 							options.onDeclined(result);
/******/ 						if(!options.ignoreDeclined)
/******/ 							abortError = new Error("Aborted because of declined dependency: " + result.moduleId + " in " + result.parentId + chainInfo);
/******/ 						break;
/******/ 					case "unaccepted":
/******/ 						if(options.onUnaccepted)
/******/ 							options.onUnaccepted(result);
/******/ 						if(!options.ignoreUnaccepted)
/******/ 							abortError = new Error("Aborted because " + moduleId + " is not accepted" + chainInfo);
/******/ 						break;
/******/ 					case "accepted":
/******/ 						if(options.onAccepted)
/******/ 							options.onAccepted(result);
/******/ 						doApply = true;
/******/ 						break;
/******/ 					case "disposed":
/******/ 						if(options.onDisposed)
/******/ 							options.onDisposed(result);
/******/ 						doDispose = true;
/******/ 						break;
/******/ 					default:
/******/ 						throw new Error("Unexception type " + result.type);
/******/ 				}
/******/ 				if(abortError) {
/******/ 					hotSetStatus("abort");
/******/ 					return Promise.reject(abortError);
/******/ 				}
/******/ 				if(doApply) {
/******/ 					appliedUpdate[moduleId] = hotUpdate[moduleId];
/******/ 					addAllToSet(outdatedModules, result.outdatedModules);
/******/ 					for(moduleId in result.outdatedDependencies) {
/******/ 						if(Object.prototype.hasOwnProperty.call(result.outdatedDependencies, moduleId)) {
/******/ 							if(!outdatedDependencies[moduleId])
/******/ 								outdatedDependencies[moduleId] = [];
/******/ 							addAllToSet(outdatedDependencies[moduleId], result.outdatedDependencies[moduleId]);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 				if(doDispose) {
/******/ 					addAllToSet(outdatedModules, [result.moduleId]);
/******/ 					appliedUpdate[moduleId] = warnUnexpectedRequire;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// Store self accepted outdated modules to require them later by the module system
/******/ 		var outdatedSelfAcceptedModules = [];
/******/ 		for(i = 0; i < outdatedModules.length; i++) {
/******/ 			moduleId = outdatedModules[i];
/******/ 			if(installedModules[moduleId] && installedModules[moduleId].hot._selfAccepted)
/******/ 				outdatedSelfAcceptedModules.push({
/******/ 					module: moduleId,
/******/ 					errorHandler: installedModules[moduleId].hot._selfAccepted
/******/ 				});
/******/ 		}
/******/ 	
/******/ 		// Now in "dispose" phase
/******/ 		hotSetStatus("dispose");
/******/ 		Object.keys(hotAvailableFilesMap).forEach(function(chunkId) {
/******/ 			if(hotAvailableFilesMap[chunkId] === false) {
/******/ 				hotDisposeChunk(chunkId);
/******/ 			}
/******/ 		});
/******/ 	
/******/ 		var idx;
/******/ 		var queue = outdatedModules.slice();
/******/ 		while(queue.length > 0) {
/******/ 			moduleId = queue.pop();
/******/ 			module = installedModules[moduleId];
/******/ 			if(!module) continue;
/******/ 	
/******/ 			var data = {};
/******/ 	
/******/ 			// Call dispose handlers
/******/ 			var disposeHandlers = module.hot._disposeHandlers;
/******/ 			for(j = 0; j < disposeHandlers.length; j++) {
/******/ 				cb = disposeHandlers[j];
/******/ 				cb(data);
/******/ 			}
/******/ 			hotCurrentModuleData[moduleId] = data;
/******/ 	
/******/ 			// disable module (this disables requires from this module)
/******/ 			module.hot.active = false;
/******/ 	
/******/ 			// remove module from cache
/******/ 			delete installedModules[moduleId];
/******/ 	
/******/ 			// remove "parents" references from all children
/******/ 			for(j = 0; j < module.children.length; j++) {
/******/ 				var child = installedModules[module.children[j]];
/******/ 				if(!child) continue;
/******/ 				idx = child.parents.indexOf(moduleId);
/******/ 				if(idx >= 0) {
/******/ 					child.parents.splice(idx, 1);
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// remove outdated dependency from module children
/******/ 		var dependency;
/******/ 		var moduleOutdatedDependencies;
/******/ 		for(moduleId in outdatedDependencies) {
/******/ 			if(Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) {
/******/ 				module = installedModules[moduleId];
/******/ 				if(module) {
/******/ 					moduleOutdatedDependencies = outdatedDependencies[moduleId];
/******/ 					for(j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 						dependency = moduleOutdatedDependencies[j];
/******/ 						idx = module.children.indexOf(dependency);
/******/ 						if(idx >= 0) module.children.splice(idx, 1);
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// Not in "apply" phase
/******/ 		hotSetStatus("apply");
/******/ 	
/******/ 		hotCurrentHash = hotUpdateNewHash;
/******/ 	
/******/ 		// insert new code
/******/ 		for(moduleId in appliedUpdate) {
/******/ 			if(Object.prototype.hasOwnProperty.call(appliedUpdate, moduleId)) {
/******/ 				modules[moduleId] = appliedUpdate[moduleId];
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// call accept handlers
/******/ 		var error = null;
/******/ 		for(moduleId in outdatedDependencies) {
/******/ 			if(Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) {
/******/ 				module = installedModules[moduleId];
/******/ 				moduleOutdatedDependencies = outdatedDependencies[moduleId];
/******/ 				var callbacks = [];
/******/ 				for(i = 0; i < moduleOutdatedDependencies.length; i++) {
/******/ 					dependency = moduleOutdatedDependencies[i];
/******/ 					cb = module.hot._acceptedDependencies[dependency];
/******/ 					if(callbacks.indexOf(cb) >= 0) continue;
/******/ 					callbacks.push(cb);
/******/ 				}
/******/ 				for(i = 0; i < callbacks.length; i++) {
/******/ 					cb = callbacks[i];
/******/ 					try {
/******/ 						cb(moduleOutdatedDependencies);
/******/ 					} catch(err) {
/******/ 						if(options.onErrored) {
/******/ 							options.onErrored({
/******/ 								type: "accept-errored",
/******/ 								moduleId: moduleId,
/******/ 								dependencyId: moduleOutdatedDependencies[i],
/******/ 								error: err
/******/ 							});
/******/ 						}
/******/ 						if(!options.ignoreErrored) {
/******/ 							if(!error)
/******/ 								error = err;
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// Load self accepted modules
/******/ 		for(i = 0; i < outdatedSelfAcceptedModules.length; i++) {
/******/ 			var item = outdatedSelfAcceptedModules[i];
/******/ 			moduleId = item.module;
/******/ 			hotCurrentParents = [moduleId];
/******/ 			try {
/******/ 				__webpack_require__(moduleId);
/******/ 			} catch(err) {
/******/ 				if(typeof item.errorHandler === "function") {
/******/ 					try {
/******/ 						item.errorHandler(err);
/******/ 					} catch(err2) {
/******/ 						if(options.onErrored) {
/******/ 							options.onErrored({
/******/ 								type: "self-accept-error-handler-errored",
/******/ 								moduleId: moduleId,
/******/ 								error: err2,
/******/ 								orginalError: err
/******/ 							});
/******/ 						}
/******/ 						if(!options.ignoreErrored) {
/******/ 							if(!error)
/******/ 								error = err2;
/******/ 						}
/******/ 						if(!error)
/******/ 							error = err;
/******/ 					}
/******/ 				} else {
/******/ 					if(options.onErrored) {
/******/ 						options.onErrored({
/******/ 							type: "self-accept-errored",
/******/ 							moduleId: moduleId,
/******/ 							error: err
/******/ 						});
/******/ 					}
/******/ 					if(!options.ignoreErrored) {
/******/ 						if(!error)
/******/ 							error = err;
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// handle errors in accept handlers and self accepted module load
/******/ 		if(error) {
/******/ 			hotSetStatus("fail");
/******/ 			return Promise.reject(error);
/******/ 		}
/******/ 	
/******/ 		hotSetStatus("idle");
/******/ 		return new Promise(function(resolve) {
/******/ 			resolve(outdatedModules);
/******/ 		});
/******/ 	}
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {},
/******/ 			hot: hotCreateModule(moduleId),
/******/ 			parents: (hotCurrentParentsTemp = hotCurrentParents, hotCurrentParents = [], hotCurrentParentsTemp),
/******/ 			children: []
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, hotCreateRequire(moduleId));
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// __webpack_hash__
/******/ 	__webpack_require__.h = function() { return hotCurrentHash; };
/******/
/******/ 	// Load entry module and return exports
/******/ 	return hotCreateRequire(13)(__webpack_require__.s = 13);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

/**
 * @class Common utilities
 * @name glMatrix
 */
var glMatrix = {};

// Configuration Constants
glMatrix.EPSILON = 0.000001;
glMatrix.ARRAY_TYPE = (typeof Float32Array !== 'undefined') ? Float32Array : Array;
glMatrix.RANDOM = Math.random;
glMatrix.ENABLE_SIMD = false;

// Capability detection
glMatrix.SIMD_AVAILABLE = (glMatrix.ARRAY_TYPE === Float32Array) && ('SIMD' in this);
glMatrix.USE_SIMD = glMatrix.ENABLE_SIMD && glMatrix.SIMD_AVAILABLE;

/**
 * Sets the type of array used when creating new vectors and matrices
 *
 * @param {Type} type Array type, such as Float32Array or Array
 */
glMatrix.setMatrixArrayType = function(type) {
    glMatrix.ARRAY_TYPE = type;
}

var degree = Math.PI / 180;

/**
* Convert Degree To Radian
*
* @param {Number} Angle in Degrees
*/
glMatrix.toRadian = function(a){
     return a * degree;
}

/**
 * Tests whether or not the arguments have approximately the same value, within an absolute
 * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less 
 * than or equal to 1.0, and a relative tolerance is used for larger values)
 * 
 * @param {Number} a The first number to test.
 * @param {Number} b The second number to test.
 * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
 */
glMatrix.equals = function(a, b) {
	return Math.abs(a - b) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a), Math.abs(b));
}

module.exports = glMatrix;


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 * 
 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 * 
 * All rights reserved.
 * 
 * Distributed under the 3-clause BSD License, see LICENSE.txt
 */



/**
 * The following functions operate on "Point" or any "Point like" object with {x,y},
 * as defined by the {@link XY} type
 * ([duck typing]{@link http://en.wikipedia.org/wiki/Duck_typing}).
 * @module
 * @private
 */

/**
 * poly2tri.js supports using custom point class instead of {@linkcode Point}.
 * Any "Point like" object with <code>{x, y}</code> attributes is supported
 * to initialize the SweepContext polylines and points
 * ([duck typing]{@link http://en.wikipedia.org/wiki/Duck_typing}).
 *
 * poly2tri.js might add extra fields to the point objects when computing the
 * triangulation : they are prefixed with <code>_p2t_</code> to avoid collisions
 * with fields in the custom class.
 *
 * @example
 *      var contour = [{x:100, y:100}, {x:100, y:300}, {x:300, y:300}, {x:300, y:100}];
 *      var swctx = new poly2tri.SweepContext(contour);
 *
 * @typedef {Object} XY
 * @property {number} x - x coordinate
 * @property {number} y - y coordinate
 */


/**
 * Point pretty printing : prints x and y coordinates.
 * @example
 *      xy.toStringBase({x:5, y:42})
 *      // → "(5;42)"
 * @protected
 * @param {!XY} p - point object with {x,y}
 * @returns {string} <code>"(x;y)"</code>
 */
function toStringBase(p) {
    return ("(" + p.x + ";" + p.y + ")");
}

/**
 * Point pretty printing. Delegates to the point's custom "toString()" method if exists,
 * else simply prints x and y coordinates.
 * @example
 *      xy.toString({x:5, y:42})
 *      // → "(5;42)"
 * @example
 *      xy.toString({x:5,y:42,toString:function() {return this.x+":"+this.y;}})
 *      // → "5:42"
 * @param {!XY} p - point object with {x,y}
 * @returns {string} <code>"(x;y)"</code>
 */
function toString(p) {
    // Try a custom toString first, and fallback to own implementation if none
    var s = p.toString();
    return (s === '[object Object]' ? toStringBase(p) : s);
}


/**
 * Compare two points component-wise. Ordered by y axis first, then x axis.
 * @param {!XY} a - point object with {x,y}
 * @param {!XY} b - point object with {x,y}
 * @return {number} <code>&lt; 0</code> if <code>a &lt; b</code>,
 *         <code>&gt; 0</code> if <code>a &gt; b</code>, 
 *         <code>0</code> otherwise.
 */
function compare(a, b) {
    if (a.y === b.y) {
        return a.x - b.x;
    } else {
        return a.y - b.y;
    }
}

/**
 * Test two Point objects for equality.
 * @param {!XY} a - point object with {x,y}
 * @param {!XY} b - point object with {x,y}
 * @return {boolean} <code>True</code> if <code>a == b</code>, <code>false</code> otherwise.
 */
function equals(a, b) {
    return a.x === b.x && a.y === b.y;
}


module.exports = {
    toString: toString,
    toStringBase: toStringBase,
    compare: compare,
    equals: equals
};


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright 2014-2016 Todd Fleming
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
// 
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

// TODO: pass React elements to alertFn



Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.arcTolerance = exports.cleanPolyDist = exports.clipperToCppScale = exports.mmToClipperScale = exports.inchToClipperScale = undefined;
exports.elementToRawPaths = elementToRawPaths;
exports.pathStrToRawPaths = pathStrToRawPaths;
exports.flipY = flipY;
exports.hasClosedRawPaths = hasClosedRawPaths;
exports.filterClosedRawPaths = filterClosedRawPaths;
exports.rawPathsToClipperPaths = rawPathsToClipperPaths;
exports.triangulateRawPaths = triangulateRawPaths;
exports.clipperPathsToCPaths = clipperPathsToCPaths;
exports.cPathsToClipperPaths = cPathsToClipperPaths;
exports.cPathsToCamPaths = cPathsToCamPaths;
exports.clipperBounds = clipperBounds;
exports.clip = clip;
exports.union = union;
exports.diff = diff;
exports.xor = xor;
exports.offset = offset;

var _clipperLib = __webpack_require__(3);

var _clipperLib2 = _interopRequireDefault(_clipperLib);

var _sweepcontext = __webpack_require__(23);

var _sweepcontext2 = _interopRequireDefault(_sweepcontext);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const inchToClipperScale = exports.inchToClipperScale = 1270000000;
const mmToClipperScale = exports.mmToClipperScale = inchToClipperScale / 25.4; // 50000000;
const clipperToCppScale = exports.clipperToCppScale = 1 / 128; // Prevent overflow for coordinates up to ~1000 mm
const cleanPolyDist = exports.cleanPolyDist = 100;
const arcTolerance = exports.arcTolerance = 10000;

// Linearize a cubic bezier. Returns ['L', x2, y2, x3, y3, ...]. The return value doesn't
// include (p1x, p1y); it's part of the previous segment.
function linearizeCubicBezier(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, minNumSegments, minSegmentLength) {
    function bez(p0, p1, p2, p3, t) {
        return (1 - t) * (1 - t) * (1 - t) * p0 + 3 * (1 - t) * (1 - t) * t * p1 + 3 * (1 - t) * t * t * p2 + t * t * t * p3;
    }

    if (p1x == c1x && p1y == c1y && p2x == c2x && p2y == c2y) return ['L', p2x, p2y];

    let numSegments = minNumSegments;
    while (true) {
        let x = p1x;
        let y = p1y;
        let result = ['L'];
        for (let i = 1; i <= numSegments; ++i) {
            let t = 1.0 * i / numSegments;
            let nextX = bez(p1x, c1x, c2x, p2x, t);
            let nextY = bez(p1y, c1y, c2y, p2y, t);
            if ((nextX - x) * (nextX - x) + (nextY - y) * (nextY - y) > minSegmentLength * minSegmentLength) {
                numSegments *= 2;
                result = null;
                break;
            }
            result.push(nextX, nextY);
            x = nextX;
            y = nextY;
        }
        if (result) return result;
    }
}

// Linearize a path. Both the input path and the returned path are in snap.svg's format.
// Calls alertFn with an error message and returns null if there's a problem.
function linearizeSnapPath(path, minNumSegments, minSegmentLength, alertFn) {
    if (path.length < 2 || path[0].length != 3 || path[0][0] != 'M') {
        alertFn('Path does not begin with M');
        return null;
    }
    let x = path[0][1];
    let y = path[0][2];
    let result = [path[0]];
    for (let i = 1; i < path.length; ++i) {
        let subpath = path[i];
        if (subpath[0] == 'C' && subpath.length == 7) {
            result.push(linearizeCubicBezier(x, y, subpath[1], subpath[2], subpath[3], subpath[4], subpath[5], subpath[6], minNumSegments, minSegmentLength));
            x = subpath[5];
            y = subpath[6];
        } else if (subpath[0] == 'M' && subpath.length == 3) {
            result.push(subpath);
            x = subpath[1];
            y = subpath[2];
        } else {
            alertFn('Subpath has an unknown prefix: ' + subpath[0]);
            return null;
        }
    }
    return result;
};

// Get linear paths (snap format) from an SVG element. Calls alertFn with an 
// error message and returns null if there's a problem.
function elementToLinearSnapPaths(element, minNumSegments, minSegmentLength, alertFn) {
    let path = null;
    let Snap = __webpack_require__(7);
    let snapElement = Snap(element);

    if (snapElement.type == 'path') path = snapElement.attr('d');else if (snapElement.type == 'rect') {
        let x = Number(snapElement.attr('x'));
        let y = Number(snapElement.attr('y'));
        let w = Number(snapElement.attr('width'));
        let h = Number(snapElement.attr('height'));
        path = 'm' + x + ',' + y + ' ' + w + ',' + 0 + ' ' + 0 + ',' + h + ' ' + -w + ',' + 0 + ' ' + 0 + ',' + -h + ' ';
    } else {
        alertFn('<b>' + snapElement.type + "</b> is not supported; try Inkscape's <strong>Object to Path</strong> command");
        return null;
    }

    if (snapElement.attr('clip-path') != '') {
        alertFn('clip-path is not supported');
        return null;
    }

    if (snapElement.attr('mask') != '') {
        alertFn('mask is not supported');
        return null;
    }

    if (path == null) {
        alertFn('path is missing');
        return;
    }

    path = Snap.path.map(path, snapElement.transform().globalMatrix);
    path = Snap.parsePathString(path);
    path = linearizeSnapPath(path, minNumSegments, minSegmentLength, alertFn);
    return path;
};

// Convert a path in snap.svg format to [[x0, y0, x1, y1, ...], ...].
// Result is in mm. Returns multiple paths. Only supports linear paths.
// Calls alertFn with an error message and returns null if there's a problem.
function snapPathToRawPaths(snapPath, pxPerInch, alertFn) {
    let factor = 25.4 / pxPerInch;
    if (snapPath.length < 2 || snapPath[0].length != 3 || snapPath[0][0] != 'M') {
        alertFn('Path does not begin with M');
        return null;
    }
    let currentPath = [snapPath[0][1] * factor, snapPath[0][2] * factor];
    let result = [currentPath];
    for (let i = 1; i < snapPath.length; ++i) {
        let subpath = snapPath[i];
        if (subpath[0] == 'M' && subpath.length == 3) {
            currentPath = [subpath[1] * factor, subpath[2] * factor];
            result.push(currentPath);
        } else if (subpath[0] == 'L') {
            for (let j = 0; j < (subpath.length - 1) / 2; ++j) currentPath.push(subpath[1 + j * 2] * factor, subpath[2 + j * 2] * factor);
        } else {
            alertFn('Subpath has a non-linear prefix: ' + subpath[0]);
            return null;
        }
    }
    return result;
};

// Convert a path in an SVG element to [[x0, y0, x1, y1, ...], ...].
// Result is in mm. Returns multiple paths. Converts curves.
// Calls alertFn with an error message and returns null if there's a problem.
function elementToRawPaths(element, pxPerInch, minNumSegments, minSegmentLength, alertFn) {
    let path = elementToLinearSnapPaths(element, minNumSegments, minSegmentLength, alertFn);
    if (path !== null) return snapPathToRawPaths(path, pxPerInch, alertFn);
    return null;
}

// Convert an SVG path string to [[x0, y0, x1, y1, ...], ...].
// Result is in mm. Returns multiple paths. Converts curves.
// Calls alertFn with an error message and returns null if there's a problem.
function pathStrToRawPaths(str, pxPerInch, minNumSegments, minSegmentLength, alertFn) {
    let Snap = __webpack_require__(7);
    let path = Snap.parsePathString(str);
    path = Snap.path.toCubic(path);
    path = linearizeSnapPath(path, minNumSegments, minSegmentLength, alertFn);
    if (path !== null) return snapPathToRawPaths(path, pxPerInch, alertFn);
    return null;
}

// [[[x0, y0, x1, y1, ...], ...], ...]
function flipY(allRawPaths, deltaY) {
    for (let rawPaths of allRawPaths) for (let rawPath of rawPaths) for (let i = 0; i < rawPath.length; i += 2) rawPath[i + 1] = deltaY - rawPath[i + 1];
}

function hasClosedRawPaths(rawPaths) {
    for (let path of rawPaths) if (path.length >= 4 && path[0] == path[path.length - 2] && path[1] == path[path.length - 1]) return true;
    return false;
}

function filterClosedRawPaths(rawPaths) {
    let result = [];
    for (let path of rawPaths) if (path.length >= 4 && path[0] == path[path.length - 2] && path[1] == path[path.length - 1]) result.push(path);
    return result;
}

function rawPathsToClipperPaths(rawPaths, transform) {
    let result = rawPaths.map(p => {
        let result = [];
        for (let i = 0; i < p.length; i += 2) {
            result.push({
                X: (transform[0] * p[i] + transform[2] * p[i + 1] + transform[4]) * mmToClipperScale,
                Y: (transform[1] * p[i] + transform[3] * p[i + 1] + transform[5]) * mmToClipperScale
            });
        }
        return result;
    });
    if (hasClosedRawPaths(rawPaths)) {
        result = _clipperLib2.default.Clipper.CleanPolygons(result, cleanPolyDist);
        result = _clipperLib2.default.Clipper.SimplifyPolygons(result, _clipperLib2.default.PolyFillType.pftEvenOdd);
    }
    return result;
}

function clipperPathsToPolyTree(paths) {
    let c = new _clipperLib2.default.Clipper();
    c.AddPaths(paths, _clipperLib2.default.PolyType.ptSubject, true);
    let polyTree = new _clipperLib2.default.PolyTree();
    c.Execute(_clipperLib2.default.ClipType.ctUnion, polyTree, _clipperLib2.default.PolyFillType.pftEvenOdd, _clipperLib2.default.PolyFillType.pftEvenOdd);
    return polyTree;
}

function triangulatePolyTree(polyTree) {
    let result = [];
    let pointToVertex = point => ({ x: point.X / mmToClipperScale, y: point.Y / mmToClipperScale });
    let contourToVertexes = path => path.map(pointToVertex);
    let nodesToVertexes = nodes => nodes.map(node => contourToVertexes(node.Contour()));
    let processNode = node => {
        let vertexes = contourToVertexes(node.Contour());
        let holes = nodesToVertexes(node.Childs());
        let context = new _sweepcontext2.default(vertexes);
        context.addHoles(holes);
        context.triangulate();
        let triangles = context.getTriangles();
        for (let t of triangles) {
            let p = t.getPoints();
            result.push(p[0].x, p[0].y, p[1].x, p[1].y, p[2].x, p[2].y);
        }
        for (let hole of node.Childs()) {
            for (let next of hole.Childs()) {
                processNode(next);
            }
        }
    };
    for (let node of polyTree.Childs()) {
        processNode(node);
    }
    return result;
}

function triangulateRawPaths(rawPaths) {
    return triangulatePolyTree(clipperPathsToPolyTree(rawPathsToClipperPaths(rawPaths, [1, 0, 0, 1, 0, 0])));
}

// Convert Clipper paths to C. Returns [double** cPaths, int cNumPaths, int* cPathSizes].
function clipperPathsToCPaths(memoryBlocks, clipperPaths) {
    let doubleSize = 8;

    let cPaths = Module._malloc(clipperPaths.length * 4);
    memoryBlocks.push(cPaths);
    let cPathsBase = cPaths >> 2;

    let cPathSizes = Module._malloc(clipperPaths.length * 4);
    memoryBlocks.push(cPathSizes);
    let cPathSizesBase = cPathSizes >> 2;

    for (let i = 0; i < clipperPaths.length; ++i) {
        let clipperPath = clipperPaths[i];

        let cPath = Module._malloc(clipperPath.length * 2 * doubleSize + 4);
        memoryBlocks.push(cPath);
        if (cPath & 4) cPath += 4;
        //console.log("-> " + cPath.toString(16));
        let pathArray = new Float64Array(Module.HEAPU32.buffer, Module.HEAPU32.byteOffset + cPath);

        for (let j = 0; j < clipperPath.length; ++j) {
            let point = clipperPath[j];
            pathArray[j * 2] = point.X * clipperToCppScale;
            pathArray[j * 2 + 1] = point.Y * clipperToCppScale;
        }

        Module.HEAPU32[cPathsBase + i] = cPath;
        Module.HEAPU32[cPathSizesBase + i] = clipperPath.length;
    }

    return [cPaths, clipperPaths.length, cPathSizes];
}

// Convert C paths to Clipper paths. double**& cPathsRef, int& cNumPathsRef, int*& cPathSizesRef
// Each point has X, Y (stride = 2).
function cPathsToClipperPaths(memoryBlocks, cPathsRef, cNumPathsRef, cPathSizesRef) {
    let cPaths = Module.HEAPU32[cPathsRef >> 2];
    memoryBlocks.push(cPaths);
    let cPathsBase = cPaths >> 2;

    let cNumPaths = Module.HEAPU32[cNumPathsRef >> 2];

    let cPathSizes = Module.HEAPU32[cPathSizesRef >> 2];
    memoryBlocks.push(cPathSizes);
    let cPathSizesBase = cPathSizes >> 2;

    let clipperPaths = [];
    for (let i = 0; i < cNumPaths; ++i) {
        let pathSize = Module.HEAPU32[cPathSizesBase + i];
        let cPath = Module.HEAPU32[cPathsBase + i];
        // cPath contains value to pass to Module._free(). The aligned version contains the actual data.
        memoryBlocks.push(cPath);
        if (cPath & 4) cPath += 4;
        let pathArray = new Float64Array(Module.HEAPU32.buffer, Module.HEAPU32.byteOffset + cPath);

        let clipperPath = [];
        clipperPaths.push(clipperPath);
        for (let j = 0; j < pathSize; ++j) clipperPath.push({
            X: pathArray[j * 2] / clipperToCppScale,
            Y: pathArray[j * 2 + 1] / clipperToCppScale
        });
    }

    return clipperPaths;
}

// Convert C paths to array of CamPath. double**& cPathsRef, int& cNumPathsRef, int*& cPathSizesRef
// Each point has X, Y, Z (stride = 3).
function cPathsToCamPaths(memoryBlocks, cPathsRef, cNumPathsRef, cPathSizesRef) {
    let cPaths = Module.HEAPU32[cPathsRef >> 2];
    memoryBlocks.push(cPaths);
    let cPathsBase = cPaths >> 2;

    let cNumPaths = Module.HEAPU32[cNumPathsRef >> 2];

    let cPathSizes = Module.HEAPU32[cPathSizesRef >> 2];
    memoryBlocks.push(cPathSizes);
    let cPathSizesBase = cPathSizes >> 2;

    let convertedPaths = [];
    for (let i = 0; i < cNumPaths; ++i) {
        let pathSize = Module.HEAPU32[cPathSizesBase + i];
        let cPath = Module.HEAPU32[cPathsBase + i];
        // cPath contains value to pass to Module._free(). The aligned version contains the actual data.
        memoryBlocks.push(cPath);
        if (cPath & 4) cPath += 4;
        let pathArray = new Float64Array(Module.HEAPU32.buffer, Module.HEAPU32.byteOffset + cPath);

        let convertedPath = [];
        convertedPaths.push({ path: convertedPath, safeToClose: false });
        for (let j = 0; j < pathSize; ++j) convertedPath.push({
            X: pathArray[j * 3] / clipperToCppScale,
            Y: pathArray[j * 3 + 1] / clipperToCppScale,
            Z: pathArray[j * 3 + 2] / clipperToCppScale
        });

        //console.log('got: path', i, ':', pathArray[0], pathArray[1], pathArray[2]);
    }

    return convertedPaths;
}

function clipperBounds(paths) {
    let minX = Number.MAX_VALUE;
    let minY = Number.MAX_VALUE;
    let maxX = -Number.MAX_VALUE;
    let maxY = -Number.MAX_VALUE;
    for (let path of paths) {
        for (let pt of path) {
            minX = Math.min(minX, pt.X);
            maxX = Math.max(maxX, pt.X);
            minY = Math.min(minY, pt.Y);
            maxY = Math.max(maxY, pt.Y);
        }
    }
    return { minX, minY, maxX, maxY };
}

// Clip Clipper geometry. clipType is a ClipperLib.ClipType constant. Returns new geometry.
function clip(paths1, paths2, clipType) {
    var clipper = new _clipperLib2.default.Clipper();
    clipper.AddPaths(paths1, _clipperLib2.default.PolyType.ptSubject, true);
    clipper.AddPaths(paths2, _clipperLib2.default.PolyType.ptClip, true);
    var result = [];
    clipper.Execute(clipType, result, _clipperLib2.default.PolyFillType.pftEvenOdd, _clipperLib2.default.PolyFillType.pftEvenOdd);
    return result;
}

// Return union of two Clipper geometries. Returns new geometry.
function union(paths1, paths2) {
    return clip(paths1, paths2, _clipperLib2.default.ClipType.ctUnion);
}

// Return difference between two Clipper geometries. Returns new geometry.
function diff(paths1, paths2) {
    return clip(paths1, paths2, _clipperLib2.default.ClipType.ctDifference);
}

// Return xor of two Clipper geometries. Returns new geometry.
function xor(paths1, paths2) {
    return clip(paths1, paths2, _clipperLib2.default.ClipType.ctXor);
}

// Offset Clipper geometries by amount (positive expands, negative shrinks). Returns new geometry.
function offset(paths, amount, joinType, endType) {
    if (joinType === undefined) joinType = _clipperLib2.default.JoinType.jtRound;
    if (endType === undefined) endType = _clipperLib2.default.EndType.etClosedPolygon;

    // bug workaround: join types are swapped in ClipperLib 6.1.3.2
    if (joinType === _clipperLib2.default.JoinType.jtSquare) joinType = _clipperLib2.default.JoinType.jtMiter;else if (joinType === _clipperLib2.default.JoinType.jtMiter) joinType = _clipperLib2.default.JoinType.jtSquare;

    var co = new _clipperLib2.default.ClipperOffset(2, arcTolerance);
    co.AddPaths(paths, joinType, endType);
    var offsetted = [];
    co.Execute(offsetted, amount);
    return offsetted;
}
;

var _temp = function () {
    if (typeof __REACT_HOT_LOADER__ === 'undefined') {
        return;
    }

    __REACT_HOT_LOADER__.register(inchToClipperScale, 'inchToClipperScale', 'C:/Users/cprez/git/LaserWeb/LaserWeb4/src/lib/mesh.js');

    __REACT_HOT_LOADER__.register(mmToClipperScale, 'mmToClipperScale', 'C:/Users/cprez/git/LaserWeb/LaserWeb4/src/lib/mesh.js');

    __REACT_HOT_LOADER__.register(clipperToCppScale, 'clipperToCppScale', 'C:/Users/cprez/git/LaserWeb/LaserWeb4/src/lib/mesh.js');

    __REACT_HOT_LOADER__.register(cleanPolyDist, 'cleanPolyDist', 'C:/Users/cprez/git/LaserWeb/LaserWeb4/src/lib/mesh.js');

    __REACT_HOT_LOADER__.register(arcTolerance, 'arcTolerance', 'C:/Users/cprez/git/LaserWeb/LaserWeb4/src/lib/mesh.js');

    __REACT_HOT_LOADER__.register(linearizeCubicBezier, 'linearizeCubicBezier', 'C:/Users/cprez/git/LaserWeb/LaserWeb4/src/lib/mesh.js');

    __REACT_HOT_LOADER__.register(linearizeSnapPath, 'linearizeSnapPath', 'C:/Users/cprez/git/LaserWeb/LaserWeb4/src/lib/mesh.js');

    __REACT_HOT_LOADER__.register(elementToLinearSnapPaths, 'elementToLinearSnapPaths', 'C:/Users/cprez/git/LaserWeb/LaserWeb4/src/lib/mesh.js');

    __REACT_HOT_LOADER__.register(snapPathToRawPaths, 'snapPathToRawPaths', 'C:/Users/cprez/git/LaserWeb/LaserWeb4/src/lib/mesh.js');

    __REACT_HOT_LOADER__.register(elementToRawPaths, 'elementToRawPaths', 'C:/Users/cprez/git/LaserWeb/LaserWeb4/src/lib/mesh.js');

    __REACT_HOT_LOADER__.register(pathStrToRawPaths, 'pathStrToRawPaths', 'C:/Users/cprez/git/LaserWeb/LaserWeb4/src/lib/mesh.js');

    __REACT_HOT_LOADER__.register(flipY, 'flipY', 'C:/Users/cprez/git/LaserWeb/LaserWeb4/src/lib/mesh.js');

    __REACT_HOT_LOADER__.register(hasClosedRawPaths, 'hasClosedRawPaths', 'C:/Users/cprez/git/LaserWeb/LaserWeb4/src/lib/mesh.js');

    __REACT_HOT_LOADER__.register(filterClosedRawPaths, 'filterClosedRawPaths', 'C:/Users/cprez/git/LaserWeb/LaserWeb4/src/lib/mesh.js');

    __REACT_HOT_LOADER__.register(rawPathsToClipperPaths, 'rawPathsToClipperPaths', 'C:/Users/cprez/git/LaserWeb/LaserWeb4/src/lib/mesh.js');

    __REACT_HOT_LOADER__.register(clipperPathsToPolyTree, 'clipperPathsToPolyTree', 'C:/Users/cprez/git/LaserWeb/LaserWeb4/src/lib/mesh.js');

    __REACT_HOT_LOADER__.register(triangulatePolyTree, 'triangulatePolyTree', 'C:/Users/cprez/git/LaserWeb/LaserWeb4/src/lib/mesh.js');

    __REACT_HOT_LOADER__.register(triangulateRawPaths, 'triangulateRawPaths', 'C:/Users/cprez/git/LaserWeb/LaserWeb4/src/lib/mesh.js');

    __REACT_HOT_LOADER__.register(clipperPathsToCPaths, 'clipperPathsToCPaths', 'C:/Users/cprez/git/LaserWeb/LaserWeb4/src/lib/mesh.js');

    __REACT_HOT_LOADER__.register(cPathsToClipperPaths, 'cPathsToClipperPaths', 'C:/Users/cprez/git/LaserWeb/LaserWeb4/src/lib/mesh.js');

    __REACT_HOT_LOADER__.register(cPathsToCamPaths, 'cPathsToCamPaths', 'C:/Users/cprez/git/LaserWeb/LaserWeb4/src/lib/mesh.js');

    __REACT_HOT_LOADER__.register(clipperBounds, 'clipperBounds', 'C:/Users/cprez/git/LaserWeb/LaserWeb4/src/lib/mesh.js');

    __REACT_HOT_LOADER__.register(clip, 'clip', 'C:/Users/cprez/git/LaserWeb/LaserWeb4/src/lib/mesh.js');

    __REACT_HOT_LOADER__.register(union, 'union', 'C:/Users/cprez/git/LaserWeb/LaserWeb4/src/lib/mesh.js');

    __REACT_HOT_LOADER__.register(diff, 'diff', 'C:/Users/cprez/git/LaserWeb/LaserWeb4/src/lib/mesh.js');

    __REACT_HOT_LOADER__.register(xor, 'xor', 'C:/Users/cprez/git/LaserWeb/LaserWeb4/src/lib/mesh.js');

    __REACT_HOT_LOADER__.register(offset, 'offset', 'C:/Users/cprez/git/LaserWeb/LaserWeb4/src/lib/mesh.js');
}();

;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;// rev 482
/********************************************************************************
 *                                                                              *
 * Author    :  Angus Johnson                                                   *
 * Version   :  6.2.1                                                          *
 * Date      :  31 October 2014                                                 *
 * Website   :  http://www.angusj.com                                           *
 * Copyright :  Angus Johnson 2010-2014                                         *
 *                                                                              *
 * License:                                                                     *
 * Use, modification & distribution is subject to Boost Software License Ver 1. *
 * http://www.boost.org/LICENSE_1_0.txt                                         *
 *                                                                              *
 * Attributions:                                                                *
 * The code in this library is an extension of Bala Vatti's clipping algorithm: *
 * "A generic solution to polygon clipping"                                     *
 * Communications of the ACM, Vol 35, Issue 7 (July 1992) pp 56-63.             *
 * http://portal.acm.org/citation.cfm?id=129906                                 *
 *                                                                              *
 * Computer graphics and geometric modeling: implementation and algorithms      *
 * By Max K. Agoston                                                            *
 * Springer; 1 edition (January 4, 2005)                                        *
 * http://books.google.com/books?q=vatti+clipping+agoston                       *
 *                                                                              *
 * See also:                                                                    *
 * "Polygon Offsetting by Computing Winding Numbers"                            *
 * Paper no. DETC2005-85513 pp. 565-575                                         *
 * ASME 2005 International Design Engineering Technical Conferences             *
 * and Computers and Information in Engineering Conference (IDETC/CIE2005)      *
 * September 24-28, 2005 , Long Beach, California, USA                          *
 * http://www.me.berkeley.edu/~mcmains/pubs/DAC05OffsetPolygon.pdf              *
 *                                                                              *
 *******************************************************************************/
/*******************************************************************************
 *                                                                              *
 * Author    :  Timo                                                            *
 * Version   :  6.2.1.0                                                         *
 * Date      :  17 June 2016                                                 *
 *                                                                              *
 * This is a translation of the C# Clipper library to Javascript.               *
 * Int128 struct of C# is implemented using JSBN of Tom Wu.                     *
 * Because Javascript lacks support for 64-bit integers, the space              *
 * is a little more restricted than in C# version.                              *
 *                                                                              *
 * C# version has support for coordinate space:                                 *
 * +-4611686018427387903 ( sqrt(2^127 -1)/2 )                                   *
 * while Javascript version has support for space:                              *
 * +-4503599627370495 ( sqrt(2^106 -1)/2 )                                      *
 *                                                                              *
 * Tom Wu's JSBN proved to be the fastest big integer library:                  *
 * http://jsperf.com/big-integer-library-test                                   *
 *                                                                              *
 * This class can be made simpler when (if ever) 64-bit integer support comes.  *
 *                                                                              *
 *******************************************************************************/
/*******************************************************************************
 *                                                                              *
 * Basic JavaScript BN library - subset useful for RSA encryption.              *
 * http://www-cs-students.stanford.edu/~tjw/jsbn/                               *
 * Copyright (c) 2005  Tom Wu                                                   *
 * All Rights Reserved.                                                         *
 * See "LICENSE" for details:                                                   *
 * http://www-cs-students.stanford.edu/~tjw/jsbn/LICENSE                        *
 *                                                                              *
 *******************************************************************************/
(function ()
{
  "use strict";
  //use_int32: When enabled 32bit ints are used instead of 64bit ints. This
  //improve performance but coordinate values are limited to the range +/- 46340
  var use_int32 = false;
  //use_xyz: adds a Z member to IntPoint. Adds a minor cost to performance.
  var use_xyz = false;
  //UseLines: Enables open path clipping. Adds a very minor cost to performance.
  var use_lines = true;

  var ClipperLib = {};
  var isNode = false;
  if (typeof module !== 'undefined' && module.exports)
  {
    module.exports = ClipperLib;
    isNode = true;
  }
  else
  {
    if (true) {
      !(__WEBPACK_AMD_DEFINE_FACTORY__ = (ClipperLib),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    }
    if (typeof (document) !== "undefined") window.ClipperLib = ClipperLib;
    else self['ClipperLib'] = ClipperLib;
  }
  var navigator_appName;
  if (!isNode)
  {
    var nav = navigator.userAgent.toString().toLowerCase();
    navigator_appName = navigator.appName;
  }
  else
  {
    var nav = "chrome"; // Node.js uses Chrome's V8 engine
    navigator_appName = "Netscape"; // Firefox, Chrome and Safari returns "Netscape", so Node.js should also
  }
  // Browser test to speedup performance critical functions
  var browser = {};
  if (nav.indexOf("chrome") != -1 && nav.indexOf("chromium") == -1) browser.chrome = 1;
  else browser.chrome = 0;
  if (nav.indexOf("chromium") != -1) browser.chromium = 1;
  else browser.chromium = 0;
  if (nav.indexOf("safari") != -1 && nav.indexOf("chrome") == -1 && nav.indexOf("chromium") == -1) browser.safari = 1;
  else browser.safari = 0;
  if (nav.indexOf("firefox") != -1) browser.firefox = 1;
  else browser.firefox = 0;
  if (nav.indexOf("firefox/17") != -1) browser.firefox17 = 1;
  else browser.firefox17 = 0;
  if (nav.indexOf("firefox/15") != -1) browser.firefox15 = 1;
  else browser.firefox15 = 0;
  if (nav.indexOf("firefox/3") != -1) browser.firefox3 = 1;
  else browser.firefox3 = 0;
  if (nav.indexOf("opera") != -1) browser.opera = 1;
  else browser.opera = 0;
  if (nav.indexOf("msie 10") != -1) browser.msie10 = 1;
  else browser.msie10 = 0;
  if (nav.indexOf("msie 9") != -1) browser.msie9 = 1;
  else browser.msie9 = 0;
  if (nav.indexOf("msie 8") != -1) browser.msie8 = 1;
  else browser.msie8 = 0;
  if (nav.indexOf("msie 7") != -1) browser.msie7 = 1;
  else browser.msie7 = 0;
  if (nav.indexOf("msie ") != -1) browser.msie = 1;
  else browser.msie = 0;
  ClipperLib.biginteger_used = null;

  // Copyright (c) 2005  Tom Wu
  // All Rights Reserved.
  // See "LICENSE" for details.
  // Basic JavaScript BN library - subset useful for RSA encryption.
  // Bits per digit
  var dbits;
  // JavaScript engine analysis
  var canary = 0xdeadbeefcafe;
  var j_lm = ((canary & 0xffffff) == 0xefcafe);
  // (public) Constructor
  function BigInteger(a, b, c)
  {
    // This test variable can be removed,
    // but at least for performance tests it is useful piece of knowledge
    // This is the only ClipperLib related variable in BigInteger library
    ClipperLib.biginteger_used = 1;
    if (a != null)
      if ("number" == typeof a && "undefined" == typeof (b)) this.fromInt(a); // faster conversion
      else if ("number" == typeof a) this.fromNumber(a, b, c);
    else if (b == null && "string" != typeof a) this.fromString(a, 256);
    else this.fromString(a, b);
  }
  // return new, unset BigInteger
  function nbi()
  {
    return new BigInteger(null,undefined,undefined);
  }
  // am: Compute w_j += (x*this_i), propagate carries,
  // c is initial carry, returns final carry.
  // c < 3*dvalue, x < 2*dvalue, this_i < dvalue
  // We need to select the fastest one that works in this environment.
  // am1: use a single mult and divide to get the high bits,
  // max digit bits should be 26 because
  // max internal value = 2*dvalue^2-2*dvalue (< 2^53)
  function am1(i, x, w, j, c, n)
  {
    while (--n >= 0)
    {
      var v = x * this[i++] + w[j] + c;
      c = Math.floor(v / 0x4000000);
      w[j++] = v & 0x3ffffff;
    }
    return c;
  }
  // am2 avoids a big mult-and-extract completely.
  // Max digit bits should be <= 30 because we do bitwise ops
  // on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)
  function am2(i, x, w, j, c, n)
  {
    var xl = x & 0x7fff,
      xh = x >> 15;
    while (--n >= 0)
    {
      var l = this[i] & 0x7fff;
      var h = this[i++] >> 15;
      var m = xh * l + h * xl;
      l = xl * l + ((m & 0x7fff) << 15) + w[j] + (c & 0x3fffffff);
      c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);
      w[j++] = l & 0x3fffffff;
    }
    return c;
  }
  // Alternately, set max digit bits to 28 since some
  // browsers slow down when dealing with 32-bit numbers.
  function am3(i, x, w, j, c, n)
  {
    var xl = x & 0x3fff,
      xh = x >> 14;
    while (--n >= 0)
    {
      var l = this[i] & 0x3fff;
      var h = this[i++] >> 14;
      var m = xh * l + h * xl;
      l = xl * l + ((m & 0x3fff) << 14) + w[j] + c;
      c = (l >> 28) + (m >> 14) + xh * h;
      w[j++] = l & 0xfffffff;
    }
    return c;
  }
  if (j_lm && (navigator_appName == "Microsoft Internet Explorer"))
  {
    BigInteger.prototype.am = am2;
    dbits = 30;
  }
  else if (j_lm && (navigator_appName != "Netscape"))
  {
    BigInteger.prototype.am = am1;
    dbits = 26;
  }
  else
  { // Mozilla/Netscape seems to prefer am3
    BigInteger.prototype.am = am3;
    dbits = 28;
  }
  BigInteger.prototype.DB = dbits;
  BigInteger.prototype.DM = ((1 << dbits) - 1);
  BigInteger.prototype.DV = (1 << dbits);
  var BI_FP = 52;
  BigInteger.prototype.FV = Math.pow(2, BI_FP);
  BigInteger.prototype.F1 = BI_FP - dbits;
  BigInteger.prototype.F2 = 2 * dbits - BI_FP;
  // Digit conversions
  var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
  var BI_RC = new Array();
  var rr, vv;
  rr = "0".charCodeAt(0);
  for (vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;
  rr = "a".charCodeAt(0);
  for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
  rr = "A".charCodeAt(0);
  for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;

  function int2char(n)
  {
    return BI_RM.charAt(n);
  }

  function intAt(s, i)
  {
    var c = BI_RC[s.charCodeAt(i)];
    return (c == null) ? -1 : c;
  }
  // (protected) copy this to r
  function bnpCopyTo(r)
  {
    for (var i = this.t - 1; i >= 0; --i) r[i] = this[i];
    r.t = this.t;
    r.s = this.s;
  }
  // (protected) set from integer value x, -DV <= x < DV
  function bnpFromInt(x)
  {
    this.t = 1;
    this.s = (x < 0) ? -1 : 0;
    if (x > 0) this[0] = x;
    else if (x < -1) this[0] = x + this.DV;
    else this.t = 0;
  }
  // return bigint initialized to value
  function nbv(i)
  {
    var r = nbi();
    r.fromInt(i);
    return r;
  }
  // (protected) set from string and radix
  function bnpFromString(s, b)
  {
    var k;
    if (b == 16) k = 4;
    else if (b == 8) k = 3;
    else if (b == 256) k = 8; // byte array
    else if (b == 2) k = 1;
    else if (b == 32) k = 5;
    else if (b == 4) k = 2;
    else
    {
      this.fromRadix(s, b);
      return;
    }
    this.t = 0;
    this.s = 0;
    var i = s.length,
      mi = false,
      sh = 0;
    while (--i >= 0)
    {
      var x = (k == 8) ? s[i] & 0xff : intAt(s, i);
      if (x < 0)
      {
        if (s.charAt(i) == "-") mi = true;
        continue;
      }
      mi = false;
      if (sh == 0)
        this[this.t++] = x;
      else if (sh + k > this.DB)
      {
        this[this.t - 1] |= (x & ((1 << (this.DB - sh)) - 1)) << sh;
        this[this.t++] = (x >> (this.DB - sh));
      }
      else
        this[this.t - 1] |= x << sh;
      sh += k;
      if (sh >= this.DB) sh -= this.DB;
    }
    if (k == 8 && (s[0] & 0x80) != 0)
    {
      this.s = -1;
      if (sh > 0) this[this.t - 1] |= ((1 << (this.DB - sh)) - 1) << sh;
    }
    this.clamp();
    if (mi) BigInteger.ZERO.subTo(this, this);
  }
  // (protected) clamp off excess high words
  function bnpClamp()
  {
    var c = this.s & this.DM;
    while (this.t > 0 && this[this.t - 1] == c)--this.t;
  }
  // (public) return string representation in given radix
  function bnToString(b)
  {
    if (this.s < 0) return "-" + this.negate().toString(b);
    var k;
    if (b == 16) k = 4;
    else if (b == 8) k = 3;
    else if (b == 2) k = 1;
    else if (b == 32) k = 5;
    else if (b == 4) k = 2;
    else return this.toRadix(b);
    var km = (1 << k) - 1,
      d, m = false,
      r = "",
      i = this.t;
    var p = this.DB - (i * this.DB) % k;
    if (i-- > 0)
    {
      if (p < this.DB && (d = this[i] >> p) > 0)
      {
        m = true;
        r = int2char(d);
      }
      while (i >= 0)
      {
        if (p < k)
        {
          d = (this[i] & ((1 << p) - 1)) << (k - p);
          d |= this[--i] >> (p += this.DB - k);
        }
        else
        {
          d = (this[i] >> (p -= k)) & km;
          if (p <= 0)
          {
            p += this.DB;
            --i;
          }
        }
        if (d > 0) m = true;
        if (m) r += int2char(d);
      }
    }
    return m ? r : "0";
  }
  // (public) -this
  function bnNegate()
  {
    var r = nbi();
    BigInteger.ZERO.subTo(this, r);
    return r;
  }
  // (public) |this|
  function bnAbs()
  {
    return (this.s < 0) ? this.negate() : this;
  }
  // (public) return + if this > a, - if this < a, 0 if equal
  function bnCompareTo(a)
  {
    var r = this.s - a.s;
    if (r != 0) return r;
    var i = this.t;
    r = i - a.t;
    if (r != 0) return (this.s < 0) ? -r : r;
    while (--i >= 0)
      if ((r = this[i] - a[i]) != 0) return r;
    return 0;
  }
  // returns bit length of the integer x
  function nbits(x)
  {
    var r = 1,
      t;
    if ((t = x >>> 16) != 0)
    {
      x = t;
      r += 16;
    }
    if ((t = x >> 8) != 0)
    {
      x = t;
      r += 8;
    }
    if ((t = x >> 4) != 0)
    {
      x = t;
      r += 4;
    }
    if ((t = x >> 2) != 0)
    {
      x = t;
      r += 2;
    }
    if ((t = x >> 1) != 0)
    {
      x = t;
      r += 1;
    }
    return r;
  }
  // (public) return the number of bits in "this"
  function bnBitLength()
  {
    if (this.t <= 0) return 0;
    return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ (this.s & this.DM));
  }
  // (protected) r = this << n*DB
  function bnpDLShiftTo(n, r)
  {
    var i;
    for (i = this.t - 1; i >= 0; --i) r[i + n] = this[i];
    for (i = n - 1; i >= 0; --i) r[i] = 0;
    r.t = this.t + n;
    r.s = this.s;
  }
  // (protected) r = this >> n*DB
  function bnpDRShiftTo(n, r)
  {
    for (var i = n; i < this.t; ++i) r[i - n] = this[i];
    r.t = Math.max(this.t - n, 0);
    r.s = this.s;
  }
  // (protected) r = this << n
  function bnpLShiftTo(n, r)
  {
    var bs = n % this.DB;
    var cbs = this.DB - bs;
    var bm = (1 << cbs) - 1;
    var ds = Math.floor(n / this.DB),
      c = (this.s << bs) & this.DM,
      i;
    for (i = this.t - 1; i >= 0; --i)
    {
      r[i + ds + 1] = (this[i] >> cbs) | c;
      c = (this[i] & bm) << bs;
    }
    for (i = ds - 1; i >= 0; --i) r[i] = 0;
    r[ds] = c;
    r.t = this.t + ds + 1;
    r.s = this.s;
    r.clamp();
  }
  // (protected) r = this >> n
  function bnpRShiftTo(n, r)
  {
    r.s = this.s;
    var ds = Math.floor(n / this.DB);
    if (ds >= this.t)
    {
      r.t = 0;
      return;
    }
    var bs = n % this.DB;
    var cbs = this.DB - bs;
    var bm = (1 << bs) - 1;
    r[0] = this[ds] >> bs;
    for (var i = ds + 1; i < this.t; ++i)
    {
      r[i - ds - 1] |= (this[i] & bm) << cbs;
      r[i - ds] = this[i] >> bs;
    }
    if (bs > 0) r[this.t - ds - 1] |= (this.s & bm) << cbs;
    r.t = this.t - ds;
    r.clamp();
  }
  // (protected) r = this - a
  function bnpSubTo(a, r)
  {
    var i = 0,
      c = 0,
      m = Math.min(a.t, this.t);
    while (i < m)
    {
      c += this[i] - a[i];
      r[i++] = c & this.DM;
      c >>= this.DB;
    }
    if (a.t < this.t)
    {
      c -= a.s;
      while (i < this.t)
      {
        c += this[i];
        r[i++] = c & this.DM;
        c >>= this.DB;
      }
      c += this.s;
    }
    else
    {
      c += this.s;
      while (i < a.t)
      {
        c -= a[i];
        r[i++] = c & this.DM;
        c >>= this.DB;
      }
      c -= a.s;
    }
    r.s = (c < 0) ? -1 : 0;
    if (c < -1) r[i++] = this.DV + c;
    else if (c > 0) r[i++] = c;
    r.t = i;
    r.clamp();
  }
  // (protected) r = this * a, r != this,a (HAC 14.12)
  // "this" should be the larger one if appropriate.
  function bnpMultiplyTo(a, r)
  {
    var x = this.abs(),
      y = a.abs();
    var i = x.t;
    r.t = i + y.t;
    while (--i >= 0) r[i] = 0;
    for (i = 0; i < y.t; ++i) r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);
    r.s = 0;
    r.clamp();
    if (this.s != a.s) BigInteger.ZERO.subTo(r, r);
  }
  // (protected) r = this^2, r != this (HAC 14.16)
  function bnpSquareTo(r)
  {
    var x = this.abs();
    var i = r.t = 2 * x.t;
    while (--i >= 0) r[i] = 0;
    for (i = 0; i < x.t - 1; ++i)
    {
      var c = x.am(i, x[i], r, 2 * i, 0, 1);
      if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV)
      {
        r[i + x.t] -= x.DV;
        r[i + x.t + 1] = 1;
      }
    }
    if (r.t > 0) r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);
    r.s = 0;
    r.clamp();
  }
  // (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)
  // r != q, this != m.  q or r may be null.
  function bnpDivRemTo(m, q, r)
  {
    var pm = m.abs();
    if (pm.t <= 0) return;
    var pt = this.abs();
    if (pt.t < pm.t)
    {
      if (q != null) q.fromInt(0);
      if (r != null) this.copyTo(r);
      return;
    }
    if (r == null) r = nbi();
    var y = nbi(),
      ts = this.s,
      ms = m.s;
    var nsh = this.DB - nbits(pm[pm.t - 1]); // normalize modulus
    if (nsh > 0)
    {
      pm.lShiftTo(nsh, y);
      pt.lShiftTo(nsh, r);
    }
    else
    {
      pm.copyTo(y);
      pt.copyTo(r);
    }
    var ys = y.t;
    var y0 = y[ys - 1];
    if (y0 == 0) return;
    var yt = y0 * (1 << this.F1) + ((ys > 1) ? y[ys - 2] >> this.F2 : 0);
    var d1 = this.FV / yt,
      d2 = (1 << this.F1) / yt,
      e = 1 << this.F2;
    var i = r.t,
      j = i - ys,
      t = (q == null) ? nbi() : q;
    y.dlShiftTo(j, t);
    if (r.compareTo(t) >= 0)
    {
      r[r.t++] = 1;
      r.subTo(t, r);
    }
    BigInteger.ONE.dlShiftTo(ys, t);
    t.subTo(y, y); // "negative" y so we can replace sub with am later
    while (y.t < ys) y[y.t++] = 0;
    while (--j >= 0)
    {
      // Estimate quotient digit
      var qd = (r[--i] == y0) ? this.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);
      if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd)
      { // Try it out
        y.dlShiftTo(j, t);
        r.subTo(t, r);
        while (r[i] < --qd) r.subTo(t, r);
      }
    }
    if (q != null)
    {
      r.drShiftTo(ys, q);
      if (ts != ms) BigInteger.ZERO.subTo(q, q);
    }
    r.t = ys;
    r.clamp();
    if (nsh > 0) r.rShiftTo(nsh, r); // Denormalize remainder
    if (ts < 0) BigInteger.ZERO.subTo(r, r);
  }
  // (public) this mod a
  function bnMod(a)
  {
    var r = nbi();
    this.abs().divRemTo(a, null, r);
    if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r, r);
    return r;
  }
  // Modular reduction using "classic" algorithm
  function Classic(m)
  {
    this.m = m;
  }

  function cConvert(x)
  {
    if (x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);
    else return x;
  }

  function cRevert(x)
  {
    return x;
  }

  function cReduce(x)
  {
    x.divRemTo(this.m, null, x);
  }

  function cMulTo(x, y, r)
  {
    x.multiplyTo(y, r);
    this.reduce(r);
  }

  function cSqrTo(x, r)
  {
    x.squareTo(r);
    this.reduce(r);
  }
  Classic.prototype.convert = cConvert;
  Classic.prototype.revert = cRevert;
  Classic.prototype.reduce = cReduce;
  Classic.prototype.mulTo = cMulTo;
  Classic.prototype.sqrTo = cSqrTo;
  // (protected) return "-1/this % 2^DB"; useful for Mont. reduction
  // justification:
  //         xy == 1 (mod m)
  //         xy =  1+km
  //   xy(2-xy) = (1+km)(1-km)
  // x[y(2-xy)] = 1-k^2m^2
  // x[y(2-xy)] == 1 (mod m^2)
  // if y is 1/x mod m, then y(2-xy) is 1/x mod m^2
  // should reduce x and y(2-xy) by m^2 at each step to keep size bounded.
  // JS multiply "overflows" differently from C/C++, so care is needed here.
  function bnpInvDigit()
  {
    if (this.t < 1) return 0;
    var x = this[0];
    if ((x & 1) == 0) return 0;
    var y = x & 3; // y == 1/x mod 2^2
    y = (y * (2 - (x & 0xf) * y)) & 0xf; // y == 1/x mod 2^4
    y = (y * (2 - (x & 0xff) * y)) & 0xff; // y == 1/x mod 2^8
    y = (y * (2 - (((x & 0xffff) * y) & 0xffff))) & 0xffff; // y == 1/x mod 2^16
    // last step - calculate inverse mod DV directly;
    // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints
    y = (y * (2 - x * y % this.DV)) % this.DV; // y == 1/x mod 2^dbits
    // we really want the negative inverse, and -DV < y < DV
    return (y > 0) ? this.DV - y : -y;
  }
  // Montgomery reduction
  function Montgomery(m)
  {
    this.m = m;
    this.mp = m.invDigit();
    this.mpl = this.mp & 0x7fff;
    this.mph = this.mp >> 15;
    this.um = (1 << (m.DB - 15)) - 1;
    this.mt2 = 2 * m.t;
  }
  // xR mod m
  function montConvert(x)
  {
    var r = nbi();
    x.abs().dlShiftTo(this.m.t, r);
    r.divRemTo(this.m, null, r);
    if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r, r);
    return r;
  }
  // x/R mod m
  function montRevert(x)
  {
    var r = nbi();
    x.copyTo(r);
    this.reduce(r);
    return r;
  }
  // x = x/R mod m (HAC 14.32)
  function montReduce(x)
  {
    while (x.t <= this.mt2) // pad x so am has enough room later
      x[x.t++] = 0;
    for (var i = 0; i < this.m.t; ++i)
    {
      // faster way of calculating u0 = x[i]*mp mod DV
      var j = x[i] & 0x7fff;
      var u0 = (j * this.mpl + (((j * this.mph + (x[i] >> 15) * this.mpl) & this.um) << 15)) & x.DM;
      // use am to combine the multiply-shift-add into one call
      j = i + this.m.t;
      x[j] += this.m.am(0, u0, x, i, 0, this.m.t);
      // propagate carry
      while (x[j] >= x.DV)
      {
        x[j] -= x.DV;
        x[++j]++;
      }
    }
    x.clamp();
    x.drShiftTo(this.m.t, x);
    if (x.compareTo(this.m) >= 0) x.subTo(this.m, x);
  }
  // r = "x^2/R mod m"; x != r
  function montSqrTo(x, r)
  {
    x.squareTo(r);
    this.reduce(r);
  }
  // r = "xy/R mod m"; x,y != r
  function montMulTo(x, y, r)
  {
    x.multiplyTo(y, r);
    this.reduce(r);
  }
  Montgomery.prototype.convert = montConvert;
  Montgomery.prototype.revert = montRevert;
  Montgomery.prototype.reduce = montReduce;
  Montgomery.prototype.mulTo = montMulTo;
  Montgomery.prototype.sqrTo = montSqrTo;
  // (protected) true iff this is even
  function bnpIsEven()
  {
    return ((this.t > 0) ? (this[0] & 1) : this.s) == 0;
  }
  // (protected) this^e, e < 2^32, doing sqr and mul with "r" (HAC 14.79)
  function bnpExp(e, z)
  {
    if (e > 0xffffffff || e < 1) return BigInteger.ONE;
    var r = nbi(),
      r2 = nbi(),
      g = z.convert(this),
      i = nbits(e) - 1;
    g.copyTo(r);
    while (--i >= 0)
    {
      z.sqrTo(r, r2);
      if ((e & (1 << i)) > 0) z.mulTo(r2, g, r);
      else
      {
        var t = r;
        r = r2;
        r2 = t;
      }
    }
    return z.revert(r);
  }
  // (public) this^e % m, 0 <= e < 2^32
  function bnModPowInt(e, m)
  {
    var z;
    if (e < 256 || m.isEven()) z = new Classic(m);
    else z = new Montgomery(m);
    return this.exp(e, z);
  }
  // protected
  BigInteger.prototype.copyTo = bnpCopyTo;
  BigInteger.prototype.fromInt = bnpFromInt;
  BigInteger.prototype.fromString = bnpFromString;
  BigInteger.prototype.clamp = bnpClamp;
  BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
  BigInteger.prototype.drShiftTo = bnpDRShiftTo;
  BigInteger.prototype.lShiftTo = bnpLShiftTo;
  BigInteger.prototype.rShiftTo = bnpRShiftTo;
  BigInteger.prototype.subTo = bnpSubTo;
  BigInteger.prototype.multiplyTo = bnpMultiplyTo;
  BigInteger.prototype.squareTo = bnpSquareTo;
  BigInteger.prototype.divRemTo = bnpDivRemTo;
  BigInteger.prototype.invDigit = bnpInvDigit;
  BigInteger.prototype.isEven = bnpIsEven;
  BigInteger.prototype.exp = bnpExp;
  // public
  BigInteger.prototype.toString = bnToString;
  BigInteger.prototype.negate = bnNegate;
  BigInteger.prototype.abs = bnAbs;
  BigInteger.prototype.compareTo = bnCompareTo;
  BigInteger.prototype.bitLength = bnBitLength;
  BigInteger.prototype.mod = bnMod;
  BigInteger.prototype.modPowInt = bnModPowInt;
  // "constants"
  BigInteger.ZERO = nbv(0);
  BigInteger.ONE = nbv(1);
  // Copyright (c) 2005-2009  Tom Wu
  // All Rights Reserved.
  // See "LICENSE" for details.
  // Extended JavaScript BN functions, required for RSA private ops.
  // Version 1.1: new BigInteger("0", 10) returns "proper" zero
  // Version 1.2: square() API, isProbablePrime fix
  // (public)
  function bnClone()
  {
    var r = nbi();
    this.copyTo(r);
    return r;
  }
  // (public) return value as integer
  function bnIntValue()
  {
    if (this.s < 0)
    {
      if (this.t == 1) return this[0] - this.DV;
      else if (this.t == 0) return -1;
    }
    else if (this.t == 1) return this[0];
    else if (this.t == 0) return 0;
    // assumes 16 < DB < 32
    return ((this[1] & ((1 << (32 - this.DB)) - 1)) << this.DB) | this[0];
  }
  // (public) return value as byte
  function bnByteValue()
  {
    return (this.t == 0) ? this.s : (this[0] << 24) >> 24;
  }
  // (public) return value as short (assumes DB>=16)
  function bnShortValue()
  {
    return (this.t == 0) ? this.s : (this[0] << 16) >> 16;
  }
  // (protected) return x s.t. r^x < DV
  function bnpChunkSize(r)
  {
    return Math.floor(Math.LN2 * this.DB / Math.log(r));
  }
  // (public) 0 if this == 0, 1 if this > 0
  function bnSigNum()
  {
    if (this.s < 0) return -1;
    else if (this.t <= 0 || (this.t == 1 && this[0] <= 0)) return 0;
    else return 1;
  }
  // (protected) convert to radix string
  function bnpToRadix(b)
  {
    if (b == null) b = 10;
    if (this.signum() == 0 || b < 2 || b > 36) return "0";
    var cs = this.chunkSize(b);
    var a = Math.pow(b, cs);
    var d = nbv(a),
      y = nbi(),
      z = nbi(),
      r = "";
    this.divRemTo(d, y, z);
    while (y.signum() > 0)
    {
      r = (a + z.intValue()).toString(b).substr(1) + r;
      y.divRemTo(d, y, z);
    }
    return z.intValue().toString(b) + r;
  }
  // (protected) convert from radix string
  function bnpFromRadix(s, b)
  {
    this.fromInt(0);
    if (b == null) b = 10;
    var cs = this.chunkSize(b);
    var d = Math.pow(b, cs),
      mi = false,
      j = 0,
      w = 0;
    for (var i = 0; i < s.length; ++i)
    {
      var x = intAt(s, i);
      if (x < 0)
      {
        if (s.charAt(i) == "-" && this.signum() == 0) mi = true;
        continue;
      }
      w = b * w + x;
      if (++j >= cs)
      {
        this.dMultiply(d);
        this.dAddOffset(w, 0);
        j = 0;
        w = 0;
      }
    }
    if (j > 0)
    {
      this.dMultiply(Math.pow(b, j));
      this.dAddOffset(w, 0);
    }
    if (mi) BigInteger.ZERO.subTo(this, this);
  }
  // (protected) alternate constructor
  function bnpFromNumber(a, b, c)
  {
    if ("number" == typeof b)
    {
      // new BigInteger(int,int,RNG)
      if (a < 2) this.fromInt(1);
      else
      {
        this.fromNumber(a, c);
        if (!this.testBit(a - 1)) // force MSB set
          this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
        if (this.isEven()) this.dAddOffset(1, 0); // force odd
        while (!this.isProbablePrime(b))
        {
          this.dAddOffset(2, 0);
          if (this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);
        }
      }
    }
    else
    {
      // new BigInteger(int,RNG)
      var x = new Array(),
        t = a & 7;
      x.length = (a >> 3) + 1;
      b.nextBytes(x);
      if (t > 0) x[0] &= ((1 << t) - 1);
      else x[0] = 0;
      this.fromString(x, 256);
    }
  }
  // (public) convert to bigendian byte array
  function bnToByteArray()
  {
    var i = this.t,
      r = new Array();
    r[0] = this.s;
    var p = this.DB - (i * this.DB) % 8,
      d, k = 0;
    if (i-- > 0)
    {
      if (p < this.DB && (d = this[i] >> p) != (this.s & this.DM) >> p)
        r[k++] = d | (this.s << (this.DB - p));
      while (i >= 0)
      {
        if (p < 8)
        {
          d = (this[i] & ((1 << p) - 1)) << (8 - p);
          d |= this[--i] >> (p += this.DB - 8);
        }
        else
        {
          d = (this[i] >> (p -= 8)) & 0xff;
          if (p <= 0)
          {
            p += this.DB;
            --i;
          }
        }
        if ((d & 0x80) != 0) d |= -256;
        if (k == 0 && (this.s & 0x80) != (d & 0x80))++k;
        if (k > 0 || d != this.s) r[k++] = d;
      }
    }
    return r;
  }

  function bnEquals(a)
  {
    return (this.compareTo(a) == 0);
  }

  function bnMin(a)
  {
    return (this.compareTo(a) < 0) ? this : a;
  }

  function bnMax(a)
  {
    return (this.compareTo(a) > 0) ? this : a;
  }
  // (protected) r = this op a (bitwise)
  function bnpBitwiseTo(a, op, r)
  {
    var i, f, m = Math.min(a.t, this.t);
    for (i = 0; i < m; ++i) r[i] = op(this[i], a[i]);
    if (a.t < this.t)
    {
      f = a.s & this.DM;
      for (i = m; i < this.t; ++i) r[i] = op(this[i], f);
      r.t = this.t;
    }
    else
    {
      f = this.s & this.DM;
      for (i = m; i < a.t; ++i) r[i] = op(f, a[i]);
      r.t = a.t;
    }
    r.s = op(this.s, a.s);
    r.clamp();
  }
  // (public) this & a
  function op_and(x, y)
  {
    return x & y;
  }

  function bnAnd(a)
  {
    var r = nbi();
    this.bitwiseTo(a, op_and, r);
    return r;
  }
  // (public) this | a
  function op_or(x, y)
  {
    return x | y;
  }

  function bnOr(a)
  {
    var r = nbi();
    this.bitwiseTo(a, op_or, r);
    return r;
  }
  // (public) this ^ a
  function op_xor(x, y)
  {
    return x ^ y;
  }

  function bnXor(a)
  {
    var r = nbi();
    this.bitwiseTo(a, op_xor, r);
    return r;
  }
  // (public) this & ~a
  function op_andnot(x, y)
  {
    return x & ~y;
  }

  function bnAndNot(a)
  {
    var r = nbi();
    this.bitwiseTo(a, op_andnot, r);
    return r;
  }
  // (public) ~this
  function bnNot()
  {
    var r = nbi();
    for (var i = 0; i < this.t; ++i) r[i] = this.DM & ~this[i];
    r.t = this.t;
    r.s = ~this.s;
    return r;
  }
  // (public) this << n
  function bnShiftLeft(n)
  {
    var r = nbi();
    if (n < 0) this.rShiftTo(-n, r);
    else this.lShiftTo(n, r);
    return r;
  }
  // (public) this >> n
  function bnShiftRight(n)
  {
    var r = nbi();
    if (n < 0) this.lShiftTo(-n, r);
    else this.rShiftTo(n, r);
    return r;
  }
  // return index of lowest 1-bit in x, x < 2^31
  function lbit(x)
  {
    if (x == 0) return -1;
    var r = 0;
    if ((x & 0xffff) == 0)
    {
      x >>= 16;
      r += 16;
    }
    if ((x & 0xff) == 0)
    {
      x >>= 8;
      r += 8;
    }
    if ((x & 0xf) == 0)
    {
      x >>= 4;
      r += 4;
    }
    if ((x & 3) == 0)
    {
      x >>= 2;
      r += 2;
    }
    if ((x & 1) == 0)++r;
    return r;
  }
  // (public) returns index of lowest 1-bit (or -1 if none)
  function bnGetLowestSetBit()
  {
    for (var i = 0; i < this.t; ++i)
      if (this[i] != 0) return i * this.DB + lbit(this[i]);
    if (this.s < 0) return this.t * this.DB;
    return -1;
  }
  // return number of 1 bits in x
  function cbit(x)
  {
    var r = 0;
    while (x != 0)
    {
      x &= x - 1;
      ++r;
    }
    return r;
  }
  // (public) return number of set bits
  function bnBitCount()
  {
    var r = 0,
      x = this.s & this.DM;
    for (var i = 0; i < this.t; ++i) r += cbit(this[i] ^ x);
    return r;
  }
  // (public) true iff nth bit is set
  function bnTestBit(n)
  {
    var j = Math.floor(n / this.DB);
    if (j >= this.t) return (this.s != 0);
    return ((this[j] & (1 << (n % this.DB))) != 0);
  }
  // (protected) this op (1<<n)
  function bnpChangeBit(n, op)
  {
    var r = BigInteger.ONE.shiftLeft(n);
    this.bitwiseTo(r, op, r);
    return r;
  }
  // (public) this | (1<<n)
  function bnSetBit(n)
  {
    return this.changeBit(n, op_or);
  }
  // (public) this & ~(1<<n)
  function bnClearBit(n)
  {
    return this.changeBit(n, op_andnot);
  }
  // (public) this ^ (1<<n)
  function bnFlipBit(n)
  {
    return this.changeBit(n, op_xor);
  }
  // (protected) r = this + a
  function bnpAddTo(a, r)
  {
    var i = 0,
      c = 0,
      m = Math.min(a.t, this.t);
    while (i < m)
    {
      c += this[i] + a[i];
      r[i++] = c & this.DM;
      c >>= this.DB;
    }
    if (a.t < this.t)
    {
      c += a.s;
      while (i < this.t)
      {
        c += this[i];
        r[i++] = c & this.DM;
        c >>= this.DB;
      }
      c += this.s;
    }
    else
    {
      c += this.s;
      while (i < a.t)
      {
        c += a[i];
        r[i++] = c & this.DM;
        c >>= this.DB;
      }
      c += a.s;
    }
    r.s = (c < 0) ? -1 : 0;
    if (c > 0) r[i++] = c;
    else if (c < -1) r[i++] = this.DV + c;
    r.t = i;
    r.clamp();
  }
  // (public) this + a
  function bnAdd(a)
  {
    var r = nbi();
    this.addTo(a, r);
    return r;
  }
  // (public) this - a
  function bnSubtract(a)
  {
    var r = nbi();
    this.subTo(a, r);
    return r;
  }
  // (public) this * a
  function bnMultiply(a)
  {
    var r = nbi();
    this.multiplyTo(a, r);
    return r;
  }
  // (public) this^2
  function bnSquare()
  {
    var r = nbi();
    this.squareTo(r);
    return r;
  }
  // (public) this / a
  function bnDivide(a)
  {
    var r = nbi();
    this.divRemTo(a, r, null);
    return r;
  }
  // (public) this % a
  function bnRemainder(a)
  {
    var r = nbi();
    this.divRemTo(a, null, r);
    return r;
  }
  // (public) [this/a,this%a]
  function bnDivideAndRemainder(a)
  {
    var q = nbi(),
      r = nbi();
    this.divRemTo(a, q, r);
    return new Array(q, r);
  }
  // (protected) this *= n, this >= 0, 1 < n < DV
  function bnpDMultiply(n)
  {
    this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
    ++this.t;
    this.clamp();
  }
  // (protected) this += n << w words, this >= 0
  function bnpDAddOffset(n, w)
  {
    if (n == 0) return;
    while (this.t <= w) this[this.t++] = 0;
    this[w] += n;
    while (this[w] >= this.DV)
    {
      this[w] -= this.DV;
      if (++w >= this.t) this[this.t++] = 0;
      ++this[w];
    }
  }
  // A "null" reducer
  function NullExp()
  {}

  function nNop(x)
  {
    return x;
  }

  function nMulTo(x, y, r)
  {
    x.multiplyTo(y, r);
  }

  function nSqrTo(x, r)
  {
    x.squareTo(r);
  }
  NullExp.prototype.convert = nNop;
  NullExp.prototype.revert = nNop;
  NullExp.prototype.mulTo = nMulTo;
  NullExp.prototype.sqrTo = nSqrTo;
  // (public) this^e
  function bnPow(e)
  {
    return this.exp(e, new NullExp());
  }
  // (protected) r = lower n words of "this * a", a.t <= n
  // "this" should be the larger one if appropriate.
  function bnpMultiplyLowerTo(a, n, r)
  {
    var i = Math.min(this.t + a.t, n);
    r.s = 0; // assumes a,this >= 0
    r.t = i;
    while (i > 0) r[--i] = 0;
    var j;
    for (j = r.t - this.t; i < j; ++i) r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);
    for (j = Math.min(a.t, n); i < j; ++i) this.am(0, a[i], r, i, 0, n - i);
    r.clamp();
  }
  // (protected) r = "this * a" without lower n words, n > 0
  // "this" should be the larger one if appropriate.
  function bnpMultiplyUpperTo(a, n, r)
  {
    --n;
    var i = r.t = this.t + a.t - n;
    r.s = 0; // assumes a,this >= 0
    while (--i >= 0) r[i] = 0;
    for (i = Math.max(n - this.t, 0); i < a.t; ++i)
      r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n);
    r.clamp();
    r.drShiftTo(1, r);
  }
  // Barrett modular reduction
  function Barrett(m)
  {
    // setup Barrett
    this.r2 = nbi();
    this.q3 = nbi();
    BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);
    this.mu = this.r2.divide(m);
    this.m = m;
  }

  function barrettConvert(x)
  {
    if (x.s < 0 || x.t > 2 * this.m.t) return x.mod(this.m);
    else if (x.compareTo(this.m) < 0) return x;
    else
    {
      var r = nbi();
      x.copyTo(r);
      this.reduce(r);
      return r;
    }
  }

  function barrettRevert(x)
  {
    return x;
  }
  // x = x mod m (HAC 14.42)
  function barrettReduce(x)
  {
    x.drShiftTo(this.m.t - 1, this.r2);
    if (x.t > this.m.t + 1)
    {
      x.t = this.m.t + 1;
      x.clamp();
    }
    this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
    this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
    while (x.compareTo(this.r2) < 0) x.dAddOffset(1, this.m.t + 1);
    x.subTo(this.r2, x);
    while (x.compareTo(this.m) >= 0) x.subTo(this.m, x);
  }
  // r = x^2 mod m; x != r
  function barrettSqrTo(x, r)
  {
    x.squareTo(r);
    this.reduce(r);
  }
  // r = x*y mod m; x,y != r
  function barrettMulTo(x, y, r)
  {
    x.multiplyTo(y, r);
    this.reduce(r);
  }
  Barrett.prototype.convert = barrettConvert;
  Barrett.prototype.revert = barrettRevert;
  Barrett.prototype.reduce = barrettReduce;
  Barrett.prototype.mulTo = barrettMulTo;
  Barrett.prototype.sqrTo = barrettSqrTo;
  // (public) this^e % m (HAC 14.85)
  function bnModPow(e, m)
  {
    var i = e.bitLength(),
      k, r = nbv(1),
      z;
    if (i <= 0) return r;
    else if (i < 18) k = 1;
    else if (i < 48) k = 3;
    else if (i < 144) k = 4;
    else if (i < 768) k = 5;
    else k = 6;
    if (i < 8)
      z = new Classic(m);
    else if (m.isEven())
      z = new Barrett(m);
    else
      z = new Montgomery(m);
    // precomputation
    var g = new Array(),
      n = 3,
      k1 = k - 1,
      km = (1 << k) - 1;
    g[1] = z.convert(this);
    if (k > 1)
    {
      var g2 = nbi();
      z.sqrTo(g[1], g2);
      while (n <= km)
      {
        g[n] = nbi();
        z.mulTo(g2, g[n - 2], g[n]);
        n += 2;
      }
    }
    var j = e.t - 1,
      w, is1 = true,
      r2 = nbi(),
      t;
    i = nbits(e[j]) - 1;
    while (j >= 0)
    {
      if (i >= k1) w = (e[j] >> (i - k1)) & km;
      else
      {
        w = (e[j] & ((1 << (i + 1)) - 1)) << (k1 - i);
        if (j > 0) w |= e[j - 1] >> (this.DB + i - k1);
      }
      n = k;
      while ((w & 1) == 0)
      {
        w >>= 1;
        --n;
      }
      if ((i -= n) < 0)
      {
        i += this.DB;
        --j;
      }
      if (is1)
      { // ret == 1, don't bother squaring or multiplying it
        g[w].copyTo(r);
        is1 = false;
      }
      else
      {
        while (n > 1)
        {
          z.sqrTo(r, r2);
          z.sqrTo(r2, r);
          n -= 2;
        }
        if (n > 0) z.sqrTo(r, r2);
        else
        {
          t = r;
          r = r2;
          r2 = t;
        }
        z.mulTo(r2, g[w], r);
      }
      while (j >= 0 && (e[j] & (1 << i)) == 0)
      {
        z.sqrTo(r, r2);
        t = r;
        r = r2;
        r2 = t;
        if (--i < 0)
        {
          i = this.DB - 1;
          --j;
        }
      }
    }
    return z.revert(r);
  }
  // (public) gcd(this,a) (HAC 14.54)
  function bnGCD(a)
  {
    var x = (this.s < 0) ? this.negate() : this.clone();
    var y = (a.s < 0) ? a.negate() : a.clone();
    if (x.compareTo(y) < 0)
    {
      var t = x;
      x = y;
      y = t;
    }
    var i = x.getLowestSetBit(),
      g = y.getLowestSetBit();
    if (g < 0) return x;
    if (i < g) g = i;
    if (g > 0)
    {
      x.rShiftTo(g, x);
      y.rShiftTo(g, y);
    }
    while (x.signum() > 0)
    {
      if ((i = x.getLowestSetBit()) > 0) x.rShiftTo(i, x);
      if ((i = y.getLowestSetBit()) > 0) y.rShiftTo(i, y);
      if (x.compareTo(y) >= 0)
      {
        x.subTo(y, x);
        x.rShiftTo(1, x);
      }
      else
      {
        y.subTo(x, y);
        y.rShiftTo(1, y);
      }
    }
    if (g > 0) y.lShiftTo(g, y);
    return y;
  }
  // (protected) this % n, n < 2^26
  function bnpModInt(n)
  {
    if (n <= 0) return 0;
    var d = this.DV % n,
      r = (this.s < 0) ? n - 1 : 0;
    if (this.t > 0)
      if (d == 0) r = this[0] % n;
      else
        for (var i = this.t - 1; i >= 0; --i) r = (d * r + this[i]) % n;
    return r;
  }
  // (public) 1/this % m (HAC 14.61)
  function bnModInverse(m)
  {
    var ac = m.isEven();
    if ((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO;
    var u = m.clone(),
      v = this.clone();
    var a = nbv(1),
      b = nbv(0),
      c = nbv(0),
      d = nbv(1);
    while (u.signum() != 0)
    {
      while (u.isEven())
      {
        u.rShiftTo(1, u);
        if (ac)
        {
          if (!a.isEven() || !b.isEven())
          {
            a.addTo(this, a);
            b.subTo(m, b);
          }
          a.rShiftTo(1, a);
        }
        else if (!b.isEven()) b.subTo(m, b);
        b.rShiftTo(1, b);
      }
      while (v.isEven())
      {
        v.rShiftTo(1, v);
        if (ac)
        {
          if (!c.isEven() || !d.isEven())
          {
            c.addTo(this, c);
            d.subTo(m, d);
          }
          c.rShiftTo(1, c);
        }
        else if (!d.isEven()) d.subTo(m, d);
        d.rShiftTo(1, d);
      }
      if (u.compareTo(v) >= 0)
      {
        u.subTo(v, u);
        if (ac) a.subTo(c, a);
        b.subTo(d, b);
      }
      else
      {
        v.subTo(u, v);
        if (ac) c.subTo(a, c);
        d.subTo(b, d);
      }
    }
    if (v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;
    if (d.compareTo(m) >= 0) return d.subtract(m);
    if (d.signum() < 0) d.addTo(m, d);
    else return d;
    if (d.signum() < 0) return d.add(m);
    else return d;
  }
  var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];
  var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
  // (public) test primality with certainty >= 1-.5^t
  function bnIsProbablePrime(t)
  {
    var i, x = this.abs();
    if (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1])
    {
      for (i = 0; i < lowprimes.length; ++i)
        if (x[0] == lowprimes[i]) return true;
      return false;
    }
    if (x.isEven()) return false;
    i = 1;
    while (i < lowprimes.length)
    {
      var m = lowprimes[i],
        j = i + 1;
      while (j < lowprimes.length && m < lplim) m *= lowprimes[j++];
      m = x.modInt(m);
      while (i < j)
        if (m % lowprimes[i++] == 0) return false;
    }
    return x.millerRabin(t);
  }
  // (protected) true if probably prime (HAC 4.24, Miller-Rabin)
  function bnpMillerRabin(t)
  {
    var n1 = this.subtract(BigInteger.ONE);
    var k = n1.getLowestSetBit();
    if (k <= 0) return false;
    var r = n1.shiftRight(k);
    t = (t + 1) >> 1;
    if (t > lowprimes.length) t = lowprimes.length;
    var a = nbi();
    for (var i = 0; i < t; ++i)
    {
      //Pick bases at random, instead of starting at 2
      a.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);
      var y = a.modPow(r, this);
      if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0)
      {
        var j = 1;
        while (j++ < k && y.compareTo(n1) != 0)
        {
          y = y.modPowInt(2, this);
          if (y.compareTo(BigInteger.ONE) == 0) return false;
        }
        if (y.compareTo(n1) != 0) return false;
      }
    }
    return true;
  }
  // protected
  BigInteger.prototype.chunkSize = bnpChunkSize;
  BigInteger.prototype.toRadix = bnpToRadix;
  BigInteger.prototype.fromRadix = bnpFromRadix;
  BigInteger.prototype.fromNumber = bnpFromNumber;
  BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
  BigInteger.prototype.changeBit = bnpChangeBit;
  BigInteger.prototype.addTo = bnpAddTo;
  BigInteger.prototype.dMultiply = bnpDMultiply;
  BigInteger.prototype.dAddOffset = bnpDAddOffset;
  BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
  BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
  BigInteger.prototype.modInt = bnpModInt;
  BigInteger.prototype.millerRabin = bnpMillerRabin;
  // public
  BigInteger.prototype.clone = bnClone;
  BigInteger.prototype.intValue = bnIntValue;
  BigInteger.prototype.byteValue = bnByteValue;
  BigInteger.prototype.shortValue = bnShortValue;
  BigInteger.prototype.signum = bnSigNum;
  BigInteger.prototype.toByteArray = bnToByteArray;
  BigInteger.prototype.equals = bnEquals;
  BigInteger.prototype.min = bnMin;
  BigInteger.prototype.max = bnMax;
  BigInteger.prototype.and = bnAnd;
  BigInteger.prototype.or = bnOr;
  BigInteger.prototype.xor = bnXor;
  BigInteger.prototype.andNot = bnAndNot;
  BigInteger.prototype.not = bnNot;
  BigInteger.prototype.shiftLeft = bnShiftLeft;
  BigInteger.prototype.shiftRight = bnShiftRight;
  BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
  BigInteger.prototype.bitCount = bnBitCount;
  BigInteger.prototype.testBit = bnTestBit;
  BigInteger.prototype.setBit = bnSetBit;
  BigInteger.prototype.clearBit = bnClearBit;
  BigInteger.prototype.flipBit = bnFlipBit;
  BigInteger.prototype.add = bnAdd;
  BigInteger.prototype.subtract = bnSubtract;
  BigInteger.prototype.multiply = bnMultiply;
  BigInteger.prototype.divide = bnDivide;
  BigInteger.prototype.remainder = bnRemainder;
  BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
  BigInteger.prototype.modPow = bnModPow;
  BigInteger.prototype.modInverse = bnModInverse;
  BigInteger.prototype.pow = bnPow;
  BigInteger.prototype.gcd = bnGCD;
  BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
  // JSBN-specific extension
  BigInteger.prototype.square = bnSquare;
  var Int128 = BigInteger;
  // BigInteger interfaces not implemented in jsbn:
  // BigInteger(int signum, byte[] magnitude)
  // double doubleValue()
  // float floatValue()
  // int hashCode()
  // long longValue()
  // static BigInteger valueOf(long val)
  // Helper functions to make BigInteger functions callable with two parameters
  // as in original C# Clipper
  Int128.prototype.IsNegative = function ()
  {
    if (this.compareTo(Int128.ZERO) == -1) return true;
    else return false;
  };
  Int128.op_Equality = function (val1, val2)
  {
    if (val1.compareTo(val2) == 0) return true;
    else return false;
  };
  Int128.op_Inequality = function (val1, val2)
  {
    if (val1.compareTo(val2) != 0) return true;
    else return false;
  };
  Int128.op_GreaterThan = function (val1, val2)
  {
    if (val1.compareTo(val2) > 0) return true;
    else return false;
  };
  Int128.op_LessThan = function (val1, val2)
  {
    if (val1.compareTo(val2) < 0) return true;
    else return false;
  };
  Int128.op_Addition = function (lhs, rhs)
  {
    return new Int128(lhs).add(new Int128(rhs));
  };
  Int128.op_Subtraction = function (lhs, rhs)
  {
    return new Int128(lhs).subtract(new Int128(rhs));
  };
  Int128.Int128Mul = function (lhs, rhs)
  {
    return new Int128(lhs).multiply(new Int128(rhs));
  };
  Int128.op_Division = function (lhs, rhs)
  {
    return lhs.divide(rhs);
  };
  Int128.prototype.ToDouble = function ()
  {
    return parseFloat(this.toString()); // This could be something faster
  };
  // end of Int128 section
  /*
  // Uncomment the following two lines if you want to use Int128 outside ClipperLib
  if (typeof(document) !== "undefined") window.Int128 = Int128;
  else self.Int128 = Int128;
  */


  // ---------------------------------------------
  // Here starts the actual Clipper library:
  // Helper function to support Inheritance in Javascript
	var Inherit = function (ce, ce2)
	{
		var p;
		if (typeof (Object.getOwnPropertyNames) == 'undefined')
		{
			for (p in ce2.prototype)
				if (typeof (ce.prototype[p]) == 'undefined' || ce.prototype[p] == Object.prototype[p]) ce.prototype[p] = ce2.prototype[p];
			for (p in ce2)
				if (typeof (ce[p]) == 'undefined') ce[p] = ce2[p];
			ce.$baseCtor = ce2;
		}
		else
		{
			var props = Object.getOwnPropertyNames(ce2.prototype);
			for (var i = 0; i < props.length; i++)
				if (typeof (Object.getOwnPropertyDescriptor(ce.prototype, props[i])) == 'undefined') Object.defineProperty(ce.prototype, props[i], Object.getOwnPropertyDescriptor(ce2.prototype, props[i]));
			for (p in ce2)
				if (typeof (ce[p]) == 'undefined') ce[p] = ce2[p];
			ce.$baseCtor = ce2;
		}
	};
  ClipperLib.Path = function ()
  {
    return [];
  };
  ClipperLib.Paths = function ()
  {
    return []; // Was previously [[]], but caused problems when pushed
  };
  // Preserves the calling way of original C# Clipper
  // Is essential due to compatibility, because DoublePoint is public class in original C# version
  ClipperLib.DoublePoint = function ()
  {
    var a = arguments;
    this.X = 0;
    this.Y = 0;
    // public DoublePoint(DoublePoint dp)
    // public DoublePoint(IntPoint ip)
    if (a.length == 1)
    {
      this.X = a[0].X;
      this.Y = a[0].Y;
    }
    else if (a.length == 2)
    {
      this.X = a[0];
      this.Y = a[1];
    }
  }; // This is internal faster function when called without arguments
  ClipperLib.DoublePoint0 = function ()
  {
    this.X = 0;
    this.Y = 0;
  };
  // This is internal faster function when called with 1 argument (dp or ip)
  ClipperLib.DoublePoint1 = function (dp)
  {
    this.X = dp.X;
    this.Y = dp.Y;
  };
  // This is internal faster function when called with 2 arguments (x and y)
  ClipperLib.DoublePoint2 = function (x, y)
  {
    this.X = x;
    this.Y = y;
  };
  // PolyTree & PolyNode start
  // -------------------------------
  ClipperLib.PolyNode = function ()
  {
    this.m_Parent = null;
    this.m_polygon = new ClipperLib.Path();
    this.m_Index = 0;
    this.m_jointype = 0;
    this.m_endtype = 0;
    this.m_Childs = [];
    this.IsOpen = false;
  };
  ClipperLib.PolyNode.prototype.IsHoleNode = function ()
  {
    var result = true;
    var node = this.m_Parent;
    while (node !== null)
    {
      result = !result;
      node = node.m_Parent;
    }
    return result;
  };
  ClipperLib.PolyNode.prototype.ChildCount = function ()
  {
    return this.m_Childs.length;
  };
  ClipperLib.PolyNode.prototype.Contour = function ()
  {
    return this.m_polygon;
  };
  ClipperLib.PolyNode.prototype.AddChild = function (Child)
  {
    var cnt = this.m_Childs.length;
    this.m_Childs.push(Child);
    Child.m_Parent = this;
    Child.m_Index = cnt;
  };
  ClipperLib.PolyNode.prototype.GetNext = function ()
  {
    if (this.m_Childs.length > 0)
      return this.m_Childs[0];
    else
      return this.GetNextSiblingUp();
  };
  ClipperLib.PolyNode.prototype.GetNextSiblingUp = function ()
  {
    if (this.m_Parent === null)
      return null;
    else if (this.m_Index == this.m_Parent.m_Childs.length - 1)
      return this.m_Parent.GetNextSiblingUp();
    else
      return this.m_Parent.m_Childs[this.m_Index + 1];
  };
  ClipperLib.PolyNode.prototype.Childs = function ()
  {
    return this.m_Childs;
  };
  ClipperLib.PolyNode.prototype.Parent = function ()
  {
    return this.m_Parent;
  };
  ClipperLib.PolyNode.prototype.IsHole = function ()
  {
    return this.IsHoleNode();
  };
  // PolyTree : PolyNode
  ClipperLib.PolyTree = function ()
  {
    this.m_AllPolys = [];
    ClipperLib.PolyNode.call(this);
  };
  ClipperLib.PolyTree.prototype.Clear = function ()
  {
    for (var i = 0, ilen = this.m_AllPolys.length; i < ilen; i++)
      this.m_AllPolys[i] = null;
    this.m_AllPolys.length = 0;
    this.m_Childs.length = 0;
  };
  ClipperLib.PolyTree.prototype.GetFirst = function ()
  {
    if (this.m_Childs.length > 0)
      return this.m_Childs[0];
    else
      return null;
  };
  ClipperLib.PolyTree.prototype.Total = function ()
  {
		var result = this.m_AllPolys.length;
		//with negative offsets, ignore the hidden outer polygon ...
		if (result > 0 && this.m_Childs[0] != this.m_AllPolys[0]) result--;
		return result;
  };
  Inherit(ClipperLib.PolyTree, ClipperLib.PolyNode);
  // -------------------------------
  // PolyTree & PolyNode end
  ClipperLib.Math_Abs_Int64 = ClipperLib.Math_Abs_Int32 = ClipperLib.Math_Abs_Double = function (a)
  {
    return Math.abs(a);
  };
  ClipperLib.Math_Max_Int32_Int32 = function (a, b)
  {
    return Math.max(a, b);
  };
  /*
  -----------------------------------
  cast_32 speedtest: http://jsperf.com/truncate-float-to-integer/2
  -----------------------------------
  */
  if (browser.msie || browser.opera || browser.safari) ClipperLib.Cast_Int32 = function (a)
  {
    return a | 0;
  };
  else ClipperLib.Cast_Int32 = function (a)
  { // eg. browser.chrome || browser.chromium || browser.firefox
    return~~ a;
  };
  /*
  --------------------------
  cast_64 speedtests: http://jsperf.com/truncate-float-to-integer
  Chrome: bitwise_not_floor
  Firefox17: toInteger (typeof test)
  IE9: bitwise_or_floor
  IE7 and IE8: to_parseint
  Chromium: to_floor_or_ceil
  Firefox3: to_floor_or_ceil
  Firefox15: to_floor_or_ceil
  Opera: to_floor_or_ceil
  Safari: to_floor_or_ceil
  --------------------------
  */
  if (browser.chrome) ClipperLib.Cast_Int64 = function (a)
  {
    if (a < -2147483648 || a > 2147483647)
      return a < 0 ? Math.ceil(a) : Math.floor(a);
    else return~~ a;
  };
  else if (browser.firefox && typeof (Number.toInteger) == "function") ClipperLib.Cast_Int64 = function (a)
  {
    return Number.toInteger(a);
  };
  else if (browser.msie7 || browser.msie8) ClipperLib.Cast_Int64 = function (a)
  {
    return parseInt(a, 10);
  };
  else if (browser.msie) ClipperLib.Cast_Int64 = function (a)
  {
    if (a < -2147483648 || a > 2147483647)
      return a < 0 ? Math.ceil(a) : Math.floor(a);
    return a | 0;
  };
  // eg. browser.chromium || browser.firefox || browser.opera || browser.safari
  else ClipperLib.Cast_Int64 = function (a)
  {
    return a < 0 ? Math.ceil(a) : Math.floor(a);
  };
  ClipperLib.Clear = function (a)
  {
    a.length = 0;
  };
  //ClipperLib.MaxSteps = 64; // How many steps at maximum in arc in BuildArc() function
  ClipperLib.PI = 3.141592653589793;
  ClipperLib.PI2 = 2 * 3.141592653589793;
  ClipperLib.IntPoint = function ()
  {
    var a = arguments,
      alen = a.length;
    this.X = 0;
    this.Y = 0;
    if (use_xyz)
    {
      this.Z = 0;
      if (alen == 3) // public IntPoint(cInt x, cInt y, cInt z = 0)
      {
        this.X = a[0];
        this.Y = a[1];
        this.Z = a[2];
      }
      else if (alen == 2) // public IntPoint(cInt x, cInt y)
      {
        this.X = a[0];
        this.Y = a[1];
        this.Z = 0;
      }
      else if (alen == 1)
      {
        if (a[0] instanceof ClipperLib.DoublePoint) // public IntPoint(DoublePoint dp)
        {
          var dp = a[0];
          this.X = ClipperLib.Clipper.Round(dp.X);
          this.Y = ClipperLib.Clipper.Round(dp.Y);
          this.Z = 0;
        }
        else // public IntPoint(IntPoint pt)
        {
          var pt = a[0];
          if (typeof (pt.Z) == "undefined") pt.Z = 0;
          this.X = pt.X;
          this.Y = pt.Y;
          this.Z = pt.Z;
        }
      }
      else // public IntPoint()
      {
        this.X = 0;
        this.Y = 0;
        this.Z = 0;
      }
    }
    else // if (!use_xyz)
    {
      if (alen == 2) // public IntPoint(cInt X, cInt Y)
      {
        this.X = a[0];
        this.Y = a[1];
      }
      else if (alen == 1)
      {
        if (a[0] instanceof ClipperLib.DoublePoint) // public IntPoint(DoublePoint dp)
        {
          var dp = a[0];
          this.X = ClipperLib.Clipper.Round(dp.X);
          this.Y = ClipperLib.Clipper.Round(dp.Y);
        }
        else // public IntPoint(IntPoint pt)
        {
          var pt = a[0];
          this.X = pt.X;
          this.Y = pt.Y;
        }
      }
      else // public IntPoint(IntPoint pt)
      {
        this.X = 0;
        this.Y = 0;
      }
    }
  };
  ClipperLib.IntPoint.op_Equality = function (a, b)
  {
    //return a == b;
    return a.X == b.X && a.Y == b.Y;
  };
  ClipperLib.IntPoint.op_Inequality = function (a, b)
  {
    //return a != b;
    return a.X != b.X || a.Y != b.Y;
  };
  /*
  ClipperLib.IntPoint.prototype.Equals = function (obj)
  {
    if (obj === null)
        return false;
    if (obj instanceof ClipperLib.IntPoint)
    {
        var a = Cast(obj, ClipperLib.IntPoint);
        return (this.X == a.X) && (this.Y == a.Y);
    }
    else
        return false;
  };
*/
  if (use_xyz)
  {
    ClipperLib.IntPoint0 = function ()
    {
      this.X = 0;
      this.Y = 0;
      this.Z = 0;
    };
    ClipperLib.IntPoint1 = function (pt)
    {
      this.X = pt.X;
      this.Y = pt.Y;
      this.Z = pt.Z;
    };
    ClipperLib.IntPoint1dp = function (dp)
    {
      this.X = ClipperLib.Clipper.Round(dp.X);
      this.Y = ClipperLib.Clipper.Round(dp.Y);
      this.Z = 0;
    };
    ClipperLib.IntPoint2 = function (x, y)
    {
      this.X = x;
      this.Y = y;
      this.Z = 0;
    };
    ClipperLib.IntPoint3 = function (x, y, z)
    {
      this.X = x;
      this.Y = y;
      this.Z = z;
    };
  }
  else // if (!use_xyz)
  {
    ClipperLib.IntPoint0 = function ()
    {
      this.X = 0;
      this.Y = 0;
    };
    ClipperLib.IntPoint1 = function (pt)
    {
      this.X = pt.X;
      this.Y = pt.Y;
    };
    ClipperLib.IntPoint1dp = function (dp)
    {
      this.X = ClipperLib.Clipper.Round(dp.X);
      this.Y = ClipperLib.Clipper.Round(dp.Y);
    };
    ClipperLib.IntPoint2 = function (x, y)
    {
      this.X = x;
      this.Y = y;
    };
  }
  ClipperLib.IntRect = function ()
  {
    var a = arguments,
      alen = a.length;
    if (alen == 4) // function (l, t, r, b)
    {
      this.left = a[0];
      this.top = a[1];
      this.right = a[2];
      this.bottom = a[3];
    }
    else if (alen == 1) // function (ir)
    {
      this.left = ir.left;
      this.top = ir.top;
      this.right = ir.right;
      this.bottom = ir.bottom;
    }
    else // function ()
    {
      this.left = 0;
      this.top = 0;
      this.right = 0;
      this.bottom = 0;
    }
  };
  ClipperLib.IntRect0 = function ()
  {
    this.left = 0;
    this.top = 0;
    this.right = 0;
    this.bottom = 0;
  };
  ClipperLib.IntRect1 = function (ir)
  {
    this.left = ir.left;
    this.top = ir.top;
    this.right = ir.right;
    this.bottom = ir.bottom;
  };
  ClipperLib.IntRect4 = function (l, t, r, b)
  {
    this.left = l;
    this.top = t;
    this.right = r;
    this.bottom = b;
  };
  ClipperLib.ClipType = {
    ctIntersection: 0,
    ctUnion: 1,
    ctDifference: 2,
    ctXor: 3
  };
  ClipperLib.PolyType = {
    ptSubject: 0,
    ptClip: 1
  };
  ClipperLib.PolyFillType = {
    pftEvenOdd: 0,
    pftNonZero: 1,
    pftPositive: 2,
    pftNegative: 3
  };
  ClipperLib.JoinType = {
    jtSquare: 0,
    jtRound: 1,
    jtMiter: 2
  };
  ClipperLib.EndType = {
    etOpenSquare: 0,
    etOpenRound: 1,
    etOpenButt: 2,
    etClosedLine: 3,
    etClosedPolygon: 4
  };
  ClipperLib.EdgeSide = {
    esLeft: 0,
    esRight: 1
  };
  ClipperLib.Direction = {
    dRightToLeft: 0,
    dLeftToRight: 1
  };
  ClipperLib.TEdge = function ()
  {
    this.Bot = new ClipperLib.IntPoint();
    this.Curr = new ClipperLib.IntPoint();
    this.Top = new ClipperLib.IntPoint();
    this.Delta = new ClipperLib.IntPoint();
    this.Dx = 0;
    this.PolyTyp = ClipperLib.PolyType.ptSubject;
    this.Side = ClipperLib.EdgeSide.esLeft;
    this.WindDelta = 0;
    this.WindCnt = 0;
    this.WindCnt2 = 0;
    this.OutIdx = 0;
    this.Next = null;
    this.Prev = null;
    this.NextInLML = null;
    this.NextInAEL = null;
    this.PrevInAEL = null;
    this.NextInSEL = null;
    this.PrevInSEL = null;
  };
  ClipperLib.IntersectNode = function ()
  {
    this.Edge1 = null;
    this.Edge2 = null;
    this.Pt = new ClipperLib.IntPoint();
  };
  ClipperLib.MyIntersectNodeSort = function () {};
  ClipperLib.MyIntersectNodeSort.Compare = function (node1, node2)
  {
    var i = node2.Pt.Y - node1.Pt.Y;
    if (i > 0) return 1;
    else if (i < 0) return -1;
    else return 0;
  };

  ClipperLib.LocalMinima = function ()
  {
    this.Y = 0;
    this.LeftBound = null;
    this.RightBound = null;
    this.Next = null;
  };
  ClipperLib.Scanbeam = function ()
  {
    this.Y = 0;
    this.Next = null;
  };
  ClipperLib.OutRec = function ()
  {
    this.Idx = 0;
    this.IsHole = false;
    this.IsOpen = false;
    this.FirstLeft = null;
    this.Pts = null;
    this.BottomPt = null;
    this.PolyNode = null;
  };
  ClipperLib.OutPt = function ()
  {
    this.Idx = 0;
    this.Pt = new ClipperLib.IntPoint();
    this.Next = null;
    this.Prev = null;
  };
  ClipperLib.Join = function ()
  {
    this.OutPt1 = null;
    this.OutPt2 = null;
    this.OffPt = new ClipperLib.IntPoint();
  };
  ClipperLib.ClipperBase = function ()
  {
    this.m_MinimaList = null;
    this.m_CurrentLM = null;
    this.m_edges = new Array();
    this.m_UseFullRange = false;
    this.m_HasOpenPaths = false;
    this.PreserveCollinear = false;
    this.m_MinimaList = null;
    this.m_CurrentLM = null;
    this.m_UseFullRange = false;
    this.m_HasOpenPaths = false;
  };
  // Ranges are in original C# too high for Javascript (in current state 2013 september):
  // protected const double horizontal = -3.4E+38;
  // internal const cInt loRange = 0x3FFFFFFF; // = 1073741823 = sqrt(2^63 -1)/2
  // internal const cInt hiRange = 0x3FFFFFFFFFFFFFFFL; // = 4611686018427387903 = sqrt(2^127 -1)/2
  // So had to adjust them to more suitable for Javascript.
  // If JS some day supports truly 64-bit integers, then these ranges can be as in C#
  // and biginteger library can be more simpler (as then 128bit can be represented as two 64bit numbers)
  ClipperLib.ClipperBase.horizontal = -9007199254740992; //-2^53
  ClipperLib.ClipperBase.Skip = -2;
  ClipperLib.ClipperBase.Unassigned = -1;
  ClipperLib.ClipperBase.tolerance = 1E-20;
  if (use_int32)
  {
    ClipperLib.ClipperBase.loRange = 0x7FFF;
    ClipperLib.ClipperBase.hiRange = 0x7FFF;
  }
  else
  {
    ClipperLib.ClipperBase.loRange = 47453132; // sqrt(2^53 -1)/2
    ClipperLib.ClipperBase.hiRange = 4503599627370495; // sqrt(2^106 -1)/2
  }

  ClipperLib.ClipperBase.near_zero = function (val)
  {
    return (val > -ClipperLib.ClipperBase.tolerance) && (val < ClipperLib.ClipperBase.tolerance);
  };
  ClipperLib.ClipperBase.IsHorizontal = function (e)
  {
    return e.Delta.Y === 0;
  };
  ClipperLib.ClipperBase.prototype.PointIsVertex = function (pt, pp)
  {
    var pp2 = pp;
    do {
      if (ClipperLib.IntPoint.op_Equality(pp2.Pt, pt))
        return true;
      pp2 = pp2.Next;
    }
    while (pp2 != pp)
    return false;
  };
  ClipperLib.ClipperBase.prototype.PointOnLineSegment = function (pt, linePt1, linePt2, UseFullRange)
  {
    if (UseFullRange)
      return ((pt.X == linePt1.X) && (pt.Y == linePt1.Y)) ||
        ((pt.X == linePt2.X) && (pt.Y == linePt2.Y)) ||
        (((pt.X > linePt1.X) == (pt.X < linePt2.X)) &&
        ((pt.Y > linePt1.Y) == (pt.Y < linePt2.Y)) &&
        (Int128.op_Equality(Int128.Int128Mul((pt.X - linePt1.X), (linePt2.Y - linePt1.Y)),
          Int128.Int128Mul((linePt2.X - linePt1.X), (pt.Y - linePt1.Y)))));
    else
      return ((pt.X == linePt1.X) && (pt.Y == linePt1.Y)) || ((pt.X == linePt2.X) && (pt.Y == linePt2.Y)) || (((pt.X > linePt1.X) == (pt.X < linePt2.X)) && ((pt.Y > linePt1.Y) == (pt.Y < linePt2.Y)) && ((pt.X - linePt1.X) * (linePt2.Y - linePt1.Y) == (linePt2.X - linePt1.X) * (pt.Y - linePt1.Y)));
  };
  ClipperLib.ClipperBase.prototype.PointOnPolygon = function (pt, pp, UseFullRange)
  {
    var pp2 = pp;
    while (true)
    {
      if (this.PointOnLineSegment(pt, pp2.Pt, pp2.Next.Pt, UseFullRange))
        return true;
      pp2 = pp2.Next;
      if (pp2 == pp)
        break;
    }
    return false;
  };
  ClipperLib.ClipperBase.prototype.SlopesEqual = ClipperLib.ClipperBase.SlopesEqual = function ()
  {
    var a = arguments,
      alen = a.length;
    var e1, e2, pt1, pt2, pt3, pt4, UseFullRange;
    if (alen == 3) // function (e1, e2, UseFullRange)
    {
      e1 = a[0];
      e2 = a[1];
      UseFullRange = a[2];
      if (UseFullRange)
        return Int128.op_Equality(Int128.Int128Mul(e1.Delta.Y, e2.Delta.X), Int128.Int128Mul(e1.Delta.X, e2.Delta.Y));
      else
        return ClipperLib.Cast_Int64((e1.Delta.Y) * (e2.Delta.X)) == ClipperLib.Cast_Int64((e1.Delta.X) * (e2.Delta.Y));
    }
    else if (alen == 4) // function (pt1, pt2, pt3, UseFullRange)
    {
      pt1 = a[0];
      pt2 = a[1];
      pt3 = a[2];
      UseFullRange = a[3];
      if (UseFullRange)
        return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt2.X - pt3.X), Int128.Int128Mul(pt1.X - pt2.X, pt2.Y - pt3.Y));
      else
        return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt2.X - pt3.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt2.Y - pt3.Y)) === 0;
    }
    else // function (pt1, pt2, pt3, pt4, UseFullRange)
    {
      pt1 = a[0];
      pt2 = a[1];
      pt3 = a[2];
      pt4 = a[3];
      UseFullRange = a[4];
      if (UseFullRange)
        return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt3.X - pt4.X), Int128.Int128Mul(pt1.X - pt2.X, pt3.Y - pt4.Y));
      else
        return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt3.X - pt4.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt3.Y - pt4.Y)) === 0;
    }
  };
  ClipperLib.ClipperBase.SlopesEqual3 = function (e1, e2, UseFullRange)
  {
    if (UseFullRange)
      return Int128.op_Equality(Int128.Int128Mul(e1.Delta.Y, e2.Delta.X), Int128.Int128Mul(e1.Delta.X, e2.Delta.Y));
    else
      return ClipperLib.Cast_Int64((e1.Delta.Y) * (e2.Delta.X)) == ClipperLib.Cast_Int64((e1.Delta.X) * (e2.Delta.Y));
  };
  ClipperLib.ClipperBase.SlopesEqual4 = function (pt1, pt2, pt3, UseFullRange)
  {
    if (UseFullRange)
      return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt2.X - pt3.X), Int128.Int128Mul(pt1.X - pt2.X, pt2.Y - pt3.Y));
    else
      return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt2.X - pt3.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt2.Y - pt3.Y)) === 0;
  };
  ClipperLib.ClipperBase.SlopesEqual5 = function (pt1, pt2, pt3, pt4, UseFullRange)
  {
    if (UseFullRange)
      return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt3.X - pt4.X), Int128.Int128Mul(pt1.X - pt2.X, pt3.Y - pt4.Y));
    else
      return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt3.X - pt4.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt3.Y - pt4.Y)) === 0;
  };
  ClipperLib.ClipperBase.prototype.Clear = function ()
  {
    this.DisposeLocalMinimaList();
    for (var i = 0, ilen = this.m_edges.length; i < ilen; ++i)
    {
      for (var j = 0, jlen = this.m_edges[i].length; j < jlen; ++j)
        this.m_edges[i][j] = null;
      ClipperLib.Clear(this.m_edges[i]);
    }
    ClipperLib.Clear(this.m_edges);
    this.m_UseFullRange = false;
    this.m_HasOpenPaths = false;
  };
  ClipperLib.ClipperBase.prototype.DisposeLocalMinimaList = function ()
  {
    while (this.m_MinimaList !== null)
    {
      var tmpLm = this.m_MinimaList.Next;
      this.m_MinimaList = null;
      this.m_MinimaList = tmpLm;
    }
    this.m_CurrentLM = null;
  };
  ClipperLib.ClipperBase.prototype.RangeTest = function (Pt, useFullRange)
  {
    if (useFullRange.Value)
    {
      if (Pt.X > ClipperLib.ClipperBase.hiRange || Pt.Y > ClipperLib.ClipperBase.hiRange || -Pt.X > ClipperLib.ClipperBase.hiRange || -Pt.Y > ClipperLib.ClipperBase.hiRange)
        ClipperLib.Error("Coordinate outside allowed range in RangeTest().");
    }
    else if (Pt.X > ClipperLib.ClipperBase.loRange || Pt.Y > ClipperLib.ClipperBase.loRange || -Pt.X > ClipperLib.ClipperBase.loRange || -Pt.Y > ClipperLib.ClipperBase.loRange)
    {
      useFullRange.Value = true;
      this.RangeTest(Pt, useFullRange);
    }
  };
  ClipperLib.ClipperBase.prototype.InitEdge = function (e, eNext, ePrev, pt)
  {
    e.Next = eNext;
    e.Prev = ePrev;
    //e.Curr = pt;
    e.Curr.X = pt.X;
    e.Curr.Y = pt.Y;
    e.OutIdx = -1;
  };
  ClipperLib.ClipperBase.prototype.InitEdge2 = function (e, polyType)
  {
    if (e.Curr.Y >= e.Next.Curr.Y)
    {
      //e.Bot = e.Curr;
      e.Bot.X = e.Curr.X;
      e.Bot.Y = e.Curr.Y;
      //e.Top = e.Next.Curr;
      e.Top.X = e.Next.Curr.X;
      e.Top.Y = e.Next.Curr.Y;
    }
    else
    {
      //e.Top = e.Curr;
      e.Top.X = e.Curr.X;
      e.Top.Y = e.Curr.Y;
      //e.Bot = e.Next.Curr;
      e.Bot.X = e.Next.Curr.X;
      e.Bot.Y = e.Next.Curr.Y;
    }
    this.SetDx(e);
    e.PolyTyp = polyType;
  };
  ClipperLib.ClipperBase.prototype.FindNextLocMin = function (E)
  {
    var E2;
    for (;;)
    {
      while (ClipperLib.IntPoint.op_Inequality(E.Bot, E.Prev.Bot) || ClipperLib.IntPoint.op_Equality(E.Curr, E.Top))
        E = E.Next;
      if (E.Dx != ClipperLib.ClipperBase.horizontal && E.Prev.Dx != ClipperLib.ClipperBase.horizontal)
        break;
      while (E.Prev.Dx == ClipperLib.ClipperBase.horizontal)
        E = E.Prev;
      E2 = E;
      while (E.Dx == ClipperLib.ClipperBase.horizontal)
        E = E.Next;
      if (E.Top.Y == E.Prev.Bot.Y)
        continue;
      //ie just an intermediate horz.
      if (E2.Prev.Bot.X < E.Bot.X)
        E = E2;
      break;
    }
    return E;
  };
  ClipperLib.ClipperBase.prototype.ProcessBound = function (E, LeftBoundIsForward)
  {
    var EStart;
    var Result = E;
    var Horz;

      if (Result.OutIdx == ClipperLib.ClipperBase.Skip)
      {
        //check if there are edges beyond the skip edge in the bound and if so
        //create another LocMin and calling ProcessBound once more ...
        E = Result;
        if (LeftBoundIsForward)
        {
          while (E.Top.Y == E.Next.Bot.Y) E = E.Next;
          while (E != Result && E.Dx == ClipperLib.ClipperBase.horizontal) E = E.Prev;
        }
        else
        {
          while (E.Top.Y == E.Prev.Bot.Y) E = E.Prev;
          while (E != Result && E.Dx == ClipperLib.ClipperBase.horizontal) E = E.Next;
        }
        if (E == Result)
        {
          if (LeftBoundIsForward) Result = E.Next;
          else Result = E.Prev;
        }
        else
        {
          //there are more edges in the bound beyond result starting with E
          if (LeftBoundIsForward)
            E = Result.Next;
          else
            E = Result.Prev;
          var locMin = new ClipperLib.LocalMinima();
          locMin.Next = null;
          locMin.Y = E.Bot.Y;
          locMin.LeftBound = null;
          locMin.RightBound = E;
          E.WindDelta = 0;
          Result = this.ProcessBound(E, LeftBoundIsForward);
          this.InsertLocalMinima(locMin);
        }
        return Result;
      }

      if (E.Dx == ClipperLib.ClipperBase.horizontal)
      {
        //We need to be careful with open paths because this may not be a
        //true local minima (ie E may be following a skip edge).
        //Also, consecutive horz. edges may start heading left before going right.
        if (LeftBoundIsForward) EStart = E.Prev;
        else EStart = E.Next;
        if (EStart.OutIdx != ClipperLib.ClipperBase.Skip)
        {
          if (EStart.Dx == ClipperLib.ClipperBase.horizontal) //ie an adjoining horizontal skip edge
          {
            if (EStart.Bot.X != E.Bot.X && EStart.Top.X != E.Bot.X)
              this.ReverseHorizontal(E);
          }
          else if (EStart.Bot.X != E.Bot.X)
            this.ReverseHorizontal(E);
        }
      }

      EStart = E;
      if (LeftBoundIsForward)
      {
        while (Result.Top.Y == Result.Next.Bot.Y && Result.Next.OutIdx != ClipperLib.ClipperBase.Skip)
          Result = Result.Next;
        if (Result.Dx == ClipperLib.ClipperBase.horizontal && Result.Next.OutIdx != ClipperLib.ClipperBase.Skip)
        {
          //nb: at the top of a bound, horizontals are added to the bound
          //only when the preceding edge attaches to the horizontal's left vertex
          //unless a Skip edge is encountered when that becomes the top divide
          Horz = Result;
          while (Horz.Prev.Dx == ClipperLib.ClipperBase.horizontal)
            Horz = Horz.Prev;
          if (Horz.Prev.Top.X == Result.Next.Top.X)
          {
            if (!LeftBoundIsForward)
              Result = Horz.Prev;
          }
          else if (Horz.Prev.Top.X > Result.Next.Top.X)
            Result = Horz.Prev;
        }
        while (E != Result)
        {
          E.NextInLML = E.Next;
          if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Prev.Top.X)
            this.ReverseHorizontal(E);
          E = E.Next;
        }
        if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Prev.Top.X)
          this.ReverseHorizontal(E);
        Result = Result.Next;
        //move to the edge just beyond current bound
      }
      else
      {
        while (Result.Top.Y == Result.Prev.Bot.Y && Result.Prev.OutIdx != ClipperLib.ClipperBase.Skip)
          Result = Result.Prev;
        if (Result.Dx == ClipperLib.ClipperBase.horizontal && Result.Prev.OutIdx != ClipperLib.ClipperBase.Skip)
        {
          Horz = Result;
          while (Horz.Next.Dx == ClipperLib.ClipperBase.horizontal)
            Horz = Horz.Next;
          if (Horz.Next.Top.X == Result.Prev.Top.X)
          {
            if (!LeftBoundIsForward)
              Result = Horz.Next;
          }
          else if (Horz.Next.Top.X > Result.Prev.Top.X)
            Result = Horz.Next;
        }
        while (E != Result)
        {
          E.NextInLML = E.Prev;
          if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Next.Top.X)
            this.ReverseHorizontal(E);
          E = E.Prev;
        }
        if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Next.Top.X)
          this.ReverseHorizontal(E);
        Result = Result.Prev;
        //move to the edge just beyond current bound
      }

    return Result;
  };

  ClipperLib.ClipperBase.prototype.AddPath = function (pg, polyType, Closed)
  {
    if (use_lines)
    {
      if (!Closed && polyType == ClipperLib.PolyType.ptClip)
        ClipperLib.Error("AddPath: Open paths must be subject.");
    }
    else
    {
      if (!Closed)
        ClipperLib.Error("AddPath: Open paths have been disabled.");
    }
    var highI = pg.length - 1;
    if (Closed)
      while (highI > 0 && (ClipperLib.IntPoint.op_Equality(pg[highI], pg[0])))
    --highI;
    while (highI > 0 && (ClipperLib.IntPoint.op_Equality(pg[highI], pg[highI - 1])))
    --highI;
    if ((Closed && highI < 2) || (!Closed && highI < 1))
      return false;
    //create a new edge array ...
    var edges = new Array();
    for (var i = 0; i <= highI; i++)
      edges.push(new ClipperLib.TEdge());
    var IsFlat = true;
    //1. Basic (first) edge initialization ...

    //edges[1].Curr = pg[1];
    edges[1].Curr.X = pg[1].X;
    edges[1].Curr.Y = pg[1].Y;

    var $1 = {Value: this.m_UseFullRange};
    this.RangeTest(pg[0], $1);
    this.m_UseFullRange = $1.Value;

    $1.Value = this.m_UseFullRange;
    this.RangeTest(pg[highI], $1);
    this.m_UseFullRange = $1.Value;

    this.InitEdge(edges[0], edges[1], edges[highI], pg[0]);
    this.InitEdge(edges[highI], edges[0], edges[highI - 1], pg[highI]);
    for (var i = highI - 1; i >= 1; --i)
    {
      $1.Value = this.m_UseFullRange;
      this.RangeTest(pg[i], $1);
      this.m_UseFullRange = $1.Value;

      this.InitEdge(edges[i], edges[i + 1], edges[i - 1], pg[i]);
    }

    var eStart = edges[0];
    //2. Remove duplicate vertices, and (when closed) collinear edges ...
    var E = eStart,
      eLoopStop = eStart;
    for (;;)
    {
    //console.log(E.Next, eStart);
    	//nb: allows matching start and end points when not Closed ...
      if (E.Curr == E.Next.Curr && (Closed || E.Next != eStart))
      {
        if (E == E.Next)
          break;
        if (E == eStart)
          eStart = E.Next;
        E = this.RemoveEdge(E);
        eLoopStop = E;
        continue;
      }
      if (E.Prev == E.Next)
        break;
      else if (Closed && ClipperLib.ClipperBase.SlopesEqual(E.Prev.Curr, E.Curr, E.Next.Curr, this.m_UseFullRange) && (!this.PreserveCollinear || !this.Pt2IsBetweenPt1AndPt3(E.Prev.Curr, E.Curr, E.Next.Curr)))
      {
        //Collinear edges are allowed for open paths but in closed paths
        //the default is to merge adjacent collinear edges into a single edge.
        //However, if the PreserveCollinear property is enabled, only overlapping
        //collinear edges (ie spikes) will be removed from closed paths.
        if (E == eStart)
          eStart = E.Next;
        E = this.RemoveEdge(E);
        E = E.Prev;
        eLoopStop = E;
        continue;
      }
      E = E.Next;
      if ((E == eLoopStop) || (!Closed && E.Next == eStart)) break;
    }
    if ((!Closed && (E == E.Next)) || (Closed && (E.Prev == E.Next)))
      return false;
    if (!Closed)
    {
      this.m_HasOpenPaths = true;
      eStart.Prev.OutIdx = ClipperLib.ClipperBase.Skip;
    }
    //3. Do second stage of edge initialization ...
    E = eStart;
    do {
      this.InitEdge2(E, polyType);
      E = E.Next;
      if (IsFlat && E.Curr.Y != eStart.Curr.Y)
        IsFlat = false;
    }
    while (E != eStart)
    //4. Finally, add edge bounds to LocalMinima list ...
    //Totally flat paths must be handled differently when adding them
    //to LocalMinima list to avoid endless loops etc ...
    if (IsFlat)
    {
      if (Closed)
        return false;
      E.Prev.OutIdx = ClipperLib.ClipperBase.Skip;
      if (E.Prev.Bot.X < E.Prev.Top.X)
        this.ReverseHorizontal(E.Prev);
      var locMin = new ClipperLib.LocalMinima();
      locMin.Next = null;
      locMin.Y = E.Bot.Y;
      locMin.LeftBound = null;
      locMin.RightBound = E;
      locMin.RightBound.Side = ClipperLib.EdgeSide.esRight;
      locMin.RightBound.WindDelta = 0;
      while (E.Next.OutIdx != ClipperLib.ClipperBase.Skip)
      {
        E.NextInLML = E.Next;
        if (E.Bot.X != E.Prev.Top.X)
          this.ReverseHorizontal(E);
        E = E.Next;
      }
      this.InsertLocalMinima(locMin);
      this.m_edges.push(edges);
      return true;
    }
    this.m_edges.push(edges);
    var leftBoundIsForward;
    var EMin = null;

		//workaround to avoid an endless loop in the while loop below when
    //open paths have matching start and end points ...
    if(ClipperLib.IntPoint.op_Equality(E.Prev.Bot, E.Prev.Top))
    	E = E.Next;

    for (;;)
    {
      E = this.FindNextLocMin(E);
      if (E == EMin)
        break;
      else if (EMin == null)
        EMin = E;
      //E and E.Prev now share a local minima (left aligned if horizontal).
      //Compare their slopes to find which starts which bound ...
      var locMin = new ClipperLib.LocalMinima();
      locMin.Next = null;
      locMin.Y = E.Bot.Y;
      if (E.Dx < E.Prev.Dx)
      {
        locMin.LeftBound = E.Prev;
        locMin.RightBound = E;
        leftBoundIsForward = false;
        //Q.nextInLML = Q.prev
      }
      else
      {
        locMin.LeftBound = E;
        locMin.RightBound = E.Prev;
        leftBoundIsForward = true;
        //Q.nextInLML = Q.next
      }
      locMin.LeftBound.Side = ClipperLib.EdgeSide.esLeft;
      locMin.RightBound.Side = ClipperLib.EdgeSide.esRight;
      if (!Closed)
        locMin.LeftBound.WindDelta = 0;
      else if (locMin.LeftBound.Next == locMin.RightBound)
        locMin.LeftBound.WindDelta = -1;
      else
        locMin.LeftBound.WindDelta = 1;
      locMin.RightBound.WindDelta = -locMin.LeftBound.WindDelta;
      E = this.ProcessBound(locMin.LeftBound, leftBoundIsForward);
      if (E.OutIdx == ClipperLib.ClipperBase.Skip)
      	E = this.ProcessBound(E, leftBoundIsForward);
      var E2 = this.ProcessBound(locMin.RightBound, !leftBoundIsForward);
      if (E2.OutIdx == ClipperLib.ClipperBase.Skip) E2 = this.ProcessBound(E2, !leftBoundIsForward);
      if (locMin.LeftBound.OutIdx == ClipperLib.ClipperBase.Skip)
        locMin.LeftBound = null;
      else if (locMin.RightBound.OutIdx == ClipperLib.ClipperBase.Skip)
        locMin.RightBound = null;
      this.InsertLocalMinima(locMin);
      if (!leftBoundIsForward)
        E = E2;
    }
    return true;
  };
  ClipperLib.ClipperBase.prototype.AddPaths = function (ppg, polyType, closed)
  {
    //  console.log("-------------------------------------------");
    //  console.log(JSON.stringify(ppg));
    var result = false;
    for (var i = 0, ilen = ppg.length; i < ilen; ++i)
      if (this.AddPath(ppg[i], polyType, closed))
        result = true;
    return result;
  };
  //------------------------------------------------------------------------------
  ClipperLib.ClipperBase.prototype.Pt2IsBetweenPt1AndPt3 = function (pt1, pt2, pt3)
  {
    if ((ClipperLib.IntPoint.op_Equality(pt1, pt3)) || (ClipperLib.IntPoint.op_Equality(pt1, pt2)) ||       (ClipperLib.IntPoint.op_Equality(pt3, pt2)))

   //if ((pt1 == pt3) || (pt1 == pt2) || (pt3 == pt2))
   return false;

    else if (pt1.X != pt3.X)
      return (pt2.X > pt1.X) == (pt2.X < pt3.X);
    else
      return (pt2.Y > pt1.Y) == (pt2.Y < pt3.Y);
  };
  ClipperLib.ClipperBase.prototype.RemoveEdge = function (e)
  {
    //removes e from double_linked_list (but without removing from memory)
    e.Prev.Next = e.Next;
    e.Next.Prev = e.Prev;
    var result = e.Next;
    e.Prev = null; //flag as removed (see ClipperBase.Clear)
    return result;
  };
  ClipperLib.ClipperBase.prototype.SetDx = function (e)
  {
    e.Delta.X = (e.Top.X - e.Bot.X);
    e.Delta.Y = (e.Top.Y - e.Bot.Y);
    if (e.Delta.Y === 0) e.Dx = ClipperLib.ClipperBase.horizontal;
    else e.Dx = (e.Delta.X) / (e.Delta.Y);
  };
  ClipperLib.ClipperBase.prototype.InsertLocalMinima = function (newLm)
  {
    if (this.m_MinimaList === null)
    {
      this.m_MinimaList = newLm;
    }
    else if (newLm.Y >= this.m_MinimaList.Y)
    {
      newLm.Next = this.m_MinimaList;
      this.m_MinimaList = newLm;
    }
    else
    {
      var tmpLm = this.m_MinimaList;
      while (tmpLm.Next !== null && (newLm.Y < tmpLm.Next.Y))
        tmpLm = tmpLm.Next;
      newLm.Next = tmpLm.Next;
      tmpLm.Next = newLm;
    }
  };
  ClipperLib.ClipperBase.prototype.PopLocalMinima = function ()
  {
    if (this.m_CurrentLM === null)
      return;
    this.m_CurrentLM = this.m_CurrentLM.Next;
  };
  ClipperLib.ClipperBase.prototype.ReverseHorizontal = function (e)
  {
    //swap horizontal edges' top and bottom x's so they follow the natural
    //progression of the bounds - ie so their xbots will align with the
    //adjoining lower edge. [Helpful in the ProcessHorizontal() method.]
    var tmp = e.Top.X;
    e.Top.X = e.Bot.X;
    e.Bot.X = tmp;
    if (use_xyz)
    {
      tmp = e.Top.Z;
      e.Top.Z = e.Bot.Z;
      e.Bot.Z = tmp;
    }
  };
  ClipperLib.ClipperBase.prototype.Reset = function ()
  {
    this.m_CurrentLM = this.m_MinimaList;
    if (this.m_CurrentLM == null)
      return;
    //ie nothing to process
    //reset all edges ...
    var lm = this.m_MinimaList;
    while (lm != null)
    {
      var e = lm.LeftBound;
      if (e != null)
      {
        //e.Curr = e.Bot;
        e.Curr.X = e.Bot.X;
        e.Curr.Y = e.Bot.Y;
        e.Side = ClipperLib.EdgeSide.esLeft;
        e.OutIdx = ClipperLib.ClipperBase.Unassigned;
      }
      e = lm.RightBound;
      if (e != null)
      {
        //e.Curr = e.Bot;
        e.Curr.X = e.Bot.X;
        e.Curr.Y = e.Bot.Y;
        e.Side = ClipperLib.EdgeSide.esRight;
        e.OutIdx = ClipperLib.ClipperBase.Unassigned;
      }
      lm = lm.Next;
    }
  };
  ClipperLib.Clipper = function (InitOptions) // public Clipper(int InitOptions = 0)
  {
    if (typeof (InitOptions) == "undefined") InitOptions = 0;
    this.m_PolyOuts = null;
    this.m_ClipType = ClipperLib.ClipType.ctIntersection;
    this.m_Scanbeam = null;
    this.m_ActiveEdges = null;
    this.m_SortedEdges = null;
    this.m_IntersectList = null;
    this.m_IntersectNodeComparer = null;
    this.m_ExecuteLocked = false;
    this.m_ClipFillType = ClipperLib.PolyFillType.pftEvenOdd;
    this.m_SubjFillType = ClipperLib.PolyFillType.pftEvenOdd;
    this.m_Joins = null;
    this.m_GhostJoins = null;
    this.m_UsingPolyTree = false;
    this.ReverseSolution = false;
    this.StrictlySimple = false;
    ClipperLib.ClipperBase.call(this);
    this.m_Scanbeam = null;
    this.m_ActiveEdges = null;
    this.m_SortedEdges = null;
    this.m_IntersectList = new Array();
    this.m_IntersectNodeComparer = ClipperLib.MyIntersectNodeSort.Compare;
    this.m_ExecuteLocked = false;
    this.m_UsingPolyTree = false;
    this.m_PolyOuts = new Array();
    this.m_Joins = new Array();
    this.m_GhostJoins = new Array();
    this.ReverseSolution = (1 & InitOptions) !== 0;
    this.StrictlySimple = (2 & InitOptions) !== 0;
    this.PreserveCollinear = (4 & InitOptions) !== 0;
    if (use_xyz)
    {
      this.ZFillFunction = null; // function (IntPoint vert1, IntPoint vert2, ref IntPoint intersectPt);
    }
  };
  ClipperLib.Clipper.ioReverseSolution = 1;
  ClipperLib.Clipper.ioStrictlySimple = 2;
  ClipperLib.Clipper.ioPreserveCollinear = 4;

  ClipperLib.Clipper.prototype.Clear = function ()
  {
    if (this.m_edges.length === 0)
      return;
    //avoids problems with ClipperBase destructor
    this.DisposeAllPolyPts();
    ClipperLib.ClipperBase.prototype.Clear.call(this);
  };

  ClipperLib.Clipper.prototype.DisposeScanbeamList = function ()
  {
    while (this.m_Scanbeam !== null)
    {
      var sb2 = this.m_Scanbeam.Next;
      this.m_Scanbeam = null;
      this.m_Scanbeam = sb2;
    }
  };
  ClipperLib.Clipper.prototype.Reset = function ()
  {
    ClipperLib.ClipperBase.prototype.Reset.call(this);
    this.m_Scanbeam = null;
    this.m_ActiveEdges = null;
    this.m_SortedEdges = null;

    var lm = this.m_MinimaList;
    while (lm !== null)
    {
      this.InsertScanbeam(lm.Y);
      lm = lm.Next;
    }
  };
  ClipperLib.Clipper.prototype.InsertScanbeam = function (Y)
  {
    if (this.m_Scanbeam === null)
    {
      this.m_Scanbeam = new ClipperLib.Scanbeam();
      this.m_Scanbeam.Next = null;
      this.m_Scanbeam.Y = Y;
    }
    else if (Y > this.m_Scanbeam.Y)
    {
      var newSb = new ClipperLib.Scanbeam();
      newSb.Y = Y;
      newSb.Next = this.m_Scanbeam;
      this.m_Scanbeam = newSb;
    }
    else
    {
      var sb2 = this.m_Scanbeam;
      while (sb2.Next !== null && (Y <= sb2.Next.Y))
        sb2 = sb2.Next;
      if (Y == sb2.Y)
        return;
      //ie ignores duplicates
      var newSb = new ClipperLib.Scanbeam();
      newSb.Y = Y;
      newSb.Next = sb2.Next;
      sb2.Next = newSb;
    }
  };
  // ************************************
  ClipperLib.Clipper.prototype.Execute = function ()
  {
    var a = arguments,
      alen = a.length,
      ispolytree = a[1] instanceof ClipperLib.PolyTree;
    if (alen == 4 && !ispolytree) // function (clipType, solution, subjFillType, clipFillType)
    {
      var clipType = a[0],
        solution = a[1],
        subjFillType = a[2],
        clipFillType = a[3];
      if (this.m_ExecuteLocked)
        return false;
      if (this.m_HasOpenPaths)
        ClipperLib.Error("Error: PolyTree struct is need for open path clipping.");
      this.m_ExecuteLocked = true;
      ClipperLib.Clear(solution);
      this.m_SubjFillType = subjFillType;
      this.m_ClipFillType = clipFillType;
      this.m_ClipType = clipType;
      this.m_UsingPolyTree = false;
      try
      {
        var succeeded = this.ExecuteInternal();
        //build the return polygons ...
        if (succeeded) this.BuildResult(solution);
      }
      finally
      {
        this.DisposeAllPolyPts();
        this.m_ExecuteLocked = false;
      }
      return succeeded;
    }
    else if (alen == 4 && ispolytree) // function (clipType, polytree, subjFillType, clipFillType)
    {
      var clipType = a[0],
        polytree = a[1],
        subjFillType = a[2],
        clipFillType = a[3];
      if (this.m_ExecuteLocked)
        return false;
      this.m_ExecuteLocked = true;
      this.m_SubjFillType = subjFillType;
      this.m_ClipFillType = clipFillType;
      this.m_ClipType = clipType;
      this.m_UsingPolyTree = true;
      try
      {
        var succeeded = this.ExecuteInternal();
        //build the return polygons ...
        if (succeeded) this.BuildResult2(polytree);
      }
      finally
      {
        this.DisposeAllPolyPts();
        this.m_ExecuteLocked = false;
      }
      return succeeded;
    }
    else if (alen == 2 && !ispolytree) // function (clipType, solution)
    {
      var clipType = a[0],
        solution = a[1];
      return this.Execute(clipType, solution, ClipperLib.PolyFillType.pftEvenOdd, ClipperLib.PolyFillType.pftEvenOdd);
    }
    else if (alen == 2 && ispolytree) // function (clipType, polytree)
    {
      var clipType = a[0],
        polytree = a[1];
      return this.Execute(clipType, polytree, ClipperLib.PolyFillType.pftEvenOdd, ClipperLib.PolyFillType.pftEvenOdd);
    }
  };
  ClipperLib.Clipper.prototype.FixHoleLinkage = function (outRec)
  {
    //skip if an outermost polygon or
    //already already points to the correct FirstLeft ...
    if (outRec.FirstLeft === null || (outRec.IsHole != outRec.FirstLeft.IsHole && outRec.FirstLeft.Pts !== null))
      return;
    var orfl = outRec.FirstLeft;
    while (orfl !== null && ((orfl.IsHole == outRec.IsHole) || orfl.Pts === null))
      orfl = orfl.FirstLeft;
    outRec.FirstLeft = orfl;
  };
  ClipperLib.Clipper.prototype.ExecuteInternal = function ()
  {
    try
    {
      this.Reset();
      if (this.m_CurrentLM === null)
        return false;
      var botY = this.PopScanbeam();
      do {
        this.InsertLocalMinimaIntoAEL(botY);
        ClipperLib.Clear(this.m_GhostJoins);
        this.ProcessHorizontals(false);
        if (this.m_Scanbeam === null)
          break;
        var topY = this.PopScanbeam();
        if (!this.ProcessIntersections(topY)) return false;

        this.ProcessEdgesAtTopOfScanbeam(topY);
        botY = topY;
      }
      while (this.m_Scanbeam !== null || this.m_CurrentLM !== null)
      //fix orientations ...
      for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)
      {
        var outRec = this.m_PolyOuts[i];
        if (outRec.Pts === null || outRec.IsOpen)
          continue;
        if ((outRec.IsHole ^ this.ReverseSolution) == (this.Area(outRec) > 0))
          this.ReversePolyPtLinks(outRec.Pts);
      }
      this.JoinCommonEdges();
      for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)
      {
        var outRec = this.m_PolyOuts[i];
        if (outRec.Pts !== null && !outRec.IsOpen)
          this.FixupOutPolygon(outRec);
      }
      if (this.StrictlySimple)
        this.DoSimplePolygons();
      return true;
    }
    finally
    {
      ClipperLib.Clear(this.m_Joins);
      ClipperLib.Clear(this.m_GhostJoins);
    }
  };
  ClipperLib.Clipper.prototype.PopScanbeam = function ()
  {
    var Y = this.m_Scanbeam.Y;
    this.m_Scanbeam = this.m_Scanbeam.Next;
    return Y;
  };

  ClipperLib.Clipper.prototype.DisposeAllPolyPts = function ()
  {
    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; ++i)
      this.DisposeOutRec(i);
    ClipperLib.Clear(this.m_PolyOuts);
  };
  ClipperLib.Clipper.prototype.DisposeOutRec = function (index)
  {
    var outRec = this.m_PolyOuts[index];
    outRec.Pts = null;
    outRec = null;
    this.m_PolyOuts[index] = null;
  };

  ClipperLib.Clipper.prototype.AddJoin = function (Op1, Op2, OffPt)
  {
    var j = new ClipperLib.Join();
    j.OutPt1 = Op1;
    j.OutPt2 = Op2;
    //j.OffPt = OffPt;
    j.OffPt.X = OffPt.X;
    j.OffPt.Y = OffPt.Y;
    this.m_Joins.push(j);
  };
  ClipperLib.Clipper.prototype.AddGhostJoin = function (Op, OffPt)
  {
    var j = new ClipperLib.Join();
    j.OutPt1 = Op;
    //j.OffPt = OffPt;
    j.OffPt.X = OffPt.X;
    j.OffPt.Y = OffPt.Y;
    this.m_GhostJoins.push(j);
  };
  if (use_xyz)
  {
    ClipperLib.Clipper.prototype.SetZ = function (pt, e1, e2)
    {
      if (this.ZFillFunction !== null)
      {
        if (pt.Z != 0 || this.ZFillFunction === null) return;
        else if (ClipperLib.IntPoint.op_Equality(pt, e1.Bot)) pt.Z = e1.Bot.Z;
        else if (ClipperLib.IntPoint.op_Equality(pt, e1.Top)) pt.Z = e1.Top.Z;
        else if (ClipperLib.IntPoint.op_Equality(pt, e2.Bot)) pt.Z = e2.Bot.Z;
        else if (ClipperLib.IntPoint.op_Equality(pt, e2.Top)) pt.Z = e2.Top.Z;
        else ZFillFunction(e1.Bot, e1.Top, e2.Bot, e2.Top, pt);
      }
    };

    //------------------------------------------------------------------------------
  }

  ClipperLib.Clipper.prototype.InsertLocalMinimaIntoAEL = function (botY)
  {
    while (this.m_CurrentLM !== null && (this.m_CurrentLM.Y == botY))
    {
      var lb = this.m_CurrentLM.LeftBound;
      var rb = this.m_CurrentLM.RightBound;
      this.PopLocalMinima();
      var Op1 = null;
      if (lb === null)
      {
        this.InsertEdgeIntoAEL(rb, null);
        this.SetWindingCount(rb);
        if (this.IsContributing(rb))
          Op1 = this.AddOutPt(rb, rb.Bot);
      }
      else if (rb == null)
      {
        this.InsertEdgeIntoAEL(lb, null);
        this.SetWindingCount(lb);
        if (this.IsContributing(lb))
          Op1 = this.AddOutPt(lb, lb.Bot);
        this.InsertScanbeam(lb.Top.Y);
      }
      else
      {
        this.InsertEdgeIntoAEL(lb, null);
        this.InsertEdgeIntoAEL(rb, lb);
        this.SetWindingCount(lb);
        rb.WindCnt = lb.WindCnt;
        rb.WindCnt2 = lb.WindCnt2;
        if (this.IsContributing(lb))
          Op1 = this.AddLocalMinPoly(lb, rb, lb.Bot);
        this.InsertScanbeam(lb.Top.Y);
      }
      if (rb != null)
      {
        if (ClipperLib.ClipperBase.IsHorizontal(rb))
          this.AddEdgeToSEL(rb);
        else
          this.InsertScanbeam(rb.Top.Y);
      }
      if (lb == null || rb == null) continue;
      //if output polygons share an Edge with a horizontal rb, they'll need joining later ...
      if (Op1 !== null && ClipperLib.ClipperBase.IsHorizontal(rb) && this.m_GhostJoins.length > 0 && rb.WindDelta !== 0)
      {
        for (var i = 0, ilen = this.m_GhostJoins.length; i < ilen; i++)
        {
          //if the horizontal Rb and a 'ghost' horizontal overlap, then convert
          //the 'ghost' join to a real join ready for later ...
          var j = this.m_GhostJoins[i];

					if (this.HorzSegmentsOverlap(j.OutPt1.Pt.X, j.OffPt.X, rb.Bot.X, rb.Top.X))
            this.AddJoin(j.OutPt1, Op1, j.OffPt);
        }
      }
      if (lb.OutIdx >= 0 && lb.PrevInAEL !== null &&
        lb.PrevInAEL.Curr.X == lb.Bot.X &&
        lb.PrevInAEL.OutIdx >= 0 &&
        ClipperLib.ClipperBase.SlopesEqual(lb.PrevInAEL, lb, this.m_UseFullRange) &&
        lb.WindDelta !== 0 && lb.PrevInAEL.WindDelta !== 0)
      {
        var Op2 = this.AddOutPt(lb.PrevInAEL, lb.Bot);
        this.AddJoin(Op1, Op2, lb.Top);
      }
      if (lb.NextInAEL != rb)
      {
        if (rb.OutIdx >= 0 && rb.PrevInAEL.OutIdx >= 0 &&
          ClipperLib.ClipperBase.SlopesEqual(rb.PrevInAEL, rb, this.m_UseFullRange) &&
          rb.WindDelta !== 0 && rb.PrevInAEL.WindDelta !== 0)
        {
          var Op2 = this.AddOutPt(rb.PrevInAEL, rb.Bot);
          this.AddJoin(Op1, Op2, rb.Top);
        }
        var e = lb.NextInAEL;
        if (e !== null)
          while (e != rb)
          {
            //nb: For calculating winding counts etc, IntersectEdges() assumes
            //that param1 will be to the right of param2 ABOVE the intersection ...
            this.IntersectEdges(rb, e, lb.Curr, false);
            //order important here
            e = e.NextInAEL;
          }
      }
    }
  };
  ClipperLib.Clipper.prototype.InsertEdgeIntoAEL = function (edge, startEdge)
  {
    if (this.m_ActiveEdges === null)
    {
      edge.PrevInAEL = null;
      edge.NextInAEL = null;
      this.m_ActiveEdges = edge;
    }
    else if (startEdge === null && this.E2InsertsBeforeE1(this.m_ActiveEdges, edge))
    {
      edge.PrevInAEL = null;
      edge.NextInAEL = this.m_ActiveEdges;
      this.m_ActiveEdges.PrevInAEL = edge;
      this.m_ActiveEdges = edge;
    }
    else
    {
      if (startEdge === null)
        startEdge = this.m_ActiveEdges;
      while (startEdge.NextInAEL !== null && !this.E2InsertsBeforeE1(startEdge.NextInAEL, edge))
        startEdge = startEdge.NextInAEL;
      edge.NextInAEL = startEdge.NextInAEL;
      if (startEdge.NextInAEL !== null)
        startEdge.NextInAEL.PrevInAEL = edge;
      edge.PrevInAEL = startEdge;
      startEdge.NextInAEL = edge;
    }
  };
  ClipperLib.Clipper.prototype.E2InsertsBeforeE1 = function (e1, e2)
  {
    if (e2.Curr.X == e1.Curr.X)
    {
      if (e2.Top.Y > e1.Top.Y)
        return e2.Top.X < ClipperLib.Clipper.TopX(e1, e2.Top.Y);
      else
        return e1.Top.X > ClipperLib.Clipper.TopX(e2, e1.Top.Y);
    }
    else
      return e2.Curr.X < e1.Curr.X;
  };
  ClipperLib.Clipper.prototype.IsEvenOddFillType = function (edge)
  {
    if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)
      return this.m_SubjFillType == ClipperLib.PolyFillType.pftEvenOdd;
    else
      return this.m_ClipFillType == ClipperLib.PolyFillType.pftEvenOdd;
  };
  ClipperLib.Clipper.prototype.IsEvenOddAltFillType = function (edge)
  {
    if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)
      return this.m_ClipFillType == ClipperLib.PolyFillType.pftEvenOdd;
    else
      return this.m_SubjFillType == ClipperLib.PolyFillType.pftEvenOdd;
  };
  ClipperLib.Clipper.prototype.IsContributing = function (edge)
  {
    var pft, pft2;
    if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)
    {
      pft = this.m_SubjFillType;
      pft2 = this.m_ClipFillType;
    }
    else
    {
      pft = this.m_ClipFillType;
      pft2 = this.m_SubjFillType;
    }
    switch (pft)
    {
    case ClipperLib.PolyFillType.pftEvenOdd:
      if (edge.WindDelta === 0 && edge.WindCnt != 1)
        return false;
      break;
    case ClipperLib.PolyFillType.pftNonZero:
      if (Math.abs(edge.WindCnt) != 1)
        return false;
      break;
    case ClipperLib.PolyFillType.pftPositive:
      if (edge.WindCnt != 1)
        return false;
      break;
    default:
      if (edge.WindCnt != -1)
        return false;
      break;
    }
    switch (this.m_ClipType)
    {
    case ClipperLib.ClipType.ctIntersection:
      switch (pft2)
      {
      case ClipperLib.PolyFillType.pftEvenOdd:
      case ClipperLib.PolyFillType.pftNonZero:
        return (edge.WindCnt2 !== 0);
      case ClipperLib.PolyFillType.pftPositive:
        return (edge.WindCnt2 > 0);
      default:
        return (edge.WindCnt2 < 0);
      }
    case ClipperLib.ClipType.ctUnion:
      switch (pft2)
      {
      case ClipperLib.PolyFillType.pftEvenOdd:
      case ClipperLib.PolyFillType.pftNonZero:
        return (edge.WindCnt2 === 0);
      case ClipperLib.PolyFillType.pftPositive:
        return (edge.WindCnt2 <= 0);
      default:
        return (edge.WindCnt2 >= 0);
      }
    case ClipperLib.ClipType.ctDifference:
      if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)
        switch (pft2)
        {
        case ClipperLib.PolyFillType.pftEvenOdd:
        case ClipperLib.PolyFillType.pftNonZero:
          return (edge.WindCnt2 === 0);
        case ClipperLib.PolyFillType.pftPositive:
          return (edge.WindCnt2 <= 0);
        default:
          return (edge.WindCnt2 >= 0);
        }
      else
        switch (pft2)
        {
        case ClipperLib.PolyFillType.pftEvenOdd:
        case ClipperLib.PolyFillType.pftNonZero:
          return (edge.WindCnt2 !== 0);
        case ClipperLib.PolyFillType.pftPositive:
          return (edge.WindCnt2 > 0);
        default:
          return (edge.WindCnt2 < 0);
        }
    case ClipperLib.ClipType.ctXor:
      if (edge.WindDelta === 0)
        switch (pft2)
        {
        case ClipperLib.PolyFillType.pftEvenOdd:
        case ClipperLib.PolyFillType.pftNonZero:
          return (edge.WindCnt2 === 0);
        case ClipperLib.PolyFillType.pftPositive:
          return (edge.WindCnt2 <= 0);
        default:
          return (edge.WindCnt2 >= 0);
        }
      else
        return true;
    }
    return true;
  };
  ClipperLib.Clipper.prototype.SetWindingCount = function (edge)
  {
    var e = edge.PrevInAEL;
    //find the edge of the same polytype that immediately preceeds 'edge' in AEL
    while (e !== null && ((e.PolyTyp != edge.PolyTyp) || (e.WindDelta === 0)))
      e = e.PrevInAEL;
    if (e === null)
    {
      edge.WindCnt = (edge.WindDelta === 0 ? 1 : edge.WindDelta);
      edge.WindCnt2 = 0;
      e = this.m_ActiveEdges;
      //ie get ready to calc WindCnt2
    }
    else if (edge.WindDelta === 0 && this.m_ClipType != ClipperLib.ClipType.ctUnion)
    {
      edge.WindCnt = 1;
      edge.WindCnt2 = e.WindCnt2;
      e = e.NextInAEL;
      //ie get ready to calc WindCnt2
    }
    else if (this.IsEvenOddFillType(edge))
    {
      //EvenOdd filling ...
      if (edge.WindDelta === 0)
      {
        //are we inside a subj polygon ...
        var Inside = true;
        var e2 = e.PrevInAEL;
        while (e2 !== null)
        {
          if (e2.PolyTyp == e.PolyTyp && e2.WindDelta !== 0)
            Inside = !Inside;
          e2 = e2.PrevInAEL;
        }
        edge.WindCnt = (Inside ? 0 : 1);
      }
      else
      {
        edge.WindCnt = edge.WindDelta;
      }
      edge.WindCnt2 = e.WindCnt2;
      e = e.NextInAEL;
      //ie get ready to calc WindCnt2
    }
    else
    {
      //nonZero, Positive or Negative filling ...
      if (e.WindCnt * e.WindDelta < 0)
      {
        //prev edge is 'decreasing' WindCount (WC) toward zero
        //so we're outside the previous polygon ...
        if (Math.abs(e.WindCnt) > 1)
        {
          //outside prev poly but still inside another.
          //when reversing direction of prev poly use the same WC
          if (e.WindDelta * edge.WindDelta < 0)
            edge.WindCnt = e.WindCnt;
          else
            edge.WindCnt = e.WindCnt + edge.WindDelta;
        }
        else
          edge.WindCnt = (edge.WindDelta === 0 ? 1 : edge.WindDelta);
      }
      else
      {
        //prev edge is 'increasing' WindCount (WC) away from zero
        //so we're inside the previous polygon ...
        if (edge.WindDelta === 0)
          edge.WindCnt = (e.WindCnt < 0 ? e.WindCnt - 1 : e.WindCnt + 1);
        else if (e.WindDelta * edge.WindDelta < 0)
          edge.WindCnt = e.WindCnt;
        else
          edge.WindCnt = e.WindCnt + edge.WindDelta;
      }
      edge.WindCnt2 = e.WindCnt2;
      e = e.NextInAEL;
      //ie get ready to calc WindCnt2
    }
    //update WindCnt2 ...
    if (this.IsEvenOddAltFillType(edge))
    {
      //EvenOdd filling ...
      while (e != edge)
      {
        if (e.WindDelta !== 0)
          edge.WindCnt2 = (edge.WindCnt2 === 0 ? 1 : 0);
        e = e.NextInAEL;
      }
    }
    else
    {
      //nonZero, Positive or Negative filling ...
      while (e != edge)
      {
        edge.WindCnt2 += e.WindDelta;
        e = e.NextInAEL;
      }
    }
  };
  ClipperLib.Clipper.prototype.AddEdgeToSEL = function (edge)
  {
    //SEL pointers in PEdge are reused to build a list of horizontal edges.
    //However, we don't need to worry about order with horizontal edge processing.
    if (this.m_SortedEdges === null)
    {
      this.m_SortedEdges = edge;
      edge.PrevInSEL = null;
      edge.NextInSEL = null;
    }
    else
    {
      edge.NextInSEL = this.m_SortedEdges;
      edge.PrevInSEL = null;
      this.m_SortedEdges.PrevInSEL = edge;
      this.m_SortedEdges = edge;
    }
  };
  ClipperLib.Clipper.prototype.CopyAELToSEL = function ()
  {
    var e = this.m_ActiveEdges;
    this.m_SortedEdges = e;
    while (e !== null)
    {
      e.PrevInSEL = e.PrevInAEL;
      e.NextInSEL = e.NextInAEL;
      e = e.NextInAEL;
    }
  };
  ClipperLib.Clipper.prototype.SwapPositionsInAEL = function (edge1, edge2)
  {
    //check that one or other edge hasn't already been removed from AEL ...
    if (edge1.NextInAEL == edge1.PrevInAEL || edge2.NextInAEL == edge2.PrevInAEL)
      return;
    if (edge1.NextInAEL == edge2)
    {
      var next = edge2.NextInAEL;
      if (next !== null)
        next.PrevInAEL = edge1;
      var prev = edge1.PrevInAEL;
      if (prev !== null)
        prev.NextInAEL = edge2;
      edge2.PrevInAEL = prev;
      edge2.NextInAEL = edge1;
      edge1.PrevInAEL = edge2;
      edge1.NextInAEL = next;
    }
    else if (edge2.NextInAEL == edge1)
    {
      var next = edge1.NextInAEL;
      if (next !== null)
        next.PrevInAEL = edge2;
      var prev = edge2.PrevInAEL;
      if (prev !== null)
        prev.NextInAEL = edge1;
      edge1.PrevInAEL = prev;
      edge1.NextInAEL = edge2;
      edge2.PrevInAEL = edge1;
      edge2.NextInAEL = next;
    }
    else
    {
      var next = edge1.NextInAEL;
      var prev = edge1.PrevInAEL;
      edge1.NextInAEL = edge2.NextInAEL;
      if (edge1.NextInAEL !== null)
        edge1.NextInAEL.PrevInAEL = edge1;
      edge1.PrevInAEL = edge2.PrevInAEL;
      if (edge1.PrevInAEL !== null)
        edge1.PrevInAEL.NextInAEL = edge1;
      edge2.NextInAEL = next;
      if (edge2.NextInAEL !== null)
        edge2.NextInAEL.PrevInAEL = edge2;
      edge2.PrevInAEL = prev;
      if (edge2.PrevInAEL !== null)
        edge2.PrevInAEL.NextInAEL = edge2;
    }
    if (edge1.PrevInAEL === null)
      this.m_ActiveEdges = edge1;
    else if (edge2.PrevInAEL === null)
      this.m_ActiveEdges = edge2;
  };
  ClipperLib.Clipper.prototype.SwapPositionsInSEL = function (edge1, edge2)
  {
    if (edge1.NextInSEL === null && edge1.PrevInSEL === null)
      return;
    if (edge2.NextInSEL === null && edge2.PrevInSEL === null)
      return;
    if (edge1.NextInSEL == edge2)
    {
      var next = edge2.NextInSEL;
      if (next !== null)
        next.PrevInSEL = edge1;
      var prev = edge1.PrevInSEL;
      if (prev !== null)
        prev.NextInSEL = edge2;
      edge2.PrevInSEL = prev;
      edge2.NextInSEL = edge1;
      edge1.PrevInSEL = edge2;
      edge1.NextInSEL = next;
    }
    else if (edge2.NextInSEL == edge1)
    {
      var next = edge1.NextInSEL;
      if (next !== null)
        next.PrevInSEL = edge2;
      var prev = edge2.PrevInSEL;
      if (prev !== null)
        prev.NextInSEL = edge1;
      edge1.PrevInSEL = prev;
      edge1.NextInSEL = edge2;
      edge2.PrevInSEL = edge1;
      edge2.NextInSEL = next;
    }
    else
    {
      var next = edge1.NextInSEL;
      var prev = edge1.PrevInSEL;
      edge1.NextInSEL = edge2.NextInSEL;
      if (edge1.NextInSEL !== null)
        edge1.NextInSEL.PrevInSEL = edge1;
      edge1.PrevInSEL = edge2.PrevInSEL;
      if (edge1.PrevInSEL !== null)
        edge1.PrevInSEL.NextInSEL = edge1;
      edge2.NextInSEL = next;
      if (edge2.NextInSEL !== null)
        edge2.NextInSEL.PrevInSEL = edge2;
      edge2.PrevInSEL = prev;
      if (edge2.PrevInSEL !== null)
        edge2.PrevInSEL.NextInSEL = edge2;
    }
    if (edge1.PrevInSEL === null)
      this.m_SortedEdges = edge1;
    else if (edge2.PrevInSEL === null)
      this.m_SortedEdges = edge2;
  };
  ClipperLib.Clipper.prototype.AddLocalMaxPoly = function (e1, e2, pt)
  {
    this.AddOutPt(e1, pt);
    if (e2.WindDelta == 0) this.AddOutPt(e2, pt);
    if (e1.OutIdx == e2.OutIdx)
    {
      e1.OutIdx = -1;
      e2.OutIdx = -1;
    }
    else if (e1.OutIdx < e2.OutIdx)
      this.AppendPolygon(e1, e2);
    else
      this.AppendPolygon(e2, e1);
  };
  ClipperLib.Clipper.prototype.AddLocalMinPoly = function (e1, e2, pt)
  {
    var result;
    var e, prevE;
    if (ClipperLib.ClipperBase.IsHorizontal(e2) || (e1.Dx > e2.Dx))
    {
      result = this.AddOutPt(e1, pt);
      e2.OutIdx = e1.OutIdx;
      e1.Side = ClipperLib.EdgeSide.esLeft;
      e2.Side = ClipperLib.EdgeSide.esRight;
      e = e1;
      if (e.PrevInAEL == e2)
        prevE = e2.PrevInAEL;
      else
        prevE = e.PrevInAEL;
    }
    else
    {
      result = this.AddOutPt(e2, pt);
      e1.OutIdx = e2.OutIdx;
      e1.Side = ClipperLib.EdgeSide.esRight;
      e2.Side = ClipperLib.EdgeSide.esLeft;
      e = e2;
      if (e.PrevInAEL == e1)
        prevE = e1.PrevInAEL;
      else
        prevE = e.PrevInAEL;
    }
    if (prevE !== null && prevE.OutIdx >= 0 && (ClipperLib.Clipper.TopX(prevE, pt.Y) == ClipperLib.Clipper.TopX(e, pt.Y)) && ClipperLib.ClipperBase.SlopesEqual(e, prevE, this.m_UseFullRange) && (e.WindDelta !== 0) && (prevE.WindDelta !== 0))
    {
      var outPt = this.AddOutPt(prevE, pt);
      this.AddJoin(result, outPt, e.Top);
    }
    return result;
  };
  ClipperLib.Clipper.prototype.CreateOutRec = function ()
  {
    var result = new ClipperLib.OutRec();
    result.Idx = -1;
    result.IsHole = false;
    result.IsOpen = false;
    result.FirstLeft = null;
    result.Pts = null;
    result.BottomPt = null;
    result.PolyNode = null;
    this.m_PolyOuts.push(result);
    result.Idx = this.m_PolyOuts.length - 1;
    return result;
  };
  ClipperLib.Clipper.prototype.AddOutPt = function (e, pt)
  {
    var ToFront = (e.Side == ClipperLib.EdgeSide.esLeft);
    if (e.OutIdx < 0)
    {
      var outRec = this.CreateOutRec();
      outRec.IsOpen = (e.WindDelta === 0);
      var newOp = new ClipperLib.OutPt();
      outRec.Pts = newOp;
      newOp.Idx = outRec.Idx;
      //newOp.Pt = pt;
      newOp.Pt.X = pt.X;
      newOp.Pt.Y = pt.Y;
      newOp.Next = newOp;
      newOp.Prev = newOp;
      if (!outRec.IsOpen)
        this.SetHoleState(e, outRec);
      e.OutIdx = outRec.Idx;
      //nb: do this after SetZ !
      return newOp;
    }
    else
    {
      var outRec = this.m_PolyOuts[e.OutIdx];
      //OutRec.Pts is the 'Left-most' point & OutRec.Pts.Prev is the 'Right-most'
      var op = outRec.Pts;
      if (ToFront && ClipperLib.IntPoint.op_Equality(pt, op.Pt))
        return op;
      else if (!ToFront && ClipperLib.IntPoint.op_Equality(pt, op.Prev.Pt))
        return op.Prev;
      var newOp = new ClipperLib.OutPt();
      newOp.Idx = outRec.Idx;
      //newOp.Pt = pt;
      newOp.Pt.X = pt.X;
      newOp.Pt.Y = pt.Y;
      newOp.Next = op;
      newOp.Prev = op.Prev;
      newOp.Prev.Next = newOp;
      op.Prev = newOp;
      if (ToFront)
        outRec.Pts = newOp;
      return newOp;
    }
  };
  ClipperLib.Clipper.prototype.SwapPoints = function (pt1, pt2)
  {
    var tmp = new ClipperLib.IntPoint(pt1.Value);
    //pt1.Value = pt2.Value;
    pt1.Value.X = pt2.Value.X;
    pt1.Value.Y = pt2.Value.Y;
    //pt2.Value = tmp;
    pt2.Value.X = tmp.X;
    pt2.Value.Y = tmp.Y;
  };
  ClipperLib.Clipper.prototype.HorzSegmentsOverlap = function (seg1a, seg1b, seg2a, seg2b)
	{
		var tmp;
		if (seg1a > seg1b)
		{
			tmp = seg1a;
			seg1a = seg1b;
			seg1b = tmp;
		}
		if (seg2a > seg2b)
		{
			tmp = seg2a;
			seg2a = seg2b;
			seg2b = tmp;
		}
		return (seg1a < seg2b) && (seg2a < seg1b);
	}

  ClipperLib.Clipper.prototype.SetHoleState = function (e, outRec)
  {
    var isHole = false;
    var e2 = e.PrevInAEL;
    while (e2 !== null)
    {
      if (e2.OutIdx >= 0 && e2.WindDelta != 0)
      {
        isHole = !isHole;
        if (outRec.FirstLeft === null)
          outRec.FirstLeft = this.m_PolyOuts[e2.OutIdx];
      }
      e2 = e2.PrevInAEL;
    }
    if (isHole)
      outRec.IsHole = true;
  };
  ClipperLib.Clipper.prototype.GetDx = function (pt1, pt2)
  {
    if (pt1.Y == pt2.Y)
      return ClipperLib.ClipperBase.horizontal;
    else
      return (pt2.X - pt1.X) / (pt2.Y - pt1.Y);
  };
  ClipperLib.Clipper.prototype.FirstIsBottomPt = function (btmPt1, btmPt2)
  {
    var p = btmPt1.Prev;
    while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt1.Pt)) && (p != btmPt1))
      p = p.Prev;
    var dx1p = Math.abs(this.GetDx(btmPt1.Pt, p.Pt));
    p = btmPt1.Next;
    while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt1.Pt)) && (p != btmPt1))
      p = p.Next;
    var dx1n = Math.abs(this.GetDx(btmPt1.Pt, p.Pt));
    p = btmPt2.Prev;
    while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt2.Pt)) && (p != btmPt2))
      p = p.Prev;
    var dx2p = Math.abs(this.GetDx(btmPt2.Pt, p.Pt));
    p = btmPt2.Next;
    while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt2.Pt)) && (p != btmPt2))
      p = p.Next;
    var dx2n = Math.abs(this.GetDx(btmPt2.Pt, p.Pt));
    return (dx1p >= dx2p && dx1p >= dx2n) || (dx1n >= dx2p && dx1n >= dx2n);
  };
  ClipperLib.Clipper.prototype.GetBottomPt = function (pp)
  {
    var dups = null;
    var p = pp.Next;
    while (p != pp)
    {
      if (p.Pt.Y > pp.Pt.Y)
      {
        pp = p;
        dups = null;
      }
      else if (p.Pt.Y == pp.Pt.Y && p.Pt.X <= pp.Pt.X)
      {
        if (p.Pt.X < pp.Pt.X)
        {
          dups = null;
          pp = p;
        }
        else
        {
          if (p.Next != pp && p.Prev != pp)
            dups = p;
        }
      }
      p = p.Next;
    }
    if (dups !== null)
    {
      //there appears to be at least 2 vertices at bottomPt so ...
      while (dups != p)
      {
        if (!this.FirstIsBottomPt(p, dups))
          pp = dups;
        dups = dups.Next;
        while (ClipperLib.IntPoint.op_Inequality(dups.Pt, pp.Pt))
          dups = dups.Next;
      }
    }
    return pp;
  };
  ClipperLib.Clipper.prototype.GetLowermostRec = function (outRec1, outRec2)
  {
    //work out which polygon fragment has the correct hole state ...
    if (outRec1.BottomPt === null)
      outRec1.BottomPt = this.GetBottomPt(outRec1.Pts);
    if (outRec2.BottomPt === null)
      outRec2.BottomPt = this.GetBottomPt(outRec2.Pts);
    var bPt1 = outRec1.BottomPt;
    var bPt2 = outRec2.BottomPt;
    if (bPt1.Pt.Y > bPt2.Pt.Y)
      return outRec1;
    else if (bPt1.Pt.Y < bPt2.Pt.Y)
      return outRec2;
    else if (bPt1.Pt.X < bPt2.Pt.X)
      return outRec1;
    else if (bPt1.Pt.X > bPt2.Pt.X)
      return outRec2;
    else if (bPt1.Next == bPt1)
      return outRec2;
    else if (bPt2.Next == bPt2)
      return outRec1;
    else if (this.FirstIsBottomPt(bPt1, bPt2))
      return outRec1;
    else
      return outRec2;
  };
  ClipperLib.Clipper.prototype.Param1RightOfParam2 = function (outRec1, outRec2)
  {
    do {
      outRec1 = outRec1.FirstLeft;
      if (outRec1 == outRec2)
        return true;
    }
    while (outRec1 !== null)
    return false;
  };
  ClipperLib.Clipper.prototype.GetOutRec = function (idx)
  {
    var outrec = this.m_PolyOuts[idx];
    while (outrec != this.m_PolyOuts[outrec.Idx])
      outrec = this.m_PolyOuts[outrec.Idx];
    return outrec;
  };
  ClipperLib.Clipper.prototype.AppendPolygon = function (e1, e2)
  {
    //get the start and ends of both output polygons ...
    var outRec1 = this.m_PolyOuts[e1.OutIdx];
    var outRec2 = this.m_PolyOuts[e2.OutIdx];
    var holeStateRec;
    if (this.Param1RightOfParam2(outRec1, outRec2))
      holeStateRec = outRec2;
    else if (this.Param1RightOfParam2(outRec2, outRec1))
      holeStateRec = outRec1;
    else
      holeStateRec = this.GetLowermostRec(outRec1, outRec2);
    var p1_lft = outRec1.Pts;
    var p1_rt = p1_lft.Prev;
    var p2_lft = outRec2.Pts;
    var p2_rt = p2_lft.Prev;
    var side;
    //join e2 poly onto e1 poly and delete pointers to e2 ...
    if (e1.Side == ClipperLib.EdgeSide.esLeft)
    {
      if (e2.Side == ClipperLib.EdgeSide.esLeft)
      {
        //z y x a b c
        this.ReversePolyPtLinks(p2_lft);
        p2_lft.Next = p1_lft;
        p1_lft.Prev = p2_lft;
        p1_rt.Next = p2_rt;
        p2_rt.Prev = p1_rt;
        outRec1.Pts = p2_rt;
      }
      else
      {
        //x y z a b c
        p2_rt.Next = p1_lft;
        p1_lft.Prev = p2_rt;
        p2_lft.Prev = p1_rt;
        p1_rt.Next = p2_lft;
        outRec1.Pts = p2_lft;
      }
      side = ClipperLib.EdgeSide.esLeft;
    }
    else
    {
      if (e2.Side == ClipperLib.EdgeSide.esRight)
      {
        //a b c z y x
        this.ReversePolyPtLinks(p2_lft);
        p1_rt.Next = p2_rt;
        p2_rt.Prev = p1_rt;
        p2_lft.Next = p1_lft;
        p1_lft.Prev = p2_lft;
      }
      else
      {
        //a b c x y z
        p1_rt.Next = p2_lft;
        p2_lft.Prev = p1_rt;
        p1_lft.Prev = p2_rt;
        p2_rt.Next = p1_lft;
      }
      side = ClipperLib.EdgeSide.esRight;
    }
    outRec1.BottomPt = null;
    if (holeStateRec == outRec2)
    {
      if (outRec2.FirstLeft != outRec1)
        outRec1.FirstLeft = outRec2.FirstLeft;
      outRec1.IsHole = outRec2.IsHole;
    }
    outRec2.Pts = null;
    outRec2.BottomPt = null;
    outRec2.FirstLeft = outRec1;
    var OKIdx = e1.OutIdx;
    var ObsoleteIdx = e2.OutIdx;
    e1.OutIdx = -1;
    //nb: safe because we only get here via AddLocalMaxPoly
    e2.OutIdx = -1;
    var e = this.m_ActiveEdges;
    while (e !== null)
    {
      if (e.OutIdx == ObsoleteIdx)
      {
        e.OutIdx = OKIdx;
        e.Side = side;
        break;
      }
      e = e.NextInAEL;
    }
    outRec2.Idx = outRec1.Idx;
  };
  ClipperLib.Clipper.prototype.ReversePolyPtLinks = function (pp)
  {
    if (pp === null)
      return;
    var pp1;
    var pp2;
    pp1 = pp;
    do {
      pp2 = pp1.Next;
      pp1.Next = pp1.Prev;
      pp1.Prev = pp2;
      pp1 = pp2;
    }
    while (pp1 != pp)
  };
  ClipperLib.Clipper.SwapSides = function (edge1, edge2)
  {
    var side = edge1.Side;
    edge1.Side = edge2.Side;
    edge2.Side = side;
  };
  ClipperLib.Clipper.SwapPolyIndexes = function (edge1, edge2)
  {
    var outIdx = edge1.OutIdx;
    edge1.OutIdx = edge2.OutIdx;
    edge2.OutIdx = outIdx;
  };
  ClipperLib.Clipper.prototype.IntersectEdges = function (e1, e2, pt)
  {
    //e1 will be to the left of e2 BELOW the intersection. Therefore e1 is before
    //e2 in AEL except when e1 is being inserted at the intersection point ...
    var e1Contributing = (e1.OutIdx >= 0);
    var e2Contributing = (e2.OutIdx >= 0);

    if (use_xyz)
    	this.SetZ(pt, e1, e2);

    if (use_lines)
    {
      //if either edge is on an OPEN path ...
      if (e1.WindDelta === 0 || e2.WindDelta === 0)
      {
        //ignore subject-subject open path intersections UNLESS they
        //are both open paths, AND they are both 'contributing maximas' ...
				if (e1.WindDelta == 0 && e2.WindDelta == 0) return;
        //if intersecting a subj line with a subj poly ...
        else if (e1.PolyTyp == e2.PolyTyp &&
          e1.WindDelta != e2.WindDelta && this.m_ClipType == ClipperLib.ClipType.ctUnion)
        {
          if (e1.WindDelta === 0)
          {
            if (e2Contributing)
            {
              this.AddOutPt(e1, pt);
              if (e1Contributing)
                e1.OutIdx = -1;
            }
          }
          else
          {
            if (e1Contributing)
            {
              this.AddOutPt(e2, pt);
              if (e2Contributing)
                e2.OutIdx = -1;
            }
          }
        }
        else if (e1.PolyTyp != e2.PolyTyp)
        {
          if ((e1.WindDelta === 0) && Math.abs(e2.WindCnt) == 1 &&
            (this.m_ClipType != ClipperLib.ClipType.ctUnion || e2.WindCnt2 === 0))
          {
            this.AddOutPt(e1, pt);
            if (e1Contributing)
              e1.OutIdx = -1;
          }
          else if ((e2.WindDelta === 0) && (Math.abs(e1.WindCnt) == 1) &&
            (this.m_ClipType != ClipperLib.ClipType.ctUnion || e1.WindCnt2 === 0))
          {
            this.AddOutPt(e2, pt);
            if (e2Contributing)
              e2.OutIdx = -1;
          }
        }
        return;
      }
    }
    //update winding counts...
    //assumes that e1 will be to the Right of e2 ABOVE the intersection
    if (e1.PolyTyp == e2.PolyTyp)
    {
      if (this.IsEvenOddFillType(e1))
      {
        var oldE1WindCnt = e1.WindCnt;
        e1.WindCnt = e2.WindCnt;
        e2.WindCnt = oldE1WindCnt;
      }
      else
      {
        if (e1.WindCnt + e2.WindDelta === 0)
          e1.WindCnt = -e1.WindCnt;
        else
          e1.WindCnt += e2.WindDelta;
        if (e2.WindCnt - e1.WindDelta === 0)
          e2.WindCnt = -e2.WindCnt;
        else
          e2.WindCnt -= e1.WindDelta;
      }
    }
    else
    {
      if (!this.IsEvenOddFillType(e2))
        e1.WindCnt2 += e2.WindDelta;
      else
        e1.WindCnt2 = (e1.WindCnt2 === 0) ? 1 : 0;
      if (!this.IsEvenOddFillType(e1))
        e2.WindCnt2 -= e1.WindDelta;
      else
        e2.WindCnt2 = (e2.WindCnt2 === 0) ? 1 : 0;
    }
    var e1FillType, e2FillType, e1FillType2, e2FillType2;
    if (e1.PolyTyp == ClipperLib.PolyType.ptSubject)
    {
      e1FillType = this.m_SubjFillType;
      e1FillType2 = this.m_ClipFillType;
    }
    else
    {
      e1FillType = this.m_ClipFillType;
      e1FillType2 = this.m_SubjFillType;
    }
    if (e2.PolyTyp == ClipperLib.PolyType.ptSubject)
    {
      e2FillType = this.m_SubjFillType;
      e2FillType2 = this.m_ClipFillType;
    }
    else
    {
      e2FillType = this.m_ClipFillType;
      e2FillType2 = this.m_SubjFillType;
    }
    var e1Wc, e2Wc;
    switch (e1FillType)
    {
    case ClipperLib.PolyFillType.pftPositive:
      e1Wc = e1.WindCnt;
      break;
    case ClipperLib.PolyFillType.pftNegative:
      e1Wc = -e1.WindCnt;
      break;
    default:
      e1Wc = Math.abs(e1.WindCnt);
      break;
    }
    switch (e2FillType)
    {
    case ClipperLib.PolyFillType.pftPositive:
      e2Wc = e2.WindCnt;
      break;
    case ClipperLib.PolyFillType.pftNegative:
      e2Wc = -e2.WindCnt;
      break;
    default:
      e2Wc = Math.abs(e2.WindCnt);
      break;
    }
    if (e1Contributing && e2Contributing)
    {
			if ((e1Wc != 0 && e1Wc != 1) || (e2Wc != 0 && e2Wc != 1) ||
			(e1.PolyTyp != e2.PolyTyp && this.m_ClipType != ClipperLib.ClipType.ctXor))
			{
				this.AddLocalMaxPoly(e1, e2, pt);
			}
      else
      {
        this.AddOutPt(e1, pt);
        this.AddOutPt(e2, pt);
        ClipperLib.Clipper.SwapSides(e1, e2);
        ClipperLib.Clipper.SwapPolyIndexes(e1, e2);
      }
    }
    else if (e1Contributing)
    {
      if (e2Wc === 0 || e2Wc == 1)
      {
        this.AddOutPt(e1, pt);
        ClipperLib.Clipper.SwapSides(e1, e2);
        ClipperLib.Clipper.SwapPolyIndexes(e1, e2);
      }
    }
    else if (e2Contributing)
    {
      if (e1Wc === 0 || e1Wc == 1)
      {
        this.AddOutPt(e2, pt);
        ClipperLib.Clipper.SwapSides(e1, e2);
        ClipperLib.Clipper.SwapPolyIndexes(e1, e2);
      }
    }
		else if ( (e1Wc == 0 || e1Wc == 1) && (e2Wc == 0 || e2Wc == 1))
    {
      //neither edge is currently contributing ...
      var e1Wc2, e2Wc2;
      switch (e1FillType2)
      {
      case ClipperLib.PolyFillType.pftPositive:
        e1Wc2 = e1.WindCnt2;
        break;
      case ClipperLib.PolyFillType.pftNegative:
        e1Wc2 = -e1.WindCnt2;
        break;
      default:
        e1Wc2 = Math.abs(e1.WindCnt2);
        break;
      }
      switch (e2FillType2)
      {
      case ClipperLib.PolyFillType.pftPositive:
        e2Wc2 = e2.WindCnt2;
        break;
      case ClipperLib.PolyFillType.pftNegative:
        e2Wc2 = -e2.WindCnt2;
        break;
      default:
        e2Wc2 = Math.abs(e2.WindCnt2);
        break;
      }
      if (e1.PolyTyp != e2.PolyTyp)
      {
        this.AddLocalMinPoly(e1, e2, pt);
      }
      else if (e1Wc == 1 && e2Wc == 1)
        switch (this.m_ClipType)
        {
        case ClipperLib.ClipType.ctIntersection:
          if (e1Wc2 > 0 && e2Wc2 > 0)
            this.AddLocalMinPoly(e1, e2, pt);
          break;
        case ClipperLib.ClipType.ctUnion:
          if (e1Wc2 <= 0 && e2Wc2 <= 0)
            this.AddLocalMinPoly(e1, e2, pt);
          break;
        case ClipperLib.ClipType.ctDifference:
          if (((e1.PolyTyp == ClipperLib.PolyType.ptClip) && (e1Wc2 > 0) && (e2Wc2 > 0)) ||
            ((e1.PolyTyp == ClipperLib.PolyType.ptSubject) && (e1Wc2 <= 0) && (e2Wc2 <= 0)))
            this.AddLocalMinPoly(e1, e2, pt);
          break;
        case ClipperLib.ClipType.ctXor:
          this.AddLocalMinPoly(e1, e2, pt);
          break;
        }
      else
        ClipperLib.Clipper.SwapSides(e1, e2);
    }
  };
  ClipperLib.Clipper.prototype.DeleteFromAEL = function (e)
  {
    var AelPrev = e.PrevInAEL;
    var AelNext = e.NextInAEL;
    if (AelPrev === null && AelNext === null && (e != this.m_ActiveEdges))
      return;
    //already deleted
    if (AelPrev !== null)
      AelPrev.NextInAEL = AelNext;
    else
      this.m_ActiveEdges = AelNext;
    if (AelNext !== null)
      AelNext.PrevInAEL = AelPrev;
    e.NextInAEL = null;
    e.PrevInAEL = null;
  };
  ClipperLib.Clipper.prototype.DeleteFromSEL = function (e)
  {
    var SelPrev = e.PrevInSEL;
    var SelNext = e.NextInSEL;
    if (SelPrev === null && SelNext === null && (e != this.m_SortedEdges))
      return;
    //already deleted
    if (SelPrev !== null)
      SelPrev.NextInSEL = SelNext;
    else
      this.m_SortedEdges = SelNext;
    if (SelNext !== null)
      SelNext.PrevInSEL = SelPrev;
    e.NextInSEL = null;
    e.PrevInSEL = null;
  };
  ClipperLib.Clipper.prototype.UpdateEdgeIntoAEL = function (e)
  {
    if (e.NextInLML === null)
      ClipperLib.Error("UpdateEdgeIntoAEL: invalid call");
    var AelPrev = e.PrevInAEL;
    var AelNext = e.NextInAEL;
    e.NextInLML.OutIdx = e.OutIdx;
    if (AelPrev !== null)
      AelPrev.NextInAEL = e.NextInLML;
    else
      this.m_ActiveEdges = e.NextInLML;
    if (AelNext !== null)
      AelNext.PrevInAEL = e.NextInLML;
    e.NextInLML.Side = e.Side;
    e.NextInLML.WindDelta = e.WindDelta;
    e.NextInLML.WindCnt = e.WindCnt;
    e.NextInLML.WindCnt2 = e.WindCnt2;
    e = e.NextInLML;
    //    e.Curr = e.Bot;
    e.Curr.X = e.Bot.X;
    e.Curr.Y = e.Bot.Y;
    e.PrevInAEL = AelPrev;
    e.NextInAEL = AelNext;
    if (!ClipperLib.ClipperBase.IsHorizontal(e))
      this.InsertScanbeam(e.Top.Y);
    return e;
  };
  ClipperLib.Clipper.prototype.ProcessHorizontals = function (isTopOfScanbeam)
  {
    var horzEdge = this.m_SortedEdges;
    while (horzEdge !== null)
    {
      this.DeleteFromSEL(horzEdge);
      this.ProcessHorizontal(horzEdge, isTopOfScanbeam);
      horzEdge = this.m_SortedEdges;
    }
  };
  ClipperLib.Clipper.prototype.GetHorzDirection = function (HorzEdge, $var)
  {
    if (HorzEdge.Bot.X < HorzEdge.Top.X)
    {
        $var.Left = HorzEdge.Bot.X;
        $var.Right = HorzEdge.Top.X;
        $var.Dir = ClipperLib.Direction.dLeftToRight;
    }
    else
    {
        $var.Left = HorzEdge.Top.X;
        $var.Right = HorzEdge.Bot.X;
        $var.Dir = ClipperLib.Direction.dRightToLeft;
    }
  };
  ClipperLib.Clipper.prototype.ProcessHorizontal = function (horzEdge, isTopOfScanbeam)
  {
    var $var = {Dir: null, Left: null, Right: null};
    this.GetHorzDirection(horzEdge, $var);
    var dir = $var.Dir;
    var horzLeft = $var.Left;
    var horzRight = $var.Right;

    var eLastHorz = horzEdge,
      eMaxPair = null;
    while (eLastHorz.NextInLML !== null && ClipperLib.ClipperBase.IsHorizontal(eLastHorz.NextInLML))
      eLastHorz = eLastHorz.NextInLML;
    if (eLastHorz.NextInLML === null)
      eMaxPair = this.GetMaximaPair(eLastHorz);
    for (;;)
    {
      var IsLastHorz = (horzEdge == eLastHorz);
      var e = this.GetNextInAEL(horzEdge, dir);
      while (e !== null)
      {
        //Break if we've got to the end of an intermediate horizontal edge ...
        //nb: Smaller Dx's are to the right of larger Dx's ABOVE the horizontal.
        if (e.Curr.X == horzEdge.Top.X && horzEdge.NextInLML !== null && e.Dx < horzEdge.NextInLML.Dx)
          break;
        var eNext = this.GetNextInAEL(e, dir);
        //saves eNext for later
        if ((dir == ClipperLib.Direction.dLeftToRight && e.Curr.X <= horzRight) || (dir == ClipperLib.Direction.dRightToLeft && e.Curr.X >= horzLeft))
        {
          //so far we're still in range of the horizontal Edge  but make sure
          //we're at the last of consec. horizontals when matching with eMaxPair
          if (e == eMaxPair && IsLastHorz)
          {
						if (horzEdge.OutIdx >= 0)
						{
							var op1 = this.AddOutPt(horzEdge, horzEdge.Top);
							var eNextHorz = this.m_SortedEdges;
							while (eNextHorz !== null)
							{
								if (eNextHorz.OutIdx >= 0 &&
									this.HorzSegmentsOverlap(horzEdge.Bot.X,
									horzEdge.Top.X, eNextHorz.Bot.X, eNextHorz.Top.X))
								{
									var op2 = this.AddOutPt(eNextHorz, eNextHorz.Bot);
									this.AddJoin(op2, op1, eNextHorz.Top);
								}
								eNextHorz = eNextHorz.NextInSEL;
							}
							this.AddGhostJoin(op1, horzEdge.Bot);
							this.AddLocalMaxPoly(horzEdge, eMaxPair, horzEdge.Top);
						}
						this.DeleteFromAEL(horzEdge);
						this.DeleteFromAEL(eMaxPair);
            return;
          }
          else if (dir == ClipperLib.Direction.dLeftToRight)
          {
            var Pt = new ClipperLib.IntPoint(e.Curr.X, horzEdge.Curr.Y);
            this.IntersectEdges(horzEdge, e, Pt);
          }
          else
          {
            var Pt = new ClipperLib.IntPoint(e.Curr.X, horzEdge.Curr.Y);
            this.IntersectEdges(e, horzEdge, Pt);
          }
          this.SwapPositionsInAEL(horzEdge, e);
        }
        else if ((dir == ClipperLib.Direction.dLeftToRight && e.Curr.X >= horzRight) || (dir == ClipperLib.Direction.dRightToLeft && e.Curr.X <= horzLeft))
          break;
        e = eNext;
      }
      //end while
      if (horzEdge.NextInLML !== null && ClipperLib.ClipperBase.IsHorizontal(horzEdge.NextInLML))
      {
        horzEdge = this.UpdateEdgeIntoAEL(horzEdge);
        if (horzEdge.OutIdx >= 0)
          this.AddOutPt(horzEdge, horzEdge.Bot);

          var $var = {Dir: dir, Left: horzLeft, Right: horzRight};
          this.GetHorzDirection(horzEdge, $var);
          dir = $var.Dir;
          horzLeft = $var.Left;
          horzRight = $var.Right;
      }
      else
        break;
    }
    //end for (;;)
    if (horzEdge.NextInLML !== null)
    {
      if (horzEdge.OutIdx >= 0)
      {
        var op1 = this.AddOutPt(horzEdge, horzEdge.Top);
				if (isTopOfScanbeam) this.AddGhostJoin(op1, horzEdge.Bot);
        horzEdge = this.UpdateEdgeIntoAEL(horzEdge);
        if (horzEdge.WindDelta === 0)
          return;
        //nb: HorzEdge is no longer horizontal here
        var ePrev = horzEdge.PrevInAEL;
        var eNext = horzEdge.NextInAEL;
        if (ePrev !== null && ePrev.Curr.X == horzEdge.Bot.X &&
          ePrev.Curr.Y == horzEdge.Bot.Y && ePrev.WindDelta !== 0 &&
          (ePrev.OutIdx >= 0 && ePrev.Curr.Y > ePrev.Top.Y &&
            ClipperLib.ClipperBase.SlopesEqual(horzEdge, ePrev, this.m_UseFullRange)))
        {
          var op2 = this.AddOutPt(ePrev, horzEdge.Bot);
          this.AddJoin(op1, op2, horzEdge.Top);
        }
        else if (eNext !== null && eNext.Curr.X == horzEdge.Bot.X &&
          eNext.Curr.Y == horzEdge.Bot.Y && eNext.WindDelta !== 0 &&
          eNext.OutIdx >= 0 && eNext.Curr.Y > eNext.Top.Y &&
          ClipperLib.ClipperBase.SlopesEqual(horzEdge, eNext, this.m_UseFullRange))
        {
          var op2 = this.AddOutPt(eNext, horzEdge.Bot);
          this.AddJoin(op1, op2, horzEdge.Top);
        }
      }
      else horzEdge = this.UpdateEdgeIntoAEL(horzEdge);
    }
  	else
    {
      if (horzEdge.OutIdx >= 0)
        this.AddOutPt(horzEdge, horzEdge.Top);
      this.DeleteFromAEL(horzEdge);
    }
  };
  ClipperLib.Clipper.prototype.GetNextInAEL = function (e, Direction)
  {
    return Direction == ClipperLib.Direction.dLeftToRight ? e.NextInAEL : e.PrevInAEL;
  };
  ClipperLib.Clipper.prototype.IsMinima = function (e)
  {
    return e !== null && (e.Prev.NextInLML != e) && (e.Next.NextInLML != e);
  };
  ClipperLib.Clipper.prototype.IsMaxima = function (e, Y)
  {
    return (e !== null && e.Top.Y == Y && e.NextInLML === null);
  };
  ClipperLib.Clipper.prototype.IsIntermediate = function (e, Y)
  {
    return (e.Top.Y == Y && e.NextInLML !== null);
  };
  ClipperLib.Clipper.prototype.GetMaximaPair = function (e)
  {
    var result = null;
    if ((ClipperLib.IntPoint.op_Equality(e.Next.Top, e.Top)) && e.Next.NextInLML === null)
      result = e.Next;
    else if ((ClipperLib.IntPoint.op_Equality(e.Prev.Top, e.Top)) && e.Prev.NextInLML === null)
      result = e.Prev;
    if (result !== null && (result.OutIdx == -2 || (result.NextInAEL == result.PrevInAEL && !ClipperLib.ClipperBase.IsHorizontal(result))))
      return null;
    return result;
  };

  ClipperLib.Clipper.prototype.ProcessIntersections = function (topY)
  {
    if (this.m_ActiveEdges == null)
      return true;
    try
    {
      this.BuildIntersectList(topY);
      if (this.m_IntersectList.length == 0)
        return true;
      if (this.m_IntersectList.length == 1 || this.FixupIntersectionOrder())
        this.ProcessIntersectList();
      else
        return false;
    }
    catch ($$e2)
    {
      this.m_SortedEdges = null;
      this.m_IntersectList.length = 0;
      ClipperLib.Error("ProcessIntersections error");
    }
    this.m_SortedEdges = null;
    return true;
  };
  ClipperLib.Clipper.prototype.BuildIntersectList = function (topY)
  {
    if (this.m_ActiveEdges === null)
      return;
    //prepare for sorting ...
    var e = this.m_ActiveEdges;
    //console.log(JSON.stringify(JSON.decycle( e )));
    this.m_SortedEdges = e;
    while (e !== null)
    {
      e.PrevInSEL = e.PrevInAEL;
      e.NextInSEL = e.NextInAEL;
      e.Curr.X = ClipperLib.Clipper.TopX(e, topY);
      e = e.NextInAEL;
    }
    //bubblesort ...
    var isModified = true;
    while (isModified && this.m_SortedEdges !== null)
    {
      isModified = false;
      e = this.m_SortedEdges;
      while (e.NextInSEL !== null)
      {
        var eNext = e.NextInSEL;
        var pt = new ClipperLib.IntPoint();
        //console.log("e.Curr.X: " + e.Curr.X + " eNext.Curr.X" + eNext.Curr.X);
        if (e.Curr.X > eNext.Curr.X)
        {
					this.IntersectPoint(e, eNext, pt);
          var newNode = new ClipperLib.IntersectNode();
          newNode.Edge1 = e;
          newNode.Edge2 = eNext;
          //newNode.Pt = pt;
          newNode.Pt.X = pt.X;
          newNode.Pt.Y = pt.Y;
          this.m_IntersectList.push(newNode);
          this.SwapPositionsInSEL(e, eNext);
          isModified = true;
        }
        else
          e = eNext;
      }
      if (e.PrevInSEL !== null)
        e.PrevInSEL.NextInSEL = null;
      else
        break;
    }
    this.m_SortedEdges = null;
  };
  ClipperLib.Clipper.prototype.EdgesAdjacent = function (inode)
  {
    return (inode.Edge1.NextInSEL == inode.Edge2) || (inode.Edge1.PrevInSEL == inode.Edge2);
  };
  ClipperLib.Clipper.IntersectNodeSort = function (node1, node2)
  {
    //the following typecast is safe because the differences in Pt.Y will
    //be limited to the height of the scanbeam.
    return (node2.Pt.Y - node1.Pt.Y);
  };
  ClipperLib.Clipper.prototype.FixupIntersectionOrder = function ()
  {
    //pre-condition: intersections are sorted bottom-most first.
    //Now it's crucial that intersections are made only between adjacent edges,
    //so to ensure this the order of intersections may need adjusting ...
    this.m_IntersectList.sort(this.m_IntersectNodeComparer);
    this.CopyAELToSEL();
    var cnt = this.m_IntersectList.length;
    for (var i = 0; i < cnt; i++)
    {
      if (!this.EdgesAdjacent(this.m_IntersectList[i]))
      {
        var j = i + 1;
        while (j < cnt && !this.EdgesAdjacent(this.m_IntersectList[j]))
          j++;
        if (j == cnt)
          return false;
        var tmp = this.m_IntersectList[i];
        this.m_IntersectList[i] = this.m_IntersectList[j];
        this.m_IntersectList[j] = tmp;
      }
      this.SwapPositionsInSEL(this.m_IntersectList[i].Edge1, this.m_IntersectList[i].Edge2);
    }
    return true;
  };
  ClipperLib.Clipper.prototype.ProcessIntersectList = function ()
  {
    for (var i = 0, ilen = this.m_IntersectList.length; i < ilen; i++)
    {
      var iNode = this.m_IntersectList[i];
      this.IntersectEdges(iNode.Edge1, iNode.Edge2, iNode.Pt);
      this.SwapPositionsInAEL(iNode.Edge1, iNode.Edge2);
    }
    this.m_IntersectList.length = 0;
  };
  /*
  --------------------------------
  Round speedtest: http://jsperf.com/fastest-round
  --------------------------------
  */
  var R1 = function (a)
  {
    return a < 0 ? Math.ceil(a - 0.5) : Math.round(a)
  };
  var R2 = function (a)
  {
    return a < 0 ? Math.ceil(a - 0.5) : Math.floor(a + 0.5)
  };
  var R3 = function (a)
  {
    return a < 0 ? -Math.round(Math.abs(a)) : Math.round(a)
  };
  var R4 = function (a)
  {
    if (a < 0)
    {
      a -= 0.5;
      return a < -2147483648 ? Math.ceil(a) : a | 0;
    }
    else
    {
      a += 0.5;
      return a > 2147483647 ? Math.floor(a) : a | 0;
    }
  };
  if (browser.msie) ClipperLib.Clipper.Round = R1;
  else if (browser.chromium) ClipperLib.Clipper.Round = R3;
  else if (browser.safari) ClipperLib.Clipper.Round = R4;
  else ClipperLib.Clipper.Round = R2; // eg. browser.chrome || browser.firefox || browser.opera
  ClipperLib.Clipper.TopX = function (edge, currentY)
  {
    //if (edge.Bot == edge.Curr) alert ("edge.Bot = edge.Curr");
    //if (edge.Bot == edge.Top) alert ("edge.Bot = edge.Top");
    if (currentY == edge.Top.Y)
      return edge.Top.X;
    return edge.Bot.X + ClipperLib.Clipper.Round(edge.Dx * (currentY - edge.Bot.Y));
  };
  ClipperLib.Clipper.prototype.IntersectPoint = function (edge1, edge2, ip)
  {
    ip.X = 0;
    ip.Y = 0;
    var b1, b2;
    //nb: with very large coordinate values, it's possible for SlopesEqual() to
    //return false but for the edge.Dx value be equal due to double precision rounding.
    if (edge1.Dx == edge2.Dx)
		{
			ip.Y = edge1.Curr.Y;
			ip.X = ClipperLib.Clipper.TopX(edge1, ip.Y);
			return;
    }
    if (edge1.Delta.X === 0)
    {
      ip.X = edge1.Bot.X;
      if (ClipperLib.ClipperBase.IsHorizontal(edge2))
      {
        ip.Y = edge2.Bot.Y;
      }
      else
      {
        b2 = edge2.Bot.Y - (edge2.Bot.X / edge2.Dx);
        ip.Y = ClipperLib.Clipper.Round(ip.X / edge2.Dx + b2);
      }
    }
    else if (edge2.Delta.X === 0)
    {
      ip.X = edge2.Bot.X;
      if (ClipperLib.ClipperBase.IsHorizontal(edge1))
      {
        ip.Y = edge1.Bot.Y;
      }
      else
      {
        b1 = edge1.Bot.Y - (edge1.Bot.X / edge1.Dx);
        ip.Y = ClipperLib.Clipper.Round(ip.X / edge1.Dx + b1);
      }
    }
    else
    {
      b1 = edge1.Bot.X - edge1.Bot.Y * edge1.Dx;
      b2 = edge2.Bot.X - edge2.Bot.Y * edge2.Dx;
      var q = (b2 - b1) / (edge1.Dx - edge2.Dx);
      ip.Y = ClipperLib.Clipper.Round(q);
      if (Math.abs(edge1.Dx) < Math.abs(edge2.Dx))
        ip.X = ClipperLib.Clipper.Round(edge1.Dx * q + b1);
      else
        ip.X = ClipperLib.Clipper.Round(edge2.Dx * q + b2);
    }
    if (ip.Y < edge1.Top.Y || ip.Y < edge2.Top.Y)
    {
      if (edge1.Top.Y > edge2.Top.Y)
      {
        ip.Y = edge1.Top.Y;
        ip.X = ClipperLib.Clipper.TopX(edge2, edge1.Top.Y);
        return ip.X < edge1.Top.X;
      }
      else
        ip.Y = edge2.Top.Y;
      if (Math.abs(edge1.Dx) < Math.abs(edge2.Dx))
        ip.X = ClipperLib.Clipper.TopX(edge1, ip.Y);
      else
        ip.X = ClipperLib.Clipper.TopX(edge2, ip.Y);
    }
		//finally, don't allow 'ip' to be BELOW curr.Y (ie bottom of scanbeam) ...
		if (ip.Y > edge1.Curr.Y)
		{
			ip.Y = edge1.Curr.Y;
			//better to use the more vertical edge to derive X ...
			if (Math.abs(edge1.Dx) > Math.abs(edge2.Dx))
				ip.X = ClipperLib.Clipper.TopX(edge2, ip.Y);
			else
				ip.X = ClipperLib.Clipper.TopX(edge1, ip.Y);
		}
  };

  ClipperLib.Clipper.prototype.ProcessEdgesAtTopOfScanbeam = function (topY)
  {
    var e = this.m_ActiveEdges;
    while (e !== null)
    {
      //1. process maxima, treating them as if they're 'bent' horizontal edges,
      //   but exclude maxima with horizontal edges. nb: e can't be a horizontal.
      var IsMaximaEdge = this.IsMaxima(e, topY);
      if (IsMaximaEdge)
      {
        var eMaxPair = this.GetMaximaPair(e);
        IsMaximaEdge = (eMaxPair === null || !ClipperLib.ClipperBase.IsHorizontal(eMaxPair));
      }
      if (IsMaximaEdge)
      {
        var ePrev = e.PrevInAEL;
        this.DoMaxima(e);
        if (ePrev === null)
          e = this.m_ActiveEdges;
        else
          e = ePrev.NextInAEL;
      }
      else
      {
        //2. promote horizontal edges, otherwise update Curr.X and Curr.Y ...
        if (this.IsIntermediate(e, topY) && ClipperLib.ClipperBase.IsHorizontal(e.NextInLML))
        {
          e = this.UpdateEdgeIntoAEL(e);
          if (e.OutIdx >= 0)
            this.AddOutPt(e, e.Bot);
          this.AddEdgeToSEL(e);
        }
        else
        {
          e.Curr.X = ClipperLib.Clipper.TopX(e, topY);
          e.Curr.Y = topY;
        }
        if (this.StrictlySimple)
        {
          var ePrev = e.PrevInAEL;
          if ((e.OutIdx >= 0) && (e.WindDelta !== 0) && ePrev !== null &&
            (ePrev.OutIdx >= 0) && (ePrev.Curr.X == e.Curr.X) &&
            (ePrev.WindDelta !== 0))
          {
           	var ip = new ClipperLib.IntPoint(e.Curr);

						if(use_xyz)
						{
							this.SetZ(ip, ePrev, e);
						}

            var op = this.AddOutPt(ePrev, ip);
            var op2 = this.AddOutPt(e, ip);
            this.AddJoin(op, op2, ip);
            //StrictlySimple (type-3) join
          }
        }
        e = e.NextInAEL;
      }
    }
    //3. Process horizontals at the Top of the scanbeam ...
    this.ProcessHorizontals(true);
    //4. Promote intermediate vertices ...
    e = this.m_ActiveEdges;
    while (e !== null)
    {
      if (this.IsIntermediate(e, topY))
      {
        var op = null;
        if (e.OutIdx >= 0)
          op = this.AddOutPt(e, e.Top);
        e = this.UpdateEdgeIntoAEL(e);
        //if output polygons share an edge, they'll need joining later ...
        var ePrev = e.PrevInAEL;
        var eNext = e.NextInAEL;
        if (ePrev !== null && ePrev.Curr.X == e.Bot.X &&
          ePrev.Curr.Y == e.Bot.Y && op !== null &&
          ePrev.OutIdx >= 0 && ePrev.Curr.Y > ePrev.Top.Y &&
          ClipperLib.ClipperBase.SlopesEqual(e, ePrev, this.m_UseFullRange) &&
          (e.WindDelta !== 0) && (ePrev.WindDelta !== 0))
        {
          var op2 = this.AddOutPt(ePrev, e.Bot);
          this.AddJoin(op, op2, e.Top);
        }
        else if (eNext !== null && eNext.Curr.X == e.Bot.X &&
          eNext.Curr.Y == e.Bot.Y && op !== null &&
          eNext.OutIdx >= 0 && eNext.Curr.Y > eNext.Top.Y &&
          ClipperLib.ClipperBase.SlopesEqual(e, eNext, this.m_UseFullRange) &&
          (e.WindDelta !== 0) && (eNext.WindDelta !== 0))
        {
          var op2 = this.AddOutPt(eNext, e.Bot);
          this.AddJoin(op, op2, e.Top);
        }
      }
      e = e.NextInAEL;
    }
  };
  ClipperLib.Clipper.prototype.DoMaxima = function (e)
  {
    var eMaxPair = this.GetMaximaPair(e);
    if (eMaxPair === null)
    {
      if (e.OutIdx >= 0)
        this.AddOutPt(e, e.Top);
      this.DeleteFromAEL(e);
      return;
    }
    var eNext = e.NextInAEL;
    var use_lines = true;
    while (eNext !== null && eNext != eMaxPair)
    {
      this.IntersectEdges(e, eNext, e.Top);
      this.SwapPositionsInAEL(e, eNext);
      eNext = e.NextInAEL;
    }
    if (e.OutIdx == -1 && eMaxPair.OutIdx == -1)
    {
      this.DeleteFromAEL(e);
      this.DeleteFromAEL(eMaxPair);
    }
    else if (e.OutIdx >= 0 && eMaxPair.OutIdx >= 0)
    {
    	if (e.OutIdx >= 0) this.AddLocalMaxPoly(e, eMaxPair, e.Top);
      this.DeleteFromAEL(e);
      this.DeleteFromAEL(eMaxPair);
    }
    else if (use_lines && e.WindDelta === 0)
    {
      if (e.OutIdx >= 0)
      {
        this.AddOutPt(e, e.Top);
        e.OutIdx = -1;
      }
      this.DeleteFromAEL(e);
      if (eMaxPair.OutIdx >= 0)
      {
        this.AddOutPt(eMaxPair, e.Top);
        eMaxPair.OutIdx = -1;
      }
      this.DeleteFromAEL(eMaxPair);
    }
    else
      ClipperLib.Error("DoMaxima error");
  };
  ClipperLib.Clipper.ReversePaths = function (polys)
  {
    for (var i = 0, len = polys.length; i < len; i++)
      polys[i].reverse();
  };
  ClipperLib.Clipper.Orientation = function (poly)
  {
    return ClipperLib.Clipper.Area(poly) >= 0;
  };
  ClipperLib.Clipper.prototype.PointCount = function (pts)
  {
    if (pts === null)
      return 0;
    var result = 0;
    var p = pts;
    do {
      result++;
      p = p.Next;
    }
    while (p != pts)
    return result;
  };
  ClipperLib.Clipper.prototype.BuildResult = function (polyg)
  {
    ClipperLib.Clear(polyg);
    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)
    {
      var outRec = this.m_PolyOuts[i];
      if (outRec.Pts === null)
        continue;
      var p = outRec.Pts.Prev;
      var cnt = this.PointCount(p);
      if (cnt < 2)
        continue;
      var pg = new Array(cnt);
      for (var j = 0; j < cnt; j++)
      {
        pg[j] = p.Pt;
        p = p.Prev;
      }
      polyg.push(pg);
    }
  };
  ClipperLib.Clipper.prototype.BuildResult2 = function (polytree)
  {
    polytree.Clear();
    //add each output polygon/contour to polytree ...
    //polytree.m_AllPolys.set_Capacity(this.m_PolyOuts.length);
    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)
    {
      var outRec = this.m_PolyOuts[i];
      var cnt = this.PointCount(outRec.Pts);
      if ((outRec.IsOpen && cnt < 2) || (!outRec.IsOpen && cnt < 3))
        continue;
      this.FixHoleLinkage(outRec);
      var pn = new ClipperLib.PolyNode();
      polytree.m_AllPolys.push(pn);
      outRec.PolyNode = pn;
      pn.m_polygon.length = cnt;
      var op = outRec.Pts.Prev;
      for (var j = 0; j < cnt; j++)
      {
        pn.m_polygon[j] = op.Pt;
        op = op.Prev;
      }
    }
    //fixup PolyNode links etc ...
    //polytree.m_Childs.set_Capacity(this.m_PolyOuts.length);
    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)
    {
      var outRec = this.m_PolyOuts[i];
      if (outRec.PolyNode === null)
        continue;
      else if (outRec.IsOpen)
      {
        outRec.PolyNode.IsOpen = true;
        polytree.AddChild(outRec.PolyNode);
      }
      else if (outRec.FirstLeft !== null && outRec.FirstLeft.PolyNode != null)
        outRec.FirstLeft.PolyNode.AddChild(outRec.PolyNode);
      else
        polytree.AddChild(outRec.PolyNode);
    }
  };
  ClipperLib.Clipper.prototype.FixupOutPolygon = function (outRec)
  {
    //FixupOutPolygon() - removes duplicate points and simplifies consecutive
    //parallel edges by removing the middle vertex.
    var lastOK = null;
    outRec.BottomPt = null;
    var pp = outRec.Pts;
    for (;;)
    {
      if (pp.Prev == pp || pp.Prev == pp.Next)
      {
        outRec.Pts = null;
        return;
      }
      //test for duplicate points and collinear edges ...
      if ((ClipperLib.IntPoint.op_Equality(pp.Pt, pp.Next.Pt)) || (ClipperLib.IntPoint.op_Equality(pp.Pt, pp.Prev.Pt)) ||
        (ClipperLib.ClipperBase.SlopesEqual(pp.Prev.Pt, pp.Pt, pp.Next.Pt, this.m_UseFullRange) &&
          (!this.PreserveCollinear || !this.Pt2IsBetweenPt1AndPt3(pp.Prev.Pt, pp.Pt, pp.Next.Pt))))
      {
        lastOK = null;
        pp.Prev.Next = pp.Next;
        pp.Next.Prev = pp.Prev;
        pp = pp.Prev;
      }
      else if (pp == lastOK)
        break;
      else
      {
        if (lastOK === null)
          lastOK = pp;
        pp = pp.Next;
      }
    }
    outRec.Pts = pp;
  };
  ClipperLib.Clipper.prototype.DupOutPt = function (outPt, InsertAfter)
  {
    var result = new ClipperLib.OutPt();
    //result.Pt = outPt.Pt;
    result.Pt.X = outPt.Pt.X;
    result.Pt.Y = outPt.Pt.Y;
    result.Idx = outPt.Idx;
    if (InsertAfter)
    {
      result.Next = outPt.Next;
      result.Prev = outPt;
      outPt.Next.Prev = result;
      outPt.Next = result;
    }
    else
    {
      result.Prev = outPt.Prev;
      result.Next = outPt;
      outPt.Prev.Next = result;
      outPt.Prev = result;
    }
    return result;
  };
  ClipperLib.Clipper.prototype.GetOverlap = function (a1, a2, b1, b2, $val)
  {
    if (a1 < a2)
    {
      if (b1 < b2)
      {
        $val.Left = Math.max(a1, b1);
        $val.Right = Math.min(a2, b2);
      }
      else
      {
        $val.Left = Math.max(a1, b2);
        $val.Right = Math.min(a2, b1);
      }
    }
    else
    {
      if (b1 < b2)
      {
        $val.Left = Math.max(a2, b1);
        $val.Right = Math.min(a1, b2);
      }
      else
      {
        $val.Left = Math.max(a2, b2);
        $val.Right = Math.min(a1, b1);
      }
    }
    return $val.Left < $val.Right;
  };
  ClipperLib.Clipper.prototype.JoinHorz = function (op1, op1b, op2, op2b, Pt, DiscardLeft)
  {
    var Dir1 = (op1.Pt.X > op1b.Pt.X ? ClipperLib.Direction.dRightToLeft : ClipperLib.Direction.dLeftToRight);
    var Dir2 = (op2.Pt.X > op2b.Pt.X ? ClipperLib.Direction.dRightToLeft : ClipperLib.Direction.dLeftToRight);
    if (Dir1 == Dir2)
      return false;
    //When DiscardLeft, we want Op1b to be on the Left of Op1, otherwise we
    //want Op1b to be on the Right. (And likewise with Op2 and Op2b.)
    //So, to facilitate this while inserting Op1b and Op2b ...
    //when DiscardLeft, make sure we're AT or RIGHT of Pt before adding Op1b,
    //otherwise make sure we're AT or LEFT of Pt. (Likewise with Op2b.)
    if (Dir1 == ClipperLib.Direction.dLeftToRight)
    {
      while (op1.Next.Pt.X <= Pt.X &&
        op1.Next.Pt.X >= op1.Pt.X && op1.Next.Pt.Y == Pt.Y)
        op1 = op1.Next;
      if (DiscardLeft && (op1.Pt.X != Pt.X))
        op1 = op1.Next;
      op1b = this.DupOutPt(op1, !DiscardLeft);
      if (ClipperLib.IntPoint.op_Inequality(op1b.Pt, Pt))
      {
        op1 = op1b;
        //op1.Pt = Pt;
        op1.Pt.X = Pt.X;
        op1.Pt.Y = Pt.Y;
        op1b = this.DupOutPt(op1, !DiscardLeft);
      }
    }
    else
    {
      while (op1.Next.Pt.X >= Pt.X &&
        op1.Next.Pt.X <= op1.Pt.X && op1.Next.Pt.Y == Pt.Y)
        op1 = op1.Next;
      if (!DiscardLeft && (op1.Pt.X != Pt.X))
        op1 = op1.Next;
      op1b = this.DupOutPt(op1, DiscardLeft);
      if (ClipperLib.IntPoint.op_Inequality(op1b.Pt, Pt))
      {
        op1 = op1b;
        //op1.Pt = Pt;
        op1.Pt.X = Pt.X;
        op1.Pt.Y = Pt.Y;
        op1b = this.DupOutPt(op1, DiscardLeft);
      }
    }
    if (Dir2 == ClipperLib.Direction.dLeftToRight)
    {
      while (op2.Next.Pt.X <= Pt.X &&
        op2.Next.Pt.X >= op2.Pt.X && op2.Next.Pt.Y == Pt.Y)
        op2 = op2.Next;
      if (DiscardLeft && (op2.Pt.X != Pt.X))
        op2 = op2.Next;
      op2b = this.DupOutPt(op2, !DiscardLeft);
      if (ClipperLib.IntPoint.op_Inequality(op2b.Pt, Pt))
      {
        op2 = op2b;
        //op2.Pt = Pt;
        op2.Pt.X = Pt.X;
        op2.Pt.Y = Pt.Y;
        op2b = this.DupOutPt(op2, !DiscardLeft);
      }
    }
    else
    {
      while (op2.Next.Pt.X >= Pt.X &&
        op2.Next.Pt.X <= op2.Pt.X && op2.Next.Pt.Y == Pt.Y)
        op2 = op2.Next;
      if (!DiscardLeft && (op2.Pt.X != Pt.X))
        op2 = op2.Next;
      op2b = this.DupOutPt(op2, DiscardLeft);
      if (ClipperLib.IntPoint.op_Inequality(op2b.Pt, Pt))
      {
        op2 = op2b;
        //op2.Pt = Pt;
        op2.Pt.X = Pt.X;
        op2.Pt.Y = Pt.Y;
        op2b = this.DupOutPt(op2, DiscardLeft);
      }
    }
    if ((Dir1 == ClipperLib.Direction.dLeftToRight) == DiscardLeft)
    {
      op1.Prev = op2;
      op2.Next = op1;
      op1b.Next = op2b;
      op2b.Prev = op1b;
    }
    else
    {
      op1.Next = op2;
      op2.Prev = op1;
      op1b.Prev = op2b;
      op2b.Next = op1b;
    }
    return true;
  };
  ClipperLib.Clipper.prototype.JoinPoints = function (j, outRec1, outRec2)
  {
    var op1 = j.OutPt1,
      op1b = new ClipperLib.OutPt();
    var op2 = j.OutPt2,
      op2b = new ClipperLib.OutPt();
    //There are 3 kinds of joins for output polygons ...
    //1. Horizontal joins where Join.OutPt1 & Join.OutPt2 are a vertices anywhere
    //along (horizontal) collinear edges (& Join.OffPt is on the same horizontal).
    //2. Non-horizontal joins where Join.OutPt1 & Join.OutPt2 are at the same
    //location at the Bottom of the overlapping segment (& Join.OffPt is above).
    //3. StrictlySimple joins where edges touch but are not collinear and where
    //Join.OutPt1, Join.OutPt2 & Join.OffPt all share the same point.
    var isHorizontal = (j.OutPt1.Pt.Y == j.OffPt.Y);
    if (isHorizontal && (ClipperLib.IntPoint.op_Equality(j.OffPt, j.OutPt1.Pt)) && (ClipperLib.IntPoint.op_Equality(j.OffPt, j.OutPt2.Pt)))
    {
      //Strictly Simple join ...
			if (outRec1 != outRec2) return false;

      op1b = j.OutPt1.Next;
      while (op1b != op1 && (ClipperLib.IntPoint.op_Equality(op1b.Pt, j.OffPt)))
        op1b = op1b.Next;
      var reverse1 = (op1b.Pt.Y > j.OffPt.Y);
      op2b = j.OutPt2.Next;
      while (op2b != op2 && (ClipperLib.IntPoint.op_Equality(op2b.Pt, j.OffPt)))
        op2b = op2b.Next;
      var reverse2 = (op2b.Pt.Y > j.OffPt.Y);
      if (reverse1 == reverse2)
        return false;
      if (reverse1)
      {
        op1b = this.DupOutPt(op1, false);
        op2b = this.DupOutPt(op2, true);
        op1.Prev = op2;
        op2.Next = op1;
        op1b.Next = op2b;
        op2b.Prev = op1b;
        j.OutPt1 = op1;
        j.OutPt2 = op1b;
        return true;
      }
      else
      {
        op1b = this.DupOutPt(op1, true);
        op2b = this.DupOutPt(op2, false);
        op1.Next = op2;
        op2.Prev = op1;
        op1b.Prev = op2b;
        op2b.Next = op1b;
        j.OutPt1 = op1;
        j.OutPt2 = op1b;
        return true;
      }
    }
    else if (isHorizontal)
    {
      //treat horizontal joins differently to non-horizontal joins since with
      //them we're not yet sure where the overlapping is. OutPt1.Pt & OutPt2.Pt
      //may be anywhere along the horizontal edge.
      op1b = op1;
      while (op1.Prev.Pt.Y == op1.Pt.Y && op1.Prev != op1b && op1.Prev != op2)
        op1 = op1.Prev;
      while (op1b.Next.Pt.Y == op1b.Pt.Y && op1b.Next != op1 && op1b.Next != op2)
        op1b = op1b.Next;
      if (op1b.Next == op1 || op1b.Next == op2)
        return false;
      //a flat 'polygon'
      op2b = op2;
      while (op2.Prev.Pt.Y == op2.Pt.Y && op2.Prev != op2b && op2.Prev != op1b)
        op2 = op2.Prev;
      while (op2b.Next.Pt.Y == op2b.Pt.Y && op2b.Next != op2 && op2b.Next != op1)
        op2b = op2b.Next;
      if (op2b.Next == op2 || op2b.Next == op1)
        return false;
      //a flat 'polygon'
      //Op1 -. Op1b & Op2 -. Op2b are the extremites of the horizontal edges

      var $val = {Left: null, Right: null};
      if (!this.GetOverlap(op1.Pt.X, op1b.Pt.X, op2.Pt.X, op2b.Pt.X, $val))
        return false;
      var Left = $val.Left;
      var Right = $val.Right;

      //DiscardLeftSide: when overlapping edges are joined, a spike will created
      //which needs to be cleaned up. However, we don't want Op1 or Op2 caught up
      //on the discard Side as either may still be needed for other joins ...
      var Pt = new ClipperLib.IntPoint();
      var DiscardLeftSide;
      if (op1.Pt.X >= Left && op1.Pt.X <= Right)
      {
        //Pt = op1.Pt;
        Pt.X = op1.Pt.X;
        Pt.Y = op1.Pt.Y;
        DiscardLeftSide = (op1.Pt.X > op1b.Pt.X);
      }
      else if (op2.Pt.X >= Left && op2.Pt.X <= Right)
      {
        //Pt = op2.Pt;
        Pt.X = op2.Pt.X;
        Pt.Y = op2.Pt.Y;
        DiscardLeftSide = (op2.Pt.X > op2b.Pt.X);
      }
      else if (op1b.Pt.X >= Left && op1b.Pt.X <= Right)
      {
        //Pt = op1b.Pt;
        Pt.X = op1b.Pt.X;
        Pt.Y = op1b.Pt.Y;
        DiscardLeftSide = op1b.Pt.X > op1.Pt.X;
      }
      else
      {
        //Pt = op2b.Pt;
        Pt.X = op2b.Pt.X;
        Pt.Y = op2b.Pt.Y;
        DiscardLeftSide = (op2b.Pt.X > op2.Pt.X);
      }
      j.OutPt1 = op1;
      j.OutPt2 = op2;
      return this.JoinHorz(op1, op1b, op2, op2b, Pt, DiscardLeftSide);
    }
    else
    {
      //nb: For non-horizontal joins ...
      //    1. Jr.OutPt1.Pt.Y == Jr.OutPt2.Pt.Y
      //    2. Jr.OutPt1.Pt > Jr.OffPt.Y
      //make sure the polygons are correctly oriented ...
      op1b = op1.Next;
      while ((ClipperLib.IntPoint.op_Equality(op1b.Pt, op1.Pt)) && (op1b != op1))
        op1b = op1b.Next;
      var Reverse1 = ((op1b.Pt.Y > op1.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual(op1.Pt, op1b.Pt, j.OffPt, this.m_UseFullRange));
      if (Reverse1)
      {
        op1b = op1.Prev;
        while ((ClipperLib.IntPoint.op_Equality(op1b.Pt, op1.Pt)) && (op1b != op1))
          op1b = op1b.Prev;
        if ((op1b.Pt.Y > op1.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual(op1.Pt, op1b.Pt, j.OffPt, this.m_UseFullRange))
          return false;
      }
      op2b = op2.Next;
      while ((ClipperLib.IntPoint.op_Equality(op2b.Pt, op2.Pt)) && (op2b != op2))
        op2b = op2b.Next;
      var Reverse2 = ((op2b.Pt.Y > op2.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual(op2.Pt, op2b.Pt, j.OffPt, this.m_UseFullRange));
      if (Reverse2)
      {
        op2b = op2.Prev;
        while ((ClipperLib.IntPoint.op_Equality(op2b.Pt, op2.Pt)) && (op2b != op2))
          op2b = op2b.Prev;
        if ((op2b.Pt.Y > op2.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual(op2.Pt, op2b.Pt, j.OffPt, this.m_UseFullRange))
          return false;
      }
      if ((op1b == op1) || (op2b == op2) || (op1b == op2b) ||
        ((outRec1 == outRec2) && (Reverse1 == Reverse2)))
        return false;
      if (Reverse1)
      {
        op1b = this.DupOutPt(op1, false);
        op2b = this.DupOutPt(op2, true);
        op1.Prev = op2;
        op2.Next = op1;
        op1b.Next = op2b;
        op2b.Prev = op1b;
        j.OutPt1 = op1;
        j.OutPt2 = op1b;
        return true;
      }
      else
      {
        op1b = this.DupOutPt(op1, true);
        op2b = this.DupOutPt(op2, false);
        op1.Next = op2;
        op2.Prev = op1;
        op1b.Prev = op2b;
        op2b.Next = op1b;
        j.OutPt1 = op1;
        j.OutPt2 = op1b;
        return true;
      }
    }
  };
  ClipperLib.Clipper.GetBounds = function (paths)
  {
    var i = 0,
      cnt = paths.length;
    while (i < cnt && paths[i].length == 0) i++;
    if (i == cnt) return new ClipperLib.IntRect(0, 0, 0, 0);
    var result = new ClipperLib.IntRect();
    result.left = paths[i][0].X;
    result.right = result.left;
    result.top = paths[i][0].Y;
    result.bottom = result.top;
    for (; i < cnt; i++)
      for (var j = 0, jlen = paths[i].length; j < jlen; j++)
      {
        if (paths[i][j].X < result.left) result.left = paths[i][j].X;
        else if (paths[i][j].X > result.right) result.right = paths[i][j].X;
        if (paths[i][j].Y < result.top) result.top = paths[i][j].Y;
        else if (paths[i][j].Y > result.bottom) result.bottom = paths[i][j].Y;
      }
    return result;
  }
  ClipperLib.Clipper.prototype.GetBounds2 = function (ops)
  {
    var opStart = ops;
    var result = new ClipperLib.IntRect();
    result.left = ops.Pt.X;
    result.right = ops.Pt.X;
    result.top = ops.Pt.Y;
    result.bottom = ops.Pt.Y;
    ops = ops.Next;
    while (ops != opStart)
    {
      if (ops.Pt.X < result.left)
        result.left = ops.Pt.X;
      if (ops.Pt.X > result.right)
        result.right = ops.Pt.X;
      if (ops.Pt.Y < result.top)
        result.top = ops.Pt.Y;
      if (ops.Pt.Y > result.bottom)
        result.bottom = ops.Pt.Y;
      ops = ops.Next;
    }
    return result;
  };

  ClipperLib.Clipper.PointInPolygon = function (pt, path)
  {
    //returns 0 if false, +1 if true, -1 if pt ON polygon boundary
		//See "The Point in Polygon Problem for Arbitrary Polygons" by Hormann & Agathos
    //http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.88.5498&rep=rep1&type=pdf
    var result = 0,
      cnt = path.length;
    if (cnt < 3)
      return 0;
    var ip = path[0];
    for (var i = 1; i <= cnt; ++i)
    {
      var ipNext = (i == cnt ? path[0] : path[i]);
      if (ipNext.Y == pt.Y)
      {
        if ((ipNext.X == pt.X) || (ip.Y == pt.Y && ((ipNext.X > pt.X) == (ip.X < pt.X))))
          return -1;
      }
      if ((ip.Y < pt.Y) != (ipNext.Y < pt.Y))
      {
        if (ip.X >= pt.X)
        {
          if (ipNext.X > pt.X)
            result = 1 - result;
          else
          {
            var d = (ip.X - pt.X) * (ipNext.Y - pt.Y) - (ipNext.X - pt.X) * (ip.Y - pt.Y);
            if (d == 0)
              return -1;
            else if ((d > 0) == (ipNext.Y > ip.Y))
              result = 1 - result;
          }
        }
        else
        {
          if (ipNext.X > pt.X)
          {
            var d = (ip.X - pt.X) * (ipNext.Y - pt.Y) - (ipNext.X - pt.X) * (ip.Y - pt.Y);
            if (d == 0)
              return -1;
            else if ((d > 0) == (ipNext.Y > ip.Y))
              result = 1 - result;
          }
        }
      }
      ip = ipNext;
    }
    return result;
  };

  ClipperLib.Clipper.prototype.PointInPolygon = function (pt, op)
  {
    //returns 0 if false, +1 if true, -1 if pt ON polygon boundary
		//See "The Point in Polygon Problem for Arbitrary Polygons" by Hormann & Agathos
    //http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.88.5498&rep=rep1&type=pdf
    var result = 0;
    var startOp = op;
		var ptx = pt.X, pty = pt.Y;
    var poly0x = op.Pt.X, poly0y = op.Pt.Y;
    do
    {
			op = op.Next;
			var poly1x = op.Pt.X, poly1y = op.Pt.Y;
      if (poly1y == pty)
      {
        if ((poly1x == ptx) || (poly0y == pty && ((poly1x > ptx) == (poly0x < ptx))))
          return -1;
      }
      if ((poly0y < pty) != (poly1y < pty))
      {
        if (poly0x >= ptx)
        {
          if (poly1x > ptx)
            result = 1 - result;
          else
          {
            var d = (poly0x - ptx) * (poly1y - pty) - (poly1x - ptx) * (poly0y - pty);
            if (d == 0)
              return -1;
            if ((d > 0) == (poly1y > poly0y))
              result = 1 - result;
          }
        }
        else
        {
          if (poly1x > ptx)
          {
            var d = (poly0x - ptx) * (poly1y - pty) - (poly1x - ptx) * (poly0y - pty);
            if (d == 0)
              return -1;
            if ((d > 0) == (poly1y > poly0y))
              result = 1 - result;
          }
        }
      }
      poly0x = poly1x;
      poly0y = poly1y;
    } while (startOp != op);

    return result;
  };

  ClipperLib.Clipper.prototype.Poly2ContainsPoly1 = function (outPt1, outPt2)
  {
    var op = outPt1;
    do
    {
			//nb: PointInPolygon returns 0 if false, +1 if true, -1 if pt on polygon
      var res = this.PointInPolygon(op.Pt, outPt2);
      if (res >= 0)
        return res > 0;
      op = op.Next;
    }
    while (op != outPt1)
    return true;
  };
  ClipperLib.Clipper.prototype.FixupFirstLefts1 = function (OldOutRec, NewOutRec)
  {
    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)
    {
			var outRec = this.m_PolyOuts[i];
			if (outRec.Pts == null || outRec.FirstLeft == null)
				continue;
			var firstLeft = this.ParseFirstLeft(outRec.FirstLeft);
			if (firstLeft == OldOutRec)
			{
        if (this.Poly2ContainsPoly1(outRec.Pts, NewOutRec.Pts))
          outRec.FirstLeft = NewOutRec;
      }
    }
  };
  ClipperLib.Clipper.prototype.FixupFirstLefts2 = function (OldOutRec, NewOutRec)
  {
    for (var $i2 = 0, $t2 = this.m_PolyOuts, $l2 = $t2.length, outRec = $t2[$i2]; $i2 < $l2; $i2++, outRec = $t2[$i2])
      if (outRec.FirstLeft == OldOutRec)
        outRec.FirstLeft = NewOutRec;
  };
  ClipperLib.Clipper.ParseFirstLeft = function (FirstLeft)
  {
    while (FirstLeft != null && FirstLeft.Pts == null)
      FirstLeft = FirstLeft.FirstLeft;
    return FirstLeft;
  };
  ClipperLib.Clipper.prototype.JoinCommonEdges = function ()
  {
    for (var i = 0, ilen = this.m_Joins.length; i < ilen; i++)
    {
      var join = this.m_Joins[i];
      var outRec1 = this.GetOutRec(join.OutPt1.Idx);
      var outRec2 = this.GetOutRec(join.OutPt2.Idx);
      if (outRec1.Pts == null || outRec2.Pts == null)
        continue;
      //get the polygon fragment with the correct hole state (FirstLeft)
      //before calling JoinPoints() ...
      var holeStateRec;
      if (outRec1 == outRec2)
        holeStateRec = outRec1;
      else if (this.Param1RightOfParam2(outRec1, outRec2))
        holeStateRec = outRec2;
      else if (this.Param1RightOfParam2(outRec2, outRec1))
        holeStateRec = outRec1;
      else
        holeStateRec = this.GetLowermostRec(outRec1, outRec2);

      if (!this.JoinPoints(join, outRec1, outRec2)) continue;

      if (outRec1 == outRec2)
      {
        //instead of joining two polygons, we've just created a new one by
        //splitting one polygon into two.
        outRec1.Pts = join.OutPt1;
        outRec1.BottomPt = null;
        outRec2 = this.CreateOutRec();
        outRec2.Pts = join.OutPt2;
        //update all OutRec2.Pts Idx's ...
        this.UpdateOutPtIdxs(outRec2);
        //We now need to check every OutRec.FirstLeft pointer. If it points
        //to OutRec1 it may need to point to OutRec2 instead ...
        if (this.m_UsingPolyTree)
          for (var j = 0, jlen = this.m_PolyOuts.length; j < jlen - 1; j++)
          {
            var oRec = this.m_PolyOuts[j];
            if (oRec.Pts == null || ClipperLib.Clipper.ParseFirstLeft(oRec.FirstLeft) != outRec1 || oRec.IsHole == outRec1.IsHole)
              continue;
            if (this.Poly2ContainsPoly1(oRec.Pts, join.OutPt2))
              oRec.FirstLeft = outRec2;
          }
        if (this.Poly2ContainsPoly1(outRec2.Pts, outRec1.Pts))
        {
          //outRec2 is contained by outRec1 ...
          outRec2.IsHole = !outRec1.IsHole;
          outRec2.FirstLeft = outRec1;
          //fixup FirstLeft pointers that may need reassigning to OutRec1
          if (this.m_UsingPolyTree)
            this.FixupFirstLefts2(outRec2, outRec1);
          if ((outRec2.IsHole ^ this.ReverseSolution) == (this.Area(outRec2) > 0))
            this.ReversePolyPtLinks(outRec2.Pts);
        }
        else if (this.Poly2ContainsPoly1(outRec1.Pts, outRec2.Pts))
        {
          //outRec1 is contained by outRec2 ...
          outRec2.IsHole = outRec1.IsHole;
          outRec1.IsHole = !outRec2.IsHole;
          outRec2.FirstLeft = outRec1.FirstLeft;
          outRec1.FirstLeft = outRec2;
          //fixup FirstLeft pointers that may need reassigning to OutRec1
          if (this.m_UsingPolyTree)
            this.FixupFirstLefts2(outRec1, outRec2);
          if ((outRec1.IsHole ^ this.ReverseSolution) == (this.Area(outRec1) > 0))
            this.ReversePolyPtLinks(outRec1.Pts);
        }
        else
        {
          //the 2 polygons are completely separate ...
          outRec2.IsHole = outRec1.IsHole;
          outRec2.FirstLeft = outRec1.FirstLeft;
          //fixup FirstLeft pointers that may need reassigning to OutRec2
          if (this.m_UsingPolyTree)
            this.FixupFirstLefts1(outRec1, outRec2);
        }
      }
      else
      {
        //joined 2 polygons together ...
        outRec2.Pts = null;
        outRec2.BottomPt = null;
        outRec2.Idx = outRec1.Idx;
        outRec1.IsHole = holeStateRec.IsHole;
        if (holeStateRec == outRec2)
          outRec1.FirstLeft = outRec2.FirstLeft;
        outRec2.FirstLeft = outRec1;
        //fixup FirstLeft pointers that may need reassigning to OutRec1
        if (this.m_UsingPolyTree)
          this.FixupFirstLefts2(outRec2, outRec1);
      }
    }
  };
  ClipperLib.Clipper.prototype.UpdateOutPtIdxs = function (outrec)
  {
    var op = outrec.Pts;
    do {
      op.Idx = outrec.Idx;
      op = op.Prev;
    }
    while (op != outrec.Pts)
  };
  ClipperLib.Clipper.prototype.DoSimplePolygons = function ()
  {
    var i = 0;
    while (i < this.m_PolyOuts.length)
    {
      var outrec = this.m_PolyOuts[i++];
      var op = outrec.Pts;
			if (op == null || outrec.IsOpen)
				continue;
      do //for each Pt in Polygon until duplicate found do ...
      {
        var op2 = op.Next;
        while (op2 != outrec.Pts)
        {
          if ((ClipperLib.IntPoint.op_Equality(op.Pt, op2.Pt)) && op2.Next != op && op2.Prev != op)
          {
            //split the polygon into two ...
            var op3 = op.Prev;
            var op4 = op2.Prev;
            op.Prev = op4;
            op4.Next = op;
            op2.Prev = op3;
            op3.Next = op2;
            outrec.Pts = op;
            var outrec2 = this.CreateOutRec();
            outrec2.Pts = op2;
            this.UpdateOutPtIdxs(outrec2);
            if (this.Poly2ContainsPoly1(outrec2.Pts, outrec.Pts))
            {
              //OutRec2 is contained by OutRec1 ...
              outrec2.IsHole = !outrec.IsHole;
              outrec2.FirstLeft = outrec;
							if (this.m_UsingPolyTree) this.FixupFirstLefts2(outrec2, outrec);

            }
            else if (this.Poly2ContainsPoly1(outrec.Pts, outrec2.Pts))
            {
              //OutRec1 is contained by OutRec2 ...
              outrec2.IsHole = outrec.IsHole;
              outrec.IsHole = !outrec2.IsHole;
              outrec2.FirstLeft = outrec.FirstLeft;
              outrec.FirstLeft = outrec2;
              if (this.m_UsingPolyTree) this.FixupFirstLefts2(outrec, outrec2);
            }
            else
            {
              //the 2 polygons are separate ...
              outrec2.IsHole = outrec.IsHole;
              outrec2.FirstLeft = outrec.FirstLeft;
							if (this.m_UsingPolyTree) this.FixupFirstLefts1(outrec, outrec2);
            }
            op2 = op;
            //ie get ready for the next iteration
          }
          op2 = op2.Next;
        }
        op = op.Next;
      }
      while (op != outrec.Pts)
    }
  };
  ClipperLib.Clipper.Area = function (poly)
  {
    var cnt = poly.length;
    if (cnt < 3)
      return 0;
    var a = 0;
    for (var i = 0, j = cnt - 1; i < cnt; ++i)
    {
      a += (poly[j].X + poly[i].X) * (poly[j].Y - poly[i].Y);
      j = i;
    }
    return -a * 0.5;
  };
  ClipperLib.Clipper.prototype.Area = function (outRec)
  {
    var op = outRec.Pts;
    if (op == null)
      return 0;
    var a = 0;
    do {
      a = a + (op.Prev.Pt.X + op.Pt.X) * (op.Prev.Pt.Y - op.Pt.Y);
      op = op.Next;
    }
    while (op != outRec.Pts)
    return a * 0.5;
  };
  ClipperLib.Clipper.SimplifyPolygon = function (poly, fillType)
  {
    var result = new Array();
    var c = new ClipperLib.Clipper(0);
    c.StrictlySimple = true;
    c.AddPath(poly, ClipperLib.PolyType.ptSubject, true);
    c.Execute(ClipperLib.ClipType.ctUnion, result, fillType, fillType);
    return result;
  };
  ClipperLib.Clipper.SimplifyPolygons = function (polys, fillType)
  {
    if (typeof (fillType) == "undefined") fillType = ClipperLib.PolyFillType.pftEvenOdd;
    var result = new Array();
    var c = new ClipperLib.Clipper(0);
    c.StrictlySimple = true;
    c.AddPaths(polys, ClipperLib.PolyType.ptSubject, true);
    c.Execute(ClipperLib.ClipType.ctUnion, result, fillType, fillType);
    return result;
  };
  ClipperLib.Clipper.DistanceSqrd = function (pt1, pt2)
  {
    var dx = (pt1.X - pt2.X);
    var dy = (pt1.Y - pt2.Y);
    return (dx * dx + dy * dy);
  };
  ClipperLib.Clipper.DistanceFromLineSqrd = function (pt, ln1, ln2)
  {
    //The equation of a line in general form (Ax + By + C = 0)
    //given 2 points (x¹,y¹) & (x²,y²) is ...
    //(y¹ - y²)x + (x² - x¹)y + (y² - y¹)x¹ - (x² - x¹)y¹ = 0
    //A = (y¹ - y²); B = (x² - x¹); C = (y² - y¹)x¹ - (x² - x¹)y¹
    //perpendicular distance of point (x³,y³) = (Ax³ + By³ + C)/Sqrt(A² + B²)
    //see http://en.wikipedia.org/wiki/Perpendicular_distance
    var A = ln1.Y - ln2.Y;
    var B = ln2.X - ln1.X;
    var C = A * ln1.X + B * ln1.Y;
    C = A * pt.X + B * pt.Y - C;
    return (C * C) / (A * A + B * B);
  };

	ClipperLib.Clipper.SlopesNearCollinear = function(pt1, pt2, pt3, distSqrd)
	{
		//this function is more accurate when the point that's GEOMETRICALLY
		//between the other 2 points is the one that's tested for distance.
		//nb: with 'spikes', either pt1 or pt3 is geometrically between the other pts
		if (Math.abs(pt1.X - pt2.X) > Math.abs(pt1.Y - pt2.Y))
		{
		if ((pt1.X > pt2.X) == (pt1.X < pt3.X))
			return ClipperLib.Clipper.DistanceFromLineSqrd(pt1, pt2, pt3) < distSqrd;
		else if ((pt2.X > pt1.X) == (pt2.X < pt3.X))
			return ClipperLib.Clipper.DistanceFromLineSqrd(pt2, pt1, pt3) < distSqrd;
				else
				return ClipperLib.Clipper.DistanceFromLineSqrd(pt3, pt1, pt2) < distSqrd;
		}
		else
		{
		if ((pt1.Y > pt2.Y) == (pt1.Y < pt3.Y))
			return ClipperLib.Clipper.DistanceFromLineSqrd(pt1, pt2, pt3) < distSqrd;
		else if ((pt2.Y > pt1.Y) == (pt2.Y < pt3.Y))
			return ClipperLib.Clipper.DistanceFromLineSqrd(pt2, pt1, pt3) < distSqrd;
				else
			return ClipperLib.Clipper.DistanceFromLineSqrd(pt3, pt1, pt2) < distSqrd;
		}
	}

  ClipperLib.Clipper.PointsAreClose = function (pt1, pt2, distSqrd)
  {
    var dx = pt1.X - pt2.X;
    var dy = pt1.Y - pt2.Y;
    return ((dx * dx) + (dy * dy) <= distSqrd);
  };
  //------------------------------------------------------------------------------
  ClipperLib.Clipper.ExcludeOp = function (op)
  {
    var result = op.Prev;
    result.Next = op.Next;
    op.Next.Prev = result;
    result.Idx = 0;
    return result;
  };
  ClipperLib.Clipper.CleanPolygon = function (path, distance)
  {
    if (typeof (distance) == "undefined") distance = 1.415;
    //distance = proximity in units/pixels below which vertices will be stripped.
    //Default ~= sqrt(2) so when adjacent vertices or semi-adjacent vertices have
    //both x & y coords within 1 unit, then the second vertex will be stripped.
    var cnt = path.length;
    if (cnt == 0)
      return new Array();
    var outPts = new Array(cnt);
    for (var i = 0; i < cnt; ++i)
      outPts[i] = new ClipperLib.OutPt();
    for (var i = 0; i < cnt; ++i)
    {
      outPts[i].Pt = path[i];
      outPts[i].Next = outPts[(i + 1) % cnt];
      outPts[i].Next.Prev = outPts[i];
      outPts[i].Idx = 0;
    }
    var distSqrd = distance * distance;
    var op = outPts[0];
    while (op.Idx == 0 && op.Next != op.Prev)
    {
      if (ClipperLib.Clipper.PointsAreClose(op.Pt, op.Prev.Pt, distSqrd))
      {
        op = ClipperLib.Clipper.ExcludeOp(op);
        cnt--;
      }
      else if (ClipperLib.Clipper.PointsAreClose(op.Prev.Pt, op.Next.Pt, distSqrd))
      {
        ClipperLib.Clipper.ExcludeOp(op.Next);
        op = ClipperLib.Clipper.ExcludeOp(op);
        cnt -= 2;
      }
      else if (ClipperLib.Clipper.SlopesNearCollinear(op.Prev.Pt, op.Pt, op.Next.Pt, distSqrd))
      {
        op = ClipperLib.Clipper.ExcludeOp(op);
        cnt--;
      }
      else
      {
        op.Idx = 1;
        op = op.Next;
      }
    }
    if (cnt < 3)
      cnt = 0;
    var result = new Array(cnt);
    for (var i = 0; i < cnt; ++i)
    {
      result[i] = new ClipperLib.IntPoint(op.Pt);
      op = op.Next;
    }
    outPts = null;
    return result;
  };
  ClipperLib.Clipper.CleanPolygons = function (polys, distance)
  {
    var result = new Array(polys.length);
    for (var i = 0, ilen = polys.length; i < ilen; i++)
      result[i] = ClipperLib.Clipper.CleanPolygon(polys[i], distance);
    return result;
  };
  ClipperLib.Clipper.Minkowski = function (pattern, path, IsSum, IsClosed)
  {
    var delta = (IsClosed ? 1 : 0);
    var polyCnt = pattern.length;
    var pathCnt = path.length;
    var result = new Array();
    if (IsSum)
      for (var i = 0; i < pathCnt; i++)
      {
        var p = new Array(polyCnt);
        for (var j = 0, jlen = pattern.length, ip = pattern[j]; j < jlen; j++, ip = pattern[j])
          p[j] = new ClipperLib.IntPoint(path[i].X + ip.X, path[i].Y + ip.Y);
        result.push(p);
      }
    else
      for (var i = 0; i < pathCnt; i++)
      {
        var p = new Array(polyCnt);
        for (var j = 0, jlen = pattern.length, ip = pattern[j]; j < jlen; j++, ip = pattern[j])
          p[j] = new ClipperLib.IntPoint(path[i].X - ip.X, path[i].Y - ip.Y);
        result.push(p);
      }
    var quads = new Array();
    for (var i = 0; i < pathCnt - 1 + delta; i++)
      for (var j = 0; j < polyCnt; j++)
      {
        var quad = new Array();
        quad.push(result[i % pathCnt][j % polyCnt]);
        quad.push(result[(i + 1) % pathCnt][j % polyCnt]);
        quad.push(result[(i + 1) % pathCnt][(j + 1) % polyCnt]);
        quad.push(result[i % pathCnt][(j + 1) % polyCnt]);
        if (!ClipperLib.Clipper.Orientation(quad))
          quad.reverse();
        quads.push(quad);
      }
			return quads;
  };

	ClipperLib.Clipper.MinkowskiSum = function(pattern, path_or_paths, pathIsClosed)
	{
		if(!(path_or_paths[0] instanceof Array))
		{
			var path = path_or_paths;
			var paths = ClipperLib.Clipper.Minkowski(pattern, path, true, pathIsClosed);
			var c = new ClipperLib.Clipper();
			c.AddPaths(paths, ClipperLib.PolyType.ptSubject, true);
			c.Execute(ClipperLib.ClipType.ctUnion, paths, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);
			return paths;
		}
		else
		{
 			var paths = path_or_paths;
			var solution = new ClipperLib.Paths();
			var c = new ClipperLib.Clipper();
			for (var i = 0; i < paths.length; ++i)
			{
				var tmp = ClipperLib.Clipper.Minkowski(pattern, paths[i], true, pathIsClosed);
				c.AddPaths(tmp, ClipperLib.PolyType.ptSubject, true);
				if (pathIsClosed)
				{
					var path = ClipperLib.Clipper.TranslatePath(paths[i], pattern[0]);
					c.AddPath(path, ClipperLib.PolyType.ptClip, true);
				}
			}
			c.Execute(ClipperLib.ClipType.ctUnion, solution,
				ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);
			return solution;
		}
	}
	//------------------------------------------------------------------------------

	ClipperLib.Clipper.TranslatePath = function (path, delta)
	{
		var outPath = new ClipperLib.Path();
		for (var i = 0; i < path.length; i++)
			outPath.push(new ClipperLib.IntPoint(path[i].X + delta.X, path[i].Y + delta.Y));
		return outPath;
	}
	//------------------------------------------------------------------------------

	ClipperLib.Clipper.MinkowskiDiff = function (poly1, poly2)
	{
		var paths = ClipperLib.Clipper.Minkowski(poly1, poly2, false, true);
		var c = new ClipperLib.Clipper();
		c.AddPaths(paths, ClipperLib.PolyType.ptSubject, true);
		c.Execute(ClipperLib.ClipType.ctUnion, paths, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);
		return paths;
	}

  ClipperLib.Clipper.PolyTreeToPaths = function (polytree)
  {
    var result = new Array();
    //result.set_Capacity(polytree.get_Total());
    ClipperLib.Clipper.AddPolyNodeToPaths(polytree, ClipperLib.Clipper.NodeType.ntAny, result);
    return result;
  };
  ClipperLib.Clipper.AddPolyNodeToPaths = function (polynode, nt, paths)
  {
    var match = true;
    switch (nt)
    {
    case ClipperLib.Clipper.NodeType.ntOpen:
      return;
    case ClipperLib.Clipper.NodeType.ntClosed:
      match = !polynode.IsOpen;
      break;
    default:
      break;
    }
    if (polynode.m_polygon.length > 0 && match)
      paths.push(polynode.m_polygon);
    for (var $i3 = 0, $t3 = polynode.Childs(), $l3 = $t3.length, pn = $t3[$i3]; $i3 < $l3; $i3++, pn = $t3[$i3])
      ClipperLib.Clipper.AddPolyNodeToPaths(pn, nt, paths);
  };
  ClipperLib.Clipper.OpenPathsFromPolyTree = function (polytree)
  {
    var result = new ClipperLib.Paths();
    //result.set_Capacity(polytree.ChildCount());
    for (var i = 0, ilen = polytree.ChildCount(); i < ilen; i++)
      if (polytree.Childs()[i].IsOpen)
        result.push(polytree.Childs()[i].m_polygon);
    return result;
  };
  ClipperLib.Clipper.ClosedPathsFromPolyTree = function (polytree)
  {
    var result = new ClipperLib.Paths();
    //result.set_Capacity(polytree.Total());
    ClipperLib.Clipper.AddPolyNodeToPaths(polytree, ClipperLib.Clipper.NodeType.ntClosed, result);
    return result;
  };
  Inherit(ClipperLib.Clipper, ClipperLib.ClipperBase);
  ClipperLib.Clipper.NodeType = {
    ntAny: 0,
    ntOpen: 1,
    ntClosed: 2
  };
  ClipperLib.ClipperOffset = function (miterLimit, arcTolerance)
  {
    if (typeof (miterLimit) == "undefined") miterLimit = 2;
    if (typeof (arcTolerance) == "undefined") arcTolerance = ClipperLib.ClipperOffset.def_arc_tolerance;
    this.m_destPolys = new ClipperLib.Paths();
    this.m_srcPoly = new ClipperLib.Path();
    this.m_destPoly = new ClipperLib.Path();
    this.m_normals = new Array();
    this.m_delta = 0;
    this.m_sinA = 0;
    this.m_sin = 0;
    this.m_cos = 0;
    this.m_miterLim = 0;
    this.m_StepsPerRad = 0;
    this.m_lowest = new ClipperLib.IntPoint();
    this.m_polyNodes = new ClipperLib.PolyNode();
    this.MiterLimit = miterLimit;
    this.ArcTolerance = arcTolerance;
    this.m_lowest.X = -1;
  };
  ClipperLib.ClipperOffset.two_pi = 6.28318530717959;
  ClipperLib.ClipperOffset.def_arc_tolerance = 0.25;
  ClipperLib.ClipperOffset.prototype.Clear = function ()
  {
    ClipperLib.Clear(this.m_polyNodes.Childs());
    this.m_lowest.X = -1;
  };
  ClipperLib.ClipperOffset.Round = ClipperLib.Clipper.Round;
  ClipperLib.ClipperOffset.prototype.AddPath = function (path, joinType, endType)
  {
    var highI = path.length - 1;
    if (highI < 0)
      return;
    var newNode = new ClipperLib.PolyNode();
    newNode.m_jointype = joinType;
    newNode.m_endtype = endType;
    //strip duplicate points from path and also get index to the lowest point ...
    if (endType == ClipperLib.EndType.etClosedLine || endType == ClipperLib.EndType.etClosedPolygon)
      while (highI > 0 && ClipperLib.IntPoint.op_Equality(path[0], path[highI]))
        highI--;
    //newNode.m_polygon.set_Capacity(highI + 1);
    newNode.m_polygon.push(path[0]);
    var j = 0,
      k = 0;
    for (var i = 1; i <= highI; i++)
      if (ClipperLib.IntPoint.op_Inequality(newNode.m_polygon[j], path[i]))
      {
        j++;
        newNode.m_polygon.push(path[i]);
        if (path[i].Y > newNode.m_polygon[k].Y || (path[i].Y == newNode.m_polygon[k].Y && path[i].X < newNode.m_polygon[k].X))
          k = j;
      }
    if (endType == ClipperLib.EndType.etClosedPolygon && j < 2) return;

    this.m_polyNodes.AddChild(newNode);
    //if this path's lowest pt is lower than all the others then update m_lowest
    if (endType != ClipperLib.EndType.etClosedPolygon)
      return;
    if (this.m_lowest.X < 0)
      this.m_lowest = new ClipperLib.IntPoint(this.m_polyNodes.ChildCount() - 1, k);
    else
    {
      var ip = this.m_polyNodes.Childs()[this.m_lowest.X].m_polygon[this.m_lowest.Y];
      if (newNode.m_polygon[k].Y > ip.Y || (newNode.m_polygon[k].Y == ip.Y && newNode.m_polygon[k].X < ip.X))
        this.m_lowest = new ClipperLib.IntPoint(this.m_polyNodes.ChildCount() - 1, k);
    }
  };
  ClipperLib.ClipperOffset.prototype.AddPaths = function (paths, joinType, endType)
  {
    for (var i = 0, ilen = paths.length; i < ilen; i++)
      this.AddPath(paths[i], joinType, endType);
  };
  ClipperLib.ClipperOffset.prototype.FixOrientations = function ()
  {
    //fixup orientations of all closed paths if the orientation of the
    //closed path with the lowermost vertex is wrong ...
    if (this.m_lowest.X >= 0 && !ClipperLib.Clipper.Orientation(this.m_polyNodes.Childs()[this.m_lowest.X].m_polygon))
    {
      for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)
      {
        var node = this.m_polyNodes.Childs()[i];
        if (node.m_endtype == ClipperLib.EndType.etClosedPolygon || (node.m_endtype == ClipperLib.EndType.etClosedLine && ClipperLib.Clipper.Orientation(node.m_polygon)))
          node.m_polygon.reverse();
      }
    }
    else
    {
      for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)
      {
        var node = this.m_polyNodes.Childs()[i];
        if (node.m_endtype == ClipperLib.EndType.etClosedLine && !ClipperLib.Clipper.Orientation(node.m_polygon))
          node.m_polygon.reverse();
      }
    }
  };
  ClipperLib.ClipperOffset.GetUnitNormal = function (pt1, pt2)
  {
    var dx = (pt2.X - pt1.X);
    var dy = (pt2.Y - pt1.Y);
    if ((dx == 0) && (dy == 0))
      return new ClipperLib.DoublePoint(0, 0);
    var f = 1 / Math.sqrt(dx * dx + dy * dy);
    dx *= f;
    dy *= f;
    return new ClipperLib.DoublePoint(dy, -dx);
  };
  ClipperLib.ClipperOffset.prototype.DoOffset = function (delta)
  {
    this.m_destPolys = new Array();
    this.m_delta = delta;
    //if Zero offset, just copy any CLOSED polygons to m_p and return ...
    if (ClipperLib.ClipperBase.near_zero(delta))
    {
      //this.m_destPolys.set_Capacity(this.m_polyNodes.ChildCount);
      for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)
      {
        var node = this.m_polyNodes.Childs()[i];
        if (node.m_endtype == ClipperLib.EndType.etClosedPolygon)
          this.m_destPolys.push(node.m_polygon);
      }
      return;
    }
    //see offset_triginometry3.svg in the documentation folder ...
    if (this.MiterLimit > 2)
      this.m_miterLim = 2 / (this.MiterLimit * this.MiterLimit);
    else
      this.m_miterLim = 0.5;
    var y;
    if (this.ArcTolerance <= 0)
      y = ClipperLib.ClipperOffset.def_arc_tolerance;
    else if (this.ArcTolerance > Math.abs(delta) * ClipperLib.ClipperOffset.def_arc_tolerance)
      y = Math.abs(delta) * ClipperLib.ClipperOffset.def_arc_tolerance;
    else
      y = this.ArcTolerance;
    //see offset_triginometry2.svg in the documentation folder ...
    var steps = 3.14159265358979 / Math.acos(1 - y / Math.abs(delta));
    this.m_sin = Math.sin(ClipperLib.ClipperOffset.two_pi / steps);
    this.m_cos = Math.cos(ClipperLib.ClipperOffset.two_pi / steps);
    this.m_StepsPerRad = steps / ClipperLib.ClipperOffset.two_pi;
    if (delta < 0)
      this.m_sin = -this.m_sin;
    //this.m_destPolys.set_Capacity(this.m_polyNodes.ChildCount * 2);
    for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)
    {
      var node = this.m_polyNodes.Childs()[i];
      this.m_srcPoly = node.m_polygon;
      var len = this.m_srcPoly.length;
      if (len == 0 || (delta <= 0 && (len < 3 || node.m_endtype != ClipperLib.EndType.etClosedPolygon)))
        continue;
      this.m_destPoly = new Array();
      if (len == 1)
      {
        if (node.m_jointype == ClipperLib.JoinType.jtRound)
        {
          var X = 1,
            Y = 0;
          for (var j = 1; j <= steps; j++)
          {
            this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X + X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y + Y * delta)));
            var X2 = X;
            X = X * this.m_cos - this.m_sin * Y;
            Y = X2 * this.m_sin + Y * this.m_cos;
          }
        }
        else
        {
          var X = -1,
            Y = -1;
          for (var j = 0; j < 4; ++j)
          {
            this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X + X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y + Y * delta)));
            if (X < 0)
              X = 1;
            else if (Y < 0)
              Y = 1;
            else
              X = -1;
          }
        }
        this.m_destPolys.push(this.m_destPoly);
        continue;
      }
      //build m_normals ...
      this.m_normals.length = 0;
      //this.m_normals.set_Capacity(len);
      for (var j = 0; j < len - 1; j++)
        this.m_normals.push(ClipperLib.ClipperOffset.GetUnitNormal(this.m_srcPoly[j], this.m_srcPoly[j + 1]));
      if (node.m_endtype == ClipperLib.EndType.etClosedLine || node.m_endtype == ClipperLib.EndType.etClosedPolygon)
        this.m_normals.push(ClipperLib.ClipperOffset.GetUnitNormal(this.m_srcPoly[len - 1], this.m_srcPoly[0]));
      else
        this.m_normals.push(new ClipperLib.DoublePoint(this.m_normals[len - 2]));
      if (node.m_endtype == ClipperLib.EndType.etClosedPolygon)
      {
        var k = len - 1;
        for (var j = 0; j < len; j++)
          k = this.OffsetPoint(j, k, node.m_jointype);
        this.m_destPolys.push(this.m_destPoly);
      }
      else if (node.m_endtype == ClipperLib.EndType.etClosedLine)
      {
        var k = len - 1;
        for (var j = 0; j < len; j++)
          k = this.OffsetPoint(j, k, node.m_jointype);
        this.m_destPolys.push(this.m_destPoly);
        this.m_destPoly = new Array();
        //re-build m_normals ...
        var n = this.m_normals[len - 1];
        for (var j = len - 1; j > 0; j--)
          this.m_normals[j] = new ClipperLib.DoublePoint(-this.m_normals[j - 1].X, -this.m_normals[j - 1].Y);
        this.m_normals[0] = new ClipperLib.DoublePoint(-n.X, -n.Y);
        k = 0;
        for (var j = len - 1; j >= 0; j--)
          k = this.OffsetPoint(j, k, node.m_jointype);
        this.m_destPolys.push(this.m_destPoly);
      }
      else
      {
        var k = 0;
        for (var j = 1; j < len - 1; ++j)
          k = this.OffsetPoint(j, k, node.m_jointype);
        var pt1;
        if (node.m_endtype == ClipperLib.EndType.etOpenButt)
        {
          var j = len - 1;
          pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[j].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[j].Y * delta));
          this.m_destPoly.push(pt1);
          pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X - this.m_normals[j].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y - this.m_normals[j].Y * delta));
          this.m_destPoly.push(pt1);
        }
        else
        {
          var j = len - 1;
          k = len - 2;
          this.m_sinA = 0;
          this.m_normals[j] = new ClipperLib.DoublePoint(-this.m_normals[j].X, -this.m_normals[j].Y);
          if (node.m_endtype == ClipperLib.EndType.etOpenSquare)
            this.DoSquare(j, k);
          else
            this.DoRound(j, k);
        }
        //re-build m_normals ...
        for (var j = len - 1; j > 0; j--)
          this.m_normals[j] = new ClipperLib.DoublePoint(-this.m_normals[j - 1].X, -this.m_normals[j - 1].Y);
        this.m_normals[0] = new ClipperLib.DoublePoint(-this.m_normals[1].X, -this.m_normals[1].Y);
        k = len - 1;
        for (var j = k - 1; j > 0; --j)
          k = this.OffsetPoint(j, k, node.m_jointype);
        if (node.m_endtype == ClipperLib.EndType.etOpenButt)
        {
          pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X - this.m_normals[0].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y - this.m_normals[0].Y * delta));
          this.m_destPoly.push(pt1);
          pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X + this.m_normals[0].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y + this.m_normals[0].Y * delta));
          this.m_destPoly.push(pt1);
        }
        else
        {
          k = 1;
          this.m_sinA = 0;
          if (node.m_endtype == ClipperLib.EndType.etOpenSquare)
            this.DoSquare(0, 1);
          else
            this.DoRound(0, 1);
        }
        this.m_destPolys.push(this.m_destPoly);
      }
    }
  };
  ClipperLib.ClipperOffset.prototype.Execute = function ()
  {
    var a = arguments,
      ispolytree = a[0] instanceof ClipperLib.PolyTree;
    if (!ispolytree) // function (solution, delta)
    {
      var solution = a[0],
        delta = a[1];
      ClipperLib.Clear(solution);
      this.FixOrientations();
      this.DoOffset(delta);
      //now clean up 'corners' ...
      var clpr = new ClipperLib.Clipper(0);
      clpr.AddPaths(this.m_destPolys, ClipperLib.PolyType.ptSubject, true);
      if (delta > 0)
      {
        clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftPositive, ClipperLib.PolyFillType.pftPositive);
      }
      else
      {
        var r = ClipperLib.Clipper.GetBounds(this.m_destPolys);
        var outer = new ClipperLib.Path();
        outer.push(new ClipperLib.IntPoint(r.left - 10, r.bottom + 10));
        outer.push(new ClipperLib.IntPoint(r.right + 10, r.bottom + 10));
        outer.push(new ClipperLib.IntPoint(r.right + 10, r.top - 10));
        outer.push(new ClipperLib.IntPoint(r.left - 10, r.top - 10));
        clpr.AddPath(outer, ClipperLib.PolyType.ptSubject, true);
        clpr.ReverseSolution = true;
        clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftNegative, ClipperLib.PolyFillType.pftNegative);
        if (solution.length > 0)
          solution.splice(0, 1);
      }
      //console.log(JSON.stringify(solution));
    }
    else // function (polytree, delta)
    {
      var solution = a[0],
        delta = a[1];
      solution.Clear();
      this.FixOrientations();
      this.DoOffset(delta);
      //now clean up 'corners' ...
      var clpr = new ClipperLib.Clipper(0);
      clpr.AddPaths(this.m_destPolys, ClipperLib.PolyType.ptSubject, true);
      if (delta > 0)
      {
        clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftPositive, ClipperLib.PolyFillType.pftPositive);
      }
      else
      {
        var r = ClipperLib.Clipper.GetBounds(this.m_destPolys);
        var outer = new ClipperLib.Path();
        outer.push(new ClipperLib.IntPoint(r.left - 10, r.bottom + 10));
        outer.push(new ClipperLib.IntPoint(r.right + 10, r.bottom + 10));
        outer.push(new ClipperLib.IntPoint(r.right + 10, r.top - 10));
        outer.push(new ClipperLib.IntPoint(r.left - 10, r.top - 10));
        clpr.AddPath(outer, ClipperLib.PolyType.ptSubject, true);
        clpr.ReverseSolution = true;
        clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftNegative, ClipperLib.PolyFillType.pftNegative);
        //remove the outer PolyNode rectangle ...
        if (solution.ChildCount() == 1 && solution.Childs()[0].ChildCount() > 0)
        {
          var outerNode = solution.Childs()[0];
          //solution.Childs.set_Capacity(outerNode.ChildCount);
          solution.Childs()[0] = outerNode.Childs()[0];
          solution.Childs()[0].m_Parent = solution;
          for (var i = 1; i < outerNode.ChildCount(); i++)
            solution.AddChild(outerNode.Childs()[i]);
        }
        else
          solution.Clear();
      }
    }
  };
  ClipperLib.ClipperOffset.prototype.OffsetPoint = function (j, k, jointype)
  {
		//cross product ...
		this.m_sinA = (this.m_normals[k].X * this.m_normals[j].Y - this.m_normals[j].X * this.m_normals[k].Y);

		if (Math.abs(this.m_sinA * this.m_delta) < 1.0)
		{
			//dot product ...
			var cosA = (this.m_normals[k].X * this.m_normals[j].X + this.m_normals[j].Y * this.m_normals[k].Y);
			if (cosA > 0) // angle ==> 0 degrees
			{
				this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[k].X * this.m_delta),
					ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[k].Y * this.m_delta)));
				return k;
			}
			//else angle ==> 180 degrees
		}
    else if (this.m_sinA > 1)
      this.m_sinA = 1.0;
    else if (this.m_sinA < -1)
      this.m_sinA = -1.0;
    if (this.m_sinA * this.m_delta < 0)
    {
      this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[k].X * this.m_delta),
        ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[k].Y * this.m_delta)));
      this.m_destPoly.push(new ClipperLib.IntPoint(this.m_srcPoly[j]));
      this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[j].X * this.m_delta),
        ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[j].Y * this.m_delta)));
    }
    else
      switch (jointype)
      {
      case ClipperLib.JoinType.jtMiter:
        {
          var r = 1 + (this.m_normals[j].X * this.m_normals[k].X + this.m_normals[j].Y * this.m_normals[k].Y);
          if (r >= this.m_miterLim)
            this.DoMiter(j, k, r);
          else
            this.DoSquare(j, k);
          break;
        }
      case ClipperLib.JoinType.jtSquare:
        this.DoSquare(j, k);
        break;
      case ClipperLib.JoinType.jtRound:
        this.DoRound(j, k);
        break;
      }
    k = j;
    return k;
  };
  ClipperLib.ClipperOffset.prototype.DoSquare = function (j, k)
  {
    var dx = Math.tan(Math.atan2(this.m_sinA,
      this.m_normals[k].X * this.m_normals[j].X + this.m_normals[k].Y * this.m_normals[j].Y) / 4);
    this.m_destPoly.push(new ClipperLib.IntPoint(
      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_delta * (this.m_normals[k].X - this.m_normals[k].Y * dx)),
      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_delta * (this.m_normals[k].Y + this.m_normals[k].X * dx))));
    this.m_destPoly.push(new ClipperLib.IntPoint(
      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_delta * (this.m_normals[j].X + this.m_normals[j].Y * dx)),
      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_delta * (this.m_normals[j].Y - this.m_normals[j].X * dx))));
  };
  ClipperLib.ClipperOffset.prototype.DoMiter = function (j, k, r)
  {
    var q = this.m_delta / r;
    this.m_destPoly.push(new ClipperLib.IntPoint(
      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + (this.m_normals[k].X + this.m_normals[j].X) * q),
      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + (this.m_normals[k].Y + this.m_normals[j].Y) * q)));
  };
  ClipperLib.ClipperOffset.prototype.DoRound = function (j, k)
  {
    var a = Math.atan2(this.m_sinA,
      this.m_normals[k].X * this.m_normals[j].X + this.m_normals[k].Y * this.m_normals[j].Y);

    	var steps = Math.max(ClipperLib.Cast_Int32(ClipperLib.ClipperOffset.Round(this.m_StepsPerRad * Math.abs(a))), 1);

    var X = this.m_normals[k].X,
      Y = this.m_normals[k].Y,
      X2;
    for (var i = 0; i < steps; ++i)
    {
      this.m_destPoly.push(new ClipperLib.IntPoint(
        ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + X * this.m_delta),
        ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + Y * this.m_delta)));
      X2 = X;
      X = X * this.m_cos - this.m_sin * Y;
      Y = X2 * this.m_sin + Y * this.m_cos;
    }
    this.m_destPoly.push(new ClipperLib.IntPoint(
      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[j].X * this.m_delta),
      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[j].Y * this.m_delta)));
  };
  ClipperLib.Error = function (message)
  {
    try
    {
      throw new Error(message);
    }
    catch (err)
    {
      alert(err.message);
    }
  };
  // ---------------------------------
  // JS extension by Timo 2013
  ClipperLib.JS = {};
  ClipperLib.JS.AreaOfPolygon = function (poly, scale)
  {
    if (!scale) scale = 1;
    return ClipperLib.Clipper.Area(poly) / (scale * scale);
  };
  ClipperLib.JS.AreaOfPolygons = function (poly, scale)
  {
    if (!scale) scale = 1;
    var area = 0;
    for (var i = 0; i < poly.length; i++)
    {
      area += ClipperLib.Clipper.Area(poly[i]);
    }
    return area / (scale * scale);
  };
  ClipperLib.JS.BoundsOfPath = function (path, scale)
  {
    return ClipperLib.JS.BoundsOfPaths([path], scale);
  };
  ClipperLib.JS.BoundsOfPaths = function (paths, scale)
  {
    if (!scale) scale = 1;
    var bounds = ClipperLib.Clipper.GetBounds(paths);
    bounds.left /= scale;
    bounds.bottom /= scale;
    bounds.right /= scale;
    bounds.top /= scale;
    return bounds;
  };
  // Clean() joins vertices that are too near each other
  // and causes distortion to offsetted polygons without cleaning
  ClipperLib.JS.Clean = function (polygon, delta)
  {
    if (!(polygon instanceof Array)) return [];
    var isPolygons = polygon[0] instanceof Array;
    var polygon = ClipperLib.JS.Clone(polygon);
    if (typeof delta != "number" || delta === null)
    {
      ClipperLib.Error("Delta is not a number in Clean().");
      return polygon;
    }
    if (polygon.length === 0 || (polygon.length == 1 && polygon[0].length === 0) || delta < 0) return polygon;
    if (!isPolygons) polygon = [polygon];
    var k_length = polygon.length;
    var len, poly, result, d, p, j, i;
    var results = [];
    for (var k = 0; k < k_length; k++)
    {
      poly = polygon[k];
      len = poly.length;
      if (len === 0) continue;
      else if (len < 3)
      {
        result = poly;
        results.push(result);
        continue;
      }
      result = poly;
      d = delta * delta;
      //d = Math.floor(c_delta * c_delta);
      p = poly[0];
      j = 1;
      for (i = 1; i < len; i++)
      {
        if ((poly[i].X - p.X) * (poly[i].X - p.X) +
          (poly[i].Y - p.Y) * (poly[i].Y - p.Y) <= d)
          continue;
        result[j] = poly[i];
        p = poly[i];
        j++;
      }
      p = poly[j - 1];
      if ((poly[0].X - p.X) * (poly[0].X - p.X) +
        (poly[0].Y - p.Y) * (poly[0].Y - p.Y) <= d)
        j--;
      if (j < len)
        result.splice(j, len - j);
      if (result.length) results.push(result);
    }
    if (!isPolygons && results.length) results = results[0];
    else if (!isPolygons && results.length === 0) results = [];
    else if (isPolygons && results.length === 0) results = [
      []
    ];
    return results;
  }
  // Make deep copy of Polygons or Polygon
  // so that also IntPoint objects are cloned and not only referenced
  // This should be the fastest way
  ClipperLib.JS.Clone = function (polygon)
  {
    if (!(polygon instanceof Array)) return [];
    if (polygon.length === 0) return [];
    else if (polygon.length == 1 && polygon[0].length === 0) return [[]];
    var isPolygons = polygon[0] instanceof Array;
    if (!isPolygons) polygon = [polygon];
    var len = polygon.length,
      plen, i, j, result;
    var results = new Array(len);
    for (i = 0; i < len; i++)
    {
      plen = polygon[i].length;
      result = new Array(plen);
      for (j = 0; j < plen; j++)
      {
        result[j] = {
          X: polygon[i][j].X,
          Y: polygon[i][j].Y
        };
      }
      results[i] = result;
    }
    if (!isPolygons) results = results[0];
    return results;
  };
  // Removes points that doesn't affect much to the visual appearance.
  // If middle point is at or under certain distance (tolerance) of the line segment between
  // start and end point, the middle point is removed.
  ClipperLib.JS.Lighten = function (polygon, tolerance)
  {
    if (!(polygon instanceof Array)) return [];
    if (typeof tolerance != "number" || tolerance === null)
    {
      ClipperLib.Error("Tolerance is not a number in Lighten().")
      return ClipperLib.JS.Clone(polygon);
    }
    if (polygon.length === 0 || (polygon.length == 1 && polygon[0].length === 0) || tolerance < 0)
    {
      return ClipperLib.JS.Clone(polygon);
    }
    if (!(polygon[0] instanceof Array)) polygon = [polygon];
    var i, j, poly, k, poly2, plen, A, B, P, d, rem, addlast;
    var bxax, byay, l, ax, ay;
    var len = polygon.length;
    var toleranceSq = tolerance * tolerance;
    var results = [];
    for (i = 0; i < len; i++)
    {
      poly = polygon[i];
      plen = poly.length;
      if (plen == 0) continue;
      for (k = 0; k < 1000000; k++) // could be forever loop, but wiser to restrict max repeat count
      {
        poly2 = [];
        plen = poly.length;
        // the first have to added to the end, if first and last are not the same
        // this way we ensure that also the actual last point can be removed if needed
        if (poly[plen - 1].X != poly[0].X || poly[plen - 1].Y != poly[0].Y)
        {
          addlast = 1;
          poly.push(
          {
            X: poly[0].X,
            Y: poly[0].Y
          });
          plen = poly.length;
        }
        else addlast = 0;
        rem = []; // Indexes of removed points
        for (j = 0; j < plen - 2; j++)
        {
          A = poly[j]; // Start point of line segment
          P = poly[j + 1]; // Middle point. This is the one to be removed.
          B = poly[j + 2]; // End point of line segment
          ax = A.X;
          ay = A.Y;
          bxax = B.X - ax;
          byay = B.Y - ay;
          if (bxax !== 0 || byay !== 0) // To avoid Nan, when A==P && P==B. And to avoid peaks (A==B && A!=P), which have lenght, but not area.
          {
            l = ((P.X - ax) * bxax + (P.Y - ay) * byay) / (bxax * bxax + byay * byay);
            if (l > 1)
            {
              ax = B.X;
              ay = B.Y;
            }
            else if (l > 0)
            {
              ax += bxax * l;
              ay += byay * l;
            }
          }
          bxax = P.X - ax;
          byay = P.Y - ay;
          d = bxax * bxax + byay * byay;
          if (d <= toleranceSq)
          {
            rem[j + 1] = 1;
            j++; // when removed, transfer the pointer to the next one
          }
        }
        // add all unremoved points to poly2
        poly2.push(
        {
          X: poly[0].X,
          Y: poly[0].Y
        });
        for (j = 1; j < plen - 1; j++)
          if (!rem[j]) poly2.push(
          {
            X: poly[j].X,
            Y: poly[j].Y
          });
        poly2.push(
        {
          X: poly[plen - 1].X,
          Y: poly[plen - 1].Y
        });
        // if the first point was added to the end, remove it
        if (addlast) poly.pop();
        // break, if there was not anymore removed points
        if (!rem.length) break;
        // else continue looping using poly2, to check if there are points to remove
        else poly = poly2;
      }
      plen = poly2.length;
      // remove duplicate from end, if needed
      if (poly2[plen - 1].X == poly2[0].X && poly2[plen - 1].Y == poly2[0].Y)
      {
        poly2.pop();
      }
      if (poly2.length > 2) // to avoid two-point-polygons
        results.push(poly2);
    }
    if (!(polygon[0] instanceof Array)) results = results[0];
    if (typeof (results) == "undefined") results = [
      []
    ];
    return results;
  }
  ClipperLib.JS.PerimeterOfPath = function (path, closed, scale)
  {
    if (typeof (path) == "undefined") return 0;
    var sqrt = Math.sqrt;
    var perimeter = 0.0;
    var p1, p2, p1x = 0.0,
      p1y = 0.0,
      p2x = 0.0,
      p2y = 0.0;
    var j = path.length;
    if (j < 2) return 0;
    if (closed)
    {
      path[j] = path[0];
      j++;
    }
    while (--j)
    {
      p1 = path[j];
      p1x = p1.X;
      p1y = p1.Y;
      p2 = path[j - 1];
      p2x = p2.X;
      p2y = p2.Y;
      perimeter += sqrt((p1x - p2x) * (p1x - p2x) + (p1y - p2y) * (p1y - p2y));
    }
    if (closed) path.pop();
    return perimeter / scale;
  };
  ClipperLib.JS.PerimeterOfPaths = function (paths, closed, scale)
  {
    if (!scale) scale = 1;
    var perimeter = 0;
    for (var i = 0; i < paths.length; i++)
    {
      perimeter += ClipperLib.JS.PerimeterOfPath(paths[i], closed, scale);
    }
    return perimeter;
  };
  ClipperLib.JS.ScaleDownPath = function (path, scale)
  {
    var i, p;
    if (!scale) scale = 1;
    i = path.length;
    while (i--)
    {
      p = path[i];
      p.X = p.X / scale;
      p.Y = p.Y / scale;
    }
  };
  ClipperLib.JS.ScaleDownPaths = function (paths, scale)
  {
    var i, j, p;
    if (!scale) scale = 1;
    i = paths.length;
    while (i--)
    {
      j = paths[i].length;
      while (j--)
      {
        p = paths[i][j];
        p.X = p.X / scale;
        p.Y = p.Y / scale;
      }
    }
  };
  ClipperLib.JS.ScaleUpPath = function (path, scale)
  {
    var i, p, round = Math.round;
    if (!scale) scale = 1;
    i = path.length;
    while (i--)
    {
      p = path[i];
      p.X = round(p.X * scale);
      p.Y = round(p.Y * scale);
    }
  };
  ClipperLib.JS.ScaleUpPaths = function (paths, scale)
  {
    var i, j, p, round = Math.round;
    if (!scale) scale = 1;
    i = paths.length;
    while (i--)
    {
      j = paths[i].length;
      while (j--)
      {
        p = paths[i][j];
        p.X = round(p.X * scale);
        p.Y = round(p.Y * scale);
      }
    }
  };
  ClipperLib.ExPolygons = function ()
  {
    return [];
  }
  ClipperLib.ExPolygon = function ()
  {
    this.outer = null;
    this.holes = null;
  };
  ClipperLib.JS.AddOuterPolyNodeToExPolygons = function (polynode, expolygons)
  {
    var ep = new ClipperLib.ExPolygon();
    ep.outer = polynode.Contour();
    var childs = polynode.Childs();
    var ilen = childs.length;
    ep.holes = new Array(ilen);
    var node, n, i, j, childs2, jlen;
    for (i = 0; i < ilen; i++)
    {
      node = childs[i];
      ep.holes[i] = node.Contour();
      //Add outer polygons contained by (nested within) holes ...
      for (j = 0, childs2 = node.Childs(), jlen = childs2.length; j < jlen; j++)
      {
        n = childs2[j];
        ClipperLib.JS.AddOuterPolyNodeToExPolygons(n, expolygons);
      }
    }
    expolygons.push(ep);
  };
  ClipperLib.JS.ExPolygonsToPaths = function (expolygons)
  {
    var a, i, alen, ilen;
    var paths = new ClipperLib.Paths();
    for (a = 0, alen = expolygons.length; a < alen; a++)
    {
      paths.push(expolygons[a].outer);
      for (i = 0, ilen = expolygons[a].holes.length; i < ilen; i++)
      {
        paths.push(expolygons[a].holes[i]);
      }
    }
    return paths;
  }
  ClipperLib.JS.PolyTreeToExPolygons = function (polytree)
  {
    var expolygons = new ClipperLib.ExPolygons();
    var node, i, childs, ilen;
    for (i = 0, childs = polytree.Childs(), ilen = childs.length; i < ilen; i++)
    {
      node = childs[i];
      ClipperLib.JS.AddOuterPolyNodeToExPolygons(node, expolygons);
    }
    return expolygons;
  };
})();


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = __webpack_require__(0);

/**
 * @class 3x3 Matrix
 * @name mat3
 */
var mat3 = {};

/**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */
mat3.create = function() {
    var out = new glMatrix.ARRAY_TYPE(9);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
};

/**
 * Copies the upper-left 3x3 values into the given mat3.
 *
 * @param {mat3} out the receiving 3x3 matrix
 * @param {mat4} a   the source 4x4 matrix
 * @returns {mat3} out
 */
mat3.fromMat4 = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[4];
    out[4] = a[5];
    out[5] = a[6];
    out[6] = a[8];
    out[7] = a[9];
    out[8] = a[10];
    return out;
};

/**
 * Creates a new mat3 initialized with values from an existing matrix
 *
 * @param {mat3} a matrix to clone
 * @returns {mat3} a new 3x3 matrix
 */
mat3.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(9);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Copy the values from one mat3 to another
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Create a new mat3 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} A new mat3
 */
mat3.fromValues = function(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
    var out = new glMatrix.ARRAY_TYPE(9);
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m10;
    out[4] = m11;
    out[5] = m12;
    out[6] = m20;
    out[7] = m21;
    out[8] = m22;
    return out;
};

/**
 * Set the components of a mat3 to the given values
 *
 * @param {mat3} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} out
 */
mat3.set = function(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m10;
    out[4] = m11;
    out[5] = m12;
    out[6] = m20;
    out[7] = m21;
    out[8] = m22;
    return out;
};

/**
 * Set a mat3 to the identity matrix
 *
 * @param {mat3} out the receiving matrix
 * @returns {mat3} out
 */
mat3.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
};

/**
 * Transpose the values of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a01 = a[1], a02 = a[2], a12 = a[5];
        out[1] = a[3];
        out[2] = a[6];
        out[3] = a01;
        out[5] = a[7];
        out[6] = a02;
        out[7] = a12;
    } else {
        out[0] = a[0];
        out[1] = a[3];
        out[2] = a[6];
        out[3] = a[1];
        out[4] = a[4];
        out[5] = a[7];
        out[6] = a[2];
        out[7] = a[5];
        out[8] = a[8];
    }
    
    return out;
};

/**
 * Inverts a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.invert = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        b01 = a22 * a11 - a12 * a21,
        b11 = -a22 * a10 + a12 * a20,
        b21 = a21 * a10 - a11 * a20,

        // Calculate the determinant
        det = a00 * b01 + a01 * b11 + a02 * b21;

    if (!det) { 
        return null; 
    }
    det = 1.0 / det;

    out[0] = b01 * det;
    out[1] = (-a22 * a01 + a02 * a21) * det;
    out[2] = (a12 * a01 - a02 * a11) * det;
    out[3] = b11 * det;
    out[4] = (a22 * a00 - a02 * a20) * det;
    out[5] = (-a12 * a00 + a02 * a10) * det;
    out[6] = b21 * det;
    out[7] = (-a21 * a00 + a01 * a20) * det;
    out[8] = (a11 * a00 - a01 * a10) * det;
    return out;
};

/**
 * Calculates the adjugate of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.adjoint = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8];

    out[0] = (a11 * a22 - a12 * a21);
    out[1] = (a02 * a21 - a01 * a22);
    out[2] = (a01 * a12 - a02 * a11);
    out[3] = (a12 * a20 - a10 * a22);
    out[4] = (a00 * a22 - a02 * a20);
    out[5] = (a02 * a10 - a00 * a12);
    out[6] = (a10 * a21 - a11 * a20);
    out[7] = (a01 * a20 - a00 * a21);
    out[8] = (a00 * a11 - a01 * a10);
    return out;
};

/**
 * Calculates the determinant of a mat3
 *
 * @param {mat3} a the source matrix
 * @returns {Number} determinant of a
 */
mat3.determinant = function (a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8];

    return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
};

/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
mat3.multiply = function (out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        b00 = b[0], b01 = b[1], b02 = b[2],
        b10 = b[3], b11 = b[4], b12 = b[5],
        b20 = b[6], b21 = b[7], b22 = b[8];

    out[0] = b00 * a00 + b01 * a10 + b02 * a20;
    out[1] = b00 * a01 + b01 * a11 + b02 * a21;
    out[2] = b00 * a02 + b01 * a12 + b02 * a22;

    out[3] = b10 * a00 + b11 * a10 + b12 * a20;
    out[4] = b10 * a01 + b11 * a11 + b12 * a21;
    out[5] = b10 * a02 + b11 * a12 + b12 * a22;

    out[6] = b20 * a00 + b21 * a10 + b22 * a20;
    out[7] = b20 * a01 + b21 * a11 + b22 * a21;
    out[8] = b20 * a02 + b21 * a12 + b22 * a22;
    return out;
};

/**
 * Alias for {@link mat3.multiply}
 * @function
 */
mat3.mul = mat3.multiply;

/**
 * Translate a mat3 by the given vector
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to translate
 * @param {vec2} v vector to translate by
 * @returns {mat3} out
 */
mat3.translate = function(out, a, v) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],
        x = v[0], y = v[1];

    out[0] = a00;
    out[1] = a01;
    out[2] = a02;

    out[3] = a10;
    out[4] = a11;
    out[5] = a12;

    out[6] = x * a00 + y * a10 + a20;
    out[7] = x * a01 + y * a11 + a21;
    out[8] = x * a02 + y * a12 + a22;
    return out;
};

/**
 * Rotates a mat3 by the given angle
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */
mat3.rotate = function (out, a, rad) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        s = Math.sin(rad),
        c = Math.cos(rad);

    out[0] = c * a00 + s * a10;
    out[1] = c * a01 + s * a11;
    out[2] = c * a02 + s * a12;

    out[3] = c * a10 - s * a00;
    out[4] = c * a11 - s * a01;
    out[5] = c * a12 - s * a02;

    out[6] = a20;
    out[7] = a21;
    out[8] = a22;
    return out;
};

/**
 * Scales the mat3 by the dimensions in the given vec2
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat3} out
 **/
mat3.scale = function(out, a, v) {
    var x = v[0], y = v[1];

    out[0] = x * a[0];
    out[1] = x * a[1];
    out[2] = x * a[2];

    out[3] = y * a[3];
    out[4] = y * a[4];
    out[5] = y * a[5];

    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.translate(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Translation vector
 * @returns {mat3} out
 */
mat3.fromTranslation = function(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = v[0];
    out[7] = v[1];
    out[8] = 1;
    return out;
}

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.rotate(dest, dest, rad);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */
mat3.fromRotation = function(out, rad) {
    var s = Math.sin(rad), c = Math.cos(rad);

    out[0] = c;
    out[1] = s;
    out[2] = 0;

    out[3] = -s;
    out[4] = c;
    out[5] = 0;

    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.scale(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat3} out
 */
mat3.fromScaling = function(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;

    out[3] = 0;
    out[4] = v[1];
    out[5] = 0;

    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
}

/**
 * Copies the values from a mat2d into a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat2d} a the matrix to copy
 * @returns {mat3} out
 **/
mat3.fromMat2d = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = 0;

    out[3] = a[2];
    out[4] = a[3];
    out[5] = 0;

    out[6] = a[4];
    out[7] = a[5];
    out[8] = 1;
    return out;
};

/**
* Calculates a 3x3 matrix from the given quaternion
*
* @param {mat3} out mat3 receiving operation result
* @param {quat} q Quaternion to create matrix from
*
* @returns {mat3} out
*/
mat3.fromQuat = function (out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        yx = y * x2,
        yy = y * y2,
        zx = z * x2,
        zy = z * y2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - yy - zz;
    out[3] = yx - wz;
    out[6] = zx + wy;

    out[1] = yx + wz;
    out[4] = 1 - xx - zz;
    out[7] = zy - wx;

    out[2] = zx - wy;
    out[5] = zy + wx;
    out[8] = 1 - xx - yy;

    return out;
};

/**
* Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
*
* @param {mat3} out mat3 receiving operation result
* @param {mat4} a Mat4 to derive the normal matrix from
*
* @returns {mat3} out
*/
mat3.normalFromMat4 = function (out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        // Calculate the determinant
        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) { 
        return null; 
    }
    det = 1.0 / det;

    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;

    out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;

    out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;

    return out;
};

/**
 * Returns a string representation of a mat3
 *
 * @param {mat3} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat3.str = function (a) {
    return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + 
                    a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + 
                    a[6] + ', ' + a[7] + ', ' + a[8] + ')';
};

/**
 * Returns Frobenius norm of a mat3
 *
 * @param {mat3} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat3.frob = function (a) {
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2)))
};

/**
 * Adds two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
mat3.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    out[6] = a[6] + b[6];
    out[7] = a[7] + b[7];
    out[8] = a[8] + b[8];
    return out;
};

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
mat3.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    out[4] = a[4] - b[4];
    out[5] = a[5] - b[5];
    out[6] = a[6] - b[6];
    out[7] = a[7] - b[7];
    out[8] = a[8] - b[8];
    return out;
};

/**
 * Alias for {@link mat3.subtract}
 * @function
 */
mat3.sub = mat3.subtract;

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat3} out
 */
mat3.multiplyScalar = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    out[6] = a[6] * b;
    out[7] = a[7] * b;
    out[8] = a[8] * b;
    return out;
};

/**
 * Adds two mat3's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat3} out the receiving vector
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat3} out
 */
mat3.multiplyScalarAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    out[3] = a[3] + (b[3] * scale);
    out[4] = a[4] + (b[4] * scale);
    out[5] = a[5] + (b[5] * scale);
    out[6] = a[6] + (b[6] * scale);
    out[7] = a[7] + (b[7] * scale);
    out[8] = a[8] + (b[8] * scale);
    return out;
};

/*
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat3} a The first matrix.
 * @param {mat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat3.exactEquals = function (a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && 
           a[3] === b[3] && a[4] === b[4] && a[5] === b[5] &&
           a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
};

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat3} a The first matrix.
 * @param {mat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat3.equals = function (a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5], a6 = a[6], a7 = a[7], a8 = a[8];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = a[6], b7 = b[7], b8 = b[8];
    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
            Math.abs(a3 - b3) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a3), Math.abs(b3)) &&
            Math.abs(a4 - b4) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a4), Math.abs(b4)) &&
            Math.abs(a5 - b5) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a5), Math.abs(b5)) &&
            Math.abs(a6 - b6) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a6), Math.abs(b6)) &&
            Math.abs(a7 - b7) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a7), Math.abs(b7)) &&
            Math.abs(a8 - b8) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a8), Math.abs(b8)));
};


module.exports = mat3;


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = __webpack_require__(0);

/**
 * @class 3 Dimensional Vector
 * @name vec3
 */
var vec3 = {};

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */
vec3.create = function() {
    var out = new glMatrix.ARRAY_TYPE(3);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    return out;
};

/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {vec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */
vec3.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(3);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
};

/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */
vec3.fromValues = function(x, y, z) {
    var out = new glMatrix.ARRAY_TYPE(3);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
};

/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the source vector
 * @returns {vec3} out
 */
vec3.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
};

/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */
vec3.set = function(out, x, y, z) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
};

/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    return out;
};

/**
 * Alias for {@link vec3.subtract}
 * @function
 */
vec3.sub = vec3.subtract;

/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    return out;
};

/**
 * Alias for {@link vec3.multiply}
 * @function
 */
vec3.mul = vec3.multiply;

/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    return out;
};

/**
 * Alias for {@link vec3.divide}
 * @function
 */
vec3.div = vec3.divide;

/**
 * Math.ceil the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to ceil
 * @returns {vec3} out
 */
vec3.ceil = function (out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    out[2] = Math.ceil(a[2]);
    return out;
};

/**
 * Math.floor the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to floor
 * @returns {vec3} out
 */
vec3.floor = function (out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    out[2] = Math.floor(a[2]);
    return out;
};

/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    return out;
};

/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    return out;
};

/**
 * Math.round the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to round
 * @returns {vec3} out
 */
vec3.round = function (out, a) {
    out[0] = Math.round(a[0]);
    out[1] = Math.round(a[1]);
    out[2] = Math.round(a[2]);
    return out;
};

/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */
vec3.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    return out;
};

/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */
vec3.scaleAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    return out;
};

/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} distance between a and b
 */
vec3.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2];
    return Math.sqrt(x*x + y*y + z*z);
};

/**
 * Alias for {@link vec3.distance}
 * @function
 */
vec3.dist = vec3.distance;

/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec3.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2];
    return x*x + y*y + z*z;
};

/**
 * Alias for {@link vec3.squaredDistance}
 * @function
 */
vec3.sqrDist = vec3.squaredDistance;

/**
 * Calculates the length of a vec3
 *
 * @param {vec3} a vector to calculate length of
 * @returns {Number} length of a
 */
vec3.length = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    return Math.sqrt(x*x + y*y + z*z);
};

/**
 * Alias for {@link vec3.length}
 * @function
 */
vec3.len = vec3.length;

/**
 * Calculates the squared length of a vec3
 *
 * @param {vec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec3.squaredLength = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    return x*x + y*y + z*z;
};

/**
 * Alias for {@link vec3.squaredLength}
 * @function
 */
vec3.sqrLen = vec3.squaredLength;

/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to negate
 * @returns {vec3} out
 */
vec3.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    return out;
};

/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to invert
 * @returns {vec3} out
 */
vec3.inverse = function(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  return out;
};

/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to normalize
 * @returns {vec3} out
 */
vec3.normalize = function(out, a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    var len = x*x + y*y + z*z;
    if (len > 0) {
        //TODO: evaluate use of glm_invsqrt here?
        len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
        out[2] = a[2] * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} dot product of a and b
 */
vec3.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
};

/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.cross = function(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2],
        bx = b[0], by = b[1], bz = b[2];

    out[0] = ay * bz - az * by;
    out[1] = az * bx - ax * bz;
    out[2] = ax * by - ay * bx;
    return out;
};

/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
vec3.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1],
        az = a[2];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    return out;
};

/**
 * Performs a hermite interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
vec3.hermite = function (out, a, b, c, d, t) {
  var factorTimes2 = t * t,
      factor1 = factorTimes2 * (2 * t - 3) + 1,
      factor2 = factorTimes2 * (t - 2) + t,
      factor3 = factorTimes2 * (t - 1),
      factor4 = factorTimes2 * (3 - 2 * t);
  
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  
  return out;
};

/**
 * Performs a bezier interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
vec3.bezier = function (out, a, b, c, d, t) {
  var inverseFactor = 1 - t,
      inverseFactorTimesTwo = inverseFactor * inverseFactor,
      factorTimes2 = t * t,
      factor1 = inverseFactorTimesTwo * inverseFactor,
      factor2 = 3 * t * inverseFactorTimesTwo,
      factor3 = 3 * factorTimes2 * inverseFactor,
      factor4 = factorTimes2 * t;
  
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  
  return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */
vec3.random = function (out, scale) {
    scale = scale || 1.0;

    var r = glMatrix.RANDOM() * 2.0 * Math.PI;
    var z = (glMatrix.RANDOM() * 2.0) - 1.0;
    var zScale = Math.sqrt(1.0-z*z) * scale;

    out[0] = Math.cos(r) * zScale;
    out[1] = Math.sin(r) * zScale;
    out[2] = z * scale;
    return out;
};

/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec3} out
 */
vec3.transformMat4 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2],
        w = m[3] * x + m[7] * y + m[11] * z + m[15];
    w = w || 1.0;
    out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
    out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
    out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
    return out;
};

/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */
vec3.transformMat3 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2];
    out[0] = x * m[0] + y * m[3] + z * m[6];
    out[1] = x * m[1] + y * m[4] + z * m[7];
    out[2] = x * m[2] + y * m[5] + z * m[8];
    return out;
};

/**
 * Transforms the vec3 with a quat
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec3} out
 */
vec3.transformQuat = function(out, a, q) {
    // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations

    var x = a[0], y = a[1], z = a[2],
        qx = q[0], qy = q[1], qz = q[2], qw = q[3],

        // calculate quat * vec
        ix = qw * x + qy * z - qz * y,
        iy = qw * y + qz * x - qx * z,
        iz = qw * z + qx * y - qy * x,
        iw = -qx * x - qy * y - qz * z;

    // calculate result * inverse quat
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return out;
};

/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
vec3.rotateX = function(out, a, b, c){
   var p = [], r=[];
	  //Translate point to the origin
	  p[0] = a[0] - b[0];
	  p[1] = a[1] - b[1];
  	p[2] = a[2] - b[2];

	  //perform rotation
	  r[0] = p[0];
	  r[1] = p[1]*Math.cos(c) - p[2]*Math.sin(c);
	  r[2] = p[1]*Math.sin(c) + p[2]*Math.cos(c);

	  //translate to correct position
	  out[0] = r[0] + b[0];
	  out[1] = r[1] + b[1];
	  out[2] = r[2] + b[2];

  	return out;
};

/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
vec3.rotateY = function(out, a, b, c){
  	var p = [], r=[];
  	//Translate point to the origin
  	p[0] = a[0] - b[0];
  	p[1] = a[1] - b[1];
  	p[2] = a[2] - b[2];
  
  	//perform rotation
  	r[0] = p[2]*Math.sin(c) + p[0]*Math.cos(c);
  	r[1] = p[1];
  	r[2] = p[2]*Math.cos(c) - p[0]*Math.sin(c);
  
  	//translate to correct position
  	out[0] = r[0] + b[0];
  	out[1] = r[1] + b[1];
  	out[2] = r[2] + b[2];
  
  	return out;
};

/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
vec3.rotateZ = function(out, a, b, c){
  	var p = [], r=[];
  	//Translate point to the origin
  	p[0] = a[0] - b[0];
  	p[1] = a[1] - b[1];
  	p[2] = a[2] - b[2];
  
  	//perform rotation
  	r[0] = p[0]*Math.cos(c) - p[1]*Math.sin(c);
  	r[1] = p[0]*Math.sin(c) + p[1]*Math.cos(c);
  	r[2] = p[2];
  
  	//translate to correct position
  	out[0] = r[0] + b[0];
  	out[1] = r[1] + b[1];
  	out[2] = r[2] + b[2];
  
  	return out;
};

/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
vec3.forEach = (function() {
    var vec = vec3.create();

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 3;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2];
        }
        
        return a;
    };
})();

/**
 * Get the angle between two 3D vectors
 * @param {vec3} a The first operand
 * @param {vec3} b The second operand
 * @returns {Number} The angle in radians
 */
vec3.angle = function(a, b) {
   
    var tempA = vec3.fromValues(a[0], a[1], a[2]);
    var tempB = vec3.fromValues(b[0], b[1], b[2]);
 
    vec3.normalize(tempA, tempA);
    vec3.normalize(tempB, tempB);
 
    var cosine = vec3.dot(tempA, tempB);

    if(cosine > 1.0){
        return 0;
    } else {
        return Math.acos(cosine);
    }     
};

/**
 * Returns a string representation of a vector
 *
 * @param {vec3} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec3.str = function (a) {
    return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';
};

/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
vec3.exactEquals = function (a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
};

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
vec3.equals = function (a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2];
    var b0 = b[0], b1 = b[1], b2 = b[2];
    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)));
};

module.exports = vec3;


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = __webpack_require__(0);

/**
 * @class 4 Dimensional Vector
 * @name vec4
 */
var vec4 = {};

/**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */
vec4.create = function() {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    return out;
};

/**
 * Creates a new vec4 initialized with values from an existing vector
 *
 * @param {vec4} a vector to clone
 * @returns {vec4} a new 4D vector
 */
vec4.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Creates a new vec4 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} a new 4D vector
 */
vec4.fromValues = function(x, y, z, w) {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
};

/**
 * Copy the values from one vec4 to another
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the source vector
 * @returns {vec4} out
 */
vec4.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Set the components of a vec4 to the given values
 *
 * @param {vec4} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} out
 */
vec4.set = function(out, x, y, z, w) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
};

/**
 * Adds two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    return out;
};

/**
 * Alias for {@link vec4.subtract}
 * @function
 */
vec4.sub = vec4.subtract;

/**
 * Multiplies two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    out[3] = a[3] * b[3];
    return out;
};

/**
 * Alias for {@link vec4.multiply}
 * @function
 */
vec4.mul = vec4.multiply;

/**
 * Divides two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    out[3] = a[3] / b[3];
    return out;
};

/**
 * Alias for {@link vec4.divide}
 * @function
 */
vec4.div = vec4.divide;

/**
 * Math.ceil the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to ceil
 * @returns {vec4} out
 */
vec4.ceil = function (out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    out[2] = Math.ceil(a[2]);
    out[3] = Math.ceil(a[3]);
    return out;
};

/**
 * Math.floor the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to floor
 * @returns {vec4} out
 */
vec4.floor = function (out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    out[2] = Math.floor(a[2]);
    out[3] = Math.floor(a[3]);
    return out;
};

/**
 * Returns the minimum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    out[3] = Math.min(a[3], b[3]);
    return out;
};

/**
 * Returns the maximum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    out[3] = Math.max(a[3], b[3]);
    return out;
};

/**
 * Math.round the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to round
 * @returns {vec4} out
 */
vec4.round = function (out, a) {
    out[0] = Math.round(a[0]);
    out[1] = Math.round(a[1]);
    out[2] = Math.round(a[2]);
    out[3] = Math.round(a[3]);
    return out;
};

/**
 * Scales a vec4 by a scalar number
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec4} out
 */
vec4.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    return out;
};

/**
 * Adds two vec4's after scaling the second operand by a scalar value
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec4} out
 */
vec4.scaleAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    out[3] = a[3] + (b[3] * scale);
    return out;
};

/**
 * Calculates the euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} distance between a and b
 */
vec4.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2],
        w = b[3] - a[3];
    return Math.sqrt(x*x + y*y + z*z + w*w);
};

/**
 * Alias for {@link vec4.distance}
 * @function
 */
vec4.dist = vec4.distance;

/**
 * Calculates the squared euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec4.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2],
        w = b[3] - a[3];
    return x*x + y*y + z*z + w*w;
};

/**
 * Alias for {@link vec4.squaredDistance}
 * @function
 */
vec4.sqrDist = vec4.squaredDistance;

/**
 * Calculates the length of a vec4
 *
 * @param {vec4} a vector to calculate length of
 * @returns {Number} length of a
 */
vec4.length = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    return Math.sqrt(x*x + y*y + z*z + w*w);
};

/**
 * Alias for {@link vec4.length}
 * @function
 */
vec4.len = vec4.length;

/**
 * Calculates the squared length of a vec4
 *
 * @param {vec4} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec4.squaredLength = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    return x*x + y*y + z*z + w*w;
};

/**
 * Alias for {@link vec4.squaredLength}
 * @function
 */
vec4.sqrLen = vec4.squaredLength;

/**
 * Negates the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to negate
 * @returns {vec4} out
 */
vec4.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = -a[3];
    return out;
};

/**
 * Returns the inverse of the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to invert
 * @returns {vec4} out
 */
vec4.inverse = function(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  out[3] = 1.0 / a[3];
  return out;
};

/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to normalize
 * @returns {vec4} out
 */
vec4.normalize = function(out, a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    var len = x*x + y*y + z*z + w*w;
    if (len > 0) {
        len = 1 / Math.sqrt(len);
        out[0] = x * len;
        out[1] = y * len;
        out[2] = z * len;
        out[3] = w * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} dot product of a and b
 */
vec4.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
};

/**
 * Performs a linear interpolation between two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec4} out
 */
vec4.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1],
        az = a[2],
        aw = a[3];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    out[3] = aw + t * (b[3] - aw);
    return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec4} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec4} out
 */
vec4.random = function (out, scale) {
    scale = scale || 1.0;

    //TODO: This is a pretty awful way of doing this. Find something better.
    out[0] = glMatrix.RANDOM();
    out[1] = glMatrix.RANDOM();
    out[2] = glMatrix.RANDOM();
    out[3] = glMatrix.RANDOM();
    vec4.normalize(out, out);
    vec4.scale(out, out, scale);
    return out;
};

/**
 * Transforms the vec4 with a mat4.
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec4} out
 */
vec4.transformMat4 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2], w = a[3];
    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
    out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
    return out;
};

/**
 * Transforms the vec4 with a quat
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec4} out
 */
vec4.transformQuat = function(out, a, q) {
    var x = a[0], y = a[1], z = a[2],
        qx = q[0], qy = q[1], qz = q[2], qw = q[3],

        // calculate quat * vec
        ix = qw * x + qy * z - qz * y,
        iy = qw * y + qz * x - qx * z,
        iz = qw * z + qx * y - qy * x,
        iw = -qx * x - qy * y - qz * z;

    // calculate result * inverse quat
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    out[3] = a[3];
    return out;
};

/**
 * Perform some operation over an array of vec4s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
vec4.forEach = (function() {
    var vec = vec4.create();

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 4;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2]; vec[3] = a[i+3];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2]; a[i+3] = vec[3];
        }
        
        return a;
    };
})();

/**
 * Returns a string representation of a vector
 *
 * @param {vec4} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec4.str = function (a) {
    return 'vec4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {vec4} a The first vector.
 * @param {vec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
vec4.exactEquals = function (a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
};

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec4} a The first vector.
 * @param {vec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
vec4.equals = function (a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
            Math.abs(a3 - b3) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a3), Math.abs(b3)));
};

module.exports = vec4;


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_LOCAL_MODULE_0__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*** IMPORTS FROM imports-loader ***/
(function() {
var fix = module.exports=0;

// Snap.svg 0.5.0
//
// Copyright (c) 2013 – 2017 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// build: 2017-02-06

// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ┌────────────────────────────────────────────────────────────┐ \\
// │ Eve 0.5.0 - JavaScript Events Library                      │ \\
// ├────────────────────────────────────────────────────────────┤ \\
// │ Author Dmitry Baranovskiy (http://dmitry.baranovskiy.com/) │ \\
// └────────────────────────────────────────────────────────────┘ \\

(function (glob) {
    var version = "0.5.0",
        has = "hasOwnProperty",
        separator = /[\.\/]/,
        comaseparator = /\s*,\s*/,
        wildcard = "*",
        fun = function () {},
        numsort = function (a, b) {
            return a - b;
        },
        current_event,
        stop,
        events = {n: {}},
        firstDefined = function () {
            for (var i = 0, ii = this.length; i < ii; i++) {
                if (typeof this[i] != "undefined") {
                    return this[i];
                }
            }
        },
        lastDefined = function () {
            var i = this.length;
            while (--i) {
                if (typeof this[i] != "undefined") {
                    return this[i];
                }
            }
        },
        objtos = Object.prototype.toString,
        Str = String,
        isArray = Array.isArray || function (ar) {
            return ar instanceof Array || objtos.call(ar) == "[object Array]";
        };
    /*\
     * eve
     [ method ]

     * Fires event with given `name`, given scope and other parameters.

     > Arguments

     - name (string) name of the *event*, dot (`.`) or slash (`/`) separated
     - scope (object) context for the event handlers
     - varargs (...) the rest of arguments will be sent to event handlers

     = (object) array of returned values from the listeners. Array has two methods `.firstDefined()` and `.lastDefined()` to get first or last not `undefined` value.
    \*/
        eve = function (name, scope) {
            var e = events,
                oldstop = stop,
                args = Array.prototype.slice.call(arguments, 2),
                listeners = eve.listeners(name),
                z = 0,
                f = false,
                l,
                indexed = [],
                queue = {},
                out = [],
                ce = current_event,
                errors = [];
            out.firstDefined = firstDefined;
            out.lastDefined = lastDefined;
            current_event = name;
            stop = 0;
            for (var i = 0, ii = listeners.length; i < ii; i++) if ("zIndex" in listeners[i]) {
                indexed.push(listeners[i].zIndex);
                if (listeners[i].zIndex < 0) {
                    queue[listeners[i].zIndex] = listeners[i];
                }
            }
            indexed.sort(numsort);
            while (indexed[z] < 0) {
                l = queue[indexed[z++]];
                out.push(l.apply(scope, args));
                if (stop) {
                    stop = oldstop;
                    return out;
                }
            }
            for (i = 0; i < ii; i++) {
                l = listeners[i];
                if ("zIndex" in l) {
                    if (l.zIndex == indexed[z]) {
                        out.push(l.apply(scope, args));
                        if (stop) {
                            break;
                        }
                        do {
                            z++;
                            l = queue[indexed[z]];
                            l && out.push(l.apply(scope, args));
                            if (stop) {
                                break;
                            }
                        } while (l)
                    } else {
                        queue[l.zIndex] = l;
                    }
                } else {
                    out.push(l.apply(scope, args));
                    if (stop) {
                        break;
                    }
                }
            }
            stop = oldstop;
            current_event = ce;
            return out;
        };
        // Undocumented. Debug only.
        eve._events = events;
    /*\
     * eve.listeners
     [ method ]

     * Internal method which gives you array of all event handlers that will be triggered by the given `name`.

     > Arguments

     - name (string) name of the event, dot (`.`) or slash (`/`) separated

     = (array) array of event handlers
    \*/
    eve.listeners = function (name) {
        var names = isArray(name) ? name : name.split(separator),
            e = events,
            item,
            items,
            k,
            i,
            ii,
            j,
            jj,
            nes,
            es = [e],
            out = [];
        for (i = 0, ii = names.length; i < ii; i++) {
            nes = [];
            for (j = 0, jj = es.length; j < jj; j++) {
                e = es[j].n;
                items = [e[names[i]], e[wildcard]];
                k = 2;
                while (k--) {
                    item = items[k];
                    if (item) {
                        nes.push(item);
                        out = out.concat(item.f || []);
                    }
                }
            }
            es = nes;
        }
        return out;
    };
    /*\
     * eve.separator
     [ method ]

     * If for some reasons you don’t like default separators (`.` or `/`) you can specify yours
     * here. Be aware that if you pass a string longer than one character it will be treated as
     * a list of characters.

     - separator (string) new separator. Empty string resets to default: `.` or `/`.
    \*/
    eve.separator = function (sep) {
        if (sep) {
            sep = Str(sep).replace(/(?=[\.\^\]\[\-])/g, "\\");
            sep = "[" + sep + "]";
            separator = new RegExp(sep);
        } else {
            separator = /[\.\/]/;
        }
    };
    /*\
     * eve.on
     [ method ]
     **
     * Binds given event handler with a given name. You can use wildcards “`*`” for the names:
     | eve.on("*.under.*", f);
     | eve("mouse.under.floor"); // triggers f
     * Use @eve to trigger the listener.
     **
     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
     - f (function) event handler function
     **
     - name (array) if you don’t want to use separators, you can use array of strings
     - f (function) event handler function
     **
     = (function) returned function accepts a single numeric parameter that represents z-index of the handler. It is an optional feature and only used when you need to ensure that some subset of handlers will be invoked in a given order, despite of the order of assignment. 
     > Example:
     | eve.on("mouse", eatIt)(2);
     | eve.on("mouse", scream);
     | eve.on("mouse", catchIt)(1);
     * This will ensure that `catchIt` function will be called before `eatIt`.
     *
     * If you want to put your handler before non-indexed handlers, specify a negative value.
     * Note: I assume most of the time you don’t need to worry about z-index, but it’s nice to have this feature “just in case”.
    \*/
    eve.on = function (name, f) {
        if (typeof f != "function") {
            return function () {};
        }
        var names = isArray(name) ? (isArray(name[0]) ? name : [name]) : Str(name).split(comaseparator);
        for (var i = 0, ii = names.length; i < ii; i++) {
            (function (name) {
                var names = isArray(name) ? name : Str(name).split(separator),
                    e = events,
                    exist;
                for (var i = 0, ii = names.length; i < ii; i++) {
                    e = e.n;
                    e = e.hasOwnProperty(names[i]) && e[names[i]] || (e[names[i]] = {n: {}});
                }
                e.f = e.f || [];
                for (i = 0, ii = e.f.length; i < ii; i++) if (e.f[i] == f) {
                    exist = true;
                    break;
                }
                !exist && e.f.push(f);
            }(names[i]));
        }
        return function (zIndex) {
            if (+zIndex == +zIndex) {
                f.zIndex = +zIndex;
            }
        };
    };
    /*\
     * eve.f
     [ method ]
     **
     * Returns function that will fire given event with optional arguments.
     * Arguments that will be passed to the result function will be also
     * concated to the list of final arguments.
     | el.onclick = eve.f("click", 1, 2);
     | eve.on("click", function (a, b, c) {
     |     console.log(a, b, c); // 1, 2, [event object]
     | });
     > Arguments
     - event (string) event name
     - varargs (…) and any other arguments
     = (function) possible event handler function
    \*/
    eve.f = function (event) {
        var attrs = [].slice.call(arguments, 1);
        return function () {
            eve.apply(null, [event, null].concat(attrs).concat([].slice.call(arguments, 0)));
        };
    };
    /*\
     * eve.stop
     [ method ]
     **
     * Is used inside an event handler to stop the event, preventing any subsequent listeners from firing.
    \*/
    eve.stop = function () {
        stop = 1;
    };
    /*\
     * eve.nt
     [ method ]
     **
     * Could be used inside event handler to figure out actual name of the event.
     **
     > Arguments
     **
     - subname (string) #optional subname of the event
     **
     = (string) name of the event, if `subname` is not specified
     * or
     = (boolean) `true`, if current event’s name contains `subname`
    \*/
    eve.nt = function (subname) {
        var cur = isArray(current_event) ? current_event.join(".") : current_event;
        if (subname) {
            return new RegExp("(?:\\.|\\/|^)" + subname + "(?:\\.|\\/|$)").test(cur);
        }
        return cur;
    };
    /*\
     * eve.nts
     [ method ]
     **
     * Could be used inside event handler to figure out actual name of the event.
     **
     **
     = (array) names of the event
    \*/
    eve.nts = function () {
        return isArray(current_event) ? current_event : current_event.split(separator);
    };
    /*\
     * eve.off
     [ method ]
     **
     * Removes given function from the list of event listeners assigned to given name.
     * If no arguments specified all the events will be cleared.
     **
     > Arguments
     **
     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
     - f (function) event handler function
    \*/
    /*\
     * eve.unbind
     [ method ]
     **
     * See @eve.off
    \*/
    eve.off = eve.unbind = function (name, f) {
        if (!name) {
            eve._events = events = {n: {}};
            return;
        }
        var names = isArray(name) ? (isArray(name[0]) ? name : [name]) : Str(name).split(comaseparator);
        if (names.length > 1) {
            for (var i = 0, ii = names.length; i < ii; i++) {
                eve.off(names[i], f);
            }
            return;
        }
        names = isArray(name) ? name : Str(name).split(separator);
        var e,
            key,
            splice,
            i, ii, j, jj,
            cur = [events],
            inodes = [];
        for (i = 0, ii = names.length; i < ii; i++) {
            for (j = 0; j < cur.length; j += splice.length - 2) {
                splice = [j, 1];
                e = cur[j].n;
                if (names[i] != wildcard) {
                    if (e[names[i]]) {
                        splice.push(e[names[i]]);
                        inodes.unshift({
                            n: e,
                            name: names[i]
                        });
                    }
                } else {
                    for (key in e) if (e[has](key)) {
                        splice.push(e[key]);
                        inodes.unshift({
                            n: e,
                            name: key
                        });
                    }
                }
                cur.splice.apply(cur, splice);
            }
        }
        for (i = 0, ii = cur.length; i < ii; i++) {
            e = cur[i];
            while (e.n) {
                if (f) {
                    if (e.f) {
                        for (j = 0, jj = e.f.length; j < jj; j++) if (e.f[j] == f) {
                            e.f.splice(j, 1);
                            break;
                        }
                        !e.f.length && delete e.f;
                    }
                    for (key in e.n) if (e.n[has](key) && e.n[key].f) {
                        var funcs = e.n[key].f;
                        for (j = 0, jj = funcs.length; j < jj; j++) if (funcs[j] == f) {
                            funcs.splice(j, 1);
                            break;
                        }
                        !funcs.length && delete e.n[key].f;
                    }
                } else {
                    delete e.f;
                    for (key in e.n) if (e.n[has](key) && e.n[key].f) {
                        delete e.n[key].f;
                    }
                }
                e = e.n;
            }
        }
        // prune inner nodes in path
        prune: for (i = 0, ii = inodes.length; i < ii; i++) {
            e = inodes[i];
            for (key in e.n[e.name].f) {
                // not empty (has listeners)
                continue prune;
            }
            for (key in e.n[e.name].n) {
                // not empty (has children)
                continue prune;
            }
            // is empty
            delete e.n[e.name];
        }
    };
    /*\
     * eve.once
     [ method ]
     **
     * Binds given event handler with a given name to only run once then unbind itself.
     | eve.once("login", f);
     | eve("login"); // triggers f
     | eve("login"); // no listeners
     * Use @eve to trigger the listener.
     **
     > Arguments
     **
     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
     - f (function) event handler function
     **
     = (function) same return function as @eve.on
    \*/
    eve.once = function (name, f) {
        var f2 = function () {
            eve.off(name, f2);
            return f.apply(this, arguments);
        };
        return eve.on(name, f2);
    };
    /*\
     * eve.version
     [ property (string) ]
     **
     * Current version of the library.
    \*/
    eve.version = version;
    eve.toString = function () {
        return "You are running Eve " + version;
    };
    (typeof module != "undefined" && module.exports) ? (module.exports = eve) : ( true ? (!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_LOCAL_MODULE_0__ = (function() { return eve; }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)))) : (glob.eve = eve));
})(this);

(function (glob, factory) {
    // AMD support
    if (true) {
        // Define as an anonymous module
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__WEBPACK_LOCAL_MODULE_0__], __WEBPACK_AMD_DEFINE_RESULT__ = function (eve) {
            return factory(glob, eve);
        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else if (typeof exports != "undefined") {
        // Next for Node.js or CommonJS
        var eve = require("eve");
        module.exports = factory(glob, eve);
    } else {
        // Browser globals (glob is window)
        // Snap adds itself to window
        factory(glob, glob.eve);
    }
}(window || this, function (window, eve) {

// Copyright (c) 2017 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var mina = (function (eve) {
    var animations = {},
    requestAnimFrame = window.requestAnimationFrame       ||
                       window.webkitRequestAnimationFrame ||
                       window.mozRequestAnimationFrame    ||
                       window.oRequestAnimationFrame      ||
                       window.msRequestAnimationFrame     ||
                       function (callback) {
                           setTimeout(callback, 16, new Date().getTime());
                           return true;
                       },
    requestID,
    isArray = Array.isArray || function (a) {
        return a instanceof Array ||
            Object.prototype.toString.call(a) == "[object Array]";
    },
    idgen = 0,
    idprefix = "M" + (+new Date).toString(36),
    ID = function () {
        return idprefix + (idgen++).toString(36);
    },
    diff = function (a, b, A, B) {
        if (isArray(a)) {
            res = [];
            for (var i = 0, ii = a.length; i < ii; i++) {
                res[i] = diff(a[i], b, A[i], B);
            }
            return res;
        }
        var dif = (A - a) / (B - b);
        return function (bb) {
            return a + dif * (bb - b);
        };
    },
    timer = Date.now || function () {
        return +new Date;
    },
    sta = function (val) {
        var a = this;
        if (val == null) {
            return a.s;
        }
        var ds = a.s - val;
        a.b += a.dur * ds;
        a.B += a.dur * ds;
        a.s = val;
    },
    speed = function (val) {
        var a = this;
        if (val == null) {
            return a.spd;
        }
        a.spd = val;
    },
    duration = function (val) {
        var a = this;
        if (val == null) {
            return a.dur;
        }
        a.s = a.s * val / a.dur;
        a.dur = val;
    },
    stopit = function () {
        var a = this;
        delete animations[a.id];
        a.update();
        eve("mina.stop." + a.id, a);
    },
    pause = function () {
        var a = this;
        if (a.pdif) {
            return;
        }
        delete animations[a.id];
        a.update();
        a.pdif = a.get() - a.b;
    },
    resume = function () {
        var a = this;
        if (!a.pdif) {
            return;
        }
        a.b = a.get() - a.pdif;
        delete a.pdif;
        animations[a.id] = a;
        frame();
    },
    update = function () {
        var a = this,
            res;
        if (isArray(a.start)) {
            res = [];
            for (var j = 0, jj = a.start.length; j < jj; j++) {
                res[j] = +a.start[j] +
                    (a.end[j] - a.start[j]) * a.easing(a.s);
            }
        } else {
            res = +a.start + (a.end - a.start) * a.easing(a.s);
        }
        a.set(res);
    },
    frame = function (timeStamp) {
        // Manual invokation?
        if (!timeStamp) {
            // Frame loop stopped?
            if (!requestID) {
                // Start frame loop...
                requestID = requestAnimFrame(frame);
            }
            return;
        }
        var len = 0;
        for (var i in animations) if (animations.hasOwnProperty(i)) {
            var a = animations[i],
                b = a.get(),
                res;
            len++;
            a.s = (b - a.b) / (a.dur / a.spd);
            if (a.s >= 1) {
                delete animations[i];
                a.s = 1;
                len--;
                (function (a) {
                    setTimeout(function () {
                        eve("mina.finish." + a.id, a);
                    });
                }(a));
            }
            a.update();
        }
        requestID = len ? requestAnimFrame(frame) : false;
    },
    /*\
     * mina
     [ method ]
     **
     * Generic animation of numbers
     **
     - a (number) start _slave_ number
     - A (number) end _slave_ number
     - b (number) start _master_ number (start time in general case)
     - B (number) end _master_ number (end time in general case)
     - get (function) getter of _master_ number (see @mina.time)
     - set (function) setter of _slave_ number
     - easing (function) #optional easing function, default is @mina.linear
     = (object) animation descriptor
     o {
     o         id (string) animation id,
     o         start (number) start _slave_ number,
     o         end (number) end _slave_ number,
     o         b (number) start _master_ number,
     o         s (number) animation status (0..1),
     o         dur (number) animation duration,
     o         spd (number) animation speed,
     o         get (function) getter of _master_ number (see @mina.time),
     o         set (function) setter of _slave_ number,
     o         easing (function) easing function, default is @mina.linear,
     o         status (function) status getter/setter,
     o         speed (function) speed getter/setter,
     o         duration (function) duration getter/setter,
     o         stop (function) animation stopper
     o         pause (function) pauses the animation
     o         resume (function) resumes the animation
     o         update (function) calles setter with the right value of the animation
     o }
    \*/
    mina = function (a, A, b, B, get, set, easing) {
        var anim = {
            id: ID(),
            start: a,
            end: A,
            b: b,
            s: 0,
            dur: B - b,
            spd: 1,
            get: get,
            set: set,
            easing: easing || mina.linear,
            status: sta,
            speed: speed,
            duration: duration,
            stop: stopit,
            pause: pause,
            resume: resume,
            update: update
        };
        animations[anim.id] = anim;
        var len = 0, i;
        for (i in animations) if (animations.hasOwnProperty(i)) {
            len++;
            if (len == 2) {
                break;
            }
        }
        len == 1 && frame();
        return anim;
    };
    /*\
     * mina.time
     [ method ]
     **
     * Returns the current time. Equivalent to:
     | function () {
     |     return (new Date).getTime();
     | }
    \*/
    mina.time = timer;
    /*\
     * mina.getById
     [ method ]
     **
     * Returns an animation by its id
     - id (string) animation's id
     = (object) See @mina
    \*/
    mina.getById = function (id) {
        return animations[id] || null;
    };

    /*\
     * mina.linear
     [ method ]
     **
     * Default linear easing
     - n (number) input 0..1
     = (number) output 0..1
    \*/
    mina.linear = function (n) {
        return n;
    };
    /*\
     * mina.easeout
     [ method ]
     **
     * Easeout easing
     - n (number) input 0..1
     = (number) output 0..1
    \*/
    mina.easeout = function (n) {
        return Math.pow(n, 1.7);
    };
    /*\
     * mina.easein
     [ method ]
     **
     * Easein easing
     - n (number) input 0..1
     = (number) output 0..1
    \*/
    mina.easein = function (n) {
        return Math.pow(n, .48);
    };
    /*\
     * mina.easeinout
     [ method ]
     **
     * Easeinout easing
     - n (number) input 0..1
     = (number) output 0..1
    \*/
    mina.easeinout = function (n) {
        if (n == 1) {
            return 1;
        }
        if (n == 0) {
            return 0;
        }
        var q = .48 - n / 1.04,
            Q = Math.sqrt(.1734 + q * q),
            x = Q - q,
            X = Math.pow(Math.abs(x), 1 / 3) * (x < 0 ? -1 : 1),
            y = -Q - q,
            Y = Math.pow(Math.abs(y), 1 / 3) * (y < 0 ? -1 : 1),
            t = X + Y + .5;
        return (1 - t) * 3 * t * t + t * t * t;
    };
    /*\
     * mina.backin
     [ method ]
     **
     * Backin easing
     - n (number) input 0..1
     = (number) output 0..1
    \*/
    mina.backin = function (n) {
        if (n == 1) {
            return 1;
        }
        var s = 1.70158;
        return n * n * ((s + 1) * n - s);
    };
    /*\
     * mina.backout
     [ method ]
     **
     * Backout easing
     - n (number) input 0..1
     = (number) output 0..1
    \*/
    mina.backout = function (n) {
        if (n == 0) {
            return 0;
        }
        n = n - 1;
        var s = 1.70158;
        return n * n * ((s + 1) * n + s) + 1;
    };
    /*\
     * mina.elastic
     [ method ]
     **
     * Elastic easing
     - n (number) input 0..1
     = (number) output 0..1
    \*/
    mina.elastic = function (n) {
        if (n == !!n) {
            return n;
        }
        return Math.pow(2, -10 * n) * Math.sin((n - .075) *
            (2 * Math.PI) / .3) + 1;
    };
    /*\
     * mina.bounce
     [ method ]
     **
     * Bounce easing
     - n (number) input 0..1
     = (number) output 0..1
    \*/
    mina.bounce = function (n) {
        var s = 7.5625,
            p = 2.75,
            l;
        if (n < 1 / p) {
            l = s * n * n;
        } else {
            if (n < 2 / p) {
                n -= 1.5 / p;
                l = s * n * n + .75;
            } else {
                if (n < 2.5 / p) {
                    n -= 2.25 / p;
                    l = s * n * n + .9375;
                } else {
                    n -= 2.625 / p;
                    l = s * n * n + .984375;
                }
            }
        }
        return l;
    };
    window.mina = mina;
    return mina;
})(typeof eve == "undefined" ? function () {} : eve);

// Copyright (c) 2013 - 2017 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

var Snap = (function(root) {
Snap.version = "0.5.1";
/*\
 * Snap
 [ method ]
 **
 * Creates a drawing surface or wraps existing SVG element.
 **
 - width (number|string) width of surface
 - height (number|string) height of surface
 * or
 - DOM (SVGElement) element to be wrapped into Snap structure
 * or
 - array (array) array of elements (will return set of elements)
 * or
 - query (string) CSS query selector
 = (object) @Element
\*/
function Snap(w, h) {
    if (w) {
        if (w.nodeType) {
            return wrap(w);
        }
        if (is(w, "array") && Snap.set) {
            return Snap.set.apply(Snap, w);
        }
        if (w instanceof Element) {
            return w;
        }
        if (h == null) {
            // try {
                w = glob.doc.querySelector(String(w));
                return wrap(w);
            // } catch (e) {
                // return null;
            // }
        }
    }
    w = w == null ? "100%" : w;
    h = h == null ? "100%" : h;
    return new Paper(w, h);
}
Snap.toString = function () {
    return "Snap v" + this.version;
};
Snap._ = {};
var glob = {
    win: root.window,
    doc: root.window.document
};
Snap._.glob = glob;
var has = "hasOwnProperty",
    Str = String,
    toFloat = parseFloat,
    toInt = parseInt,
    math = Math,
    mmax = math.max,
    mmin = math.min,
    abs = math.abs,
    pow = math.pow,
    PI = math.PI,
    round = math.round,
    E = "",
    S = " ",
    objectToString = Object.prototype.toString,
    ISURL = /^url\(['"]?([^\)]+?)['"]?\)$/i,
    colourRegExp = /^\s*((#[a-f\d]{6})|(#[a-f\d]{3})|rgba?\(\s*([\d\.]+%?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+%?(?:\s*,\s*[\d\.]+%?)?)\s*\)|hsba?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?%?)\s*\)|hsla?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?%?)\s*\))\s*$/i,
    bezierrg = /^(?:cubic-)?bezier\(([^,]+),([^,]+),([^,]+),([^\)]+)\)/,
    separator = Snap._.separator = /[,\s]+/,
    whitespace = /[\s]/g,
    commaSpaces = /[\s]*,[\s]*/,
    hsrg = {hs: 1, rg: 1},
    pathCommand = /([a-z])[\s,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\s]*,?[\s]*)+)/ig,
    tCommand = /([rstm])[\s,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\s]*,?[\s]*)+)/ig,
    pathValues = /(-?\d*\.?\d*(?:e[\-+]?\d+)?)[\s]*,?[\s]*/ig,
    idgen = 0,
    idprefix = "S" + (+new Date).toString(36),
    ID = function (el) {
        return (el && el.type ? el.type : E) + idprefix + (idgen++).toString(36);
    },
    xlink = "http://www.w3.org/1999/xlink",
    xmlns = "http://www.w3.org/2000/svg",
    hub = {},
    /*\
     * Snap.url
     [ method ]
     **
     * Wraps path into `"url('<path>')"`.
     - value (string) path
     = (string) wrapped path
    \*/
    URL = Snap.url = function (url) {
        return "url('#" + url + "')";
    };

function $(el, attr) {
    if (attr) {
        if (el == "#text") {
            el = glob.doc.createTextNode(attr.text || attr["#text"] || "");
        }
        if (el == "#comment") {
            el = glob.doc.createComment(attr.text || attr["#text"] || "");
        }
        if (typeof el == "string") {
            el = $(el);
        }
        if (typeof attr == "string") {
            if (el.nodeType == 1) {
                if (attr.substring(0, 6) == "xlink:") {
                    return el.getAttributeNS(xlink, attr.substring(6));
                }
                if (attr.substring(0, 4) == "xml:") {
                    return el.getAttributeNS(xmlns, attr.substring(4));
                }
                return el.getAttribute(attr);
            } else if (attr == "text") {
                return el.nodeValue;
            } else {
                return null;
            }
        }
        if (el.nodeType == 1) {
            for (var key in attr) if (attr[has](key)) {
                var val = Str(attr[key]);
                if (val) {
                    if (key.substring(0, 6) == "xlink:") {
                        el.setAttributeNS(xlink, key.substring(6), val);
                    } else if (key.substring(0, 4) == "xml:") {
                        el.setAttributeNS(xmlns, key.substring(4), val);
                    } else {
                        el.setAttribute(key, val);
                    }
                } else {
                    el.removeAttribute(key);
                }
            }
        } else if ("text" in attr) {
            el.nodeValue = attr.text;
        }
    } else {
        el = glob.doc.createElementNS(xmlns, el);
    }
    return el;
}
Snap._.$ = $;
Snap._.id = ID;
function getAttrs(el) {
    var attrs = el.attributes,
        name,
        out = {};
    for (var i = 0; i < attrs.length; i++) {
        if (attrs[i].namespaceURI == xlink) {
            name = "xlink:";
        } else {
            name = "";
        }
        name += attrs[i].name;
        out[name] = attrs[i].textContent;
    }
    return out;
}
function is(o, type) {
    type = Str.prototype.toLowerCase.call(type);
    if (type == "finite") {
        return isFinite(o);
    }
    if (type == "array" &&
        (o instanceof Array || Array.isArray && Array.isArray(o))) {
        return true;
    }
    return  type == "null" && o === null ||
            type == typeof o && o !== null ||
            type == "object" && o === Object(o) ||
            objectToString.call(o).slice(8, -1).toLowerCase() == type;
}
/*\
 * Snap.format
 [ method ]
 **
 * Replaces construction of type `{<name>}` to the corresponding argument
 **
 - token (string) string to format
 - json (object) object which properties are used as a replacement
 = (string) formatted string
 > Usage
 | // this draws a rectangular shape equivalent to "M10,20h40v50h-40z"
 | paper.path(Snap.format("M{x},{y}h{dim.width}v{dim.height}h{dim['negative width']}z", {
 |     x: 10,
 |     y: 20,
 |     dim: {
 |         width: 40,
 |         height: 50,
 |         "negative width": -40
 |     }
 | }));
\*/
Snap.format = (function () {
    var tokenRegex = /\{([^\}]+)\}/g,
        objNotationRegex = /(?:(?:^|\.)(.+?)(?=\[|\.|$|\()|\[('|")(.+?)\2\])(\(\))?/g, // matches .xxxxx or ["xxxxx"] to run over object properties
        replacer = function (all, key, obj) {
            var res = obj;
            key.replace(objNotationRegex, function (all, name, quote, quotedName, isFunc) {
                name = name || quotedName;
                if (res) {
                    if (name in res) {
                        res = res[name];
                    }
                    typeof res == "function" && isFunc && (res = res());
                }
            });
            res = (res == null || res == obj ? all : res) + "";
            return res;
        };
    return function (str, obj) {
        return Str(str).replace(tokenRegex, function (all, key) {
            return replacer(all, key, obj);
        });
    };
})();
function clone(obj) {
    if (typeof obj == "function" || Object(obj) !== obj) {
        return obj;
    }
    var res = new obj.constructor;
    for (var key in obj) if (obj[has](key)) {
        res[key] = clone(obj[key]);
    }
    return res;
}
Snap._.clone = clone;
function repush(array, item) {
    for (var i = 0, ii = array.length; i < ii; i++) if (array[i] === item) {
        return array.push(array.splice(i, 1)[0]);
    }
}
function cacher(f, scope, postprocessor) {
    function newf() {
        var arg = Array.prototype.slice.call(arguments, 0),
            args = arg.join("\u2400"),
            cache = newf.cache = newf.cache || {},
            count = newf.count = newf.count || [];
        if (cache[has](args)) {
            repush(count, args);
            return postprocessor ? postprocessor(cache[args]) : cache[args];
        }
        count.length >= 1e3 && delete cache[count.shift()];
        count.push(args);
        cache[args] = f.apply(scope, arg);
        return postprocessor ? postprocessor(cache[args]) : cache[args];
    }
    return newf;
}
Snap._.cacher = cacher;
function angle(x1, y1, x2, y2, x3, y3) {
    if (x3 == null) {
        var x = x1 - x2,
            y = y1 - y2;
        if (!x && !y) {
            return 0;
        }
        return (180 + math.atan2(-y, -x) * 180 / PI + 360) % 360;
    } else {
        return angle(x1, y1, x3, y3) - angle(x2, y2, x3, y3);
    }
}
function rad(deg) {
    return deg % 360 * PI / 180;
}
function deg(rad) {
    return rad * 180 / PI % 360;
}
function x_y() {
    return this.x + S + this.y;
}
function x_y_w_h() {
    return this.x + S + this.y + S + this.width + " \xd7 " + this.height;
}

/*\
 * Snap.rad
 [ method ]
 **
 * Transform angle to radians
 - deg (number) angle in degrees
 = (number) angle in radians
\*/
Snap.rad = rad;
/*\
 * Snap.deg
 [ method ]
 **
 * Transform angle to degrees
 - rad (number) angle in radians
 = (number) angle in degrees
\*/
Snap.deg = deg;
/*\
 * Snap.sin
 [ method ]
 **
 * Equivalent to `Math.sin()` only works with degrees, not radians.
 - angle (number) angle in degrees
 = (number) sin
\*/
Snap.sin = function (angle) {
    return math.sin(Snap.rad(angle));
};
/*\
 * Snap.tan
 [ method ]
 **
 * Equivalent to `Math.tan()` only works with degrees, not radians.
 - angle (number) angle in degrees
 = (number) tan
\*/
Snap.tan = function (angle) {
    return math.tan(Snap.rad(angle));
};
/*\
 * Snap.cos
 [ method ]
 **
 * Equivalent to `Math.cos()` only works with degrees, not radians.
 - angle (number) angle in degrees
 = (number) cos
\*/
Snap.cos = function (angle) {
    return math.cos(Snap.rad(angle));
};
/*\
 * Snap.asin
 [ method ]
 **
 * Equivalent to `Math.asin()` only works with degrees, not radians.
 - num (number) value
 = (number) asin in degrees
\*/
Snap.asin = function (num) {
    return Snap.deg(math.asin(num));
};
/*\
 * Snap.acos
 [ method ]
 **
 * Equivalent to `Math.acos()` only works with degrees, not radians.
 - num (number) value
 = (number) acos in degrees
\*/
Snap.acos = function (num) {
    return Snap.deg(math.acos(num));
};
/*\
 * Snap.atan
 [ method ]
 **
 * Equivalent to `Math.atan()` only works with degrees, not radians.
 - num (number) value
 = (number) atan in degrees
\*/
Snap.atan = function (num) {
    return Snap.deg(math.atan(num));
};
/*\
 * Snap.atan2
 [ method ]
 **
 * Equivalent to `Math.atan2()` only works with degrees, not radians.
 - num (number) value
 = (number) atan2 in degrees
\*/
Snap.atan2 = function (num) {
    return Snap.deg(math.atan2(num));
};
/*\
 * Snap.angle
 [ method ]
 **
 * Returns an angle between two or three points
 - x1 (number) x coord of first point
 - y1 (number) y coord of first point
 - x2 (number) x coord of second point
 - y2 (number) y coord of second point
 - x3 (number) #optional x coord of third point
 - y3 (number) #optional y coord of third point
 = (number) angle in degrees
\*/
Snap.angle = angle;
/*\
 * Snap.len
 [ method ]
 **
 * Returns distance between two points
 - x1 (number) x coord of first point
 - y1 (number) y coord of first point
 - x2 (number) x coord of second point
 - y2 (number) y coord of second point
 = (number) distance
\*/
Snap.len = function (x1, y1, x2, y2) {
    return Math.sqrt(Snap.len2(x1, y1, x2, y2));
};
/*\
 * Snap.len2
 [ method ]
 **
 * Returns squared distance between two points
 - x1 (number) x coord of first point
 - y1 (number) y coord of first point
 - x2 (number) x coord of second point
 - y2 (number) y coord of second point
 = (number) distance
\*/
Snap.len2 = function (x1, y1, x2, y2) {
    return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);
};
/*\
 * Snap.closestPoint
 [ method ]
 **
 * Returns closest point to a given one on a given path.
 - path (Element) path element
 - x (number) x coord of a point
 - y (number) y coord of a point
 = (object) in format
 {
    x (number) x coord of the point on the path
    y (number) y coord of the point on the path
    length (number) length of the path to the point
    distance (number) distance from the given point to the path
 }
\*/
// Copied from http://bl.ocks.org/mbostock/8027637
Snap.closestPoint = function (path, x, y) {
    function distance2(p) {
        var dx = p.x - x,
            dy = p.y - y;
        return dx * dx + dy * dy;
    }
    var pathNode = path.node,
        pathLength = pathNode.getTotalLength(),
        precision = pathLength / pathNode.pathSegList.numberOfItems * .125,
        best,
        bestLength,
        bestDistance = Infinity;

    // linear scan for coarse approximation
    for (var scan, scanLength = 0, scanDistance; scanLength <= pathLength; scanLength += precision) {
        if ((scanDistance = distance2(scan = pathNode.getPointAtLength(scanLength))) < bestDistance) {
            best = scan;
            bestLength = scanLength;
            bestDistance = scanDistance;
        }
    }

    // binary search for precise estimate
    precision *= .5;
    while (precision > .5) {
        var before,
            after,
            beforeLength,
            afterLength,
            beforeDistance,
            afterDistance;
        if ((beforeLength = bestLength - precision) >= 0 && (beforeDistance = distance2(before = pathNode.getPointAtLength(beforeLength))) < bestDistance) {
            best = before;
            bestLength = beforeLength;
            bestDistance = beforeDistance;
        } else if ((afterLength = bestLength + precision) <= pathLength && (afterDistance = distance2(after = pathNode.getPointAtLength(afterLength))) < bestDistance) {
            best = after;
            bestLength = afterLength;
            bestDistance = afterDistance;
        } else {
            precision *= .5;
        }
    }

    best = {
        x: best.x,
        y: best.y,
        length: bestLength,
        distance: Math.sqrt(bestDistance)
    };
    return best;
}
/*\
 * Snap.is
 [ method ]
 **
 * Handy replacement for the `typeof` operator
 - o (…) any object or primitive
 - type (string) name of the type, e.g., `string`, `function`, `number`, etc.
 = (boolean) `true` if given value is of given type
\*/
Snap.is = is;
/*\
 * Snap.snapTo
 [ method ]
 **
 * Snaps given value to given grid
 - values (array|number) given array of values or step of the grid
 - value (number) value to adjust
 - tolerance (number) #optional maximum distance to the target value that would trigger the snap. Default is `10`.
 = (number) adjusted value
\*/
Snap.snapTo = function (values, value, tolerance) {
    tolerance = is(tolerance, "finite") ? tolerance : 10;
    if (is(values, "array")) {
        var i = values.length;
        while (i--) if (abs(values[i] - value) <= tolerance) {
            return values[i];
        }
    } else {
        values = +values;
        var rem = value % values;
        if (rem < tolerance) {
            return value - rem;
        }
        if (rem > values - tolerance) {
            return value - rem + values;
        }
    }
    return value;
};
// Colour
/*\
 * Snap.getRGB
 [ method ]
 **
 * Parses color string as RGB object
 - color (string) color string in one of the following formats:
 # <ul>
 #     <li>Color name (<code>red</code>, <code>green</code>, <code>cornflowerblue</code>, etc)</li>
 #     <li>#••• — shortened HTML color: (<code>#000</code>, <code>#fc0</code>, etc.)</li>
 #     <li>#•••••• — full length HTML color: (<code>#000000</code>, <code>#bd2300</code>)</li>
 #     <li>rgb(•••, •••, •••) — red, green and blue channels values: (<code>rgb(200,&nbsp;100,&nbsp;0)</code>)</li>
 #     <li>rgba(•••, •••, •••, •••) — also with opacity</li>
 #     <li>rgb(•••%, •••%, •••%) — same as above, but in %: (<code>rgb(100%,&nbsp;175%,&nbsp;0%)</code>)</li>
 #     <li>rgba(•••%, •••%, •••%, •••%) — also with opacity</li>
 #     <li>hsb(•••, •••, •••) — hue, saturation and brightness values: (<code>hsb(0.5,&nbsp;0.25,&nbsp;1)</code>)</li>
 #     <li>hsba(•••, •••, •••, •••) — also with opacity</li>
 #     <li>hsb(•••%, •••%, •••%) — same as above, but in %</li>
 #     <li>hsba(•••%, •••%, •••%, •••%) — also with opacity</li>
 #     <li>hsl(•••, •••, •••) — hue, saturation and luminosity values: (<code>hsb(0.5,&nbsp;0.25,&nbsp;0.5)</code>)</li>
 #     <li>hsla(•••, •••, •••, •••) — also with opacity</li>
 #     <li>hsl(•••%, •••%, •••%) — same as above, but in %</li>
 #     <li>hsla(•••%, •••%, •••%, •••%) — also with opacity</li>
 # </ul>
 * Note that `%` can be used any time: `rgb(20%, 255, 50%)`.
 = (object) RGB object in the following format:
 o {
 o     r (number) red,
 o     g (number) green,
 o     b (number) blue,
 o     hex (string) color in HTML/CSS format: #••••••,
 o     error (boolean) true if string can't be parsed
 o }
\*/
Snap.getRGB = cacher(function (colour) {
    if (!colour || !!((colour = Str(colour)).indexOf("-") + 1)) {
        return {r: -1, g: -1, b: -1, hex: "none", error: 1, toString: rgbtoString};
    }
    if (colour == "none") {
        return {r: -1, g: -1, b: -1, hex: "none", toString: rgbtoString};
    }
    !(hsrg[has](colour.toLowerCase().substring(0, 2)) || colour.charAt() == "#") && (colour = toHex(colour));
    if (!colour) {
        return {r: -1, g: -1, b: -1, hex: "none", error: 1, toString: rgbtoString};
    }
    var res,
        red,
        green,
        blue,
        opacity,
        t,
        values,
        rgb = colour.match(colourRegExp);
    if (rgb) {
        if (rgb[2]) {
            blue = toInt(rgb[2].substring(5), 16);
            green = toInt(rgb[2].substring(3, 5), 16);
            red = toInt(rgb[2].substring(1, 3), 16);
        }
        if (rgb[3]) {
            blue = toInt((t = rgb[3].charAt(3)) + t, 16);
            green = toInt((t = rgb[3].charAt(2)) + t, 16);
            red = toInt((t = rgb[3].charAt(1)) + t, 16);
        }
        if (rgb[4]) {
            values = rgb[4].split(commaSpaces);
            red = toFloat(values[0]);
            values[0].slice(-1) == "%" && (red *= 2.55);
            green = toFloat(values[1]);
            values[1].slice(-1) == "%" && (green *= 2.55);
            blue = toFloat(values[2]);
            values[2].slice(-1) == "%" && (blue *= 2.55);
            rgb[1].toLowerCase().slice(0, 4) == "rgba" && (opacity = toFloat(values[3]));
            values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
        }
        if (rgb[5]) {
            values = rgb[5].split(commaSpaces);
            red = toFloat(values[0]);
            values[0].slice(-1) == "%" && (red /= 100);
            green = toFloat(values[1]);
            values[1].slice(-1) == "%" && (green /= 100);
            blue = toFloat(values[2]);
            values[2].slice(-1) == "%" && (blue /= 100);
            (values[0].slice(-3) == "deg" || values[0].slice(-1) == "\xb0") && (red /= 360);
            rgb[1].toLowerCase().slice(0, 4) == "hsba" && (opacity = toFloat(values[3]));
            values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
            return Snap.hsb2rgb(red, green, blue, opacity);
        }
        if (rgb[6]) {
            values = rgb[6].split(commaSpaces);
            red = toFloat(values[0]);
            values[0].slice(-1) == "%" && (red /= 100);
            green = toFloat(values[1]);
            values[1].slice(-1) == "%" && (green /= 100);
            blue = toFloat(values[2]);
            values[2].slice(-1) == "%" && (blue /= 100);
            (values[0].slice(-3) == "deg" || values[0].slice(-1) == "\xb0") && (red /= 360);
            rgb[1].toLowerCase().slice(0, 4) == "hsla" && (opacity = toFloat(values[3]));
            values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
            return Snap.hsl2rgb(red, green, blue, opacity);
        }
        red = mmin(math.round(red), 255);
        green = mmin(math.round(green), 255);
        blue = mmin(math.round(blue), 255);
        opacity = mmin(mmax(opacity, 0), 1);
        rgb = {r: red, g: green, b: blue, toString: rgbtoString};
        rgb.hex = "#" + (16777216 | blue | green << 8 | red << 16).toString(16).slice(1);
        rgb.opacity = is(opacity, "finite") ? opacity : 1;
        return rgb;
    }
    return {r: -1, g: -1, b: -1, hex: "none", error: 1, toString: rgbtoString};
}, Snap);
/*\
 * Snap.hsb
 [ method ]
 **
 * Converts HSB values to a hex representation of the color
 - h (number) hue
 - s (number) saturation
 - b (number) value or brightness
 = (string) hex representation of the color
\*/
Snap.hsb = cacher(function (h, s, b) {
    return Snap.hsb2rgb(h, s, b).hex;
});
/*\
 * Snap.hsl
 [ method ]
 **
 * Converts HSL values to a hex representation of the color
 - h (number) hue
 - s (number) saturation
 - l (number) luminosity
 = (string) hex representation of the color
\*/
Snap.hsl = cacher(function (h, s, l) {
    return Snap.hsl2rgb(h, s, l).hex;
});
/*\
 * Snap.rgb
 [ method ]
 **
 * Converts RGB values to a hex representation of the color
 - r (number) red
 - g (number) green
 - b (number) blue
 = (string) hex representation of the color
\*/
Snap.rgb = cacher(function (r, g, b, o) {
    if (is(o, "finite")) {
        var round = math.round;
        return "rgba(" + [round(r), round(g), round(b), +o.toFixed(2)] + ")";
    }
    return "#" + (16777216 | b | g << 8 | r << 16).toString(16).slice(1);
});
var toHex = function (color) {
    var i = glob.doc.getElementsByTagName("head")[0] || glob.doc.getElementsByTagName("svg")[0],
        red = "rgb(255, 0, 0)";
    toHex = cacher(function (color) {
        if (color.toLowerCase() == "red") {
            return red;
        }
        i.style.color = red;
        i.style.color = color;
        var out = glob.doc.defaultView.getComputedStyle(i, E).getPropertyValue("color");
        return out == red ? null : out;
    });
    return toHex(color);
},
hsbtoString = function () {
    return "hsb(" + [this.h, this.s, this.b] + ")";
},
hsltoString = function () {
    return "hsl(" + [this.h, this.s, this.l] + ")";
},
rgbtoString = function () {
    return this.opacity == 1 || this.opacity == null ?
            this.hex :
            "rgba(" + [this.r, this.g, this.b, this.opacity] + ")";
},
prepareRGB = function (r, g, b) {
    if (g == null && is(r, "object") && "r" in r && "g" in r && "b" in r) {
        b = r.b;
        g = r.g;
        r = r.r;
    }
    if (g == null && is(r, string)) {
        var clr = Snap.getRGB(r);
        r = clr.r;
        g = clr.g;
        b = clr.b;
    }
    if (r > 1 || g > 1 || b > 1) {
        r /= 255;
        g /= 255;
        b /= 255;
    }

    return [r, g, b];
},
packageRGB = function (r, g, b, o) {
    r = math.round(r * 255);
    g = math.round(g * 255);
    b = math.round(b * 255);
    var rgb = {
        r: r,
        g: g,
        b: b,
        opacity: is(o, "finite") ? o : 1,
        hex: Snap.rgb(r, g, b),
        toString: rgbtoString
    };
    is(o, "finite") && (rgb.opacity = o);
    return rgb;
};
/*\
 * Snap.color
 [ method ]
 **
 * Parses the color string and returns an object featuring the color's component values
 - clr (string) color string in one of the supported formats (see @Snap.getRGB)
 = (object) Combined RGB/HSB object in the following format:
 o {
 o     r (number) red,
 o     g (number) green,
 o     b (number) blue,
 o     hex (string) color in HTML/CSS format: #••••••,
 o     error (boolean) `true` if string can't be parsed,
 o     h (number) hue,
 o     s (number) saturation,
 o     v (number) value (brightness),
 o     l (number) lightness
 o }
\*/
Snap.color = function (clr) {
    var rgb;
    if (is(clr, "object") && "h" in clr && "s" in clr && "b" in clr) {
        rgb = Snap.hsb2rgb(clr);
        clr.r = rgb.r;
        clr.g = rgb.g;
        clr.b = rgb.b;
        clr.opacity = 1;
        clr.hex = rgb.hex;
    } else if (is(clr, "object") && "h" in clr && "s" in clr && "l" in clr) {
        rgb = Snap.hsl2rgb(clr);
        clr.r = rgb.r;
        clr.g = rgb.g;
        clr.b = rgb.b;
        clr.opacity = 1;
        clr.hex = rgb.hex;
    } else {
        if (is(clr, "string")) {
            clr = Snap.getRGB(clr);
        }
        if (is(clr, "object") && "r" in clr && "g" in clr && "b" in clr && !("error" in clr)) {
            rgb = Snap.rgb2hsl(clr);
            clr.h = rgb.h;
            clr.s = rgb.s;
            clr.l = rgb.l;
            rgb = Snap.rgb2hsb(clr);
            clr.v = rgb.b;
        } else {
            clr = {hex: "none"};
            clr.r = clr.g = clr.b = clr.h = clr.s = clr.v = clr.l = -1;
            clr.error = 1;
        }
    }
    clr.toString = rgbtoString;
    return clr;
};
/*\
 * Snap.hsb2rgb
 [ method ]
 **
 * Converts HSB values to an RGB object
 - h (number) hue
 - s (number) saturation
 - v (number) value or brightness
 = (object) RGB object in the following format:
 o {
 o     r (number) red,
 o     g (number) green,
 o     b (number) blue,
 o     hex (string) color in HTML/CSS format: #••••••
 o }
\*/
Snap.hsb2rgb = function (h, s, v, o) {
    if (is(h, "object") && "h" in h && "s" in h && "b" in h) {
        v = h.b;
        s = h.s;
        o = h.o;
        h = h.h;
    }
    h *= 360;
    var R, G, B, X, C;
    h = h % 360 / 60;
    C = v * s;
    X = C * (1 - abs(h % 2 - 1));
    R = G = B = v - C;

    h = ~~h;
    R += [C, X, 0, 0, X, C][h];
    G += [X, C, C, X, 0, 0][h];
    B += [0, 0, X, C, C, X][h];
    return packageRGB(R, G, B, o);
};
/*\
 * Snap.hsl2rgb
 [ method ]
 **
 * Converts HSL values to an RGB object
 - h (number) hue
 - s (number) saturation
 - l (number) luminosity
 = (object) RGB object in the following format:
 o {
 o     r (number) red,
 o     g (number) green,
 o     b (number) blue,
 o     hex (string) color in HTML/CSS format: #••••••
 o }
\*/
Snap.hsl2rgb = function (h, s, l, o) {
    if (is(h, "object") && "h" in h && "s" in h && "l" in h) {
        l = h.l;
        s = h.s;
        h = h.h;
    }
    if (h > 1 || s > 1 || l > 1) {
        h /= 360;
        s /= 100;
        l /= 100;
    }
    h *= 360;
    var R, G, B, X, C;
    h = h % 360 / 60;
    C = 2 * s * (l < .5 ? l : 1 - l);
    X = C * (1 - abs(h % 2 - 1));
    R = G = B = l - C / 2;

    h = ~~h;
    R += [C, X, 0, 0, X, C][h];
    G += [X, C, C, X, 0, 0][h];
    B += [0, 0, X, C, C, X][h];
    return packageRGB(R, G, B, o);
};
/*\
 * Snap.rgb2hsb
 [ method ]
 **
 * Converts RGB values to an HSB object
 - r (number) red
 - g (number) green
 - b (number) blue
 = (object) HSB object in the following format:
 o {
 o     h (number) hue,
 o     s (number) saturation,
 o     b (number) brightness
 o }
\*/
Snap.rgb2hsb = function (r, g, b) {
    b = prepareRGB(r, g, b);
    r = b[0];
    g = b[1];
    b = b[2];

    var H, S, V, C;
    V = mmax(r, g, b);
    C = V - mmin(r, g, b);
    H = C == 0 ? null :
        V == r ? (g - b) / C :
        V == g ? (b - r) / C + 2 :
                 (r - g) / C + 4;
    H = (H + 360) % 6 * 60 / 360;
    S = C == 0 ? 0 : C / V;
    return {h: H, s: S, b: V, toString: hsbtoString};
};
/*\
 * Snap.rgb2hsl
 [ method ]
 **
 * Converts RGB values to an HSL object
 - r (number) red
 - g (number) green
 - b (number) blue
 = (object) HSL object in the following format:
 o {
 o     h (number) hue,
 o     s (number) saturation,
 o     l (number) luminosity
 o }
\*/
Snap.rgb2hsl = function (r, g, b) {
    b = prepareRGB(r, g, b);
    r = b[0];
    g = b[1];
    b = b[2];

    var H, S, L, M, m, C;
    M = mmax(r, g, b);
    m = mmin(r, g, b);
    C = M - m;
    H = C == 0 ? null :
        M == r ? (g - b) / C :
        M == g ? (b - r) / C + 2 :
                 (r - g) / C + 4;
    H = (H + 360) % 6 * 60 / 360;
    L = (M + m) / 2;
    S = C == 0 ? 0 :
         L < .5 ? C / (2 * L) :
                  C / (2 - 2 * L);
    return {h: H, s: S, l: L, toString: hsltoString};
};

// Transformations
/*\
 * Snap.parsePathString
 [ method ]
 **
 * Utility method
 **
 * Parses given path string into an array of arrays of path segments
 - pathString (string|array) path string or array of segments (in the last case it is returned straight away)
 = (array) array of segments
\*/
Snap.parsePathString = function (pathString) {
    if (!pathString) {
        return null;
    }
    var pth = Snap.path(pathString);
    if (pth.arr) {
        return Snap.path.clone(pth.arr);
    }

    var paramCounts = {a: 7, c: 6, o: 2, h: 1, l: 2, m: 2, r: 4, q: 4, s: 4, t: 2, v: 1, u: 3, z: 0},
        data = [];
    if (is(pathString, "array") && is(pathString[0], "array")) { // rough assumption
        data = Snap.path.clone(pathString);
    }
    if (!data.length) {
        Str(pathString).replace(pathCommand, function (a, b, c) {
            var params = [],
                name = b.toLowerCase();
            c.replace(pathValues, function (a, b) {
                b && params.push(+b);
            });
            if (name == "m" && params.length > 2) {
                data.push([b].concat(params.splice(0, 2)));
                name = "l";
                b = b == "m" ? "l" : "L";
            }
            if (name == "o" && params.length == 1) {
                data.push([b, params[0]]);
            }
            if (name == "r") {
                data.push([b].concat(params));
            } else while (params.length >= paramCounts[name]) {
                data.push([b].concat(params.splice(0, paramCounts[name])));
                if (!paramCounts[name]) {
                    break;
                }
            }
        });
    }
    data.toString = Snap.path.toString;
    pth.arr = Snap.path.clone(data);
    return data;
};
/*\
 * Snap.parseTransformString
 [ method ]
 **
 * Utility method
 **
 * Parses given transform string into an array of transformations
 - TString (string|array) transform string or array of transformations (in the last case it is returned straight away)
 = (array) array of transformations
\*/
var parseTransformString = Snap.parseTransformString = function (TString) {
    if (!TString) {
        return null;
    }
    var paramCounts = {r: 3, s: 4, t: 2, m: 6},
        data = [];
    if (is(TString, "array") && is(TString[0], "array")) { // rough assumption
        data = Snap.path.clone(TString);
    }
    if (!data.length) {
        Str(TString).replace(tCommand, function (a, b, c) {
            var params = [],
                name = b.toLowerCase();
            c.replace(pathValues, function (a, b) {
                b && params.push(+b);
            });
            data.push([b].concat(params));
        });
    }
    data.toString = Snap.path.toString;
    return data;
};
function svgTransform2string(tstr) {
    var res = [];
    tstr = tstr.replace(/(?:^|\s)(\w+)\(([^)]+)\)/g, function (all, name, params) {
        params = params.split(/\s*,\s*|\s+/);
        if (name == "rotate" && params.length == 1) {
            params.push(0, 0);
        }
        if (name == "scale") {
            if (params.length > 2) {
                params = params.slice(0, 2);
            } else if (params.length == 2) {
                params.push(0, 0);
            }
            if (params.length == 1) {
                params.push(params[0], 0, 0);
            }
        }
        if (name == "skewX") {
            res.push(["m", 1, 0, math.tan(rad(params[0])), 1, 0, 0]);
        } else if (name == "skewY") {
            res.push(["m", 1, math.tan(rad(params[0])), 0, 1, 0, 0]);
        } else {
            res.push([name.charAt(0)].concat(params));
        }
        return all;
    });
    return res;
}
Snap._.svgTransform2string = svgTransform2string;
Snap._.rgTransform = /^[a-z][\s]*-?\.?\d/i;
function transform2matrix(tstr, bbox) {
    var tdata = parseTransformString(tstr),
        m = new Snap.Matrix;
    if (tdata) {
        for (var i = 0, ii = tdata.length; i < ii; i++) {
            var t = tdata[i],
                tlen = t.length,
                command = Str(t[0]).toLowerCase(),
                absolute = t[0] != command,
                inver = absolute ? m.invert() : 0,
                x1,
                y1,
                x2,
                y2,
                bb;
            if (command == "t" && tlen == 2){
                m.translate(t[1], 0);
            } else if (command == "t" && tlen == 3) {
                if (absolute) {
                    x1 = inver.x(0, 0);
                    y1 = inver.y(0, 0);
                    x2 = inver.x(t[1], t[2]);
                    y2 = inver.y(t[1], t[2]);
                    m.translate(x2 - x1, y2 - y1);
                } else {
                    m.translate(t[1], t[2]);
                }
            } else if (command == "r") {
                if (tlen == 2) {
                    bb = bb || bbox;
                    m.rotate(t[1], bb.x + bb.width / 2, bb.y + bb.height / 2);
                } else if (tlen == 4) {
                    if (absolute) {
                        x2 = inver.x(t[2], t[3]);
                        y2 = inver.y(t[2], t[3]);
                        m.rotate(t[1], x2, y2);
                    } else {
                        m.rotate(t[1], t[2], t[3]);
                    }
                }
            } else if (command == "s") {
                if (tlen == 2 || tlen == 3) {
                    bb = bb || bbox;
                    m.scale(t[1], t[tlen - 1], bb.x + bb.width / 2, bb.y + bb.height / 2);
                } else if (tlen == 4) {
                    if (absolute) {
                        x2 = inver.x(t[2], t[3]);
                        y2 = inver.y(t[2], t[3]);
                        m.scale(t[1], t[1], x2, y2);
                    } else {
                        m.scale(t[1], t[1], t[2], t[3]);
                    }
                } else if (tlen == 5) {
                    if (absolute) {
                        x2 = inver.x(t[3], t[4]);
                        y2 = inver.y(t[3], t[4]);
                        m.scale(t[1], t[2], x2, y2);
                    } else {
                        m.scale(t[1], t[2], t[3], t[4]);
                    }
                }
            } else if (command == "m" && tlen == 7) {
                m.add(t[1], t[2], t[3], t[4], t[5], t[6]);
            }
        }
    }
    return m;
}
Snap._.transform2matrix = transform2matrix;
Snap._unit2px = unit2px;
var contains = glob.doc.contains || glob.doc.compareDocumentPosition ?
    function (a, b) {
        var adown = a.nodeType == 9 ? a.documentElement : a,
            bup = b && b.parentNode;
            return a == bup || !!(bup && bup.nodeType == 1 && (
                adown.contains ?
                    adown.contains(bup) :
                    a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16
            ));
    } :
    function (a, b) {
        if (b) {
            while (b) {
                b = b.parentNode;
                if (b == a) {
                    return true;
                }
            }
        }
        return false;
    };
function getSomeDefs(el) {
    var p = el.node.ownerSVGElement && wrap(el.node.ownerSVGElement) ||
            el.node.parentNode && wrap(el.node.parentNode) ||
            Snap.select("svg") ||
            Snap(0, 0),
        pdefs = p.select("defs"),
        defs  = pdefs == null ? false : pdefs.node;
    if (!defs) {
        defs = make("defs", p.node).node;
    }
    return defs;
}
function getSomeSVG(el) {
    return el.node.ownerSVGElement && wrap(el.node.ownerSVGElement) || Snap.select("svg");
}
Snap._.getSomeDefs = getSomeDefs;
Snap._.getSomeSVG = getSomeSVG;
function unit2px(el, name, value) {
    var svg = getSomeSVG(el).node,
        out = {},
        mgr = svg.querySelector(".svg---mgr");
    if (!mgr) {
        mgr = $("rect");
        $(mgr, {x: -9e9, y: -9e9, width: 10, height: 10, "class": "svg---mgr", fill: "none"});
        svg.appendChild(mgr);
    }
    function getW(val) {
        if (val == null) {
            return E;
        }
        if (val == +val) {
            return val;
        }
        $(mgr, {width: val});
        try {
            return mgr.getBBox().width;
        } catch (e) {
            return 0;
        }
    }
    function getH(val) {
        if (val == null) {
            return E;
        }
        if (val == +val) {
            return val;
        }
        $(mgr, {height: val});
        try {
            return mgr.getBBox().height;
        } catch (e) {
            return 0;
        }
    }
    function set(nam, f) {
        if (name == null) {
            out[nam] = f(el.attr(nam) || 0);
        } else if (nam == name) {
            out = f(value == null ? el.attr(nam) || 0 : value);
        }
    }
    switch (el.type) {
        case "rect":
            set("rx", getW);
            set("ry", getH);
        case "image":
            set("width", getW);
            set("height", getH);
        case "text":
            set("x", getW);
            set("y", getH);
        break;
        case "circle":
            set("cx", getW);
            set("cy", getH);
            set("r", getW);
        break;
        case "ellipse":
            set("cx", getW);
            set("cy", getH);
            set("rx", getW);
            set("ry", getH);
        break;
        case "line":
            set("x1", getW);
            set("x2", getW);
            set("y1", getH);
            set("y2", getH);
        break;
        case "marker":
            set("refX", getW);
            set("markerWidth", getW);
            set("refY", getH);
            set("markerHeight", getH);
        break;
        case "radialGradient":
            set("fx", getW);
            set("fy", getH);
        break;
        case "tspan":
            set("dx", getW);
            set("dy", getH);
        break;
        default:
            set(name, getW);
    }
    svg.removeChild(mgr);
    return out;
}
/*\
 * Snap.select
 [ method ]
 **
 * Wraps a DOM element specified by CSS selector as @Element
 - query (string) CSS selector of the element
 = (Element) the current element
\*/
Snap.select = function (query) {
    query = Str(query).replace(/([^\\]):/g, "$1\\:");
    return wrap(glob.doc.querySelector(query));
};
/*\
 * Snap.selectAll
 [ method ]
 **
 * Wraps DOM elements specified by CSS selector as set or array of @Element
 - query (string) CSS selector of the element
 = (Element) the current element
\*/
Snap.selectAll = function (query) {
    var nodelist = glob.doc.querySelectorAll(query),
        set = (Snap.set || Array)();
    for (var i = 0; i < nodelist.length; i++) {
        set.push(wrap(nodelist[i]));
    }
    return set;
};

function add2group(list) {
    if (!is(list, "array")) {
        list = Array.prototype.slice.call(arguments, 0);
    }
    var i = 0,
        j = 0,
        node = this.node;
    while (this[i]) delete this[i++];
    for (i = 0; i < list.length; i++) {
        if (list[i].type == "set") {
            list[i].forEach(function (el) {
                node.appendChild(el.node);
            });
        } else {
            node.appendChild(list[i].node);
        }
    }
    var children = node.childNodes;
    for (i = 0; i < children.length; i++) {
        this[j++] = wrap(children[i]);
    }
    return this;
}
// Hub garbage collector every 10s
setInterval(function () {
    for (var key in hub) if (hub[has](key)) {
        var el = hub[key],
            node = el.node;
        if (el.type != "svg" && !node.ownerSVGElement || el.type == "svg" && (!node.parentNode || "ownerSVGElement" in node.parentNode && !node.ownerSVGElement)) {
            delete hub[key];
        }
    }
}, 1e4);
function Element(el) {
    if (el.snap in hub) {
        return hub[el.snap];
    }
    var svg;
    try {
        svg = el.ownerSVGElement;
    } catch(e) {}
    /*\
     * Element.node
     [ property (object) ]
     **
     * Gives you a reference to the DOM object, so you can assign event handlers or just mess around.
     > Usage
     | // draw a circle at coordinate 10,10 with radius of 10
     | var c = paper.circle(10, 10, 10);
     | c.node.onclick = function () {
     |     c.attr("fill", "red");
     | };
    \*/
    this.node = el;
    if (svg) {
        this.paper = new Paper(svg);
    }
    /*\
     * Element.type
     [ property (string) ]
     **
     * SVG tag name of the given element.
    \*/
    this.type = el.tagName || el.nodeName;
    var id = this.id = ID(this);
    this.anims = {};
    this._ = {
        transform: []
    };
    el.snap = id;
    hub[id] = this;
    if (this.type == "g") {
        this.add = add2group;
    }
    if (this.type in {g: 1, mask: 1, pattern: 1, symbol: 1}) {
        for (var method in Paper.prototype) if (Paper.prototype[has](method)) {
            this[method] = Paper.prototype[method];
        }
    }
}
   /*\
     * Element.attr
     [ method ]
     **
     * Gets or sets given attributes of the element.
     **
     - params (object) contains key-value pairs of attributes you want to set
     * or
     - param (string) name of the attribute
     = (Element) the current element
     * or
     = (string) value of attribute
     > Usage
     | el.attr({
     |     fill: "#fc0",
     |     stroke: "#000",
     |     strokeWidth: 2, // CamelCase...
     |     "fill-opacity": 0.5, // or dash-separated names
     |     width: "*=2" // prefixed values
     | });
     | console.log(el.attr("fill")); // #fc0
     * Prefixed values in format `"+=10"` supported. All four operations
     * (`+`, `-`, `*` and `/`) could be used. Optionally you can use units for `+`
     * and `-`: `"+=2em"`.
    \*/
    Element.prototype.attr = function (params, value) {
        var el = this,
            node = el.node;
        if (!params) {
            if (node.nodeType != 1) {
                return {
                    text: node.nodeValue
                };
            }
            var attr = node.attributes,
                out = {};
            for (var i = 0, ii = attr.length; i < ii; i++) {
                out[attr[i].nodeName] = attr[i].nodeValue;
            }
            return out;
        }
        if (is(params, "string")) {
            if (arguments.length > 1) {
                var json = {};
                json[params] = value;
                params = json;
            } else {
                return eve("snap.util.getattr." + params, el).firstDefined();
            }
        }
        for (var att in params) {
            if (params[has](att)) {
                eve("snap.util.attr." + att, el, params[att]);
            }
        }
        return el;
    };
/*\
 * Snap.parse
 [ method ]
 **
 * Parses SVG fragment and converts it into a @Fragment
 **
 - svg (string) SVG string
 = (Fragment) the @Fragment
\*/
Snap.parse = function (svg) {
    var f = glob.doc.createDocumentFragment(),
        full = true,
        div = glob.doc.createElement("div");
    svg = Str(svg);
    if (!svg.match(/^\s*<\s*svg(?:\s|>)/)) {
        svg = "<svg>" + svg + "</svg>";
        full = false;
    }
    div.innerHTML = svg;
    svg = div.getElementsByTagName("svg")[0];
    if (svg) {
        if (full) {
            f = svg;
        } else {
            while (svg.firstChild) {
                f.appendChild(svg.firstChild);
            }
        }
    }
    return new Fragment(f);
};
function Fragment(frag) {
    this.node = frag;
}
/*\
 * Snap.fragment
 [ method ]
 **
 * Creates a DOM fragment from a given list of elements or strings
 **
 - varargs (…) SVG string
 = (Fragment) the @Fragment
\*/
Snap.fragment = function () {
    var args = Array.prototype.slice.call(arguments, 0),
        f = glob.doc.createDocumentFragment();
    for (var i = 0, ii = args.length; i < ii; i++) {
        var item = args[i];
        if (item.node && item.node.nodeType) {
            f.appendChild(item.node);
        }
        if (item.nodeType) {
            f.appendChild(item);
        }
        if (typeof item == "string") {
            f.appendChild(Snap.parse(item).node);
        }
    }
    return new Fragment(f);
};

function make(name, parent) {
    var res = $(name);
    parent.appendChild(res);
    var el = wrap(res);
    return el;
}
function Paper(w, h) {
    var res,
        desc,
        defs,
        proto = Paper.prototype;
    if (w && w.tagName && w.tagName.toLowerCase() == "svg") {
        if (w.snap in hub) {
            return hub[w.snap];
        }
        var doc = w.ownerDocument;
        res = new Element(w);
        desc = w.getElementsByTagName("desc")[0];
        defs = w.getElementsByTagName("defs")[0];
        if (!desc) {
            desc = $("desc");
            desc.appendChild(doc.createTextNode("Created with Snap"));
            res.node.appendChild(desc);
        }
        if (!defs) {
            defs = $("defs");
            res.node.appendChild(defs);
        }
        res.defs = defs;
        for (var key in proto) if (proto[has](key)) {
            res[key] = proto[key];
        }
        res.paper = res.root = res;
    } else {
        res = make("svg", glob.doc.body);
        $(res.node, {
            height: h,
            version: 1.1,
            width: w,
            xmlns: xmlns
        });
    }
    return res;
}
function wrap(dom) {
    if (!dom) {
        return dom;
    }
    if (dom instanceof Element || dom instanceof Fragment) {
        return dom;
    }
    if (dom.tagName && dom.tagName.toLowerCase() == "svg") {
        return new Paper(dom);
    }
    if (dom.tagName && dom.tagName.toLowerCase() == "object" && dom.type == "image/svg+xml") {
        return new Paper(dom.contentDocument.getElementsByTagName("svg")[0]);
    }
    return new Element(dom);
}

Snap._.make = make;
Snap._.wrap = wrap;
/*\
 * Paper.el
 [ method ]
 **
 * Creates an element on paper with a given name and no attributes
 **
 - name (string) tag name
 - attr (object) attributes
 = (Element) the current element
 > Usage
 | var c = paper.circle(10, 10, 10); // is the same as...
 | var c = paper.el("circle").attr({
 |     cx: 10,
 |     cy: 10,
 |     r: 10
 | });
 | // and the same as
 | var c = paper.el("circle", {
 |     cx: 10,
 |     cy: 10,
 |     r: 10
 | });
\*/
Paper.prototype.el = function (name, attr) {
    var el = make(name, this.node);
    attr && el.attr(attr);
    return el;
};
/*\
 * Element.children
 [ method ]
 **
 * Returns array of all the children of the element.
 = (array) array of Elements
\*/
Element.prototype.children = function () {
    var out = [],
        ch = this.node.childNodes;
    for (var i = 0, ii = ch.length; i < ii; i++) {
        out[i] = Snap(ch[i]);
    }
    return out;
};
function jsonFiller(root, o) {
    for (var i = 0, ii = root.length; i < ii; i++) {
        var item = {
                type: root[i].type,
                attr: root[i].attr()
            },
            children = root[i].children();
        o.push(item);
        if (children.length) {
            jsonFiller(children, item.childNodes = []);
        }
    }
}
/*\
 * Element.toJSON
 [ method ]
 **
 * Returns object representation of the given element and all its children.
 = (object) in format
 o {
 o     type (string) this.type,
 o     attr (object) attributes map,
 o     childNodes (array) optional array of children in the same format
 o }
\*/
Element.prototype.toJSON = function () {
    var out = [];
    jsonFiller([this], out);
    return out[0];
};
// default
eve.on("snap.util.getattr", function () {
    var att = eve.nt();
    att = att.substring(att.lastIndexOf(".") + 1);
    var css = att.replace(/[A-Z]/g, function (letter) {
        return "-" + letter.toLowerCase();
    });
    if (cssAttr[has](css)) {
        return this.node.ownerDocument.defaultView.getComputedStyle(this.node, null).getPropertyValue(css);
    } else {
        return $(this.node, att);
    }
});
var cssAttr = {
    "alignment-baseline": 0,
    "baseline-shift": 0,
    "clip": 0,
    "clip-path": 0,
    "clip-rule": 0,
    "color": 0,
    "color-interpolation": 0,
    "color-interpolation-filters": 0,
    "color-profile": 0,
    "color-rendering": 0,
    "cursor": 0,
    "direction": 0,
    "display": 0,
    "dominant-baseline": 0,
    "enable-background": 0,
    "fill": 0,
    "fill-opacity": 0,
    "fill-rule": 0,
    "filter": 0,
    "flood-color": 0,
    "flood-opacity": 0,
    "font": 0,
    "font-family": 0,
    "font-size": 0,
    "font-size-adjust": 0,
    "font-stretch": 0,
    "font-style": 0,
    "font-variant": 0,
    "font-weight": 0,
    "glyph-orientation-horizontal": 0,
    "glyph-orientation-vertical": 0,
    "image-rendering": 0,
    "kerning": 0,
    "letter-spacing": 0,
    "lighting-color": 0,
    "marker": 0,
    "marker-end": 0,
    "marker-mid": 0,
    "marker-start": 0,
    "mask": 0,
    "opacity": 0,
    "overflow": 0,
    "pointer-events": 0,
    "shape-rendering": 0,
    "stop-color": 0,
    "stop-opacity": 0,
    "stroke": 0,
    "stroke-dasharray": 0,
    "stroke-dashoffset": 0,
    "stroke-linecap": 0,
    "stroke-linejoin": 0,
    "stroke-miterlimit": 0,
    "stroke-opacity": 0,
    "stroke-width": 0,
    "text-anchor": 0,
    "text-decoration": 0,
    "text-rendering": 0,
    "unicode-bidi": 0,
    "visibility": 0,
    "word-spacing": 0,
    "writing-mode": 0
};

eve.on("snap.util.attr", function (value) {
    var att = eve.nt(),
        attr = {};
    att = att.substring(att.lastIndexOf(".") + 1);
    attr[att] = value;
    var style = att.replace(/-(\w)/gi, function (all, letter) {
            return letter.toUpperCase();
        }),
        css = att.replace(/[A-Z]/g, function (letter) {
            return "-" + letter.toLowerCase();
        });
    if (cssAttr[has](css)) {
        this.node.style[style] = value == null ? E : value;
    } else {
        $(this.node, attr);
    }
});
(function (proto) {}(Paper.prototype));

// simple ajax
/*\
 * Snap.ajax
 [ method ]
 **
 * Simple implementation of Ajax
 **
 - url (string) URL
 - postData (object|string) data for post request
 - callback (function) callback
 - scope (object) #optional scope of callback
 * or
 - url (string) URL
 - callback (function) callback
 - scope (object) #optional scope of callback
 = (XMLHttpRequest) the XMLHttpRequest object, just in case
\*/
Snap.ajax = function (url, postData, callback, scope){
    var req = new XMLHttpRequest,
        id = ID();
    if (req) {
        if (is(postData, "function")) {
            scope = callback;
            callback = postData;
            postData = null;
        } else if (is(postData, "object")) {
            var pd = [];
            for (var key in postData) if (postData.hasOwnProperty(key)) {
                pd.push(encodeURIComponent(key) + "=" + encodeURIComponent(postData[key]));
            }
            postData = pd.join("&");
        }
        req.open(postData ? "POST" : "GET", url, true);
        if (postData) {
            req.setRequestHeader("X-Requested-With", "XMLHttpRequest");
            req.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
        }
        if (callback) {
            eve.once("snap.ajax." + id + ".0", callback);
            eve.once("snap.ajax." + id + ".200", callback);
            eve.once("snap.ajax." + id + ".304", callback);
        }
        req.onreadystatechange = function() {
            if (req.readyState != 4) return;
            eve("snap.ajax." + id + "." + req.status, scope, req);
        };
        if (req.readyState == 4) {
            return req;
        }
        req.send(postData);
        return req;
    }
};
/*\
 * Snap.load
 [ method ]
 **
 * Loads external SVG file as a @Fragment (see @Snap.ajax for more advanced AJAX)
 **
 - url (string) URL
 - callback (function) callback
 - scope (object) #optional scope of callback
\*/
Snap.load = function (url, callback, scope) {
    Snap.ajax(url, function (req) {
        var f = Snap.parse(req.responseText);
        scope ? callback.call(scope, f) : callback(f);
    });
};
var getOffset = function (elem) {
    var box = elem.getBoundingClientRect(),
        doc = elem.ownerDocument,
        body = doc.body,
        docElem = doc.documentElement,
        clientTop = docElem.clientTop || body.clientTop || 0, clientLeft = docElem.clientLeft || body.clientLeft || 0,
        top  = box.top  + (g.win.pageYOffset || docElem.scrollTop || body.scrollTop ) - clientTop,
        left = box.left + (g.win.pageXOffset || docElem.scrollLeft || body.scrollLeft) - clientLeft;
    return {
        y: top,
        x: left
    };
};
/*\
 * Snap.getElementByPoint
 [ method ]
 **
 * Returns you topmost element under given point.
 **
 = (object) Snap element object
 - x (number) x coordinate from the top left corner of the window
 - y (number) y coordinate from the top left corner of the window
 > Usage
 | Snap.getElementByPoint(mouseX, mouseY).attr({stroke: "#f00"});
\*/
Snap.getElementByPoint = function (x, y) {
    var paper = this,
        svg = paper.canvas,
        target = glob.doc.elementFromPoint(x, y);
    if (glob.win.opera && target.tagName == "svg") {
        var so = getOffset(target),
            sr = target.createSVGRect();
        sr.x = x - so.x;
        sr.y = y - so.y;
        sr.width = sr.height = 1;
        var hits = target.getIntersectionList(sr, null);
        if (hits.length) {
            target = hits[hits.length - 1];
        }
    }
    if (!target) {
        return null;
    }
    return wrap(target);
};
/*\
 * Snap.plugin
 [ method ]
 **
 * Let you write plugins. You pass in a function with five arguments, like this:
 | Snap.plugin(function (Snap, Element, Paper, global, Fragment) {
 |     Snap.newmethod = function () {};
 |     Element.prototype.newmethod = function () {};
 |     Paper.prototype.newmethod = function () {};
 | });
 * Inside the function you have access to all main objects (and their
 * prototypes). This allow you to extend anything you want.
 **
 - f (function) your plugin body
\*/
Snap.plugin = function (f) {
    f(Snap, Element, Paper, glob, Fragment);
};
glob.win.Snap = Snap;
return Snap;
}(window || this));

// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Snap.plugin(function (Snap, Element, Paper, glob, Fragment) {
    var elproto = Element.prototype,
        is = Snap.is,
        Str = String,
        unit2px = Snap._unit2px,
        $ = Snap._.$,
        make = Snap._.make,
        getSomeDefs = Snap._.getSomeDefs,
        has = "hasOwnProperty",
        wrap = Snap._.wrap;
    /*\
     * Element.getBBox
     [ method ]
     **
     * Returns the bounding box descriptor for the given element
     **
     = (object) bounding box descriptor:
     o {
     o     cx: (number) x of the center,
     o     cy: (number) x of the center,
     o     h: (number) height,
     o     height: (number) height,
     o     path: (string) path command for the box,
     o     r0: (number) radius of a circle that fully encloses the box,
     o     r1: (number) radius of the smallest circle that can be enclosed,
     o     r2: (number) radius of the largest circle that can be enclosed,
     o     vb: (string) box as a viewbox command,
     o     w: (number) width,
     o     width: (number) width,
     o     x2: (number) x of the right side,
     o     x: (number) x of the left side,
     o     y2: (number) y of the bottom edge,
     o     y: (number) y of the top edge
     o }
    \*/
    elproto.getBBox = function (isWithoutTransform) {
        if (this.type == "tspan") {
            return Snap._.box(this.node.getClientRects().item(0));
        }
        if (!Snap.Matrix || !Snap.path) {
            return this.node.getBBox();
        }
        var el = this,
            m = new Snap.Matrix;
        if (el.removed) {
            return Snap._.box();
        }
        while (el.type == "use") {
            if (!isWithoutTransform) {
                m = m.add(el.transform().localMatrix.translate(el.attr("x") || 0, el.attr("y") || 0));
            }
            if (el.original) {
                el = el.original;
            } else {
                var href = el.attr("xlink:href");
                el = el.original = el.node.ownerDocument.getElementById(href.substring(href.indexOf("#") + 1));
            }
        }
        var _ = el._,
            pathfinder = Snap.path.get[el.type] || Snap.path.get.deflt;
        try {
            if (isWithoutTransform) {
                _.bboxwt = pathfinder ? Snap.path.getBBox(el.realPath = pathfinder(el)) : Snap._.box(el.node.getBBox());
                return Snap._.box(_.bboxwt);
            } else {
                el.realPath = pathfinder(el);
                el.matrix = el.transform().localMatrix;
                _.bbox = Snap.path.getBBox(Snap.path.map(el.realPath, m.add(el.matrix)));
                return Snap._.box(_.bbox);
            }
        } catch (e) {
            // Firefox doesn’t give you bbox of hidden element
            return Snap._.box();
        }
    };
    var propString = function () {
        return this.string;
    };
    function extractTransform(el, tstr) {
        if (tstr == null) {
            var doReturn = true;
            if (el.type == "linearGradient" || el.type == "radialGradient") {
                tstr = el.node.getAttribute("gradientTransform");
            } else if (el.type == "pattern") {
                tstr = el.node.getAttribute("patternTransform");
            } else {
                tstr = el.node.getAttribute("transform");
            }
            if (!tstr) {
                return new Snap.Matrix;
            }
            tstr = Snap._.svgTransform2string(tstr);
        } else {
            if (!Snap._.rgTransform.test(tstr)) {
                tstr = Snap._.svgTransform2string(tstr);
            } else {
                tstr = Str(tstr).replace(/\.{3}|\u2026/g, el._.transform || "");
            }
            if (is(tstr, "array")) {
                tstr = Snap.path ? Snap.path.toString.call(tstr) : Str(tstr);
            }
            el._.transform = tstr;
        }
        var m = Snap._.transform2matrix(tstr, el.getBBox(1));
        if (doReturn) {
            return m;
        } else {
            el.matrix = m;
        }
    }
    /*\
     * Element.transform
     [ method ]
     **
     * Gets or sets transformation of the element
     **
     - tstr (string) transform string in Snap or SVG format
     = (Element) the current element
     * or
     = (object) transformation descriptor:
     o {
     o     string (string) transform string,
     o     globalMatrix (Matrix) matrix of all transformations applied to element or its parents,
     o     localMatrix (Matrix) matrix of transformations applied only to the element,
     o     diffMatrix (Matrix) matrix of difference between global and local transformations,
     o     global (string) global transformation as string,
     o     local (string) local transformation as string,
     o     toString (function) returns `string` property
     o }
    \*/
    elproto.transform = function (tstr) {
        var _ = this._;
        if (tstr == null) {
            var papa = this,
                global = new Snap.Matrix(this.node.getCTM()),
                local = extractTransform(this),
                ms = [local],
                m = new Snap.Matrix,
                i,
                localString = local.toTransformString(),
                string = Str(local) == Str(this.matrix) ?
                            Str(_.transform) : localString;
            while (papa.type != "svg" && (papa = papa.parent())) {
                ms.push(extractTransform(papa));
            }
            i = ms.length;
            while (i--) {
                m.add(ms[i]);
            }
            return {
                string: string,
                globalMatrix: global,
                totalMatrix: m,
                localMatrix: local,
                diffMatrix: global.clone().add(local.invert()),
                global: global.toTransformString(),
                total: m.toTransformString(),
                local: localString,
                toString: propString
            };
        }
        if (tstr instanceof Snap.Matrix) {
            this.matrix = tstr;
            this._.transform = tstr.toTransformString();
        } else {
            extractTransform(this, tstr);
        }

        if (this.node) {
            if (this.type == "linearGradient" || this.type == "radialGradient") {
                $(this.node, {gradientTransform: this.matrix});
            } else if (this.type == "pattern") {
                $(this.node, {patternTransform: this.matrix});
            } else {
                $(this.node, {transform: this.matrix});
            }
        }

        return this;
    };
    /*\
     * Element.parent
     [ method ]
     **
     * Returns the element's parent
     **
     = (Element) the parent element
    \*/
    elproto.parent = function () {
        return wrap(this.node.parentNode);
    };
    /*\
     * Element.append
     [ method ]
     **
     * Appends the given element to current one
     **
     - el (Element|Set) element to append
     = (Element) the parent element
    \*/
    /*\
     * Element.add
     [ method ]
     **
     * See @Element.append
    \*/
    elproto.append = elproto.add = function (el) {
        if (el) {
            if (el.type == "set") {
                var it = this;
                el.forEach(function (el) {
                    it.add(el);
                });
                return this;
            }
            el = wrap(el);
            this.node.appendChild(el.node);
            el.paper = this.paper;
        }
        return this;
    };
    /*\
     * Element.appendTo
     [ method ]
     **
     * Appends the current element to the given one
     **
     - el (Element) parent element to append to
     = (Element) the child element
    \*/
    elproto.appendTo = function (el) {
        if (el) {
            el = wrap(el);
            el.append(this);
        }
        return this;
    };
    /*\
     * Element.prepend
     [ method ]
     **
     * Prepends the given element to the current one
     **
     - el (Element) element to prepend
     = (Element) the parent element
    \*/
    elproto.prepend = function (el) {
        if (el) {
            if (el.type == "set") {
                var it = this,
                    first;
                el.forEach(function (el) {
                    if (first) {
                        first.after(el);
                    } else {
                        it.prepend(el);
                    }
                    first = el;
                });
                return this;
            }
            el = wrap(el);
            var parent = el.parent();
            this.node.insertBefore(el.node, this.node.firstChild);
            this.add && this.add();
            el.paper = this.paper;
            this.parent() && this.parent().add();
            parent && parent.add();
        }
        return this;
    };
    /*\
     * Element.prependTo
     [ method ]
     **
     * Prepends the current element to the given one
     **
     - el (Element) parent element to prepend to
     = (Element) the child element
    \*/
    elproto.prependTo = function (el) {
        el = wrap(el);
        el.prepend(this);
        return this;
    };
    /*\
     * Element.before
     [ method ]
     **
     * Inserts given element before the current one
     **
     - el (Element) element to insert
     = (Element) the parent element
    \*/
    elproto.before = function (el) {
        if (el.type == "set") {
            var it = this;
            el.forEach(function (el) {
                var parent = el.parent();
                it.node.parentNode.insertBefore(el.node, it.node);
                parent && parent.add();
            });
            this.parent().add();
            return this;
        }
        el = wrap(el);
        var parent = el.parent();
        this.node.parentNode.insertBefore(el.node, this.node);
        this.parent() && this.parent().add();
        parent && parent.add();
        el.paper = this.paper;
        return this;
    };
    /*\
     * Element.after
     [ method ]
     **
     * Inserts given element after the current one
     **
     - el (Element) element to insert
     = (Element) the parent element
    \*/
    elproto.after = function (el) {
        el = wrap(el);
        var parent = el.parent();
        if (this.node.nextSibling) {
            this.node.parentNode.insertBefore(el.node, this.node.nextSibling);
        } else {
            this.node.parentNode.appendChild(el.node);
        }
        this.parent() && this.parent().add();
        parent && parent.add();
        el.paper = this.paper;
        return this;
    };
    /*\
     * Element.insertBefore
     [ method ]
     **
     * Inserts the element after the given one
     **
     - el (Element) element next to whom insert to
     = (Element) the parent element
    \*/
    elproto.insertBefore = function (el) {
        el = wrap(el);
        var parent = this.parent();
        el.node.parentNode.insertBefore(this.node, el.node);
        this.paper = el.paper;
        parent && parent.add();
        el.parent() && el.parent().add();
        return this;
    };
    /*\
     * Element.insertAfter
     [ method ]
     **
     * Inserts the element after the given one
     **
     - el (Element) element next to whom insert to
     = (Element) the parent element
    \*/
    elproto.insertAfter = function (el) {
        el = wrap(el);
        var parent = this.parent();
        el.node.parentNode.insertBefore(this.node, el.node.nextSibling);
        this.paper = el.paper;
        parent && parent.add();
        el.parent() && el.parent().add();
        return this;
    };
    /*\
     * Element.remove
     [ method ]
     **
     * Removes element from the DOM
     = (Element) the detached element
    \*/
    elproto.remove = function () {
        var parent = this.parent();
        this.node.parentNode && this.node.parentNode.removeChild(this.node);
        delete this.paper;
        this.removed = true;
        parent && parent.add();
        return this;
    };
    /*\
     * Element.select
     [ method ]
     **
     * Gathers the nested @Element matching the given set of CSS selectors
     **
     - query (string) CSS selector
     = (Element) result of query selection
    \*/
    elproto.select = function (query) {
        return wrap(this.node.querySelector(query));
    };
    /*\
     * Element.selectAll
     [ method ]
     **
     * Gathers nested @Element objects matching the given set of CSS selectors
     **
     - query (string) CSS selector
     = (Set|array) result of query selection
    \*/
    elproto.selectAll = function (query) {
        var nodelist = this.node.querySelectorAll(query),
            set = (Snap.set || Array)();
        for (var i = 0; i < nodelist.length; i++) {
            set.push(wrap(nodelist[i]));
        }
        return set;
    };
    /*\
     * Element.asPX
     [ method ]
     **
     * Returns given attribute of the element as a `px` value (not %, em, etc.)
     **
     - attr (string) attribute name
     - value (string) #optional attribute value
     = (Element) result of query selection
    \*/
    elproto.asPX = function (attr, value) {
        if (value == null) {
            value = this.attr(attr);
        }
        return +unit2px(this, attr, value);
    };
    // SIERRA Element.use(): I suggest adding a note about how to access the original element the returned <use> instantiates. It's a part of SVG with which ordinary web developers may be least familiar.
    /*\
     * Element.use
     [ method ]
     **
     * Creates a `<use>` element linked to the current element
     **
     = (Element) the `<use>` element
    \*/
    elproto.use = function () {
        var use,
            id = this.node.id;
        if (!id) {
            id = this.id;
            $(this.node, {
                id: id
            });
        }
        if (this.type == "linearGradient" || this.type == "radialGradient" ||
            this.type == "pattern") {
            use = make(this.type, this.node.parentNode);
        } else {
            use = make("use", this.node.parentNode);
        }
        $(use.node, {
            "xlink:href": "#" + id
        });
        use.original = this;
        return use;
    };
    function fixids(el) {
        var els = el.selectAll("*"),
            it,
            url = /^\s*url\(("|'|)(.*)\1\)\s*$/,
            ids = [],
            uses = {};
        function urltest(it, name) {
            var val = $(it.node, name);
            val = val && val.match(url);
            val = val && val[2];
            if (val && val.charAt() == "#") {
                val = val.substring(1);
            } else {
                return;
            }
            if (val) {
                uses[val] = (uses[val] || []).concat(function (id) {
                    var attr = {};
                    attr[name] = Snap.url(id);
                    $(it.node, attr);
                });
            }
        }
        function linktest(it) {
            var val = $(it.node, "xlink:href");
            if (val && val.charAt() == "#") {
                val = val.substring(1);
            } else {
                return;
            }
            if (val) {
                uses[val] = (uses[val] || []).concat(function (id) {
                    it.attr("xlink:href", "#" + id);
                });
            }
        }
        for (var i = 0, ii = els.length; i < ii; i++) {
            it = els[i];
            urltest(it, "fill");
            urltest(it, "stroke");
            urltest(it, "filter");
            urltest(it, "mask");
            urltest(it, "clip-path");
            linktest(it);
            var oldid = $(it.node, "id");
            if (oldid) {
                $(it.node, {id: it.id});
                ids.push({
                    old: oldid,
                    id: it.id
                });
            }
        }
        for (i = 0, ii = ids.length; i < ii; i++) {
            var fs = uses[ids[i].old];
            if (fs) {
                for (var j = 0, jj = fs.length; j < jj; j++) {
                    fs[j](ids[i].id);
                }
            }
        }
    }
    /*\
     * Element.clone
     [ method ]
     **
     * Creates a clone of the element and inserts it after the element
     **
     = (Element) the clone
    \*/
    elproto.clone = function () {
        var clone = wrap(this.node.cloneNode(true));
        if ($(clone.node, "id")) {
            $(clone.node, {id: clone.id});
        }
        fixids(clone);
        clone.insertAfter(this);
        return clone;
    };
    /*\
     * Element.toDefs
     [ method ]
     **
     * Moves element to the shared `<defs>` area
     **
     = (Element) the element
    \*/
    elproto.toDefs = function () {
        var defs = getSomeDefs(this);
        defs.appendChild(this.node);
        return this;
    };
    /*\
     * Element.toPattern
     [ method ]
     **
     * Creates a `<pattern>` element from the current element
     **
     * To create a pattern you have to specify the pattern rect:
     - x (string|number)
     - y (string|number)
     - width (string|number)
     - height (string|number)
     = (Element) the `<pattern>` element
     * You can use pattern later on as an argument for `fill` attribute:
     | var p = paper.path("M10-5-10,15M15,0,0,15M0-5-20,15").attr({
     |         fill: "none",
     |         stroke: "#bada55",
     |         strokeWidth: 5
     |     }).pattern(0, 0, 10, 10),
     |     c = paper.circle(200, 200, 100);
     | c.attr({
     |     fill: p
     | });
    \*/
    elproto.pattern = elproto.toPattern = function (x, y, width, height) {
        var p = make("pattern", getSomeDefs(this));
        if (x == null) {
            x = this.getBBox();
        }
        if (is(x, "object") && "x" in x) {
            y = x.y;
            width = x.width;
            height = x.height;
            x = x.x;
        }
        $(p.node, {
            x: x,
            y: y,
            width: width,
            height: height,
            patternUnits: "userSpaceOnUse",
            id: p.id,
            viewBox: [x, y, width, height].join(" ")
        });
        p.node.appendChild(this.node);
        return p;
    };
// SIERRA Element.marker(): clarify what a reference point is. E.g., helps you offset the object from its edge such as when centering it over a path.
// SIERRA Element.marker(): I suggest the method should accept default reference point values.  Perhaps centered with (refX = width/2) and (refY = height/2)? Also, couldn't it assume the element's current _width_ and _height_? And please specify what _x_ and _y_ mean: offsets? If so, from where?  Couldn't they also be assigned default values?
    /*\
     * Element.marker
     [ method ]
     **
     * Creates a `<marker>` element from the current element
     **
     * To create a marker you have to specify the bounding rect and reference point:
     - x (number)
     - y (number)
     - width (number)
     - height (number)
     - refX (number)
     - refY (number)
     = (Element) the `<marker>` element
     * You can specify the marker later as an argument for `marker-start`, `marker-end`, `marker-mid`, and `marker` attributes. The `marker` attribute places the marker at every point along the path, and `marker-mid` places them at every point except the start and end.
    \*/
    // TODO add usage for markers
    elproto.marker = function (x, y, width, height, refX, refY) {
        var p = make("marker", getSomeDefs(this));
        if (x == null) {
            x = this.getBBox();
        }
        if (is(x, "object") && "x" in x) {
            y = x.y;
            width = x.width;
            height = x.height;
            refX = x.refX || x.cx;
            refY = x.refY || x.cy;
            x = x.x;
        }
        $(p.node, {
            viewBox: [x, y, width, height].join(" "),
            markerWidth: width,
            markerHeight: height,
            orient: "auto",
            refX: refX || 0,
            refY: refY || 0,
            id: p.id
        });
        p.node.appendChild(this.node);
        return p;
    };
    var eldata = {};
    /*\
     * Element.data
     [ method ]
     **
     * Adds or retrieves given value associated with given key. (Don’t confuse
     * with `data-` attributes)
     *
     * See also @Element.removeData
     - key (string) key to store data
     - value (any) #optional value to store
     = (object) @Element
     * or, if value is not specified:
     = (any) value
     > Usage
     | for (var i = 0, i < 5, i++) {
     |     paper.circle(10 + 15 * i, 10, 10)
     |          .attr({fill: "#000"})
     |          .data("i", i)
     |          .click(function () {
     |             alert(this.data("i"));
     |          });
     | }
    \*/
    elproto.data = function (key, value) {
        var data = eldata[this.id] = eldata[this.id] || {};
        if (arguments.length == 0){
            eve("snap.data.get." + this.id, this, data, null);
            return data;
        }
        if (arguments.length == 1) {
            if (Snap.is(key, "object")) {
                for (var i in key) if (key[has](i)) {
                    this.data(i, key[i]);
                }
                return this;
            }
            eve("snap.data.get." + this.id, this, data[key], key);
            return data[key];
        }
        data[key] = value;
        eve("snap.data.set." + this.id, this, value, key);
        return this;
    };
    /*\
     * Element.removeData
     [ method ]
     **
     * Removes value associated with an element by given key.
     * If key is not provided, removes all the data of the element.
     - key (string) #optional key
     = (object) @Element
    \*/
    elproto.removeData = function (key) {
        if (key == null) {
            eldata[this.id] = {};
        } else {
            eldata[this.id] && delete eldata[this.id][key];
        }
        return this;
    };
    /*\
     * Element.outerSVG
     [ method ]
     **
     * Returns SVG code for the element, equivalent to HTML's `outerHTML`.
     *
     * See also @Element.innerSVG
     = (string) SVG code for the element
    \*/
    /*\
     * Element.toString
     [ method ]
     **
     * See @Element.outerSVG
    \*/
    elproto.outerSVG = elproto.toString = toString(1);
    /*\
     * Element.innerSVG
     [ method ]
     **
     * Returns SVG code for the element's contents, equivalent to HTML's `innerHTML`
     = (string) SVG code for the element
    \*/
    elproto.innerSVG = toString();
    function toString(type) {
        return function () {
            var res = type ? "<" + this.type : "",
                attr = this.node.attributes,
                chld = this.node.childNodes;
            if (type) {
                for (var i = 0, ii = attr.length; i < ii; i++) {
                    res += " " + attr[i].name + '="' +
                            attr[i].value.replace(/"/g, '\\"') + '"';
                }
            }
            if (chld.length) {
                type && (res += ">");
                for (i = 0, ii = chld.length; i < ii; i++) {
                    if (chld[i].nodeType == 3) {
                        res += chld[i].nodeValue;
                    } else if (chld[i].nodeType == 1) {
                        res += wrap(chld[i]).toString();
                    }
                }
                type && (res += "</" + this.type + ">");
            } else {
                type && (res += "/>");
            }
            return res;
        };
    }
    elproto.toDataURL = function () {
        if (window && window.btoa) {
            var bb = this.getBBox(),
                svg = Snap.format('<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="{width}" height="{height}" viewBox="{x} {y} {width} {height}">{contents}</svg>', {
                x: +bb.x.toFixed(3),
                y: +bb.y.toFixed(3),
                width: +bb.width.toFixed(3),
                height: +bb.height.toFixed(3),
                contents: this.outerSVG()
            });
            return "data:image/svg+xml;base64," + btoa(unescape(encodeURIComponent(svg)));
        }
    };
    /*\
     * Fragment.select
     [ method ]
     **
     * See @Element.select
    \*/
    Fragment.prototype.select = elproto.select;
    /*\
     * Fragment.selectAll
     [ method ]
     **
     * See @Element.selectAll
    \*/
    Fragment.prototype.selectAll = elproto.selectAll;
});

// Copyright (c) 2016 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Snap.plugin(function (Snap, Element, Paper, glob, Fragment) {
    var elproto = Element.prototype,
        is = Snap.is,
        Str = String,
        has = "hasOwnProperty";
    function slice(from, to, f) {
        return function (arr) {
            var res = arr.slice(from, to);
            if (res.length == 1) {
                res = res[0];
            }
            return f ? f(res) : res;
        };
    }
    var Animation = function (attr, ms, easing, callback) {
        if (typeof easing == "function" && !easing.length) {
            callback = easing;
            easing = mina.linear;
        }
        this.attr = attr;
        this.dur = ms;
        easing && (this.easing = easing);
        callback && (this.callback = callback);
    };
    Snap._.Animation = Animation;
    /*\
     * Snap.animation
     [ method ]
     **
     * Creates an animation object
     **
     - attr (object) attributes of final destination
     - duration (number) duration of the animation, in milliseconds
     - easing (function) #optional one of easing functions of @mina or custom one
     - callback (function) #optional callback function that fires when animation ends
     = (object) animation object
    \*/
    Snap.animation = function (attr, ms, easing, callback) {
        return new Animation(attr, ms, easing, callback);
    };
    /*\
     * Element.inAnim
     [ method ]
     **
     * Returns a set of animations that may be able to manipulate the current element
     **
     = (object) in format:
     o {
     o     anim (object) animation object,
     o     mina (object) @mina object,
     o     curStatus (number) 0..1 — status of the animation: 0 — just started, 1 — just finished,
     o     status (function) gets or sets the status of the animation,
     o     stop (function) stops the animation
     o }
    \*/
    elproto.inAnim = function () {
        var el = this,
            res = [];
        for (var id in el.anims) if (el.anims[has](id)) {
            (function (a) {
                res.push({
                    anim: new Animation(a._attrs, a.dur, a.easing, a._callback),
                    mina: a,
                    curStatus: a.status(),
                    status: function (val) {
                        return a.status(val);
                    },
                    stop: function () {
                        a.stop();
                    }
                });
            }(el.anims[id]));
        }
        return res;
    };
    /*\
     * Snap.animate
     [ method ]
     **
     * Runs generic animation of one number into another with a caring function
     **
     - from (number|array) number or array of numbers
     - to (number|array) number or array of numbers
     - setter (function) caring function that accepts one number argument
     - duration (number) duration, in milliseconds
     - easing (function) #optional easing function from @mina or custom
     - callback (function) #optional callback function to execute when animation ends
     = (object) animation object in @mina format
     o {
     o     id (string) animation id, consider it read-only,
     o     duration (function) gets or sets the duration of the animation,
     o     easing (function) easing,
     o     speed (function) gets or sets the speed of the animation,
     o     status (function) gets or sets the status of the animation,
     o     stop (function) stops the animation
     o }
     | var rect = Snap().rect(0, 0, 10, 10);
     | Snap.animate(0, 10, function (val) {
     |     rect.attr({
     |         x: val
     |     });
     | }, 1000);
     | // in given context is equivalent to
     | rect.animate({x: 10}, 1000);
    \*/
    Snap.animate = function (from, to, setter, ms, easing, callback) {
        if (typeof easing == "function" && !easing.length) {
            callback = easing;
            easing = mina.linear;
        }
        var now = mina.time(),
            anim = mina(from, to, now, now + ms, mina.time, setter, easing);
        callback && eve.once("mina.finish." + anim.id, callback);
        return anim;
    };
    /*\
     * Element.stop
     [ method ]
     **
     * Stops all the animations for the current element
     **
     = (Element) the current element
    \*/
    elproto.stop = function () {
        var anims = this.inAnim();
        for (var i = 0, ii = anims.length; i < ii; i++) {
            anims[i].stop();
        }
        return this;
    };
    /*\
     * Element.animate
     [ method ]
     **
     * Animates the given attributes of the element
     **
     - attrs (object) key-value pairs of destination attributes
     - duration (number) duration of the animation in milliseconds
     - easing (function) #optional easing function from @mina or custom
     - callback (function) #optional callback function that executes when the animation ends
     = (Element) the current element
    \*/
    elproto.animate = function (attrs, ms, easing, callback) {
        if (typeof easing == "function" && !easing.length) {
            callback = easing;
            easing = mina.linear;
        }
        if (attrs instanceof Animation) {
            callback = attrs.callback;
            easing = attrs.easing;
            ms = attrs.dur;
            attrs = attrs.attr;
        }
        var fkeys = [], tkeys = [], keys = {}, from, to, f, eq,
            el = this;
        for (var key in attrs) if (attrs[has](key)) {
            if (el.equal) {
                eq = el.equal(key, Str(attrs[key]));
                from = eq.from;
                to = eq.to;
                f = eq.f;
            } else {
                from = +el.attr(key);
                to = +attrs[key];
            }
            var len = is(from, "array") ? from.length : 1;
            keys[key] = slice(fkeys.length, fkeys.length + len, f);
            fkeys = fkeys.concat(from);
            tkeys = tkeys.concat(to);
        }
        var now = mina.time(),
            anim = mina(fkeys, tkeys, now, now + ms, mina.time, function (val) {
                var attr = {};
                for (var key in keys) if (keys[has](key)) {
                    attr[key] = keys[key](val);
                }
                el.attr(attr);
            }, easing);
        el.anims[anim.id] = anim;
        anim._attrs = attrs;
        anim._callback = callback;
        eve("snap.animcreated." + el.id, anim);
        eve.once("mina.finish." + anim.id, function () {
            eve.off("mina.*." + anim.id);
            delete el.anims[anim.id];
            callback && callback.call(el);
        });
        eve.once("mina.stop." + anim.id, function () {
            eve.off("mina.*." + anim.id);
            delete el.anims[anim.id];
        });
        return el;
    };
});

// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Snap.plugin(function (Snap, Element, Paper, glob, Fragment) {
    var objectToString = Object.prototype.toString,
        Str = String,
        math = Math,
        E = "";
    function Matrix(a, b, c, d, e, f) {
        if (b == null && objectToString.call(a) == "[object SVGMatrix]") {
            this.a = a.a;
            this.b = a.b;
            this.c = a.c;
            this.d = a.d;
            this.e = a.e;
            this.f = a.f;
            return;
        }
        if (a != null) {
            this.a = +a;
            this.b = +b;
            this.c = +c;
            this.d = +d;
            this.e = +e;
            this.f = +f;
        } else {
            this.a = 1;
            this.b = 0;
            this.c = 0;
            this.d = 1;
            this.e = 0;
            this.f = 0;
        }
    }
    (function (matrixproto) {
        /*\
         * Matrix.add
         [ method ]
         **
         * Adds the given matrix to existing one
         - a (number)
         - b (number)
         - c (number)
         - d (number)
         - e (number)
         - f (number)
         * or
         - matrix (object) @Matrix
        \*/
        matrixproto.add = function (a, b, c, d, e, f) {
            if (a && a instanceof Matrix) {
                return this.add(a.a, a.b, a.c, a.d, a.e, a.f);
            }
            var aNew = a * this.a + b * this.c,
                bNew = a * this.b + b * this.d;
            this.e += e * this.a + f * this.c;
            this.f += e * this.b + f * this.d;
            this.c = c * this.a + d * this.c;
            this.d = c * this.b + d * this.d;

            this.a = aNew;
            this.b = bNew;
            return this;
        };
        /*\
         * Matrix.multLeft
         [ method ]
         **
         * Multiplies a passed affine transform to the left: M * this.
         - a (number)
         - b (number)
         - c (number)
         - d (number)
         - e (number)
         - f (number)
         * or
         - matrix (object) @Matrix
        \*/
        Matrix.prototype.multLeft = function (a, b, c, d, e, f) {
            if (a && a instanceof Matrix) {
                return this.multLeft(a.a, a.b, a.c, a.d, a.e, a.f);
            }
            var aNew = a * this.a + c * this.b,
                cNew = a * this.c + c * this.d,
                eNew = a * this.e + c * this.f + e;
            this.b = b * this.a + d * this.b;
            this.d = b * this.c + d * this.d;
            this.f = b * this.e + d * this.f + f;

            this.a = aNew;
            this.c = cNew;
            this.e = eNew;
            return this;
        };
        /*\
         * Matrix.invert
         [ method ]
         **
         * Returns an inverted version of the matrix
         = (object) @Matrix
        \*/
        matrixproto.invert = function () {
            var me = this,
                x = me.a * me.d - me.b * me.c;
            return new Matrix(me.d / x, -me.b / x, -me.c / x, me.a / x, (me.c * me.f - me.d * me.e) / x, (me.b * me.e - me.a * me.f) / x);
        };
        /*\
         * Matrix.clone
         [ method ]
         **
         * Returns a copy of the matrix
         = (object) @Matrix
        \*/
        matrixproto.clone = function () {
            return new Matrix(this.a, this.b, this.c, this.d, this.e, this.f);
        };
        /*\
         * Matrix.translate
         [ method ]
         **
         * Translate the matrix
         - x (number) horizontal offset distance
         - y (number) vertical offset distance
        \*/
        matrixproto.translate = function (x, y) {
            this.e += x * this.a + y * this.c;
            this.f += x * this.b + y * this.d;
            return this;
        };
        /*\
         * Matrix.scale
         [ method ]
         **
         * Scales the matrix
         - x (number) amount to be scaled, with `1` resulting in no change
         - y (number) #optional amount to scale along the vertical axis. (Otherwise `x` applies to both axes.)
         - cx (number) #optional horizontal origin point from which to scale
         - cy (number) #optional vertical origin point from which to scale
         * Default cx, cy is the middle point of the element.
        \*/
        matrixproto.scale = function (x, y, cx, cy) {
            y == null && (y = x);
            (cx || cy) && this.translate(cx, cy);
            this.a *= x;
            this.b *= x;
            this.c *= y;
            this.d *= y;
            (cx || cy) && this.translate(-cx, -cy);
            return this;
        };
        /*\
         * Matrix.rotate
         [ method ]
         **
         * Rotates the matrix
         - a (number) angle of rotation, in degrees
         - x (number) horizontal origin point from which to rotate
         - y (number) vertical origin point from which to rotate
        \*/
        matrixproto.rotate = function (a, x, y) {
            a = Snap.rad(a);
            x = x || 0;
            y = y || 0;
            var cos = +math.cos(a).toFixed(9),
                sin = +math.sin(a).toFixed(9);
            this.add(cos, sin, -sin, cos, x, y);
            return this.add(1, 0, 0, 1, -x, -y);
        };
        /*\
         * Matrix.skewX
         [ method ]
         **
         * Skews the matrix along the x-axis
         - x (number) Angle to skew along the x-axis (in degrees).
        \*/
        matrixproto.skewX = function (x) {
            return this.skew(x, 0);
        };
        /*\
         * Matrix.skewY
         [ method ]
         **
         * Skews the matrix along the y-axis
         - y (number) Angle to skew along the y-axis (in degrees).
        \*/
        matrixproto.skewY = function (y) {
            return this.skew(0, y);
        };
        /*\
         * Matrix.skew
         [ method ]
         **
         * Skews the matrix
         - y (number) Angle to skew along the y-axis (in degrees).
         - x (number) Angle to skew along the x-axis (in degrees).
        \*/
        matrixproto.skew = function (x, y) {
            x = x || 0;
            y = y || 0;
            x = Snap.rad(x);
            y = Snap.rad(y);
            var c = math.tan(x).toFixed(9);
            var b = math.tan(y).toFixed(9);
            return this.add(1, b, c, 1, 0, 0);
        };
        /*\
         * Matrix.x
         [ method ]
         **
         * Returns x coordinate for given point after transformation described by the matrix. See also @Matrix.y
         - x (number)
         - y (number)
         = (number) x
        \*/
        matrixproto.x = function (x, y) {
            return x * this.a + y * this.c + this.e;
        };
        /*\
         * Matrix.y
         [ method ]
         **
         * Returns y coordinate for given point after transformation described by the matrix. See also @Matrix.x
         - x (number)
         - y (number)
         = (number) y
        \*/
        matrixproto.y = function (x, y) {
            return x * this.b + y * this.d + this.f;
        };
        matrixproto.get = function (i) {
            return +this[Str.fromCharCode(97 + i)].toFixed(4);
        };
        matrixproto.toString = function () {
            return "matrix(" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)].join() + ")";
        };
        matrixproto.offset = function () {
            return [this.e.toFixed(4), this.f.toFixed(4)];
        };
        function norm(a) {
            return a[0] * a[0] + a[1] * a[1];
        }
        function normalize(a) {
            var mag = math.sqrt(norm(a));
            a[0] && (a[0] /= mag);
            a[1] && (a[1] /= mag);
        }
        /*\
         * Matrix.determinant
         [ method ]
         **
         * Finds determinant of the given matrix.
         = (number) determinant
        \*/
        matrixproto.determinant = function () {
            return this.a * this.d - this.b * this.c;
        };
        /*\
         * Matrix.split
         [ method ]
         **
         * Splits matrix into primitive transformations
         = (object) in format:
         o dx (number) translation by x
         o dy (number) translation by y
         o scalex (number) scale by x
         o scaley (number) scale by y
         o shear (number) shear
         o rotate (number) rotation in deg
         o isSimple (boolean) could it be represented via simple transformations
        \*/
        matrixproto.split = function () {
            var out = {};
            // translation
            out.dx = this.e;
            out.dy = this.f;

            // scale and shear
            var row = [[this.a, this.b], [this.c, this.d]];
            out.scalex = math.sqrt(norm(row[0]));
            normalize(row[0]);

            out.shear = row[0][0] * row[1][0] + row[0][1] * row[1][1];
            row[1] = [row[1][0] - row[0][0] * out.shear, row[1][1] - row[0][1] * out.shear];

            out.scaley = math.sqrt(norm(row[1]));
            normalize(row[1]);
            out.shear /= out.scaley;

            if (this.determinant() < 0) {
                out.scalex = -out.scalex;
            }

            // rotation
            var sin = row[0][1],
                cos = row[1][1];
            if (cos < 0) {
                out.rotate = Snap.deg(math.acos(cos));
                if (sin < 0) {
                    out.rotate = 360 - out.rotate;
                }
            } else {
                out.rotate = Snap.deg(math.asin(sin));
            }

            out.isSimple = !+out.shear.toFixed(9) && (out.scalex.toFixed(9) == out.scaley.toFixed(9) || !out.rotate);
            out.isSuperSimple = !+out.shear.toFixed(9) && out.scalex.toFixed(9) == out.scaley.toFixed(9) && !out.rotate;
            out.noRotation = !+out.shear.toFixed(9) && !out.rotate;
            return out;
        };
        /*\
         * Matrix.toTransformString
         [ method ]
         **
         * Returns transform string that represents given matrix
         = (string) transform string
        \*/
        matrixproto.toTransformString = function (shorter) {
            var s = shorter || this.split();
            if (!+s.shear.toFixed(9)) {
                s.scalex = +s.scalex.toFixed(4);
                s.scaley = +s.scaley.toFixed(4);
                s.rotate = +s.rotate.toFixed(4);
                return  (s.dx || s.dy ? "t" + [+s.dx.toFixed(4), +s.dy.toFixed(4)] : E) +
                        (s.rotate ? "r" + [+s.rotate.toFixed(4), 0, 0] : E) +
                        (s.scalex != 1 || s.scaley != 1 ? "s" + [s.scalex, s.scaley, 0, 0] : E);
            } else {
                return "m" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)];
            }
        };
    })(Matrix.prototype);
    /*\
     * Snap.Matrix
     [ method ]
     **
     * Matrix constructor, extend on your own risk.
     * To create matrices use @Snap.matrix.
    \*/
    Snap.Matrix = Matrix;
    /*\
     * Snap.matrix
     [ method ]
     **
     * Utility method
     **
     * Returns a matrix based on the given parameters
     - a (number)
     - b (number)
     - c (number)
     - d (number)
     - e (number)
     - f (number)
     * or
     - svgMatrix (SVGMatrix)
     = (object) @Matrix
    \*/
    Snap.matrix = function (a, b, c, d, e, f) {
        return new Matrix(a, b, c, d, e, f);
    };
});

// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Snap.plugin(function (Snap, Element, Paper, glob, Fragment) {
    var has = "hasOwnProperty",
        make = Snap._.make,
        wrap = Snap._.wrap,
        is = Snap.is,
        getSomeDefs = Snap._.getSomeDefs,
        reURLValue = /^url\((['"]?)([^)]+)\1\)$/,
        $ = Snap._.$,
        URL = Snap.url,
        Str = String,
        separator = Snap._.separator,
        E = "";
    /*\
     * Snap.deurl
     [ method ]
     **
     * Unwraps path from `"url(<path>)"`.
     - value (string) url path
     = (string) unwrapped path
    \*/
    Snap.deurl = function (value) {
        var res = String(value).match(reURLValue);
        return res ? res[2] : value;
    }
    // Attributes event handlers
    eve.on("snap.util.attr.mask", function (value) {
        if (value instanceof Element || value instanceof Fragment) {
            eve.stop();
            if (value instanceof Fragment && value.node.childNodes.length == 1) {
                value = value.node.firstChild;
                getSomeDefs(this).appendChild(value);
                value = wrap(value);
            }
            if (value.type == "mask") {
                var mask = value;
            } else {
                mask = make("mask", getSomeDefs(this));
                mask.node.appendChild(value.node);
            }
            !mask.node.id && $(mask.node, {
                id: mask.id
            });
            $(this.node, {
                mask: URL(mask.id)
            });
        }
    });
    (function (clipIt) {
        eve.on("snap.util.attr.clip", clipIt);
        eve.on("snap.util.attr.clip-path", clipIt);
        eve.on("snap.util.attr.clipPath", clipIt);
    }(function (value) {
        if (value instanceof Element || value instanceof Fragment) {
            eve.stop();
            var clip,
                node = value.node;
            while (node) {
                if (node.nodeName === "clipPath") {
                    clip = new Element(node);
                    break;
                }
                if (node.nodeName === "svg") {
                    clip = undefined;
                    break;
                }
                node = node.parentNode;
            }
            if (!clip) {
                clip = make("clipPath", getSomeDefs(this));
                clip.node.appendChild(value.node);
                !clip.node.id && $(clip.node, {
                    id: clip.id
                });
            }
            $(this.node, {
                "clip-path": URL(clip.node.id || clip.id)
            });
        }
    }));
    function fillStroke(name) {
        return function (value) {
            eve.stop();
            if (value instanceof Fragment && value.node.childNodes.length == 1 &&
                (value.node.firstChild.tagName == "radialGradient" ||
                value.node.firstChild.tagName == "linearGradient" ||
                value.node.firstChild.tagName == "pattern")) {
                value = value.node.firstChild;
                getSomeDefs(this).appendChild(value);
                value = wrap(value);
            }
            if (value instanceof Element) {
                if (value.type == "radialGradient" || value.type == "linearGradient"
                   || value.type == "pattern") {
                    if (!value.node.id) {
                        $(value.node, {
                            id: value.id
                        });
                    }
                    var fill = URL(value.node.id);
                } else {
                    fill = value.attr(name);
                }
            } else {
                fill = Snap.color(value);
                if (fill.error) {
                    var grad = Snap(getSomeDefs(this).ownerSVGElement).gradient(value);
                    if (grad) {
                        if (!grad.node.id) {
                            $(grad.node, {
                                id: grad.id
                            });
                        }
                        fill = URL(grad.node.id);
                    } else {
                        fill = value;
                    }
                } else {
                    fill = Str(fill);
                }
            }
            var attrs = {};
            attrs[name] = fill;
            $(this.node, attrs);
            this.node.style[name] = E;
        };
    }
    eve.on("snap.util.attr.fill", fillStroke("fill"));
    eve.on("snap.util.attr.stroke", fillStroke("stroke"));
    var gradrg = /^([lr])(?:\(([^)]*)\))?(.*)$/i;
    eve.on("snap.util.grad.parse", function parseGrad(string) {
        string = Str(string);
        var tokens = string.match(gradrg);
        if (!tokens) {
            return null;
        }
        var type = tokens[1],
            params = tokens[2],
            stops = tokens[3];
        params = params.split(/\s*,\s*/).map(function (el) {
            return +el == el ? +el : el;
        });
        if (params.length == 1 && params[0] == 0) {
            params = [];
        }
        stops = stops.split("-");
        stops = stops.map(function (el) {
            el = el.split(":");
            var out = {
                color: el[0]
            };
            if (el[1]) {
                out.offset = parseFloat(el[1]);
            }
            return out;
        });
        var len = stops.length,
            start = 0,
            j = 0;
        function seed(i, end) {
            var step = (end - start) / (i - j);
            for (var k = j; k < i; k++) {
                stops[k].offset = +(+start + step * (k - j)).toFixed(2);
            }
            j = i;
            start = end;
        }
        len--;
        for (var i = 0; i < len; i++) if ("offset" in stops[i]) {
            seed(i, stops[i].offset);
        }
        stops[len].offset = stops[len].offset || 100;
        seed(len, stops[len].offset);
        return {
            type: type,
            params: params,
            stops: stops
        };
    });

    eve.on("snap.util.attr.d", function (value) {
        eve.stop();
        if (is(value, "array") && is(value[0], "array")) {
            value = Snap.path.toString.call(value);
        }
        value = Str(value);
        if (value.match(/[ruo]/i)) {
            value = Snap.path.toAbsolute(value);
        }
        $(this.node, {d: value});
    })(-1);
    eve.on("snap.util.attr.#text", function (value) {
        eve.stop();
        value = Str(value);
        var txt = glob.doc.createTextNode(value);
        while (this.node.firstChild) {
            this.node.removeChild(this.node.firstChild);
        }
        this.node.appendChild(txt);
    })(-1);
    eve.on("snap.util.attr.path", function (value) {
        eve.stop();
        this.attr({d: value});
    })(-1);
    eve.on("snap.util.attr.class", function (value) {
        eve.stop();
        this.node.className.baseVal = value;
    })(-1);
    eve.on("snap.util.attr.viewBox", function (value) {
        var vb;
        if (is(value, "object") && "x" in value) {
            vb = [value.x, value.y, value.width, value.height].join(" ");
        } else if (is(value, "array")) {
            vb = value.join(" ");
        } else {
            vb = value;
        }
        $(this.node, {
            viewBox: vb
        });
        eve.stop();
    })(-1);
    eve.on("snap.util.attr.transform", function (value) {
        this.transform(value);
        eve.stop();
    })(-1);
    eve.on("snap.util.attr.r", function (value) {
        if (this.type == "rect") {
            eve.stop();
            $(this.node, {
                rx: value,
                ry: value
            });
        }
    })(-1);
    eve.on("snap.util.attr.textpath", function (value) {
        eve.stop();
        if (this.type == "text") {
            var id, tp, node;
            if (!value && this.textPath) {
                tp = this.textPath;
                while (tp.node.firstChild) {
                    this.node.appendChild(tp.node.firstChild);
                }
                tp.remove();
                delete this.textPath;
                return;
            }
            if (is(value, "string")) {
                var defs = getSomeDefs(this),
                    path = wrap(defs.parentNode).path(value);
                defs.appendChild(path.node);
                id = path.id;
                path.attr({id: id});
            } else {
                value = wrap(value);
                if (value instanceof Element) {
                    id = value.attr("id");
                    if (!id) {
                        id = value.id;
                        value.attr({id: id});
                    }
                }
            }
            if (id) {
                tp = this.textPath;
                node = this.node;
                if (tp) {
                    tp.attr({"xlink:href": "#" + id});
                } else {
                    tp = $("textPath", {
                        "xlink:href": "#" + id
                    });
                    while (node.firstChild) {
                        tp.appendChild(node.firstChild);
                    }
                    node.appendChild(tp);
                    this.textPath = wrap(tp);
                }
            }
        }
    })(-1);
    eve.on("snap.util.attr.text", function (value) {
        if (this.type == "text") {
            var i = 0,
                node = this.node,
                tuner = function (chunk) {
                    var out = $("tspan");
                    if (is(chunk, "array")) {
                        for (var i = 0; i < chunk.length; i++) {
                            out.appendChild(tuner(chunk[i]));
                        }
                    } else {
                        out.appendChild(glob.doc.createTextNode(chunk));
                    }
                    out.normalize && out.normalize();
                    return out;
                };
            while (node.firstChild) {
                node.removeChild(node.firstChild);
            }
            var tuned = tuner(value);
            while (tuned.firstChild) {
                node.appendChild(tuned.firstChild);
            }
        }
        eve.stop();
    })(-1);
    function setFontSize(value) {
        eve.stop();
        if (value == +value) {
            value += "px";
        }
        this.node.style.fontSize = value;
    }
    eve.on("snap.util.attr.fontSize", setFontSize)(-1);
    eve.on("snap.util.attr.font-size", setFontSize)(-1);


    eve.on("snap.util.getattr.transform", function () {
        eve.stop();
        return this.transform();
    })(-1);
    eve.on("snap.util.getattr.textpath", function () {
        eve.stop();
        return this.textPath;
    })(-1);
    // Markers
    (function () {
        function getter(end) {
            return function () {
                eve.stop();
                var style = glob.doc.defaultView.getComputedStyle(this.node, null).getPropertyValue("marker-" + end);
                if (style == "none") {
                    return style;
                } else {
                    return Snap(glob.doc.getElementById(style.match(reURLValue)[1]));
                }
            };
        }
        function setter(end) {
            return function (value) {
                eve.stop();
                var name = "marker" + end.charAt(0).toUpperCase() + end.substring(1);
                if (value == "" || !value) {
                    this.node.style[name] = "none";
                    return;
                }
                if (value.type == "marker") {
                    var id = value.node.id;
                    if (!id) {
                        $(value.node, {id: value.id});
                    }
                    this.node.style[name] = URL(id);
                    return;
                }
            };
        }
        eve.on("snap.util.getattr.marker-end", getter("end"))(-1);
        eve.on("snap.util.getattr.markerEnd", getter("end"))(-1);
        eve.on("snap.util.getattr.marker-start", getter("start"))(-1);
        eve.on("snap.util.getattr.markerStart", getter("start"))(-1);
        eve.on("snap.util.getattr.marker-mid", getter("mid"))(-1);
        eve.on("snap.util.getattr.markerMid", getter("mid"))(-1);
        eve.on("snap.util.attr.marker-end", setter("end"))(-1);
        eve.on("snap.util.attr.markerEnd", setter("end"))(-1);
        eve.on("snap.util.attr.marker-start", setter("start"))(-1);
        eve.on("snap.util.attr.markerStart", setter("start"))(-1);
        eve.on("snap.util.attr.marker-mid", setter("mid"))(-1);
        eve.on("snap.util.attr.markerMid", setter("mid"))(-1);
    }());
    eve.on("snap.util.getattr.r", function () {
        if (this.type == "rect" && $(this.node, "rx") == $(this.node, "ry")) {
            eve.stop();
            return $(this.node, "rx");
        }
    })(-1);
    function textExtract(node) {
        var out = [];
        var children = node.childNodes;
        for (var i = 0, ii = children.length; i < ii; i++) {
            var chi = children[i];
            if (chi.nodeType == 3) {
                out.push(chi.nodeValue);
            }
            if (chi.tagName == "tspan") {
                if (chi.childNodes.length == 1 && chi.firstChild.nodeType == 3) {
                    out.push(chi.firstChild.nodeValue);
                } else {
                    out.push(textExtract(chi));
                }
            }
        }
        return out;
    }
    eve.on("snap.util.getattr.text", function () {
        if (this.type == "text" || this.type == "tspan") {
            eve.stop();
            var out = textExtract(this.node);
            return out.length == 1 ? out[0] : out;
        }
    })(-1);
    eve.on("snap.util.getattr.#text", function () {
        return this.node.textContent;
    })(-1);
    eve.on("snap.util.getattr.fill", function (internal) {
        if (internal) {
            return;
        }
        eve.stop();
        var value = eve("snap.util.getattr.fill", this, true).firstDefined();
        return Snap(Snap.deurl(value)) || value;
    })(-1);
    eve.on("snap.util.getattr.stroke", function (internal) {
        if (internal) {
            return;
        }
        eve.stop();
        var value = eve("snap.util.getattr.stroke", this, true).firstDefined();
        return Snap(Snap.deurl(value)) || value;
    })(-1);
    eve.on("snap.util.getattr.viewBox", function () {
        eve.stop();
        var vb = $(this.node, "viewBox");
        if (vb) {
            vb = vb.split(separator);
            return Snap._.box(+vb[0], +vb[1], +vb[2], +vb[3]);
        } else {
            return;
        }
    })(-1);
    eve.on("snap.util.getattr.points", function () {
        var p = $(this.node, "points");
        eve.stop();
        if (p) {
            return p.split(separator);
        } else {
            return;
        }
    })(-1);
    eve.on("snap.util.getattr.path", function () {
        var p = $(this.node, "d");
        eve.stop();
        return p;
    })(-1);
    eve.on("snap.util.getattr.class", function () {
        return this.node.className.baseVal;
    })(-1);
    function getFontSize() {
        eve.stop();
        return this.node.style.fontSize;
    }
    eve.on("snap.util.getattr.fontSize", getFontSize)(-1);
    eve.on("snap.util.getattr.font-size", getFontSize)(-1);
});

// Copyright (c) 2014 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Snap.plugin(function (Snap, Element, Paper, glob, Fragment) {
    var rgNotSpace = /\S+/g,
        rgBadSpace = /[\t\r\n\f]/g,
        rgTrim = /(^\s+|\s+$)/g,
        Str = String,
        elproto = Element.prototype;
    /*\
     * Element.addClass
     [ method ]
     **
     * Adds given class name or list of class names to the element.
     - value (string) class name or space separated list of class names
     **
     = (Element) original element.
    \*/
    elproto.addClass = function (value) {
        var classes = Str(value || "").match(rgNotSpace) || [],
            elem = this.node,
            className = elem.className.baseVal,
            curClasses = className.match(rgNotSpace) || [],
            j,
            pos,
            clazz,
            finalValue;

        if (classes.length) {
            j = 0;
            while (clazz = classes[j++]) {
                pos = curClasses.indexOf(clazz);
                if (!~pos) {
                    curClasses.push(clazz);
                }
            }

            finalValue = curClasses.join(" ");
            if (className != finalValue) {
                elem.className.baseVal = finalValue;
            }
        }
        return this;
    };
    /*\
     * Element.removeClass
     [ method ]
     **
     * Removes given class name or list of class names from the element.
     - value (string) class name or space separated list of class names
     **
     = (Element) original element.
    \*/
    elproto.removeClass = function (value) {
        var classes = Str(value || "").match(rgNotSpace) || [],
            elem = this.node,
            className = elem.className.baseVal,
            curClasses = className.match(rgNotSpace) || [],
            j,
            pos,
            clazz,
            finalValue;
        if (curClasses.length) {
            j = 0;
            while (clazz = classes[j++]) {
                pos = curClasses.indexOf(clazz);
                if (~pos) {
                    curClasses.splice(pos, 1);
                }
            }

            finalValue = curClasses.join(" ");
            if (className != finalValue) {
                elem.className.baseVal = finalValue;
            }
        }
        return this;
    };
    /*\
     * Element.hasClass
     [ method ]
     **
     * Checks if the element has a given class name in the list of class names applied to it.
     - value (string) class name
     **
     = (boolean) `true` if the element has given class
    \*/
    elproto.hasClass = function (value) {
        var elem = this.node,
            className = elem.className.baseVal,
            curClasses = className.match(rgNotSpace) || [];
        return !!~curClasses.indexOf(value);
    };
    /*\
     * Element.toggleClass
     [ method ]
     **
     * Add or remove one or more classes from the element, depending on either
     * the class’s presence or the value of the `flag` argument.
     - value (string) class name or space separated list of class names
     - flag (boolean) value to determine whether the class should be added or removed
     **
     = (Element) original element.
    \*/
    elproto.toggleClass = function (value, flag) {
        if (flag != null) {
            if (flag) {
                return this.addClass(value);
            } else {
                return this.removeClass(value);
            }
        }
        var classes = (value || "").match(rgNotSpace) || [],
            elem = this.node,
            className = elem.className.baseVal,
            curClasses = className.match(rgNotSpace) || [],
            j,
            pos,
            clazz,
            finalValue;
        j = 0;
        while (clazz = classes[j++]) {
            pos = curClasses.indexOf(clazz);
            if (~pos) {
                curClasses.splice(pos, 1);
            } else {
                curClasses.push(clazz);
            }
        }

        finalValue = curClasses.join(" ");
        if (className != finalValue) {
            elem.className.baseVal = finalValue;
        }
        return this;
    };
});

// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Snap.plugin(function (Snap, Element, Paper, glob, Fragment) {
    var operators = {
            "+": function (x, y) {
                    return x + y;
                },
            "-": function (x, y) {
                    return x - y;
                },
            "/": function (x, y) {
                    return x / y;
                },
            "*": function (x, y) {
                    return x * y;
                }
        },
        Str = String,
        reUnit = /[a-z]+$/i,
        reAddon = /^\s*([+\-\/*])\s*=\s*([\d.eE+\-]+)\s*([^\d\s]+)?\s*$/;
    function getNumber(val) {
        return val;
    }
    function getUnit(unit) {
        return function (val) {
            return +val.toFixed(3) + unit;
        };
    }
    eve.on("snap.util.attr", function (val) {
        var plus = Str(val).match(reAddon);
        if (plus) {
            var evnt = eve.nt(),
                name = evnt.substring(evnt.lastIndexOf(".") + 1),
                a = this.attr(name),
                atr = {};
            eve.stop();
            var unit = plus[3] || "",
                aUnit = a.match(reUnit),
                op = operators[plus[1]];
            if (aUnit && aUnit == unit) {
                val = op(parseFloat(a), +plus[2]);
            } else {
                a = this.asPX(name);
                val = op(this.asPX(name), this.asPX(name, plus[2] + unit));
            }
            if (isNaN(a) || isNaN(val)) {
                return;
            }
            atr[name] = val;
            this.attr(atr);
        }
    })(-10);
    eve.on("snap.util.equal", function (name, b) {
        var A, B, a = Str(this.attr(name) || ""),
            el = this,
            bplus = Str(b).match(reAddon);
        if (bplus) {
            eve.stop();
            var unit = bplus[3] || "",
                aUnit = a.match(reUnit),
                op = operators[bplus[1]];
            if (aUnit && aUnit == unit) {
                return {
                    from: parseFloat(a),
                    to: op(parseFloat(a), +bplus[2]),
                    f: getUnit(aUnit)
                };
            } else {
                a = this.asPX(name);
                return {
                    from: a,
                    to: op(a, this.asPX(name, bplus[2] + unit)),
                    f: getNumber
                };
            }
        }
    })(-10);
});

// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Snap.plugin(function (Snap, Element, Paper, glob, Fragment) {
    var proto = Paper.prototype,
        is = Snap.is;
    /*\
     * Paper.rect
     [ method ]
     *
     * Draws a rectangle
     **
     - x (number) x coordinate of the top left corner
     - y (number) y coordinate of the top left corner
     - width (number) width
     - height (number) height
     - rx (number) #optional horizontal radius for rounded corners, default is 0
     - ry (number) #optional vertical radius for rounded corners, default is rx or 0
     = (object) the `rect` element
     **
     > Usage
     | // regular rectangle
     | var c = paper.rect(10, 10, 50, 50);
     | // rectangle with rounded corners
     | var c = paper.rect(40, 40, 50, 50, 10);
    \*/
    proto.rect = function (x, y, w, h, rx, ry) {
        var attr;
        if (ry == null) {
            ry = rx;
        }
        if (is(x, "object") && x == "[object Object]") {
            attr = x;
        } else if (x != null) {
            attr = {
                x: x,
                y: y,
                width: w,
                height: h
            };
            if (rx != null) {
                attr.rx = rx;
                attr.ry = ry;
            }
        }
        return this.el("rect", attr);
    };
    /*\
     * Paper.circle
     [ method ]
     **
     * Draws a circle
     **
     - x (number) x coordinate of the centre
     - y (number) y coordinate of the centre
     - r (number) radius
     = (object) the `circle` element
     **
     > Usage
     | var c = paper.circle(50, 50, 40);
    \*/
    proto.circle = function (cx, cy, r) {
        var attr;
        if (is(cx, "object") && cx == "[object Object]") {
            attr = cx;
        } else if (cx != null) {
            attr = {
                cx: cx,
                cy: cy,
                r: r
            };
        }
        return this.el("circle", attr);
    };

    var preload = (function () {
        function onerror() {
            this.parentNode.removeChild(this);
        }
        return function (src, f) {
            var img = glob.doc.createElement("img"),
                body = glob.doc.body;
            img.style.cssText = "position:absolute;left:-9999em;top:-9999em";
            img.onload = function () {
                f.call(img);
                img.onload = img.onerror = null;
                body.removeChild(img);
            };
            img.onerror = onerror;
            body.appendChild(img);
            img.src = src;
        };
    }());

    /*\
     * Paper.image
     [ method ]
     **
     * Places an image on the surface
     **
     - src (string) URI of the source image
     - x (number) x offset position
     - y (number) y offset position
     - width (number) width of the image
     - height (number) height of the image
     = (object) the `image` element
     * or
     = (object) Snap element object with type `image`
     **
     > Usage
     | var c = paper.image("apple.png", 10, 10, 80, 80);
    \*/
    proto.image = function (src, x, y, width, height) {
        var el = this.el("image");
        if (is(src, "object") && "src" in src) {
            el.attr(src);
        } else if (src != null) {
            var set = {
                "xlink:href": src,
                preserveAspectRatio: "none"
            };
            if (x != null && y != null) {
                set.x = x;
                set.y = y;
            }
            if (width != null && height != null) {
                set.width = width;
                set.height = height;
            } else {
                preload(src, function () {
                    Snap._.$(el.node, {
                        width: this.offsetWidth,
                        height: this.offsetHeight
                    });
                });
            }
            Snap._.$(el.node, set);
        }
        return el;
    };
    /*\
     * Paper.ellipse
     [ method ]
     **
     * Draws an ellipse
     **
     - x (number) x coordinate of the centre
     - y (number) y coordinate of the centre
     - rx (number) horizontal radius
     - ry (number) vertical radius
     = (object) the `ellipse` element
     **
     > Usage
     | var c = paper.ellipse(50, 50, 40, 20);
    \*/
    proto.ellipse = function (cx, cy, rx, ry) {
        var attr;
        if (is(cx, "object") && cx == "[object Object]") {
            attr = cx;
        } else if (cx != null) {
            attr ={
                cx: cx,
                cy: cy,
                rx: rx,
                ry: ry
            };
        }
        return this.el("ellipse", attr);
    };
    // SIERRA Paper.path(): Unclear from the link what a Catmull-Rom curveto is, and why it would make life any easier.
    /*\
     * Paper.path
     [ method ]
     **
     * Creates a `<path>` element using the given string as the path's definition
     - pathString (string) #optional path string in SVG format
     * Path string consists of one-letter commands, followed by comma seprarated arguments in numerical form. Example:
     | "M10,20L30,40"
     * This example features two commands: `M`, with arguments `(10, 20)` and `L` with arguments `(30, 40)`. Uppercase letter commands express coordinates in absolute terms, while lowercase commands express them in relative terms from the most recently declared coordinates.
     *
     # <p>Here is short list of commands available, for more details see <a href="http://www.w3.org/TR/SVG/paths.html#PathData" title="Details of a path's data attribute's format are described in the SVG specification.">SVG path string format</a> or <a href="https://developer.mozilla.org/en/SVG/Tutorial/Paths">article about path strings at MDN</a>.</p>
     # <table><thead><tr><th>Command</th><th>Name</th><th>Parameters</th></tr></thead><tbody>
     # <tr><td>M</td><td>moveto</td><td>(x y)+</td></tr>
     # <tr><td>Z</td><td>closepath</td><td>(none)</td></tr>
     # <tr><td>L</td><td>lineto</td><td>(x y)+</td></tr>
     # <tr><td>H</td><td>horizontal lineto</td><td>x+</td></tr>
     # <tr><td>V</td><td>vertical lineto</td><td>y+</td></tr>
     # <tr><td>C</td><td>curveto</td><td>(x1 y1 x2 y2 x y)+</td></tr>
     # <tr><td>S</td><td>smooth curveto</td><td>(x2 y2 x y)+</td></tr>
     # <tr><td>Q</td><td>quadratic Bézier curveto</td><td>(x1 y1 x y)+</td></tr>
     # <tr><td>T</td><td>smooth quadratic Bézier curveto</td><td>(x y)+</td></tr>
     # <tr><td>A</td><td>elliptical arc</td><td>(rx ry x-axis-rotation large-arc-flag sweep-flag x y)+</td></tr>
     # <tr><td>R</td><td><a href="http://en.wikipedia.org/wiki/Catmull–Rom_spline#Catmull.E2.80.93Rom_spline">Catmull-Rom curveto</a>*</td><td>x1 y1 (x y)+</td></tr></tbody></table>
     * * _Catmull-Rom curveto_ is a not standard SVG command and added to make life easier.
     * Note: there is a special case when a path consists of only three commands: `M10,10R…z`. In this case the path connects back to its starting point.
     > Usage
     | var c = paper.path("M10 10L90 90");
     | // draw a diagonal line:
     | // move to 10,10, line to 90,90
    \*/
    proto.path = function (d) {
        var attr;
        if (is(d, "object") && !is(d, "array")) {
            attr = d;
        } else if (d) {
            attr = {d: d};
        }
        return this.el("path", attr);
    };
    /*\
     * Paper.g
     [ method ]
     **
     * Creates a group element
     **
     - varargs (…) #optional elements to nest within the group
     = (object) the `g` element
     **
     > Usage
     | var c1 = paper.circle(),
     |     c2 = paper.rect(),
     |     g = paper.g(c2, c1); // note that the order of elements is different
     * or
     | var c1 = paper.circle(),
     |     c2 = paper.rect(),
     |     g = paper.g();
     | g.add(c2, c1);
    \*/
    /*\
     * Paper.group
     [ method ]
     **
     * See @Paper.g
    \*/
    proto.group = proto.g = function (first) {
        var attr,
            el = this.el("g");
        if (arguments.length == 1 && first && !first.type) {
            el.attr(first);
        } else if (arguments.length) {
            el.add(Array.prototype.slice.call(arguments, 0));
        }
        return el;
    };
    /*\
     * Paper.svg
     [ method ]
     **
     * Creates a nested SVG element.
     - x (number) @optional X of the element
     - y (number) @optional Y of the element
     - width (number) @optional width of the element
     - height (number) @optional height of the element
     - vbx (number) @optional viewbox X
     - vby (number) @optional viewbox Y
     - vbw (number) @optional viewbox width
     - vbh (number) @optional viewbox height
     **
     = (object) the `svg` element
     **
    \*/
    proto.svg = function (x, y, width, height, vbx, vby, vbw, vbh) {
        var attrs = {};
        if (is(x, "object") && y == null) {
            attrs = x;
        } else {
            if (x != null) {
                attrs.x = x;
            }
            if (y != null) {
                attrs.y = y;
            }
            if (width != null) {
                attrs.width = width;
            }
            if (height != null) {
                attrs.height = height;
            }
            if (vbx != null && vby != null && vbw != null && vbh != null) {
                attrs.viewBox = [vbx, vby, vbw, vbh];
            }
        }
        return this.el("svg", attrs);
    };
    /*\
     * Paper.mask
     [ method ]
     **
     * Equivalent in behaviour to @Paper.g, except it’s a mask.
     **
     = (object) the `mask` element
     **
    \*/
    proto.mask = function (first) {
        var attr,
            el = this.el("mask");
        if (arguments.length == 1 && first && !first.type) {
            el.attr(first);
        } else if (arguments.length) {
            el.add(Array.prototype.slice.call(arguments, 0));
        }
        return el;
    };
    /*\
     * Paper.ptrn
     [ method ]
     **
     * Equivalent in behaviour to @Paper.g, except it’s a pattern.
     - x (number) @optional X of the element
     - y (number) @optional Y of the element
     - width (number) @optional width of the element
     - height (number) @optional height of the element
     - vbx (number) @optional viewbox X
     - vby (number) @optional viewbox Y
     - vbw (number) @optional viewbox width
     - vbh (number) @optional viewbox height
     **
     = (object) the `pattern` element
     **
    \*/
    proto.ptrn = function (x, y, width, height, vx, vy, vw, vh) {
        if (is(x, "object")) {
            var attr = x;
        } else {
            attr = {patternUnits: "userSpaceOnUse"};
            if (x) {
                attr.x = x;
            }
            if (y) {
                attr.y = y;
            }
            if (width != null) {
                attr.width = width;
            }
            if (height != null) {
                attr.height = height;
            }
            if (vx != null && vy != null && vw != null && vh != null) {
                attr.viewBox = [vx, vy, vw, vh];
            } else {
                attr.viewBox = [x || 0, y || 0, width || 0, height || 0];
            }
        }
        return this.el("pattern", attr);
    };
    /*\
     * Paper.use
     [ method ]
     **
     * Creates a <use> element.
     - id (string) @optional id of element to link
     * or
     - id (Element) @optional element to link
     **
     = (object) the `use` element
     **
    \*/
    proto.use = function (id) {
        if (id != null) {
            if (id instanceof Element) {
                if (!id.attr("id")) {
                    id.attr({id: Snap._.id(id)});
                }
                id = id.attr("id");
            }
            if (String(id).charAt() == "#") {
                id = id.substring(1);
            }
            return this.el("use", {"xlink:href": "#" + id});
        } else {
            return Element.prototype.use.call(this);
        }
    };
    /*\
     * Paper.symbol
     [ method ]
     **
     * Creates a <symbol> element.
     - vbx (number) @optional viewbox X
     - vby (number) @optional viewbox Y
     - vbw (number) @optional viewbox width
     - vbh (number) @optional viewbox height
     = (object) the `symbol` element
     **
    \*/
    proto.symbol = function (vx, vy, vw, vh) {
        var attr = {};
        if (vx != null && vy != null && vw != null && vh != null) {
            attr.viewBox = [vx, vy, vw, vh];
        }

        return this.el("symbol", attr);
    };
    /*\
     * Paper.text
     [ method ]
     **
     * Draws a text string
     **
     - x (number) x coordinate position
     - y (number) y coordinate position
     - text (string|array) The text string to draw or array of strings to nest within separate `<tspan>` elements
     = (object) the `text` element
     **
     > Usage
     | var t1 = paper.text(50, 50, "Snap");
     | var t2 = paper.text(50, 50, ["S","n","a","p"]);
     | // Text path usage
     | t1.attr({textpath: "M10,10L100,100"});
     | // or
     | var pth = paper.path("M10,10L100,100");
     | t1.attr({textpath: pth});
    \*/
    proto.text = function (x, y, text) {
        var attr = {};
        if (is(x, "object")) {
            attr = x;
        } else if (x != null) {
            attr = {
                x: x,
                y: y,
                text: text || ""
            };
        }
        return this.el("text", attr);
    };
    /*\
     * Paper.line
     [ method ]
     **
     * Draws a line
     **
     - x1 (number) x coordinate position of the start
     - y1 (number) y coordinate position of the start
     - x2 (number) x coordinate position of the end
     - y2 (number) y coordinate position of the end
     = (object) the `line` element
     **
     > Usage
     | var t1 = paper.line(50, 50, 100, 100);
    \*/
    proto.line = function (x1, y1, x2, y2) {
        var attr = {};
        if (is(x1, "object")) {
            attr = x1;
        } else if (x1 != null) {
            attr = {
                x1: x1,
                x2: x2,
                y1: y1,
                y2: y2
            };
        }
        return this.el("line", attr);
    };
    /*\
     * Paper.polyline
     [ method ]
     **
     * Draws a polyline
     **
     - points (array) array of points
     * or
     - varargs (…) points
     = (object) the `polyline` element
     **
     > Usage
     | var p1 = paper.polyline([10, 10, 100, 100]);
     | var p2 = paper.polyline(10, 10, 100, 100);
    \*/
    proto.polyline = function (points) {
        if (arguments.length > 1) {
            points = Array.prototype.slice.call(arguments, 0);
        }
        var attr = {};
        if (is(points, "object") && !is(points, "array")) {
            attr = points;
        } else if (points != null) {
            attr = {points: points};
        }
        return this.el("polyline", attr);
    };
    /*\
     * Paper.polygon
     [ method ]
     **
     * Draws a polygon. See @Paper.polyline
    \*/
    proto.polygon = function (points) {
        if (arguments.length > 1) {
            points = Array.prototype.slice.call(arguments, 0);
        }
        var attr = {};
        if (is(points, "object") && !is(points, "array")) {
            attr = points;
        } else if (points != null) {
            attr = {points: points};
        }
        return this.el("polygon", attr);
    };
    // gradients
    (function () {
        var $ = Snap._.$;
        // gradients' helpers
        /*\
         * Element.stops
         [ method ]
         **
         * Only for gradients!
         * Returns array of gradient stops elements.
         = (array) the stops array.
        \*/
        function Gstops() {
            return this.selectAll("stop");
        }
        /*\
         * Element.addStop
         [ method ]
         **
         * Only for gradients!
         * Adds another stop to the gradient.
         - color (string) stops color
         - offset (number) stops offset 0..100
         = (object) gradient element
        \*/
        function GaddStop(color, offset) {
            var stop = $("stop"),
                attr = {
                    offset: +offset + "%"
                };
            color = Snap.color(color);
            attr["stop-color"] = color.hex;
            if (color.opacity < 1) {
                attr["stop-opacity"] = color.opacity;
            }
            $(stop, attr);
            var stops = this.stops(),
                inserted;
            for (var i = 0; i < stops.length; i++) {
                var stopOffset = parseFloat(stops[i].attr("offset"));
                if (stopOffset > offset) {
                    this.node.insertBefore(stop, stops[i].node);
                    inserted = true;
                    break;
                }
            }
            if (!inserted) {
                this.node.appendChild(stop);
            }
            return this;
        }
        function GgetBBox() {
            if (this.type == "linearGradient") {
                var x1 = $(this.node, "x1") || 0,
                    x2 = $(this.node, "x2") || 1,
                    y1 = $(this.node, "y1") || 0,
                    y2 = $(this.node, "y2") || 0;
                return Snap._.box(x1, y1, math.abs(x2 - x1), math.abs(y2 - y1));
            } else {
                var cx = this.node.cx || .5,
                    cy = this.node.cy || .5,
                    r = this.node.r || 0;
                return Snap._.box(cx - r, cy - r, r * 2, r * 2);
            }
        }
        /*\
         * Element.setStops
         [ method ]
         **
         * Only for gradients!
         * Updates stops of the gradient based on passed gradient descriptor. See @Ppaer.gradient
         - str (string) gradient descriptor part after `()`.
         = (object) gradient element
         | var g = paper.gradient("l(0, 0, 1, 1)#000-#f00-#fff");
         | g.setStops("#fff-#000-#f00-#fc0");
        \*/
        function GsetStops(str) {
            var grad = str,
                stops = this.stops();
            if (typeof str == "string") {
                grad = eve("snap.util.grad.parse", null, "l(0,0,0,1)" + str).firstDefined().stops;
            }
            if (!Snap.is(grad, "array")) {
                return;
            }
            for (var i = 0; i < stops.length; i++) {
                if (grad[i]) {
                    var color = Snap.color(grad[i].color),
                        attr = {"offset": grad[i].offset + "%"};
                    attr["stop-color"] = color.hex;
                    if (color.opacity < 1) {
                        attr["stop-opacity"] = color.opacity;
                    }
                    stops[i].attr(attr);
                } else {
                    stops[i].remove();
                }
            }
            for (i = stops.length; i < grad.length; i++) {
                this.addStop(grad[i].color, grad[i].offset);
            }
            return this;
        }
        function gradient(defs, str) {
            var grad = eve("snap.util.grad.parse", null, str).firstDefined(),
                el;
            if (!grad) {
                return null;
            }
            grad.params.unshift(defs);
            if (grad.type.toLowerCase() == "l") {
                el = gradientLinear.apply(0, grad.params);
            } else {
                el = gradientRadial.apply(0, grad.params);
            }
            if (grad.type != grad.type.toLowerCase()) {
                $(el.node, {
                    gradientUnits: "userSpaceOnUse"
                });
            }
            var stops = grad.stops,
                len = stops.length;
            for (var i = 0; i < len; i++) {
                var stop = stops[i];
                el.addStop(stop.color, stop.offset);
            }
            return el;
        }
        function gradientLinear(defs, x1, y1, x2, y2) {
            var el = Snap._.make("linearGradient", defs);
            el.stops = Gstops;
            el.addStop = GaddStop;
            el.getBBox = GgetBBox;
            el.setStops = GsetStops;
            if (x1 != null) {
                $(el.node, {
                    x1: x1,
                    y1: y1,
                    x2: x2,
                    y2: y2
                });
            }
            return el;
        }
        function gradientRadial(defs, cx, cy, r, fx, fy) {
            var el = Snap._.make("radialGradient", defs);
            el.stops = Gstops;
            el.addStop = GaddStop;
            el.getBBox = GgetBBox;
            if (cx != null) {
                $(el.node, {
                    cx: cx,
                    cy: cy,
                    r: r
                });
            }
            if (fx != null && fy != null) {
                $(el.node, {
                    fx: fx,
                    fy: fy
                });
            }
            return el;
        }
        /*\
         * Paper.gradient
         [ method ]
         **
         * Creates a gradient element
         **
         - gradient (string) gradient descriptor
         > Gradient Descriptor
         * The gradient descriptor is an expression formatted as
         * follows: `<type>(<coords>)<colors>`.  The `<type>` can be
         * either linear or radial.  The uppercase `L` or `R` letters
         * indicate absolute coordinates offset from the SVG surface.
         * Lowercase `l` or `r` letters indicate coordinates
         * calculated relative to the element to which the gradient is
         * applied.  Coordinates specify a linear gradient vector as
         * `x1`, `y1`, `x2`, `y2`, or a radial gradient as `cx`, `cy`,
         * `r` and optional `fx`, `fy` specifying a focal point away
         * from the center of the circle. Specify `<colors>` as a list
         * of dash-separated CSS color values.  Each color may be
         * followed by a custom offset value, separated with a colon
         * character.
         > Examples
         * Linear gradient, relative from top-left corner to bottom-right
         * corner, from black through red to white:
         | var g = paper.gradient("l(0, 0, 1, 1)#000-#f00-#fff");
         * Linear gradient, absolute from (0, 0) to (100, 100), from black
         * through red at 25% to white:
         | var g = paper.gradient("L(0, 0, 100, 100)#000-#f00:25-#fff");
         * Radial gradient, relative from the center of the element with radius
         * half the width, from black to white:
         | var g = paper.gradient("r(0.5, 0.5, 0.5)#000-#fff");
         * To apply the gradient:
         | paper.circle(50, 50, 40).attr({
         |     fill: g
         | });
         = (object) the `gradient` element
        \*/
        proto.gradient = function (str) {
            return gradient(this.defs, str);
        };
        proto.gradientLinear = function (x1, y1, x2, y2) {
            return gradientLinear(this.defs, x1, y1, x2, y2);
        };
        proto.gradientRadial = function (cx, cy, r, fx, fy) {
            return gradientRadial(this.defs, cx, cy, r, fx, fy);
        };
        /*\
         * Paper.toString
         [ method ]
         **
         * Returns SVG code for the @Paper
         = (string) SVG code for the @Paper
        \*/
        proto.toString = function () {
            var doc = this.node.ownerDocument,
                f = doc.createDocumentFragment(),
                d = doc.createElement("div"),
                svg = this.node.cloneNode(true),
                res;
            f.appendChild(d);
            d.appendChild(svg);
            Snap._.$(svg, {xmlns: "http://www.w3.org/2000/svg"});
            res = d.innerHTML;
            f.removeChild(f.firstChild);
            return res;
        };
        /*\
         * Paper.toDataURL
         [ method ]
         **
         * Returns SVG code for the @Paper as Data URI string.
         = (string) Data URI string
        \*/
        proto.toDataURL = function () {
            if (window && window.btoa) {
                return "data:image/svg+xml;base64," + btoa(unescape(encodeURIComponent(this)));
            }
        };
        /*\
         * Paper.clear
         [ method ]
         **
         * Removes all child nodes of the paper, except <defs>.
        \*/
        proto.clear = function () {
            var node = this.node.firstChild,
                next;
            while (node) {
                next = node.nextSibling;
                if (node.tagName != "defs") {
                    node.parentNode.removeChild(node);
                } else {
                    proto.clear.call({node: node});
                }
                node = next;
            }
        };
    }());
});

// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Snap.plugin(function (Snap, Element, Paper, glob) {
    var elproto = Element.prototype,
        is = Snap.is,
        clone = Snap._.clone,
        has = "hasOwnProperty",
        p2s = /,?([a-z]),?/gi,
        toFloat = parseFloat,
        math = Math,
        PI = math.PI,
        mmin = math.min,
        mmax = math.max,
        pow = math.pow,
        abs = math.abs;
    function paths(ps) {
        var p = paths.ps = paths.ps || {};
        if (p[ps]) {
            p[ps].sleep = 100;
        } else {
            p[ps] = {
                sleep: 100
            };
        }
        setTimeout(function () {
            for (var key in p) if (p[has](key) && key != ps) {
                p[key].sleep--;
                !p[key].sleep && delete p[key];
            }
        });
        return p[ps];
    }
    function box(x, y, width, height) {
        if (x == null) {
            x = y = width = height = 0;
        }
        if (y == null) {
            y = x.y;
            width = x.width;
            height = x.height;
            x = x.x;
        }
        return {
            x: x,
            y: y,
            width: width,
            w: width,
            height: height,
            h: height,
            x2: x + width,
            y2: y + height,
            cx: x + width / 2,
            cy: y + height / 2,
            r1: math.min(width, height) / 2,
            r2: math.max(width, height) / 2,
            r0: math.sqrt(width * width + height * height) / 2,
            path: rectPath(x, y, width, height),
            vb: [x, y, width, height].join(" ")
        };
    }
    function toString() {
        return this.join(",").replace(p2s, "$1");
    }
    function pathClone(pathArray) {
        var res = clone(pathArray);
        res.toString = toString;
        return res;
    }
    function getPointAtSegmentLength(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length) {
        if (length == null) {
            return bezlen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y);
        } else {
            return findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y,
                getTotLen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length));
        }
    }
    function getLengthFactory(istotal, subpath) {
        function O(val) {
            return +(+val).toFixed(3);
        }
        return Snap._.cacher(function (path, length, onlystart) {
            if (path instanceof Element) {
                path = path.attr("d");
            }
            path = path2curve(path);
            var x, y, p, l, sp = "", subpaths = {}, point,
                len = 0;
            for (var i = 0, ii = path.length; i < ii; i++) {
                p = path[i];
                if (p[0] == "M") {
                    x = +p[1];
                    y = +p[2];
                } else {
                    l = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);
                    if (len + l > length) {
                        if (subpath && !subpaths.start) {
                            point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);
                            sp += [
                                "C" + O(point.start.x),
                                O(point.start.y),
                                O(point.m.x),
                                O(point.m.y),
                                O(point.x),
                                O(point.y)
                            ];
                            if (onlystart) {return sp;}
                            subpaths.start = sp;
                            sp = [
                                "M" + O(point.x),
                                O(point.y) + "C" + O(point.n.x),
                                O(point.n.y),
                                O(point.end.x),
                                O(point.end.y),
                                O(p[5]),
                                O(p[6])
                            ].join();
                            len += l;
                            x = +p[5];
                            y = +p[6];
                            continue;
                        }
                        if (!istotal && !subpath) {
                            point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);
                            return point;
                        }
                    }
                    len += l;
                    x = +p[5];
                    y = +p[6];
                }
                sp += p.shift() + p;
            }
            subpaths.end = sp;
            point = istotal ? len : subpath ? subpaths : findDotsAtSegment(x, y, p[0], p[1], p[2], p[3], p[4], p[5], 1);
            return point;
        }, null, Snap._.clone);
    }
    var getTotalLength = getLengthFactory(1),
        getPointAtLength = getLengthFactory(),
        getSubpathsAtLength = getLengthFactory(0, 1);
    function findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
        var t1 = 1 - t,
            t13 = pow(t1, 3),
            t12 = pow(t1, 2),
            t2 = t * t,
            t3 = t2 * t,
            x = t13 * p1x + t12 * 3 * t * c1x + t1 * 3 * t * t * c2x + t3 * p2x,
            y = t13 * p1y + t12 * 3 * t * c1y + t1 * 3 * t * t * c2y + t3 * p2y,
            mx = p1x + 2 * t * (c1x - p1x) + t2 * (c2x - 2 * c1x + p1x),
            my = p1y + 2 * t * (c1y - p1y) + t2 * (c2y - 2 * c1y + p1y),
            nx = c1x + 2 * t * (c2x - c1x) + t2 * (p2x - 2 * c2x + c1x),
            ny = c1y + 2 * t * (c2y - c1y) + t2 * (p2y - 2 * c2y + c1y),
            ax = t1 * p1x + t * c1x,
            ay = t1 * p1y + t * c1y,
            cx = t1 * c2x + t * p2x,
            cy = t1 * c2y + t * p2y,
            alpha = 90 - math.atan2(mx - nx, my - ny) * 180 / PI;
        // (mx > nx || my < ny) && (alpha += 180);
        return {
            x: x,
            y: y,
            m: {x: mx, y: my},
            n: {x: nx, y: ny},
            start: {x: ax, y: ay},
            end: {x: cx, y: cy},
            alpha: alpha
        };
    }
    function bezierBBox(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
        if (!Snap.is(p1x, "array")) {
            p1x = [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y];
        }
        var bbox = curveDim.apply(null, p1x);
        return box(
            bbox.min.x,
            bbox.min.y,
            bbox.max.x - bbox.min.x,
            bbox.max.y - bbox.min.y
        );
    }
    function isPointInsideBBox(bbox, x, y) {
        return  x >= bbox.x &&
                x <= bbox.x + bbox.width &&
                y >= bbox.y &&
                y <= bbox.y + bbox.height;
    }
    function isBBoxIntersect(bbox1, bbox2) {
        bbox1 = box(bbox1);
        bbox2 = box(bbox2);
        return isPointInsideBBox(bbox2, bbox1.x, bbox1.y)
            || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y)
            || isPointInsideBBox(bbox2, bbox1.x, bbox1.y2)
            || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y2)
            || isPointInsideBBox(bbox1, bbox2.x, bbox2.y)
            || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y)
            || isPointInsideBBox(bbox1, bbox2.x, bbox2.y2)
            || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y2)
            || (bbox1.x < bbox2.x2 && bbox1.x > bbox2.x
                || bbox2.x < bbox1.x2 && bbox2.x > bbox1.x)
            && (bbox1.y < bbox2.y2 && bbox1.y > bbox2.y
                || bbox2.y < bbox1.y2 && bbox2.y > bbox1.y);
    }
    function base3(t, p1, p2, p3, p4) {
        var t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4,
            t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;
        return t * t2 - 3 * p1 + 3 * p2;
    }
    function bezlen(x1, y1, x2, y2, x3, y3, x4, y4, z) {
        if (z == null) {
            z = 1;
        }
        z = z > 1 ? 1 : z < 0 ? 0 : z;
        var z2 = z / 2,
            n = 12,
            Tvalues = [-.1252,.1252,-.3678,.3678,-.5873,.5873,-.7699,.7699,-.9041,.9041,-.9816,.9816],
            Cvalues = [0.2491,0.2491,0.2335,0.2335,0.2032,0.2032,0.1601,0.1601,0.1069,0.1069,0.0472,0.0472],
            sum = 0;
        for (var i = 0; i < n; i++) {
            var ct = z2 * Tvalues[i] + z2,
                xbase = base3(ct, x1, x2, x3, x4),
                ybase = base3(ct, y1, y2, y3, y4),
                comb = xbase * xbase + ybase * ybase;
            sum += Cvalues[i] * math.sqrt(comb);
        }
        return z2 * sum;
    }
    function getTotLen(x1, y1, x2, y2, x3, y3, x4, y4, ll) {
        if (ll < 0 || bezlen(x1, y1, x2, y2, x3, y3, x4, y4) < ll) {
            return;
        }
        var t = 1,
            step = t / 2,
            t2 = t - step,
            l,
            e = .01;
        l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);
        while (abs(l - ll) > e) {
            step /= 2;
            t2 += (l < ll ? 1 : -1) * step;
            l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);
        }
        return t2;
    }
    function intersect(x1, y1, x2, y2, x3, y3, x4, y4) {
        if (
            mmax(x1, x2) < mmin(x3, x4) ||
            mmin(x1, x2) > mmax(x3, x4) ||
            mmax(y1, y2) < mmin(y3, y4) ||
            mmin(y1, y2) > mmax(y3, y4)
        ) {
            return;
        }
        var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),
            ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),
            denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);

        if (!denominator) {
            return;
        }
        var px = nx / denominator,
            py = ny / denominator,
            px2 = +px.toFixed(2),
            py2 = +py.toFixed(2);
        if (
            px2 < +mmin(x1, x2).toFixed(2) ||
            px2 > +mmax(x1, x2).toFixed(2) ||
            px2 < +mmin(x3, x4).toFixed(2) ||
            px2 > +mmax(x3, x4).toFixed(2) ||
            py2 < +mmin(y1, y2).toFixed(2) ||
            py2 > +mmax(y1, y2).toFixed(2) ||
            py2 < +mmin(y3, y4).toFixed(2) ||
            py2 > +mmax(y3, y4).toFixed(2)
        ) {
            return;
        }
        return {x: px, y: py};
    }
    function inter(bez1, bez2) {
        return interHelper(bez1, bez2);
    }
    function interCount(bez1, bez2) {
        return interHelper(bez1, bez2, 1);
    }
    function interHelper(bez1, bez2, justCount) {
        var bbox1 = bezierBBox(bez1),
            bbox2 = bezierBBox(bez2);
        if (!isBBoxIntersect(bbox1, bbox2)) {
            return justCount ? 0 : [];
        }
        var l1 = bezlen.apply(0, bez1),
            l2 = bezlen.apply(0, bez2),
            n1 = ~~(l1 / 8),
            n2 = ~~(l2 / 8),
            dots1 = [],
            dots2 = [],
            xy = {},
            res = justCount ? 0 : [];
        for (var i = 0; i < n1 + 1; i++) {
            var p = findDotsAtSegment.apply(0, bez1.concat(i / n1));
            dots1.push({x: p.x, y: p.y, t: i / n1});
        }
        for (i = 0; i < n2 + 1; i++) {
            p = findDotsAtSegment.apply(0, bez2.concat(i / n2));
            dots2.push({x: p.x, y: p.y, t: i / n2});
        }
        for (i = 0; i < n1; i++) {
            for (var j = 0; j < n2; j++) {
                var di = dots1[i],
                    di1 = dots1[i + 1],
                    dj = dots2[j],
                    dj1 = dots2[j + 1],
                    ci = abs(di1.x - di.x) < .001 ? "y" : "x",
                    cj = abs(dj1.x - dj.x) < .001 ? "y" : "x",
                    is = intersect(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y);
                if (is) {
                    if (xy[is.x.toFixed(4)] == is.y.toFixed(4)) {
                        continue;
                    }
                    xy[is.x.toFixed(4)] = is.y.toFixed(4);
                    var t1 = di.t + abs((is[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t),
                        t2 = dj.t + abs((is[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);
                    if (t1 >= 0 && t1 <= 1 && t2 >= 0 && t2 <= 1) {
                        if (justCount) {
                            res++;
                        } else {
                            res.push({
                                x: is.x,
                                y: is.y,
                                t1: t1,
                                t2: t2
                            });
                        }
                    }
                }
            }
        }
        return res;
    }
    function pathIntersection(path1, path2) {
        return interPathHelper(path1, path2);
    }
    function pathIntersectionNumber(path1, path2) {
        return interPathHelper(path1, path2, 1);
    }
    function interPathHelper(path1, path2, justCount) {
        path1 = path2curve(path1);
        path2 = path2curve(path2);
        var x1, y1, x2, y2, x1m, y1m, x2m, y2m, bez1, bez2,
            res = justCount ? 0 : [];
        for (var i = 0, ii = path1.length; i < ii; i++) {
            var pi = path1[i];
            if (pi[0] == "M") {
                x1 = x1m = pi[1];
                y1 = y1m = pi[2];
            } else {
                if (pi[0] == "C") {
                    bez1 = [x1, y1].concat(pi.slice(1));
                    x1 = bez1[6];
                    y1 = bez1[7];
                } else {
                    bez1 = [x1, y1, x1, y1, x1m, y1m, x1m, y1m];
                    x1 = x1m;
                    y1 = y1m;
                }
                for (var j = 0, jj = path2.length; j < jj; j++) {
                    var pj = path2[j];
                    if (pj[0] == "M") {
                        x2 = x2m = pj[1];
                        y2 = y2m = pj[2];
                    } else {
                        if (pj[0] == "C") {
                            bez2 = [x2, y2].concat(pj.slice(1));
                            x2 = bez2[6];
                            y2 = bez2[7];
                        } else {
                            bez2 = [x2, y2, x2, y2, x2m, y2m, x2m, y2m];
                            x2 = x2m;
                            y2 = y2m;
                        }
                        var intr = interHelper(bez1, bez2, justCount);
                        if (justCount) {
                            res += intr;
                        } else {
                            for (var k = 0, kk = intr.length; k < kk; k++) {
                                intr[k].segment1 = i;
                                intr[k].segment2 = j;
                                intr[k].bez1 = bez1;
                                intr[k].bez2 = bez2;
                            }
                            res = res.concat(intr);
                        }
                    }
                }
            }
        }
        return res;
    }
    function isPointInsidePath(path, x, y) {
        var bbox = pathBBox(path);
        return isPointInsideBBox(bbox, x, y) &&
               interPathHelper(path, [["M", x, y], ["H", bbox.x2 + 10]], 1) % 2 == 1;
    }
    function pathBBox(path) {
        var pth = paths(path);
        if (pth.bbox) {
            return clone(pth.bbox);
        }
        if (!path) {
            return box();
        }
        path = path2curve(path);
        var x = 0,
            y = 0,
            X = [],
            Y = [],
            p;
        for (var i = 0, ii = path.length; i < ii; i++) {
            p = path[i];
            if (p[0] == "M") {
                x = p[1];
                y = p[2];
                X.push(x);
                Y.push(y);
            } else {
                var dim = curveDim(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);
                X = X.concat(dim.min.x, dim.max.x);
                Y = Y.concat(dim.min.y, dim.max.y);
                x = p[5];
                y = p[6];
            }
        }
        var xmin = mmin.apply(0, X),
            ymin = mmin.apply(0, Y),
            xmax = mmax.apply(0, X),
            ymax = mmax.apply(0, Y),
            bb = box(xmin, ymin, xmax - xmin, ymax - ymin);
        pth.bbox = clone(bb);
        return bb;
    }
    function rectPath(x, y, w, h, r) {
        if (r) {
            return [
                ["M", +x + +r, y],
                ["l", w - r * 2, 0],
                ["a", r, r, 0, 0, 1, r, r],
                ["l", 0, h - r * 2],
                ["a", r, r, 0, 0, 1, -r, r],
                ["l", r * 2 - w, 0],
                ["a", r, r, 0, 0, 1, -r, -r],
                ["l", 0, r * 2 - h],
                ["a", r, r, 0, 0, 1, r, -r],
                ["z"]
            ];
        }
        var res = [["M", x, y], ["l", w, 0], ["l", 0, h], ["l", -w, 0], ["z"]];
        res.toString = toString;
        return res;
    }
    function ellipsePath(x, y, rx, ry, a) {
        if (a == null && ry == null) {
            ry = rx;
        }
        x = +x;
        y = +y;
        rx = +rx;
        ry = +ry;
        if (a != null) {
            var rad = Math.PI / 180,
                x1 = x + rx * Math.cos(-ry * rad),
                x2 = x + rx * Math.cos(-a * rad),
                y1 = y + rx * Math.sin(-ry * rad),
                y2 = y + rx * Math.sin(-a * rad),
                res = [["M", x1, y1], ["A", rx, rx, 0, +(a - ry > 180), 0, x2, y2]];
        } else {
            res = [
                ["M", x, y],
                ["m", 0, -ry],
                ["a", rx, ry, 0, 1, 1, 0, 2 * ry],
                ["a", rx, ry, 0, 1, 1, 0, -2 * ry],
                ["z"]
            ];
        }
        res.toString = toString;
        return res;
    }
    var unit2px = Snap._unit2px,
        getPath = {
        path: function (el) {
            return el.attr("path");
        },
        circle: function (el) {
            var attr = unit2px(el);
            return ellipsePath(attr.cx, attr.cy, attr.r);
        },
        ellipse: function (el) {
            var attr = unit2px(el);
            return ellipsePath(attr.cx || 0, attr.cy || 0, attr.rx, attr.ry);
        },
        rect: function (el) {
            var attr = unit2px(el);
            return rectPath(attr.x || 0, attr.y || 0, attr.width, attr.height, attr.rx, attr.ry);
        },
        image: function (el) {
            var attr = unit2px(el);
            return rectPath(attr.x || 0, attr.y || 0, attr.width, attr.height);
        },
        line: function (el) {
            return "M" + [el.attr("x1") || 0, el.attr("y1") || 0, el.attr("x2"), el.attr("y2")];
        },
        polyline: function (el) {
            return "M" + el.attr("points");
        },
        polygon: function (el) {
            return "M" + el.attr("points") + "z";
        },
        deflt: function (el) {
            var bbox = el.node.getBBox();
            return rectPath(bbox.x, bbox.y, bbox.width, bbox.height);
        }
    };
    function pathToRelative(pathArray) {
        var pth = paths(pathArray),
            lowerCase = String.prototype.toLowerCase;
        if (pth.rel) {
            return pathClone(pth.rel);
        }
        if (!Snap.is(pathArray, "array") || !Snap.is(pathArray && pathArray[0], "array")) {
            pathArray = Snap.parsePathString(pathArray);
        }
        var res = [],
            x = 0,
            y = 0,
            mx = 0,
            my = 0,
            start = 0;
        if (pathArray[0][0] == "M") {
            x = pathArray[0][1];
            y = pathArray[0][2];
            mx = x;
            my = y;
            start++;
            res.push(["M", x, y]);
        }
        for (var i = start, ii = pathArray.length; i < ii; i++) {
            var r = res[i] = [],
                pa = pathArray[i];
            if (pa[0] != lowerCase.call(pa[0])) {
                r[0] = lowerCase.call(pa[0]);
                switch (r[0]) {
                    case "a":
                        r[1] = pa[1];
                        r[2] = pa[2];
                        r[3] = pa[3];
                        r[4] = pa[4];
                        r[5] = pa[5];
                        r[6] = +(pa[6] - x).toFixed(3);
                        r[7] = +(pa[7] - y).toFixed(3);
                        break;
                    case "v":
                        r[1] = +(pa[1] - y).toFixed(3);
                        break;
                    case "m":
                        mx = pa[1];
                        my = pa[2];
                    default:
                        for (var j = 1, jj = pa.length; j < jj; j++) {
                            r[j] = +(pa[j] - (j % 2 ? x : y)).toFixed(3);
                        }
                }
            } else {
                r = res[i] = [];
                if (pa[0] == "m") {
                    mx = pa[1] + x;
                    my = pa[2] + y;
                }
                for (var k = 0, kk = pa.length; k < kk; k++) {
                    res[i][k] = pa[k];
                }
            }
            var len = res[i].length;
            switch (res[i][0]) {
                case "z":
                    x = mx;
                    y = my;
                    break;
                case "h":
                    x += +res[i][len - 1];
                    break;
                case "v":
                    y += +res[i][len - 1];
                    break;
                default:
                    x += +res[i][len - 2];
                    y += +res[i][len - 1];
            }
        }
        res.toString = toString;
        pth.rel = pathClone(res);
        return res;
    }
    function pathToAbsolute(pathArray) {
        var pth = paths(pathArray);
        if (pth.abs) {
            return pathClone(pth.abs);
        }
        if (!is(pathArray, "array") || !is(pathArray && pathArray[0], "array")) { // rough assumption
            pathArray = Snap.parsePathString(pathArray);
        }
        if (!pathArray || !pathArray.length) {
            return [["M", 0, 0]];
        }
        var res = [],
            x = 0,
            y = 0,
            mx = 0,
            my = 0,
            start = 0,
            pa0;
        if (pathArray[0][0] == "M") {
            x = +pathArray[0][1];
            y = +pathArray[0][2];
            mx = x;
            my = y;
            start++;
            res[0] = ["M", x, y];
        }
        var crz = pathArray.length == 3 &&
            pathArray[0][0] == "M" &&
            pathArray[1][0].toUpperCase() == "R" &&
            pathArray[2][0].toUpperCase() == "Z";
        for (var r, pa, i = start, ii = pathArray.length; i < ii; i++) {
            res.push(r = []);
            pa = pathArray[i];
            pa0 = pa[0];
            if (pa0 != pa0.toUpperCase()) {
                r[0] = pa0.toUpperCase();
                switch (r[0]) {
                    case "A":
                        r[1] = pa[1];
                        r[2] = pa[2];
                        r[3] = pa[3];
                        r[4] = pa[4];
                        r[5] = pa[5];
                        r[6] = +pa[6] + x;
                        r[7] = +pa[7] + y;
                        break;
                    case "V":
                        r[1] = +pa[1] + y;
                        break;
                    case "H":
                        r[1] = +pa[1] + x;
                        break;
                    case "R":
                        var dots = [x, y].concat(pa.slice(1));
                        for (var j = 2, jj = dots.length; j < jj; j++) {
                            dots[j] = +dots[j] + x;
                            dots[++j] = +dots[j] + y;
                        }
                        res.pop();
                        res = res.concat(catmullRom2bezier(dots, crz));
                        break;
                    case "O":
                        res.pop();
                        dots = ellipsePath(x, y, pa[1], pa[2]);
                        dots.push(dots[0]);
                        res = res.concat(dots);
                        break;
                    case "U":
                        res.pop();
                        res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));
                        r = ["U"].concat(res[res.length - 1].slice(-2));
                        break;
                    case "M":
                        mx = +pa[1] + x;
                        my = +pa[2] + y;
                    default:
                        for (j = 1, jj = pa.length; j < jj; j++) {
                            r[j] = +pa[j] + (j % 2 ? x : y);
                        }
                }
            } else if (pa0 == "R") {
                dots = [x, y].concat(pa.slice(1));
                res.pop();
                res = res.concat(catmullRom2bezier(dots, crz));
                r = ["R"].concat(pa.slice(-2));
            } else if (pa0 == "O") {
                res.pop();
                dots = ellipsePath(x, y, pa[1], pa[2]);
                dots.push(dots[0]);
                res = res.concat(dots);
            } else if (pa0 == "U") {
                res.pop();
                res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));
                r = ["U"].concat(res[res.length - 1].slice(-2));
            } else {
                for (var k = 0, kk = pa.length; k < kk; k++) {
                    r[k] = pa[k];
                }
            }
            pa0 = pa0.toUpperCase();
            if (pa0 != "O") {
                switch (r[0]) {
                    case "Z":
                        x = +mx;
                        y = +my;
                        break;
                    case "H":
                        x = r[1];
                        break;
                    case "V":
                        y = r[1];
                        break;
                    case "M":
                        mx = r[r.length - 2];
                        my = r[r.length - 1];
                    default:
                        x = r[r.length - 2];
                        y = r[r.length - 1];
                }
            }
        }
        res.toString = toString;
        pth.abs = pathClone(res);
        return res;
    }
    function l2c(x1, y1, x2, y2) {
        return [x1, y1, x2, y2, x2, y2];
    }
    function q2c(x1, y1, ax, ay, x2, y2) {
        var _13 = 1 / 3,
            _23 = 2 / 3;
        return [
                _13 * x1 + _23 * ax,
                _13 * y1 + _23 * ay,
                _13 * x2 + _23 * ax,
                _13 * y2 + _23 * ay,
                x2,
                y2
            ];
    }
    function a2c(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {
        // for more information of where this math came from visit:
        // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
        var _120 = PI * 120 / 180,
            rad = PI / 180 * (+angle || 0),
            res = [],
            xy,
            rotate = Snap._.cacher(function (x, y, rad) {
                var X = x * math.cos(rad) - y * math.sin(rad),
                    Y = x * math.sin(rad) + y * math.cos(rad);
                return {x: X, y: Y};
            });
        if (!rx || !ry) {
            return [x1, y1, x2, y2, x2, y2];
        }
        if (!recursive) {
            xy = rotate(x1, y1, -rad);
            x1 = xy.x;
            y1 = xy.y;
            xy = rotate(x2, y2, -rad);
            x2 = xy.x;
            y2 = xy.y;
            var cos = math.cos(PI / 180 * angle),
                sin = math.sin(PI / 180 * angle),
                x = (x1 - x2) / 2,
                y = (y1 - y2) / 2;
            var h = x * x / (rx * rx) + y * y / (ry * ry);
            if (h > 1) {
                h = math.sqrt(h);
                rx = h * rx;
                ry = h * ry;
            }
            var rx2 = rx * rx,
                ry2 = ry * ry,
                k = (large_arc_flag == sweep_flag ? -1 : 1) *
                    math.sqrt(abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x))),
                cx = k * rx * y / ry + (x1 + x2) / 2,
                cy = k * -ry * x / rx + (y1 + y2) / 2,
                f1 = math.asin(((y1 - cy) / ry).toFixed(9)),
                f2 = math.asin(((y2 - cy) / ry).toFixed(9));

            f1 = x1 < cx ? PI - f1 : f1;
            f2 = x2 < cx ? PI - f2 : f2;
            f1 < 0 && (f1 = PI * 2 + f1);
            f2 < 0 && (f2 = PI * 2 + f2);
            if (sweep_flag && f1 > f2) {
                f1 = f1 - PI * 2;
            }
            if (!sweep_flag && f2 > f1) {
                f2 = f2 - PI * 2;
            }
        } else {
            f1 = recursive[0];
            f2 = recursive[1];
            cx = recursive[2];
            cy = recursive[3];
        }
        var df = f2 - f1;
        if (abs(df) > _120) {
            var f2old = f2,
                x2old = x2,
                y2old = y2;
            f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
            x2 = cx + rx * math.cos(f2);
            y2 = cy + ry * math.sin(f2);
            res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);
        }
        df = f2 - f1;
        var c1 = math.cos(f1),
            s1 = math.sin(f1),
            c2 = math.cos(f2),
            s2 = math.sin(f2),
            t = math.tan(df / 4),
            hx = 4 / 3 * rx * t,
            hy = 4 / 3 * ry * t,
            m1 = [x1, y1],
            m2 = [x1 + hx * s1, y1 - hy * c1],
            m3 = [x2 + hx * s2, y2 - hy * c2],
            m4 = [x2, y2];
        m2[0] = 2 * m1[0] - m2[0];
        m2[1] = 2 * m1[1] - m2[1];
        if (recursive) {
            return [m2, m3, m4].concat(res);
        } else {
            res = [m2, m3, m4].concat(res).join().split(",");
            var newres = [];
            for (var i = 0, ii = res.length; i < ii; i++) {
                newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;
            }
            return newres;
        }
    }
    function findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
        var t1 = 1 - t;
        return {
            x: pow(t1, 3) * p1x + pow(t1, 2) * 3 * t * c1x + t1 * 3 * t * t * c2x + pow(t, 3) * p2x,
            y: pow(t1, 3) * p1y + pow(t1, 2) * 3 * t * c1y + t1 * 3 * t * t * c2y + pow(t, 3) * p2y
        };
    }

    // Returns bounding box of cubic bezier curve.
    // Source: http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html
    // Original version: NISHIO Hirokazu
    // Modifications: https://github.com/timo22345
    function curveDim(x0, y0, x1, y1, x2, y2, x3, y3) {
        var tvalues = [],
            bounds = [[], []],
            a, b, c, t, t1, t2, b2ac, sqrtb2ac;
        for (var i = 0; i < 2; ++i) {
            if (i == 0) {
                b = 6 * x0 - 12 * x1 + 6 * x2;
                a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
                c = 3 * x1 - 3 * x0;
            } else {
                b = 6 * y0 - 12 * y1 + 6 * y2;
                a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
                c = 3 * y1 - 3 * y0;
            }
            if (abs(a) < 1e-12) {
                if (abs(b) < 1e-12) {
                    continue;
                }
                t = -c / b;
                if (0 < t && t < 1) {
                    tvalues.push(t);
                }
                continue;
            }
            b2ac = b * b - 4 * c * a;
            sqrtb2ac = math.sqrt(b2ac);
            if (b2ac < 0) {
                continue;
            }
            t1 = (-b + sqrtb2ac) / (2 * a);
            if (0 < t1 && t1 < 1) {
                tvalues.push(t1);
            }
            t2 = (-b - sqrtb2ac) / (2 * a);
            if (0 < t2 && t2 < 1) {
                tvalues.push(t2);
            }
        }

        var x, y, j = tvalues.length,
            jlen = j,
            mt;
        while (j--) {
            t = tvalues[j];
            mt = 1 - t;
            bounds[0][j] = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;
            bounds[1][j] = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;
        }

        bounds[0][jlen] = x0;
        bounds[1][jlen] = y0;
        bounds[0][jlen + 1] = x3;
        bounds[1][jlen + 1] = y3;
        bounds[0].length = bounds[1].length = jlen + 2;


        return {
          min: {x: mmin.apply(0, bounds[0]), y: mmin.apply(0, bounds[1])},
          max: {x: mmax.apply(0, bounds[0]), y: mmax.apply(0, bounds[1])}
        };
    }

    function path2curve(path, path2) {
        var pth = !path2 && paths(path);
        if (!path2 && pth.curve) {
            return pathClone(pth.curve);
        }
        var p = pathToAbsolute(path),
            p2 = path2 && pathToAbsolute(path2),
            attrs = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null},
            attrs2 = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null},
            processPath = function (path, d, pcom) {
                var nx, ny;
                if (!path) {
                    return ["C", d.x, d.y, d.x, d.y, d.x, d.y];
                }
                !(path[0] in {T: 1, Q: 1}) && (d.qx = d.qy = null);
                switch (path[0]) {
                    case "M":
                        d.X = path[1];
                        d.Y = path[2];
                        break;
                    case "A":
                        path = ["C"].concat(a2c.apply(0, [d.x, d.y].concat(path.slice(1))));
                        break;
                    case "S":
                        if (pcom == "C" || pcom == "S") { // In "S" case we have to take into account, if the previous command is C/S.
                            nx = d.x * 2 - d.bx;          // And reflect the previous
                            ny = d.y * 2 - d.by;          // command's control point relative to the current point.
                        }
                        else {                            // or some else or nothing
                            nx = d.x;
                            ny = d.y;
                        }
                        path = ["C", nx, ny].concat(path.slice(1));
                        break;
                    case "T":
                        if (pcom == "Q" || pcom == "T") { // In "T" case we have to take into account, if the previous command is Q/T.
                            d.qx = d.x * 2 - d.qx;        // And make a reflection similar
                            d.qy = d.y * 2 - d.qy;        // to case "S".
                        }
                        else {                            // or something else or nothing
                            d.qx = d.x;
                            d.qy = d.y;
                        }
                        path = ["C"].concat(q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));
                        break;
                    case "Q":
                        d.qx = path[1];
                        d.qy = path[2];
                        path = ["C"].concat(q2c(d.x, d.y, path[1], path[2], path[3], path[4]));
                        break;
                    case "L":
                        path = ["C"].concat(l2c(d.x, d.y, path[1], path[2]));
                        break;
                    case "H":
                        path = ["C"].concat(l2c(d.x, d.y, path[1], d.y));
                        break;
                    case "V":
                        path = ["C"].concat(l2c(d.x, d.y, d.x, path[1]));
                        break;
                    case "Z":
                        path = ["C"].concat(l2c(d.x, d.y, d.X, d.Y));
                        break;
                }
                return path;
            },
            fixArc = function (pp, i) {
                if (pp[i].length > 7) {
                    pp[i].shift();
                    var pi = pp[i];
                    while (pi.length) {
                        pcoms1[i] = "A"; // if created multiple C:s, their original seg is saved
                        p2 && (pcoms2[i] = "A"); // the same as above
                        pp.splice(i++, 0, ["C"].concat(pi.splice(0, 6)));
                    }
                    pp.splice(i, 1);
                    ii = mmax(p.length, p2 && p2.length || 0);
                }
            },
            fixM = function (path1, path2, a1, a2, i) {
                if (path1 && path2 && path1[i][0] == "M" && path2[i][0] != "M") {
                    path2.splice(i, 0, ["M", a2.x, a2.y]);
                    a1.bx = 0;
                    a1.by = 0;
                    a1.x = path1[i][1];
                    a1.y = path1[i][2];
                    ii = mmax(p.length, p2 && p2.length || 0);
                }
            },
            pcoms1 = [], // path commands of original path p
            pcoms2 = [], // path commands of original path p2
            pfirst = "", // temporary holder for original path command
            pcom = ""; // holder for previous path command of original path
        for (var i = 0, ii = mmax(p.length, p2 && p2.length || 0); i < ii; i++) {
            p[i] && (pfirst = p[i][0]); // save current path command

            if (pfirst != "C") // C is not saved yet, because it may be result of conversion
            {
                pcoms1[i] = pfirst; // Save current path command
                i && ( pcom = pcoms1[i - 1]); // Get previous path command pcom
            }
            p[i] = processPath(p[i], attrs, pcom); // Previous path command is inputted to processPath

            if (pcoms1[i] != "A" && pfirst == "C") pcoms1[i] = "C"; // A is the only command
            // which may produce multiple C:s
            // so we have to make sure that C is also C in original path

            fixArc(p, i); // fixArc adds also the right amount of A:s to pcoms1

            if (p2) { // the same procedures is done to p2
                p2[i] && (pfirst = p2[i][0]);
                if (pfirst != "C") {
                    pcoms2[i] = pfirst;
                    i && (pcom = pcoms2[i - 1]);
                }
                p2[i] = processPath(p2[i], attrs2, pcom);

                if (pcoms2[i] != "A" && pfirst == "C") {
                    pcoms2[i] = "C";
                }

                fixArc(p2, i);
            }
            fixM(p, p2, attrs, attrs2, i);
            fixM(p2, p, attrs2, attrs, i);
            var seg = p[i],
                seg2 = p2 && p2[i],
                seglen = seg.length,
                seg2len = p2 && seg2.length;
            attrs.x = seg[seglen - 2];
            attrs.y = seg[seglen - 1];
            attrs.bx = toFloat(seg[seglen - 4]) || attrs.x;
            attrs.by = toFloat(seg[seglen - 3]) || attrs.y;
            attrs2.bx = p2 && (toFloat(seg2[seg2len - 4]) || attrs2.x);
            attrs2.by = p2 && (toFloat(seg2[seg2len - 3]) || attrs2.y);
            attrs2.x = p2 && seg2[seg2len - 2];
            attrs2.y = p2 && seg2[seg2len - 1];
        }
        if (!p2) {
            pth.curve = pathClone(p);
        }
        return p2 ? [p, p2] : p;
    }
    function mapPath(path, matrix) {
        if (!matrix) {
            return path;
        }
        var x, y, i, j, ii, jj, pathi;
        path = path2curve(path);
        for (i = 0, ii = path.length; i < ii; i++) {
            pathi = path[i];
            for (j = 1, jj = pathi.length; j < jj; j += 2) {
                x = matrix.x(pathi[j], pathi[j + 1]);
                y = matrix.y(pathi[j], pathi[j + 1]);
                pathi[j] = x;
                pathi[j + 1] = y;
            }
        }
        return path;
    }

    // http://schepers.cc/getting-to-the-point
    function catmullRom2bezier(crp, z) {
        var d = [];
        for (var i = 0, iLen = crp.length; iLen - 2 * !z > i; i += 2) {
            var p = [
                        {x: +crp[i - 2], y: +crp[i - 1]},
                        {x: +crp[i],     y: +crp[i + 1]},
                        {x: +crp[i + 2], y: +crp[i + 3]},
                        {x: +crp[i + 4], y: +crp[i + 5]}
                    ];
            if (z) {
                if (!i) {
                    p[0] = {x: +crp[iLen - 2], y: +crp[iLen - 1]};
                } else if (iLen - 4 == i) {
                    p[3] = {x: +crp[0], y: +crp[1]};
                } else if (iLen - 2 == i) {
                    p[2] = {x: +crp[0], y: +crp[1]};
                    p[3] = {x: +crp[2], y: +crp[3]};
                }
            } else {
                if (iLen - 4 == i) {
                    p[3] = p[2];
                } else if (!i) {
                    p[0] = {x: +crp[i], y: +crp[i + 1]};
                }
            }
            d.push(["C",
                  (-p[0].x + 6 * p[1].x + p[2].x) / 6,
                  (-p[0].y + 6 * p[1].y + p[2].y) / 6,
                  (p[1].x + 6 * p[2].x - p[3].x) / 6,
                  (p[1].y + 6*p[2].y - p[3].y) / 6,
                  p[2].x,
                  p[2].y
            ]);
        }

        return d;
    }

    // export
    Snap.path = paths;

    /*\
     * Snap.path.getTotalLength
     [ method ]
     **
     * Returns the length of the given path in pixels
     **
     - path (string) SVG path string
     **
     = (number) length
    \*/
    Snap.path.getTotalLength = getTotalLength;
    /*\
     * Snap.path.getPointAtLength
     [ method ]
     **
     * Returns the coordinates of the point located at the given length along the given path
     **
     - path (string) SVG path string
     - length (number) length, in pixels, from the start of the path, excluding non-rendering jumps
     **
     = (object) representation of the point:
     o {
     o     x: (number) x coordinate,
     o     y: (number) y coordinate,
     o     alpha: (number) angle of derivative
     o }
    \*/
    Snap.path.getPointAtLength = getPointAtLength;
    /*\
     * Snap.path.getSubpath
     [ method ]
     **
     * Returns the subpath of a given path between given start and end lengths
     **
     - path (string) SVG path string
     - from (number) length, in pixels, from the start of the path to the start of the segment
     - to (number) length, in pixels, from the start of the path to the end of the segment
     **
     = (string) path string definition for the segment
    \*/
    Snap.path.getSubpath = function (path, from, to) {
        if (this.getTotalLength(path) - to < 1e-6) {
            return getSubpathsAtLength(path, from).end;
        }
        var a = getSubpathsAtLength(path, to, 1);
        return from ? getSubpathsAtLength(a, from).end : a;
    };
    /*\
     * Element.getTotalLength
     [ method ]
     **
     * Returns the length of the path in pixels (only works for `path` elements)
     = (number) length
    \*/
    elproto.getTotalLength = function () {
        if (this.node.getTotalLength) {
            return this.node.getTotalLength();
        }
    };
    // SIERRA Element.getPointAtLength()/Element.getTotalLength(): If a <path> is broken into different segments, is the jump distance to the new coordinates set by the _M_ or _m_ commands calculated as part of the path's total length?
    /*\
     * Element.getPointAtLength
     [ method ]
     **
     * Returns coordinates of the point located at the given length on the given path (only works for `path` elements)
     **
     - length (number) length, in pixels, from the start of the path, excluding non-rendering jumps
     **
     = (object) representation of the point:
     o {
     o     x: (number) x coordinate,
     o     y: (number) y coordinate,
     o     alpha: (number) angle of derivative
     o }
    \*/
    elproto.getPointAtLength = function (length) {
        return getPointAtLength(this.attr("d"), length);
    };
    // SIERRA Element.getSubpath(): Similar to the problem for Element.getPointAtLength(). Unclear how this would work for a segmented path. Overall, the concept of _subpath_ and what I'm calling a _segment_ (series of non-_M_ or _Z_ commands) is unclear.
    /*\
     * Element.getSubpath
     [ method ]
     **
     * Returns subpath of a given element from given start and end lengths (only works for `path` elements)
     **
     - from (number) length, in pixels, from the start of the path to the start of the segment
     - to (number) length, in pixels, from the start of the path to the end of the segment
     **
     = (string) path string definition for the segment
    \*/
    elproto.getSubpath = function (from, to) {
        return Snap.path.getSubpath(this.attr("d"), from, to);
    };
    Snap._.box = box;
    /*\
     * Snap.path.findDotsAtSegment
     [ method ]
     **
     * Utility method
     **
     * Finds dot coordinates on the given cubic beziér curve at the given t
     - p1x (number) x of the first point of the curve
     - p1y (number) y of the first point of the curve
     - c1x (number) x of the first anchor of the curve
     - c1y (number) y of the first anchor of the curve
     - c2x (number) x of the second anchor of the curve
     - c2y (number) y of the second anchor of the curve
     - p2x (number) x of the second point of the curve
     - p2y (number) y of the second point of the curve
     - t (number) position on the curve (0..1)
     = (object) point information in format:
     o {
     o     x: (number) x coordinate of the point,
     o     y: (number) y coordinate of the point,
     o     m: {
     o         x: (number) x coordinate of the left anchor,
     o         y: (number) y coordinate of the left anchor
     o     },
     o     n: {
     o         x: (number) x coordinate of the right anchor,
     o         y: (number) y coordinate of the right anchor
     o     },
     o     start: {
     o         x: (number) x coordinate of the start of the curve,
     o         y: (number) y coordinate of the start of the curve
     o     },
     o     end: {
     o         x: (number) x coordinate of the end of the curve,
     o         y: (number) y coordinate of the end of the curve
     o     },
     o     alpha: (number) angle of the curve derivative at the point
     o }
    \*/
    Snap.path.findDotsAtSegment = findDotsAtSegment;
    /*\
     * Snap.path.bezierBBox
     [ method ]
     **
     * Utility method
     **
     * Returns the bounding box of a given cubic beziér curve
     - p1x (number) x of the first point of the curve
     - p1y (number) y of the first point of the curve
     - c1x (number) x of the first anchor of the curve
     - c1y (number) y of the first anchor of the curve
     - c2x (number) x of the second anchor of the curve
     - c2y (number) y of the second anchor of the curve
     - p2x (number) x of the second point of the curve
     - p2y (number) y of the second point of the curve
     * or
     - bez (array) array of six points for beziér curve
     = (object) bounding box
     o {
     o     x: (number) x coordinate of the left top point of the box,
     o     y: (number) y coordinate of the left top point of the box,
     o     x2: (number) x coordinate of the right bottom point of the box,
     o     y2: (number) y coordinate of the right bottom point of the box,
     o     width: (number) width of the box,
     o     height: (number) height of the box
     o }
    \*/
    Snap.path.bezierBBox = bezierBBox;
    /*\
     * Snap.path.isPointInsideBBox
     [ method ]
     **
     * Utility method
     **
     * Returns `true` if given point is inside bounding box
     - bbox (string) bounding box
     - x (string) x coordinate of the point
     - y (string) y coordinate of the point
     = (boolean) `true` if point is inside
    \*/
    Snap.path.isPointInsideBBox = isPointInsideBBox;
    Snap.closest = function (x, y, X, Y) {
        var r = 100,
            b = box(x - r / 2, y - r / 2, r, r),
            inside = [],
            getter = X[0].hasOwnProperty("x") ? function (i) {
                return {
                    x: X[i].x,
                    y: X[i].y
                };
            } : function (i) {
                return {
                    x: X[i],
                    y: Y[i]
                };
            },
            found = 0;
        while (r <= 1e6 && !found) {
            for (var i = 0, ii = X.length; i < ii; i++) {
                var xy = getter(i);
                if (isPointInsideBBox(b, xy.x, xy.y)) {
                    found++;
                    inside.push(xy);
                    break;
                }
            }
            if (!found) {
                r *= 2;
                b = box(x - r / 2, y - r / 2, r, r)
            }
        }
        if (r == 1e6) {
            return;
        }
        var len = Infinity,
            res;
        for (i = 0, ii = inside.length; i < ii; i++) {
            var l = Snap.len(x, y, inside[i].x, inside[i].y);
            if (len > l) {
                len = l;
                inside[i].len = l;
                res = inside[i];
            }
        }
        return res;
    };
    /*\
     * Snap.path.isBBoxIntersect
     [ method ]
     **
     * Utility method
     **
     * Returns `true` if two bounding boxes intersect
     - bbox1 (string) first bounding box
     - bbox2 (string) second bounding box
     = (boolean) `true` if bounding boxes intersect
    \*/
    Snap.path.isBBoxIntersect = isBBoxIntersect;
    /*\
     * Snap.path.intersection
     [ method ]
     **
     * Utility method
     **
     * Finds intersections of two paths
     - path1 (string) path string
     - path2 (string) path string
     = (array) dots of intersection
     o [
     o     {
     o         x: (number) x coordinate of the point,
     o         y: (number) y coordinate of the point,
     o         t1: (number) t value for segment of path1,
     o         t2: (number) t value for segment of path2,
     o         segment1: (number) order number for segment of path1,
     o         segment2: (number) order number for segment of path2,
     o         bez1: (array) eight coordinates representing beziér curve for the segment of path1,
     o         bez2: (array) eight coordinates representing beziér curve for the segment of path2
     o     }
     o ]
    \*/
    Snap.path.intersection = pathIntersection;
    Snap.path.intersectionNumber = pathIntersectionNumber;
    /*\
     * Snap.path.isPointInside
     [ method ]
     **
     * Utility method
     **
     * Returns `true` if given point is inside a given closed path.
     *
     * Note: fill mode doesn’t affect the result of this method.
     - path (string) path string
     - x (number) x of the point
     - y (number) y of the point
     = (boolean) `true` if point is inside the path
    \*/
    Snap.path.isPointInside = isPointInsidePath;
    /*\
     * Snap.path.getBBox
     [ method ]
     **
     * Utility method
     **
     * Returns the bounding box of a given path
     - path (string) path string
     = (object) bounding box
     o {
     o     x: (number) x coordinate of the left top point of the box,
     o     y: (number) y coordinate of the left top point of the box,
     o     x2: (number) x coordinate of the right bottom point of the box,
     o     y2: (number) y coordinate of the right bottom point of the box,
     o     width: (number) width of the box,
     o     height: (number) height of the box
     o }
    \*/
    Snap.path.getBBox = pathBBox;
    Snap.path.get = getPath;
    /*\
     * Snap.path.toRelative
     [ method ]
     **
     * Utility method
     **
     * Converts path coordinates into relative values
     - path (string) path string
     = (array) path string
    \*/
    Snap.path.toRelative = pathToRelative;
    /*\
     * Snap.path.toAbsolute
     [ method ]
     **
     * Utility method
     **
     * Converts path coordinates into absolute values
     - path (string) path string
     = (array) path string
    \*/
    Snap.path.toAbsolute = pathToAbsolute;
    /*\
     * Snap.path.toCubic
     [ method ]
     **
     * Utility method
     **
     * Converts path to a new path where all segments are cubic beziér curves
     - pathString (string|array) path string or array of segments
     = (array) array of segments
    \*/
    Snap.path.toCubic = path2curve;
    /*\
     * Snap.path.map
     [ method ]
     **
     * Transform the path string with the given matrix
     - path (string) path string
     - matrix (object) see @Matrix
     = (string) transformed path string
    \*/
    Snap.path.map = mapPath;
    Snap.path.toString = toString;
    Snap.path.clone = pathClone;
});

// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Snap.plugin(function (Snap, Element, Paper, glob) {
    var mmax = Math.max,
        mmin = Math.min;

    // Set
    var Set = function (items) {
        this.items = [];
	this.bindings = {};
        this.length = 0;
        this.type = "set";
        if (items) {
            for (var i = 0, ii = items.length; i < ii; i++) {
                if (items[i]) {
                    this[this.items.length] = this.items[this.items.length] = items[i];
                    this.length++;
                }
            }
        }
    },
    setproto = Set.prototype;
    /*\
     * Set.push
     [ method ]
     **
     * Adds each argument to the current set
     = (object) original element
    \*/
    setproto.push = function () {
        var item,
            len;
        for (var i = 0, ii = arguments.length; i < ii; i++) {
            item = arguments[i];
            if (item) {
                len = this.items.length;
                this[len] = this.items[len] = item;
                this.length++;
            }
        }
        return this;
    };
    /*\
     * Set.pop
     [ method ]
     **
     * Removes last element and returns it
     = (object) element
    \*/
    setproto.pop = function () {
        this.length && delete this[this.length--];
        return this.items.pop();
    };
    /*\
     * Set.forEach
     [ method ]
     **
     * Executes given function for each element in the set
     *
     * If the function returns `false`, the loop stops running.
     **
     - callback (function) function to run
     - thisArg (object) context object for the callback
     = (object) Set object
    \*/
    setproto.forEach = function (callback, thisArg) {
        for (var i = 0, ii = this.items.length; i < ii; i++) {
            if (callback.call(thisArg, this.items[i], i) === false) {
                return this;
            }
        }
        return this;
    };
    /*\
     * Set.animate
     [ method ]
     **
     * Animates each element in set in sync.
     *
     **
     - attrs (object) key-value pairs of destination attributes
     - duration (number) duration of the animation in milliseconds
     - easing (function) #optional easing function from @mina or custom
     - callback (function) #optional callback function that executes when the animation ends
     * or
     - animation (array) array of animation parameter for each element in set in format `[attrs, duration, easing, callback]`
     > Usage
     | // animate all elements in set to radius 10
     | set.animate({r: 10}, 500, mina.easein);
     | // or
     | // animate first element to radius 10, but second to radius 20 and in different time
     | set.animate([{r: 10}, 500, mina.easein], [{r: 20}, 1500, mina.easein]);
     = (Element) the current element
    \*/
    setproto.animate = function (attrs, ms, easing, callback) {
        if (typeof easing == "function" && !easing.length) {
            callback = easing;
            easing = mina.linear;
        }
        if (attrs instanceof Snap._.Animation) {
            callback = attrs.callback;
            easing = attrs.easing;
            ms = easing.dur;
            attrs = attrs.attr;
        }
        var args = arguments;
        if (Snap.is(attrs, "array") && Snap.is(args[args.length - 1], "array")) {
            var each = true;
        }
        var begin,
            handler = function () {
                if (begin) {
                    this.b = begin;
                } else {
                    begin = this.b;
                }
            },
            cb = 0,
            set = this,
            callbacker = callback && function () {
                if (++cb == set.length) {
                    callback.call(this);
                }
            };
        return this.forEach(function (el, i) {
            eve.once("snap.animcreated." + el.id, handler);
            if (each) {
                args[i] && el.animate.apply(el, args[i]);
            } else {
                el.animate(attrs, ms, easing, callbacker);
            }
        });
    };
    /*\
     * Set.remove
     [ method ]
     **
     * Removes all children of the set.
     *
     = (object) Set object
    \*/
    setproto.remove = function () {
        while (this.length) {
            this.pop().remove();
        }
        return this;
    };
    /*\
     * Set.bind
     [ method ]
     **
     * Specifies how to handle a specific attribute when applied
     * to a set.
     *
     **
     - attr (string) attribute name
     - callback (function) function to run
     * or
     - attr (string) attribute name
     - element (Element) specific element in the set to apply the attribute to
     * or
     - attr (string) attribute name
     - element (Element) specific element in the set to apply the attribute to
     - eattr (string) attribute on the element to bind the attribute to
     = (object) Set object
    \*/
    setproto.bind = function (attr, a, b) {
        var data = {};
        if (typeof a == "function") {
            this.bindings[attr] = a;
        } else {
            var aname = b || attr;
            this.bindings[attr] = function (v) {
                data[aname] = v;
                a.attr(data);
            };
        }
        return this;
    };
    /*\
     * Set.attr
     [ method ]
     **
     * Equivalent of @Element.attr.
     = (object) Set object
    \*/
    setproto.attr = function (value) {
        var unbound = {};
        for (var k in value) {
            if (this.bindings[k]) {
                this.bindings[k](value[k]);
            } else {
                unbound[k] = value[k];
            }
        }
        for (var i = 0, ii = this.items.length; i < ii; i++) {
            this.items[i].attr(unbound);
        }
        return this;
    };
    /*\
     * Set.clear
     [ method ]
     **
     * Removes all elements from the set
    \*/
    setproto.clear = function () {
        while (this.length) {
            this.pop();
        }
    };
    /*\
     * Set.splice
     [ method ]
     **
     * Removes range of elements from the set
     **
     - index (number) position of the deletion
     - count (number) number of element to remove
     - insertion… (object) #optional elements to insert
     = (object) set elements that were deleted
    \*/
    setproto.splice = function (index, count, insertion) {
        index = index < 0 ? mmax(this.length + index, 0) : index;
        count = mmax(0, mmin(this.length - index, count));
        var tail = [],
            todel = [],
            args = [],
            i;
        for (i = 2; i < arguments.length; i++) {
            args.push(arguments[i]);
        }
        for (i = 0; i < count; i++) {
            todel.push(this[index + i]);
        }
        for (; i < this.length - index; i++) {
            tail.push(this[index + i]);
        }
        var arglen = args.length;
        for (i = 0; i < arglen + tail.length; i++) {
            this.items[index + i] = this[index + i] = i < arglen ? args[i] : tail[i - arglen];
        }
        i = this.items.length = this.length -= count - arglen;
        while (this[i]) {
            delete this[i++];
        }
        return new Set(todel);
    };
    /*\
     * Set.exclude
     [ method ]
     **
     * Removes given element from the set
     **
     - element (object) element to remove
     = (boolean) `true` if object was found and removed from the set
    \*/
    setproto.exclude = function (el) {
        for (var i = 0, ii = this.length; i < ii; i++) if (this[i] == el) {
            this.splice(i, 1);
            return true;
        }
        return false;
    };
    /*\
     * Set.insertAfter
     [ method ]
     **
     * Inserts set elements after given element.
     **
     - element (object) set will be inserted after this element
     = (object) Set object
    \*/
    setproto.insertAfter = function (el) {
        var i = this.items.length;
        while (i--) {
            this.items[i].insertAfter(el);
        }
        return this;
    };
    /*\
     * Set.getBBox
     [ method ]
     **
     * Union of all bboxes of the set. See @Element.getBBox.
     = (object) bounding box descriptor. See @Element.getBBox.
    \*/
    setproto.getBBox = function () {
        var x = [],
            y = [],
            x2 = [],
            y2 = [];
        for (var i = this.items.length; i--;) if (!this.items[i].removed) {
            var box = this.items[i].getBBox();
            x.push(box.x);
            y.push(box.y);
            x2.push(box.x + box.width);
            y2.push(box.y + box.height);
        }
        x = mmin.apply(0, x);
        y = mmin.apply(0, y);
        x2 = mmax.apply(0, x2);
        y2 = mmax.apply(0, y2);
        return {
            x: x,
            y: y,
            x2: x2,
            y2: y2,
            width: x2 - x,
            height: y2 - y,
            cx: x + (x2 - x) / 2,
            cy: y + (y2 - y) / 2
        };
    };
    /*\
     * Set.insertAfter
     [ method ]
     **
     * Creates a clone of the set.
     **
     = (object) New Set object
    \*/
    setproto.clone = function (s) {
        s = new Set;
        for (var i = 0, ii = this.items.length; i < ii; i++) {
            s.push(this.items[i].clone());
        }
        return s;
    };
    setproto.toString = function () {
        return "Snap\u2018s set";
    };
    setproto.type = "set";
    // export
    /*\
     * Snap.Set
     [ property ]
     **
     * Set constructor.
    \*/
    Snap.Set = Set;
    /*\
     * Snap.set
     [ method ]
     **
     * Creates a set and fills it with list of arguments.
     **
     = (object) New Set object
     | var r = paper.rect(0, 0, 10, 10),
     |     s1 = Snap.set(), // empty set
     |     s2 = Snap.set(r, paper.circle(100, 100, 20)); // prefilled set
    \*/
    Snap.set = function () {
        var set = new Set;
        if (arguments.length) {
            set.push.apply(set, Array.prototype.slice.call(arguments, 0));
        }
        return set;
    };
});

// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Snap.plugin(function (Snap, Element, Paper, glob) {
    var names = {},
        reUnit = /[%a-z]+$/i,
        Str = String;
    names.stroke = names.fill = "colour";
    function getEmpty(item) {
        var l = item[0];
        switch (l.toLowerCase()) {
            case "t": return [l, 0, 0];
            case "m": return [l, 1, 0, 0, 1, 0, 0];
            case "r": if (item.length == 4) {
                return [l, 0, item[2], item[3]];
            } else {
                return [l, 0];
            }
            case "s": if (item.length == 5) {
                return [l, 1, 1, item[3], item[4]];
            } else if (item.length == 3) {
                return [l, 1, 1];
            } else {
                return [l, 1];
            }
        }
    }
    function equaliseTransform(t1, t2, getBBox) {
        t1 = t1 || new Snap.Matrix;
        t2 = t2 || new Snap.Matrix;
        t1 = Snap.parseTransformString(t1.toTransformString()) || [];
        t2 = Snap.parseTransformString(t2.toTransformString()) || [];
        var maxlength = Math.max(t1.length, t2.length),
            from = [],
            to = [],
            i = 0, j, jj,
            tt1, tt2;
        for (; i < maxlength; i++) {
            tt1 = t1[i] || getEmpty(t2[i]);
            tt2 = t2[i] || getEmpty(tt1);
            if (tt1[0] != tt2[0] ||
                tt1[0].toLowerCase() == "r" && (tt1[2] != tt2[2] || tt1[3] != tt2[3]) ||
                tt1[0].toLowerCase() == "s" && (tt1[3] != tt2[3] || tt1[4] != tt2[4])
                ) {
                    t1 = Snap._.transform2matrix(t1, getBBox());
                    t2 = Snap._.transform2matrix(t2, getBBox());
                    from = [["m", t1.a, t1.b, t1.c, t1.d, t1.e, t1.f]];
                    to = [["m", t2.a, t2.b, t2.c, t2.d, t2.e, t2.f]];
                    break;
            }
            from[i] = [];
            to[i] = [];
            for (j = 0, jj = Math.max(tt1.length, tt2.length); j < jj; j++) {
                j in tt1 && (from[i][j] = tt1[j]);
                j in tt2 && (to[i][j] = tt2[j]);
            }
        }
        return {
            from: path2array(from),
            to: path2array(to),
            f: getPath(from)
        };
    }
    function getNumber(val) {
        return val;
    }
    function getUnit(unit) {
        return function (val) {
            return +val.toFixed(3) + unit;
        };
    }
    function getViewBox(val) {
        return val.join(" ");
    }
    function getColour(clr) {
        return Snap.rgb(clr[0], clr[1], clr[2], clr[3]);
    }
    function getPath(path) {
        var k = 0, i, ii, j, jj, out, a, b = [];
        for (i = 0, ii = path.length; i < ii; i++) {
            out = "[";
            a = ['"' + path[i][0] + '"'];
            for (j = 1, jj = path[i].length; j < jj; j++) {
                a[j] = "val[" + k++ + "]";
            }
            out += a + "]";
            b[i] = out;
        }
        return Function("val", "return Snap.path.toString.call([" + b + "])");
    }
    function path2array(path) {
        var out = [];
        for (var i = 0, ii = path.length; i < ii; i++) {
            for (var j = 1, jj = path[i].length; j < jj; j++) {
                out.push(path[i][j]);
            }
        }
        return out;
    }
    function isNumeric(obj) {
        return isFinite(obj);
    }
    function arrayEqual(arr1, arr2) {
        if (!Snap.is(arr1, "array") || !Snap.is(arr2, "array")) {
            return false;
        }
        return arr1.toString() == arr2.toString();
    }
    Element.prototype.equal = function (name, b) {
        return eve("snap.util.equal", this, name, b).firstDefined();
    };
    eve.on("snap.util.equal", function (name, b) {
        var A, B, a = Str(this.attr(name) || ""),
            el = this;
        if (names[name] == "colour") {
            A = Snap.color(a);
            B = Snap.color(b);
            return {
                from: [A.r, A.g, A.b, A.opacity],
                to: [B.r, B.g, B.b, B.opacity],
                f: getColour
            };
        }
        if (name == "viewBox") {
            A = this.attr(name).vb.split(" ").map(Number);
            B = b.split(" ").map(Number);
            return {
                from: A,
                to: B,
                f: getViewBox
            };
        }
        if (name == "transform" || name == "gradientTransform" || name == "patternTransform") {
            if (typeof b == "string") {
                b = Str(b).replace(/\.{3}|\u2026/g, a);
            }
            a = this.matrix;
            if (!Snap._.rgTransform.test(b)) {
                b = Snap._.transform2matrix(Snap._.svgTransform2string(b), this.getBBox());
            } else {
                b = Snap._.transform2matrix(b, this.getBBox());
            }
            return equaliseTransform(a, b, function () {
                return el.getBBox(1);
            });
        }
        if (name == "d" || name == "path") {
            A = Snap.path.toCubic(a, b);
            return {
                from: path2array(A[0]),
                to: path2array(A[1]),
                f: getPath(A[0])
            };
        }
        if (name == "points") {
            A = Str(a).split(Snap._.separator);
            B = Str(b).split(Snap._.separator);
            return {
                from: A,
                to: B,
                f: function (val) { return val; }
            };
        }
        if (isNumeric(a) && isNumeric(b)) {
            return {
                from: parseFloat(a),
                to: parseFloat(b),
                f: getNumber
            };
        }
        var aUnit = a.match(reUnit),
            bUnit = Str(b).match(reUnit);
        if (aUnit && arrayEqual(aUnit, bUnit)) {
            return {
                from: parseFloat(a),
                to: parseFloat(b),
                f: getUnit(aUnit)
            };
        } else {
            return {
                from: this.asPX(name),
                to: this.asPX(name, b),
                f: getNumber
            };
        }
    });
});

// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Snap.plugin(function (Snap, Element, Paper, glob) {
    var elproto = Element.prototype,
    has = "hasOwnProperty",
    supportsTouch = "createTouch" in glob.doc,
    events = [
        "click", "dblclick", "mousedown", "mousemove", "mouseout",
        "mouseover", "mouseup", "touchstart", "touchmove", "touchend",
        "touchcancel"
    ],
    touchMap = {
        mousedown: "touchstart",
        mousemove: "touchmove",
        mouseup: "touchend"
    },
    getScroll = function (xy, el) {
        var name = xy == "y" ? "scrollTop" : "scrollLeft",
            doc = el && el.node ? el.node.ownerDocument : glob.doc;
        return doc[name in doc.documentElement ? "documentElement" : "body"][name];
    },
    preventDefault = function () {
        this.returnValue = false;
    },
    preventTouch = function () {
        return this.originalEvent.preventDefault();
    },
    stopPropagation = function () {
        this.cancelBubble = true;
    },
    stopTouch = function () {
        return this.originalEvent.stopPropagation();
    },
    addEvent = function (obj, type, fn, element) {
        var realName = supportsTouch && touchMap[type] ? touchMap[type] : type,
            f = function (e) {
                var scrollY = getScroll("y", element),
                    scrollX = getScroll("x", element);
                if (supportsTouch && touchMap[has](type)) {
                    for (var i = 0, ii = e.targetTouches && e.targetTouches.length; i < ii; i++) {
                        if (e.targetTouches[i].target == obj || obj.contains(e.targetTouches[i].target)) {
                            var olde = e;
                            e = e.targetTouches[i];
                            e.originalEvent = olde;
                            e.preventDefault = preventTouch;
                            e.stopPropagation = stopTouch;
                            break;
                        }
                    }
                }
                var x = e.clientX + scrollX,
                    y = e.clientY + scrollY;
                return fn.call(element, e, x, y);
            };

        if (type !== realName) {
            obj.addEventListener(type, f, false);
        }

        obj.addEventListener(realName, f, false);

        return function () {
            if (type !== realName) {
                obj.removeEventListener(type, f, false);
            }

            obj.removeEventListener(realName, f, false);
            return true;
        };
    },
    drag = [],
    dragMove = function (e) {
        var x = e.clientX,
            y = e.clientY,
            scrollY = getScroll("y"),
            scrollX = getScroll("x"),
            dragi,
            j = drag.length;
        while (j--) {
            dragi = drag[j];
            if (supportsTouch) {
                var i = e.touches && e.touches.length,
                    touch;
                while (i--) {
                    touch = e.touches[i];
                    if (touch.identifier == dragi.el._drag.id || dragi.el.node.contains(touch.target)) {
                        x = touch.clientX;
                        y = touch.clientY;
                        (e.originalEvent ? e.originalEvent : e).preventDefault();
                        break;
                    }
                }
            } else {
                e.preventDefault();
            }
            var node = dragi.el.node,
                o,
                next = node.nextSibling,
                parent = node.parentNode,
                display = node.style.display;
            // glob.win.opera && parent.removeChild(node);
            // node.style.display = "none";
            // o = dragi.el.paper.getElementByPoint(x, y);
            // node.style.display = display;
            // glob.win.opera && (next ? parent.insertBefore(node, next) : parent.appendChild(node));
            // o && eve("snap.drag.over." + dragi.el.id, dragi.el, o);
            x += scrollX;
            y += scrollY;
            eve("snap.drag.move." + dragi.el.id, dragi.move_scope || dragi.el, x - dragi.el._drag.x, y - dragi.el._drag.y, x, y, e);
        }
    },
    dragUp = function (e) {
        Snap.unmousemove(dragMove).unmouseup(dragUp);
        var i = drag.length,
            dragi;
        while (i--) {
            dragi = drag[i];
            dragi.el._drag = {};
            eve("snap.drag.end." + dragi.el.id, dragi.end_scope || dragi.start_scope || dragi.move_scope || dragi.el, e);
            eve.off("snap.drag.*." + dragi.el.id);
        }
        drag = [];
    };
    /*\
     * Element.click
     [ method ]
     **
     * Adds a click event handler to the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.unclick
     [ method ]
     **
     * Removes a click event handler from the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    
    /*\
     * Element.dblclick
     [ method ]
     **
     * Adds a double click event handler to the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.undblclick
     [ method ]
     **
     * Removes a double click event handler from the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    
    /*\
     * Element.mousedown
     [ method ]
     **
     * Adds a mousedown event handler to the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.unmousedown
     [ method ]
     **
     * Removes a mousedown event handler from the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    
    /*\
     * Element.mousemove
     [ method ]
     **
     * Adds a mousemove event handler to the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.unmousemove
     [ method ]
     **
     * Removes a mousemove event handler from the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    
    /*\
     * Element.mouseout
     [ method ]
     **
     * Adds a mouseout event handler to the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.unmouseout
     [ method ]
     **
     * Removes a mouseout event handler from the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    
    /*\
     * Element.mouseover
     [ method ]
     **
     * Adds a mouseover event handler to the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.unmouseover
     [ method ]
     **
     * Removes a mouseover event handler from the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    
    /*\
     * Element.mouseup
     [ method ]
     **
     * Adds a mouseup event handler to the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.unmouseup
     [ method ]
     **
     * Removes a mouseup event handler from the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    
    /*\
     * Element.touchstart
     [ method ]
     **
     * Adds a touchstart event handler to the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.untouchstart
     [ method ]
     **
     * Removes a touchstart event handler from the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    
    /*\
     * Element.touchmove
     [ method ]
     **
     * Adds a touchmove event handler to the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.untouchmove
     [ method ]
     **
     * Removes a touchmove event handler from the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    
    /*\
     * Element.touchend
     [ method ]
     **
     * Adds a touchend event handler to the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.untouchend
     [ method ]
     **
     * Removes a touchend event handler from the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    
    /*\
     * Element.touchcancel
     [ method ]
     **
     * Adds a touchcancel event handler to the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.untouchcancel
     [ method ]
     **
     * Removes a touchcancel event handler from the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    for (var i = events.length; i--;) {
        (function (eventName) {
            Snap[eventName] = elproto[eventName] = function (fn, scope) {
                if (Snap.is(fn, "function")) {
                    this.events = this.events || [];
                    this.events.push({
                        name: eventName,
                        f: fn,
                        unbind: addEvent(this.node || document, eventName, fn, scope || this)
                    });
                } else {
                    for (var i = 0, ii = this.events.length; i < ii; i++) if (this.events[i].name == eventName) {
                        try {
                            this.events[i].f.call(this);
                        } catch (e) {}
                    }
                }
                return this;
            };
            Snap["un" + eventName] =
            elproto["un" + eventName] = function (fn) {
                var events = this.events || [],
                    l = events.length;
                while (l--) if (events[l].name == eventName &&
                               (events[l].f == fn || !fn)) {
                    events[l].unbind();
                    events.splice(l, 1);
                    !events.length && delete this.events;
                    return this;
                }
                return this;
            };
        })(events[i]);
    }
    /*\
     * Element.hover
     [ method ]
     **
     * Adds hover event handlers to the element
     - f_in (function) handler for hover in
     - f_out (function) handler for hover out
     - icontext (object) #optional context for hover in handler
     - ocontext (object) #optional context for hover out handler
     = (object) @Element
    \*/
    elproto.hover = function (f_in, f_out, scope_in, scope_out) {
        return this.mouseover(f_in, scope_in).mouseout(f_out, scope_out || scope_in);
    };
    /*\
     * Element.unhover
     [ method ]
     **
     * Removes hover event handlers from the element
     - f_in (function) handler for hover in
     - f_out (function) handler for hover out
     = (object) @Element
    \*/
    elproto.unhover = function (f_in, f_out) {
        return this.unmouseover(f_in).unmouseout(f_out);
    };
    var draggable = [];
    // SIERRA unclear what _context_ refers to for starting, ending, moving the drag gesture.
    // SIERRA Element.drag(): _x position of the mouse_: Where are the x/y values offset from?
    // SIERRA Element.drag(): much of this member's doc appears to be duplicated for some reason.
    // SIERRA Unclear about this sentence: _Additionally following drag events will be triggered: drag.start.<id> on start, drag.end.<id> on end and drag.move.<id> on every move._ Is there a global _drag_ object to which you can assign handlers keyed by an element's ID?
    /*\
     * Element.drag
     [ method ]
     **
     * Adds event handlers for an element's drag gesture
     **
     - onmove (function) handler for moving
     - onstart (function) handler for drag start
     - onend (function) handler for drag end
     - mcontext (object) #optional context for moving handler
     - scontext (object) #optional context for drag start handler
     - econtext (object) #optional context for drag end handler
     * Additionaly following `drag` events are triggered: `drag.start.<id>` on start, 
     * `drag.end.<id>` on end and `drag.move.<id>` on every move. When element is dragged over another element 
     * `drag.over.<id>` fires as well.
     *
     * Start event and start handler are called in specified context or in context of the element with following parameters:
     o x (number) x position of the mouse
     o y (number) y position of the mouse
     o event (object) DOM event object
     * Move event and move handler are called in specified context or in context of the element with following parameters:
     o dx (number) shift by x from the start point
     o dy (number) shift by y from the start point
     o x (number) x position of the mouse
     o y (number) y position of the mouse
     o event (object) DOM event object
     * End event and end handler are called in specified context or in context of the element with following parameters:
     o event (object) DOM event object
     = (object) @Element
    \*/
    elproto.drag = function (onmove, onstart, onend, move_scope, start_scope, end_scope) {
        var el = this;
        if (!arguments.length) {
            var origTransform;
            return el.drag(function (dx, dy) {
                this.attr({
                    transform: origTransform + (origTransform ? "T" : "t") + [dx, dy]
                });
            }, function () {
                origTransform = this.transform().local;
            });
        }
        function start(e, x, y) {
            (e.originalEvent || e).preventDefault();
            el._drag.x = x;
            el._drag.y = y;
            el._drag.id = e.identifier;
            !drag.length && Snap.mousemove(dragMove).mouseup(dragUp);
            drag.push({el: el, move_scope: move_scope, start_scope: start_scope, end_scope: end_scope});
            onstart && eve.on("snap.drag.start." + el.id, onstart);
            onmove && eve.on("snap.drag.move." + el.id, onmove);
            onend && eve.on("snap.drag.end." + el.id, onend);
            eve("snap.drag.start." + el.id, start_scope || move_scope || el, x, y, e);
        }
        function init(e, x, y) {
            eve("snap.draginit." + el.id, el, e, x, y);
        }
        eve.on("snap.draginit." + el.id, start);
        el._drag = {};
        draggable.push({el: el, start: start, init: init});
        el.mousedown(init);
        return el;
    };
    /*
     * Element.onDragOver
     [ method ]
     **
     * Shortcut to assign event handler for `drag.over.<id>` event, where `id` is the element's `id` (see @Element.id)
     - f (function) handler for event, first argument would be the element you are dragging over
    \*/
    // elproto.onDragOver = function (f) {
    //     f ? eve.on("snap.drag.over." + this.id, f) : eve.unbind("snap.drag.over." + this.id);
    // };
    /*\
     * Element.undrag
     [ method ]
     **
     * Removes all drag event handlers from the given element
    \*/
    elproto.undrag = function () {
        var i = draggable.length;
        while (i--) if (draggable[i].el == this) {
            this.unmousedown(draggable[i].init);
            draggable.splice(i, 1);
            eve.unbind("snap.drag.*." + this.id);
            eve.unbind("snap.draginit." + this.id);
        }
        !draggable.length && Snap.unmousemove(dragMove).unmouseup(dragUp);
        return this;
    };
});

// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Snap.plugin(function (Snap, Element, Paper, glob) {
    var elproto = Element.prototype,
        pproto = Paper.prototype,
        rgurl = /^\s*url\((.+)\)/,
        Str = String,
        $ = Snap._.$;
    Snap.filter = {};
    /*\
     * Paper.filter
     [ method ]
     **
     * Creates a `<filter>` element
     **
     - filstr (string) SVG fragment of filter provided as a string
     = (object) @Element
     * Note: It is recommended to use filters embedded into the page inside an empty SVG element.
     > Usage
     | var f = paper.filter('<feGaussianBlur stdDeviation="2"/>'),
     |     c = paper.circle(10, 10, 10).attr({
     |         filter: f
     |     });
    \*/
    pproto.filter = function (filstr) {
        var paper = this;
        if (paper.type != "svg") {
            paper = paper.paper;
        }
        var f = Snap.parse(Str(filstr)),
            id = Snap._.id(),
            width = paper.node.offsetWidth,
            height = paper.node.offsetHeight,
            filter = $("filter");
        $(filter, {
            id: id,
            filterUnits: "userSpaceOnUse"
        });
        filter.appendChild(f.node);
        paper.defs.appendChild(filter);
        return new Element(filter);
    };

    eve.on("snap.util.getattr.filter", function () {
        eve.stop();
        var p = $(this.node, "filter");
        if (p) {
            var match = Str(p).match(rgurl);
            return match && Snap.select(match[1]);
        }
    });
    eve.on("snap.util.attr.filter", function (value) {
        if (value instanceof Element && value.type == "filter") {
            eve.stop();
            var id = value.node.id;
            if (!id) {
                $(value.node, {id: value.id});
                id = value.id;
            }
            $(this.node, {
                filter: Snap.url(id)
            });
        }
        if (!value || value == "none") {
            eve.stop();
            this.node.removeAttribute("filter");
        }
    });
    /*\
     * Snap.filter.blur
     [ method ]
     **
     * Returns an SVG markup string for the blur filter
     **
     - x (number) amount of horizontal blur, in pixels
     - y (number) #optional amount of vertical blur, in pixels
     = (string) filter representation
     > Usage
     | var f = paper.filter(Snap.filter.blur(5, 10)),
     |     c = paper.circle(10, 10, 10).attr({
     |         filter: f
     |     });
    \*/
    Snap.filter.blur = function (x, y) {
        if (x == null) {
            x = 2;
        }
        var def = y == null ? x : [x, y];
        return Snap.format('\<feGaussianBlur stdDeviation="{def}"/>', {
            def: def
        });
    };
    Snap.filter.blur.toString = function () {
        return this();
    };
    /*\
     * Snap.filter.shadow
     [ method ]
     **
     * Returns an SVG markup string for the shadow filter
     **
     - dx (number) #optional horizontal shift of the shadow, in pixels
     - dy (number) #optional vertical shift of the shadow, in pixels
     - blur (number) #optional amount of blur
     - color (string) #optional color of the shadow
     - opacity (number) #optional `0..1` opacity of the shadow
     * or
     - dx (number) #optional horizontal shift of the shadow, in pixels
     - dy (number) #optional vertical shift of the shadow, in pixels
     - color (string) #optional color of the shadow
     - opacity (number) #optional `0..1` opacity of the shadow
     * which makes blur default to `4`. Or
     - dx (number) #optional horizontal shift of the shadow, in pixels
     - dy (number) #optional vertical shift of the shadow, in pixels
     - opacity (number) #optional `0..1` opacity of the shadow
     = (string) filter representation
     > Usage
     | var f = paper.filter(Snap.filter.shadow(0, 2, .3)),
     |     c = paper.circle(10, 10, 10).attr({
     |         filter: f
     |     });
    \*/
    Snap.filter.shadow = function (dx, dy, blur, color, opacity) {
        if (opacity == null) {
            if (color == null) {
                opacity = blur;
                blur = 4;
                color = "#000";
            } else {
                opacity = color;
                color = blur;
                blur = 4;
            }
        }
        if (blur == null) {
            blur = 4;
        }
        if (opacity == null) {
            opacity = 1;
        }
        if (dx == null) {
            dx = 0;
            dy = 2;
        }
        if (dy == null) {
            dy = dx;
        }
        color = Snap.color(color);
        return Snap.format('<feGaussianBlur in="SourceAlpha" stdDeviation="{blur}"/><feOffset dx="{dx}" dy="{dy}" result="offsetblur"/><feFlood flood-color="{color}"/><feComposite in2="offsetblur" operator="in"/><feComponentTransfer><feFuncA type="linear" slope="{opacity}"/></feComponentTransfer><feMerge><feMergeNode/><feMergeNode in="SourceGraphic"/></feMerge>', {
            color: color,
            dx: dx,
            dy: dy,
            blur: blur,
            opacity: opacity
        });
    };
    Snap.filter.shadow.toString = function () {
        return this();
    };
    /*\
     * Snap.filter.grayscale
     [ method ]
     **
     * Returns an SVG markup string for the grayscale filter
     **
     - amount (number) amount of filter (`0..1`)
     = (string) filter representation
    \*/
    Snap.filter.grayscale = function (amount) {
        if (amount == null) {
            amount = 1;
        }
        return Snap.format('<feColorMatrix type="matrix" values="{a} {b} {c} 0 0 {d} {e} {f} 0 0 {g} {b} {h} 0 0 0 0 0 1 0"/>', {
            a: 0.2126 + 0.7874 * (1 - amount),
            b: 0.7152 - 0.7152 * (1 - amount),
            c: 0.0722 - 0.0722 * (1 - amount),
            d: 0.2126 - 0.2126 * (1 - amount),
            e: 0.7152 + 0.2848 * (1 - amount),
            f: 0.0722 - 0.0722 * (1 - amount),
            g: 0.2126 - 0.2126 * (1 - amount),
            h: 0.0722 + 0.9278 * (1 - amount)
        });
    };
    Snap.filter.grayscale.toString = function () {
        return this();
    };
    /*\
     * Snap.filter.sepia
     [ method ]
     **
     * Returns an SVG markup string for the sepia filter
     **
     - amount (number) amount of filter (`0..1`)
     = (string) filter representation
    \*/
    Snap.filter.sepia = function (amount) {
        if (amount == null) {
            amount = 1;
        }
        return Snap.format('<feColorMatrix type="matrix" values="{a} {b} {c} 0 0 {d} {e} {f} 0 0 {g} {h} {i} 0 0 0 0 0 1 0"/>', {
            a: 0.393 + 0.607 * (1 - amount),
            b: 0.769 - 0.769 * (1 - amount),
            c: 0.189 - 0.189 * (1 - amount),
            d: 0.349 - 0.349 * (1 - amount),
            e: 0.686 + 0.314 * (1 - amount),
            f: 0.168 - 0.168 * (1 - amount),
            g: 0.272 - 0.272 * (1 - amount),
            h: 0.534 - 0.534 * (1 - amount),
            i: 0.131 + 0.869 * (1 - amount)
        });
    };
    Snap.filter.sepia.toString = function () {
        return this();
    };
    /*\
     * Snap.filter.saturate
     [ method ]
     **
     * Returns an SVG markup string for the saturate filter
     **
     - amount (number) amount of filter (`0..1`)
     = (string) filter representation
    \*/
    Snap.filter.saturate = function (amount) {
        if (amount == null) {
            amount = 1;
        }
        return Snap.format('<feColorMatrix type="saturate" values="{amount}"/>', {
            amount: 1 - amount
        });
    };
    Snap.filter.saturate.toString = function () {
        return this();
    };
    /*\
     * Snap.filter.hueRotate
     [ method ]
     **
     * Returns an SVG markup string for the hue-rotate filter
     **
     - angle (number) angle of rotation
     = (string) filter representation
    \*/
    Snap.filter.hueRotate = function (angle) {
        angle = angle || 0;
        return Snap.format('<feColorMatrix type="hueRotate" values="{angle}"/>', {
            angle: angle
        });
    };
    Snap.filter.hueRotate.toString = function () {
        return this();
    };
    /*\
     * Snap.filter.invert
     [ method ]
     **
     * Returns an SVG markup string for the invert filter
     **
     - amount (number) amount of filter (`0..1`)
     = (string) filter representation
    \*/
    Snap.filter.invert = function (amount) {
        if (amount == null) {
            amount = 1;
        }
//        <feColorMatrix type="matrix" values="-1 0 0 0 1  0 -1 0 0 1  0 0 -1 0 1  0 0 0 1 0" color-interpolation-filters="sRGB"/>
        return Snap.format('<feComponentTransfer><feFuncR type="table" tableValues="{amount} {amount2}"/><feFuncG type="table" tableValues="{amount} {amount2}"/><feFuncB type="table" tableValues="{amount} {amount2}"/></feComponentTransfer>', {
            amount: amount,
            amount2: 1 - amount
        });
    };
    Snap.filter.invert.toString = function () {
        return this();
    };
    /*\
     * Snap.filter.brightness
     [ method ]
     **
     * Returns an SVG markup string for the brightness filter
     **
     - amount (number) amount of filter (`0..1`)
     = (string) filter representation
    \*/
    Snap.filter.brightness = function (amount) {
        if (amount == null) {
            amount = 1;
        }
        return Snap.format('<feComponentTransfer><feFuncR type="linear" slope="{amount}"/><feFuncG type="linear" slope="{amount}"/><feFuncB type="linear" slope="{amount}"/></feComponentTransfer>', {
            amount: amount
        });
    };
    Snap.filter.brightness.toString = function () {
        return this();
    };
    /*\
     * Snap.filter.contrast
     [ method ]
     **
     * Returns an SVG markup string for the contrast filter
     **
     - amount (number) amount of filter (`0..1`)
     = (string) filter representation
    \*/
    Snap.filter.contrast = function (amount) {
        if (amount == null) {
            amount = 1;
        }
        return Snap.format('<feComponentTransfer><feFuncR type="linear" slope="{amount}" intercept="{amount2}"/><feFuncG type="linear" slope="{amount}" intercept="{amount2}"/><feFuncB type="linear" slope="{amount}" intercept="{amount2}"/></feComponentTransfer>', {
            amount: amount,
            amount2: .5 - amount / 2
        });
    };
    Snap.filter.contrast.toString = function () {
        return this();
    };
});

// Copyright (c) 2014 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Snap.plugin(function (Snap, Element, Paper, glob, Fragment) {
    var box = Snap._.box,
        is = Snap.is,
        firstLetter = /^[^a-z]*([tbmlrc])/i,
        toString = function () {
            return "T" + this.dx + "," + this.dy;
        };
    /*\
     * Element.getAlign
     [ method ]
     **
     * Returns shift needed to align the element relatively to given element.
     * If no elements specified, parent `<svg>` container will be used.
     - el (object) @optional alignment element
     - way (string) one of six values: `"top"`, `"middle"`, `"bottom"`, `"left"`, `"center"`, `"right"`
     = (object|string) Object in format `{dx: , dy: }` also has a string representation as a transformation string
     > Usage
     | el.transform(el.getAlign(el2, "top"));
     * or
     | var dy = el.getAlign(el2, "top").dy;
    \*/
    Element.prototype.getAlign = function (el, way) {
        if (way == null && is(el, "string")) {
            way = el;
            el = null;
        }
        el = el || this.paper;
        var bx = el.getBBox ? el.getBBox() : box(el),
            bb = this.getBBox(),
            out = {};
        way = way && way.match(firstLetter);
        way = way ? way[1].toLowerCase() : "c";
        switch (way) {
            case "t":
                out.dx = 0;
                out.dy = bx.y - bb.y;
            break;
            case "b":
                out.dx = 0;
                out.dy = bx.y2 - bb.y2;
            break;
            case "m":
                out.dx = 0;
                out.dy = bx.cy - bb.cy;
            break;
            case "l":
                out.dx = bx.x - bb.x;
                out.dy = 0;
            break;
            case "r":
                out.dx = bx.x2 - bb.x2;
                out.dy = 0;
            break;
            default:
                out.dx = bx.cx - bb.cx;
                out.dy = 0;
            break;
        }
        out.toString = toString;
        return out;
    };
    /*\
     * Element.align
     [ method ]
     **
     * Aligns the element relatively to given one via transformation.
     * If no elements specified, parent `<svg>` container will be used.
     - el (object) @optional alignment element
     - way (string) one of six values: `"top"`, `"middle"`, `"bottom"`, `"left"`, `"center"`, `"right"`
     = (object) this element
     > Usage
     | el.align(el2, "top");
     * or
     | el.align("middle");
    \*/
    Element.prototype.align = function (el, way) {
        return this.transform("..." + this.getAlign(el, way));
    };
});

// Copyright (c) 2017 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Snap.plugin(function (Snap, Element, Paper, glob) {
    // Colours are from https://www.materialui.co
    var red         = "#ffebee#ffcdd2#ef9a9a#e57373#ef5350#f44336#e53935#d32f2f#c62828#b71c1c#ff8a80#ff5252#ff1744#d50000",
        pink        = "#FCE4EC#F8BBD0#F48FB1#F06292#EC407A#E91E63#D81B60#C2185B#AD1457#880E4F#FF80AB#FF4081#F50057#C51162",
        purple      = "#F3E5F5#E1BEE7#CE93D8#BA68C8#AB47BC#9C27B0#8E24AA#7B1FA2#6A1B9A#4A148C#EA80FC#E040FB#D500F9#AA00FF",
        deeppurple  = "#EDE7F6#D1C4E9#B39DDB#9575CD#7E57C2#673AB7#5E35B1#512DA8#4527A0#311B92#B388FF#7C4DFF#651FFF#6200EA",
        indigo      = "#E8EAF6#C5CAE9#9FA8DA#7986CB#5C6BC0#3F51B5#3949AB#303F9F#283593#1A237E#8C9EFF#536DFE#3D5AFE#304FFE",
        blue        = "#E3F2FD#BBDEFB#90CAF9#64B5F6#64B5F6#2196F3#1E88E5#1976D2#1565C0#0D47A1#82B1FF#448AFF#2979FF#2962FF",
        lightblue   = "#E1F5FE#B3E5FC#81D4FA#4FC3F7#29B6F6#03A9F4#039BE5#0288D1#0277BD#01579B#80D8FF#40C4FF#00B0FF#0091EA",
        cyan        = "#E0F7FA#B2EBF2#80DEEA#4DD0E1#26C6DA#00BCD4#00ACC1#0097A7#00838F#006064#84FFFF#18FFFF#00E5FF#00B8D4",
        teal        = "#E0F2F1#B2DFDB#80CBC4#4DB6AC#26A69A#009688#00897B#00796B#00695C#004D40#A7FFEB#64FFDA#1DE9B6#00BFA5",
        green       = "#E8F5E9#C8E6C9#A5D6A7#81C784#66BB6A#4CAF50#43A047#388E3C#2E7D32#1B5E20#B9F6CA#69F0AE#00E676#00C853",
        lightgreen  = "#F1F8E9#DCEDC8#C5E1A5#AED581#9CCC65#8BC34A#7CB342#689F38#558B2F#33691E#CCFF90#B2FF59#76FF03#64DD17",
        lime        = "#F9FBE7#F0F4C3#E6EE9C#DCE775#D4E157#CDDC39#C0CA33#AFB42B#9E9D24#827717#F4FF81#EEFF41#C6FF00#AEEA00",
        yellow      = "#FFFDE7#FFF9C4#FFF59D#FFF176#FFEE58#FFEB3B#FDD835#FBC02D#F9A825#F57F17#FFFF8D#FFFF00#FFEA00#FFD600",
        amber       = "#FFF8E1#FFECB3#FFE082#FFD54F#FFCA28#FFC107#FFB300#FFA000#FF8F00#FF6F00#FFE57F#FFD740#FFC400#FFAB00",
        orange      = "#FFF3E0#FFE0B2#FFCC80#FFB74D#FFA726#FF9800#FB8C00#F57C00#EF6C00#E65100#FFD180#FFAB40#FF9100#FF6D00",
        deeporange  = "#FBE9E7#FFCCBC#FFAB91#FF8A65#FF7043#FF5722#F4511E#E64A19#D84315#BF360C#FF9E80#FF6E40#FF3D00#DD2C00",
        brown       = "#EFEBE9#D7CCC8#BCAAA4#A1887F#8D6E63#795548#6D4C41#5D4037#4E342E#3E2723",
        grey        = "#FAFAFA#F5F5F5#EEEEEE#E0E0E0#BDBDBD#9E9E9E#757575#616161#424242#212121",
        bluegrey    = "#ECEFF1#CFD8DC#B0BEC5#90A4AE#78909C#607D8B#546E7A#455A64#37474F#263238";
    /*\
     * Snap.mui
     [ property ]
     **
     * Contain Material UI colours.
     | Snap().rect(0, 0, 10, 10).attr({fill: Snap.mui.deeppurple, stroke: Snap.mui.amber[600]});
     # For colour reference: <a href="https://www.materialui.co">https://www.materialui.co</a>.
    \*/
    Snap.mui = {};
    /*\
     * Snap.flat
     [ property ]
     **
     * Contain Flat UI colours.
     | Snap().rect(0, 0, 10, 10).attr({fill: Snap.flat.carrot, stroke: Snap.flat.wetasphalt});
     # For colour reference: <a href="https://www.materialui.co">https://www.materialui.co</a>.
    \*/
    Snap.flat = {};
    function saveColor(colors) {
        colors = colors.split(/(?=#)/);
        var color = new String(colors[5]);
        color[50] = colors[0];
        color[100] = colors[1];
        color[200] = colors[2];
        color[300] = colors[3];
        color[400] = colors[4];
        color[500] = colors[5];
        color[600] = colors[6];
        color[700] = colors[7];
        color[800] = colors[8];
        color[900] = colors[9];
        if (colors[10]) {
            color.A100 = colors[10];
            color.A200 = colors[11];
            color.A400 = colors[12];
            color.A700 = colors[13];
        }
        return color;
    }
    Snap.mui.red = saveColor(red);
    Snap.mui.pink = saveColor(pink);
    Snap.mui.purple = saveColor(purple);
    Snap.mui.deeppurple = saveColor(deeppurple);
    Snap.mui.indigo = saveColor(indigo);
    Snap.mui.blue = saveColor(blue);
    Snap.mui.lightblue = saveColor(lightblue);
    Snap.mui.cyan = saveColor(cyan);
    Snap.mui.teal = saveColor(teal);
    Snap.mui.green = saveColor(green);
    Snap.mui.lightgreen = saveColor(lightgreen);
    Snap.mui.lime = saveColor(lime);
    Snap.mui.yellow = saveColor(yellow);
    Snap.mui.amber = saveColor(amber);
    Snap.mui.orange = saveColor(orange);
    Snap.mui.deeporange = saveColor(deeporange);
    Snap.mui.brown = saveColor(brown);
    Snap.mui.grey = saveColor(grey);
    Snap.mui.bluegrey = saveColor(bluegrey);
    Snap.flat.turquoise = "#1abc9c";
    Snap.flat.greensea = "#16a085";
    Snap.flat.sunflower = "#f1c40f";
    Snap.flat.orange = "#f39c12";
    Snap.flat.emerland = "#2ecc71";
    Snap.flat.nephritis = "#27ae60";
    Snap.flat.carrot = "#e67e22";
    Snap.flat.pumpkin = "#d35400";
    Snap.flat.peterriver = "#3498db";
    Snap.flat.belizehole = "#2980b9";
    Snap.flat.alizarin = "#e74c3c";
    Snap.flat.pomegranate = "#c0392b";
    Snap.flat.amethyst = "#9b59b6";
    Snap.flat.wisteria = "#8e44ad";
    Snap.flat.clouds = "#ecf0f1";
    Snap.flat.silver = "#bdc3c7";
    Snap.flat.wetasphalt = "#34495e";
    Snap.flat.midnightblue = "#2c3e50";
    Snap.flat.concrete = "#95a5a6";
    Snap.flat.asbestos = "#7f8c8d";
    /*\
     * Snap.importMUIColors
     [ method ]
     **
     * Imports Material UI colours into global object.
     | Snap.importMUIColors();
     | Snap().rect(0, 0, 10, 10).attr({fill: deeppurple, stroke: amber[600]});
     # For colour reference: <a href="https://www.materialui.co">https://www.materialui.co</a>.
    \*/
    Snap.importMUIColors = function () {
        for (var color in Snap.mui) {
            if (Snap.mui.hasOwnProperty(color)) {
                window[color] = Snap.mui[color];
            }
        }
    };
});

return Snap;
}));
}.call(window));

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 * 
 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 * 
 * All rights reserved.
 * 
 * Distributed under the 3-clause BSD License, see LICENSE.txt
 */

/* jshint maxcomplexity:11 */




/*
 * Note
 * ====
 * the structure of this JavaScript version of poly2tri intentionally follows
 * as closely as possible the structure of the reference C++ version, to make it 
 * easier to keep the 2 versions in sync.
 */


// -------------------------------------------------------------------------Node

/**
 * Advancing front node
 * @constructor
 * @private
 * @struct
 * @param {!XY} p - Point
 * @param {Triangle=} t triangle (optional)
 */
var Node = function(p, t) {
    /** @type {XY} */
    this.point = p;

    /** @type {Triangle|null} */
    this.triangle = t || null;

    /** @type {Node|null} */
    this.next = null;
    /** @type {Node|null} */
    this.prev = null;

    /** @type {number} */
    this.value = p.x;
};

// ---------------------------------------------------------------AdvancingFront
/**
 * @constructor
 * @private
 * @struct
 * @param {Node} head
 * @param {Node} tail
 */
var AdvancingFront = function(head, tail) {
    /** @type {Node} */
    this.head_ = head;
    /** @type {Node} */
    this.tail_ = tail;
    /** @type {Node} */
    this.search_node_ = head;
};

/** @return {Node} */
AdvancingFront.prototype.head = function() {
    return this.head_;
};

/** @param {Node} node */
AdvancingFront.prototype.setHead = function(node) {
    this.head_ = node;
};

/** @return {Node} */
AdvancingFront.prototype.tail = function() {
    return this.tail_;
};

/** @param {Node} node */
AdvancingFront.prototype.setTail = function(node) {
    this.tail_ = node;
};

/** @return {Node} */
AdvancingFront.prototype.search = function() {
    return this.search_node_;
};

/** @param {Node} node */
AdvancingFront.prototype.setSearch = function(node) {
    this.search_node_ = node;
};

/** @return {Node} */
AdvancingFront.prototype.findSearchNode = function(/*x*/) {
    // TODO: implement BST index
    return this.search_node_;
};

/**
 * @param {number} x value
 * @return {Node}
 */
AdvancingFront.prototype.locateNode = function(x) {
    var node = this.search_node_;

    /* jshint boss:true */
    if (x < node.value) {
        while (node = node.prev) {
            if (x >= node.value) {
                this.search_node_ = node;
                return node;
            }
        }
    } else {
        while (node = node.next) {
            if (x < node.value) {
                this.search_node_ = node.prev;
                return node.prev;
            }
        }
    }
    return null;
};

/**
 * @param {!XY} point - Point
 * @return {Node}
 */
AdvancingFront.prototype.locatePoint = function(point) {
    var px = point.x;
    var node = this.findSearchNode(px);
    var nx = node.point.x;

    if (px === nx) {
        // Here we are comparing point references, not values
        if (point !== node.point) {
            // We might have two nodes with same x value for a short time
            if (point === node.prev.point) {
                node = node.prev;
            } else if (point === node.next.point) {
                node = node.next;
            } else {
                throw new Error('poly2tri Invalid AdvancingFront.locatePoint() call');
            }
        }
    } else if (px < nx) {
        /* jshint boss:true */
        while (node = node.prev) {
            if (point === node.point) {
                break;
            }
        }
    } else {
        while (node = node.next) {
            if (point === node.point) {
                break;
            }
        }
    }

    if (node) {
        this.search_node_ = node;
    }
    return node;
};


// ----------------------------------------------------------------------Exports

module.exports = AdvancingFront;
module.exports.Node = Node;



/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 * 
 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 * 
 * All rights reserved.
 * 
 * Distributed under the 3-clause BSD License, see LICENSE.txt
 */



/*
 * Class added in the JavaScript version (was not present in the c++ version)
 */

var xy = __webpack_require__(1);

/**
 * Custom exception class to indicate invalid Point values
 * @constructor
 * @public
 * @extends Error
 * @struct
 * @param {string=} message - error message
 * @param {Array.<XY>=} points - invalid points
 */
var PointError = function(message, points) {
    this.name = "PointError";
    /**
     * Invalid points
     * @public
     * @type {Array.<XY>}
     */
    this.points = points = points || [];
    /**
     * Error message
     * @public
     * @type {string}
     */
    this.message = message || "Invalid Points!";
    for (var i = 0; i < points.length; i++) {
        this.message += " " + xy.toString(points[i]);
    }
};
PointError.prototype = new Error();
PointError.prototype.constructor = PointError;


module.exports = PointError;


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 * 
 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 *
 * All rights reserved.
 * 
 * Distributed under the 3-clause BSD License, see LICENSE.txt
 */

/* jshint maxcomplexity:10 */




/*
 * Note
 * ====
 * the structure of this JavaScript version of poly2tri intentionally follows
 * as closely as possible the structure of the reference C++ version, to make it 
 * easier to keep the 2 versions in sync.
 */

var xy = __webpack_require__(1);


// ---------------------------------------------------------------------Triangle
/**
 * Triangle class.<br>
 * Triangle-based data structures are known to have better performance than
 * quad-edge structures.
 * See: J. Shewchuk, "Triangle: Engineering a 2D Quality Mesh Generator and
 * Delaunay Triangulator", "Triangulations in CGAL"
 *
 * @constructor
 * @struct
 * @param {!XY} pa  point object with {x,y}
 * @param {!XY} pb  point object with {x,y}
 * @param {!XY} pc  point object with {x,y}
 */
var Triangle = function(a, b, c) {
    /**
     * Triangle points
     * @private
     * @type {Array.<XY>}
     */
    this.points_ = [a, b, c];

    /**
     * Neighbor list
     * @private
     * @type {Array.<Triangle>}
     */
    this.neighbors_ = [null, null, null];

    /**
     * Has this triangle been marked as an interior triangle?
     * @private
     * @type {boolean}
     */
    this.interior_ = false;

    /**
     * Flags to determine if an edge is a Constrained edge
     * @private
     * @type {Array.<boolean>}
     */
    this.constrained_edge = [false, false, false];

    /**
     * Flags to determine if an edge is a Delauney edge
     * @private
     * @type {Array.<boolean>}
     */
    this.delaunay_edge = [false, false, false];
};

var p2s = xy.toString;
/**
 * For pretty printing ex. <code>"[(5;42)(10;20)(21;30)]"</code>.
 * @public
 * @return {string}
 */
Triangle.prototype.toString = function() {
    return ("[" + p2s(this.points_[0]) + p2s(this.points_[1]) + p2s(this.points_[2]) + "]");
};

/**
 * Get one vertice of the triangle.
 * The output triangles of a triangulation have vertices which are references
 * to the initial input points (not copies): any custom fields in the
 * initial points can be retrieved in the output triangles.
 * @example
 *      var contour = [{x:100, y:100, id:1}, {x:100, y:300, id:2}, {x:300, y:300, id:3}];
 *      var swctx = new poly2tri.SweepContext(contour);
 *      swctx.triangulate();
 *      var triangles = swctx.getTriangles();
 *      typeof triangles[0].getPoint(0).id
 *      // → "number"
 * @param {number} index - vertice index: 0, 1 or 2
 * @public
 * @returns {XY}
 */
Triangle.prototype.getPoint = function(index) {
    return this.points_[index];
};

/**
 * For backward compatibility
 * @function
 * @deprecated use {@linkcode Triangle#getPoint} instead
 */
Triangle.prototype.GetPoint = Triangle.prototype.getPoint;

/**
 * Get all 3 vertices of the triangle as an array
 * @public
 * @return {Array.<XY>}
 */
// Method added in the JavaScript version (was not present in the c++ version)
Triangle.prototype.getPoints = function() {
    return this.points_;
};

/**
 * @private
 * @param {number} index
 * @returns {?Triangle}
 */
Triangle.prototype.getNeighbor = function(index) {
    return this.neighbors_[index];
};

/**
 * Test if this Triangle contains the Point object given as parameter as one of its vertices.
 * Only point references are compared, not values.
 * @public
 * @param {XY} point - point object with {x,y}
 * @return {boolean} <code>True</code> if the Point object is of the Triangle's vertices,
 *         <code>false</code> otherwise.
 */
Triangle.prototype.containsPoint = function(point) {
    var points = this.points_;
    // Here we are comparing point references, not values
    return (point === points[0] || point === points[1] || point === points[2]);
};

/**
 * Test if this Triangle contains the Edge object given as parameter as its
 * bounding edges. Only point references are compared, not values.
 * @private
 * @param {Edge} edge
 * @return {boolean} <code>True</code> if the Edge object is of the Triangle's bounding
 *         edges, <code>false</code> otherwise.
 */
Triangle.prototype.containsEdge = function(edge) {
    return this.containsPoint(edge.p) && this.containsPoint(edge.q);
};

/**
 * Test if this Triangle contains the two Point objects given as parameters among its vertices.
 * Only point references are compared, not values.
 * @param {XY} p1 - point object with {x,y}
 * @param {XY} p2 - point object with {x,y}
 * @return {boolean}
 */
Triangle.prototype.containsPoints = function(p1, p2) {
    return this.containsPoint(p1) && this.containsPoint(p2);
};

/**
 * Has this triangle been marked as an interior triangle?
 * @returns {boolean}
 */
Triangle.prototype.isInterior = function() {
    return this.interior_;
};

/**
 * Mark this triangle as an interior triangle
 * @private
 * @param {boolean} interior
 * @returns {Triangle} this
 */
Triangle.prototype.setInterior = function(interior) {
    this.interior_ = interior;
    return this;
};

/**
 * Update neighbor pointers.
 * @private
 * @param {XY} p1 - point object with {x,y}
 * @param {XY} p2 - point object with {x,y}
 * @param {Triangle} t Triangle object.
 * @throws {Error} if can't find objects
 */
Triangle.prototype.markNeighborPointers = function(p1, p2, t) {
    var points = this.points_;
    // Here we are comparing point references, not values
    if ((p1 === points[2] && p2 === points[1]) || (p1 === points[1] && p2 === points[2])) {
        this.neighbors_[0] = t;
    } else if ((p1 === points[0] && p2 === points[2]) || (p1 === points[2] && p2 === points[0])) {
        this.neighbors_[1] = t;
    } else if ((p1 === points[0] && p2 === points[1]) || (p1 === points[1] && p2 === points[0])) {
        this.neighbors_[2] = t;
    } else {
        throw new Error('poly2tri Invalid Triangle.markNeighborPointers() call');
    }
};

/**
 * Exhaustive search to update neighbor pointers
 * @private
 * @param {!Triangle} t
 */
Triangle.prototype.markNeighbor = function(t) {
    var points = this.points_;
    if (t.containsPoints(points[1], points[2])) {
        this.neighbors_[0] = t;
        t.markNeighborPointers(points[1], points[2], this);
    } else if (t.containsPoints(points[0], points[2])) {
        this.neighbors_[1] = t;
        t.markNeighborPointers(points[0], points[2], this);
    } else if (t.containsPoints(points[0], points[1])) {
        this.neighbors_[2] = t;
        t.markNeighborPointers(points[0], points[1], this);
    }
};


Triangle.prototype.clearNeighbors = function() {
    this.neighbors_[0] = null;
    this.neighbors_[1] = null;
    this.neighbors_[2] = null;
};

Triangle.prototype.clearDelaunayEdges = function() {
    this.delaunay_edge[0] = false;
    this.delaunay_edge[1] = false;
    this.delaunay_edge[2] = false;
};

/**
 * Returns the point clockwise to the given point.
 * @private
 * @param {XY} p - point object with {x,y}
 */
Triangle.prototype.pointCW = function(p) {
    var points = this.points_;
    // Here we are comparing point references, not values
    if (p === points[0]) {
        return points[2];
    } else if (p === points[1]) {
        return points[0];
    } else if (p === points[2]) {
        return points[1];
    } else {
        return null;
    }
};

/**
 * Returns the point counter-clockwise to the given point.
 * @private
 * @param {XY} p - point object with {x,y}
 */
Triangle.prototype.pointCCW = function(p) {
    var points = this.points_;
    // Here we are comparing point references, not values
    if (p === points[0]) {
        return points[1];
    } else if (p === points[1]) {
        return points[2];
    } else if (p === points[2]) {
        return points[0];
    } else {
        return null;
    }
};

/**
 * Returns the neighbor clockwise to given point.
 * @private
 * @param {XY} p - point object with {x,y}
 */
Triangle.prototype.neighborCW = function(p) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        return this.neighbors_[1];
    } else if (p === this.points_[1]) {
        return this.neighbors_[2];
    } else {
        return this.neighbors_[0];
    }
};

/**
 * Returns the neighbor counter-clockwise to given point.
 * @private
 * @param {XY} p - point object with {x,y}
 */
Triangle.prototype.neighborCCW = function(p) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        return this.neighbors_[2];
    } else if (p === this.points_[1]) {
        return this.neighbors_[0];
    } else {
        return this.neighbors_[1];
    }
};

Triangle.prototype.getConstrainedEdgeCW = function(p) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        return this.constrained_edge[1];
    } else if (p === this.points_[1]) {
        return this.constrained_edge[2];
    } else {
        return this.constrained_edge[0];
    }
};

Triangle.prototype.getConstrainedEdgeCCW = function(p) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        return this.constrained_edge[2];
    } else if (p === this.points_[1]) {
        return this.constrained_edge[0];
    } else {
        return this.constrained_edge[1];
    }
};

// Additional check from Java version (see issue #88)
Triangle.prototype.getConstrainedEdgeAcross = function(p) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        return this.constrained_edge[0];
    } else if (p === this.points_[1]) {
        return this.constrained_edge[1];
    } else {
        return this.constrained_edge[2];
    }
};

Triangle.prototype.setConstrainedEdgeCW = function(p, ce) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        this.constrained_edge[1] = ce;
    } else if (p === this.points_[1]) {
        this.constrained_edge[2] = ce;
    } else {
        this.constrained_edge[0] = ce;
    }
};

Triangle.prototype.setConstrainedEdgeCCW = function(p, ce) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        this.constrained_edge[2] = ce;
    } else if (p === this.points_[1]) {
        this.constrained_edge[0] = ce;
    } else {
        this.constrained_edge[1] = ce;
    }
};

Triangle.prototype.getDelaunayEdgeCW = function(p) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        return this.delaunay_edge[1];
    } else if (p === this.points_[1]) {
        return this.delaunay_edge[2];
    } else {
        return this.delaunay_edge[0];
    }
};

Triangle.prototype.getDelaunayEdgeCCW = function(p) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        return this.delaunay_edge[2];
    } else if (p === this.points_[1]) {
        return this.delaunay_edge[0];
    } else {
        return this.delaunay_edge[1];
    }
};

Triangle.prototype.setDelaunayEdgeCW = function(p, e) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        this.delaunay_edge[1] = e;
    } else if (p === this.points_[1]) {
        this.delaunay_edge[2] = e;
    } else {
        this.delaunay_edge[0] = e;
    }
};

Triangle.prototype.setDelaunayEdgeCCW = function(p, e) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        this.delaunay_edge[2] = e;
    } else if (p === this.points_[1]) {
        this.delaunay_edge[0] = e;
    } else {
        this.delaunay_edge[1] = e;
    }
};

/**
 * The neighbor across to given point.
 * @private
 * @param {XY} p - point object with {x,y}
 * @returns {Triangle}
 */
Triangle.prototype.neighborAcross = function(p) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        return this.neighbors_[0];
    } else if (p === this.points_[1]) {
        return this.neighbors_[1];
    } else {
        return this.neighbors_[2];
    }
};

/**
 * @private
 * @param {!Triangle} t Triangle object.
 * @param {XY} p - point object with {x,y}
 */
Triangle.prototype.oppositePoint = function(t, p) {
    var cw = t.pointCW(p);
    return this.pointCW(cw);
};

/**
 * Legalize triangle by rotating clockwise around oPoint
 * @private
 * @param {XY} opoint - point object with {x,y}
 * @param {XY} npoint - point object with {x,y}
 * @throws {Error} if oPoint can not be found
 */
Triangle.prototype.legalize = function(opoint, npoint) {
    var points = this.points_;
    // Here we are comparing point references, not values
    if (opoint === points[0]) {
        points[1] = points[0];
        points[0] = points[2];
        points[2] = npoint;
    } else if (opoint === points[1]) {
        points[2] = points[1];
        points[1] = points[0];
        points[0] = npoint;
    } else if (opoint === points[2]) {
        points[0] = points[2];
        points[2] = points[1];
        points[1] = npoint;
    } else {
        throw new Error('poly2tri Invalid Triangle.legalize() call');
    }
};

/**
 * Returns the index of a point in the triangle. 
 * The point *must* be a reference to one of the triangle's vertices.
 * @private
 * @param {XY} p - point object with {x,y}
 * @returns {number} index 0, 1 or 2
 * @throws {Error} if p can not be found
 */
Triangle.prototype.index = function(p) {
    var points = this.points_;
    // Here we are comparing point references, not values
    if (p === points[0]) {
        return 0;
    } else if (p === points[1]) {
        return 1;
    } else if (p === points[2]) {
        return 2;
    } else {
        throw new Error('poly2tri Invalid Triangle.index() call');
    }
};

/**
 * @private
 * @param {XY} p1 - point object with {x,y}
 * @param {XY} p2 - point object with {x,y}
 * @return {number} index 0, 1 or 2, or -1 if errror
 */
Triangle.prototype.edgeIndex = function(p1, p2) {
    var points = this.points_;
    // Here we are comparing point references, not values
    if (p1 === points[0]) {
        if (p2 === points[1]) {
            return 2;
        } else if (p2 === points[2]) {
            return 1;
        }
    } else if (p1 === points[1]) {
        if (p2 === points[2]) {
            return 0;
        } else if (p2 === points[0]) {
            return 2;
        }
    } else if (p1 === points[2]) {
        if (p2 === points[0]) {
            return 1;
        } else if (p2 === points[1]) {
            return 0;
        }
    }
    return -1;
};

/**
 * Mark an edge of this triangle as constrained.
 * @private
 * @param {number} index - edge index
 */
Triangle.prototype.markConstrainedEdgeByIndex = function(index) {
    this.constrained_edge[index] = true;
};
/**
 * Mark an edge of this triangle as constrained.
 * @private
 * @param {Edge} edge instance
 */
Triangle.prototype.markConstrainedEdgeByEdge = function(edge) {
    this.markConstrainedEdgeByPoints(edge.p, edge.q);
};
/**
 * Mark an edge of this triangle as constrained.
 * This method takes two Point instances defining the edge of the triangle.
 * @private
 * @param {XY} p - point object with {x,y}
 * @param {XY} q - point object with {x,y}
 */
Triangle.prototype.markConstrainedEdgeByPoints = function(p, q) {
    var points = this.points_;
    // Here we are comparing point references, not values        
    if ((q === points[0] && p === points[1]) || (q === points[1] && p === points[0])) {
        this.constrained_edge[2] = true;
    } else if ((q === points[0] && p === points[2]) || (q === points[2] && p === points[0])) {
        this.constrained_edge[1] = true;
    } else if ((q === points[1] && p === points[2]) || (q === points[2] && p === points[1])) {
        this.constrained_edge[0] = true;
    }
};


// ---------------------------------------------------------Exports (public API)

module.exports = Triangle;


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright 2016 Todd Fleming
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
// 
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.



Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getLaserCutGcode = getLaserCutGcode;
exports.getLaserCutGcodeFromOp = getLaserCutGcodeFromOp;

var _cam = __webpack_require__(12);

var _mesh = __webpack_require__(2);

// Convert laser cut paths to gcode.
//      paths:          Array of CamPath
//      scale:          Factor to convert Clipper units to gcode units
//      offsetX:        Offset X (gcode units)
//      offsetY:        Offset Y (gcode units)
//      decimal:        Number of decimal places to keep in gcode
//      cutFeed:        Feedrate for horizontal cuts (gcode units)
//      laserPower:     [0, 100]
//      passes:         Number of passes
//      tabGeometry:    Tab geometry
//      gcodeToolOn:   Laser on (may be empty)
//      gcodeToolOff:  Laser off (may be empty)
//      gcodeSMaxValue: Max S value
function getLaserCutGcode(props) {
    let paths = props.paths,
        scale = props.scale,
        offsetX = props.offsetX,
        offsetY = props.offsetY,
        decimal = props.decimal,
        cutFeed = props.cutFeed,
        laserPower = props.laserPower,
        passes = props.passes,
        useA = props.useA,
        aAxisDiameter = props.aAxisDiameter,
        tabGeometry = props.tabGeometry,
        gcodeToolOn = props.gcodeToolOn,
        gcodeToolOff = props.gcodeToolOff,
        gcodeLaserIntensity = props.gcodeLaserIntensity,
        gcodeLaserIntensitySeparateLine = props.gcodeLaserIntensitySeparateLine,
        gcodeSMinValue = props.gcodeSMinValue,
        gcodeSMaxValue = props.gcodeSMaxValue,
        useZ = props.useZ,
        useBlower = props.useBlower,
        hookPassStart = props.hookPassStart,
        hookPassEnd = props.hookPassEnd;


    if (gcodeToolOn) gcodeToolOn += '\r\n';
    if (gcodeToolOff) gcodeToolOff += '\r\n';
    let laserOnS = gcodeLaserIntensity + (gcodeSMinValue + (gcodeSMaxValue - gcodeSMinValue) * laserPower / 100).toFixed(decimal);

    let lastX = 0,
        lastY = 0,
        lastA = 0;
    function convertPoint(p, rapid) {
        let x = p.X * scale + offsetX;
        let y = p.Y * scale + offsetY;
        if (useA) {
            let a = y * 360 / aAxisDiameter / Math.PI;
            let roundedX = Number(x.toFixed(decimal));
            let roundedA = Number(a.toFixed(decimal));
            let adjustedY = roundedA * aAxisDiameter * Math.PI / 360;
            if (rapid) {
                lastX = roundedX;
                lastY = adjustedY;
                lastA = roundedA;
                return 'G0 X' + x.toFixed(decimal) + ' A' + a.toFixed(decimal);
            } else {
                let dx = roundedX - lastX,
                    dy = adjustedY - lastY,
                    da = roundedA - lastA;
                let travelTime = Math.sqrt(dx * dx + dy * dy) / cutFeed;
                let f = 0;
                if (dx) f = Math.abs(dx) / travelTime;else if (da) f = Math.abs(da) / travelTime;else return '';
                lastX = roundedX;
                lastY = adjustedY;
                lastA = roundedA;
                return 'G1 X' + x.toFixed(decimal) + ' A' + a.toFixed(decimal) + ' F' + f.toFixed(decimal);
            }
        } else {
            if (rapid) return 'G0 X' + x.toFixed(decimal) + ' Y' + y.toFixed(decimal);else return 'G1 X' + x.toFixed(decimal) + ' Y' + y.toFixed(decimal);
        }
    }

    let gcode = '';

    for (let pass = 0; pass < passes; ++pass) {

        if (hookPassStart) gcode += hookPassStart;

        gcode += '\n\n; Pass ' + pass + '\r\n';

        if (useBlower) {
            if (useBlower.blowerOn) {
                gcode += `\r\n ${useBlower.blowerOn}; Enable Air assist\r\n`;
            }
        }

        let usedZposition = false;
        for (let pathIndex = 0; pathIndex < paths.length; ++pathIndex) {
            let path = paths[pathIndex].path;
            if (path.length === 0) continue;
            gcode += '\r\n; Pass ' + pass + ' Path ' + pathIndex + '\r\n';

            let separatedPaths = (0, _cam.separateTabs)(path, tabGeometry);
            for (let selectedIndex = 0; selectedIndex < separatedPaths.length; ++selectedIndex) {
                let selectedPath = separatedPaths[selectedIndex];
                if (selectedPath.length === 0) continue;
                if (selectedIndex & 1) {
                    gcode += '; Skip tab\r\n';
                    continue;
                }
                gcode += convertPoint(selectedPath[0], true) + '\r\n';

                if (useZ && !usedZposition) {
                    usedZposition = true;
                    let zHeight = useZ.startZ + useZ.offsetZ - useZ.passDepth * pass;
                    gcode += `; Pass Z Height ${zHeight}mm (Offset: ${useZ.offsetZ}mm)\r\n`;
                    gcode += 'G0 Z' + zHeight.toFixed(decimal) + '\r\n\r\n';
                }

                gcode += gcodeToolOn;
                for (let i = 1; i < selectedPath.length; ++i) {
                    if (i == 1 && gcodeLaserIntensitySeparateLine) gcode += laserOnS + '\n';
                    gcode += convertPoint(selectedPath[i], false);
                    if (i == 1 && !gcodeLaserIntensitySeparateLine) gcode += ' ' + laserOnS;
                    if (i == 1 && !useA) gcode += ' F' + cutFeed;
                    gcode += '\r\n';
                }
                gcode += gcodeToolOff;
            }
        }

        if (useBlower) {
            if (useBlower.blowerOff) {
                gcode += `\r\n ${useBlower.blowerOff}; Disable Air assist\r\n`;
            }
        }

        if (hookPassEnd) gcode += hookPassEnd;
    }

    return gcode;
}; // getLaserCutGcode

function getLaserCutGcodeFromOp(settings, opIndex, op, geometry, openGeometry, tabGeometry, showAlert, done, progress) {
    let ok = true;

    if (op.type !== 'Laser Cut' && op.type !== 'Laser Fill Path') {
        if (op.laserDiameter <= 0) {
            showAlert("Laser Diameter must be greater than 0", "danger");
            ok = false;
        }
    }
    if (op.type === 'Laser Fill Path') {
        if (op.lineDistance <= 0) {
            showAlert("Line Distance must be greater than 0", "danger");
            ok = false;
        }
    }
    if (op.laserPower < 0 || op.laserPower > 100) {
        showAlert("Laser Power must be in range [0, 100]", "danger");
        ok = false;
    }
    if (op.passes <= 0 || (op.passes | 0) !== +op.passes) {
        showAlert("Passes must be integer > 0", "danger");
        ok = false;
    }
    if (op.cutRate <= 0) {
        showAlert("Cut Rate must be greater than 0", "danger");
        ok = false;
    }
    if (op.useA) {
        if (op.aAxisDiameter <= 0) {
            showAlert("A axis diameter must be greater than 0", "danger");
            ok = false;
        }
    }

    if (settings.machineZEnabled) {
        if (op.startHeight === "" || isNaN(op.startHeight)) {
            showAlert("Start Height must be a valid number", "danger");
            ok = false;
        }
    }

    if (!ok) {
        done(false);
    }

    let camPaths = [];
    if (op.type === 'Laser Cut') {
        camPaths = (0, _cam.cut)(geometry, openGeometry, false);
    } else if (op.type === 'Laser Cut Inside') {
        if (op.margin) geometry = (0, _mesh.offset)(geometry, -op.margin * _mesh.mmToClipperScale);
        camPaths = (0, _cam.insideOutside)(geometry, op.laserDiameter * _mesh.mmToClipperScale, true, op.cutWidth * _mesh.mmToClipperScale, op.stepOver, op.direction === 'Climb', false);
    } else if (op.type === 'Laser Cut Outside') {
        if (op.margin) geometry = (0, _mesh.offset)(geometry, op.margin * _mesh.mmToClipperScale);
        camPaths = (0, _cam.insideOutside)(geometry, op.laserDiameter * _mesh.mmToClipperScale, false, op.cutWidth * _mesh.mmToClipperScale, op.stepOver, op.direction === 'Climb', false);
    } else if (op.type === 'Laser Fill Path') {
        if (op.margin) geometry = (0, _mesh.offset)(geometry, -op.margin * _mesh.mmToClipperScale);
        camPaths = (0, _cam.fillPath)(geometry, op.lineDistance * _mesh.mmToClipperScale, op.lineAngle);
    }

    (0, _cam.reduceCamPaths)(camPaths, op.segmentLength * _mesh.mmToClipperScale);

    let feedScale = 1;
    if (settings.toolFeedUnits === 'mm/s') feedScale = 60;

    let gcode = "\r\n;" + "\r\n; Operation:    " + opIndex + "\r\n; Type:         " + op.type + "\r\n; Paths:        " + camPaths.length + "\r\n; Passes:       " + op.passes + "\r\n; Cut rate:     " + op.cutRate + ' ' + settings.toolFeedUnits + "\r\n;\r\n";

    if (op.hookOperationStart.length) gcode += op.hookOperationStart;

    gcode += getLaserCutGcode({
        paths: camPaths,
        scale: 1 / _mesh.mmToClipperScale,
        offsetX: 0,
        offsetY: 0,
        decimal: 2,
        cutFeed: op.cutRate * feedScale,
        laserPower: op.laserPower,
        passes: op.passes,
        useA: op.useA,
        useZ: settings.machineZEnabled ? {
            startZ: Number(op.startHeight),
            offsetZ: settings.machineZToolOffset,
            passDepth: op.passDepth
        } : false,
        useBlower: op.useBlower ? {
            blowerOn: settings.machineBlowerGcodeOn,
            blowerOff: settings.machineBlowerGcodeOff
        } : false,
        aAxisDiameter: op.aAxisDiameter,
        tabGeometry: tabGeometry,
        gcodeToolOn: settings.gcodeToolOn,
        gcodeToolOff: settings.gcodeToolOff,
        gcodeLaserIntensity: settings.gcodeLaserIntensity,
        gcodeLaserIntensitySeparateLine: settings.gcodeLaserIntensitySeparateLine,
        gcodeSMinValue: settings.gcodeSMinValue,
        gcodeSMaxValue: settings.gcodeSMaxValue,

        hookPassStart: op.hookPassStart,
        hookPassEnd: op.hookPassEnd
    });

    if (op.hookOperationEnd.length) gcode += op.hookOperationEnd;

    done(gcode);
} // getLaserCutGcodeFromOp

;

var _temp = function () {
    if (typeof __REACT_HOT_LOADER__ === 'undefined') {
        return;
    }

    __REACT_HOT_LOADER__.register(getLaserCutGcode, 'getLaserCutGcode', 'C:/Users/cprez/git/LaserWeb/LaserWeb4/src/lib/cam-gcode-laser-cut.js');

    __REACT_HOT_LOADER__.register(getLaserCutGcodeFromOp, 'getLaserCutGcodeFromOp', 'C:/Users/cprez/git/LaserWeb/LaserWeb4/src/lib/cam-gcode-laser-cut.js');
}();

;

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright 2014, 2016 Todd Fleming
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.



Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.dist = dist;
exports.pocket = pocket;
exports.insideOutside = insideOutside;
exports.cut = cut;
exports.fillPath = fillPath;
exports.vCarve = vCarve;
exports.reduceCamPaths = reduceCamPaths;
exports.getClipperPathsFromCamPaths = getClipperPathsFromCamPaths;
exports.separateTabs = separateTabs;

var _clipperLib = __webpack_require__(3);

var _clipperLib2 = _interopRequireDefault(_clipperLib);

var _glMatrix = __webpack_require__(14);

var _mesh = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

__webpack_require__(26);

function dist(x1, y1, x2, y2) {
    return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
}

// Does the line from p1 to p2 cross outside of bounds?
function crosses(bounds, p1, p2) {
    if (bounds === null) return true;
    if (p1.X === p2.X && p1.Y === p2.Y) return false;
    let clipper = new _clipperLib2.default.Clipper();
    clipper.AddPath([p1, p2], _clipperLib2.default.PolyType.ptSubject, false);
    clipper.AddPaths(bounds, _clipperLib2.default.PolyType.ptClip, true);
    let result = new _clipperLib2.default.PolyTree();
    clipper.Execute(_clipperLib2.default.ClipType.ctIntersection, result, _clipperLib2.default.PolyFillType.pftEvenOdd, _clipperLib2.default.PolyFillType.pftEvenOdd);
    if (result.ChildCount() === 1) {
        let child = result.Childs()[0];
        let points = child.Contour();
        if (points.length === 2) {
            if (points[0].X === p1.X && points[1].X === p2.X && points[0].Y === p1.Y && points[1].Y === p2.Y) return false;
            if (points[0].X === p2.X && points[1].X === p1.X && points[0].Y === p2.Y && points[1].Y === p1.Y) return false;
        }
    }
    return true;
}

function pathIsClosed(clipperPath) {
    return clipperPath.length >= 2 && clipperPath[0].X === clipperPath[clipperPath.length - 1].X && clipperPath[0].Y === clipperPath[clipperPath.length - 1].Y;
}

// Close all paths
function closeClipperPaths(paths) {
    for (let path of paths) path.push(path[0]);
}

// CamPath has this format: {
//      path:               Clipper path
//      safeToClose:        Is it safe to close the path without retracting?
// }

// Try to merge paths. A merged path doesn't cross outside of bounds. Returns array of CamPath.
// If paths contains both open and closed paths, then the closed paths must be before the open
// paths within the array.
function mergePaths(bounds, paths) {
    if (paths.length === 0) return [];

    let currentPath = paths[0];
    if (pathIsClosed(currentPath)) currentPath.push(currentPath[0]);
    let currentPoint = currentPath[currentPath.length - 1];
    paths[0] = [];

    let mergedPaths = [];
    let numLeft = paths.length - 1;
    while (numLeft > 0) {
        let closestPathIndex = null;
        let closestPointIndex = null;
        let closestPointDist = null;
        let closestReverse = false;
        for (let pathIndex = 0; pathIndex < paths.length; ++pathIndex) {
            let path = paths[pathIndex];
            function check(pointIndex) {
                let point = path[pointIndex];
                let dist = (currentPoint.X - point.X) * (currentPoint.X - point.X) + (currentPoint.Y - point.Y) * (currentPoint.Y - point.Y);
                if (closestPointDist === null || dist < closestPointDist) {
                    closestPathIndex = pathIndex;
                    closestPointIndex = pointIndex;
                    closestPointDist = dist;
                    closestReverse = false;
                    return true;
                } else return false;
            }
            if (pathIsClosed(path)) {
                for (let pointIndex = 0; pointIndex < path.length; ++pointIndex) check(pointIndex);
            } else if (path.length) {
                check(0);
                if (check(path.length - 1)) closestReverse = true;
            }
        }

        let path = paths[closestPathIndex];
        paths[closestPathIndex] = [];
        numLeft -= 1;
        let needNew;
        if (pathIsClosed(path)) {
            needNew = crosses(bounds, currentPoint, path[closestPointIndex]);
            path = path.slice(closestPointIndex, path.length).concat(path.slice(1, closestPointIndex));
            path.push(path[0]);
        } else {
            needNew = true;
            if (closestReverse) {
                path = path.slice();
                path.reverse();
            }
        }
        if (needNew) {
            mergedPaths.push(currentPath);
            currentPath = path;
            currentPoint = currentPath[currentPath.length - 1];
        } else {
            currentPath = currentPath.concat(path);
            currentPoint = currentPath[currentPath.length - 1];
        }
    }
    mergedPaths.push(currentPath);

    let camPaths = [];
    for (let i = 0; i < mergedPaths.length; ++i) {
        let path = mergedPaths[i];
        camPaths.push({
            path: path,
            safeToClose: !crosses(bounds, path[0], path[path.length - 1])
        });
    }

    return camPaths;
}

// Compute paths for pocket operation on Clipper geometry. Returns array
// of CamPath. cutterDia is in Clipper units. stepover is in the range (0, 100).
function pocket(geometry, cutterDia, stepover, climb) {
    stepover = stepover / 100;
    let current = (0, _mesh.offset)(geometry, -cutterDia / 2);
    let bounds = current.slice(0);
    let allPaths = [];
    while (current.length !== 0) {
        if (!climb) for (let i = 0; i < current.length; ++i) current[i].reverse();
        allPaths = current.concat(allPaths);
        current = (0, _mesh.offset)(current, -cutterDia * stepover);
    }
    closeClipperPaths(allPaths);
    return mergePaths(bounds, allPaths);
};

// Compute paths for inside/outside operation on Clipper geometry. Returns array
// of CamPath. cutterDia and width are in Clipper units. stepover is in the
// range (0, 100].
function insideOutside(geometry, cutterDia, isInside, width, stepover, climb, allowRecutInBounds) {

    stepover = stepover / 100;
    width = Math.max(width, cutterDia);

    let currentWidth = cutterDia;
    let allPaths = [];
    let eachWidth = cutterDia * stepover;

    let current;
    let bounds = null;
    let eachOffset;
    let needReverse;

    if (isInside) {
        current = (0, _mesh.offset)(geometry, -cutterDia / 2);
        if (allowRecutInBounds) bounds = (0, _mesh.diff)(current, (0, _mesh.offset)(geometry, -(width - cutterDia / 2)));
        eachOffset = -eachWidth;
        needReverse = !climb;
    } else {
        current = (0, _mesh.offset)(geometry, cutterDia / 2);
        if (allowRecutInBounds) bounds = (0, _mesh.diff)((0, _mesh.offset)(geometry, width - cutterDia / 2), current);
        eachOffset = eachWidth;
        needReverse = climb;
    }

    while (currentWidth <= width) {
        if (needReverse) for (let i = 0; i < current.length; ++i) current[i].reverse();
        allPaths = current.concat(allPaths);
        let nextWidth = currentWidth + eachWidth;
        if (nextWidth > width && width - currentWidth > 0) {
            current = (0, _mesh.offset)(current, width - currentWidth);
            if (needReverse) for (let i = 0; i < current.length; ++i) current[i].reverse();
            allPaths = current.concat(allPaths);
            break;
        }
        currentWidth = nextWidth;
        if (currentWidth <= width) current = (0, _mesh.offset)(current, eachOffset);
    }
    closeClipperPaths(allPaths);
    return mergePaths(bounds, allPaths);
};

// Compute paths for cut operation on Clipper geometry. Returns array
// of CamPath.
function cut(geometry, openGeometry, climb) {
    let allPaths = [];
    for (let i = 0; i < geometry.length; ++i) {
        let path = geometry[i].slice(0);
        if (climb) path.reverse();
        path.push(path[0]);
        allPaths.push(path);
    }
    for (let path of openGeometry) allPaths.push(path.slice());
    let result = mergePaths(null, allPaths);
    for (let i = 0; i < result.length; ++i) result[i].safeToClose = pathIsClosed(result[i].path);
    return result;
};

function fillPath(geometry, lineDistance, angle) {
    if (!geometry.length || !geometry[0].length) return [];
    let bounds = (0, _mesh.clipperBounds)(geometry);
    let cx = (bounds.minX + bounds.maxX) / 2;
    let cy = (bounds.minY + bounds.maxY) / 2;
    let r = dist(cx, cy, bounds.minX, bounds.minY) + lineDistance;

    let m = _glMatrix.mat3.fromTranslation([], [cx, cy]);
    m = _glMatrix.mat3.rotate([], m, angle * Math.PI / 180);
    m = _glMatrix.mat3.translate([], m, [-cx, -cy]);
    let makePoint = (x, y) => {
        let p = _glMatrix.vec2.transformMat3([], [x, y], m);
        return { X: p[0], Y: p[1] };
    };

    let scan = [];
    for (let y = cy - r; y < cy + r; y += lineDistance * 2) {
        scan.push(makePoint(cx - r, y), makePoint(cx + r, y), makePoint(cx + r, y + lineDistance), makePoint(cx - r, y + lineDistance));
    }

    let allPaths = [];
    let separated = separateTabs(scan, geometry);
    for (let i = 1; i < separated.length; i += 2) allPaths.push(separated[i]);
    return mergePaths(null, allPaths);
};

function vCarve(geometry, cutterAngle, passDepth) {
    if (cutterAngle <= 0 || cutterAngle >= 180) return [];

    let memoryBlocks = [];
    let cGeometry = (0, _mesh.clipperPathsToCPaths)(memoryBlocks, geometry);
    let resultPathsRef = Module._malloc(4);
    let resultNumPathsRef = Module._malloc(4);
    let resultPathSizesRef = Module._malloc(4);
    memoryBlocks.push(resultPathsRef);
    memoryBlocks.push(resultNumPathsRef);
    memoryBlocks.push(resultPathSizesRef);

    let debugArg0 = 0,
        debugArg1 = 0;

    //extern "C" void vCarve(
    //    int debugArg0, int debugArg1,
    //    double** paths, int numPaths, int* pathSizes,
    //    double cutterAngle, double passDepth,
    //    double**& resultPaths, int& resultNumPaths, int*& resultPathSizes)
    Module.ccall('vCarve', 'void', ['number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number'], [debugArg0, debugArg1, cGeometry[0], cGeometry[1], cGeometry[2], cutterAngle, passDepth * _mesh.clipperToCppScale, resultPathsRef, resultNumPathsRef, resultPathSizesRef]);

    let result = (0, _mesh.cPathsToCamPaths)(memoryBlocks, resultPathsRef, resultNumPathsRef, resultPathSizesRef);

    for (let i = 0; i < memoryBlocks.length; ++i) Module._free(memoryBlocks[i]);

    return result;
};

function reduceCamPaths(camPaths, minDist) {
    let minDistSqr = minDist * minDist;
    let distSqr = (p1, p2) => (p1.X - p2.X) * (p1.X - p2.X) + (p1.Y - p2.Y) * (p1.Y - p2.Y);
    for (let camPath of camPaths) {
        let path = camPath.path;
        let newPath = [path[0]];
        for (let i = 1; i < path.length - 1; ++i) {
            let sq = distSqr(path[i], newPath[newPath.length - 1]);
            if (sq > 0 && sq >= minDistSqr) newPath.push(path[i]);
        }
        newPath.push(path[path.length - 1]);
        camPath.path = newPath;
    }
}

// Convert array of CamPath to array of Clipper path
function getClipperPathsFromCamPaths(paths) {
    let result = [];
    if (paths !== null) for (let i = 0; i < paths.length; ++i) result.push(paths[i].path);
    return result;
}

let displayedCppTabError1 = false;
let displayedCppTabError2 = false;

function separateTabs(cutterPath, tabGeometry) {
    if (tabGeometry.length === 0) return [cutterPath];
    if (typeof Module === 'undefined') {
        if (!displayedCppTabError1) {
            showAlert("Failed to load cam-cpp.js; tabs will be missing. This message will not repeat.", "danger", false);
            displayedCppTabError1 = true;
        }
        return cutterPath;
    }

    let memoryBlocks = [];

    let cCutterPath = (0, _mesh.clipperPathsToCPaths)(memoryBlocks, [cutterPath]);
    let cTabGeometry = (0, _mesh.clipperPathsToCPaths)(memoryBlocks, tabGeometry);

    let errorRef = Module._malloc(4);
    let resultPathsRef = Module._malloc(4);
    let resultNumPathsRef = Module._malloc(4);
    let resultPathSizesRef = Module._malloc(4);
    memoryBlocks.push(errorRef);
    memoryBlocks.push(resultPathsRef);
    memoryBlocks.push(resultNumPathsRef);
    memoryBlocks.push(resultPathSizesRef);

    //extern "C" void separateTabs(
    //    double** pathPolygons, int numPaths, int* pathSizes,
    //    double** tabPolygons, int numTabPolygons, int* tabPolygonSizes,
    //    bool& error,
    //    double**& resultPaths, int& resultNumPaths, int*& resultPathSizes)
    Module.ccall('separateTabs', 'void', ['number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number'], [cCutterPath[0], cCutterPath[1], cCutterPath[2], cTabGeometry[0], cTabGeometry[1], cTabGeometry[2], errorRef, resultPathsRef, resultNumPathsRef, resultPathSizesRef]);

    if (Module.HEAPU32[errorRef >> 2] && !displayedCppTabError2) {
        showAlert("Internal error processing tabs; tabs will be missing. This message will not repeat.", "danger", false);
        displayedCppTabError2 = true;
    }

    let result = (0, _mesh.cPathsToClipperPaths)(memoryBlocks, resultPathsRef, resultNumPathsRef, resultPathSizesRef);

    for (let i = 0; i < memoryBlocks.length; ++i) Module._free(memoryBlocks[i]);

    return result;
}
;

var _temp = function () {
    if (typeof __REACT_HOT_LOADER__ === 'undefined') {
        return;
    }

    __REACT_HOT_LOADER__.register(dist, 'dist', 'C:/Users/cprez/git/LaserWeb/LaserWeb4/src/lib/cam.js');

    __REACT_HOT_LOADER__.register(crosses, 'crosses', 'C:/Users/cprez/git/LaserWeb/LaserWeb4/src/lib/cam.js');

    __REACT_HOT_LOADER__.register(pathIsClosed, 'pathIsClosed', 'C:/Users/cprez/git/LaserWeb/LaserWeb4/src/lib/cam.js');

    __REACT_HOT_LOADER__.register(closeClipperPaths, 'closeClipperPaths', 'C:/Users/cprez/git/LaserWeb/LaserWeb4/src/lib/cam.js');

    __REACT_HOT_LOADER__.register(mergePaths, 'mergePaths', 'C:/Users/cprez/git/LaserWeb/LaserWeb4/src/lib/cam.js');

    __REACT_HOT_LOADER__.register(pocket, 'pocket', 'C:/Users/cprez/git/LaserWeb/LaserWeb4/src/lib/cam.js');

    __REACT_HOT_LOADER__.register(insideOutside, 'insideOutside', 'C:/Users/cprez/git/LaserWeb/LaserWeb4/src/lib/cam.js');

    __REACT_HOT_LOADER__.register(cut, 'cut', 'C:/Users/cprez/git/LaserWeb/LaserWeb4/src/lib/cam.js');

    __REACT_HOT_LOADER__.register(fillPath, 'fillPath', 'C:/Users/cprez/git/LaserWeb/LaserWeb4/src/lib/cam.js');

    __REACT_HOT_LOADER__.register(vCarve, 'vCarve', 'C:/Users/cprez/git/LaserWeb/LaserWeb4/src/lib/cam.js');

    __REACT_HOT_LOADER__.register(reduceCamPaths, 'reduceCamPaths', 'C:/Users/cprez/git/LaserWeb/LaserWeb4/src/lib/cam.js');

    __REACT_HOT_LOADER__.register(getClipperPathsFromCamPaths, 'getClipperPathsFromCamPaths', 'C:/Users/cprez/git/LaserWeb/LaserWeb4/src/lib/cam.js');

    __REACT_HOT_LOADER__.register(displayedCppTabError1, 'displayedCppTabError1', 'C:/Users/cprez/git/LaserWeb/LaserWeb4/src/lib/cam.js');

    __REACT_HOT_LOADER__.register(displayedCppTabError2, 'displayedCppTabError2', 'C:/Users/cprez/git/LaserWeb/LaserWeb4/src/lib/cam.js');

    __REACT_HOT_LOADER__.register(separateTabs, 'separateTabs', 'C:/Users/cprez/git/LaserWeb/LaserWeb4/src/lib/cam.js');
}();

;

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _camGcodeLaserCut = __webpack_require__(11);

onmessage = event => {
    var _event$data = event.data;
    let settings = _event$data.settings,
        opIndex = _event$data.opIndex,
        op = _event$data.op;
    var _event$data$geometry = _event$data.geometry;
    let geometry = _event$data$geometry === undefined ? [] : _event$data$geometry;
    var _event$data$openGeome = _event$data.openGeometry;
    let openGeometry = _event$data$openGeome === undefined ? [] : _event$data$openGeome;
    var _event$data$tabGeomet = _event$data.tabGeometry;
    let tabGeometry = _event$data$tabGeomet === undefined ? [] : _event$data$tabGeomet;


    const errors = [];

    const showAlert = (message, level) => {
        errors.push({ message, level });
    };
    const progress = () => {
        postMessage(JSON.stringify({ event: "onProgress", gcode, errors }));
    };
    const done = gcode => {
        if (gcode === false && errors.length) {
            postMessage(JSON.stringify({ event: "onError", errors }));
        } else {
            postMessage(JSON.stringify({ event: "onDone", gcode }));
        }
        self.close();
    };

    _camGcodeLaserCut.getLaserCutGcodeFromOp.apply(undefined, [settings, opIndex, op, geometry, openGeometry, tabGeometry, showAlert, done, progress]);
};
;

var _temp = function () {
    if (typeof __REACT_HOT_LOADER__ === 'undefined') {
        return;
    }
}();

;

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @fileoverview gl-matrix - High performance matrix and vector operations
 * @author Brandon Jones
 * @author Colin MacKenzie IV
 * @version 2.3.2
 */

/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */
// END HEADER

exports.glMatrix = __webpack_require__(0);
exports.mat2 = __webpack_require__(15);
exports.mat2d = __webpack_require__(16);
exports.mat3 = __webpack_require__(4);
exports.mat4 = __webpack_require__(17);
exports.quat = __webpack_require__(18);
exports.vec2 = __webpack_require__(19);
exports.vec3 = __webpack_require__(5);
exports.vec4 = __webpack_require__(6);

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = __webpack_require__(0);

/**
 * @class 2x2 Matrix
 * @name mat2
 */
var mat2 = {};

/**
 * Creates a new identity mat2
 *
 * @returns {mat2} a new 2x2 matrix
 */
mat2.create = function() {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Creates a new mat2 initialized with values from an existing matrix
 *
 * @param {mat2} a matrix to clone
 * @returns {mat2} a new 2x2 matrix
 */
mat2.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Copy the values from one mat2 to another
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Set a mat2 to the identity matrix
 *
 * @param {mat2} out the receiving matrix
 * @returns {mat2} out
 */
mat2.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Create a new mat2 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out A new 2x2 matrix
 */
mat2.fromValues = function(m00, m01, m10, m11) {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = m00;
    out[1] = m01;
    out[2] = m10;
    out[3] = m11;
    return out;
};

/**
 * Set the components of a mat2 to the given values
 *
 * @param {mat2} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out
 */
mat2.set = function(out, m00, m01, m10, m11) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m10;
    out[3] = m11;
    return out;
};


/**
 * Transpose the values of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a1 = a[1];
        out[1] = a[2];
        out[2] = a1;
    } else {
        out[0] = a[0];
        out[1] = a[2];
        out[2] = a[1];
        out[3] = a[3];
    }
    
    return out;
};

/**
 * Inverts a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.invert = function(out, a) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],

        // Calculate the determinant
        det = a0 * a3 - a2 * a1;

    if (!det) {
        return null;
    }
    det = 1.0 / det;
    
    out[0] =  a3 * det;
    out[1] = -a1 * det;
    out[2] = -a2 * det;
    out[3] =  a0 * det;

    return out;
};

/**
 * Calculates the adjugate of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.adjoint = function(out, a) {
    // Caching this value is nessecary if out == a
    var a0 = a[0];
    out[0] =  a[3];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] =  a0;

    return out;
};

/**
 * Calculates the determinant of a mat2
 *
 * @param {mat2} a the source matrix
 * @returns {Number} determinant of a
 */
mat2.determinant = function (a) {
    return a[0] * a[3] - a[2] * a[1];
};

/**
 * Multiplies two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */
mat2.multiply = function (out, a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    out[0] = a0 * b0 + a2 * b1;
    out[1] = a1 * b0 + a3 * b1;
    out[2] = a0 * b2 + a2 * b3;
    out[3] = a1 * b2 + a3 * b3;
    return out;
};

/**
 * Alias for {@link mat2.multiply}
 * @function
 */
mat2.mul = mat2.multiply;

/**
 * Rotates a mat2 by the given angle
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */
mat2.rotate = function (out, a, rad) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
        s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = a0 *  c + a2 * s;
    out[1] = a1 *  c + a3 * s;
    out[2] = a0 * -s + a2 * c;
    out[3] = a1 * -s + a3 * c;
    return out;
};

/**
 * Scales the mat2 by the dimensions in the given vec2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2} out
 **/
mat2.scale = function(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
        v0 = v[0], v1 = v[1];
    out[0] = a0 * v0;
    out[1] = a1 * v0;
    out[2] = a2 * v1;
    out[3] = a3 * v1;
    return out;
};

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.rotate(dest, dest, rad);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */
mat2.fromRotation = function(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = c;
    out[1] = s;
    out[2] = -s;
    out[3] = c;
    return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.scale(dest, dest, vec);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat2} out
 */
mat2.fromScaling = function(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = v[1];
    return out;
}

/**
 * Returns a string representation of a mat2
 *
 * @param {mat2} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat2.str = function (a) {
    return 'mat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

/**
 * Returns Frobenius norm of a mat2
 *
 * @param {mat2} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat2.frob = function (a) {
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2)))
};

/**
 * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
 * @param {mat2} L the lower triangular matrix 
 * @param {mat2} D the diagonal matrix 
 * @param {mat2} U the upper triangular matrix 
 * @param {mat2} a the input matrix to factorize
 */

mat2.LDU = function (L, D, U, a) { 
    L[2] = a[2]/a[0]; 
    U[0] = a[0]; 
    U[1] = a[1]; 
    U[3] = a[3] - L[2] * U[1]; 
    return [L, D, U];       
}; 

/**
 * Adds two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */
mat2.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    return out;
};

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */
mat2.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    return out;
};

/**
 * Alias for {@link mat2.subtract}
 * @function
 */
mat2.sub = mat2.subtract;

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat2} a The first matrix.
 * @param {mat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat2.exactEquals = function (a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
};

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat2} a The first matrix.
 * @param {mat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat2.equals = function (a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
            Math.abs(a3 - b3) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a3), Math.abs(b3)));
};

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2} out
 */
mat2.multiplyScalar = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    return out;
};

/**
 * Adds two mat2's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2} out the receiving vector
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2} out
 */
mat2.multiplyScalarAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    out[3] = a[3] + (b[3] * scale);
    return out;
};

module.exports = mat2;


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = __webpack_require__(0);

/**
 * @class 2x3 Matrix
 * @name mat2d
 * 
 * @description 
 * A mat2d contains six elements defined as:
 * <pre>
 * [a, c, tx,
 *  b, d, ty]
 * </pre>
 * This is a short form for the 3x3 matrix:
 * <pre>
 * [a, c, tx,
 *  b, d, ty,
 *  0, 0, 1]
 * </pre>
 * The last row is ignored so the array is shorter and operations are faster.
 */
var mat2d = {};

/**
 * Creates a new identity mat2d
 *
 * @returns {mat2d} a new 2x3 matrix
 */
mat2d.create = function() {
    var out = new glMatrix.ARRAY_TYPE(6);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = 0;
    out[5] = 0;
    return out;
};

/**
 * Creates a new mat2d initialized with values from an existing matrix
 *
 * @param {mat2d} a matrix to clone
 * @returns {mat2d} a new 2x3 matrix
 */
mat2d.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(6);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    return out;
};

/**
 * Copy the values from one mat2d to another
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */
mat2d.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    return out;
};

/**
 * Set a mat2d to the identity matrix
 *
 * @param {mat2d} out the receiving matrix
 * @returns {mat2d} out
 */
mat2d.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = 0;
    out[5] = 0;
    return out;
};

/**
 * Create a new mat2d with the given values
 *
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} A new mat2d
 */
mat2d.fromValues = function(a, b, c, d, tx, ty) {
    var out = new glMatrix.ARRAY_TYPE(6);
    out[0] = a;
    out[1] = b;
    out[2] = c;
    out[3] = d;
    out[4] = tx;
    out[5] = ty;
    return out;
};

/**
 * Set the components of a mat2d to the given values
 *
 * @param {mat2d} out the receiving matrix
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} out
 */
mat2d.set = function(out, a, b, c, d, tx, ty) {
    out[0] = a;
    out[1] = b;
    out[2] = c;
    out[3] = d;
    out[4] = tx;
    out[5] = ty;
    return out;
};

/**
 * Inverts a mat2d
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */
mat2d.invert = function(out, a) {
    var aa = a[0], ab = a[1], ac = a[2], ad = a[3],
        atx = a[4], aty = a[5];

    var det = aa * ad - ab * ac;
    if(!det){
        return null;
    }
    det = 1.0 / det;

    out[0] = ad * det;
    out[1] = -ab * det;
    out[2] = -ac * det;
    out[3] = aa * det;
    out[4] = (ac * aty - ad * atx) * det;
    out[5] = (ab * atx - aa * aty) * det;
    return out;
};

/**
 * Calculates the determinant of a mat2d
 *
 * @param {mat2d} a the source matrix
 * @returns {Number} determinant of a
 */
mat2d.determinant = function (a) {
    return a[0] * a[3] - a[1] * a[2];
};

/**
 * Multiplies two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */
mat2d.multiply = function (out, a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5];
    out[0] = a0 * b0 + a2 * b1;
    out[1] = a1 * b0 + a3 * b1;
    out[2] = a0 * b2 + a2 * b3;
    out[3] = a1 * b2 + a3 * b3;
    out[4] = a0 * b4 + a2 * b5 + a4;
    out[5] = a1 * b4 + a3 * b5 + a5;
    return out;
};

/**
 * Alias for {@link mat2d.multiply}
 * @function
 */
mat2d.mul = mat2d.multiply;

/**
 * Rotates a mat2d by the given angle
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */
mat2d.rotate = function (out, a, rad) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = a0 *  c + a2 * s;
    out[1] = a1 *  c + a3 * s;
    out[2] = a0 * -s + a2 * c;
    out[3] = a1 * -s + a3 * c;
    out[4] = a4;
    out[5] = a5;
    return out;
};

/**
 * Scales the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2d} out
 **/
mat2d.scale = function(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        v0 = v[0], v1 = v[1];
    out[0] = a0 * v0;
    out[1] = a1 * v0;
    out[2] = a2 * v1;
    out[3] = a3 * v1;
    out[4] = a4;
    out[5] = a5;
    return out;
};

/**
 * Translates the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to translate the matrix by
 * @returns {mat2d} out
 **/
mat2d.translate = function(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        v0 = v[0], v1 = v[1];
    out[0] = a0;
    out[1] = a1;
    out[2] = a2;
    out[3] = a3;
    out[4] = a0 * v0 + a2 * v1 + a4;
    out[5] = a1 * v0 + a3 * v1 + a5;
    return out;
};

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.rotate(dest, dest, rad);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */
mat2d.fromRotation = function(out, rad) {
    var s = Math.sin(rad), c = Math.cos(rad);
    out[0] = c;
    out[1] = s;
    out[2] = -s;
    out[3] = c;
    out[4] = 0;
    out[5] = 0;
    return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.scale(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat2d} out
 */
mat2d.fromScaling = function(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = v[1];
    out[4] = 0;
    out[5] = 0;
    return out;
}

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.translate(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {vec2} v Translation vector
 * @returns {mat2d} out
 */
mat2d.fromTranslation = function(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = v[0];
    out[5] = v[1];
    return out;
}

/**
 * Returns a string representation of a mat2d
 *
 * @param {mat2d} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat2d.str = function (a) {
    return 'mat2d(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + 
                    a[3] + ', ' + a[4] + ', ' + a[5] + ')';
};

/**
 * Returns Frobenius norm of a mat2d
 *
 * @param {mat2d} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat2d.frob = function (a) { 
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + 1))
}; 

/**
 * Adds two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */
mat2d.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    return out;
};

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */
mat2d.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    out[4] = a[4] - b[4];
    out[5] = a[5] - b[5];
    return out;
};

/**
 * Alias for {@link mat2d.subtract}
 * @function
 */
mat2d.sub = mat2d.subtract;

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2d} out
 */
mat2d.multiplyScalar = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    return out;
};

/**
 * Adds two mat2d's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2d} out the receiving vector
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2d} out
 */
mat2d.multiplyScalarAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    out[3] = a[3] + (b[3] * scale);
    out[4] = a[4] + (b[4] * scale);
    out[5] = a[5] + (b[5] * scale);
    return out;
};

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat2d} a The first matrix.
 * @param {mat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat2d.exactEquals = function (a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5];
};

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat2d} a The first matrix.
 * @param {mat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat2d.equals = function (a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5];
    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
            Math.abs(a3 - b3) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a3), Math.abs(b3)) &&
            Math.abs(a4 - b4) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a4), Math.abs(b4)) &&
            Math.abs(a5 - b5) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a5), Math.abs(b5)));
};

module.exports = mat2d;


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = __webpack_require__(0);

/**
 * @class 4x4 Matrix
 * @name mat4
 */
var mat4 = {
  scalar: {},
  SIMD: {},
};

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */
mat4.create = function() {
    var out = new glMatrix.ARRAY_TYPE(16);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};

/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {mat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */
mat4.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(16);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Create a new mat4 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} A new mat4
 */
mat4.fromValues = function(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    var out = new glMatrix.ARRAY_TYPE(16);
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m03;
    out[4] = m10;
    out[5] = m11;
    out[6] = m12;
    out[7] = m13;
    out[8] = m20;
    out[9] = m21;
    out[10] = m22;
    out[11] = m23;
    out[12] = m30;
    out[13] = m31;
    out[14] = m32;
    out[15] = m33;
    return out;
};

/**
 * Set the components of a mat4 to the given values
 *
 * @param {mat4} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} out
 */
mat4.set = function(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m03;
    out[4] = m10;
    out[5] = m11;
    out[6] = m12;
    out[7] = m13;
    out[8] = m20;
    out[9] = m21;
    out[10] = m22;
    out[11] = m23;
    out[12] = m30;
    out[13] = m31;
    out[14] = m32;
    out[15] = m33;
    return out;
};


/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */
mat4.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};

/**
 * Transpose the values of a mat4 not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.scalar.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a01 = a[1], a02 = a[2], a03 = a[3],
            a12 = a[6], a13 = a[7],
            a23 = a[11];

        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a01;
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a02;
        out[9] = a12;
        out[11] = a[14];
        out[12] = a03;
        out[13] = a13;
        out[14] = a23;
    } else {
        out[0] = a[0];
        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a[1];
        out[5] = a[5];
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a[2];
        out[9] = a[6];
        out[10] = a[10];
        out[11] = a[14];
        out[12] = a[3];
        out[13] = a[7];
        out[14] = a[11];
        out[15] = a[15];
    }

    return out;
};

/**
 * Transpose the values of a mat4 using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.SIMD.transpose = function(out, a) {
    var a0, a1, a2, a3,
        tmp01, tmp23,
        out0, out1, out2, out3;

    a0 = SIMD.Float32x4.load(a, 0);
    a1 = SIMD.Float32x4.load(a, 4);
    a2 = SIMD.Float32x4.load(a, 8);
    a3 = SIMD.Float32x4.load(a, 12);

    tmp01 = SIMD.Float32x4.shuffle(a0, a1, 0, 1, 4, 5);
    tmp23 = SIMD.Float32x4.shuffle(a2, a3, 0, 1, 4, 5);
    out0  = SIMD.Float32x4.shuffle(tmp01, tmp23, 0, 2, 4, 6);
    out1  = SIMD.Float32x4.shuffle(tmp01, tmp23, 1, 3, 5, 7);
    SIMD.Float32x4.store(out, 0,  out0);
    SIMD.Float32x4.store(out, 4,  out1);

    tmp01 = SIMD.Float32x4.shuffle(a0, a1, 2, 3, 6, 7);
    tmp23 = SIMD.Float32x4.shuffle(a2, a3, 2, 3, 6, 7);
    out2  = SIMD.Float32x4.shuffle(tmp01, tmp23, 0, 2, 4, 6);
    out3  = SIMD.Float32x4.shuffle(tmp01, tmp23, 1, 3, 5, 7);
    SIMD.Float32x4.store(out, 8,  out2);
    SIMD.Float32x4.store(out, 12, out3);

    return out;
};

/**
 * Transpse a mat4 using SIMD if available and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.transpose = glMatrix.USE_SIMD ? mat4.SIMD.transpose : mat4.scalar.transpose;

/**
 * Inverts a mat4 not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.scalar.invert = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        // Calculate the determinant
        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) {
        return null;
    }
    det = 1.0 / det;

    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

    return out;
};

/**
 * Inverts a mat4 using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.SIMD.invert = function(out, a) {
  var row0, row1, row2, row3,
      tmp1,
      minor0, minor1, minor2, minor3,
      det,
      a0 = SIMD.Float32x4.load(a, 0),
      a1 = SIMD.Float32x4.load(a, 4),
      a2 = SIMD.Float32x4.load(a, 8),
      a3 = SIMD.Float32x4.load(a, 12);

  // Compute matrix adjugate
  tmp1 = SIMD.Float32x4.shuffle(a0, a1, 0, 1, 4, 5);
  row1 = SIMD.Float32x4.shuffle(a2, a3, 0, 1, 4, 5);
  row0 = SIMD.Float32x4.shuffle(tmp1, row1, 0, 2, 4, 6);
  row1 = SIMD.Float32x4.shuffle(row1, tmp1, 1, 3, 5, 7);
  tmp1 = SIMD.Float32x4.shuffle(a0, a1, 2, 3, 6, 7);
  row3 = SIMD.Float32x4.shuffle(a2, a3, 2, 3, 6, 7);
  row2 = SIMD.Float32x4.shuffle(tmp1, row3, 0, 2, 4, 6);
  row3 = SIMD.Float32x4.shuffle(row3, tmp1, 1, 3, 5, 7);

  tmp1   = SIMD.Float32x4.mul(row2, row3);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor0 = SIMD.Float32x4.mul(row1, tmp1);
  minor1 = SIMD.Float32x4.mul(row0, tmp1);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor0 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row1, tmp1), minor0);
  minor1 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor1);
  minor1 = SIMD.Float32x4.swizzle(minor1, 2, 3, 0, 1);

  tmp1   = SIMD.Float32x4.mul(row1, row2);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor0 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor0);
  minor3 = SIMD.Float32x4.mul(row0, tmp1);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor0 = SIMD.Float32x4.sub(minor0, SIMD.Float32x4.mul(row3, tmp1));
  minor3 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor3);
  minor3 = SIMD.Float32x4.swizzle(minor3, 2, 3, 0, 1);

  tmp1   = SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(row1, 2, 3, 0, 1), row3);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  row2   = SIMD.Float32x4.swizzle(row2, 2, 3, 0, 1);
  minor0 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row2, tmp1), minor0);
  minor2 = SIMD.Float32x4.mul(row0, tmp1);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor0 = SIMD.Float32x4.sub(minor0, SIMD.Float32x4.mul(row2, tmp1));
  minor2 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor2);
  minor2 = SIMD.Float32x4.swizzle(minor2, 2, 3, 0, 1);

  tmp1   = SIMD.Float32x4.mul(row0, row1);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor2 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor2);
  minor3 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row2, tmp1), minor3);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor2 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row3, tmp1), minor2);
  minor3 = SIMD.Float32x4.sub(minor3, SIMD.Float32x4.mul(row2, tmp1));

  tmp1   = SIMD.Float32x4.mul(row0, row3);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor1 = SIMD.Float32x4.sub(minor1, SIMD.Float32x4.mul(row2, tmp1));
  minor2 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row1, tmp1), minor2);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor1 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row2, tmp1), minor1);
  minor2 = SIMD.Float32x4.sub(minor2, SIMD.Float32x4.mul(row1, tmp1));

  tmp1   = SIMD.Float32x4.mul(row0, row2);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor1 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor1);
  minor3 = SIMD.Float32x4.sub(minor3, SIMD.Float32x4.mul(row1, tmp1));
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor1 = SIMD.Float32x4.sub(minor1, SIMD.Float32x4.mul(row3, tmp1));
  minor3 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row1, tmp1), minor3);

  // Compute matrix determinant
  det   = SIMD.Float32x4.mul(row0, minor0);
  det   = SIMD.Float32x4.add(SIMD.Float32x4.swizzle(det, 2, 3, 0, 1), det);
  det   = SIMD.Float32x4.add(SIMD.Float32x4.swizzle(det, 1, 0, 3, 2), det);
  tmp1  = SIMD.Float32x4.reciprocalApproximation(det);
  det   = SIMD.Float32x4.sub(
               SIMD.Float32x4.add(tmp1, tmp1),
               SIMD.Float32x4.mul(det, SIMD.Float32x4.mul(tmp1, tmp1)));
  det   = SIMD.Float32x4.swizzle(det, 0, 0, 0, 0);
  if (!det) {
      return null;
  }

  // Compute matrix inverse
  SIMD.Float32x4.store(out, 0,  SIMD.Float32x4.mul(det, minor0));
  SIMD.Float32x4.store(out, 4,  SIMD.Float32x4.mul(det, minor1));
  SIMD.Float32x4.store(out, 8,  SIMD.Float32x4.mul(det, minor2));
  SIMD.Float32x4.store(out, 12, SIMD.Float32x4.mul(det, minor3));
  return out;
}

/**
 * Inverts a mat4 using SIMD if available and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.invert = glMatrix.USE_SIMD ? mat4.SIMD.invert : mat4.scalar.invert;

/**
 * Calculates the adjugate of a mat4 not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.scalar.adjoint = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    out[0]  =  (a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22));
    out[1]  = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
    out[2]  =  (a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12));
    out[3]  = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
    out[4]  = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
    out[5]  =  (a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22));
    out[6]  = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
    out[7]  =  (a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12));
    out[8]  =  (a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21));
    out[9]  = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
    out[10] =  (a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11));
    out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
    out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
    out[13] =  (a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21));
    out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
    out[15] =  (a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11));
    return out;
};

/**
 * Calculates the adjugate of a mat4 using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.SIMD.adjoint = function(out, a) {
  var a0, a1, a2, a3;
  var row0, row1, row2, row3;
  var tmp1;
  var minor0, minor1, minor2, minor3;

  var a0 = SIMD.Float32x4.load(a, 0);
  var a1 = SIMD.Float32x4.load(a, 4);
  var a2 = SIMD.Float32x4.load(a, 8);
  var a3 = SIMD.Float32x4.load(a, 12);

  // Transpose the source matrix.  Sort of.  Not a true transpose operation
  tmp1 = SIMD.Float32x4.shuffle(a0, a1, 0, 1, 4, 5);
  row1 = SIMD.Float32x4.shuffle(a2, a3, 0, 1, 4, 5);
  row0 = SIMD.Float32x4.shuffle(tmp1, row1, 0, 2, 4, 6);
  row1 = SIMD.Float32x4.shuffle(row1, tmp1, 1, 3, 5, 7);

  tmp1 = SIMD.Float32x4.shuffle(a0, a1, 2, 3, 6, 7);
  row3 = SIMD.Float32x4.shuffle(a2, a3, 2, 3, 6, 7);
  row2 = SIMD.Float32x4.shuffle(tmp1, row3, 0, 2, 4, 6);
  row3 = SIMD.Float32x4.shuffle(row3, tmp1, 1, 3, 5, 7);

  tmp1   = SIMD.Float32x4.mul(row2, row3);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor0 = SIMD.Float32x4.mul(row1, tmp1);
  minor1 = SIMD.Float32x4.mul(row0, tmp1);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor0 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row1, tmp1), minor0);
  minor1 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor1);
  minor1 = SIMD.Float32x4.swizzle(minor1, 2, 3, 0, 1);

  tmp1   = SIMD.Float32x4.mul(row1, row2);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor0 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor0);
  minor3 = SIMD.Float32x4.mul(row0, tmp1);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor0 = SIMD.Float32x4.sub(minor0, SIMD.Float32x4.mul(row3, tmp1));
  minor3 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor3);
  minor3 = SIMD.Float32x4.swizzle(minor3, 2, 3, 0, 1);

  tmp1   = SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(row1, 2, 3, 0, 1), row3);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  row2   = SIMD.Float32x4.swizzle(row2, 2, 3, 0, 1);
  minor0 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row2, tmp1), minor0);
  minor2 = SIMD.Float32x4.mul(row0, tmp1);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor0 = SIMD.Float32x4.sub(minor0, SIMD.Float32x4.mul(row2, tmp1));
  minor2 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor2);
  minor2 = SIMD.Float32x4.swizzle(minor2, 2, 3, 0, 1);

  tmp1   = SIMD.Float32x4.mul(row0, row1);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor2 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor2);
  minor3 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row2, tmp1), minor3);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor2 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row3, tmp1), minor2);
  minor3 = SIMD.Float32x4.sub(minor3, SIMD.Float32x4.mul(row2, tmp1));

  tmp1   = SIMD.Float32x4.mul(row0, row3);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor1 = SIMD.Float32x4.sub(minor1, SIMD.Float32x4.mul(row2, tmp1));
  minor2 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row1, tmp1), minor2);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor1 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row2, tmp1), minor1);
  minor2 = SIMD.Float32x4.sub(minor2, SIMD.Float32x4.mul(row1, tmp1));

  tmp1   = SIMD.Float32x4.mul(row0, row2);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor1 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor1);
  minor3 = SIMD.Float32x4.sub(minor3, SIMD.Float32x4.mul(row1, tmp1));
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor1 = SIMD.Float32x4.sub(minor1, SIMD.Float32x4.mul(row3, tmp1));
  minor3 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row1, tmp1), minor3);

  SIMD.Float32x4.store(out, 0,  minor0);
  SIMD.Float32x4.store(out, 4,  minor1);
  SIMD.Float32x4.store(out, 8,  minor2);
  SIMD.Float32x4.store(out, 12, minor3);
  return out;
};

/**
 * Calculates the adjugate of a mat4 using SIMD if available and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
 mat4.adjoint = glMatrix.USE_SIMD ? mat4.SIMD.adjoint : mat4.scalar.adjoint;

/**
 * Calculates the determinant of a mat4
 *
 * @param {mat4} a the source matrix
 * @returns {Number} determinant of a
 */
mat4.determinant = function (a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32;

    // Calculate the determinant
    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
};

/**
 * Multiplies two mat4's explicitly using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand, must be a Float32Array
 * @param {mat4} b the second operand, must be a Float32Array
 * @returns {mat4} out
 */
mat4.SIMD.multiply = function (out, a, b) {
    var a0 = SIMD.Float32x4.load(a, 0);
    var a1 = SIMD.Float32x4.load(a, 4);
    var a2 = SIMD.Float32x4.load(a, 8);
    var a3 = SIMD.Float32x4.load(a, 12);

    var b0 = SIMD.Float32x4.load(b, 0);
    var out0 = SIMD.Float32x4.add(
                   SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b0, 0, 0, 0, 0), a0),
                   SIMD.Float32x4.add(
                       SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b0, 1, 1, 1, 1), a1),
                       SIMD.Float32x4.add(
                           SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b0, 2, 2, 2, 2), a2),
                           SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b0, 3, 3, 3, 3), a3))));
    SIMD.Float32x4.store(out, 0, out0);

    var b1 = SIMD.Float32x4.load(b, 4);
    var out1 = SIMD.Float32x4.add(
                   SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b1, 0, 0, 0, 0), a0),
                   SIMD.Float32x4.add(
                       SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b1, 1, 1, 1, 1), a1),
                       SIMD.Float32x4.add(
                           SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b1, 2, 2, 2, 2), a2),
                           SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b1, 3, 3, 3, 3), a3))));
    SIMD.Float32x4.store(out, 4, out1);

    var b2 = SIMD.Float32x4.load(b, 8);
    var out2 = SIMD.Float32x4.add(
                   SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b2, 0, 0, 0, 0), a0),
                   SIMD.Float32x4.add(
                       SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b2, 1, 1, 1, 1), a1),
                       SIMD.Float32x4.add(
                               SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b2, 2, 2, 2, 2), a2),
                               SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b2, 3, 3, 3, 3), a3))));
    SIMD.Float32x4.store(out, 8, out2);

    var b3 = SIMD.Float32x4.load(b, 12);
    var out3 = SIMD.Float32x4.add(
                   SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b3, 0, 0, 0, 0), a0),
                   SIMD.Float32x4.add(
                        SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b3, 1, 1, 1, 1), a1),
                        SIMD.Float32x4.add(
                            SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b3, 2, 2, 2, 2), a2),
                            SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b3, 3, 3, 3, 3), a3))));
    SIMD.Float32x4.store(out, 12, out3);

    return out;
};

/**
 * Multiplies two mat4's explicitly not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
mat4.scalar.multiply = function (out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    // Cache only the current line of the second matrix
    var b0  = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    out[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
    out[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
    out[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
    out[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
    return out;
};

/**
 * Multiplies two mat4's using SIMD if available and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
mat4.multiply = glMatrix.USE_SIMD ? mat4.SIMD.multiply : mat4.scalar.multiply;

/**
 * Alias for {@link mat4.multiply}
 * @function
 */
mat4.mul = mat4.multiply;

/**
 * Translate a mat4 by the given vector not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */
mat4.scalar.translate = function (out, a, v) {
    var x = v[0], y = v[1], z = v[2],
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23;

    if (a === out) {
        out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
        out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
        out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
        out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    } else {
        a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
        a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
        a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

        out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;
        out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;
        out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;

        out[12] = a00 * x + a10 * y + a20 * z + a[12];
        out[13] = a01 * x + a11 * y + a21 * z + a[13];
        out[14] = a02 * x + a12 * y + a22 * z + a[14];
        out[15] = a03 * x + a13 * y + a23 * z + a[15];
    }

    return out;
};

/**
 * Translates a mat4 by the given vector using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */
mat4.SIMD.translate = function (out, a, v) {
    var a0 = SIMD.Float32x4.load(a, 0),
        a1 = SIMD.Float32x4.load(a, 4),
        a2 = SIMD.Float32x4.load(a, 8),
        a3 = SIMD.Float32x4.load(a, 12),
        vec = SIMD.Float32x4(v[0], v[1], v[2] , 0);

    if (a !== out) {
        out[0] = a[0]; out[1] = a[1]; out[2] = a[2]; out[3] = a[3];
        out[4] = a[4]; out[5] = a[5]; out[6] = a[6]; out[7] = a[7];
        out[8] = a[8]; out[9] = a[9]; out[10] = a[10]; out[11] = a[11];
    }

    a0 = SIMD.Float32x4.mul(a0, SIMD.Float32x4.swizzle(vec, 0, 0, 0, 0));
    a1 = SIMD.Float32x4.mul(a1, SIMD.Float32x4.swizzle(vec, 1, 1, 1, 1));
    a2 = SIMD.Float32x4.mul(a2, SIMD.Float32x4.swizzle(vec, 2, 2, 2, 2));

    var t0 = SIMD.Float32x4.add(a0, SIMD.Float32x4.add(a1, SIMD.Float32x4.add(a2, a3)));
    SIMD.Float32x4.store(out, 12, t0);

    return out;
};

/**
 * Translates a mat4 by the given vector using SIMD if available and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */
mat4.translate = glMatrix.USE_SIMD ? mat4.SIMD.translate : mat4.scalar.translate;

/**
 * Scales the mat4 by the dimensions in the given vec3 not using vectorization
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/
mat4.scalar.scale = function(out, a, v) {
    var x = v[0], y = v[1], z = v[2];

    out[0] = a[0] * x;
    out[1] = a[1] * x;
    out[2] = a[2] * x;
    out[3] = a[3] * x;
    out[4] = a[4] * y;
    out[5] = a[5] * y;
    out[6] = a[6] * y;
    out[7] = a[7] * y;
    out[8] = a[8] * z;
    out[9] = a[9] * z;
    out[10] = a[10] * z;
    out[11] = a[11] * z;
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Scales the mat4 by the dimensions in the given vec3 using vectorization
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/
mat4.SIMD.scale = function(out, a, v) {
    var a0, a1, a2;
    var vec = SIMD.Float32x4(v[0], v[1], v[2], 0);

    a0 = SIMD.Float32x4.load(a, 0);
    SIMD.Float32x4.store(
        out, 0, SIMD.Float32x4.mul(a0, SIMD.Float32x4.swizzle(vec, 0, 0, 0, 0)));

    a1 = SIMD.Float32x4.load(a, 4);
    SIMD.Float32x4.store(
        out, 4, SIMD.Float32x4.mul(a1, SIMD.Float32x4.swizzle(vec, 1, 1, 1, 1)));

    a2 = SIMD.Float32x4.load(a, 8);
    SIMD.Float32x4.store(
        out, 8, SIMD.Float32x4.mul(a2, SIMD.Float32x4.swizzle(vec, 2, 2, 2, 2)));

    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Scales the mat4 by the dimensions in the given vec3 using SIMD if available and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 */
mat4.scale = glMatrix.USE_SIMD ? mat4.SIMD.scale : mat4.scalar.scale;

/**
 * Rotates a mat4 by the given angle around the given axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
mat4.rotate = function (out, a, rad, axis) {
    var x = axis[0], y = axis[1], z = axis[2],
        len = Math.sqrt(x * x + y * y + z * z),
        s, c, t,
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23,
        b00, b01, b02,
        b10, b11, b12,
        b20, b21, b22;

    if (Math.abs(len) < glMatrix.EPSILON) { return null; }

    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;

    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;

    a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
    a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
    a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

    // Construct the elements of the rotation matrix
    b00 = x * x * t + c; b01 = y * x * t + z * s; b02 = z * x * t - y * s;
    b10 = x * y * t - z * s; b11 = y * y * t + c; b12 = z * y * t + x * s;
    b20 = x * z * t + y * s; b21 = y * z * t - x * s; b22 = z * z * t + c;

    // Perform rotation-specific matrix multiplication
    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
    out[11] = a03 * b20 + a13 * b21 + a23 * b22;

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }
    return out;
};

/**
 * Rotates a matrix by the given angle around the X axis not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.scalar.rotateX = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[0]  = a[0];
        out[1]  = a[1];
        out[2]  = a[2];
        out[3]  = a[3];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[4] = a10 * c + a20 * s;
    out[5] = a11 * c + a21 * s;
    out[6] = a12 * c + a22 * s;
    out[7] = a13 * c + a23 * s;
    out[8] = a20 * c - a10 * s;
    out[9] = a21 * c - a11 * s;
    out[10] = a22 * c - a12 * s;
    out[11] = a23 * c - a13 * s;
    return out;
};

/**
 * Rotates a matrix by the given angle around the X axis using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.SIMD.rotateX = function (out, a, rad) {
    var s = SIMD.Float32x4.splat(Math.sin(rad)),
        c = SIMD.Float32x4.splat(Math.cos(rad));

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
      out[0]  = a[0];
      out[1]  = a[1];
      out[2]  = a[2];
      out[3]  = a[3];
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    var a_1 = SIMD.Float32x4.load(a, 4);
    var a_2 = SIMD.Float32x4.load(a, 8);
    SIMD.Float32x4.store(out, 4,
                         SIMD.Float32x4.add(SIMD.Float32x4.mul(a_1, c), SIMD.Float32x4.mul(a_2, s)));
    SIMD.Float32x4.store(out, 8,
                         SIMD.Float32x4.sub(SIMD.Float32x4.mul(a_2, c), SIMD.Float32x4.mul(a_1, s)));
    return out;
};

/**
 * Rotates a matrix by the given angle around the X axis using SIMD if availabe and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.rotateX = glMatrix.USE_SIMD ? mat4.SIMD.rotateX : mat4.scalar.rotateX;

/**
 * Rotates a matrix by the given angle around the Y axis not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.scalar.rotateY = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[4]  = a[4];
        out[5]  = a[5];
        out[6]  = a[6];
        out[7]  = a[7];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[0] = a00 * c - a20 * s;
    out[1] = a01 * c - a21 * s;
    out[2] = a02 * c - a22 * s;
    out[3] = a03 * c - a23 * s;
    out[8] = a00 * s + a20 * c;
    out[9] = a01 * s + a21 * c;
    out[10] = a02 * s + a22 * c;
    out[11] = a03 * s + a23 * c;
    return out;
};

/**
 * Rotates a matrix by the given angle around the Y axis using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.SIMD.rotateY = function (out, a, rad) {
    var s = SIMD.Float32x4.splat(Math.sin(rad)),
        c = SIMD.Float32x4.splat(Math.cos(rad));

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[4]  = a[4];
        out[5]  = a[5];
        out[6]  = a[6];
        out[7]  = a[7];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    var a_0 = SIMD.Float32x4.load(a, 0);
    var a_2 = SIMD.Float32x4.load(a, 8);
    SIMD.Float32x4.store(out, 0,
                         SIMD.Float32x4.sub(SIMD.Float32x4.mul(a_0, c), SIMD.Float32x4.mul(a_2, s)));
    SIMD.Float32x4.store(out, 8,
                         SIMD.Float32x4.add(SIMD.Float32x4.mul(a_0, s), SIMD.Float32x4.mul(a_2, c)));
    return out;
};

/**
 * Rotates a matrix by the given angle around the Y axis if SIMD available and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
 mat4.rotateY = glMatrix.USE_SIMD ? mat4.SIMD.rotateY : mat4.scalar.rotateY;

/**
 * Rotates a matrix by the given angle around the Z axis not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.scalar.rotateZ = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3],
        a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[8]  = a[8];
        out[9]  = a[9];
        out[10] = a[10];
        out[11] = a[11];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[0] = a00 * c + a10 * s;
    out[1] = a01 * c + a11 * s;
    out[2] = a02 * c + a12 * s;
    out[3] = a03 * c + a13 * s;
    out[4] = a10 * c - a00 * s;
    out[5] = a11 * c - a01 * s;
    out[6] = a12 * c - a02 * s;
    out[7] = a13 * c - a03 * s;
    return out;
};

/**
 * Rotates a matrix by the given angle around the Z axis using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.SIMD.rotateZ = function (out, a, rad) {
    var s = SIMD.Float32x4.splat(Math.sin(rad)),
        c = SIMD.Float32x4.splat(Math.cos(rad));

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[8]  = a[8];
        out[9]  = a[9];
        out[10] = a[10];
        out[11] = a[11];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    var a_0 = SIMD.Float32x4.load(a, 0);
    var a_1 = SIMD.Float32x4.load(a, 4);
    SIMD.Float32x4.store(out, 0,
                         SIMD.Float32x4.add(SIMD.Float32x4.mul(a_0, c), SIMD.Float32x4.mul(a_1, s)));
    SIMD.Float32x4.store(out, 4,
                         SIMD.Float32x4.sub(SIMD.Float32x4.mul(a_1, c), SIMD.Float32x4.mul(a_0, s)));
    return out;
};

/**
 * Rotates a matrix by the given angle around the Z axis if SIMD available and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
 mat4.rotateZ = glMatrix.USE_SIMD ? mat4.SIMD.rotateZ : mat4.scalar.rotateZ;

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
mat4.fromTranslation = function(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.scale(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Scaling vector
 * @returns {mat4} out
 */
mat4.fromScaling = function(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = v[1];
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = v[2];
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from a given angle around a given axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotate(dest, dest, rad, axis);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
mat4.fromRotation = function(out, rad, axis) {
    var x = axis[0], y = axis[1], z = axis[2],
        len = Math.sqrt(x * x + y * y + z * z),
        s, c, t;

    if (Math.abs(len) < glMatrix.EPSILON) { return null; }

    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;

    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;

    // Perform rotation-specific matrix multiplication
    out[0] = x * x * t + c;
    out[1] = y * x * t + z * s;
    out[2] = z * x * t - y * s;
    out[3] = 0;
    out[4] = x * y * t - z * s;
    out[5] = y * y * t + c;
    out[6] = z * y * t + x * s;
    out[7] = 0;
    out[8] = x * z * t + y * s;
    out[9] = y * z * t - x * s;
    out[10] = z * z * t + c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from the given angle around the X axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateX(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.fromXRotation = function(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad);

    // Perform axis-specific matrix multiplication
    out[0]  = 1;
    out[1]  = 0;
    out[2]  = 0;
    out[3]  = 0;
    out[4] = 0;
    out[5] = c;
    out[6] = s;
    out[7] = 0;
    out[8] = 0;
    out[9] = -s;
    out[10] = c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from the given angle around the Y axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateY(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.fromYRotation = function(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad);

    // Perform axis-specific matrix multiplication
    out[0]  = c;
    out[1]  = 0;
    out[2]  = -s;
    out[3]  = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = s;
    out[9] = 0;
    out[10] = c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from the given angle around the Z axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateZ(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.fromZRotation = function(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad);

    // Perform axis-specific matrix multiplication
    out[0]  = c;
    out[1]  = s;
    out[2]  = 0;
    out[3]  = 0;
    out[4] = -s;
    out[5] = c;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     var quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
mat4.fromRotationTranslation = function (out, q, v) {
    // Quaternion math
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        xy = x * y2,
        xz = x * z2,
        yy = y * y2,
        yz = y * z2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - (yy + zz);
    out[1] = xy + wz;
    out[2] = xz - wy;
    out[3] = 0;
    out[4] = xy - wz;
    out[5] = 1 - (xx + zz);
    out[6] = yz + wx;
    out[7] = 0;
    out[8] = xz + wy;
    out[9] = yz - wx;
    out[10] = 1 - (xx + yy);
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;

    return out;
};

/**
 * Returns the translation vector component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslation,
 *  the returned vector will be the same as the translation vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive translation component
 * @param  {mat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */
mat4.getTranslation = function (out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];

  return out;
};

/**
 * Returns a quaternion representing the rotational component
 *  of a transformation matrix. If a matrix is built with
 *  fromRotationTranslation, the returned quaternion will be the
 *  same as the quaternion originally supplied.
 * @param {quat} out Quaternion to receive the rotation component
 * @param {mat4} mat Matrix to be decomposed (input)
 * @return {quat} out
 */
mat4.getRotation = function (out, mat) {
  // Algorithm taken from http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
  var trace = mat[0] + mat[5] + mat[10];
  var S = 0;

  if (trace > 0) { 
    S = Math.sqrt(trace + 1.0) * 2;
    out[3] = 0.25 * S;
    out[0] = (mat[6] - mat[9]) / S;
    out[1] = (mat[8] - mat[2]) / S; 
    out[2] = (mat[1] - mat[4]) / S; 
  } else if ((mat[0] > mat[5])&(mat[0] > mat[10])) { 
    S = Math.sqrt(1.0 + mat[0] - mat[5] - mat[10]) * 2;
    out[3] = (mat[6] - mat[9]) / S;
    out[0] = 0.25 * S;
    out[1] = (mat[1] + mat[4]) / S; 
    out[2] = (mat[8] + mat[2]) / S; 
  } else if (mat[5] > mat[10]) { 
    S = Math.sqrt(1.0 + mat[5] - mat[0] - mat[10]) * 2;
    out[3] = (mat[8] - mat[2]) / S;
    out[0] = (mat[1] + mat[4]) / S; 
    out[1] = 0.25 * S;
    out[2] = (mat[6] + mat[9]) / S; 
  } else { 
    S = Math.sqrt(1.0 + mat[10] - mat[0] - mat[5]) * 2;
    out[3] = (mat[1] - mat[4]) / S;
    out[0] = (mat[8] + mat[2]) / S;
    out[1] = (mat[6] + mat[9]) / S;
    out[2] = 0.25 * S;
  }

  return out;
};

/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     var quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @returns {mat4} out
 */
mat4.fromRotationTranslationScale = function (out, q, v, s) {
    // Quaternion math
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        xy = x * y2,
        xz = x * z2,
        yy = y * y2,
        yz = y * z2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2,
        sx = s[0],
        sy = s[1],
        sz = s[2];

    out[0] = (1 - (yy + zz)) * sx;
    out[1] = (xy + wz) * sx;
    out[2] = (xz - wy) * sx;
    out[3] = 0;
    out[4] = (xy - wz) * sy;
    out[5] = (1 - (xx + zz)) * sy;
    out[6] = (yz + wx) * sy;
    out[7] = 0;
    out[8] = (xz + wy) * sz;
    out[9] = (yz - wx) * sz;
    out[10] = (1 - (xx + yy)) * sz;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;

    return out;
};

/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     mat4.translate(dest, origin);
 *     var quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *     mat4.translate(dest, negativeOrigin);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @param {vec3} o The origin vector around which to scale and rotate
 * @returns {mat4} out
 */
mat4.fromRotationTranslationScaleOrigin = function (out, q, v, s, o) {
  // Quaternion math
  var x = q[0], y = q[1], z = q[2], w = q[3],
      x2 = x + x,
      y2 = y + y,
      z2 = z + z,

      xx = x * x2,
      xy = x * y2,
      xz = x * z2,
      yy = y * y2,
      yz = y * z2,
      zz = z * z2,
      wx = w * x2,
      wy = w * y2,
      wz = w * z2,

      sx = s[0],
      sy = s[1],
      sz = s[2],

      ox = o[0],
      oy = o[1],
      oz = o[2];

  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0] + ox - (out[0] * ox + out[4] * oy + out[8] * oz);
  out[13] = v[1] + oy - (out[1] * ox + out[5] * oy + out[9] * oz);
  out[14] = v[2] + oz - (out[2] * ox + out[6] * oy + out[10] * oz);
  out[15] = 1;

  return out;
};

/**
 * Calculates a 4x4 matrix from the given quaternion
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat} q Quaternion to create matrix from
 *
 * @returns {mat4} out
 */
mat4.fromQuat = function (out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        yx = y * x2,
        yy = y * y2,
        zx = z * x2,
        zy = z * y2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - yy - zz;
    out[1] = yx + wz;
    out[2] = zx - wy;
    out[3] = 0;

    out[4] = yx - wz;
    out[5] = 1 - xx - zz;
    out[6] = zy + wx;
    out[7] = 0;

    out[8] = zx + wy;
    out[9] = zy - wx;
    out[10] = 1 - xx - yy;
    out[11] = 0;

    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;

    return out;
};

/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.frustum = function (out, left, right, bottom, top, near, far) {
    var rl = 1 / (right - left),
        tb = 1 / (top - bottom),
        nf = 1 / (near - far);
    out[0] = (near * 2) * rl;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = (near * 2) * tb;
    out[6] = 0;
    out[7] = 0;
    out[8] = (right + left) * rl;
    out[9] = (top + bottom) * tb;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (far * near * 2) * nf;
    out[15] = 0;
    return out;
};

/**
 * Generates a perspective projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.perspective = function (out, fovy, aspect, near, far) {
    var f = 1.0 / Math.tan(fovy / 2),
        nf = 1 / (near - far);
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (2 * far * near) * nf;
    out[15] = 0;
    return out;
};

/**
 * Generates a perspective projection matrix with the given field of view.
 * This is primarily useful for generating projection matrices to be used
 * with the still experiemental WebVR API.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.perspectiveFromFieldOfView = function (out, fov, near, far) {
    var upTan = Math.tan(fov.upDegrees * Math.PI/180.0),
        downTan = Math.tan(fov.downDegrees * Math.PI/180.0),
        leftTan = Math.tan(fov.leftDegrees * Math.PI/180.0),
        rightTan = Math.tan(fov.rightDegrees * Math.PI/180.0),
        xScale = 2.0 / (leftTan + rightTan),
        yScale = 2.0 / (upTan + downTan);

    out[0] = xScale;
    out[1] = 0.0;
    out[2] = 0.0;
    out[3] = 0.0;
    out[4] = 0.0;
    out[5] = yScale;
    out[6] = 0.0;
    out[7] = 0.0;
    out[8] = -((leftTan - rightTan) * xScale * 0.5);
    out[9] = ((upTan - downTan) * yScale * 0.5);
    out[10] = far / (near - far);
    out[11] = -1.0;
    out[12] = 0.0;
    out[13] = 0.0;
    out[14] = (far * near) / (near - far);
    out[15] = 0.0;
    return out;
}

/**
 * Generates a orthogonal projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.ortho = function (out, left, right, bottom, top, near, far) {
    var lr = 1 / (left - right),
        bt = 1 / (bottom - top),
        nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
};

/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */
mat4.lookAt = function (out, eye, center, up) {
    var x0, x1, x2, y0, y1, y2, z0, z1, z2, len,
        eyex = eye[0],
        eyey = eye[1],
        eyez = eye[2],
        upx = up[0],
        upy = up[1],
        upz = up[2],
        centerx = center[0],
        centery = center[1],
        centerz = center[2];

    if (Math.abs(eyex - centerx) < glMatrix.EPSILON &&
        Math.abs(eyey - centery) < glMatrix.EPSILON &&
        Math.abs(eyez - centerz) < glMatrix.EPSILON) {
        return mat4.identity(out);
    }

    z0 = eyex - centerx;
    z1 = eyey - centery;
    z2 = eyez - centerz;

    len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
    z0 *= len;
    z1 *= len;
    z2 *= len;

    x0 = upy * z2 - upz * z1;
    x1 = upz * z0 - upx * z2;
    x2 = upx * z1 - upy * z0;
    len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
    if (!len) {
        x0 = 0;
        x1 = 0;
        x2 = 0;
    } else {
        len = 1 / len;
        x0 *= len;
        x1 *= len;
        x2 *= len;
    }

    y0 = z1 * x2 - z2 * x1;
    y1 = z2 * x0 - z0 * x2;
    y2 = z0 * x1 - z1 * x0;

    len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
    if (!len) {
        y0 = 0;
        y1 = 0;
        y2 = 0;
    } else {
        len = 1 / len;
        y0 *= len;
        y1 *= len;
        y2 *= len;
    }

    out[0] = x0;
    out[1] = y0;
    out[2] = z0;
    out[3] = 0;
    out[4] = x1;
    out[5] = y1;
    out[6] = z1;
    out[7] = 0;
    out[8] = x2;
    out[9] = y2;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;

    return out;
};

/**
 * Returns a string representation of a mat4
 *
 * @param {mat4} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat4.str = function (a) {
    return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' +
                    a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' +
                    a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' +
                    a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';
};

/**
 * Returns Frobenius norm of a mat4
 *
 * @param {mat4} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat4.frob = function (a) {
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2) + Math.pow(a[9], 2) + Math.pow(a[10], 2) + Math.pow(a[11], 2) + Math.pow(a[12], 2) + Math.pow(a[13], 2) + Math.pow(a[14], 2) + Math.pow(a[15], 2) ))
};

/**
 * Adds two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
mat4.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    out[6] = a[6] + b[6];
    out[7] = a[7] + b[7];
    out[8] = a[8] + b[8];
    out[9] = a[9] + b[9];
    out[10] = a[10] + b[10];
    out[11] = a[11] + b[11];
    out[12] = a[12] + b[12];
    out[13] = a[13] + b[13];
    out[14] = a[14] + b[14];
    out[15] = a[15] + b[15];
    return out;
};

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
mat4.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    out[4] = a[4] - b[4];
    out[5] = a[5] - b[5];
    out[6] = a[6] - b[6];
    out[7] = a[7] - b[7];
    out[8] = a[8] - b[8];
    out[9] = a[9] - b[9];
    out[10] = a[10] - b[10];
    out[11] = a[11] - b[11];
    out[12] = a[12] - b[12];
    out[13] = a[13] - b[13];
    out[14] = a[14] - b[14];
    out[15] = a[15] - b[15];
    return out;
};

/**
 * Alias for {@link mat4.subtract}
 * @function
 */
mat4.sub = mat4.subtract;

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat4} out
 */
mat4.multiplyScalar = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    out[6] = a[6] * b;
    out[7] = a[7] * b;
    out[8] = a[8] * b;
    out[9] = a[9] * b;
    out[10] = a[10] * b;
    out[11] = a[11] * b;
    out[12] = a[12] * b;
    out[13] = a[13] * b;
    out[14] = a[14] * b;
    out[15] = a[15] * b;
    return out;
};

/**
 * Adds two mat4's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat4} out the receiving vector
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat4} out
 */
mat4.multiplyScalarAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    out[3] = a[3] + (b[3] * scale);
    out[4] = a[4] + (b[4] * scale);
    out[5] = a[5] + (b[5] * scale);
    out[6] = a[6] + (b[6] * scale);
    out[7] = a[7] + (b[7] * scale);
    out[8] = a[8] + (b[8] * scale);
    out[9] = a[9] + (b[9] * scale);
    out[10] = a[10] + (b[10] * scale);
    out[11] = a[11] + (b[11] * scale);
    out[12] = a[12] + (b[12] * scale);
    out[13] = a[13] + (b[13] * scale);
    out[14] = a[14] + (b[14] * scale);
    out[15] = a[15] + (b[15] * scale);
    return out;
};

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat4} a The first matrix.
 * @param {mat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat4.exactEquals = function (a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && 
           a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && 
           a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] &&
           a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
};

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat4} a The first matrix.
 * @param {mat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat4.equals = function (a, b) {
    var a0  = a[0],  a1  = a[1],  a2  = a[2],  a3  = a[3],
        a4  = a[4],  a5  = a[5],  a6  = a[6],  a7  = a[7], 
        a8  = a[8],  a9  = a[9],  a10 = a[10], a11 = a[11], 
        a12 = a[12], a13 = a[13], a14 = a[14], a15 = a[15];

    var b0  = b[0],  b1  = b[1],  b2  = b[2],  b3  = b[3],
        b4  = b[4],  b5  = b[5],  b6  = b[6],  b7  = b[7], 
        b8  = b[8],  b9  = b[9],  b10 = b[10], b11 = b[11], 
        b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];

    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
            Math.abs(a3 - b3) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a3), Math.abs(b3)) &&
            Math.abs(a4 - b4) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a4), Math.abs(b4)) &&
            Math.abs(a5 - b5) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a5), Math.abs(b5)) &&
            Math.abs(a6 - b6) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a6), Math.abs(b6)) &&
            Math.abs(a7 - b7) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a7), Math.abs(b7)) &&
            Math.abs(a8 - b8) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a8), Math.abs(b8)) &&
            Math.abs(a9 - b9) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a9), Math.abs(b9)) &&
            Math.abs(a10 - b10) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a10), Math.abs(b10)) &&
            Math.abs(a11 - b11) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a11), Math.abs(b11)) &&
            Math.abs(a12 - b12) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a12), Math.abs(b12)) &&
            Math.abs(a13 - b13) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a13), Math.abs(b13)) &&
            Math.abs(a14 - b14) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a14), Math.abs(b14)) &&
            Math.abs(a15 - b15) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a15), Math.abs(b15)));
};



module.exports = mat4;


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = __webpack_require__(0);
var mat3 = __webpack_require__(4);
var vec3 = __webpack_require__(5);
var vec4 = __webpack_require__(6);

/**
 * @class Quaternion
 * @name quat
 */
var quat = {};

/**
 * Creates a new identity quat
 *
 * @returns {quat} a new quaternion
 */
quat.create = function() {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Sets a quaternion to represent the shortest rotation from one
 * vector to another.
 *
 * Both vectors are assumed to be unit length.
 *
 * @param {quat} out the receiving quaternion.
 * @param {vec3} a the initial vector
 * @param {vec3} b the destination vector
 * @returns {quat} out
 */
quat.rotationTo = (function() {
    var tmpvec3 = vec3.create();
    var xUnitVec3 = vec3.fromValues(1,0,0);
    var yUnitVec3 = vec3.fromValues(0,1,0);

    return function(out, a, b) {
        var dot = vec3.dot(a, b);
        if (dot < -0.999999) {
            vec3.cross(tmpvec3, xUnitVec3, a);
            if (vec3.length(tmpvec3) < 0.000001)
                vec3.cross(tmpvec3, yUnitVec3, a);
            vec3.normalize(tmpvec3, tmpvec3);
            quat.setAxisAngle(out, tmpvec3, Math.PI);
            return out;
        } else if (dot > 0.999999) {
            out[0] = 0;
            out[1] = 0;
            out[2] = 0;
            out[3] = 1;
            return out;
        } else {
            vec3.cross(tmpvec3, a, b);
            out[0] = tmpvec3[0];
            out[1] = tmpvec3[1];
            out[2] = tmpvec3[2];
            out[3] = 1 + dot;
            return quat.normalize(out, out);
        }
    };
})();

/**
 * Sets the specified quaternion with values corresponding to the given
 * axes. Each axis is a vec3 and is expected to be unit length and
 * perpendicular to all other specified axes.
 *
 * @param {vec3} view  the vector representing the viewing direction
 * @param {vec3} right the vector representing the local "right" direction
 * @param {vec3} up    the vector representing the local "up" direction
 * @returns {quat} out
 */
quat.setAxes = (function() {
    var matr = mat3.create();

    return function(out, view, right, up) {
        matr[0] = right[0];
        matr[3] = right[1];
        matr[6] = right[2];

        matr[1] = up[0];
        matr[4] = up[1];
        matr[7] = up[2];

        matr[2] = -view[0];
        matr[5] = -view[1];
        matr[8] = -view[2];

        return quat.normalize(out, quat.fromMat3(out, matr));
    };
})();

/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {quat} a quaternion to clone
 * @returns {quat} a new quaternion
 * @function
 */
quat.clone = vec4.clone;

/**
 * Creates a new quat initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} a new quaternion
 * @function
 */
quat.fromValues = vec4.fromValues;

/**
 * Copy the values from one quat to another
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the source quaternion
 * @returns {quat} out
 * @function
 */
quat.copy = vec4.copy;

/**
 * Set the components of a quat to the given values
 *
 * @param {quat} out the receiving quaternion
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} out
 * @function
 */
quat.set = vec4.set;

/**
 * Set a quat to the identity quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */
quat.identity = function(out) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out the receiving quaternion
 * @param {vec3} axis the axis around which to rotate
 * @param {Number} rad the angle in radians
 * @returns {quat} out
 **/
quat.setAxisAngle = function(out, axis, rad) {
    rad = rad * 0.5;
    var s = Math.sin(rad);
    out[0] = s * axis[0];
    out[1] = s * axis[1];
    out[2] = s * axis[2];
    out[3] = Math.cos(rad);
    return out;
};

/**
 * Gets the rotation axis and angle for a given
 *  quaternion. If a quaternion is created with
 *  setAxisAngle, this method will return the same
 *  values as providied in the original parameter list
 *  OR functionally equivalent values.
 * Example: The quaternion formed by axis [0, 0, 1] and
 *  angle -90 is the same as the quaternion formed by
 *  [0, 0, 1] and 270. This method favors the latter.
 * @param  {vec3} out_axis  Vector receiving the axis of rotation
 * @param  {quat} q     Quaternion to be decomposed
 * @return {Number}     Angle, in radians, of the rotation
 */
quat.getAxisAngle = function(out_axis, q) {
    var rad = Math.acos(q[3]) * 2.0;
    var s = Math.sin(rad / 2.0);
    if (s != 0.0) {
        out_axis[0] = q[0] / s;
        out_axis[1] = q[1] / s;
        out_axis[2] = q[2] / s;
    } else {
        // If s is zero, return any axis (no rotation - axis does not matter)
        out_axis[0] = 1;
        out_axis[1] = 0;
        out_axis[2] = 0;
    }
    return rad;
};

/**
 * Adds two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 * @function
 */
quat.add = vec4.add;

/**
 * Multiplies two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 */
quat.multiply = function(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = b[0], by = b[1], bz = b[2], bw = b[3];

    out[0] = ax * bw + aw * bx + ay * bz - az * by;
    out[1] = ay * bw + aw * by + az * bx - ax * bz;
    out[2] = az * bw + aw * bz + ax * by - ay * bx;
    out[3] = aw * bw - ax * bx - ay * by - az * bz;
    return out;
};

/**
 * Alias for {@link quat.multiply}
 * @function
 */
quat.mul = quat.multiply;

/**
 * Scales a quat by a scalar number
 *
 * @param {quat} out the receiving vector
 * @param {quat} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {quat} out
 * @function
 */
quat.scale = vec4.scale;

/**
 * Rotates a quaternion by the given angle about the X axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateX = function (out, a, rad) {
    rad *= 0.5; 

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw + aw * bx;
    out[1] = ay * bw + az * bx;
    out[2] = az * bw - ay * bx;
    out[3] = aw * bw - ax * bx;
    return out;
};

/**
 * Rotates a quaternion by the given angle about the Y axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateY = function (out, a, rad) {
    rad *= 0.5; 

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        by = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw - az * by;
    out[1] = ay * bw + aw * by;
    out[2] = az * bw + ax * by;
    out[3] = aw * bw - ay * by;
    return out;
};

/**
 * Rotates a quaternion by the given angle about the Z axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateZ = function (out, a, rad) {
    rad *= 0.5; 

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bz = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw + ay * bz;
    out[1] = ay * bw - ax * bz;
    out[2] = az * bw + aw * bz;
    out[3] = aw * bw - az * bz;
    return out;
};

/**
 * Calculates the W component of a quat from the X, Y, and Z components.
 * Assumes that quaternion is 1 unit in length.
 * Any existing W component will be ignored.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate W component of
 * @returns {quat} out
 */
quat.calculateW = function (out, a) {
    var x = a[0], y = a[1], z = a[2];

    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
    return out;
};

/**
 * Calculates the dot product of two quat's
 *
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */
quat.dot = vec4.dot;

/**
 * Performs a linear interpolation between two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {quat} out
 * @function
 */
quat.lerp = vec4.lerp;

/**
 * Performs a spherical linear interpolation between two quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {quat} out
 */
quat.slerp = function (out, a, b, t) {
    // benchmarks:
    //    http://jsperf.com/quaternion-slerp-implementations

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = b[0], by = b[1], bz = b[2], bw = b[3];

    var        omega, cosom, sinom, scale0, scale1;

    // calc cosine
    cosom = ax * bx + ay * by + az * bz + aw * bw;
    // adjust signs (if necessary)
    if ( cosom < 0.0 ) {
        cosom = -cosom;
        bx = - bx;
        by = - by;
        bz = - bz;
        bw = - bw;
    }
    // calculate coefficients
    if ( (1.0 - cosom) > 0.000001 ) {
        // standard case (slerp)
        omega  = Math.acos(cosom);
        sinom  = Math.sin(omega);
        scale0 = Math.sin((1.0 - t) * omega) / sinom;
        scale1 = Math.sin(t * omega) / sinom;
    } else {        
        // "from" and "to" quaternions are very close 
        //  ... so we can do a linear interpolation
        scale0 = 1.0 - t;
        scale1 = t;
    }
    // calculate final values
    out[0] = scale0 * ax + scale1 * bx;
    out[1] = scale0 * ay + scale1 * by;
    out[2] = scale0 * az + scale1 * bz;
    out[3] = scale0 * aw + scale1 * bw;
    
    return out;
};

/**
 * Performs a spherical linear interpolation with two control points
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {quat} c the third operand
 * @param {quat} d the fourth operand
 * @param {Number} t interpolation amount
 * @returns {quat} out
 */
quat.sqlerp = (function () {
  var temp1 = quat.create();
  var temp2 = quat.create();
  
  return function (out, a, b, c, d, t) {
    quat.slerp(temp1, a, d, t);
    quat.slerp(temp2, b, c, t);
    quat.slerp(out, temp1, temp2, 2 * t * (1 - t));
    
    return out;
  };
}());

/**
 * Calculates the inverse of a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate inverse of
 * @returns {quat} out
 */
quat.invert = function(out, a) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
        dot = a0*a0 + a1*a1 + a2*a2 + a3*a3,
        invDot = dot ? 1.0/dot : 0;
    
    // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

    out[0] = -a0*invDot;
    out[1] = -a1*invDot;
    out[2] = -a2*invDot;
    out[3] = a3*invDot;
    return out;
};

/**
 * Calculates the conjugate of a quat
 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate conjugate of
 * @returns {quat} out
 */
quat.conjugate = function (out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = a[3];
    return out;
};

/**
 * Calculates the length of a quat
 *
 * @param {quat} a vector to calculate length of
 * @returns {Number} length of a
 * @function
 */
quat.length = vec4.length;

/**
 * Alias for {@link quat.length}
 * @function
 */
quat.len = quat.length;

/**
 * Calculates the squared length of a quat
 *
 * @param {quat} a vector to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */
quat.squaredLength = vec4.squaredLength;

/**
 * Alias for {@link quat.squaredLength}
 * @function
 */
quat.sqrLen = quat.squaredLength;

/**
 * Normalize a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quaternion to normalize
 * @returns {quat} out
 * @function
 */
quat.normalize = vec4.normalize;

/**
 * Creates a quaternion from the given 3x3 rotation matrix.
 *
 * NOTE: The resultant quaternion is not normalized, so you should be sure
 * to renormalize the quaternion yourself where necessary.
 *
 * @param {quat} out the receiving quaternion
 * @param {mat3} m rotation matrix
 * @returns {quat} out
 * @function
 */
quat.fromMat3 = function(out, m) {
    // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
    // article "Quaternion Calculus and Fast Animation".
    var fTrace = m[0] + m[4] + m[8];
    var fRoot;

    if ( fTrace > 0.0 ) {
        // |w| > 1/2, may as well choose w > 1/2
        fRoot = Math.sqrt(fTrace + 1.0);  // 2w
        out[3] = 0.5 * fRoot;
        fRoot = 0.5/fRoot;  // 1/(4w)
        out[0] = (m[5]-m[7])*fRoot;
        out[1] = (m[6]-m[2])*fRoot;
        out[2] = (m[1]-m[3])*fRoot;
    } else {
        // |w| <= 1/2
        var i = 0;
        if ( m[4] > m[0] )
          i = 1;
        if ( m[8] > m[i*3+i] )
          i = 2;
        var j = (i+1)%3;
        var k = (i+2)%3;
        
        fRoot = Math.sqrt(m[i*3+i]-m[j*3+j]-m[k*3+k] + 1.0);
        out[i] = 0.5 * fRoot;
        fRoot = 0.5 / fRoot;
        out[3] = (m[j*3+k] - m[k*3+j]) * fRoot;
        out[j] = (m[j*3+i] + m[i*3+j]) * fRoot;
        out[k] = (m[k*3+i] + m[i*3+k]) * fRoot;
    }
    
    return out;
};

/**
 * Returns a string representation of a quatenion
 *
 * @param {quat} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
quat.str = function (a) {
    return 'quat(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

/**
 * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)
 *
 * @param {quat} a The first quaternion.
 * @param {quat} b The second quaternion.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
quat.exactEquals = vec4.exactEquals;

/**
 * Returns whether or not the quaternions have approximately the same elements in the same position.
 *
 * @param {quat} a The first vector.
 * @param {quat} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
quat.equals = vec4.equals;

module.exports = quat;


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = __webpack_require__(0);

/**
 * @class 2 Dimensional Vector
 * @name vec2
 */
var vec2 = {};

/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */
vec2.create = function() {
    var out = new glMatrix.ARRAY_TYPE(2);
    out[0] = 0;
    out[1] = 0;
    return out;
};

/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {vec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */
vec2.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(2);
    out[0] = a[0];
    out[1] = a[1];
    return out;
};

/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */
vec2.fromValues = function(x, y) {
    var out = new glMatrix.ARRAY_TYPE(2);
    out[0] = x;
    out[1] = y;
    return out;
};

/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the source vector
 * @returns {vec2} out
 */
vec2.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    return out;
};

/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */
vec2.set = function(out, x, y) {
    out[0] = x;
    out[1] = y;
    return out;
};

/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    return out;
};

/**
 * Alias for {@link vec2.subtract}
 * @function
 */
vec2.sub = vec2.subtract;

/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    return out;
};

/**
 * Alias for {@link vec2.multiply}
 * @function
 */
vec2.mul = vec2.multiply;

/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    return out;
};

/**
 * Alias for {@link vec2.divide}
 * @function
 */
vec2.div = vec2.divide;

/**
 * Math.ceil the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to ceil
 * @returns {vec2} out
 */
vec2.ceil = function (out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    return out;
};

/**
 * Math.floor the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to floor
 * @returns {vec2} out
 */
vec2.floor = function (out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    return out;
};

/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    return out;
};

/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    return out;
};

/**
 * Math.round the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to round
 * @returns {vec2} out
 */
vec2.round = function (out, a) {
    out[0] = Math.round(a[0]);
    out[1] = Math.round(a[1]);
    return out;
};

/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */
vec2.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    return out;
};

/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */
vec2.scaleAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    return out;
};

/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} distance between a and b
 */
vec2.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return Math.sqrt(x*x + y*y);
};

/**
 * Alias for {@link vec2.distance}
 * @function
 */
vec2.dist = vec2.distance;

/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec2.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return x*x + y*y;
};

/**
 * Alias for {@link vec2.squaredDistance}
 * @function
 */
vec2.sqrDist = vec2.squaredDistance;

/**
 * Calculates the length of a vec2
 *
 * @param {vec2} a vector to calculate length of
 * @returns {Number} length of a
 */
vec2.length = function (a) {
    var x = a[0],
        y = a[1];
    return Math.sqrt(x*x + y*y);
};

/**
 * Alias for {@link vec2.length}
 * @function
 */
vec2.len = vec2.length;

/**
 * Calculates the squared length of a vec2
 *
 * @param {vec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec2.squaredLength = function (a) {
    var x = a[0],
        y = a[1];
    return x*x + y*y;
};

/**
 * Alias for {@link vec2.squaredLength}
 * @function
 */
vec2.sqrLen = vec2.squaredLength;

/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to negate
 * @returns {vec2} out
 */
vec2.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    return out;
};

/**
 * Returns the inverse of the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to invert
 * @returns {vec2} out
 */
vec2.inverse = function(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  return out;
};

/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to normalize
 * @returns {vec2} out
 */
vec2.normalize = function(out, a) {
    var x = a[0],
        y = a[1];
    var len = x*x + y*y;
    if (len > 0) {
        //TODO: evaluate use of glm_invsqrt here?
        len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} dot product of a and b
 */
vec2.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1];
};

/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec3} out
 */
vec2.cross = function(out, a, b) {
    var z = a[0] * b[1] - a[1] * b[0];
    out[0] = out[1] = 0;
    out[2] = z;
    return out;
};

/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec2} out
 */
vec2.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */
vec2.random = function (out, scale) {
    scale = scale || 1.0;
    var r = glMatrix.RANDOM() * 2.0 * Math.PI;
    out[0] = Math.cos(r) * scale;
    out[1] = Math.sin(r) * scale;
    return out;
};

/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat2 = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[2] * y;
    out[1] = m[1] * x + m[3] * y;
    return out;
};

/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2d} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat2d = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[2] * y + m[4];
    out[1] = m[1] * x + m[3] * y + m[5];
    return out;
};

/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat3} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat3 = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[3] * y + m[6];
    out[1] = m[1] * x + m[4] * y + m[7];
    return out;
};

/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat4 = function(out, a, m) {
    var x = a[0], 
        y = a[1];
    out[0] = m[0] * x + m[4] * y + m[12];
    out[1] = m[1] * x + m[5] * y + m[13];
    return out;
};

/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
vec2.forEach = (function() {
    var vec = vec2.create();

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 2;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1];
        }
        
        return a;
    };
})();

/**
 * Returns a string representation of a vector
 *
 * @param {vec2} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec2.str = function (a) {
    return 'vec2(' + a[0] + ', ' + a[1] + ')';
};

/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
vec2.exactEquals = function (a, b) {
    return a[0] === b[0] && a[1] === b[1];
};

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
vec2.equals = function (a, b) {
    var a0 = a[0], a1 = a[1];
    var b0 = b[0], b1 = b[1];
    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)));
};

module.exports = vec2;


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 *
 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 *
 * All rights reserved.
 *
 * Distributed under the 3-clause BSD License, see LICENSE.txt
 */



/*
 * Function added in the JavaScript version (was not present in the c++ version)
 */

/**
 * assert and throw an exception.
 *
 * @private
 * @param {boolean} condition   the condition which is asserted
 * @param {string} message      the message which is display is condition is falsy
 */
function assert(condition, message) {
    if (!condition) {
        throw new Error(message || "Assert Failed");
    }
}
module.exports = assert;




/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 * 
 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 * 
 * All rights reserved.
 * 
 * Distributed under the 3-clause BSD License, see LICENSE.txt
 */




/*
 * Note
 * ====
 * the structure of this JavaScript version of poly2tri intentionally follows
 * as closely as possible the structure of the reference C++ version, to make it 
 * easier to keep the 2 versions in sync.
 */

var xy = __webpack_require__(1);

// ------------------------------------------------------------------------Point
/**
 * Construct a point
 * @example
 *      var point = new poly2tri.Point(150, 150);
 * @public
 * @constructor
 * @struct
 * @param {number=} x    coordinate (0 if undefined)
 * @param {number=} y    coordinate (0 if undefined)
 */
var Point = function(x, y) {
    /**
     * @type {number}
     * @expose
     */
    this.x = +x || 0;
    /**
     * @type {number}
     * @expose
     */
    this.y = +y || 0;

    // All extra fields added to Point are prefixed with _p2t_
    // to avoid collisions if custom Point class is used.

    /**
     * The edges this point constitutes an upper ending point
     * @private
     * @type {Array.<Edge>}
     */
    this._p2t_edge_list = null;
};

/**
 * For pretty printing
 * @example
 *      "p=" + new poly2tri.Point(5,42)
 *      // → "p=(5;42)"
 * @returns {string} <code>"(x;y)"</code>
 */
Point.prototype.toString = function() {
    return xy.toStringBase(this);
};

/**
 * JSON output, only coordinates
 * @example
 *      JSON.stringify(new poly2tri.Point(1,2))
 *      // → '{"x":1,"y":2}'
 */
Point.prototype.toJSON = function() {
    return { x: this.x, y: this.y };
};

/**
 * Creates a copy of this Point object.
 * @return {Point} new cloned point
 */
Point.prototype.clone = function() {
    return new Point(this.x, this.y);
};

/**
 * Set this Point instance to the origo. <code>(0; 0)</code>
 * @return {Point} this (for chaining)
 */
Point.prototype.set_zero = function() {
    this.x = 0.0;
    this.y = 0.0;
    return this; // for chaining
};

/**
 * Set the coordinates of this instance.
 * @param {number} x   coordinate
 * @param {number} y   coordinate
 * @return {Point} this (for chaining)
 */
Point.prototype.set = function(x, y) {
    this.x = +x || 0;
    this.y = +y || 0;
    return this; // for chaining
};

/**
 * Negate this Point instance. (component-wise)
 * @return {Point} this (for chaining)
 */
Point.prototype.negate = function() {
    this.x = -this.x;
    this.y = -this.y;
    return this; // for chaining
};

/**
 * Add another Point object to this instance. (component-wise)
 * @param {!Point} n - Point object.
 * @return {Point} this (for chaining)
 */
Point.prototype.add = function(n) {
    this.x += n.x;
    this.y += n.y;
    return this; // for chaining
};

/**
 * Subtract this Point instance with another point given. (component-wise)
 * @param {!Point} n - Point object.
 * @return {Point} this (for chaining)
 */
Point.prototype.sub = function(n) {
    this.x -= n.x;
    this.y -= n.y;
    return this; // for chaining
};

/**
 * Multiply this Point instance by a scalar. (component-wise)
 * @param {number} s   scalar.
 * @return {Point} this (for chaining)
 */
Point.prototype.mul = function(s) {
    this.x *= s;
    this.y *= s;
    return this; // for chaining
};

/**
 * Return the distance of this Point instance from the origo.
 * @return {number} distance
 */
Point.prototype.length = function() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
};

/**
 * Normalize this Point instance (as a vector).
 * @return {number} The original distance of this instance from the origo.
 */
Point.prototype.normalize = function() {
    var len = this.length();
    this.x /= len;
    this.y /= len;
    return len;
};

/**
 * Test this Point object with another for equality.
 * @param {!XY} p - any "Point like" object with {x,y}
 * @return {boolean} <code>true</code> if same x and y coordinates, <code>false</code> otherwise.
 */
Point.prototype.equals = function(p) {
    return this.x === p.x && this.y === p.y;
};


// -----------------------------------------------------Point ("static" methods)

/**
 * Negate a point component-wise and return the result as a new Point object.
 * @param {!XY} p - any "Point like" object with {x,y}
 * @return {Point} the resulting Point object.
 */
Point.negate = function(p) {
    return new Point(-p.x, -p.y);
};

/**
 * Add two points component-wise and return the result as a new Point object.
 * @param {!XY} a - any "Point like" object with {x,y}
 * @param {!XY} b - any "Point like" object with {x,y}
 * @return {Point} the resulting Point object.
 */
Point.add = function(a, b) {
    return new Point(a.x + b.x, a.y + b.y);
};

/**
 * Subtract two points component-wise and return the result as a new Point object.
 * @param {!XY} a - any "Point like" object with {x,y}
 * @param {!XY} b - any "Point like" object with {x,y}
 * @return {Point} the resulting Point object.
 */
Point.sub = function(a, b) {
    return new Point(a.x - b.x, a.y - b.y);
};

/**
 * Multiply a point by a scalar and return the result as a new Point object.
 * @param {number} s - the scalar
 * @param {!XY} p - any "Point like" object with {x,y}
 * @return {Point} the resulting Point object.
 */
Point.mul = function(s, p) {
    return new Point(s * p.x, s * p.y);
};

/**
 * Perform the cross product on either two points (this produces a scalar)
 * or a point and a scalar (this produces a point).
 * This function requires two parameters, either may be a Point object or a
 * number.
 * @param  {XY|number} a - Point object or scalar.
 * @param  {XY|number} b - Point object or scalar.
 * @return {Point|number} a Point object or a number, depending on the parameters.
 */
Point.cross = function(a, b) {
    if (typeof(a) === 'number') {
        if (typeof(b) === 'number') {
            return a * b;
        } else {
            return new Point(-a * b.y, a * b.x);
        }
    } else {
        if (typeof(b) === 'number') {
            return new Point(b * a.y, -b * a.x);
        } else {
            return a.x * b.y - a.y * b.x;
        }
    }
};


// -----------------------------------------------------------------"Point-Like"
/*
 * The following functions operate on "Point" or any "Point like" object 
 * with {x,y} (duck typing).
 */

Point.toString = xy.toString;
Point.compare = xy.compare;
Point.cmp = xy.compare; // backward compatibility
Point.equals = xy.equals;

/**
 * Peform the dot product on two vectors.
 * @public
 * @param {!XY} a - any "Point like" object with {x,y}
 * @param {!XY} b - any "Point like" object with {x,y}
 * @return {number} The dot product
 */
Point.dot = function(a, b) {
    return a.x * b.x + a.y * b.y;
};


// ---------------------------------------------------------Exports (public API)

module.exports = Point;


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 * 
 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 * 
 * All rights reserved.
 * 
 * Distributed under the 3-clause BSD License, see LICENSE.txt
 */

/* jshint latedef:nofunc, maxcomplexity:9 */



/**
 * This 'Sweep' module is present in order to keep this JavaScript version
 * as close as possible to the reference C++ version, even though almost all
 * functions could be declared as methods on the {@linkcode module:sweepcontext~SweepContext} object.
 * @module
 * @private
 */

/*
 * Note
 * ====
 * the structure of this JavaScript version of poly2tri intentionally follows
 * as closely as possible the structure of the reference C++ version, to make it 
 * easier to keep the 2 versions in sync.
 */

var assert = __webpack_require__(20);
var PointError = __webpack_require__(9);
var Triangle = __webpack_require__(10);
var Node = __webpack_require__(8).Node;


// ------------------------------------------------------------------------utils

var utils = __webpack_require__(24);

/** @const */
var EPSILON = utils.EPSILON;

/** @const */
var Orientation = utils.Orientation;
/** @const */
var orient2d = utils.orient2d;
/** @const */
var inScanArea = utils.inScanArea;
/** @const */
var isAngleObtuse = utils.isAngleObtuse;


// ------------------------------------------------------------------------Sweep

/**
 * Triangulate the polygon with holes and Steiner points.
 * Do this AFTER you've added the polyline, holes, and Steiner points
 * @private
 * @param {!SweepContext} tcx - SweepContext object
 */
function triangulate(tcx) {
    tcx.initTriangulation();
    tcx.createAdvancingFront();
    // Sweep points; build mesh
    sweepPoints(tcx);
    // Clean up
    finalizationPolygon(tcx);
}

/**
 * Start sweeping the Y-sorted point set from bottom to top
 * @param {!SweepContext} tcx - SweepContext object
 */
function sweepPoints(tcx) {
    var i, len = tcx.pointCount();
    for (i = 1; i < len; ++i) {
        var point = tcx.getPoint(i);
        var node = pointEvent(tcx, point);
        var edges = point._p2t_edge_list;
        for (var j = 0; edges && j < edges.length; ++j) {
            edgeEventByEdge(tcx, edges[j], node);
        }
    }
}

/**
 * @param {!SweepContext} tcx - SweepContext object
 */
function finalizationPolygon(tcx) {
    // Get an Internal triangle to start with
    var t = tcx.front().head().next.triangle;
    var p = tcx.front().head().next.point;
    while (!t.getConstrainedEdgeCW(p)) {
        t = t.neighborCCW(p);
    }

    // Collect interior triangles constrained by edges
    tcx.meshClean(t);
}

/**
 * Find closes node to the left of the new point and
 * create a new triangle. If needed new holes and basins
 * will be filled to.
 * @param {!SweepContext} tcx - SweepContext object
 * @param {!XY} point   Point
 */
function pointEvent(tcx, point) {
    var node = tcx.locateNode(point);
    var new_node = newFrontTriangle(tcx, point, node);

    // Only need to check +epsilon since point never have smaller
    // x value than node due to how we fetch nodes from the front
    if (point.x <= node.point.x + (EPSILON)) {
        fill(tcx, node);
    }

    //tcx.AddNode(new_node);

    fillAdvancingFront(tcx, new_node);
    return new_node;
}

function edgeEventByEdge(tcx, edge, node) {
    tcx.edge_event.constrained_edge = edge;
    tcx.edge_event.right = (edge.p.x > edge.q.x);

    if (isEdgeSideOfTriangle(node.triangle, edge.p, edge.q)) {
        return;
    }

    // For now we will do all needed filling
    // TODO: integrate with flip process might give some better performance
    //       but for now this avoid the issue with cases that needs both flips and fills
    fillEdgeEvent(tcx, edge, node);
    edgeEventByPoints(tcx, edge.p, edge.q, node.triangle, edge.q);
}

function edgeEventByPoints(tcx, ep, eq, triangle, point) {
    if (isEdgeSideOfTriangle(triangle, ep, eq)) {
        return;
    }

    var p1 = triangle.pointCCW(point);
    var o1 = orient2d(eq, p1, ep);
    if (o1 === Orientation.COLLINEAR) {
        // TODO integrate here changes from C++ version
        // (C++ repo revision 09880a869095 dated March 8, 2011)
        throw new PointError('poly2tri EdgeEvent: Collinear not supported!', [eq, p1, ep]);
    }

    var p2 = triangle.pointCW(point);
    var o2 = orient2d(eq, p2, ep);
    if (o2 === Orientation.COLLINEAR) {
        // TODO integrate here changes from C++ version
        // (C++ repo revision 09880a869095 dated March 8, 2011)
        throw new PointError('poly2tri EdgeEvent: Collinear not supported!', [eq, p2, ep]);
    }

    if (o1 === o2) {
        // Need to decide if we are rotating CW or CCW to get to a triangle
        // that will cross edge
        if (o1 === Orientation.CW) {
            triangle = triangle.neighborCCW(point);
        } else {
            triangle = triangle.neighborCW(point);
        }
        edgeEventByPoints(tcx, ep, eq, triangle, point);
    } else {
        // This triangle crosses constraint so lets flippin start!
        flipEdgeEvent(tcx, ep, eq, triangle, point);
    }
}

function isEdgeSideOfTriangle(triangle, ep, eq) {
    var index = triangle.edgeIndex(ep, eq);
    if (index !== -1) {
        triangle.markConstrainedEdgeByIndex(index);
        var t = triangle.getNeighbor(index);
        if (t) {
            t.markConstrainedEdgeByPoints(ep, eq);
        }
        return true;
    }
    return false;
}

/**
 * Creates a new front triangle and legalize it
 * @param {!SweepContext} tcx - SweepContext object
 */
function newFrontTriangle(tcx, point, node) {
    var triangle = new Triangle(point, node.point, node.next.point);

    triangle.markNeighbor(node.triangle);
    tcx.addToMap(triangle);

    var new_node = new Node(point);
    new_node.next = node.next;
    new_node.prev = node;
    node.next.prev = new_node;
    node.next = new_node;

    if (!legalize(tcx, triangle)) {
        tcx.mapTriangleToNodes(triangle);
    }

    return new_node;
}

/**
 * Adds a triangle to the advancing front to fill a hole.
 * @param {!SweepContext} tcx - SweepContext object
 * @param node - middle node, that is the bottom of the hole
 */
function fill(tcx, node) {
    var triangle = new Triangle(node.prev.point, node.point, node.next.point);

    // TODO: should copy the constrained_edge value from neighbor triangles
    //       for now constrained_edge values are copied during the legalize
    triangle.markNeighbor(node.prev.triangle);
    triangle.markNeighbor(node.triangle);

    tcx.addToMap(triangle);

    // Update the advancing front
    node.prev.next = node.next;
    node.next.prev = node.prev;


    // If it was legalized the triangle has already been mapped
    if (!legalize(tcx, triangle)) {
        tcx.mapTriangleToNodes(triangle);
    }

    //tcx.removeNode(node);
}

/**
 * Fills holes in the Advancing Front
 * @param {!SweepContext} tcx - SweepContext object
 */
function fillAdvancingFront(tcx, n) {
    // Fill right holes
    var node = n.next;
    while (node.next) {
        // TODO integrate here changes from C++ version
        // (C++ repo revision acf81f1f1764 dated April 7, 2012)
        if (isAngleObtuse(node.point, node.next.point, node.prev.point)) {
            break;
        }
        fill(tcx, node);
        node = node.next;
    }

    // Fill left holes
    node = n.prev;
    while (node.prev) {
        // TODO integrate here changes from C++ version
        // (C++ repo revision acf81f1f1764 dated April 7, 2012)
        if (isAngleObtuse(node.point, node.next.point, node.prev.point)) {
            break;
        }
        fill(tcx, node);
        node = node.prev;
    }

    // Fill right basins
    if (n.next && n.next.next) {
        if (isBasinAngleRight(n)) {
            fillBasin(tcx, n);
        }
    }
}

/**
 * The basin angle is decided against the horizontal line [1,0].
 * @param {Node} node
 * @return {boolean} true if angle < 3*π/4
 */
function isBasinAngleRight(node) {
    var ax = node.point.x - node.next.next.point.x;
    var ay = node.point.y - node.next.next.point.y;
    assert(ay >= 0, "unordered y");
    return (ax >= 0 || Math.abs(ax) < ay);
}

/**
 * Returns true if triangle was legalized
 * @param {!SweepContext} tcx - SweepContext object
 * @return {boolean}
 */
function legalize(tcx, t) {
    // To legalize a triangle we start by finding if any of the three edges
    // violate the Delaunay condition
    for (var i = 0; i < 3; ++i) {
        if (t.delaunay_edge[i]) {
            continue;
        }
        var ot = t.getNeighbor(i);
        if (ot) {
            var p = t.getPoint(i);
            var op = ot.oppositePoint(t, p);
            var oi = ot.index(op);

            // If this is a Constrained Edge or a Delaunay Edge(only during recursive legalization)
            // then we should not try to legalize
            if (ot.constrained_edge[oi] || ot.delaunay_edge[oi]) {
                t.constrained_edge[i] = ot.constrained_edge[oi];
                continue;
            }

            var inside = inCircle(p, t.pointCCW(p), t.pointCW(p), op);
            if (inside) {
                // Lets mark this shared edge as Delaunay
                t.delaunay_edge[i] = true;
                ot.delaunay_edge[oi] = true;

                // Lets rotate shared edge one vertex CW to legalize it
                rotateTrianglePair(t, p, ot, op);

                // We now got one valid Delaunay Edge shared by two triangles
                // This gives us 4 new edges to check for Delaunay

                // Make sure that triangle to node mapping is done only one time for a specific triangle
                var not_legalized = !legalize(tcx, t);
                if (not_legalized) {
                    tcx.mapTriangleToNodes(t);
                }

                not_legalized = !legalize(tcx, ot);
                if (not_legalized) {
                    tcx.mapTriangleToNodes(ot);
                }
                // Reset the Delaunay edges, since they only are valid Delaunay edges
                // until we add a new triangle or point.
                // XXX: need to think about this. Can these edges be tried after we
                //      return to previous recursive level?
                t.delaunay_edge[i] = false;
                ot.delaunay_edge[oi] = false;

                // If triangle have been legalized no need to check the other edges since
                // the recursive legalization will handles those so we can end here.
                return true;
            }
        }
    }
    return false;
}

/**
 * <b>Requirement</b>:<br>
 * 1. a,b and c form a triangle.<br>
 * 2. a and d is know to be on opposite side of bc<br>
 * <pre>
 *                a
 *                +
 *               / \
 *              /   \
 *            b/     \c
 *            +-------+
 *           /    d    \
 *          /           \
 * </pre>
 * <b>Fact</b>: d has to be in area B to have a chance to be inside the circle formed by
 *  a,b and c<br>
 *  d is outside B if orient2d(a,b,d) or orient2d(c,a,d) is CW<br>
 *  This preknowledge gives us a way to optimize the incircle test
 * @param pa - triangle point, opposite d
 * @param pb - triangle point
 * @param pc - triangle point
 * @param pd - point opposite a
 * @return {boolean} true if d is inside circle, false if on circle edge
 */
function inCircle(pa, pb, pc, pd) {
    var adx = pa.x - pd.x;
    var ady = pa.y - pd.y;
    var bdx = pb.x - pd.x;
    var bdy = pb.y - pd.y;

    var adxbdy = adx * bdy;
    var bdxady = bdx * ady;
    var oabd = adxbdy - bdxady;
    if (oabd <= 0) {
        return false;
    }

    var cdx = pc.x - pd.x;
    var cdy = pc.y - pd.y;

    var cdxady = cdx * ady;
    var adxcdy = adx * cdy;
    var ocad = cdxady - adxcdy;
    if (ocad <= 0) {
        return false;
    }

    var bdxcdy = bdx * cdy;
    var cdxbdy = cdx * bdy;

    var alift = adx * adx + ady * ady;
    var blift = bdx * bdx + bdy * bdy;
    var clift = cdx * cdx + cdy * cdy;

    var det = alift * (bdxcdy - cdxbdy) + blift * ocad + clift * oabd;
    return det > 0;
}

/**
 * Rotates a triangle pair one vertex CW
 *<pre>
 *       n2                    n2
 *  P +-----+             P +-----+
 *    | t  /|               |\  t |
 *    |   / |               | \   |
 *  n1|  /  |n3           n1|  \  |n3
 *    | /   |    after CW   |   \ |
 *    |/ oT |               | oT \|
 *    +-----+ oP            +-----+
 *       n4                    n4
 * </pre>
 */
function rotateTrianglePair(t, p, ot, op) {
    var n1, n2, n3, n4;
    n1 = t.neighborCCW(p);
    n2 = t.neighborCW(p);
    n3 = ot.neighborCCW(op);
    n4 = ot.neighborCW(op);

    var ce1, ce2, ce3, ce4;
    ce1 = t.getConstrainedEdgeCCW(p);
    ce2 = t.getConstrainedEdgeCW(p);
    ce3 = ot.getConstrainedEdgeCCW(op);
    ce4 = ot.getConstrainedEdgeCW(op);

    var de1, de2, de3, de4;
    de1 = t.getDelaunayEdgeCCW(p);
    de2 = t.getDelaunayEdgeCW(p);
    de3 = ot.getDelaunayEdgeCCW(op);
    de4 = ot.getDelaunayEdgeCW(op);

    t.legalize(p, op);
    ot.legalize(op, p);

    // Remap delaunay_edge
    ot.setDelaunayEdgeCCW(p, de1);
    t.setDelaunayEdgeCW(p, de2);
    t.setDelaunayEdgeCCW(op, de3);
    ot.setDelaunayEdgeCW(op, de4);

    // Remap constrained_edge
    ot.setConstrainedEdgeCCW(p, ce1);
    t.setConstrainedEdgeCW(p, ce2);
    t.setConstrainedEdgeCCW(op, ce3);
    ot.setConstrainedEdgeCW(op, ce4);

    // Remap neighbors
    // XXX: might optimize the markNeighbor by keeping track of
    //      what side should be assigned to what neighbor after the
    //      rotation. Now mark neighbor does lots of testing to find
    //      the right side.
    t.clearNeighbors();
    ot.clearNeighbors();
    if (n1) {
        ot.markNeighbor(n1);
    }
    if (n2) {
        t.markNeighbor(n2);
    }
    if (n3) {
        t.markNeighbor(n3);
    }
    if (n4) {
        ot.markNeighbor(n4);
    }
    t.markNeighbor(ot);
}

/**
 * Fills a basin that has formed on the Advancing Front to the right
 * of given node.<br>
 * First we decide a left,bottom and right node that forms the
 * boundaries of the basin. Then we do a reqursive fill.
 *
 * @param {!SweepContext} tcx - SweepContext object
 * @param node - starting node, this or next node will be left node
 */
function fillBasin(tcx, node) {
    if (orient2d(node.point, node.next.point, node.next.next.point) === Orientation.CCW) {
        tcx.basin.left_node = node.next.next;
    } else {
        tcx.basin.left_node = node.next;
    }

    // Find the bottom and right node
    tcx.basin.bottom_node = tcx.basin.left_node;
    while (tcx.basin.bottom_node.next && tcx.basin.bottom_node.point.y >= tcx.basin.bottom_node.next.point.y) {
        tcx.basin.bottom_node = tcx.basin.bottom_node.next;
    }
    if (tcx.basin.bottom_node === tcx.basin.left_node) {
        // No valid basin
        return;
    }

    tcx.basin.right_node = tcx.basin.bottom_node;
    while (tcx.basin.right_node.next && tcx.basin.right_node.point.y < tcx.basin.right_node.next.point.y) {
        tcx.basin.right_node = tcx.basin.right_node.next;
    }
    if (tcx.basin.right_node === tcx.basin.bottom_node) {
        // No valid basins
        return;
    }

    tcx.basin.width = tcx.basin.right_node.point.x - tcx.basin.left_node.point.x;
    tcx.basin.left_highest = tcx.basin.left_node.point.y > tcx.basin.right_node.point.y;

    fillBasinReq(tcx, tcx.basin.bottom_node);
}

/**
 * Recursive algorithm to fill a Basin with triangles
 *
 * @param {!SweepContext} tcx - SweepContext object
 * @param node - bottom_node
 */
function fillBasinReq(tcx, node) {
    // if shallow stop filling
    if (isShallow(tcx, node)) {
        return;
    }

    fill(tcx, node);

    var o;
    if (node.prev === tcx.basin.left_node && node.next === tcx.basin.right_node) {
        return;
    } else if (node.prev === tcx.basin.left_node) {
        o = orient2d(node.point, node.next.point, node.next.next.point);
        if (o === Orientation.CW) {
            return;
        }
        node = node.next;
    } else if (node.next === tcx.basin.right_node) {
        o = orient2d(node.point, node.prev.point, node.prev.prev.point);
        if (o === Orientation.CCW) {
            return;
        }
        node = node.prev;
    } else {
        // Continue with the neighbor node with lowest Y value
        if (node.prev.point.y < node.next.point.y) {
            node = node.prev;
        } else {
            node = node.next;
        }
    }

    fillBasinReq(tcx, node);
}

function isShallow(tcx, node) {
    var height;
    if (tcx.basin.left_highest) {
        height = tcx.basin.left_node.point.y - node.point.y;
    } else {
        height = tcx.basin.right_node.point.y - node.point.y;
    }

    // if shallow stop filling
    if (tcx.basin.width > height) {
        return true;
    }
    return false;
}

function fillEdgeEvent(tcx, edge, node) {
    if (tcx.edge_event.right) {
        fillRightAboveEdgeEvent(tcx, edge, node);
    } else {
        fillLeftAboveEdgeEvent(tcx, edge, node);
    }
}

function fillRightAboveEdgeEvent(tcx, edge, node) {
    while (node.next.point.x < edge.p.x) {
        // Check if next node is below the edge
        if (orient2d(edge.q, node.next.point, edge.p) === Orientation.CCW) {
            fillRightBelowEdgeEvent(tcx, edge, node);
        } else {
            node = node.next;
        }
    }
}

function fillRightBelowEdgeEvent(tcx, edge, node) {
    if (node.point.x < edge.p.x) {
        if (orient2d(node.point, node.next.point, node.next.next.point) === Orientation.CCW) {
            // Concave
            fillRightConcaveEdgeEvent(tcx, edge, node);
        } else {
            // Convex
            fillRightConvexEdgeEvent(tcx, edge, node);
            // Retry this one
            fillRightBelowEdgeEvent(tcx, edge, node);
        }
    }
}

function fillRightConcaveEdgeEvent(tcx, edge, node) {
    fill(tcx, node.next);
    if (node.next.point !== edge.p) {
        // Next above or below edge?
        if (orient2d(edge.q, node.next.point, edge.p) === Orientation.CCW) {
            // Below
            if (orient2d(node.point, node.next.point, node.next.next.point) === Orientation.CCW) {
                // Next is concave
                fillRightConcaveEdgeEvent(tcx, edge, node);
            } else {
                // Next is convex
                /* jshint noempty:false */
            }
        }
    }
}

function fillRightConvexEdgeEvent(tcx, edge, node) {
    // Next concave or convex?
    if (orient2d(node.next.point, node.next.next.point, node.next.next.next.point) === Orientation.CCW) {
        // Concave
        fillRightConcaveEdgeEvent(tcx, edge, node.next);
    } else {
        // Convex
        // Next above or below edge?
        if (orient2d(edge.q, node.next.next.point, edge.p) === Orientation.CCW) {
            // Below
            fillRightConvexEdgeEvent(tcx, edge, node.next);
        } else {
            // Above
            /* jshint noempty:false */
        }
    }
}

function fillLeftAboveEdgeEvent(tcx, edge, node) {
    while (node.prev.point.x > edge.p.x) {
        // Check if next node is below the edge
        if (orient2d(edge.q, node.prev.point, edge.p) === Orientation.CW) {
            fillLeftBelowEdgeEvent(tcx, edge, node);
        } else {
            node = node.prev;
        }
    }
}

function fillLeftBelowEdgeEvent(tcx, edge, node) {
    if (node.point.x > edge.p.x) {
        if (orient2d(node.point, node.prev.point, node.prev.prev.point) === Orientation.CW) {
            // Concave
            fillLeftConcaveEdgeEvent(tcx, edge, node);
        } else {
            // Convex
            fillLeftConvexEdgeEvent(tcx, edge, node);
            // Retry this one
            fillLeftBelowEdgeEvent(tcx, edge, node);
        }
    }
}

function fillLeftConvexEdgeEvent(tcx, edge, node) {
    // Next concave or convex?
    if (orient2d(node.prev.point, node.prev.prev.point, node.prev.prev.prev.point) === Orientation.CW) {
        // Concave
        fillLeftConcaveEdgeEvent(tcx, edge, node.prev);
    } else {
        // Convex
        // Next above or below edge?
        if (orient2d(edge.q, node.prev.prev.point, edge.p) === Orientation.CW) {
            // Below
            fillLeftConvexEdgeEvent(tcx, edge, node.prev);
        } else {
            // Above
            /* jshint noempty:false */
        }
    }
}

function fillLeftConcaveEdgeEvent(tcx, edge, node) {
    fill(tcx, node.prev);
    if (node.prev.point !== edge.p) {
        // Next above or below edge?
        if (orient2d(edge.q, node.prev.point, edge.p) === Orientation.CW) {
            // Below
            if (orient2d(node.point, node.prev.point, node.prev.prev.point) === Orientation.CW) {
                // Next is concave
                fillLeftConcaveEdgeEvent(tcx, edge, node);
            } else {
                // Next is convex
                /* jshint noempty:false */
            }
        }
    }
}

function flipEdgeEvent(tcx, ep, eq, t, p) {
    var ot = t.neighborAcross(p);
    assert(ot, "FLIP failed due to missing triangle!");

    var op = ot.oppositePoint(t, p);

    // Additional check from Java version (see issue #88)
    if (t.getConstrainedEdgeAcross(p)) {
        var index = t.index(p);
        throw new PointError("poly2tri Intersecting Constraints",
                [p, op, t.getPoint((index + 1) % 3), t.getPoint((index + 2) % 3)]);
    }

    if (inScanArea(p, t.pointCCW(p), t.pointCW(p), op)) {
        // Lets rotate shared edge one vertex CW
        rotateTrianglePair(t, p, ot, op);
        tcx.mapTriangleToNodes(t);
        tcx.mapTriangleToNodes(ot);

        // XXX: in the original C++ code for the next 2 lines, we are
        // comparing point values (and not pointers). In this JavaScript
        // code, we are comparing point references (pointers). This works
        // because we can't have 2 different points with the same values.
        // But to be really equivalent, we should use "Point.equals" here.
        if (p === eq && op === ep) {
            if (eq === tcx.edge_event.constrained_edge.q && ep === tcx.edge_event.constrained_edge.p) {
                t.markConstrainedEdgeByPoints(ep, eq);
                ot.markConstrainedEdgeByPoints(ep, eq);
                legalize(tcx, t);
                legalize(tcx, ot);
            } else {
                // XXX: I think one of the triangles should be legalized here?
                /* jshint noempty:false */
            }
        } else {
            var o = orient2d(eq, op, ep);
            t = nextFlipTriangle(tcx, o, t, ot, p, op);
            flipEdgeEvent(tcx, ep, eq, t, p);
        }
    } else {
        var newP = nextFlipPoint(ep, eq, ot, op);
        flipScanEdgeEvent(tcx, ep, eq, t, ot, newP);
        edgeEventByPoints(tcx, ep, eq, t, p);
    }
}

/**
 * After a flip we have two triangles and know that only one will still be
 * intersecting the edge. So decide which to contiune with and legalize the other
 *
 * @param {!SweepContext} tcx - SweepContext object
 * @param o - should be the result of an orient2d( eq, op, ep )
 * @param t - triangle 1
 * @param ot - triangle 2
 * @param p - a point shared by both triangles
 * @param op - another point shared by both triangles
 * @return returns the triangle still intersecting the edge
 */
function nextFlipTriangle(tcx, o, t, ot, p, op) {
    var edge_index;
    if (o === Orientation.CCW) {
        // ot is not crossing edge after flip
        edge_index = ot.edgeIndex(p, op);
        ot.delaunay_edge[edge_index] = true;
        legalize(tcx, ot);
        ot.clearDelaunayEdges();
        return t;
    }

    // t is not crossing edge after flip
    edge_index = t.edgeIndex(p, op);

    t.delaunay_edge[edge_index] = true;
    legalize(tcx, t);
    t.clearDelaunayEdges();
    return ot;
}

/**
 * When we need to traverse from one triangle to the next we need
 * the point in current triangle that is the opposite point to the next
 * triangle.
 */
function nextFlipPoint(ep, eq, ot, op) {
    var o2d = orient2d(eq, op, ep);
    if (o2d === Orientation.CW) {
        // Right
        return ot.pointCCW(op);
    } else if (o2d === Orientation.CCW) {
        // Left
        return ot.pointCW(op);
    } else {
        throw new PointError("poly2tri [Unsupported] nextFlipPoint: opposing point on constrained edge!", [eq, op, ep]);
    }
}

/**
 * Scan part of the FlipScan algorithm<br>
 * When a triangle pair isn't flippable we will scan for the next
 * point that is inside the flip triangle scan area. When found
 * we generate a new flipEdgeEvent
 *
 * @param {!SweepContext} tcx - SweepContext object
 * @param ep - last point on the edge we are traversing
 * @param eq - first point on the edge we are traversing
 * @param {!Triangle} flip_triangle - the current triangle sharing the point eq with edge
 * @param t
 * @param p
 */
function flipScanEdgeEvent(tcx, ep, eq, flip_triangle, t, p) {
    var ot = t.neighborAcross(p);
    assert(ot, "FLIP failed due to missing triangle");

    var op = ot.oppositePoint(t, p);

    if (inScanArea(eq, flip_triangle.pointCCW(eq), flip_triangle.pointCW(eq), op)) {
        // flip with new edge op.eq
        flipEdgeEvent(tcx, eq, op, ot, op);
    } else {
        var newP = nextFlipPoint(ep, eq, ot, op);
        flipScanEdgeEvent(tcx, ep, eq, flip_triangle, ot, newP);
    }
}


// ----------------------------------------------------------------------Exports

exports.triangulate = triangulate;


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 * 
 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 * 
 * All rights reserved.
 * 
 * Distributed under the 3-clause BSD License, see LICENSE.txt
 */

/* jshint maxcomplexity:6 */




/*
 * Note
 * ====
 * the structure of this JavaScript version of poly2tri intentionally follows
 * as closely as possible the structure of the reference C++ version, to make it 
 * easier to keep the 2 versions in sync.
 */

var PointError = __webpack_require__(9);
var Point = __webpack_require__(21);
var Triangle = __webpack_require__(10);
var sweep = __webpack_require__(22);
var AdvancingFront = __webpack_require__(8);
var Node = AdvancingFront.Node;


// ------------------------------------------------------------------------utils

/**
 * Initial triangle factor, seed triangle will extend 30% of
 * PointSet width to both left and right.
 * @private
 * @const
 */
var kAlpha = 0.3;


// -------------------------------------------------------------------------Edge
/**
 * Represents a simple polygon's edge
 * @constructor
 * @struct
 * @private
 * @param {Point} p1
 * @param {Point} p2
 * @throw {PointError} if p1 is same as p2
 */
var Edge = function(p1, p2) {
    this.p = p1;
    this.q = p2;

    if (p1.y > p2.y) {
        this.q = p1;
        this.p = p2;
    } else if (p1.y === p2.y) {
        if (p1.x > p2.x) {
            this.q = p1;
            this.p = p2;
        } else if (p1.x === p2.x) {
            throw new PointError('poly2tri Invalid Edge constructor: repeated points!', [p1]);
        }
    }

    if (!this.q._p2t_edge_list) {
        this.q._p2t_edge_list = [];
    }
    this.q._p2t_edge_list.push(this);
};


// ------------------------------------------------------------------------Basin
/**
 * @constructor
 * @struct
 * @private
 */
var Basin = function() {
    /** @type {Node} */
    this.left_node = null;
    /** @type {Node} */
    this.bottom_node = null;
    /** @type {Node} */
    this.right_node = null;
    /** @type {number} */
    this.width = 0.0;
    /** @type {boolean} */
    this.left_highest = false;
};

Basin.prototype.clear = function() {
    this.left_node = null;
    this.bottom_node = null;
    this.right_node = null;
    this.width = 0.0;
    this.left_highest = false;
};

// --------------------------------------------------------------------EdgeEvent
/**
 * @constructor
 * @struct
 * @private
 */
var EdgeEvent = function() {
    /** @type {Edge} */
    this.constrained_edge = null;
    /** @type {boolean} */
    this.right = false;
};

// ----------------------------------------------------SweepContext (public API)
/**
 * SweepContext constructor option
 * @typedef {Object} SweepContextOptions
 * @property {boolean=} cloneArrays - if <code>true</code>, do a shallow copy of the Array parameters
 *                  (contour, holes). Points inside arrays are never copied.
 *                  Default is <code>false</code> : keep a reference to the array arguments,
 *                  who will be modified in place.
 */
/**
 * Constructor for the triangulation context.
 * It accepts a simple polyline (with non repeating points), 
 * which defines the constrained edges.
 *
 * @example
 *          var contour = [
 *              new poly2tri.Point(100, 100),
 *              new poly2tri.Point(100, 300),
 *              new poly2tri.Point(300, 300),
 *              new poly2tri.Point(300, 100)
 *          ];
 *          var swctx = new poly2tri.SweepContext(contour, {cloneArrays: true});
 * @example
 *          var contour = [{x:100, y:100}, {x:100, y:300}, {x:300, y:300}, {x:300, y:100}];
 *          var swctx = new poly2tri.SweepContext(contour, {cloneArrays: true});
 * @constructor
 * @public
 * @struct
 * @param {Array.<XY>} contour - array of point objects. The points can be either {@linkcode Point} instances,
 *          or any "Point like" custom class with <code>{x, y}</code> attributes.
 * @param {SweepContextOptions=} options - constructor options
 */
var SweepContext = function(contour, options) {
    options = options || {};
    this.triangles_ = [];
    this.map_ = [];
    this.points_ = (options.cloneArrays ? contour.slice(0) : contour);
    this.edge_list = [];

    // Bounding box of all points. Computed at the start of the triangulation, 
    // it is stored in case it is needed by the caller.
    this.pmin_ = this.pmax_ = null;

    /**
     * Advancing front
     * @private
     * @type {AdvancingFront}
     */
    this.front_ = null;

    /**
     * head point used with advancing front
     * @private
     * @type {Point}
     */
    this.head_ = null;

    /**
     * tail point used with advancing front
     * @private
     * @type {Point}
     */
    this.tail_ = null;

    /**
     * @private
     * @type {Node}
     */
    this.af_head_ = null;
    /**
     * @private
     * @type {Node}
     */
    this.af_middle_ = null;
    /**
     * @private
     * @type {Node}
     */
    this.af_tail_ = null;

    this.basin = new Basin();
    this.edge_event = new EdgeEvent();

    this.initEdges(this.points_);
};


/**
 * Add a hole to the constraints
 * @example
 *      var swctx = new poly2tri.SweepContext(contour);
 *      var hole = [
 *          new poly2tri.Point(200, 200),
 *          new poly2tri.Point(200, 250),
 *          new poly2tri.Point(250, 250)
 *      ];
 *      swctx.addHole(hole);
 * @example
 *      var swctx = new poly2tri.SweepContext(contour);
 *      swctx.addHole([{x:200, y:200}, {x:200, y:250}, {x:250, y:250}]);
 * @public
 * @param {Array.<XY>} polyline - array of "Point like" objects with {x,y}
 */
SweepContext.prototype.addHole = function(polyline) {
    this.initEdges(polyline);
    var i, len = polyline.length;
    for (i = 0; i < len; i++) {
        this.points_.push(polyline[i]);
    }
    return this; // for chaining
};

/**
 * For backward compatibility
 * @function
 * @deprecated use {@linkcode SweepContext#addHole} instead
 */
SweepContext.prototype.AddHole = SweepContext.prototype.addHole;


/**
 * Add several holes to the constraints
 * @example
 *      var swctx = new poly2tri.SweepContext(contour);
 *      var holes = [
 *          [ new poly2tri.Point(200, 200), new poly2tri.Point(200, 250), new poly2tri.Point(250, 250) ],
 *          [ new poly2tri.Point(300, 300), new poly2tri.Point(300, 350), new poly2tri.Point(350, 350) ]
 *      ];
 *      swctx.addHoles(holes);
 * @example
 *      var swctx = new poly2tri.SweepContext(contour);
 *      var holes = [
 *          [{x:200, y:200}, {x:200, y:250}, {x:250, y:250}],
 *          [{x:300, y:300}, {x:300, y:350}, {x:350, y:350}]
 *      ];
 *      swctx.addHoles(holes);
 * @public
 * @param {Array.<Array.<XY>>} holes - array of array of "Point like" objects with {x,y}
 */
// Method added in the JavaScript version (was not present in the c++ version)
SweepContext.prototype.addHoles = function(holes) {
    var i, len = holes.length;
    for (i = 0; i < len; i++) {
        this.initEdges(holes[i]);
    }
    this.points_ = this.points_.concat.apply(this.points_, holes);
    return this; // for chaining
};


/**
 * Add a Steiner point to the constraints
 * @example
 *      var swctx = new poly2tri.SweepContext(contour);
 *      var point = new poly2tri.Point(150, 150);
 *      swctx.addPoint(point);
 * @example
 *      var swctx = new poly2tri.SweepContext(contour);
 *      swctx.addPoint({x:150, y:150});
 * @public
 * @param {XY} point - any "Point like" object with {x,y}
 */
SweepContext.prototype.addPoint = function(point) {
    this.points_.push(point);
    return this; // for chaining
};

/**
 * For backward compatibility
 * @function
 * @deprecated use {@linkcode SweepContext#addPoint} instead
 */
SweepContext.prototype.AddPoint = SweepContext.prototype.addPoint;


/**
 * Add several Steiner points to the constraints
 * @example
 *      var swctx = new poly2tri.SweepContext(contour);
 *      var points = [
 *          new poly2tri.Point(150, 150),
 *          new poly2tri.Point(200, 250),
 *          new poly2tri.Point(250, 250)
 *      ];
 *      swctx.addPoints(points);
 * @example
 *      var swctx = new poly2tri.SweepContext(contour);
 *      swctx.addPoints([{x:150, y:150}, {x:200, y:250}, {x:250, y:250}]);
 * @public
 * @param {Array.<XY>} points - array of "Point like" object with {x,y}
 */
// Method added in the JavaScript version (was not present in the c++ version)
SweepContext.prototype.addPoints = function(points) {
    this.points_ = this.points_.concat(points);
    return this; // for chaining
};


/**
 * Triangulate the polygon with holes and Steiner points.
 * Do this AFTER you've added the polyline, holes, and Steiner points
 * @example
 *      var swctx = new poly2tri.SweepContext(contour);
 *      swctx.triangulate();
 *      var triangles = swctx.getTriangles();
 * @public
 */
// Shortcut method for sweep.triangulate(SweepContext).
// Method added in the JavaScript version (was not present in the c++ version)
SweepContext.prototype.triangulate = function() {
    sweep.triangulate(this);
    return this; // for chaining
};


/**
 * Get the bounding box of the provided constraints (contour, holes and 
 * Steinter points). Warning : these values are not available if the triangulation 
 * has not been done yet.
 * @public
 * @returns {{min:Point,max:Point}} object with 'min' and 'max' Point
 */
// Method added in the JavaScript version (was not present in the c++ version)
SweepContext.prototype.getBoundingBox = function() {
    return {min: this.pmin_, max: this.pmax_};
};

/**
 * Get result of triangulation.
 * The output triangles have vertices which are references
 * to the initial input points (not copies): any custom fields in the
 * initial points can be retrieved in the output triangles.
 * @example
 *      var swctx = new poly2tri.SweepContext(contour);
 *      swctx.triangulate();
 *      var triangles = swctx.getTriangles();
 * @example
 *      var contour = [{x:100, y:100, id:1}, {x:100, y:300, id:2}, {x:300, y:300, id:3}];
 *      var swctx = new poly2tri.SweepContext(contour);
 *      swctx.triangulate();
 *      var triangles = swctx.getTriangles();
 *      typeof triangles[0].getPoint(0).id
 *      // → "number"
 * @public
 * @returns {array<Triangle>}   array of triangles
 */
SweepContext.prototype.getTriangles = function() {
    return this.triangles_;
};

/**
 * For backward compatibility
 * @function
 * @deprecated use {@linkcode SweepContext#getTriangles} instead
 */
SweepContext.prototype.GetTriangles = SweepContext.prototype.getTriangles;


// ---------------------------------------------------SweepContext (private API)

/** @private */
SweepContext.prototype.front = function() {
    return this.front_;
};

/** @private */
SweepContext.prototype.pointCount = function() {
    return this.points_.length;
};

/** @private */
SweepContext.prototype.head = function() {
    return this.head_;
};

/** @private */
SweepContext.prototype.setHead = function(p1) {
    this.head_ = p1;
};

/** @private */
SweepContext.prototype.tail = function() {
    return this.tail_;
};

/** @private */
SweepContext.prototype.setTail = function(p1) {
    this.tail_ = p1;
};

/** @private */
SweepContext.prototype.getMap = function() {
    return this.map_;
};

/** @private */
SweepContext.prototype.initTriangulation = function() {
    var xmax = this.points_[0].x;
    var xmin = this.points_[0].x;
    var ymax = this.points_[0].y;
    var ymin = this.points_[0].y;

    // Calculate bounds
    var i, len = this.points_.length;
    for (i = 1; i < len; i++) {
        var p = this.points_[i];
        /* jshint expr:true */
        (p.x > xmax) && (xmax = p.x);
        (p.x < xmin) && (xmin = p.x);
        (p.y > ymax) && (ymax = p.y);
        (p.y < ymin) && (ymin = p.y);
    }
    this.pmin_ = new Point(xmin, ymin);
    this.pmax_ = new Point(xmax, ymax);

    var dx = kAlpha * (xmax - xmin);
    var dy = kAlpha * (ymax - ymin);
    this.head_ = new Point(xmax + dx, ymin - dy);
    this.tail_ = new Point(xmin - dx, ymin - dy);

    // Sort points along y-axis
    this.points_.sort(Point.compare);
};

/** @private */
SweepContext.prototype.initEdges = function(polyline) {
    var i, len = polyline.length;
    for (i = 0; i < len; ++i) {
        this.edge_list.push(new Edge(polyline[i], polyline[(i + 1) % len]));
    }
};

/** @private */
SweepContext.prototype.getPoint = function(index) {
    return this.points_[index];
};

/** @private */
SweepContext.prototype.addToMap = function(triangle) {
    this.map_.push(triangle);
};

/** @private */
SweepContext.prototype.locateNode = function(point) {
    return this.front_.locateNode(point.x);
};

/** @private */
SweepContext.prototype.createAdvancingFront = function() {
    var head;
    var middle;
    var tail;
    // Initial triangle
    var triangle = new Triangle(this.points_[0], this.tail_, this.head_);

    this.map_.push(triangle);

    head = new Node(triangle.getPoint(1), triangle);
    middle = new Node(triangle.getPoint(0), triangle);
    tail = new Node(triangle.getPoint(2));

    this.front_ = new AdvancingFront(head, tail);

    head.next = middle;
    middle.next = tail;
    middle.prev = head;
    tail.prev = middle;
};

/** @private */
SweepContext.prototype.removeNode = function(node) {
    // do nothing
    /* jshint unused:false */
};

/** @private */
SweepContext.prototype.mapTriangleToNodes = function(t) {
    for (var i = 0; i < 3; ++i) {
        if (!t.getNeighbor(i)) {
            var n = this.front_.locatePoint(t.pointCW(t.getPoint(i)));
            if (n) {
                n.triangle = t;
            }
        }
    }
};

/** @private */
SweepContext.prototype.removeFromMap = function(triangle) {
    var i, map = this.map_, len = map.length;
    for (i = 0; i < len; i++) {
        if (map[i] === triangle) {
            map.splice(i, 1);
            break;
        }
    }
};

/**
 * Do a depth first traversal to collect triangles
 * @private
 * @param {Triangle} triangle start
 */
SweepContext.prototype.meshClean = function(triangle) {
    // New implementation avoids recursive calls and use a loop instead.
    // Cf. issues # 57, 65 and 69.
    var triangles = [triangle], t, i;
    /* jshint boss:true */
    while (t = triangles.pop()) {
        if (!t.isInterior()) {
            t.setInterior(true);
            this.triangles_.push(t);
            for (i = 0; i < 3; i++) {
                if (!t.constrained_edge[i]) {
                    triangles.push(t.getNeighbor(i));
                }
            }
        }
    }
};

// ----------------------------------------------------------------------Exports

module.exports = SweepContext;


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 * 
 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 * 
 * All rights reserved.
 * 
 * Distributed under the 3-clause BSD License, see LICENSE.txt
 */



/**
 * Precision to detect repeated or collinear points
 * @private
 * @const {number}
 * @default
 */
var EPSILON = 1e-12;
exports.EPSILON = EPSILON;

/**
 * @private
 * @enum {number}
 * @readonly
 */
var Orientation = {
    "CW": 1,
    "CCW": -1,
    "COLLINEAR": 0
};
exports.Orientation = Orientation;


/**
 * Formula to calculate signed area<br>
 * Positive if CCW<br>
 * Negative if CW<br>
 * 0 if collinear<br>
 * <pre>
 * A[P1,P2,P3]  =  (x1*y2 - y1*x2) + (x2*y3 - y2*x3) + (x3*y1 - y3*x1)
 *              =  (x1-x3)*(y2-y3) - (y1-y3)*(x2-x3)
 * </pre>
 *
 * @private
 * @param {!XY} pa  point object with {x,y}
 * @param {!XY} pb  point object with {x,y}
 * @param {!XY} pc  point object with {x,y}
 * @return {Orientation}
 */
function orient2d(pa, pb, pc) {
    var detleft = (pa.x - pc.x) * (pb.y - pc.y);
    var detright = (pa.y - pc.y) * (pb.x - pc.x);
    var val = detleft - detright;
    if (val > -(EPSILON) && val < (EPSILON)) {
        return Orientation.COLLINEAR;
    } else if (val > 0) {
        return Orientation.CCW;
    } else {
        return Orientation.CW;
    }
}
exports.orient2d = orient2d;


/**
 *
 * @private
 * @param {!XY} pa  point object with {x,y}
 * @param {!XY} pb  point object with {x,y}
 * @param {!XY} pc  point object with {x,y}
 * @param {!XY} pd  point object with {x,y}
 * @return {boolean}
 */
function inScanArea(pa, pb, pc, pd) {
    var oadb = (pa.x - pb.x) * (pd.y - pb.y) - (pd.x - pb.x) * (pa.y - pb.y);
    if (oadb >= -EPSILON) {
        return false;
    }

    var oadc = (pa.x - pc.x) * (pd.y - pc.y) - (pd.x - pc.x) * (pa.y - pc.y);
    if (oadc <= EPSILON) {
        return false;
    }
    return true;
}
exports.inScanArea = inScanArea;


/**
 * Check if the angle between (pa,pb) and (pa,pc) is obtuse i.e. (angle > π/2 || angle < -π/2)
 *
 * @private
 * @param {!XY} pa  point object with {x,y}
 * @param {!XY} pb  point object with {x,y}
 * @param {!XY} pc  point object with {x,y}
 * @return {boolean} true if angle is obtuse
 */
function isAngleObtuse(pa, pb, pc) {
    var ax = pb.x - pa.x;
    var ay = pb.y - pa.y;
    var bx = pc.x - pa.x;
    var by = pc.y - pa.y;
    return (ax * bx + ay * by) < 0;
}
exports.isAngleObtuse = isAngleObtuse;



/***/ }),
/* 25 */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
module.exports = function(src) {
	if (typeof execScript !== "undefined")
		execScript(src);
	else
		eval.call(null, src);
}


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(25)(__webpack_require__(27))

/***/ }),
/* 27 */
/***/ (function(module, exports) {

module.exports = "var Module;if(!Module)Module=(typeof Module!==\"undefined\"?Module:null)||{};var moduleOverrides={};for(var key in Module){if(Module.hasOwnProperty(key)){moduleOverrides[key]=Module[key]}}var ENVIRONMENT_IS_WEB=typeof window===\"object\";var ENVIRONMENT_IS_WORKER=typeof importScripts===\"function\";var ENVIRONMENT_IS_NODE=typeof process===\"object\"&&typeof require===\"function\"&&!ENVIRONMENT_IS_WEB&&!ENVIRONMENT_IS_WORKER;var ENVIRONMENT_IS_SHELL=!ENVIRONMENT_IS_WEB&&!ENVIRONMENT_IS_NODE&&!ENVIRONMENT_IS_WORKER;if(ENVIRONMENT_IS_NODE){if(!Module[\"print\"])Module[\"print\"]=function print(x){process[\"stdout\"].write(x+\"\\n\")};if(!Module[\"printErr\"])Module[\"printErr\"]=function printErr(x){process[\"stderr\"].write(x+\"\\n\")};var nodeFS=require(\"fs\");var nodePath=require(\"path\");Module[\"read\"]=function read(filename,binary){filename=nodePath[\"normalize\"](filename);var ret=nodeFS[\"readFileSync\"](filename);if(!ret&&filename!=nodePath[\"resolve\"](filename)){filename=path.join(__dirname,\"..\",\"src\",filename);ret=nodeFS[\"readFileSync\"](filename)}if(ret&&!binary)ret=ret.toString();return ret};Module[\"readBinary\"]=function readBinary(filename){var ret=Module[\"read\"](filename,true);if(!ret.buffer){ret=new Uint8Array(ret)}assert(ret.buffer);return ret};Module[\"load\"]=function load(f){globalEval(read(f))};if(!Module[\"thisProgram\"]){if(process[\"argv\"].length>1){Module[\"thisProgram\"]=process[\"argv\"][1].replace(/\\\\/g,\"/\")}else{Module[\"thisProgram\"]=\"unknown-program\"}}Module[\"arguments\"]=process[\"argv\"].slice(2);if(typeof module!==\"undefined\"){module[\"exports\"]=Module}process[\"on\"](\"uncaughtException\",(function(ex){if(!(ex instanceof ExitStatus)){throw ex}}));Module[\"inspect\"]=(function(){return\"[Emscripten Module object]\"})}else if(ENVIRONMENT_IS_SHELL){if(!Module[\"print\"])Module[\"print\"]=print;if(typeof printErr!=\"undefined\")Module[\"printErr\"]=printErr;if(typeof read!=\"undefined\"){Module[\"read\"]=read}else{Module[\"read\"]=function read(){throw\"no read() available (jsc?)\"}}Module[\"readBinary\"]=function readBinary(f){if(typeof readbuffer===\"function\"){return new Uint8Array(readbuffer(f))}var data=read(f,\"binary\");assert(typeof data===\"object\");return data};if(typeof scriptArgs!=\"undefined\"){Module[\"arguments\"]=scriptArgs}else if(typeof arguments!=\"undefined\"){Module[\"arguments\"]=arguments}}else if(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER){Module[\"read\"]=function read(url){var xhr=new XMLHttpRequest;xhr.open(\"GET\",url,false);xhr.send(null);return xhr.responseText};if(typeof arguments!=\"undefined\"){Module[\"arguments\"]=arguments}if(typeof console!==\"undefined\"){if(!Module[\"print\"])Module[\"print\"]=function print(x){console.log(x)};if(!Module[\"printErr\"])Module[\"printErr\"]=function printErr(x){console.log(x)}}else{var TRY_USE_DUMP=false;if(!Module[\"print\"])Module[\"print\"]=TRY_USE_DUMP&&typeof dump!==\"undefined\"?(function(x){dump(x)}):(function(x){})}if(ENVIRONMENT_IS_WORKER){Module[\"load\"]=importScripts}if(typeof Module[\"setWindowTitle\"]===\"undefined\"){Module[\"setWindowTitle\"]=(function(title){document.title=title})}}else{throw\"Unknown runtime environment. Where are we?\"}function globalEval(x){eval.call(null,x)}if(!Module[\"load\"]&&Module[\"read\"]){Module[\"load\"]=function load(f){globalEval(Module[\"read\"](f))}}if(!Module[\"print\"]){Module[\"print\"]=(function(){})}if(!Module[\"printErr\"]){Module[\"printErr\"]=Module[\"print\"]}if(!Module[\"arguments\"]){Module[\"arguments\"]=[]}if(!Module[\"thisProgram\"]){Module[\"thisProgram\"]=\"./this.program\"}Module.print=Module[\"print\"];Module.printErr=Module[\"printErr\"];Module[\"preRun\"]=[];Module[\"postRun\"]=[];for(var key in moduleOverrides){if(moduleOverrides.hasOwnProperty(key)){Module[key]=moduleOverrides[key]}}var Runtime={setTempRet0:(function(value){tempRet0=value}),getTempRet0:(function(){return tempRet0}),stackSave:(function(){return STACKTOP}),stackRestore:(function(stackTop){STACKTOP=stackTop}),getNativeTypeSize:(function(type){switch(type){case\"i1\":case\"i8\":return 1;case\"i16\":return 2;case\"i32\":return 4;case\"i64\":return 8;case\"float\":return 4;case\"double\":return 8;default:{if(type[type.length-1]===\"*\"){return Runtime.QUANTUM_SIZE}else if(type[0]===\"i\"){var bits=parseInt(type.substr(1));assert(bits%8===0);return bits/8}else{return 0}}}}),getNativeFieldSize:(function(type){return Math.max(Runtime.getNativeTypeSize(type),Runtime.QUANTUM_SIZE)}),STACK_ALIGN:16,prepVararg:(function(ptr,type){if(type===\"double\"||type===\"i64\"){if(ptr&7){assert((ptr&7)===4);ptr+=4}}else{assert((ptr&3)===0)}return ptr}),getAlignSize:(function(type,size,vararg){if(!vararg&&(type==\"i64\"||type==\"double\"))return 8;if(!type)return Math.min(size,8);return Math.min(size||(type?Runtime.getNativeFieldSize(type):0),Runtime.QUANTUM_SIZE)}),dynCall:(function(sig,ptr,args){if(args&&args.length){if(!args.splice)args=Array.prototype.slice.call(args);args.splice(0,0,ptr);return Module[\"dynCall_\"+sig].apply(null,args)}else{return Module[\"dynCall_\"+sig].call(null,ptr)}}),functionPointers:[],addFunction:(function(func){for(var i=0;i<Runtime.functionPointers.length;i++){if(!Runtime.functionPointers[i]){Runtime.functionPointers[i]=func;return 2*(1+i)}}throw\"Finished up all reserved function pointers. Use a higher value for RESERVED_FUNCTION_POINTERS.\"}),removeFunction:(function(index){Runtime.functionPointers[(index-2)/2]=null}),warnOnce:(function(text){if(!Runtime.warnOnce.shown)Runtime.warnOnce.shown={};if(!Runtime.warnOnce.shown[text]){Runtime.warnOnce.shown[text]=1;Module.printErr(text)}}),funcWrappers:{},getFuncWrapper:(function(func,sig){assert(sig);if(!Runtime.funcWrappers[sig]){Runtime.funcWrappers[sig]={}}var sigCache=Runtime.funcWrappers[sig];if(!sigCache[func]){sigCache[func]=function dynCall_wrapper(){return Runtime.dynCall(sig,func,arguments)}}return sigCache[func]}),getCompilerSetting:(function(name){throw\"You must build with -s RETAIN_COMPILER_SETTINGS=1 for Runtime.getCompilerSetting or emscripten_get_compiler_setting to work\"}),stackAlloc:(function(size){var ret=STACKTOP;STACKTOP=STACKTOP+size|0;STACKTOP=STACKTOP+15&-16;return ret}),staticAlloc:(function(size){var ret=STATICTOP;STATICTOP=STATICTOP+size|0;STATICTOP=STATICTOP+15&-16;return ret}),dynamicAlloc:(function(size){var ret=DYNAMICTOP;DYNAMICTOP=DYNAMICTOP+size|0;DYNAMICTOP=DYNAMICTOP+15&-16;if(DYNAMICTOP>=TOTAL_MEMORY){var success=enlargeMemory();if(!success){DYNAMICTOP=ret;return 0}}return ret}),alignMemory:(function(size,quantum){var ret=size=Math.ceil(size/(quantum?quantum:16))*(quantum?quantum:16);return ret}),makeBigInt:(function(low,high,unsigned){var ret=unsigned?+(low>>>0)+ +(high>>>0)*+4294967296:+(low>>>0)+ +(high|0)*+4294967296;return ret}),GLOBAL_BASE:8,QUANTUM_SIZE:4,__dummy__:0};Module[\"Runtime\"]=Runtime;var __THREW__=0;var ABORT=false;var EXITSTATUS=0;var undef=0;var tempValue,tempInt,tempBigInt,tempInt2,tempBigInt2,tempPair,tempBigIntI,tempBigIntR,tempBigIntS,tempBigIntP,tempBigIntD,tempDouble,tempFloat;var tempI64,tempI64b;var tempRet0,tempRet1,tempRet2,tempRet3,tempRet4,tempRet5,tempRet6,tempRet7,tempRet8,tempRet9;function assert(condition,text){if(!condition){abort(\"Assertion failed: \"+text)}}var globalScope=this;function getCFunc(ident){var func=Module[\"_\"+ident];if(!func){try{func=eval(\"_\"+ident)}catch(e){}}assert(func,\"Cannot call unknown function \"+ident+\" (perhaps LLVM optimizations or closure removed it?)\");return func}var cwrap,ccall;((function(){var JSfuncs={\"stackSave\":(function(){Runtime.stackSave()}),\"stackRestore\":(function(){Runtime.stackRestore()}),\"arrayToC\":(function(arr){var ret=Runtime.stackAlloc(arr.length);writeArrayToMemory(arr,ret);return ret}),\"stringToC\":(function(str){var ret=0;if(str!==null&&str!==undefined&&str!==0){ret=Runtime.stackAlloc((str.length<<2)+1);writeStringToMemory(str,ret)}return ret})};var toC={\"string\":JSfuncs[\"stringToC\"],\"array\":JSfuncs[\"arrayToC\"]};ccall=function ccallFunc(ident,returnType,argTypes,args,opts){var func=getCFunc(ident);var cArgs=[];var stack=0;if(args){for(var i=0;i<args.length;i++){var converter=toC[argTypes[i]];if(converter){if(stack===0)stack=Runtime.stackSave();cArgs[i]=converter(args[i])}else{cArgs[i]=args[i]}}}var ret=func.apply(null,cArgs);if(returnType===\"string\")ret=Pointer_stringify(ret);if(stack!==0){if(opts&&opts.async){EmterpreterAsync.asyncFinalizers.push((function(){Runtime.stackRestore(stack)}));return}Runtime.stackRestore(stack)}return ret};var sourceRegex=/^function\\s*\\(([^)]*)\\)\\s*{\\s*([^*]*?)[\\s;]*(?:return\\s*(.*?)[;\\s]*)?}$/;function parseJSFunc(jsfunc){var parsed=jsfunc.toString().match(sourceRegex).slice(1);return{arguments:parsed[0],body:parsed[1],returnValue:parsed[2]}}var JSsource={};for(var fun in JSfuncs){if(JSfuncs.hasOwnProperty(fun)){JSsource[fun]=parseJSFunc(JSfuncs[fun])}}cwrap=function cwrap(ident,returnType,argTypes){argTypes=argTypes||[];var cfunc=getCFunc(ident);var numericArgs=argTypes.every((function(type){return type===\"number\"}));var numericRet=returnType!==\"string\";if(numericRet&&numericArgs){return cfunc}var argNames=argTypes.map((function(x,i){return\"$\"+i}));var funcstr=\"(function(\"+argNames.join(\",\")+\") {\";var nargs=argTypes.length;if(!numericArgs){funcstr+=\"var stack = \"+JSsource[\"stackSave\"].body+\";\";for(var i=0;i<nargs;i++){var arg=argNames[i],type=argTypes[i];if(type===\"number\")continue;var convertCode=JSsource[type+\"ToC\"];funcstr+=\"var \"+convertCode.arguments+\" = \"+arg+\";\";funcstr+=convertCode.body+\";\";funcstr+=arg+\"=\"+convertCode.returnValue+\";\"}}var cfuncname=parseJSFunc((function(){return cfunc})).returnValue;funcstr+=\"var ret = \"+cfuncname+\"(\"+argNames.join(\",\")+\");\";if(!numericRet){var strgfy=parseJSFunc((function(){return Pointer_stringify})).returnValue;funcstr+=\"ret = \"+strgfy+\"(ret);\"}if(!numericArgs){funcstr+=JSsource[\"stackRestore\"].body.replace(\"()\",\"(stack)\")+\";\"}funcstr+=\"return ret})\";return eval(funcstr)}}))();Module[\"ccall\"]=ccall;Module[\"cwrap\"]=cwrap;function setValue(ptr,value,type,noSafe){type=type||\"i8\";if(type.charAt(type.length-1)===\"*\")type=\"i32\";switch(type){case\"i1\":HEAP8[ptr>>0]=value;break;case\"i8\":HEAP8[ptr>>0]=value;break;case\"i16\":HEAP16[ptr>>1]=value;break;case\"i32\":HEAP32[ptr>>2]=value;break;case\"i64\":tempI64=[value>>>0,(tempDouble=value,+Math_abs(tempDouble)>=+1?tempDouble>+0?(Math_min(+Math_floor(tempDouble/+4294967296),+4294967295)|0)>>>0:~~+Math_ceil((tempDouble- +(~~tempDouble>>>0))/+4294967296)>>>0:0)],HEAP32[ptr>>2]=tempI64[0],HEAP32[ptr+4>>2]=tempI64[1];break;case\"float\":HEAPF32[ptr>>2]=value;break;case\"double\":HEAPF64[ptr>>3]=value;break;default:abort(\"invalid type for setValue: \"+type)}}Module[\"setValue\"]=setValue;function getValue(ptr,type,noSafe){type=type||\"i8\";if(type.charAt(type.length-1)===\"*\")type=\"i32\";switch(type){case\"i1\":return HEAP8[ptr>>0];case\"i8\":return HEAP8[ptr>>0];case\"i16\":return HEAP16[ptr>>1];case\"i32\":return HEAP32[ptr>>2];case\"i64\":return HEAP32[ptr>>2];case\"float\":return HEAPF32[ptr>>2];case\"double\":return HEAPF64[ptr>>3];default:abort(\"invalid type for setValue: \"+type)}return null}Module[\"getValue\"]=getValue;var ALLOC_NORMAL=0;var ALLOC_STACK=1;var ALLOC_STATIC=2;var ALLOC_DYNAMIC=3;var ALLOC_NONE=4;Module[\"ALLOC_NORMAL\"]=ALLOC_NORMAL;Module[\"ALLOC_STACK\"]=ALLOC_STACK;Module[\"ALLOC_STATIC\"]=ALLOC_STATIC;Module[\"ALLOC_DYNAMIC\"]=ALLOC_DYNAMIC;Module[\"ALLOC_NONE\"]=ALLOC_NONE;function allocate(slab,types,allocator,ptr){var zeroinit,size;if(typeof slab===\"number\"){zeroinit=true;size=slab}else{zeroinit=false;size=slab.length}var singleType=typeof types===\"string\"?types:null;var ret;if(allocator==ALLOC_NONE){ret=ptr}else{ret=[_malloc,Runtime.stackAlloc,Runtime.staticAlloc,Runtime.dynamicAlloc][allocator===undefined?ALLOC_STATIC:allocator](Math.max(size,singleType?1:types.length))}if(zeroinit){var ptr=ret,stop;assert((ret&3)==0);stop=ret+(size&~3);for(;ptr<stop;ptr+=4){HEAP32[ptr>>2]=0}stop=ret+size;while(ptr<stop){HEAP8[ptr++>>0]=0}return ret}if(singleType===\"i8\"){if(slab.subarray||slab.slice){HEAPU8.set(slab,ret)}else{HEAPU8.set(new Uint8Array(slab),ret)}return ret}var i=0,type,typeSize,previousType;while(i<size){var curr=slab[i];if(typeof curr===\"function\"){curr=Runtime.getFunctionIndex(curr)}type=singleType||types[i];if(type===0){i++;continue}if(type==\"i64\")type=\"i32\";setValue(ret+i,curr,type);if(previousType!==type){typeSize=Runtime.getNativeTypeSize(type);previousType=type}i+=typeSize}return ret}Module[\"allocate\"]=allocate;function getMemory(size){if(!staticSealed)return Runtime.staticAlloc(size);if(typeof _sbrk!==\"undefined\"&&!_sbrk.called||!runtimeInitialized)return Runtime.dynamicAlloc(size);return _malloc(size)}Module[\"getMemory\"]=getMemory;function Pointer_stringify(ptr,length){if(length===0||!ptr)return\"\";var hasUtf=0;var t;var i=0;while(1){t=HEAPU8[ptr+i>>0];hasUtf|=t;if(t==0&&!length)break;i++;if(length&&i==length)break}if(!length)length=i;var ret=\"\";if(hasUtf<128){var MAX_CHUNK=1024;var curr;while(length>0){curr=String.fromCharCode.apply(String,HEAPU8.subarray(ptr,ptr+Math.min(length,MAX_CHUNK)));ret=ret?ret+curr:curr;ptr+=MAX_CHUNK;length-=MAX_CHUNK}return ret}return Module[\"UTF8ToString\"](ptr)}Module[\"Pointer_stringify\"]=Pointer_stringify;function AsciiToString(ptr){var str=\"\";while(1){var ch=HEAP8[ptr++>>0];if(!ch)return str;str+=String.fromCharCode(ch)}}Module[\"AsciiToString\"]=AsciiToString;function stringToAscii(str,outPtr){return writeAsciiToMemory(str,outPtr,false)}Module[\"stringToAscii\"]=stringToAscii;function UTF8ArrayToString(u8Array,idx){var u0,u1,u2,u3,u4,u5;var str=\"\";while(1){u0=u8Array[idx++];if(!u0)return str;if(!(u0&128)){str+=String.fromCharCode(u0);continue}u1=u8Array[idx++]&63;if((u0&224)==192){str+=String.fromCharCode((u0&31)<<6|u1);continue}u2=u8Array[idx++]&63;if((u0&240)==224){u0=(u0&15)<<12|u1<<6|u2}else{u3=u8Array[idx++]&63;if((u0&248)==240){u0=(u0&7)<<18|u1<<12|u2<<6|u3}else{u4=u8Array[idx++]&63;if((u0&252)==248){u0=(u0&3)<<24|u1<<18|u2<<12|u3<<6|u4}else{u5=u8Array[idx++]&63;u0=(u0&1)<<30|u1<<24|u2<<18|u3<<12|u4<<6|u5}}}if(u0<65536){str+=String.fromCharCode(u0)}else{var ch=u0-65536;str+=String.fromCharCode(55296|ch>>10,56320|ch&1023)}}}Module[\"UTF8ArrayToString\"]=UTF8ArrayToString;function UTF8ToString(ptr){return UTF8ArrayToString(HEAPU8,ptr)}Module[\"UTF8ToString\"]=UTF8ToString;function stringToUTF8Array(str,outU8Array,outIdx,maxBytesToWrite){if(!(maxBytesToWrite>0))return 0;var startIdx=outIdx;var endIdx=outIdx+maxBytesToWrite-1;for(var i=0;i<str.length;++i){var u=str.charCodeAt(i);if(u>=55296&&u<=57343)u=65536+((u&1023)<<10)|str.charCodeAt(++i)&1023;if(u<=127){if(outIdx>=endIdx)break;outU8Array[outIdx++]=u}else if(u<=2047){if(outIdx+1>=endIdx)break;outU8Array[outIdx++]=192|u>>6;outU8Array[outIdx++]=128|u&63}else if(u<=65535){if(outIdx+2>=endIdx)break;outU8Array[outIdx++]=224|u>>12;outU8Array[outIdx++]=128|u>>6&63;outU8Array[outIdx++]=128|u&63}else if(u<=2097151){if(outIdx+3>=endIdx)break;outU8Array[outIdx++]=240|u>>18;outU8Array[outIdx++]=128|u>>12&63;outU8Array[outIdx++]=128|u>>6&63;outU8Array[outIdx++]=128|u&63}else if(u<=67108863){if(outIdx+4>=endIdx)break;outU8Array[outIdx++]=248|u>>24;outU8Array[outIdx++]=128|u>>18&63;outU8Array[outIdx++]=128|u>>12&63;outU8Array[outIdx++]=128|u>>6&63;outU8Array[outIdx++]=128|u&63}else{if(outIdx+5>=endIdx)break;outU8Array[outIdx++]=252|u>>30;outU8Array[outIdx++]=128|u>>24&63;outU8Array[outIdx++]=128|u>>18&63;outU8Array[outIdx++]=128|u>>12&63;outU8Array[outIdx++]=128|u>>6&63;outU8Array[outIdx++]=128|u&63}}outU8Array[outIdx]=0;return outIdx-startIdx}Module[\"stringToUTF8Array\"]=stringToUTF8Array;function stringToUTF8(str,outPtr,maxBytesToWrite){return stringToUTF8Array(str,HEAPU8,outPtr,maxBytesToWrite)}Module[\"stringToUTF8\"]=stringToUTF8;function lengthBytesUTF8(str){var len=0;for(var i=0;i<str.length;++i){var u=str.charCodeAt(i);if(u>=55296&&u<=57343)u=65536+((u&1023)<<10)|str.charCodeAt(++i)&1023;if(u<=127){++len}else if(u<=2047){len+=2}else if(u<=65535){len+=3}else if(u<=2097151){len+=4}else if(u<=67108863){len+=5}else{len+=6}}return len}Module[\"lengthBytesUTF8\"]=lengthBytesUTF8;function UTF16ToString(ptr){var i=0;var str=\"\";while(1){var codeUnit=HEAP16[ptr+i*2>>1];if(codeUnit==0)return str;++i;str+=String.fromCharCode(codeUnit)}}Module[\"UTF16ToString\"]=UTF16ToString;function stringToUTF16(str,outPtr,maxBytesToWrite){if(maxBytesToWrite===undefined){maxBytesToWrite=2147483647}if(maxBytesToWrite<2)return 0;maxBytesToWrite-=2;var startPtr=outPtr;var numCharsToWrite=maxBytesToWrite<str.length*2?maxBytesToWrite/2:str.length;for(var i=0;i<numCharsToWrite;++i){var codeUnit=str.charCodeAt(i);HEAP16[outPtr>>1]=codeUnit;outPtr+=2}HEAP16[outPtr>>1]=0;return outPtr-startPtr}Module[\"stringToUTF16\"]=stringToUTF16;function lengthBytesUTF16(str){return str.length*2}Module[\"lengthBytesUTF16\"]=lengthBytesUTF16;function UTF32ToString(ptr){var i=0;var str=\"\";while(1){var utf32=HEAP32[ptr+i*4>>2];if(utf32==0)return str;++i;if(utf32>=65536){var ch=utf32-65536;str+=String.fromCharCode(55296|ch>>10,56320|ch&1023)}else{str+=String.fromCharCode(utf32)}}}Module[\"UTF32ToString\"]=UTF32ToString;function stringToUTF32(str,outPtr,maxBytesToWrite){if(maxBytesToWrite===undefined){maxBytesToWrite=2147483647}if(maxBytesToWrite<4)return 0;var startPtr=outPtr;var endPtr=startPtr+maxBytesToWrite-4;for(var i=0;i<str.length;++i){var codeUnit=str.charCodeAt(i);if(codeUnit>=55296&&codeUnit<=57343){var trailSurrogate=str.charCodeAt(++i);codeUnit=65536+((codeUnit&1023)<<10)|trailSurrogate&1023}HEAP32[outPtr>>2]=codeUnit;outPtr+=4;if(outPtr+4>endPtr)break}HEAP32[outPtr>>2]=0;return outPtr-startPtr}Module[\"stringToUTF32\"]=stringToUTF32;function lengthBytesUTF32(str){var len=0;for(var i=0;i<str.length;++i){var codeUnit=str.charCodeAt(i);if(codeUnit>=55296&&codeUnit<=57343)++i;len+=4}return len}Module[\"lengthBytesUTF32\"]=lengthBytesUTF32;function demangle(func){var hasLibcxxabi=!!Module[\"___cxa_demangle\"];if(hasLibcxxabi){try{var buf=_malloc(func.length);writeStringToMemory(func.substr(1),buf);var status=_malloc(4);var ret=Module[\"___cxa_demangle\"](buf,0,0,status);if(getValue(status,\"i32\")===0&&ret){return Pointer_stringify(ret)}}catch(e){}finally{if(buf)_free(buf);if(status)_free(status);if(ret)_free(ret)}}var i=3;var basicTypes={\"v\":\"void\",\"b\":\"bool\",\"c\":\"char\",\"s\":\"short\",\"i\":\"int\",\"l\":\"long\",\"f\":\"float\",\"d\":\"double\",\"w\":\"wchar_t\",\"a\":\"signed char\",\"h\":\"unsigned char\",\"t\":\"unsigned short\",\"j\":\"unsigned int\",\"m\":\"unsigned long\",\"x\":\"long long\",\"y\":\"unsigned long long\",\"z\":\"...\"};var subs=[];var first=true;function dump(x){if(x)Module.print(x);Module.print(func);var pre=\"\";for(var a=0;a<i;a++)pre+=\" \";Module.print(pre+\"^\")}function parseNested(){i++;if(func[i]===\"K\")i++;var parts=[];while(func[i]!==\"E\"){if(func[i]===\"S\"){i++;var next=func.indexOf(\"_\",i);var num=func.substring(i,next)||0;parts.push(subs[num]||\"?\");i=next+1;continue}if(func[i]===\"C\"){parts.push(parts[parts.length-1]);i+=2;continue}var size=parseInt(func.substr(i));var pre=size.toString().length;if(!size||!pre){i--;break}var curr=func.substr(i+pre,size);parts.push(curr);subs.push(curr);i+=pre+size}i++;return parts}function parse(rawList,limit,allowVoid){limit=limit||Infinity;var ret=\"\",list=[];function flushList(){return\"(\"+list.join(\", \")+\")\"}var name;if(func[i]===\"N\"){name=parseNested().join(\"::\");limit--;if(limit===0)return rawList?[name]:name}else{if(func[i]===\"K\"||first&&func[i]===\"L\")i++;var size=parseInt(func.substr(i));if(size){var pre=size.toString().length;name=func.substr(i+pre,size);i+=pre+size}}first=false;if(func[i]===\"I\"){i++;var iList=parse(true);var iRet=parse(true,1,true);ret+=iRet[0]+\" \"+name+\"<\"+iList.join(\", \")+\">\"}else{ret=name}paramLoop:while(i<func.length&&limit-->0){var c=func[i++];if(c in basicTypes){list.push(basicTypes[c])}else{switch(c){case\"P\":list.push(parse(true,1,true)[0]+\"*\");break;case\"R\":list.push(parse(true,1,true)[0]+\"&\");break;case\"L\":{i++;var end=func.indexOf(\"E\",i);var size=end-i;list.push(func.substr(i,size));i+=size+2;break};case\"A\":{var size=parseInt(func.substr(i));i+=size.toString().length;if(func[i]!==\"_\")throw\"?\";i++;list.push(parse(true,1,true)[0]+\" [\"+size+\"]\");break};case\"E\":break paramLoop;default:ret+=\"?\"+c;break paramLoop}}}if(!allowVoid&&list.length===1&&list[0]===\"void\")list=[];if(rawList){if(ret){list.push(ret+\"?\")}return list}else{return ret+flushList()}}var parsed=func;try{if(func==\"Object._main\"||func==\"_main\"){return\"main()\"}if(typeof func===\"number\")func=Pointer_stringify(func);if(func[0]!==\"_\")return func;if(func[1]!==\"_\")return func;if(func[2]!==\"Z\")return func;switch(func[3]){case\"n\":return\"operator new()\";case\"d\":return\"operator delete()\"}parsed=parse()}catch(e){parsed+=\"?\"}if(parsed.indexOf(\"?\")>=0&&!hasLibcxxabi){Runtime.warnOnce(\"warning: a problem occurred in builtin C++ name demangling; build with  -s DEMANGLE_SUPPORT=1  to link in libcxxabi demangling\")}return parsed}function demangleAll(text){return text.replace(/__Z[\\w\\d_]+/g,(function(x){var y=demangle(x);return x===y?x:x+\" [\"+y+\"]\"}))}function jsStackTrace(){var err=new Error;if(!err.stack){try{throw new Error(0)}catch(e){err=e}if(!err.stack){return\"(no stack trace available)\"}}return err.stack.toString()}function stackTrace(){return demangleAll(jsStackTrace())}Module[\"stackTrace\"]=stackTrace;var PAGE_SIZE=4096;function alignMemoryPage(x){if(x%4096>0){x+=4096-x%4096}return x}var HEAP;var HEAP8,HEAPU8,HEAP16,HEAPU16,HEAP32,HEAPU32,HEAPF32,HEAPF64;var STATIC_BASE=0,STATICTOP=0,staticSealed=false;var STACK_BASE=0,STACKTOP=0,STACK_MAX=0;var DYNAMIC_BASE=0,DYNAMICTOP=0;function enlargeMemory(){var OLD_TOTAL_MEMORY=TOTAL_MEMORY;var LIMIT=Math.pow(2,31);if(DYNAMICTOP>=LIMIT)return false;while(TOTAL_MEMORY<=DYNAMICTOP){if(TOTAL_MEMORY<LIMIT/2){TOTAL_MEMORY=alignMemoryPage(2*TOTAL_MEMORY)}else{var last=TOTAL_MEMORY;TOTAL_MEMORY=alignMemoryPage((3*TOTAL_MEMORY+LIMIT)/4);if(TOTAL_MEMORY<=last)return false}}TOTAL_MEMORY=Math.max(TOTAL_MEMORY,16*1024*1024);if(TOTAL_MEMORY>=LIMIT)return false;try{if(ArrayBuffer.transfer){buffer=ArrayBuffer.transfer(buffer,TOTAL_MEMORY)}else{var oldHEAP8=HEAP8;buffer=new ArrayBuffer(TOTAL_MEMORY)}}catch(e){return false}var success=_emscripten_replace_memory(buffer);if(!success)return false;Module[\"buffer\"]=buffer;Module[\"HEAP8\"]=HEAP8=new Int8Array(buffer);Module[\"HEAP16\"]=HEAP16=new Int16Array(buffer);Module[\"HEAP32\"]=HEAP32=new Int32Array(buffer);Module[\"HEAPU8\"]=HEAPU8=new Uint8Array(buffer);Module[\"HEAPU16\"]=HEAPU16=new Uint16Array(buffer);Module[\"HEAPU32\"]=HEAPU32=new Uint32Array(buffer);Module[\"HEAPF32\"]=HEAPF32=new Float32Array(buffer);Module[\"HEAPF64\"]=HEAPF64=new Float64Array(buffer);if(!ArrayBuffer.transfer){HEAP8.set(oldHEAP8)}return true}var byteLength;try{byteLength=Function.prototype.call.bind(Object.getOwnPropertyDescriptor(ArrayBuffer.prototype,\"byteLength\").get);byteLength(new ArrayBuffer(4))}catch(e){byteLength=(function(buffer){return buffer.byteLength})}var TOTAL_STACK=Module[\"TOTAL_STACK\"]||5242880;var TOTAL_MEMORY=Module[\"TOTAL_MEMORY\"]||16777216;var totalMemory=64*1024;while(totalMemory<TOTAL_MEMORY||totalMemory<2*TOTAL_STACK){if(totalMemory<16*1024*1024){totalMemory*=2}else{totalMemory+=16*1024*1024}}totalMemory=Math.max(totalMemory,16*1024*1024);if(totalMemory!==TOTAL_MEMORY){TOTAL_MEMORY=totalMemory}assert(typeof Int32Array!==\"undefined\"&&typeof Float64Array!==\"undefined\"&&!!(new Int32Array(1))[\"subarray\"]&&!!(new Int32Array(1))[\"set\"],\"JS engine does not provide full typed array support\");var buffer;buffer=new ArrayBuffer(TOTAL_MEMORY);HEAP8=new Int8Array(buffer);HEAP16=new Int16Array(buffer);HEAP32=new Int32Array(buffer);HEAPU8=new Uint8Array(buffer);HEAPU16=new Uint16Array(buffer);HEAPU32=new Uint32Array(buffer);HEAPF32=new Float32Array(buffer);HEAPF64=new Float64Array(buffer);HEAP32[0]=255;assert(HEAPU8[0]===255&&HEAPU8[3]===0,\"Typed arrays 2 must be run on a little-endian system\");Module[\"HEAP\"]=HEAP;Module[\"buffer\"]=buffer;Module[\"HEAP8\"]=HEAP8;Module[\"HEAP16\"]=HEAP16;Module[\"HEAP32\"]=HEAP32;Module[\"HEAPU8\"]=HEAPU8;Module[\"HEAPU16\"]=HEAPU16;Module[\"HEAPU32\"]=HEAPU32;Module[\"HEAPF32\"]=HEAPF32;Module[\"HEAPF64\"]=HEAPF64;function callRuntimeCallbacks(callbacks){while(callbacks.length>0){var callback=callbacks.shift();if(typeof callback==\"function\"){callback();continue}var func=callback.func;if(typeof func===\"number\"){if(callback.arg===undefined){Runtime.dynCall(\"v\",func)}else{Runtime.dynCall(\"vi\",func,[callback.arg])}}else{func(callback.arg===undefined?null:callback.arg)}}}var __ATPRERUN__=[];var __ATINIT__=[];var __ATMAIN__=[];var __ATEXIT__=[];var __ATPOSTRUN__=[];var runtimeInitialized=false;var runtimeExited=false;function preRun(){if(Module[\"preRun\"]){if(typeof Module[\"preRun\"]==\"function\")Module[\"preRun\"]=[Module[\"preRun\"]];while(Module[\"preRun\"].length){addOnPreRun(Module[\"preRun\"].shift())}}callRuntimeCallbacks(__ATPRERUN__)}function ensureInitRuntime(){if(runtimeInitialized)return;runtimeInitialized=true;callRuntimeCallbacks(__ATINIT__)}function preMain(){callRuntimeCallbacks(__ATMAIN__)}function exitRuntime(){callRuntimeCallbacks(__ATEXIT__);runtimeExited=true}function postRun(){if(Module[\"postRun\"]){if(typeof Module[\"postRun\"]==\"function\")Module[\"postRun\"]=[Module[\"postRun\"]];while(Module[\"postRun\"].length){addOnPostRun(Module[\"postRun\"].shift())}}callRuntimeCallbacks(__ATPOSTRUN__)}function addOnPreRun(cb){__ATPRERUN__.unshift(cb)}Module[\"addOnPreRun\"]=addOnPreRun;function addOnInit(cb){__ATINIT__.unshift(cb)}Module[\"addOnInit\"]=addOnInit;function addOnPreMain(cb){__ATMAIN__.unshift(cb)}Module[\"addOnPreMain\"]=addOnPreMain;function addOnExit(cb){__ATEXIT__.unshift(cb)}Module[\"addOnExit\"]=addOnExit;function addOnPostRun(cb){__ATPOSTRUN__.unshift(cb)}Module[\"addOnPostRun\"]=addOnPostRun;function intArrayFromString(stringy,dontAddNull,length){var len=length>0?length:lengthBytesUTF8(stringy)+1;var u8array=new Array(len);var numBytesWritten=stringToUTF8Array(stringy,u8array,0,u8array.length);if(dontAddNull)u8array.length=numBytesWritten;return u8array}Module[\"intArrayFromString\"]=intArrayFromString;function intArrayToString(array){var ret=[];for(var i=0;i<array.length;i++){var chr=array[i];if(chr>255){chr&=255}ret.push(String.fromCharCode(chr))}return ret.join(\"\")}Module[\"intArrayToString\"]=intArrayToString;function writeStringToMemory(string,buffer,dontAddNull){var array=intArrayFromString(string,dontAddNull);var i=0;while(i<array.length){var chr=array[i];HEAP8[buffer+i>>0]=chr;i=i+1}}Module[\"writeStringToMemory\"]=writeStringToMemory;function writeArrayToMemory(array,buffer){for(var i=0;i<array.length;i++){HEAP8[buffer++>>0]=array[i]}}Module[\"writeArrayToMemory\"]=writeArrayToMemory;function writeAsciiToMemory(str,buffer,dontAddNull){for(var i=0;i<str.length;++i){HEAP8[buffer++>>0]=str.charCodeAt(i)}if(!dontAddNull)HEAP8[buffer>>0]=0}Module[\"writeAsciiToMemory\"]=writeAsciiToMemory;function unSign(value,bits,ignore){if(value>=0){return value}return bits<=32?2*Math.abs(1<<bits-1)+value:Math.pow(2,bits)+value}function reSign(value,bits,ignore){if(value<=0){return value}var half=bits<=32?Math.abs(1<<bits-1):Math.pow(2,bits-1);if(value>=half&&(bits<=32||value>half)){value=-2*half+value}return value}if(!Math[\"imul\"]||Math[\"imul\"](4294967295,5)!==-5)Math[\"imul\"]=function imul(a,b){var ah=a>>>16;var al=a&65535;var bh=b>>>16;var bl=b&65535;return al*bl+(ah*bl+al*bh<<16)|0};Math.imul=Math[\"imul\"];if(!Math[\"clz32\"])Math[\"clz32\"]=(function(x){x=x>>>0;for(var i=0;i<32;i++){if(x&1<<31-i)return i}return 32});Math.clz32=Math[\"clz32\"];var Math_abs=Math.abs;var Math_cos=Math.cos;var Math_sin=Math.sin;var Math_tan=Math.tan;var Math_acos=Math.acos;var Math_asin=Math.asin;var Math_atan=Math.atan;var Math_atan2=Math.atan2;var Math_exp=Math.exp;var Math_log=Math.log;var Math_sqrt=Math.sqrt;var Math_ceil=Math.ceil;var Math_floor=Math.floor;var Math_pow=Math.pow;var Math_imul=Math.imul;var Math_fround=Math.fround;var Math_min=Math.min;var Math_clz32=Math.clz32;var runDependencies=0;var runDependencyWatcher=null;var dependenciesFulfilled=null;function getUniqueRunDependency(id){return id}function addRunDependency(id){runDependencies++;if(Module[\"monitorRunDependencies\"]){Module[\"monitorRunDependencies\"](runDependencies)}}Module[\"addRunDependency\"]=addRunDependency;function removeRunDependency(id){runDependencies--;if(Module[\"monitorRunDependencies\"]){Module[\"monitorRunDependencies\"](runDependencies)}if(runDependencies==0){if(runDependencyWatcher!==null){clearInterval(runDependencyWatcher);runDependencyWatcher=null}if(dependenciesFulfilled){var callback=dependenciesFulfilled;dependenciesFulfilled=null;callback()}}}Module[\"removeRunDependency\"]=removeRunDependency;Module[\"preloadedImages\"]={};Module[\"preloadedAudios\"]={};var memoryInitializer=null;var ASM_CONSTS=[];STATIC_BASE=8;STATICTOP=STATIC_BASE+4928;__ATINIT__.push();allocate([192,0,0,0,103,4,0,0,24,0,0,0,0,0,0,0,152,0,0,0,116,4,0,0,152,0,0,0,129,4,0,0,192,0,0,0,142,4,0,0,32,0,0,0,0,0,0,0,192,0,0,0,175,4,0,0,40,0,0,0,0,0,0,0,192,0,0,0,245,4,0,0,40,0,0,0,0,0,0,0,192,0,0,0,209,4,0,0,72,0,0,0,0,0,0,0,192,0,0,0,23,5,0,0,56,0,0,0,0,0,0,0,0,0,0,0,8,0,0,0,1,0,0,0,2,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,56,0,0,0,3,0,0,0,4,0,0,0,5,0,0,0,6,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,104,0,0,0,3,0,0,0,7,0,0,0,5,0,0,0,6,0,0,0,1,0,0,0,2,0,0,0,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,3,0,0,0,46,13,0,0,0,4,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,10,255,255,255,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,109,97,58,32,37,100,45,62,37,100,10,0,109,98,58,32,37,100,45,62,37,100,10,0,109,32,100,111,110,101,0,97,32,99,117,116,116,101,114,65,110,103,108,101,61,37,102,32,112,97,115,115,68,101,112,116,104,61,37,102,32,109,97,120,68,101,112,116,104,61,37,102,10,0,105,0,106,58,32,101,100,103,101,73,110,100,101,120,101,115,58,32,37,100,10,0,107,0,110,117,109,80,114,111,99,101,115,115,101,100,58,32,37,100,47,37,100,10,0,100,105,118,101,0,114,101,116,114,97,99,116,0,122,32,45,32,100,111,110,101,0,98,0,99,0,100,0,101,0,102,58,32,37,100,32,118,111,114,111,110,111,105,32,101,100,103,101,115,10,0,103,49,58,32,37,100,32,102,105,108,116,101,114,69,100,103,101,115,10,0,103,50,58,32,37,100,32,102,105,108,116,101,114,69,100,103,101,115,10,0,103,51,58,32,37,100,32,102,105,108,116,101,114,69,100,103,101,115,10,0,103,52,0,103,53,58,32,37,100,32,101,100,103,101,115,10,0,83,116,57,98,97,100,95,97,108,108,111,99,0,83,116,57,101,120,99,101,112,116,105,111,110,0,83,116,57,116,121,112,101,95,105,110,102,111,0,78,49,48,95,95,99,120,120,97,98,105,118,49,49,54,95,95,115,104,105,109,95,116,121,112,101,95,105,110,102,111,69,0,78,49,48,95,95,99,120,120,97,98,105,118,49,49,55,95,95,99,108,97,115,115,95,116,121,112,101,95,105,110,102,111,69,0,78,49,48,95,95,99,120,120,97,98,105,118,49,49,57,95,95,112,111,105,110,116,101,114,95,116,121,112,101,95,105,110,102,111,69,0,78,49,48,95,95,99,120,120,97,98,105,118,49,49,55,95,95,112,98,97,115,101,95,116,121,112,101,95,105,110,102,111,69,0,78,49,48,95,95,99,120,120,97,98,105,118,49,50,48,95,95,115,105,95,99,108,97,115,115,95,116,121,112,101,95,105,110,102,111,69,0,33,34,118,101,99,116,111,114,32,108,101,110,103,116,104,95,101,114,114,111,114,34,0,67,58,92,80,114,111,103,114,97,109,32,70,105,108,101,115,92,69,109,115,99,114,105,112,116,101,110,92,101,109,115,99,114,105,112,116,101,110,92,49,46,51,53,46,48,92,115,121,115,116,101,109,92,105,110,99,108,117,100,101,92,108,105,98,99,120,120,92,118,101,99,116,111,114,0,95,95,116,104,114,111,119,95,108,101,110,103,116,104,95,101,114,114,111,114,0,115,116,100,58,58,98,97,100,95,97,108,108,111,99,0,84,33,34,25,13,1,2,3,17,75,28,12,16,4,11,29,18,30,39,104,110,111,112,113,98,32,5,6,15,19,20,21,26,8,22,7,40,36,23,24,9,10,14,27,31,37,35,131,130,125,38,42,43,60,61,62,63,67,71,74,77,88,89,90,91,92,93,94,95,96,97,99,100,101,102,103,105,106,107,108,114,115,116,121,122,123,124,0,73,108,108,101,103,97,108,32,98,121,116,101,32,115,101,113,117,101,110,99,101,0,68,111,109,97,105,110,32,101,114,114,111,114,0,82,101,115,117,108,116,32,110,111,116,32,114,101,112,114,101,115,101,110,116,97,98,108,101,0,78,111,116,32,97,32,116,116,121,0,80,101,114,109,105,115,115,105,111,110,32,100,101,110,105,101,100,0,79,112,101,114,97,116,105,111,110,32,110,111,116,32,112,101,114,109,105,116,116,101,100,0,78,111,32,115,117,99,104,32,102,105,108,101,32,111,114,32,100,105,114,101,99,116,111,114,121,0,78,111,32,115,117,99,104,32,112,114,111,99,101,115,115,0,70,105,108,101,32,101,120,105,115,116,115,0,86,97,108,117,101,32,116,111,111,32,108,97,114,103,101,32,102,111,114,32,100,97,116,97,32,116,121,112,101,0,78,111,32,115,112,97,99,101,32,108,101,102,116,32,111,110,32,100,101,118,105,99,101,0,79,117,116,32,111,102,32,109,101,109,111,114,121,0,82,101,115,111,117,114,99,101,32,98,117,115,121,0,73,110,116,101,114,114,117,112,116,101,100,32,115,121,115,116,101,109,32,99,97,108,108,0,82,101,115,111,117,114,99,101,32,116,101,109,112,111,114,97,114,105,108,121,32,117,110,97,118,97,105,108,97,98,108,101,0,73,110,118,97,108,105,100,32,115,101,101,107,0,67,114,111,115,115,45,100,101,118,105,99,101,32,108,105,110,107,0,82,101,97,100,45,111,110,108,121,32,102,105,108,101,32,115,121,115,116,101,109,0,68,105,114,101,99,116,111,114,121,32,110,111,116,32,101,109,112,116,121,0,67,111,110,110,101,99,116,105,111,110,32,114,101,115,101,116,32,98,121,32,112,101,101,114,0,79,112,101,114,97,116,105,111,110,32,116,105,109,101,100,32,111,117,116,0,67,111,110,110,101,99,116,105,111,110,32,114,101,102,117,115,101,100,0,72,111,115,116,32,105,115,32,100,111,119,110,0,72,111,115,116,32,105,115,32,117,110,114,101,97,99,104,97,98,108,101,0,65,100,100,114,101,115,115,32,105,110,32,117,115,101,0,66,114,111,107,101,110,32,112,105,112,101,0,73,47,79,32,101,114,114,111,114,0,78,111,32,115,117,99,104,32,100,101,118,105,99,101,32,111,114,32,97,100,100,114,101,115,115,0,66,108,111,99,107,32,100,101,118,105,99,101,32,114,101,113,117,105,114,101,100,0,78,111,32,115,117,99,104,32,100,101,118,105,99,101,0,78,111,116,32,97,32,100,105,114,101,99,116,111,114,121,0,73,115,32,97,32,100,105,114,101,99,116,111,114,121,0,84,101,120,116,32,102,105,108,101,32,98,117,115,121,0,69,120,101,99,32,102,111,114,109,97,116,32,101,114,114,111,114,0,73,110,118,97,108,105,100,32,97,114,103,117,109,101,110,116,0,65,114,103,117,109,101,110,116,32,108,105,115,116,32,116,111,111,32,108,111,110,103,0,83,121,109,98,111,108,105,99,32,108,105,110,107,32,108,111,111,112,0,70,105,108,101,110,97,109,101,32,116,111,111,32,108,111,110,103,0,84,111,111,32,109,97,110,121,32,111,112,101,110,32,102,105,108,101,115,32,105,110,32,115,121,115,116,101,109,0,78,111,32,102,105,108,101,32,100,101,115,99,114,105,112,116,111,114,115,32,97,118,97,105,108,97,98,108,101,0,66,97,100,32,102,105,108,101,32,100,101,115,99,114,105,112,116,111,114,0,78,111,32,99,104,105,108,100,32,112,114,111,99,101,115,115,0,66,97,100,32,97,100,100,114,101,115,115,0,70,105,108,101,32,116,111,111,32,108,97,114,103,101,0,84,111,111,32,109,97,110,121,32,108,105,110,107,115,0,78,111,32,108,111,99,107,115,32,97,118,97,105,108,97,98,108,101,0,82,101,115,111,117,114,99,101,32,100,101,97,100,108,111,99,107,32,119,111,117,108,100,32,111,99,99,117,114,0,83,116,97,116,101,32,110,111,116,32,114,101,99,111,118,101,114,97,98,108,101,0,80,114,101,118,105,111,117,115,32,111,119,110,101,114,32,100,105,101,100,0,79,112,101,114,97,116,105,111,110,32,99,97,110,99,101,108,101,100,0,70,117,110,99,116,105,111,110,32,110,111,116,32,105,109,112,108,101,109,101,110,116,101,100,0,78,111,32,109,101,115,115,97,103,101,32,111,102,32,100,101,115,105,114,101,100,32,116,121,112,101,0,73,100,101,110,116,105,102,105,101,114,32,114,101,109,111,118,101,100,0,68,101,118,105,99,101,32,110,111,116,32,97,32,115,116,114,101,97,109,0,78,111,32,100,97,116,97,32,97,118,97,105,108,97,98,108,101,0,68,101,118,105,99,101,32,116,105,109,101,111,117,116,0,79,117,116,32,111,102,32,115,116,114,101,97,109,115,32,114,101,115,111,117,114,99,101,115,0,76,105,110,107,32,104,97,115,32,98,101,101,110,32,115,101,118,101,114,101,100,0,80,114,111,116,111,99,111,108,32,101,114,114,111,114,0,66,97,100,32,109,101,115,115,97,103,101,0,70,105,108,101,32,100,101,115,99,114,105,112,116,111,114,32,105,110,32,98,97,100,32,115,116,97,116,101,0,78,111,116,32,97,32,115,111,99,107,101,116,0,68,101,115,116,105,110,97,116,105,111,110,32,97,100,100,114,101,115,115,32,114,101,113,117,105,114,101,100,0,77,101,115,115,97,103,101,32,116,111,111,32,108,97,114,103,101,0,80,114,111,116,111,99,111,108,32,119,114,111,110,103,32,116,121,112,101,32,102,111,114,32,115,111,99,107,101,116,0,80,114,111,116,111,99,111,108,32,110,111,116,32,97,118,97,105,108,97,98,108,101,0,80,114,111,116,111,99,111,108,32,110,111,116,32,115,117,112,112,111,114,116,101,100,0,83,111,99,107,101,116,32,116,121,112,101,32,110,111,116,32,115,117,112,112,111,114,116,101,100,0,78,111,116,32,115,117,112,112,111,114,116,101,100,0,80,114,111,116,111,99,111,108,32,102,97,109,105,108,121,32,110,111,116,32,115,117,112,112,111,114,116,101,100,0,65,100,100,114,101,115,115,32,102,97,109,105,108,121,32,110,111,116,32,115,117,112,112,111,114,116,101,100,32,98,121,32,112,114,111,116,111,99,111,108,0,65,100,100,114,101,115,115,32,110,111,116,32,97,118,97,105,108,97,98,108,101,0,78,101,116,119,111,114,107,32,105,115,32,100,111,119,110,0,78,101,116,119,111,114,107,32,117,110,114,101,97,99,104,97,98,108,101,0,67,111,110,110,101,99,116,105,111,110,32,114,101,115,101,116,32,98,121,32,110,101,116,119,111,114,107,0,67,111,110,110,101,99,116,105,111,110,32,97,98,111,114,116,101,100,0,78,111,32,98,117,102,102,101,114,32,115,112,97,99,101,32,97,118,97,105,108,97,98,108,101,0,83,111,99,107,101,116,32,105,115,32,99,111,110,110,101,99,116,101,100,0,83,111,99,107,101,116,32,110,111,116,32,99,111,110,110,101,99,116,101,100,0,67,97,110,110,111,116,32,115,101,110,100,32,97,102,116,101,114,32,115,111,99,107,101,116,32,115,104,117,116,100,111,119,110,0,79,112,101,114,97,116,105,111,110,32,97,108,114,101,97,100,121,32,105,110,32,112,114,111,103,114,101,115,115,0,79,112,101,114,97,116,105,111,110,32,105,110,32,112,114,111,103,114,101,115,115,0,83,116,97,108,101,32,102,105,108,101,32,104,97,110,100,108,101,0,82,101,109,111,116,101,32,73,47,79,32,101,114,114,111,114,0,81,117,111,116,97,32,101,120,99,101,101,100,101,100,0,78,111,32,109,101,100,105,117,109,32,102,111,117,110,100,0,87,114,111,110,103,32,109,101,100,105,117,109,32,116,121,112,101,0,78,111,32,101,114,114,111,114,32,105,110,102,111,114,109,97,116,105,111,110,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,17,0,10,0,17,17,17,0,0,0,0,5,0,0,0,0,0,0,9,0,0,0,0,11,0,0,0,0,0,0,0,0,17,0,15,10,17,17,17,3,10,7,0,1,19,9,11,11,0,0,9,6,11,0,0,11,0,6,17,0,0,0,17,17,17,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,11,0,0,0,0,0,0,0,0,17,0,10,10,17,17,17,0,10,0,0,2,0,9,11,0,0,0,9,0,11,0,0,11,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,12,0,0,0,0,0,0,0,0,0,0,0,12,0,0,0,0,12,0,0,0,0,9,12,0,0,0,0,0,12,0,0,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,14,0,0,0,0,0,0,0,0,0,0,0,13,0,0,0,4,13,0,0,0,0,9,14,0,0,0,0,0,14,0,0,14,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,0,0,0,0,15,0,0,0,0,15,0,0,0,0,9,16,0,0,0,0,0,16,0,0,16,0,0,18,0,0,0,18,18,18,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,18,0,0,0,18,18,18,0,0,0,0,0,0,9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,11,0,0,0,0,0,0,0,0,0,0,0,10,0,0,0,0,10,0,0,0,0,9,11,0,0,0,0,0,11,0,0,11,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,12,0,0,0,0,0,0,0,0,0,0,0,12,0,0,0,0,12,0,0,0,0,9,12,0,0,0,0,0,12,0,0,12,0,0,48,49,50,51,52,53,54,55,56,57,65,66,67,68,69,70,45,43,32,32,32,48,88,48,120,0,40,110,117,108,108,41,0,45,48,88,43,48,88,32,48,88,45,48,120,43,48,120,32,48,120,0,105,110,102,0,73,78,70,0,110,97,110,0,78,65,78,0,46,0],\"i8\",ALLOC_NONE,Runtime.GLOBAL_BASE);var tempDoublePtr=Runtime.alignMemory(allocate(12,\"i8\",ALLOC_STATIC),8);assert(tempDoublePtr%8==0);function copyTempFloat(ptr){HEAP8[tempDoublePtr]=HEAP8[ptr];HEAP8[tempDoublePtr+1]=HEAP8[ptr+1];HEAP8[tempDoublePtr+2]=HEAP8[ptr+2];HEAP8[tempDoublePtr+3]=HEAP8[ptr+3]}function copyTempDouble(ptr){HEAP8[tempDoublePtr]=HEAP8[ptr];HEAP8[tempDoublePtr+1]=HEAP8[ptr+1];HEAP8[tempDoublePtr+2]=HEAP8[ptr+2];HEAP8[tempDoublePtr+3]=HEAP8[ptr+3];HEAP8[tempDoublePtr+4]=HEAP8[ptr+4];HEAP8[tempDoublePtr+5]=HEAP8[ptr+5];HEAP8[tempDoublePtr+6]=HEAP8[ptr+6];HEAP8[tempDoublePtr+7]=HEAP8[ptr+7]}var _BDtoIHigh=true;Module[\"_i64Subtract\"]=_i64Subtract;function ___setErrNo(value){if(Module[\"___errno_location\"])HEAP32[Module[\"___errno_location\"]()>>2]=value;return value}var ERRNO_CODES={EPERM:1,ENOENT:2,ESRCH:3,EINTR:4,EIO:5,ENXIO:6,E2BIG:7,ENOEXEC:8,EBADF:9,ECHILD:10,EAGAIN:11,EWOULDBLOCK:11,ENOMEM:12,EACCES:13,EFAULT:14,ENOTBLK:15,EBUSY:16,EEXIST:17,EXDEV:18,ENODEV:19,ENOTDIR:20,EISDIR:21,EINVAL:22,ENFILE:23,EMFILE:24,ENOTTY:25,ETXTBSY:26,EFBIG:27,ENOSPC:28,ESPIPE:29,EROFS:30,EMLINK:31,EPIPE:32,EDOM:33,ERANGE:34,ENOMSG:42,EIDRM:43,ECHRNG:44,EL2NSYNC:45,EL3HLT:46,EL3RST:47,ELNRNG:48,EUNATCH:49,ENOCSI:50,EL2HLT:51,EDEADLK:35,ENOLCK:37,EBADE:52,EBADR:53,EXFULL:54,ENOANO:55,EBADRQC:56,EBADSLT:57,EDEADLOCK:35,EBFONT:59,ENOSTR:60,ENODATA:61,ETIME:62,ENOSR:63,ENONET:64,ENOPKG:65,EREMOTE:66,ENOLINK:67,EADV:68,ESRMNT:69,ECOMM:70,EPROTO:71,EMULTIHOP:72,EDOTDOT:73,EBADMSG:74,ENOTUNIQ:76,EBADFD:77,EREMCHG:78,ELIBACC:79,ELIBBAD:80,ELIBSCN:81,ELIBMAX:82,ELIBEXEC:83,ENOSYS:38,ENOTEMPTY:39,ENAMETOOLONG:36,ELOOP:40,EOPNOTSUPP:95,EPFNOSUPPORT:96,ECONNRESET:104,ENOBUFS:105,EAFNOSUPPORT:97,EPROTOTYPE:91,ENOTSOCK:88,ENOPROTOOPT:92,ESHUTDOWN:108,ECONNREFUSED:111,EADDRINUSE:98,ECONNABORTED:103,ENETUNREACH:101,ENETDOWN:100,ETIMEDOUT:110,EHOSTDOWN:112,EHOSTUNREACH:113,EINPROGRESS:115,EALREADY:114,EDESTADDRREQ:89,EMSGSIZE:90,EPROTONOSUPPORT:93,ESOCKTNOSUPPORT:94,EADDRNOTAVAIL:99,ENETRESET:102,EISCONN:106,ENOTCONN:107,ETOOMANYREFS:109,EUSERS:87,EDQUOT:122,ESTALE:116,ENOTSUP:95,ENOMEDIUM:123,EILSEQ:84,EOVERFLOW:75,ECANCELED:125,ENOTRECOVERABLE:131,EOWNERDEAD:130,ESTRPIPE:86};function _sysconf(name){switch(name){case 30:return PAGE_SIZE;case 85:return totalMemory/PAGE_SIZE;case 132:case 133:case 12:case 137:case 138:case 15:case 235:case 16:case 17:case 18:case 19:case 20:case 149:case 13:case 10:case 236:case 153:case 9:case 21:case 22:case 159:case 154:case 14:case 77:case 78:case 139:case 80:case 81:case 82:case 68:case 67:case 164:case 11:case 29:case 47:case 48:case 95:case 52:case 51:case 46:return 200809;case 79:return 0;case 27:case 246:case 127:case 128:case 23:case 24:case 160:case 161:case 181:case 182:case 242:case 183:case 184:case 243:case 244:case 245:case 165:case 178:case 179:case 49:case 50:case 168:case 169:case 175:case 170:case 171:case 172:case 97:case 76:case 32:case 173:case 35:return-1;case 176:case 177:case 7:case 155:case 8:case 157:case 125:case 126:case 92:case 93:case 129:case 130:case 131:case 94:case 91:return 1;case 74:case 60:case 69:case 70:case 4:return 1024;case 31:case 42:case 72:return 32;case 87:case 26:case 33:return 2147483647;case 34:case 1:return 47839;case 38:case 36:return 99;case 43:case 37:return 2048;case 0:return 2097152;case 3:return 65536;case 28:return 32768;case 44:return 32767;case 75:return 16384;case 39:return 1e3;case 89:return 700;case 71:return 256;case 40:return 255;case 2:return 100;case 180:return 64;case 25:return 20;case 5:return 16;case 6:return 6;case 73:return 4;case 84:{if(typeof navigator===\"object\")return navigator[\"hardwareConcurrency\"]||1;return 1}}___setErrNo(ERRNO_CODES.EINVAL);return-1}var _SItoD=true;function _pthread_cleanup_push(routine,arg){__ATEXIT__.push((function(){Runtime.dynCall(\"vi\",routine,[arg])}));_pthread_cleanup_push.level=__ATEXIT__.length}function __ZSt18uncaught_exceptionv(){return!!__ZSt18uncaught_exceptionv.uncaught_exception}var EXCEPTIONS={last:0,caught:[],infos:{},deAdjust:(function(adjusted){if(!adjusted||EXCEPTIONS.infos[adjusted])return adjusted;for(var ptr in EXCEPTIONS.infos){var info=EXCEPTIONS.infos[ptr];if(info.adjusted===adjusted){return ptr}}return adjusted}),addRef:(function(ptr){if(!ptr)return;var info=EXCEPTIONS.infos[ptr];info.refcount++}),decRef:(function(ptr){if(!ptr)return;var info=EXCEPTIONS.infos[ptr];assert(info.refcount>0);info.refcount--;if(info.refcount===0){if(info.destructor){Runtime.dynCall(\"vi\",info.destructor,[ptr])}delete EXCEPTIONS.infos[ptr];___cxa_free_exception(ptr)}}),clearRef:(function(ptr){if(!ptr)return;var info=EXCEPTIONS.infos[ptr];info.refcount=0})};function ___resumeException(ptr){if(!EXCEPTIONS.last){EXCEPTIONS.last=ptr}EXCEPTIONS.clearRef(EXCEPTIONS.deAdjust(ptr));throw ptr+\" - Exception catching is disabled, this exception cannot be caught. Compile with -s DISABLE_EXCEPTION_CATCHING=0 or DISABLE_EXCEPTION_CATCHING=2 to catch.\"}function ___cxa_find_matching_catch(){var thrown=EXCEPTIONS.last;if(!thrown){return(asm[\"setTempRet0\"](0),0)|0}var info=EXCEPTIONS.infos[thrown];var throwntype=info.type;if(!throwntype){return(asm[\"setTempRet0\"](0),thrown)|0}var typeArray=Array.prototype.slice.call(arguments);var pointer=Module[\"___cxa_is_pointer_type\"](throwntype);if(!___cxa_find_matching_catch.buffer)___cxa_find_matching_catch.buffer=_malloc(4);HEAP32[___cxa_find_matching_catch.buffer>>2]=thrown;thrown=___cxa_find_matching_catch.buffer;for(var i=0;i<typeArray.length;i++){if(typeArray[i]&&Module[\"___cxa_can_catch\"](typeArray[i],throwntype,thrown)){thrown=HEAP32[thrown>>2];info.adjusted=thrown;return(asm[\"setTempRet0\"](typeArray[i]),thrown)|0}}thrown=HEAP32[thrown>>2];return(asm[\"setTempRet0\"](throwntype),thrown)|0}function ___cxa_throw(ptr,type,destructor){EXCEPTIONS.infos[ptr]={ptr:ptr,adjusted:ptr,type:type,destructor:destructor,refcount:0};EXCEPTIONS.last=ptr;if(!(\"uncaught_exception\"in __ZSt18uncaught_exceptionv)){__ZSt18uncaught_exceptionv.uncaught_exception=1}else{__ZSt18uncaught_exceptionv.uncaught_exception++}throw ptr+\" - Exception catching is disabled, this exception cannot be caught. Compile with -s DISABLE_EXCEPTION_CATCHING=0 or DISABLE_EXCEPTION_CATCHING=2 to catch.\"}Module[\"_memset\"]=_memset;var _BDtoILow=true;Module[\"_bitshift64Lshr\"]=_bitshift64Lshr;Module[\"_bitshift64Shl\"]=_bitshift64Shl;function _pthread_cleanup_pop(){assert(_pthread_cleanup_push.level==__ATEXIT__.length,\"cannot pop if something else added meanwhile!\");__ATEXIT__.pop();_pthread_cleanup_push.level=__ATEXIT__.length}function _abort(){Module[\"abort\"]()}function ___assert_fail(condition,filename,line,func){ABORT=true;throw\"Assertion failed: \"+Pointer_stringify(condition)+\", at: \"+[filename?Pointer_stringify(filename):\"unknown filename\",line,func?Pointer_stringify(func):\"unknown function\"]+\" at \"+stackTrace()}var _tan=Math_tan;function _emscripten_memcpy_big(dest,src,num){HEAPU8.set(HEAPU8.subarray(src,src+num),dest);return dest}Module[\"_memcpy\"]=_memcpy;var SYSCALLS={varargs:0,get:(function(varargs){SYSCALLS.varargs+=4;var ret=HEAP32[SYSCALLS.varargs-4>>2];return ret}),getStr:(function(){var ret=Pointer_stringify(SYSCALLS.get());return ret}),get64:(function(){var low=SYSCALLS.get(),high=SYSCALLS.get();if(low>=0)assert(high===0);else assert(high===-1);return low}),getZero:(function(){assert(SYSCALLS.get()===0)})};function ___syscall6(which,varargs){SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD();FS.close(stream);return 0}catch(e){if(typeof FS===\"undefined\"||!(e instanceof FS.ErrnoError))abort(e);return-e.errno}}Module[\"_i64Add\"]=_i64Add;function _sbrk(bytes){var self=_sbrk;if(!self.called){DYNAMICTOP=alignMemoryPage(DYNAMICTOP);self.called=true;assert(Runtime.dynamicAlloc);self.alloc=Runtime.dynamicAlloc;Runtime.dynamicAlloc=(function(){abort(\"cannot dynamically allocate, sbrk now has control\")})}var ret=DYNAMICTOP;if(bytes!=0){var success=self.alloc(bytes);if(!success)return-1>>>0}return ret}Module[\"_memmove\"]=_memmove;function ___syscall146(which,varargs){SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.get(),iov=SYSCALLS.get(),iovcnt=SYSCALLS.get();var ret=0;if(!___syscall146.buffer)___syscall146.buffer=[];var buffer=___syscall146.buffer;for(var i=0;i<iovcnt;i++){var ptr=HEAP32[iov+i*8>>2];var len=HEAP32[iov+(i*8+4)>>2];for(var j=0;j<len;j++){var curr=HEAPU8[ptr+j];if(curr===0||curr===10){Module[\"print\"](UTF8ArrayToString(buffer,0));buffer.length=0}else{buffer.push(curr)}}ret+=len}return ret}catch(e){if(typeof FS===\"undefined\"||!(e instanceof FS.ErrnoError))abort(e);return-e.errno}}var _BItoD=true;var _sqrt=Math_sqrt;function ___syscall140(which,varargs){SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD(),offset_high=SYSCALLS.get(),offset_low=SYSCALLS.get(),result=SYSCALLS.get(),whence=SYSCALLS.get();var offset=offset_low;assert(offset_high===0);FS.llseek(stream,offset,whence);HEAP32[result>>2]=stream.position;if(stream.getdents&&offset===0&&whence===0)stream.getdents=null;return 0}catch(e){if(typeof FS===\"undefined\"||!(e instanceof FS.ErrnoError))abort(e);return-e.errno}}var PATH=undefined;function _emscripten_set_main_loop_timing(mode,value){Browser.mainLoop.timingMode=mode;Browser.mainLoop.timingValue=value;if(!Browser.mainLoop.func){return 1}if(mode==0){Browser.mainLoop.scheduler=function Browser_mainLoop_scheduler_setTimeout(){setTimeout(Browser.mainLoop.runner,value)};Browser.mainLoop.method=\"timeout\"}else if(mode==1){Browser.mainLoop.scheduler=function Browser_mainLoop_scheduler_rAF(){Browser.requestAnimationFrame(Browser.mainLoop.runner)};Browser.mainLoop.method=\"rAF\"}else if(mode==2){if(!window[\"setImmediate\"]){var setImmediates=[];var emscriptenMainLoopMessageId=\"__emcc\";function Browser_setImmediate_messageHandler(event){if(event.source===window&&event.data===emscriptenMainLoopMessageId){event.stopPropagation();setImmediates.shift()()}}window.addEventListener(\"message\",Browser_setImmediate_messageHandler,true);window[\"setImmediate\"]=function Browser_emulated_setImmediate(func){setImmediates.push(func);window.postMessage(emscriptenMainLoopMessageId,\"*\")}}Browser.mainLoop.scheduler=function Browser_mainLoop_scheduler_setImmediate(){window[\"setImmediate\"](Browser.mainLoop.runner)};Browser.mainLoop.method=\"immediate\"}return 0}function _emscripten_set_main_loop(func,fps,simulateInfiniteLoop,arg,noSetTiming){Module[\"noExitRuntime\"]=true;assert(!Browser.mainLoop.func,\"emscripten_set_main_loop: there can only be one main loop function at once: call emscripten_cancel_main_loop to cancel the previous one before setting a new one with different parameters.\");Browser.mainLoop.func=func;Browser.mainLoop.arg=arg;var thisMainLoopId=Browser.mainLoop.currentlyRunningMainloop;Browser.mainLoop.runner=function Browser_mainLoop_runner(){if(ABORT)return;if(Browser.mainLoop.queue.length>0){var start=Date.now();var blocker=Browser.mainLoop.queue.shift();blocker.func(blocker.arg);if(Browser.mainLoop.remainingBlockers){var remaining=Browser.mainLoop.remainingBlockers;var next=remaining%1==0?remaining-1:Math.floor(remaining);if(blocker.counted){Browser.mainLoop.remainingBlockers=next}else{next=next+.5;Browser.mainLoop.remainingBlockers=(8*remaining+next)/9}}console.log('main loop blocker \"'+blocker.name+'\" took '+(Date.now()-start)+\" ms\");Browser.mainLoop.updateStatus();setTimeout(Browser.mainLoop.runner,0);return}if(thisMainLoopId<Browser.mainLoop.currentlyRunningMainloop)return;Browser.mainLoop.currentFrameNumber=Browser.mainLoop.currentFrameNumber+1|0;if(Browser.mainLoop.timingMode==1&&Browser.mainLoop.timingValue>1&&Browser.mainLoop.currentFrameNumber%Browser.mainLoop.timingValue!=0){Browser.mainLoop.scheduler();return}if(Browser.mainLoop.method===\"timeout\"&&Module.ctx){Module.printErr(\"Looks like you are rendering without using requestAnimationFrame for the main loop. You should use 0 for the frame rate in emscripten_set_main_loop in order to use requestAnimationFrame, as that can greatly improve your frame rates!\");Browser.mainLoop.method=\"\"}Browser.mainLoop.runIter((function(){if(typeof arg!==\"undefined\"){Runtime.dynCall(\"vi\",func,[arg])}else{Runtime.dynCall(\"v\",func)}}));if(thisMainLoopId<Browser.mainLoop.currentlyRunningMainloop)return;if(typeof SDL===\"object\"&&SDL.audio&&SDL.audio.queueNewAudioData)SDL.audio.queueNewAudioData();Browser.mainLoop.scheduler()};if(!noSetTiming){if(fps&&fps>0)_emscripten_set_main_loop_timing(0,1e3/fps);else _emscripten_set_main_loop_timing(1,1);Browser.mainLoop.scheduler()}if(simulateInfiniteLoop){throw\"SimulateInfiniteLoop\"}}var Browser={mainLoop:{scheduler:null,method:\"\",currentlyRunningMainloop:0,func:null,arg:0,timingMode:0,timingValue:0,currentFrameNumber:0,queue:[],pause:(function(){Browser.mainLoop.scheduler=null;Browser.mainLoop.currentlyRunningMainloop++}),resume:(function(){Browser.mainLoop.currentlyRunningMainloop++;var timingMode=Browser.mainLoop.timingMode;var timingValue=Browser.mainLoop.timingValue;var func=Browser.mainLoop.func;Browser.mainLoop.func=null;_emscripten_set_main_loop(func,0,false,Browser.mainLoop.arg,true);_emscripten_set_main_loop_timing(timingMode,timingValue);Browser.mainLoop.scheduler()}),updateStatus:(function(){if(Module[\"setStatus\"]){var message=Module[\"statusMessage\"]||\"Please wait...\";var remaining=Browser.mainLoop.remainingBlockers;var expected=Browser.mainLoop.expectedBlockers;if(remaining){if(remaining<expected){Module[\"setStatus\"](message+\" (\"+(expected-remaining)+\"/\"+expected+\")\")}else{Module[\"setStatus\"](message)}}else{Module[\"setStatus\"](\"\")}}}),runIter:(function(func){if(ABORT)return;if(Module[\"preMainLoop\"]){var preRet=Module[\"preMainLoop\"]();if(preRet===false){return}}try{func()}catch(e){if(e instanceof ExitStatus){return}else{if(e&&typeof e===\"object\"&&e.stack)Module.printErr(\"exception thrown: \"+[e,e.stack]);throw e}}if(Module[\"postMainLoop\"])Module[\"postMainLoop\"]()})},isFullScreen:false,pointerLock:false,moduleContextCreatedCallbacks:[],workers:[],init:(function(){if(!Module[\"preloadPlugins\"])Module[\"preloadPlugins\"]=[];if(Browser.initted)return;Browser.initted=true;try{new Blob;Browser.hasBlobConstructor=true}catch(e){Browser.hasBlobConstructor=false;console.log(\"warning: no blob constructor, cannot create blobs with mimetypes\")}Browser.BlobBuilder=typeof MozBlobBuilder!=\"undefined\"?MozBlobBuilder:typeof WebKitBlobBuilder!=\"undefined\"?WebKitBlobBuilder:!Browser.hasBlobConstructor?console.log(\"warning: no BlobBuilder\"):null;Browser.URLObject=typeof window!=\"undefined\"?window.URL?window.URL:window.webkitURL:undefined;if(!Module.noImageDecoding&&typeof Browser.URLObject===\"undefined\"){console.log(\"warning: Browser does not support creating object URLs. Built-in browser image decoding will not be available.\");Module.noImageDecoding=true}var imagePlugin={};imagePlugin[\"canHandle\"]=function imagePlugin_canHandle(name){return!Module.noImageDecoding&&/\\.(jpg|jpeg|png|bmp)$/i.test(name)};imagePlugin[\"handle\"]=function imagePlugin_handle(byteArray,name,onload,onerror){var b=null;if(Browser.hasBlobConstructor){try{b=new Blob([byteArray],{type:Browser.getMimetype(name)});if(b.size!==byteArray.length){b=new Blob([(new Uint8Array(byteArray)).buffer],{type:Browser.getMimetype(name)})}}catch(e){Runtime.warnOnce(\"Blob constructor present but fails: \"+e+\"; falling back to blob builder\")}}if(!b){var bb=new Browser.BlobBuilder;bb.append((new Uint8Array(byteArray)).buffer);b=bb.getBlob()}var url=Browser.URLObject.createObjectURL(b);var img=new Image;img.onload=function img_onload(){assert(img.complete,\"Image \"+name+\" could not be decoded\");var canvas=document.createElement(\"canvas\");canvas.width=img.width;canvas.height=img.height;var ctx=canvas.getContext(\"2d\");ctx.drawImage(img,0,0);Module[\"preloadedImages\"][name]=canvas;Browser.URLObject.revokeObjectURL(url);if(onload)onload(byteArray)};img.onerror=function img_onerror(event){console.log(\"Image \"+url+\" could not be decoded\");if(onerror)onerror()};img.src=url};Module[\"preloadPlugins\"].push(imagePlugin);var audioPlugin={};audioPlugin[\"canHandle\"]=function audioPlugin_canHandle(name){return!Module.noAudioDecoding&&name.substr(-4)in{\".ogg\":1,\".wav\":1,\".mp3\":1}};audioPlugin[\"handle\"]=function audioPlugin_handle(byteArray,name,onload,onerror){var done=false;function finish(audio){if(done)return;done=true;Module[\"preloadedAudios\"][name]=audio;if(onload)onload(byteArray)}function fail(){if(done)return;done=true;Module[\"preloadedAudios\"][name]=new Audio;if(onerror)onerror()}if(Browser.hasBlobConstructor){try{var b=new Blob([byteArray],{type:Browser.getMimetype(name)})}catch(e){return fail()}var url=Browser.URLObject.createObjectURL(b);var audio=new Audio;audio.addEventListener(\"canplaythrough\",(function(){finish(audio)}),false);audio.onerror=function audio_onerror(event){if(done)return;console.log(\"warning: browser could not fully decode audio \"+name+\", trying slower base64 approach\");function encode64(data){var BASE=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";var PAD=\"=\";var ret=\"\";var leftchar=0;var leftbits=0;for(var i=0;i<data.length;i++){leftchar=leftchar<<8|data[i];leftbits+=8;while(leftbits>=6){var curr=leftchar>>leftbits-6&63;leftbits-=6;ret+=BASE[curr]}}if(leftbits==2){ret+=BASE[(leftchar&3)<<4];ret+=PAD+PAD}else if(leftbits==4){ret+=BASE[(leftchar&15)<<2];ret+=PAD}return ret}audio.src=\"data:audio/x-\"+name.substr(-3)+\";base64,\"+encode64(byteArray);finish(audio)};audio.src=url;Browser.safeSetTimeout((function(){finish(audio)}),1e4)}else{return fail()}};Module[\"preloadPlugins\"].push(audioPlugin);var canvas=Module[\"canvas\"];function pointerLockChange(){Browser.pointerLock=document[\"pointerLockElement\"]===canvas||document[\"mozPointerLockElement\"]===canvas||document[\"webkitPointerLockElement\"]===canvas||document[\"msPointerLockElement\"]===canvas}if(canvas){canvas.requestPointerLock=canvas[\"requestPointerLock\"]||canvas[\"mozRequestPointerLock\"]||canvas[\"webkitRequestPointerLock\"]||canvas[\"msRequestPointerLock\"]||(function(){});canvas.exitPointerLock=document[\"exitPointerLock\"]||document[\"mozExitPointerLock\"]||document[\"webkitExitPointerLock\"]||document[\"msExitPointerLock\"]||(function(){});canvas.exitPointerLock=canvas.exitPointerLock.bind(document);document.addEventListener(\"pointerlockchange\",pointerLockChange,false);document.addEventListener(\"mozpointerlockchange\",pointerLockChange,false);document.addEventListener(\"webkitpointerlockchange\",pointerLockChange,false);document.addEventListener(\"mspointerlockchange\",pointerLockChange,false);if(Module[\"elementPointerLock\"]){canvas.addEventListener(\"click\",(function(ev){if(!Browser.pointerLock&&canvas.requestPointerLock){canvas.requestPointerLock();ev.preventDefault()}}),false)}}}),createContext:(function(canvas,useWebGL,setInModule,webGLContextAttributes){if(useWebGL&&Module.ctx&&canvas==Module.canvas)return Module.ctx;var ctx;var contextHandle;if(useWebGL){var contextAttributes={antialias:false,alpha:false};if(webGLContextAttributes){for(var attribute in webGLContextAttributes){contextAttributes[attribute]=webGLContextAttributes[attribute]}}contextHandle=GL.createContext(canvas,contextAttributes);if(contextHandle){ctx=GL.getContext(contextHandle).GLctx}canvas.style.backgroundColor=\"black\"}else{ctx=canvas.getContext(\"2d\")}if(!ctx)return null;if(setInModule){if(!useWebGL)assert(typeof GLctx===\"undefined\",\"cannot set in module if GLctx is used, but we are a non-GL context that would replace it\");Module.ctx=ctx;if(useWebGL)GL.makeContextCurrent(contextHandle);Module.useWebGL=useWebGL;Browser.moduleContextCreatedCallbacks.forEach((function(callback){callback()}));Browser.init()}return ctx}),destroyContext:(function(canvas,useWebGL,setInModule){}),fullScreenHandlersInstalled:false,lockPointer:undefined,resizeCanvas:undefined,requestFullScreen:(function(lockPointer,resizeCanvas,vrDevice){Browser.lockPointer=lockPointer;Browser.resizeCanvas=resizeCanvas;Browser.vrDevice=vrDevice;if(typeof Browser.lockPointer===\"undefined\")Browser.lockPointer=true;if(typeof Browser.resizeCanvas===\"undefined\")Browser.resizeCanvas=false;if(typeof Browser.vrDevice===\"undefined\")Browser.vrDevice=null;var canvas=Module[\"canvas\"];function fullScreenChange(){Browser.isFullScreen=false;var canvasContainer=canvas.parentNode;if((document[\"webkitFullScreenElement\"]||document[\"webkitFullscreenElement\"]||document[\"mozFullScreenElement\"]||document[\"mozFullscreenElement\"]||document[\"fullScreenElement\"]||document[\"fullscreenElement\"]||document[\"msFullScreenElement\"]||document[\"msFullscreenElement\"]||document[\"webkitCurrentFullScreenElement\"])===canvasContainer){canvas.cancelFullScreen=document[\"cancelFullScreen\"]||document[\"mozCancelFullScreen\"]||document[\"webkitCancelFullScreen\"]||document[\"msExitFullscreen\"]||document[\"exitFullscreen\"]||(function(){});canvas.cancelFullScreen=canvas.cancelFullScreen.bind(document);if(Browser.lockPointer)canvas.requestPointerLock();Browser.isFullScreen=true;if(Browser.resizeCanvas)Browser.setFullScreenCanvasSize()}else{canvasContainer.parentNode.insertBefore(canvas,canvasContainer);canvasContainer.parentNode.removeChild(canvasContainer);if(Browser.resizeCanvas)Browser.setWindowedCanvasSize()}if(Module[\"onFullScreen\"])Module[\"onFullScreen\"](Browser.isFullScreen);Browser.updateCanvasDimensions(canvas)}if(!Browser.fullScreenHandlersInstalled){Browser.fullScreenHandlersInstalled=true;document.addEventListener(\"fullscreenchange\",fullScreenChange,false);document.addEventListener(\"mozfullscreenchange\",fullScreenChange,false);document.addEventListener(\"webkitfullscreenchange\",fullScreenChange,false);document.addEventListener(\"MSFullscreenChange\",fullScreenChange,false)}var canvasContainer=document.createElement(\"div\");canvas.parentNode.insertBefore(canvasContainer,canvas);canvasContainer.appendChild(canvas);canvasContainer.requestFullScreen=canvasContainer[\"requestFullScreen\"]||canvasContainer[\"mozRequestFullScreen\"]||canvasContainer[\"msRequestFullscreen\"]||(canvasContainer[\"webkitRequestFullScreen\"]?(function(){canvasContainer[\"webkitRequestFullScreen\"](Element[\"ALLOW_KEYBOARD_INPUT\"])}):null);if(vrDevice){canvasContainer.requestFullScreen({vrDisplay:vrDevice})}else{canvasContainer.requestFullScreen()}}),nextRAF:0,fakeRequestAnimationFrame:(function(func){var now=Date.now();if(Browser.nextRAF===0){Browser.nextRAF=now+1e3/60}else{while(now+2>=Browser.nextRAF){Browser.nextRAF+=1e3/60}}var delay=Math.max(Browser.nextRAF-now,0);setTimeout(func,delay)}),requestAnimationFrame:function requestAnimationFrame(func){if(typeof window===\"undefined\"){Browser.fakeRequestAnimationFrame(func)}else{if(!window.requestAnimationFrame){window.requestAnimationFrame=window[\"requestAnimationFrame\"]||window[\"mozRequestAnimationFrame\"]||window[\"webkitRequestAnimationFrame\"]||window[\"msRequestAnimationFrame\"]||window[\"oRequestAnimationFrame\"]||Browser.fakeRequestAnimationFrame}window.requestAnimationFrame(func)}},safeCallback:(function(func){return(function(){if(!ABORT)return func.apply(null,arguments)})}),allowAsyncCallbacks:true,queuedAsyncCallbacks:[],pauseAsyncCallbacks:(function(){Browser.allowAsyncCallbacks=false}),resumeAsyncCallbacks:(function(){Browser.allowAsyncCallbacks=true;if(Browser.queuedAsyncCallbacks.length>0){var callbacks=Browser.queuedAsyncCallbacks;Browser.queuedAsyncCallbacks=[];callbacks.forEach((function(func){func()}))}}),safeRequestAnimationFrame:(function(func){return Browser.requestAnimationFrame((function(){if(ABORT)return;if(Browser.allowAsyncCallbacks){func()}else{Browser.queuedAsyncCallbacks.push(func)}}))}),safeSetTimeout:(function(func,timeout){Module[\"noExitRuntime\"]=true;return setTimeout((function(){if(ABORT)return;if(Browser.allowAsyncCallbacks){func()}else{Browser.queuedAsyncCallbacks.push(func)}}),timeout)}),safeSetInterval:(function(func,timeout){Module[\"noExitRuntime\"]=true;return setInterval((function(){if(ABORT)return;if(Browser.allowAsyncCallbacks){func()}}),timeout)}),getMimetype:(function(name){return{\"jpg\":\"image/jpeg\",\"jpeg\":\"image/jpeg\",\"png\":\"image/png\",\"bmp\":\"image/bmp\",\"ogg\":\"audio/ogg\",\"wav\":\"audio/wav\",\"mp3\":\"audio/mpeg\"}[name.substr(name.lastIndexOf(\".\")+1)]}),getUserMedia:(function(func){if(!window.getUserMedia){window.getUserMedia=navigator[\"getUserMedia\"]||navigator[\"mozGetUserMedia\"]}window.getUserMedia(func)}),getMovementX:(function(event){return event[\"movementX\"]||event[\"mozMovementX\"]||event[\"webkitMovementX\"]||0}),getMovementY:(function(event){return event[\"movementY\"]||event[\"mozMovementY\"]||event[\"webkitMovementY\"]||0}),getMouseWheelDelta:(function(event){var delta=0;switch(event.type){case\"DOMMouseScroll\":delta=event.detail;break;case\"mousewheel\":delta=event.wheelDelta;break;case\"wheel\":delta=event[\"deltaY\"];break;default:throw\"unrecognized mouse wheel event: \"+event.type}return delta}),mouseX:0,mouseY:0,mouseMovementX:0,mouseMovementY:0,touches:{},lastTouches:{},calculateMouseEvent:(function(event){if(Browser.pointerLock){if(event.type!=\"mousemove\"&&\"mozMovementX\"in event){Browser.mouseMovementX=Browser.mouseMovementY=0}else{Browser.mouseMovementX=Browser.getMovementX(event);Browser.mouseMovementY=Browser.getMovementY(event)}if(typeof SDL!=\"undefined\"){Browser.mouseX=SDL.mouseX+Browser.mouseMovementX;Browser.mouseY=SDL.mouseY+Browser.mouseMovementY}else{Browser.mouseX+=Browser.mouseMovementX;Browser.mouseY+=Browser.mouseMovementY}}else{var rect=Module[\"canvas\"].getBoundingClientRect();var cw=Module[\"canvas\"].width;var ch=Module[\"canvas\"].height;var scrollX=typeof window.scrollX!==\"undefined\"?window.scrollX:window.pageXOffset;var scrollY=typeof window.scrollY!==\"undefined\"?window.scrollY:window.pageYOffset;if(event.type===\"touchstart\"||event.type===\"touchend\"||event.type===\"touchmove\"){var touch=event.touch;if(touch===undefined){return}var adjustedX=touch.pageX-(scrollX+rect.left);var adjustedY=touch.pageY-(scrollY+rect.top);adjustedX=adjustedX*(cw/rect.width);adjustedY=adjustedY*(ch/rect.height);var coords={x:adjustedX,y:adjustedY};if(event.type===\"touchstart\"){Browser.lastTouches[touch.identifier]=coords;Browser.touches[touch.identifier]=coords}else if(event.type===\"touchend\"||event.type===\"touchmove\"){var last=Browser.touches[touch.identifier];if(!last)last=coords;Browser.lastTouches[touch.identifier]=last;Browser.touches[touch.identifier]=coords}return}var x=event.pageX-(scrollX+rect.left);var y=event.pageY-(scrollY+rect.top);x=x*(cw/rect.width);y=y*(ch/rect.height);Browser.mouseMovementX=x-Browser.mouseX;Browser.mouseMovementY=y-Browser.mouseY;Browser.mouseX=x;Browser.mouseY=y}}),xhrLoad:(function(url,onload,onerror){var xhr=new XMLHttpRequest;xhr.open(\"GET\",url,true);xhr.responseType=\"arraybuffer\";xhr.onload=function xhr_onload(){if(xhr.status==200||xhr.status==0&&xhr.response){onload(xhr.response)}else{onerror()}};xhr.onerror=onerror;xhr.send(null)}),asyncLoad:(function(url,onload,onerror,noRunDep){Browser.xhrLoad(url,(function(arrayBuffer){assert(arrayBuffer,'Loading data file \"'+url+'\" failed (no arrayBuffer).');onload(new Uint8Array(arrayBuffer));if(!noRunDep)removeRunDependency(\"al \"+url)}),(function(event){if(onerror){onerror()}else{throw'Loading data file \"'+url+'\" failed.'}}));if(!noRunDep)addRunDependency(\"al \"+url)}),resizeListeners:[],updateResizeListeners:(function(){var canvas=Module[\"canvas\"];Browser.resizeListeners.forEach((function(listener){listener(canvas.width,canvas.height)}))}),setCanvasSize:(function(width,height,noUpdates){var canvas=Module[\"canvas\"];Browser.updateCanvasDimensions(canvas,width,height);if(!noUpdates)Browser.updateResizeListeners()}),windowedWidth:0,windowedHeight:0,setFullScreenCanvasSize:(function(){if(typeof SDL!=\"undefined\"){var flags=HEAPU32[SDL.screen+Runtime.QUANTUM_SIZE*0>>2];flags=flags|8388608;HEAP32[SDL.screen+Runtime.QUANTUM_SIZE*0>>2]=flags}Browser.updateResizeListeners()}),setWindowedCanvasSize:(function(){if(typeof SDL!=\"undefined\"){var flags=HEAPU32[SDL.screen+Runtime.QUANTUM_SIZE*0>>2];flags=flags&~8388608;HEAP32[SDL.screen+Runtime.QUANTUM_SIZE*0>>2]=flags}Browser.updateResizeListeners()}),updateCanvasDimensions:(function(canvas,wNative,hNative){if(wNative&&hNative){canvas.widthNative=wNative;canvas.heightNative=hNative}else{wNative=canvas.widthNative;hNative=canvas.heightNative}var w=wNative;var h=hNative;if(Module[\"forcedAspectRatio\"]&&Module[\"forcedAspectRatio\"]>0){if(w/h<Module[\"forcedAspectRatio\"]){w=Math.round(h*Module[\"forcedAspectRatio\"])}else{h=Math.round(w/Module[\"forcedAspectRatio\"])}}if((document[\"webkitFullScreenElement\"]||document[\"webkitFullscreenElement\"]||document[\"mozFullScreenElement\"]||document[\"mozFullscreenElement\"]||document[\"fullScreenElement\"]||document[\"fullscreenElement\"]||document[\"msFullScreenElement\"]||document[\"msFullscreenElement\"]||document[\"webkitCurrentFullScreenElement\"])===canvas.parentNode&&typeof screen!=\"undefined\"){var factor=Math.min(screen.width/w,screen.height/h);w=Math.round(w*factor);h=Math.round(h*factor)}if(Browser.resizeCanvas){if(canvas.width!=w)canvas.width=w;if(canvas.height!=h)canvas.height=h;if(typeof canvas.style!=\"undefined\"){canvas.style.removeProperty(\"width\");canvas.style.removeProperty(\"height\")}}else{if(canvas.width!=wNative)canvas.width=wNative;if(canvas.height!=hNative)canvas.height=hNative;if(typeof canvas.style!=\"undefined\"){if(w!=wNative||h!=hNative){canvas.style.setProperty(\"width\",w+\"px\",\"important\");canvas.style.setProperty(\"height\",h+\"px\",\"important\")}else{canvas.style.removeProperty(\"width\");canvas.style.removeProperty(\"height\")}}}}),wgetRequests:{},nextWgetRequestHandle:0,getNextWgetRequestHandle:(function(){var handle=Browser.nextWgetRequestHandle;Browser.nextWgetRequestHandle++;return handle})};function _time(ptr){var ret=Date.now()/1e3|0;if(ptr){HEAP32[ptr>>2]=ret}return ret}function _pthread_self(){return 0}var _UItoD=true;function _malloc(bytes){var ptr=Runtime.dynamicAlloc(bytes+8);return ptr+8&4294967288}Module[\"_malloc\"]=_malloc;function ___cxa_allocate_exception(size){return _malloc(size)}function ___syscall54(which,varargs){SYSCALLS.varargs=varargs;try{return 0}catch(e){if(typeof FS===\"undefined\"||!(e instanceof FS.ErrnoError))abort(e);return-e.errno}}Module[\"requestFullScreen\"]=function Module_requestFullScreen(lockPointer,resizeCanvas,vrDevice){Browser.requestFullScreen(lockPointer,resizeCanvas,vrDevice)};Module[\"requestAnimationFrame\"]=function Module_requestAnimationFrame(func){Browser.requestAnimationFrame(func)};Module[\"setCanvasSize\"]=function Module_setCanvasSize(width,height,noUpdates){Browser.setCanvasSize(width,height,noUpdates)};Module[\"pauseMainLoop\"]=function Module_pauseMainLoop(){Browser.mainLoop.pause()};Module[\"resumeMainLoop\"]=function Module_resumeMainLoop(){Browser.mainLoop.resume()};Module[\"getUserMedia\"]=function Module_getUserMedia(){Browser.getUserMedia()};Module[\"createContext\"]=function Module_createContext(canvas,useWebGL,setInModule,webGLContextAttributes){return Browser.createContext(canvas,useWebGL,setInModule,webGLContextAttributes)};STACK_BASE=STACKTOP=Runtime.alignMemory(STATICTOP);staticSealed=true;STACK_MAX=STACK_BASE+TOTAL_STACK;DYNAMIC_BASE=DYNAMICTOP=Runtime.alignMemory(STACK_MAX);assert(DYNAMIC_BASE<TOTAL_MEMORY,\"TOTAL_MEMORY not big enough for stack\");var cttz_i8=allocate([8,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,7,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0],\"i8\",ALLOC_DYNAMIC);function invoke_iiii(index,a1,a2,a3){try{return Module[\"dynCall_iiii\"](index,a1,a2,a3)}catch(e){if(typeof e!==\"number\"&&e!==\"longjmp\")throw e;asm[\"setThrew\"](1,0)}}function invoke_viiiii(index,a1,a2,a3,a4,a5){try{Module[\"dynCall_viiiii\"](index,a1,a2,a3,a4,a5)}catch(e){if(typeof e!==\"number\"&&e!==\"longjmp\")throw e;asm[\"setThrew\"](1,0)}}function invoke_vi(index,a1){try{Module[\"dynCall_vi\"](index,a1)}catch(e){if(typeof e!==\"number\"&&e!==\"longjmp\")throw e;asm[\"setThrew\"](1,0)}}function invoke_ii(index,a1){try{return Module[\"dynCall_ii\"](index,a1)}catch(e){if(typeof e!==\"number\"&&e!==\"longjmp\")throw e;asm[\"setThrew\"](1,0)}}function invoke_v(index){try{Module[\"dynCall_v\"](index)}catch(e){if(typeof e!==\"number\"&&e!==\"longjmp\")throw e;asm[\"setThrew\"](1,0)}}function invoke_viiiiii(index,a1,a2,a3,a4,a5,a6){try{Module[\"dynCall_viiiiii\"](index,a1,a2,a3,a4,a5,a6)}catch(e){if(typeof e!==\"number\"&&e!==\"longjmp\")throw e;asm[\"setThrew\"](1,0)}}function invoke_iii(index,a1,a2){try{return Module[\"dynCall_iii\"](index,a1,a2)}catch(e){if(typeof e!==\"number\"&&e!==\"longjmp\")throw e;asm[\"setThrew\"](1,0)}}function invoke_viiii(index,a1,a2,a3,a4){try{Module[\"dynCall_viiii\"](index,a1,a2,a3,a4)}catch(e){if(typeof e!==\"number\"&&e!==\"longjmp\")throw e;asm[\"setThrew\"](1,0)}}Module.asmGlobalArg={\"Math\":Math,\"Int8Array\":Int8Array,\"Int16Array\":Int16Array,\"Int32Array\":Int32Array,\"Uint8Array\":Uint8Array,\"Uint16Array\":Uint16Array,\"Uint32Array\":Uint32Array,\"Float32Array\":Float32Array,\"Float64Array\":Float64Array,\"NaN\":NaN,\"Infinity\":Infinity,\"byteLength\":byteLength};Module.asmLibraryArg={\"abort\":abort,\"assert\":assert,\"invoke_iiii\":invoke_iiii,\"invoke_viiiii\":invoke_viiiii,\"invoke_vi\":invoke_vi,\"invoke_ii\":invoke_ii,\"invoke_v\":invoke_v,\"invoke_viiiiii\":invoke_viiiiii,\"invoke_iii\":invoke_iii,\"invoke_viiii\":invoke_viiii,\"_pthread_cleanup_pop\":_pthread_cleanup_pop,\"___syscall6\":___syscall6,\"___setErrNo\":___setErrNo,\"___assert_fail\":___assert_fail,\"___cxa_allocate_exception\":___cxa_allocate_exception,\"___cxa_find_matching_catch\":___cxa_find_matching_catch,\"_emscripten_set_main_loop_timing\":_emscripten_set_main_loop_timing,\"_sbrk\":_sbrk,\"_emscripten_memcpy_big\":_emscripten_memcpy_big,\"___resumeException\":___resumeException,\"__ZSt18uncaught_exceptionv\":__ZSt18uncaught_exceptionv,\"_sysconf\":_sysconf,\"_pthread_self\":_pthread_self,\"___syscall140\":___syscall140,\"___syscall54\":___syscall54,\"_emscripten_set_main_loop\":_emscripten_set_main_loop,\"_tan\":_tan,\"___cxa_throw\":___cxa_throw,\"_abort\":_abort,\"_pthread_cleanup_push\":_pthread_cleanup_push,\"_time\":_time,\"_sqrt\":_sqrt,\"___syscall146\":___syscall146,\"STACKTOP\":STACKTOP,\"STACK_MAX\":STACK_MAX,\"tempDoublePtr\":tempDoublePtr,\"ABORT\":ABORT,\"cttz_i8\":cttz_i8};// EMSCRIPTEN_START_ASM\r\nvar asm=(function(global,env,buffer) {\r\n\"use asm\";var a=global.Int8Array;var b=global.Int16Array;var c=global.Int32Array;var d=global.Uint8Array;var e=global.Uint16Array;var f=global.Uint32Array;var g=global.Float32Array;var h=global.Float64Array;var i=new a(buffer);var j=new b(buffer);var k=new c(buffer);var l=new d(buffer);var m=new e(buffer);var n=new f(buffer);var o=new g(buffer);var p=new h(buffer);var q=global.byteLength;var r=env.STACKTOP|0;var s=env.STACK_MAX|0;var t=env.tempDoublePtr|0;var u=env.ABORT|0;var v=env.cttz_i8|0;var w=0;var x=0;var y=0;var z=0;var A=global.NaN,B=global.Infinity;var C=0,D=0,E=0,F=0,G=0.0,H=0,I=0,J=0,K=0.0;var L=0;var M=0;var N=0;var O=0;var P=0;var Q=0;var R=0;var S=0;var T=0;var U=0;var V=global.Math.floor;var W=global.Math.abs;var X=global.Math.sqrt;var Y=global.Math.pow;var Z=global.Math.cos;var _=global.Math.sin;var $=global.Math.tan;var aa=global.Math.acos;var ba=global.Math.asin;var ca=global.Math.atan;var da=global.Math.atan2;var ea=global.Math.exp;var fa=global.Math.log;var ga=global.Math.ceil;var ha=global.Math.imul;var ia=global.Math.min;var ja=global.Math.clz32;var ka=env.abort;var la=env.assert;var ma=env.invoke_iiii;var na=env.invoke_viiiii;var oa=env.invoke_vi;var pa=env.invoke_ii;var qa=env.invoke_v;var ra=env.invoke_viiiiii;var sa=env.invoke_iii;var ta=env.invoke_viiii;var ua=env._pthread_cleanup_pop;var va=env.___syscall6;var wa=env.___setErrNo;var xa=env.___assert_fail;var ya=env.___cxa_allocate_exception;var za=env.___cxa_find_matching_catch;var Aa=env._emscripten_set_main_loop_timing;var Ba=env._sbrk;var Ca=env._emscripten_memcpy_big;var Da=env.___resumeException;var Ea=env.__ZSt18uncaught_exceptionv;var Fa=env._sysconf;var Ga=env._pthread_self;var Ha=env.___syscall140;var Ia=env.___syscall54;var Ja=env._emscripten_set_main_loop;var Ka=env._tan;var La=env.___cxa_throw;var Ma=env._abort;var Na=env._pthread_cleanup_push;var Oa=env._time;var Pa=env._sqrt;var Qa=env.___syscall146;var Ra=0.0;function Sa(newBuffer){if(q(newBuffer)&16777215||q(newBuffer)<=16777215||q(newBuffer)>2147483648)return false;i=new a(newBuffer);j=new b(newBuffer);k=new c(newBuffer);l=new d(newBuffer);m=new e(newBuffer);n=new f(newBuffer);o=new g(newBuffer);p=new h(newBuffer);buffer=newBuffer;return true}\r\n// EMSCRIPTEN_START_FUNCS\r\nfunction mc(a,b,c){a=a|0;b=b|0;c=+c;var d=0,e=0,f=0,g=0,h=0.0,l=0.0,m=0.0,n=0,o=0,q=0,s=0.0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,M=0.0,N=0.0,O=0.0,P=0.0,Q=0,R=0.0,S=0,T=0,U=0,V=0,W=0,Y=0,Z=0,_=0,aa=0.0,ba=0,ca=0,da=0,ea=0,fa=0,ga=0,ha=0,ia=0,ja=0,ka=0,la=0,ma=0,na=0,oa=0,pa=0,qa=0,ra=0,sa=0,ta=0,ua=0,va=0,wa=0,za=0,Aa=0;Aa=r;r=r+2992|0;oa=Aa+192|0;ua=Aa+184|0;ma=Aa+168|0;la=Aa+160|0;ea=Aa+136|0;ja=Aa+120|0;fa=Aa+64|0;_=Aa+32|0;Q=Aa;wa=Aa+2964|0;va=Aa+2920|0;ra=Aa+220|0;ha=Aa+2960|0;sa=Aa+2976|0;k[wa>>2]=0;za=wa+4|0;k[za>>2]=0;k[wa+8>>2]=0;d=k[b>>2]|0;ba=b+4|0;w=k[ba>>2]|0;if((d|0)!=(w|0)){x=wa+8|0;do{v=d+4|0;f=k[d>>2]|0;e=(k[v>>2]|0)-f>>3;if(e){q=0;do{u=q;q=q+1|0;o=f+(u<<3)|0;do if(q>>>0<e>>>0){e=f+(q<<3)|0;n=k[za>>2]|0;if(n>>>0<(k[x>>2]|0)>>>0){k[n>>2]=0;k[n+4>>2]=0;k[n+8>>2]=0;k[n+12>>2]=0;k[n>>2]=k[o>>2];k[n+4>>2]=k[f+(u<<3)+4>>2];k[n+8>>2]=k[e>>2];k[n+12>>2]=k[f+(q<<3)+4>>2];k[za>>2]=n+16;break}else{yc(wa,o,e);break}}else{e=k[za>>2]|0;if(e>>>0<(k[x>>2]|0)>>>0){k[e>>2]=0;k[e+4>>2]=0;k[e+8>>2]=0;k[e+12>>2]=0;k[e>>2]=k[o>>2];k[e+4>>2]=k[f+(u<<3)+4>>2];k[e+8>>2]=k[f>>2];k[e+12>>2]=k[f+4>>2];k[za>>2]=e+16;break}else{yc(wa,o,f);break}}while(0);f=k[d>>2]|0;e=(k[v>>2]|0)-f>>3}while(q>>>0<e>>>0)}d=d+12|0}while((d|0)!=(w|0))}n=(k[87]|0)>-1;a:do if(!1){d=1021;na=16}else{e=1021;d=1021;while(1){if(!(i[e>>0]|0))break a;e=e+1|0;d=e;if(!(d&3)){d=e;na=16;break}}}while(0);if((na|0)==16){while(1){e=k[d>>2]|0;if(!((e&-2139062144^-2139062144)&e+-16843009))d=d+4|0;else break}if((e&255)<<24>>24)do d=d+1|0;while((i[d>>0]|0)!=0)}f=d-1021|0;d=k[72]|0;e=(d|0)==0;b:do if(n){do if(e){d=i[346]|0;i[346]=d+255|d;d=k[68]|0;if(!(d&8)){k[70]=0;k[69]=0;e=k[79]|0;k[75]=e;k[73]=e;d=e+(k[80]|0)|0;k[72]=d;break}else{k[68]=d|32;d=0;na=38;break b}}else e=k[73]|0;while(0);if((d-e|0)>>>0<f>>>0){d=Ta[k[308>>2]&7](272,1021,f)|0;na=38;break}else{fe(e|0,1021,f|0)|0;k[73]=(k[73]|0)+f;na=40;break}}else{do if(e){d=i[346]|0;i[346]=d+255|d;d=k[68]|0;if(!(d&8)){k[70]=0;k[69]=0;e=k[79]|0;k[75]=e;k[73]=e;d=e+(k[80]|0)|0;k[72]=d;break}else{k[68]=d|32;d=0;na=38;break b}}else e=k[73]|0;while(0);if((d-e|0)>>>0<f>>>0){d=Ta[k[308>>2]&7](272,1021,f)|0;na=38;break}else{fe(e|0,1021,f|0)|0;k[73]=(k[73]|0)+f;na=40;break}}while(0);if((na|0)==38)if(!((d|0)!=(f|0)?((d>>>0)/(f>>>0)|0|0)<1:0))na=40;do if((na|0)==40){f=i[347]|0;if(f<<24>>24!=10){d=k[73]|0;e=k[72]|0;if(d>>>0<e>>>0){k[73]=d+1;i[d>>0]=10;break}}else e=k[72]|0;i[oa>>0]=10;do if(!e){f=j[173]|0;d=(f&65535)<<24>>24;i[346]=d+255|d;d=k[68]|0;if(!(d&8)){k[70]=0;k[69]=0;n=k[79]|0;k[75]=n;k[73]=n;e=n+(k[80]|0)|0;k[72]=e;d=(f&65535)>>>8&255;na=49;break}else{k[68]=d|32;break}}else{n=k[73]|0;d=f;na=49}while(0);do if((na|0)==49)if(n>>>0>=e>>>0|d<<24>>24==10){Ta[k[308>>2]&7](272,oa,1)|0;break}else{k[73]=n+1;i[n>>0]=10;break}while(0)}while(0);o=va;q=o+36|0;do{k[o>>2]=0;o=o+4|0}while((o|0)<(q|0));S=ra+4|0;k[S>>2]=0;U=ra+8|0;k[U>>2]=0;k[ra+12>>2]=0;V=ra+20|0;k[V>>2]=0;k[V+4>>2]=0;k[V+8>>2]=0;i[V+12>>0]=0;V=ra+36|0;k[V>>2]=0;k[V+4>>2]=0;k[V+8>>2]=0;j[V+12>>1]=0;V=ra+52|0;k[V>>2]=V;k[ra+56>>2]=V;V=ra+60|0;k[V>>2]=0;W=ra+64|0;i[oa>>0]=0;i[oa+1>>0]=0;i[oa+2>>0]=0;T=ra+68|0;k[T>>2]=0;Y=ra+72|0;k[Y>>2]=0;Z=ra+76|0;i[Z>>0]=i[oa>>0]|0;i[Z+1>>0]=i[oa+1>>0]|0;i[Z+2>>0]=i[oa+2>>0]|0;Z=ra+68|0;k[W>>2]=Z;v=ra+2696|0;k[v>>2]=0;d=k[wa>>2]|0;w=k[za>>2]|0;c:do if((d|0)!=(w|0)){x=ra+4|0;y=oa+8|0;z=oa+16|0;A=oa+24|0;B=ra+12|0;C=fa+8|0;D=fa+16|0;E=fa+24|0;F=_+8|0;G=_+16|0;H=_+24|0;I=Q+8|0;J=Q+16|0;K=Q+24|0;e=0;f=0;while(1){n=k[d>>2]|0;o=k[d+4>>2]|0;q=k[d+8>>2]|0;u=k[d+12>>2]|0;na=oa;k[na>>2]=n;k[na+4>>2]=o;na=y;k[na>>2]=n;k[na+4>>2]=o;k[z>>2]=0;k[A>>2]=0;if(e>>>0<f>>>0){k[e>>2]=k[oa>>2];k[e+4>>2]=k[oa+4>>2];k[e+8>>2]=k[oa+8>>2];k[e+12>>2]=k[oa+12>>2];k[e+16>>2]=k[oa+16>>2];k[e+20>>2]=k[oa+20>>2];k[e+24>>2]=k[oa+24>>2];e=(k[U>>2]|0)+28|0;k[U>>2]=e}else{pd(x,oa);e=k[U>>2]|0}k[e+-8>>2]=k[v>>2];na=e+-4|0;k[na>>2]=k[na>>2]|1;na=fa;k[na>>2]=q;k[na+4>>2]=u;na=C;k[na>>2]=q;k[na+4>>2]=u;k[D>>2]=0;k[E>>2]=0;if(e>>>0<(k[B>>2]|0)>>>0){k[e>>2]=k[fa>>2];k[e+4>>2]=k[fa+4>>2];k[e+8>>2]=k[fa+8>>2];k[e+12>>2]=k[fa+12>>2];k[e+16>>2]=k[fa+16>>2];k[e+20>>2]=k[fa+20>>2];k[e+24>>2]=k[fa+24>>2];e=(k[U>>2]|0)+28|0;k[U>>2]=e}else{pd(x,fa);e=k[U>>2]|0}k[e+-8>>2]=k[v>>2];na=e+-4|0;k[na>>2]=k[na>>2]|2;if((n|0)==(q|0))if((o|0)<(u|0))na=64;else na=68;else if((n|0)<(q|0))na=64;else na=68;if((na|0)==64){na=0;f=_;k[f>>2]=n;k[f+4>>2]=o;o=F;k[o>>2]=q;k[o+4>>2]=u;k[G>>2]=0;k[H>>2]=0;if(e>>>0<(k[B>>2]|0)>>>0){k[e>>2]=k[_>>2];k[e+4>>2]=k[_+4>>2];k[e+8>>2]=k[_+8>>2];k[e+12>>2]=k[_+12>>2];k[e+16>>2]=k[_+16>>2];k[e+20>>2]=k[_+20>>2];k[e+24>>2]=k[_+24>>2];e=(k[U>>2]|0)+28|0;k[U>>2]=e}else{pd(x,_);e=k[U>>2]|0}u=e+-4|0;k[u>>2]=k[u>>2]|8}else if((na|0)==68){na=0;f=Q;k[f>>2]=q;k[f+4>>2]=u;u=I;k[u>>2]=n;k[u+4>>2]=o;k[J>>2]=0;k[K>>2]=0;if(e>>>0<(k[B>>2]|0)>>>0){k[e>>2]=k[Q>>2];k[e+4>>2]=k[Q+4>>2];k[e+8>>2]=k[Q+8>>2];k[e+12>>2]=k[Q+12>>2];k[e+16>>2]=k[Q+16>>2];k[e+20>>2]=k[Q+20>>2];k[e+24>>2]=k[Q+24>>2];e=(k[U>>2]|0)+28|0;k[U>>2]=e}else{pd(x,Q);e=k[U>>2]|0}u=e+-4|0;k[u>>2]=k[u>>2]|9}u=k[v>>2]|0;k[e+-8>>2]=u;k[v>>2]=u+1;d=d+16|0;if((d|0)==(w|0))break c;f=k[B>>2]|0}}while(0);n=(k[87]|0)>-1;d:do if(!3){d=1023;na=77}else{e=1023;d=1023;while(1){if(!(i[e>>0]|0))break d;e=e+1|0;d=e;if(!(d&3)){d=e;na=77;break}}}while(0);if((na|0)==77){while(1){e=k[d>>2]|0;if(!((e&-2139062144^-2139062144)&e+-16843009))d=d+4|0;else break}if((e&255)<<24>>24)do d=d+1|0;while((i[d>>0]|0)!=0)}f=d-1023|0;d=k[72]|0;e=(d|0)==0;e:do if(n){do if(e){d=i[346]|0;i[346]=d+255|d;d=k[68]|0;if(!(d&8)){k[70]=0;k[69]=0;e=k[79]|0;k[75]=e;k[73]=e;d=e+(k[80]|0)|0;k[72]=d;break}else{k[68]=d|32;d=0;na=99;break e}}else e=k[73]|0;while(0);if((d-e|0)>>>0<f>>>0){d=Ta[k[308>>2]&7](272,1023,f)|0;na=99;break}else{fe(e|0,1023,f|0)|0;k[73]=(k[73]|0)+f;na=101;break}}else{do if(e){d=i[346]|0;i[346]=d+255|d;d=k[68]|0;if(!(d&8)){k[70]=0;k[69]=0;e=k[79]|0;k[75]=e;k[73]=e;d=e+(k[80]|0)|0;k[72]=d;break}else{k[68]=d|32;d=0;na=99;break e}}else e=k[73]|0;while(0);if((d-e|0)>>>0<f>>>0){d=Ta[k[308>>2]&7](272,1023,f)|0;na=99;break}else{fe(e|0,1023,f|0)|0;k[73]=(k[73]|0)+f;na=101;break}}while(0);if((na|0)==99)if(!((d|0)!=(f|0)?((d>>>0)/(f>>>0)|0|0)<1:0))na=101;do if((na|0)==101){f=i[347]|0;if(f<<24>>24!=10){d=k[73]|0;e=k[72]|0;if(d>>>0<e>>>0){k[73]=d+1;i[d>>0]=10;break}}else e=k[72]|0;i[oa>>0]=10;do if(!e){f=j[173]|0;d=(f&65535)<<24>>24;i[346]=d+255|d;d=k[68]|0;if(!(d&8)){k[70]=0;k[69]=0;n=k[79]|0;k[75]=n;k[73]=n;e=n+(k[80]|0)|0;k[72]=e;d=(f&65535)>>>8&255;na=110;break}else{k[68]=d|32;break}}else{n=k[73]|0;d=f;na=110}while(0);do if((na|0)==110)if(n>>>0>=e>>>0|d<<24>>24==10){Ta[k[308>>2]&7](272,oa,1)|0;break}else{k[73]=n+1;i[n>>0]=10;break}while(0)}while(0);x=k[U>>2]|0;y=k[S>>2]|0;z=(x-y|0)/28|0;A=va+8|0;o=k[va>>2]|0;d=o;if((((k[A>>2]|0)-d|0)/12|0)>>>0<z>>>0){q=va+4|0;f=(k[q>>2]|0)-d|0;n=(f|0)/12|0;if((x|0)==(y|0))d=0;else{e=z*12|0;d=_d(e)|0;f:do if(!d){while(1){d=k[35]|0;k[35]=d+0;if(!d)break;Xa[d&0]();d=_d(e)|0;if(d)break f}Aa=ya(4)|0;k[Aa>>2]=128;La(Aa|0,8,1)}while(0)}Q=d+((((f|0)/-12|0)+n|0)*12|0)|0;fe(Q|0,o|0,f|0)|0;k[va>>2]=Q;k[q>>2]=d+(n*12|0);k[A>>2]=d+(z*12|0);if(o)$d(o)}o=va+12|0;q=z<<1;u=va+20|0;v=k[o>>2]|0;d=v;if((((k[u>>2]|0)-d|0)/24|0)>>>0<q>>>0){w=va+16|0;f=(k[w>>2]|0)-d|0;n=(f|0)/24|0;if((x|0)==(y|0))d=0;else{e=z*48|0;e=(e|0)==0?1:e;d=_d(e)|0;g:do if(!d){while(1){d=k[35]|0;k[35]=d+0;if(!d)break;Xa[d&0]();d=_d(e)|0;if(d)break g}Aa=ya(4)|0;k[Aa>>2]=128;La(Aa|0,8,1)}while(0)}Q=d+((((f|0)/-24|0)+n|0)*24|0)|0;fe(Q|0,v|0,f|0)|0;k[o>>2]=Q;k[w>>2]=d+(n*24|0);k[u>>2]=d+(q*24|0);if(v)$d(v)}o=va+24|0;q=z*6|0;u=va+32|0;v=k[o>>2]|0;d=v;if((((k[u>>2]|0)-d|0)/24|0)>>>0<q>>>0){w=va+28|0;f=(k[w>>2]|0)-d|0;n=(f|0)/24|0;if((x|0)==(y|0))d=0;else{e=z*144|0;e=(e|0)==0?1:e;d=_d(e)|0;h:do if(!d){while(1){d=k[35]|0;k[35]=d+0;if(!d)break;Xa[d&0]();d=_d(e)|0;if(d)break h}Aa=ya(4)|0;k[Aa>>2]=128;La(Aa|0,8,1)}while(0)}Q=d+((((f|0)/-24|0)+n|0)*24|0)|0;fe(Q|0,v|0,f|0)|0;k[o>>2]=Q;k[w>>2]=d+(n*24|0);k[u>>2]=d+(q*24|0);if(v)$d(v)}kd(k[S>>2]|0,k[U>>2]|0);n=k[S>>2]|0;d=k[U>>2]|0;i:do if((n|0)!=(d|0)){e=n+28|0;if((e|0)!=(d|0)){f=n;while(1){if((((k[f>>2]|0)==(k[f+28>>2]|0)?(k[f+4>>2]|0)==(k[f+32>>2]|0):0)?(k[f+8>>2]|0)==(k[f+36>>2]|0):0)?(k[f+12>>2]|0)==(k[f+40>>2]|0):0){na=148;break i}f=e+28|0;if((f|0)==(d|0))break;else{Q=e;e=f;f=Q}}}}else{f=n;na=148}while(0);if((na|0)==148)if((f|0)!=(d|0)){e=f+56|0;if((e|0)==(d|0))e=n;else{n=f;f=f+28|0;while(1){if((((k[n>>2]|0)==(k[e>>2]|0)?(k[n+4>>2]|0)==(k[f+32>>2]|0):0)?(k[n+8>>2]|0)==(k[f+36>>2]|0):0)?(k[n+12>>2]|0)==(k[f+40>>2]|0):0)f=n;else{f=n+28|0;k[f>>2]=k[e>>2];k[f+4>>2]=k[e+4>>2];k[f+8>>2]=k[e+8>>2];k[f+12>>2]=k[e+12>>2];k[f+16>>2]=k[e+16>>2];k[f+20>>2]=k[e+20>>2];k[f+24>>2]=k[e+24>>2]}n=e+28|0;if((n|0)==(d|0))break;else{Q=e;e=n;n=f;f=Q}}d=k[U>>2]|0;e=k[S>>2]|0}n=f+28|0;o=n;if((n|0)!=(d|0)){e=e+((((d-o|0)/28|0)+((o-e|0)/28|0)|0)*28|0)|0;d=d-e|0;he(n|0,e|0,d|0)|0;d=f+((((d|0)/28|0)+1|0)*28|0)|0;e=k[U>>2]|0;if((e|0)!=(d|0)){d=e+(~(((e+-28-d|0)>>>0)/28|0)*28|0)|0;k[U>>2]=d}}}o=k[S>>2]|0;e=o;if((d|0)!=(o|0)){f=(d-e|0)/28|0;n=0;do{k[o+(n*28|0)+16>>2]=n;n=n+1|0}while(n>>>0<f>>>0)}k[ra+16>>2]=e;do if((o|0)==(d|0)){u=ra+16|0;d=o}else{if((d-e|0)==28){d=k[o+24>>2]&31;k[oa>>2]=k[o+20>>2];k[oa+4>>2]=0;k[oa+8>>2]=d;d=va+4|0;e=k[d>>2]|0;if(e>>>0<(k[A>>2]|0)>>>0){k[e>>2]=k[oa>>2];k[e+4>>2]=k[oa+4>>2];k[e+8>>2]=k[oa+8>>2];k[d>>2]=(k[d>>2]|0)+12}else gd(va,oa);u=ra+16|0;d=(k[u>>2]|0)+28|0;k[u>>2]=d;break}x=ra+16|0;if((o|0)!=(d|0)){f=k[o>>2]|0;n=o;e=0;do{if((k[n>>2]|0)!=(f|0)){d=n;break}if((f|0)!=(k[n+8>>2]|0)){d=n;break}n=n+28|0;k[x>>2]=n;e=e+1|0}while((n|0)!=(d|0));if((e|0)==1){k[fa>>2]=Z;k[oa>>2]=k[fa>>2];dd(ra,o,o,o+28|0,oa,va)|0;d=(k[x>>2]|0)+28|0;k[x>>2]=d;u=x;break}else e=d}else e=d;d=o+28|0;j:do if((d|0)==(e|0))d=e;else{w=fa+28|0;v=o;k:while(1){k[fa>>2]=k[v>>2];k[fa+4>>2]=k[v+4>>2];k[fa+8>>2]=k[v+8>>2];k[fa+12>>2]=k[v+12>>2];k[fa+16>>2]=k[v+16>>2];k[fa+20>>2]=k[v+20>>2];k[fa+24>>2]=k[v+24>>2];k[w>>2]=k[d>>2];k[w+4>>2]=k[d+4>>2];k[w+8>>2]=k[d+8>>2];k[w+12>>2]=k[d+12>>2];k[w+16>>2]=k[d+16>>2];k[w+20>>2]=k[d+20>>2];k[w+24>>2]=k[d+24>>2];ed(_,va,v,d);u=k[_>>2]|0;e=_d(80)|0;if(!e)do{e=k[35]|0;k[35]=e+0;if(!e)break k;Xa[e&0]();e=_d(80)|0}while((e|0)==0);f=e+16|0;o=f;n=fa;q=o+56|0;do{k[o>>2]=k[n>>2];o=o+4|0;n=n+4|0}while((o|0)<(q|0));n=e+72|0;k[n>>2]=0;k[n+4>>2]=u;n=fd(W,Z,oa,f)|0;f=k[n>>2]|0;do if(!f){f=k[oa>>2]|0;k[e>>2]=0;k[e+4>>2]=0;k[e+8>>2]=f;k[n>>2]=e;f=k[k[W>>2]>>2]|0;if(f){k[W>>2]=f;e=k[n>>2]|0}Nb(k[T>>2]|0,e);k[Y>>2]=(k[Y>>2]|0)+1}else{if((f|0)==(e|0))break;$d(e)}while(0);d=d+28|0;if((d|0)==(k[x>>2]|0))break j;else v=v+28|0}Aa=ya(4)|0;k[Aa>>2]=128;La(Aa|0,8,1)}while(0);u=x}while(0);o=ra+36|0;q=ra+40|0;n=k[o>>2]|0;e=k[q>>2]|0;l:while(1){f=(d|0)==(k[U>>2]|0);do if((n|0)!=(e|0)){if(f){Kc(ra,va);break}I=(k[n>>2]|0)+24|0;K=k[I>>2]|0;I=k[I+4>>2]|0;p[t>>3]=+(k[d>>2]|0);J=k[t>>2]|0;H=k[t+4>>2]|0;S=(H|0)>-1|(H|0)==-1&J>>>0>4294967295;Q=be(0,-2147483648,J|0,H|0)|0;J=S?Q:J;H=S?L:H;S=(I|0)>-1|(I|0)==-1&K>>>0>4294967295;Q=be(0,-2147483648,K|0,I|0)|0;K=S?Q:K;I=S?L:I;S=be(J|0,H|0,K|0,I|0)|0;Q=L;_=be(K|0,I|0,J|0,H|0)|0;T=L;if(((H>>>0>I>>>0|(H|0)==(I|0)&J>>>0>K>>>0?(Q>>>0>0|(Q|0)==0&S>>>0>64)<<31>>31:(T>>>0>0|(T|0)==0&_>>>0>64)&1)|0)==-1){Jc(ra,va);break}else{Kc(ra,va);break}}else{if(f)break l;Jc(ra,va)}while(0);d=k[o>>2]|0;e=k[q>>2]|0;m:do if((d|0)==(e|0))e=d;else while(1){n=k[d>>2]|0;if(i[n+32>>0]|0)break m;f=e-d|0;if((f|0)>4){_=e+-4|0;k[d>>2]=k[_>>2];k[_>>2]=n;Lc(d,(f>>2)+-1|0,d);d=k[q>>2]|0}else d=e;k[q>>2]=d+-4;d=n+4|0;e=k[n>>2]|0;k[e+4>>2]=k[d>>2];k[k[d>>2]>>2]=e;k[V>>2]=(k[V>>2]|0)+-1;$d(n);d=k[o>>2]|0;e=k[q>>2]|0;if((d|0)==(e|0)){e=d;break}}while(0);n=d;d=k[u>>2]|0}Cc(k[Z>>2]|0);k[Y>>2]=0;k[W>>2]=Z;k[Z>>2]=0;Y=va+24|0;e=k[Y>>2]|0;f=e;Z=va+28|0;d=k[Z>>2]|0;if((e|0)==(d|0)){n=f;d=e;f=e}else{n=f;v=f;while(1){f=k[e+4>>2]|0;u=k[e+8>>2]|0;o=k[u+4>>2]|0;q=f;if(((f|0)!=0&(o|0)!=0?(K=f,S=k[K>>2]|0,K=k[K+4>>2]|0,Q=o,T=k[Q>>2]|0,Q=k[Q+4>>2]|0,V=(K|0)>-1|(K|0)==-1&S>>>0>4294967295,U=be(0,-2147483648,S|0,K|0)|0,S=V?U:S,K=V?L:K,V=(Q|0)>-1|(Q|0)==-1&T>>>0>4294967295,U=be(0,-2147483648,T|0,Q|0)|0,T=V?U:T,Q=V?L:Q,V=be(S|0,K|0,T|0,Q|0)|0,U=L,_=be(T|0,Q|0,S|0,K|0)|0,W=L,((K>>>0>Q>>>0|(K|0)==(Q|0)&S>>>0>T>>>0?(U>>>0>0|(U|0)==0&V>>>0>128)<<31>>31:(W>>>0>0|(W|0)==0&_>>>0>128)&1)|0)==0):0)?(K=f+8|0,S=k[K>>2]|0,K=k[K+4>>2]|0,Q=o+8|0,T=k[Q>>2]|0,Q=k[Q+4>>2]|0,V=(K|0)>-1|(K|0)==-1&S>>>0>4294967295,U=be(0,-2147483648,S|0,K|0)|0,S=V?U:S,K=V?L:K,V=(Q|0)>-1|(Q|0)==-1&T>>>0>4294967295,U=be(0,-2147483648,T|0,Q|0)|0,T=V?U:T,Q=V?L:Q,V=be(S|0,K|0,T|0,Q|0)|0,U=L,_=be(T|0,Q|0,S|0,K|0)|0,W=L,((K>>>0>Q>>>0|(K|0)==(Q|0)&S>>>0>T>>>0?(U>>>0>0|(U|0)==0&V>>>0>128)<<31>>31:(W>>>0>0|(W|0)==0&_>>>0>128)&1)|0)==0):0){f=k[(k[u+16>>2]|0)+8>>2]|0;if((f|0)==(u|0))f=u;else{o=f;do{k[o+4>>2]=q;o=k[(k[o+16>>2]|0)+8>>2]|0}while((o|0)!=(u|0))}W=k[u+12>>2]|0;_=k[(k[u+8>>2]|0)+12>>2]|0;V=k[(k[(k[e+16>>2]|0)+8>>2]|0)+8>>2]|0;k[V+12>>2]=_;k[_+16>>2]=V;_=k[f+8>>2]|0;k[W+16>>2]=_;k[_+12>>2]=W}else{o=n;do if((e|0)!=(o|0)){f=n;d=v;k[f>>2]=k[d>>2];k[f+4>>2]=k[d+4>>2];k[f+8>>2]=k[d+8>>2];k[f+12>>2]=k[d+12>>2];k[f+16>>2]=k[d+16>>2];k[f+20>>2]=k[d+20>>2];f=o+24|0;d=e+24|0;k[f>>2]=k[d>>2];k[f+4>>2]=k[d+4>>2];k[f+8>>2]=k[d+8>>2];k[f+12>>2]=k[d+12>>2];k[f+16>>2]=k[d+16>>2];k[f+20>>2]=k[d+20>>2];k[o+8>>2]=f;k[o+32>>2]=o;d=k[o+16>>2]|0;if(d){k[d+12>>2]=o;k[(k[o+36>>2]|0)+16>>2]=f}d=o+40|0;if(!(k[d>>2]|0))break;k[(k[o+12>>2]|0)+16>>2]=o;k[(k[d>>2]|0)+12>>2]=f}while(0);n=o+48|0;d=k[Z>>2]|0}f=v+48|0;if((f|0)==(d|0))break;else{e=f;v=f}}f=k[Y>>2]|0}e=n;if((e|0)!=(d|0)){_=f+((((d-n|0)/24|0)+((n-f|0)/24|0)|0)*24|0)|0;d=d-_|0;he(n|0,_|0,d|0)|0;d=e+(((d|0)/24|0)*24|0)|0;e=k[Z>>2]|0;if((e|0)!=(d|0)){d=e+(~(((e+-24-d|0)>>>0)/24|0)*24|0)|0;k[Z>>2]=d}}e=k[Y>>2]|0;if((e|0)!=(d|0))do{k[(k[e>>2]|0)+4>>2]=e;f=k[e+4>>2]|0;if(f)k[f+16>>2]=e;e=e+24|0}while((e|0)!=(d|0));V=va+12|0;f=k[V>>2]|0;e=f;W=va+16|0;d=k[W>>2]|0;if((f|0)==(d|0)){d=f;n=f}else{n=f;do{if(k[n+16>>2]|0){f=e;if((n|0)!=(f|0)){d=e;k[d>>2]=k[n>>2];k[d+4>>2]=k[n+4>>2];k[d+8>>2]=k[n+8>>2];k[d+12>>2]=k[n+12>>2];k[d+16>>2]=k[n+16>>2];k[d+20>>2]=k[n+20>>2];d=k[f+16>>2]|0;e=d;do{k[e+4>>2]=f;e=k[(k[e+16>>2]|0)+8>>2]|0}while((e|0)!=(d|0))}e=f+24|0;d=k[W>>2]|0}n=n+24|0}while((n|0)!=(d|0));n=k[V>>2]|0}f=e;if((f|0)!=(d|0)){_=n+((((d-e|0)/24|0)+((e-n|0)/24|0)|0)*24|0)|0;d=d-_|0;he(e|0,_|0,d|0)|0;d=f+(((d|0)/24|0)*24|0)|0;e=k[W>>2]|0;if((e|0)!=(d|0)){d=e+(~(((e+-24-d|0)>>>0)/24|0)*24|0)|0;k[W>>2]=d}}if((k[V>>2]|0)==(d|0)){w=k[Y>>2]|0;e=w;q=k[Z>>2]|0;if((w|0)!=(q|0)){k[w+12>>2]=w;k[w+16>>2]=w;d=w+24|0;n=w+48|0;f=w+36|0;if((n|0)==(q|0))e=w;else{u=(((q+-96-e|0)>>>0)/48|0)<<1;v=u+3|0;o=w+(v*24|0)+12|0;e=w;while(1){k[f>>2]=n;k[e+40>>2]=n;k[e+60>>2]=d;k[e+64>>2]=d;d=n+48|0;if((d|0)==(q|0))break;else{_=n;n=d;f=e+84|0;d=e+72|0;e=_}}f=o;e=w+((u+2|0)*24|0)|0;d=w+(v*24|0)|0}k[f>>2]=d;k[e+40>>2]=d}}else{d=k[va>>2]|0;q=k[va+4>>2]|0;if((d|0)!=(q|0))do{n=k[d+4>>2]|0;do if(n){e=n;while(1){f=e;e=k[e+16>>2]|0;if(!e)break;if((e|0)==(n|0)){na=251;break}}if((na|0)==251){na=0;if(!(k[n+16>>2]|0))f=n;else break}while(1){e=n+12|0;o=k[e>>2]|0;if(!o)break;else n=o}k[f+16>>2]=n;k[e>>2]=f}while(0);d=d+12|0}while((d|0)!=(q|0))}k[ha>>2]=0;n=(k[87]|0)>-1;n:do if(!1){d=1025;na=259}else{e=1025;d=1025;while(1){if(!(i[e>>0]|0))break n;e=e+1|0;d=e;if(!(d&3)){d=e;na=259;break}}}while(0);if((na|0)==259){while(1){e=k[d>>2]|0;if(!((e&-2139062144^-2139062144)&e+-16843009))d=d+4|0;else break}if((e&255)<<24>>24)do d=d+1|0;while((i[d>>0]|0)!=0)}f=d-1025|0;d=k[72]|0;e=(d|0)==0;o:do if(n){do if(e){d=i[346]|0;i[346]=d+255|d;d=k[68]|0;if(!(d&8)){k[70]=0;k[69]=0;e=k[79]|0;k[75]=e;k[73]=e;d=e+(k[80]|0)|0;k[72]=d;break}else{k[68]=d|32;d=0;na=281;break o}}else e=k[73]|0;while(0);if((d-e|0)>>>0<f>>>0){d=Ta[k[308>>2]&7](272,1025,f)|0;na=281;break}else{fe(e|0,1025,f|0)|0;k[73]=(k[73]|0)+f;na=283;break}}else{do if(e){d=i[346]|0;i[346]=d+255|d;d=k[68]|0;if(!(d&8)){k[70]=0;k[69]=0;e=k[79]|0;k[75]=e;k[73]=e;d=e+(k[80]|0)|0;k[72]=d;break}else{k[68]=d|32;d=0;na=281;break o}}else e=k[73]|0;while(0);if((d-e|0)>>>0<f>>>0){d=Ta[k[308>>2]&7](272,1025,f)|0;na=281;break}else{fe(e|0,1025,f|0)|0;k[73]=(k[73]|0)+f;na=283;break}}while(0);do if((na|0)==281){if((d|0)==(f|0)){na=283;break}if(((d>>>0)/(f>>>0)|0|0)>=1)na=283}while(0);p:do if((na|0)==283){f=i[347]|0;do if(f<<24>>24==10)e=k[72]|0;else{d=k[73]|0;e=k[72]|0;if(d>>>0>=e>>>0)break;k[73]=d+1;i[d>>0]=10;break p}while(0);i[oa>>0]=10;do if(!e){f=j[173]|0;d=(f&65535)<<24>>24;i[346]=d+255|d;d=k[68]|0;if(!(d&8)){k[70]=0;k[69]=0;n=k[79]|0;k[75]=n;k[73]=n;e=n+(k[80]|0)|0;k[72]=e;d=(f&65535)>>>8&255;na=292;break}else{k[68]=d|32;break}}else{n=k[73]|0;d=f;na=292}while(0);do if((na|0)==292)if(n>>>0>=e>>>0|d<<24>>24==10){Ta[k[308>>2]&7](272,oa,1)|0;break}else{k[73]=n+1;i[n>>0]=10;break}while(0)}while(0);d=k[b>>2]|0;G=k[ba>>2]|0;q:do if(d>>>0<G>>>0){f=0;e=0;r:while(1){F=k[d>>2]|0;E=F;F=(k[d+4>>2]|0)-F>>3;if(F){D=0;do{q=D;D=D+1|0;C=D>>>0<F>>>0;v=C?E+(D<<3)|0:E;o=k[E+(q<<3)>>2]|0;q=k[E+(q<<3)+4>>2]|0;n=k[v>>2]|0;v=k[v+4>>2]|0;do if((o|0)!=(n|0)|(q|0)!=(v|0)){do if((o|0)<=(n|0)){if((o|0)!=(n|0)){u=o;w=q;o=v;v=1;na=302;break}if((q|0)<=(v|0)){u=o;n=o;o=v;v=1;na=303}else{u=n;w=v;n=o;o=q;v=-1;na=302}}else{u=n;w=v;n=o;o=q;v=-1;na=302}while(0);if((na|0)==302){na=0;if((u|0)==(n|0)){q=w;na=303}else{q=w;B=o}}if((na|0)==303){na=0;B=o;v=0-v|0}o=e;w=k[ha>>2]|0;if(o>>>0<w>>>0){i[o>>0]=0;i[o+1>>0]=0;i[o+2>>0]=0;k[o+4>>2]=0;k[o+8>>2]=0;k[o+12>>2]=0;k[o+16>>2]=u;k[o+20>>2]=q;k[o+24>>2]=0;k[o+28>>2]=n;k[o+32>>2]=B;k[o+36>>2]=0;k[o+40>>2]=v;e=o+44|0;break}A=f;z=e-f|0;y=(z|0)/44|0;x=y+1|0;if(x>>>0>97612893){na=308;break r}e=(w-f|0)/44|0;if(e>>>0<48806446){e=e<<1;e=e>>>0<x>>>0?x:e;if(!e){w=0;o=0}else na=311}else{e=97612893;na=311}if((na|0)==311){na=0;w=e*44|0;w=(w|0)==0?1:w;o=_d(w)|0;if(!o)do{o=k[35]|0;k[35]=o+0;if(!o){na=314;break r}Xa[o&0]();o=_d(w)|0}while((o|0)==0);w=e}e=o+(y*44|0)|0;i[e>>0]=0;i[e+1>>0]=0;i[e+2>>0]=0;k[e+4>>2]=0;k[e+8>>2]=0;k[e+12>>2]=0;k[e+16>>2]=u;k[e+20>>2]=q;k[e+24>>2]=0;k[e+28>>2]=n;k[e+32>>2]=B;k[e+36>>2]=0;k[e+40>>2]=v;e=o+(x*44|0)|0;ba=o+((((z|0)/-44|0)+y|0)*44|0)|0;n=ba;fe(ba|0,A|0,z|0)|0;k[ha>>2]=o+(w*44|0);if(!f){f=n;break}$d(A);f=n}while(0)}while(C)}d=d+12|0;if(d>>>0>=G>>>0){g=f;ca=e;break q}}if((na|0)==308)xa(1340,1363,303,1438);else if((na|0)==314){Aa=ya(4)|0;k[Aa>>2]=128;La(Aa|0,8,1)}}else{g=0;ca=0}while(0);n=(k[87]|0)>-1;s:do if(!3){d=1027;na=322}else{e=1027;d=1027;while(1){if(!(i[e>>0]|0))break s;e=e+1|0;d=e;if(!(d&3)){d=e;na=322;break}}}while(0);if((na|0)==322){while(1){e=k[d>>2]|0;if(!((e&-2139062144^-2139062144)&e+-16843009))d=d+4|0;else break}if((e&255)<<24>>24)do d=d+1|0;while((i[d>>0]|0)!=0)}f=d-1027|0;d=k[72]|0;e=(d|0)==0;t:do if(n){do if(e){d=i[346]|0;i[346]=d+255|d;d=k[68]|0;if(!(d&8)){k[70]=0;k[69]=0;e=k[79]|0;k[75]=e;k[73]=e;d=e+(k[80]|0)|0;k[72]=d;break}else{k[68]=d|32;d=0;na=344;break t}}else e=k[73]|0;while(0);if((d-e|0)>>>0<f>>>0){d=Ta[k[308>>2]&7](272,1027,f)|0;na=344;break}else{fe(e|0,1027,f|0)|0;k[73]=(k[73]|0)+f;na=346;break}}else{do if(e){d=i[346]|0;i[346]=d+255|d;d=k[68]|0;if(!(d&8)){k[70]=0;k[69]=0;e=k[79]|0;k[75]=e;k[73]=e;d=e+(k[80]|0)|0;k[72]=d;break}else{k[68]=d|32;d=0;na=344;break t}}else e=k[73]|0;while(0);if((d-e|0)>>>0<f>>>0){d=Ta[k[308>>2]&7](272,1027,f)|0;na=344;break}else{fe(e|0,1027,f|0)|0;k[73]=(k[73]|0)+f;na=346;break}}while(0);do if((na|0)==344){if((d|0)==(f|0)){na=346;break}if(((d>>>0)/(f>>>0)|0|0)>=1)na=346}while(0);u:do if((na|0)==346){f=i[347]|0;do if(f<<24>>24==10)e=k[72]|0;else{d=k[73]|0;e=k[72]|0;if(d>>>0>=e>>>0)break;k[73]=d+1;i[d>>0]=10;break u}while(0);i[oa>>0]=10;do if(!e){f=j[173]|0;d=(f&65535)<<24>>24;i[346]=d+255|d;d=k[68]|0;if(!(d&8)){k[70]=0;k[69]=0;n=k[79]|0;k[75]=n;k[73]=n;e=n+(k[80]|0)|0;k[72]=e;d=(f&65535)>>>8&255;na=355;break}else{k[68]=d|32;break}}else{n=k[73]|0;d=f;na=355}while(0);do if((na|0)==355)if(n>>>0>=e>>>0|d<<24>>24==10){Ta[k[308>>2]&7](272,oa,1)|0;break}else{k[73]=n+1;i[n>>0]=10;break}while(0)}while(0);d=g;if((ca|0)!=(d|0)){e=(ca-g|0)/44|0;f=0;do{i[d+(f*44|0)>>0]=1;f=f+1|0}while(f>>>0<e>>>0)}d=k[Y>>2]|0;e=k[Z>>2]|0;if((d|0)!=(e|0)){f=d;do{ba=f+20|0;k[ba>>2]=k[ba>>2]&31;f=f+24|0}while((f|0)!=(e|0))}k[ja>>2]=(e-d|0)/24|0;Nd(1029,ja);e=k[Z>>2]|0;d=k[Y>>2]|0;v:do if((e|0)!=(d|0)){f=ca;D=0;w:while(1){n=d+(D*24|0)+20|0;o=k[n>>2]|0;do if(o&2){u=k[d+(D*24|0)+4>>2]|0;if(!u)break;q=k[d+(D*24|0)+8>>2]|0;v=k[q+4>>2]|0;if(!((v|0)!=0&(o&32|0)==0))break;k[n>>2]=o&31|32;d=q+20|0;k[d>>2]=k[d>>2]&31|32;h=+p[u>>3];p[t>>3]=h;d=k[t+4>>2]|0;e=de(k[t>>2]|0,d|0,52)|0;e=e&2047;do if(e>>>0<=1074){d=(d|0)<0;m=d?-h:h;if(e>>>0<1022){h=h*0.0;break}l=m+4503599627370496.0+-4503599627370496.0-m;do if(l>.5)h=m+l+-1.0;else{h=m+l;if(!(l<=-.5))break;h=h+1.0}while(0);h=d?-h:h}while(0);C=~~h;h=+p[u+8>>3];p[t>>3]=h;d=k[t+4>>2]|0;e=de(k[t>>2]|0,d|0,52)|0;e=e&2047;do if(e>>>0<=1074){d=(d|0)<0;m=d?-h:h;if(e>>>0<1022){h=h*0.0;break}l=m+4503599627370496.0+-4503599627370496.0-m;do if(l>.5)h=m+l+-1.0;else{h=m+l;if(!(l<=-.5))break;h=h+1.0}while(0);h=d?-h:h}while(0);B=~~h;h=+p[v>>3];p[t>>3]=h;d=k[t+4>>2]|0;e=de(k[t>>2]|0,d|0,52)|0;e=e&2047;do if(e>>>0<=1074){d=(d|0)<0;m=d?-h:h;if(e>>>0<1022){h=h*0.0;break}l=m+4503599627370496.0+-4503599627370496.0-m;do if(l>.5)h=m+l+-1.0;else{h=m+l;if(!(l<=-.5))break;h=h+1.0}while(0);h=d?-h:h}while(0);e=~~h;h=+p[v+8>>3];p[t>>3]=h;d=k[t+4>>2]|0;n=de(k[t>>2]|0,d|0,52)|0;n=n&2047;do if(n>>>0<=1074){d=(d|0)<0;m=d?-h:h;if(n>>>0<1022){h=h*0.0;break}l=m+4503599627370496.0+-4503599627370496.0-m;do if(l>.5)h=m+l+-1.0;else{h=m+l;if(!(l<=-.5))break;h=h+1.0}while(0);h=d?-h:h}while(0);y=~~h;u=f;d=k[ha>>2]|0;do if(u>>>0<d>>>0){i[u>>0]=0;i[u+1>>0]=0;i[u+2>>0]=0;k[u+4>>2]=0;k[u+8>>2]=0;k[u+12>>2]=0;d=u+16|0;f=u+16|0;k[f>>2]=C;k[u+20>>2]=B;k[u+24>>2]=0;n=u+28|0;o=u+28|0;k[o>>2]=e;k[u+32>>2]=y;k[u+36>>2]=0;q=u+40|0;k[q>>2]=1;do if((C|0)<=(e|0)){if((C|0)!=(e|0)){f=C;d=1;na=406;break}if((B|0)<=(y|0)){d=1;na=407}else na=405}else na=405;while(0);if((na|0)==405){k[oa>>2]=k[d>>2];k[oa+4>>2]=k[d+4>>2];k[oa+8>>2]=k[d+8>>2];k[d>>2]=k[n>>2];k[d+4>>2]=k[n+4>>2];k[d+8>>2]=k[n+8>>2];k[n>>2]=k[oa>>2];k[n+4>>2]=k[oa+4>>2];k[n+8>>2]=k[oa+8>>2];k[q>>2]=-1;f=k[f>>2]|0;e=k[o>>2]|0;d=-1;na=406}if((na|0)==406?(na=0,(f|0)==(e|0)):0)na=407;if((na|0)==407){na=0;k[q>>2]=0-d}f=u+44|0}else{A=g;z=f-g|0;x=(z|0)/44|0;w=x+1|0;if(w>>>0>97612893){na=410;break w}d=(d-g|0)/44|0;if(d>>>0<48806446){n=d<<1;n=n>>>0<w>>>0?w:n}else n=97612893;f=n*44|0;f=(f|0)==0?1:f;d=_d(f)|0;if(!d)while(1){d=k[35]|0;k[35]=d+0;if(!d){na=416;break w}Xa[d&0]();d=_d(f)|0;if(d){u=d;break}}else u=d;v=u+(n*44|0)|0;i[u+(x*44|0)>>0]=0;i[u+(x*44|0)+1>>0]=0;i[u+(x*44|0)+2>>0]=0;k[u+(x*44|0)+4>>2]=0;k[u+(x*44|0)+8>>2]=0;k[u+(x*44|0)+12>>2]=0;d=u+(x*44|0)+16|0;f=u+(x*44|0)+16|0;k[f>>2]=C;k[u+(x*44|0)+20>>2]=B;k[u+(x*44|0)+24>>2]=0;n=u+(x*44|0)+28|0;o=u+(x*44|0)+28|0;k[o>>2]=e;k[u+(x*44|0)+32>>2]=y;k[u+(x*44|0)+36>>2]=0;q=u+(x*44|0)+40|0;k[q>>2]=1;do if((C|0)<=(e|0)){if((C|0)!=(e|0)){f=C;d=1;na=421;break}if((B|0)<=(y|0)){d=1;na=422}else na=420}else na=420;while(0);if((na|0)==420){k[oa>>2]=k[d>>2];k[oa+4>>2]=k[d+4>>2];k[oa+8>>2]=k[d+8>>2];k[d>>2]=k[n>>2];k[d+4>>2]=k[n+4>>2];k[d+8>>2]=k[n+8>>2];k[n>>2]=k[oa>>2];k[n+4>>2]=k[oa+4>>2];k[n+8>>2]=k[oa+8>>2];k[q>>2]=-1;f=k[f>>2]|0;e=k[o>>2]|0;d=-1;na=421}if((na|0)==421?(na=0,(f|0)==(e|0)):0)na=422;if((na|0)==422){na=0;k[q>>2]=0-d}f=u+(w*44|0)|0;ca=u+((((z|0)/-44|0)+x|0)*44|0)|0;d=ca;fe(ca|0,A|0,z|0)|0;k[ha>>2]=v;if(!g){g=d;break}$d(A);g=d}while(0);k[f+-32>>2]=D;e=k[Z>>2]|0;d=k[Y>>2]|0}while(0);D=D+1|0;if(D>>>0>=((e-d|0)/24|0)>>>0){ga=g;da=f;break v}}if((na|0)==410)xa(1340,1363,303,1438);else if((na|0)==416){Aa=ya(4)|0;k[Aa>>2]=128;La(Aa|0,8,1)}}else{ga=g;da=ca}while(0);f=da;F=ga;z=(da-ga|0)/44|0;k[ea>>2]=z;Nd(1050,ea);k[oa>>2]=0;G=oa+4|0;k[G>>2]=0;k[oa+8>>2]=0;x=oa+8|0;y=(f|0)!=(F|0);if(y){e=z*24|0;d=_d(e)|0;x:do if(!d){while(1){d=k[35]|0;k[35]=d+0;if(!d)break;Xa[d&0]();d=_d(e)|0;if(d)break x}Aa=ya(4)|0;k[Aa>>2]=128;La(Aa|0,8,1)}while(0);da=d;g=d+(z*24|0)|0;k[oa>>2]=da;k[G>>2]=da;k[x>>2]=g}else{g=0;d=0}y:do if((f|0)!=(F|0)){n=ea+4|0;o=ea+8|0;q=ea+12|0;u=ea+16|0;v=ea+16|0;w=ea+20|0;e=0;while(1){f=k[F+(e*44|0)+16>>2]|0;b=k[F+(e*44|0)+20>>2]|0;ba=k[F+(e*44|0)+28>>2]|0;da=k[F+(e*44|0)+32>>2]|0;ca=k[F+(e*44|0)+40>>2]|0;k[ea>>2]=f;k[n>>2]=b;k[o>>2]=ba;k[q>>2]=da;da=u;k[da>>2]=e;k[da+4>>2]=ca;if(d>>>0<g>>>0){k[d>>2]=f;k[d+4>>2]=k[n>>2];k[d+8>>2]=k[o>>2];k[d+12>>2]=k[q>>2];k[d+16>>2]=k[v>>2];k[d+20>>2]=k[w>>2];k[G>>2]=d+24}else Db(oa,ea);e=e+1|0;if(e>>>0>=z>>>0)break y;d=k[G>>2]|0;g=k[x>>2]|0}}while(0);k[ja>>2]=0;E=ja+4|0;k[E>>2]=0;k[ja+8>>2]=0;f=ja+8|0;if(y){e=z*24|0;d=_d(e)|0;z:do if(!d){while(1){d=k[35]|0;k[35]=d+0;if(!d)break;Xa[d&0]();d=_d(e)|0;if(d)break z}Aa=ya(4)|0;k[Aa>>2]=128;La(Aa|0,8,1)}while(0);ea=d;k[ja>>2]=ea;k[E>>2]=ea;k[f>>2]=d+(z*24|0)}Eb(ja,k[oa>>2]|0,k[G>>2]|0);D=k[E>>2]|0;o=k[ja>>2]|0;f=(D-o|0)/24|0;n=(D|0)==(o|0);A:do if(!n){e=f*44|0;e=(e|0)==0?1:e;d=_d(e)|0;do if(!d){while(1){d=k[35]|0;k[35]=d+0;if(!d){na=451;break}Xa[d&0]();d=_d(e)|0;if(d){na=452;break}}if((na|0)==451){Aa=ya(4)|0;k[Aa>>2]=128;La(Aa|0,8,1)}else if((na|0)==452){g=d;f=d+(f*44|0)|0;e=f;if(n){ta=g;ia=e;ka=g;break A}else break}}else{f=d+(f*44|0)|0;e=f;g=d}while(0);n=g;B:while(1){w=F+((k[o+16>>2]|0)*44|0)|0;k[fa>>2]=k[w>>2];k[fa+4>>2]=k[w+4>>2];k[fa+8>>2]=k[w+8>>2];k[fa+12>>2]=k[w+12>>2];v=k[w+24>>2]|0;w=k[w+36>>2]|0;x=k[o>>2]|0;y=k[o+4>>2]|0;z=k[o+8>>2]|0;A=k[o+12>>2]|0;B=k[o+20>>2]|0;do if((d|0)==(f|0)){C=n;u=g-n|0;q=(u|0)/44|0;g=q+1|0;if(g>>>0>97612893){na=457;break B}d=(e-n|0)/44|0;if(d>>>0<48806446){d=d<<1;d=d>>>0<g>>>0?g:d;if(!d){d=0;f=0}else na=460}else{d=97612893;na=460}if((na|0)==460){na=0;f=d*44|0;f=(f|0)==0?1:f;e=_d(f)|0;if(!e)do{e=k[35]|0;k[35]=e+0;if(!e){na=463;break B}Xa[e&0]();e=_d(f)|0}while((e|0)==0);f=e}e=f+(d*44|0)|0;ea=f+(q*44|0)|0;k[ea>>2]=k[fa>>2];k[ea+4>>2]=k[fa+4>>2];k[ea+8>>2]=k[fa+8>>2];k[ea+12>>2]=k[fa+12>>2];k[ea+16>>2]=x;k[ea+20>>2]=y;k[ea+24>>2]=v;k[ea+28>>2]=z;k[ea+32>>2]=A;k[ea+36>>2]=w;k[ea+40>>2]=B;g=f+(g*44|0)|0;ea=f+((((u|0)/-44|0)+q|0)*44|0)|0;d=ea;fe(ea|0,C|0,u|0)|0;if(!n){n=d;break}$d(C);n=d}else{k[d>>2]=k[fa>>2];k[d+4>>2]=k[fa+4>>2];k[d+8>>2]=k[fa+8>>2];k[d+12>>2]=k[fa+12>>2];k[d+16>>2]=x;k[d+20>>2]=y;k[d+24>>2]=v;k[d+28>>2]=z;k[d+32>>2]=A;k[d+36>>2]=w;k[d+40>>2]=B;g=d+44|0}while(0);d=o+24|0;if((d|0)==(D|0)){ta=n;ia=e;ka=g;break A}o=d;d=g;f=e}if((na|0)==457)xa(1340,1363,303,1438);else if((na|0)==463){Aa=ya(4)|0;k[Aa>>2]=128;La(Aa|0,8,1)}}else{ta=0;ia=0;ka=0}while(0);if(ga){$d(F);k[ha>>2]=0}k[ha>>2]=ia;d=k[ja>>2]|0;e=d;if(d){f=k[E>>2]|0;if((f|0)!=(d|0))k[E>>2]=f+(~(((f+-24-e|0)>>>0)/24|0)*24|0);$d(d)}d=k[oa>>2]|0;e=d;if(d){f=k[G>>2]|0;if((f|0)!=(d|0))k[G>>2]=f+(~(((f+-24-e|0)>>>0)/24|0)*24|0);$d(d)}T=ka;U=ta;J=(ka-ta|0)/44|0;k[la>>2]=J;Nd(1070,la);k[oa>>2]=3;Ac(U,T,oa);k[ma>>2]=J;Nd(1090,ma);J=(U|0)==(T|0);do if(!J){I=ma+4|0;d=ta;z=0;y=0;g=U;q=0;o=0;e=k[U+16>>2]|0;f=0;n=0;u=0;C:while(1){D:do if((g|0)==(T|0))if((q|0)==(o|0)){na=575;break C}else H=u;else{w=g;v=f;g=u;while(1){if((k[w+16>>2]|0)!=(e|0)){f=v;H=g;break D};k[I>>2]=0;k[I+4>>2]=0;i[I+8>>0]=0;i[la>>0]=0;d=n;do if((d|0)==(g|0)){u=n-v|0;n=u>>5;o=n+1|0;if(o>>>0>134217727){na=487;break C}if(n>>>0<67108863){g=u>>4;g=g>>>0<o>>>0?o:g}else g=134217727;f=g<<5;f=(f|0)==0?1:f;d=_d(f)|0;if(!d)do{d=k[35]|0;k[35]=d+0;if(!d){na=493;break C}Xa[d&0]();d=_d(f)|0}while((d|0)==0);q=d+(g<<5)|0;k[d+(n<<5)>>2]=0;k[d+(n<<5)+4>>2]=0;k[d+(n<<5)+8>>2]=w;f=d+(n<<5)+12|0;k[f>>2]=k[ma>>2];k[f+4>>2]=k[ma+4>>2];k[f+8>>2]=k[ma+8>>2];i[f+12>>0]=i[ma+12>>0]|0;i[d+(n<<5)+25>>0]=1;n=d+(n<<5)+26|0;j[n>>1]=j[la>>1]|0;j[n+2>>1]=j[la+2>>1]|0;j[n+4>>1]=j[la+4>>1]|0;n=d+(o<<5)|0;f=d;g=v;fe(d|0,g|0,u|0)|0;if(!v){g=q;break}$d(g);g=q}else{k[d>>2]=0;k[d+4>>2]=0;k[d+8>>2]=w;f=d+12|0;k[f>>2]=k[ma>>2];k[f+4>>2]=k[ma+4>>2];k[f+8>>2]=k[ma+8>>2];i[f+12>>0]=i[ma+12>>0]|0;i[d+25>>0]=1;f=d+26|0;j[f>>1]=j[la>>1]|0;j[f+2>>1]=j[la+2>>1]|0;j[f+4>>1]=j[la+4>>1]|0;f=v;n=d+32|0}while(0);w=w+44|0;d=w;if((w|0)==(T|0)){H=g;break}else v=f}}while(0);G=f;F=n;w=(G|0)==(F|0);E:do if(w){k[oa>>2]=4;Ec(G,F,oa);u=z;q=y;o=G}else{s=+(e|0);x=G;do{g=k[x+8>>2]|0;o=k[g+20>>2]|0;v=g+28|0;q=k[v>>2]|0;u=k[g+32>>2]|0;do if((o|0)==(u|0)){h=+(o|0);g=g+16|0}else{g=g+16|0;m=+(k[g>>2]|0);h=+(o|0);l=s-m;if(l==0.0)break;h=h+(+(u|0)-h)*l/(+(q|0)-m)}while(0);p[x+16>>3]=h;if((e|0)==(k[g>>2]|0))g=1;else g=(e|0)==(k[v>>2]|0);i[x+24>>0]=g&1;x=x+32|0}while((x|0)!=(F|0));k[oa>>2]=4;Ec(G,F,oa);if(w){u=z;q=y;o=G;break}else{x=z;E=G;g=f}while(1){q=E+32|0;o=q;F:do if(!((i[E+24>>0]|0)==0|(q|0)==(F|0))){v=E+16|0;u=E;while(1){if(!(i[u+56>>0]|0))break F;if(!(+p[u+48>>3]==+p[v>>3]))break F;u=q+32|0;o=u;if((u|0)==(F|0))break;else{ka=q;q=u;u=ka}}}while(0);q=g;D=q>>>0<o>>>0;if(D){u=q;do{w=k[u+8>>2]|0;v=k[w+16>>2]|0;w=w+28|0;if((v|0)!=(k[w>>2]|0)){i[u+25>>0]=(e|0)==(v|0)&1;i[u+26>>0]=(e|0)==(k[w>>2]|0)&1}u=u+32|0}while(u>>>0<o>>>0)}G:do if((q|0)==(o|0))w=x;else{C=o+25|0;u=q;w=x;v=y;while(1){x=u;H:do if((u|0)==(o|0)){u=x;na=521}else while(1){y=k[u+8>>2]|0;z=i[u+25>>0]|0;if((k[y+16>>2]|0)==(k[y+28>>2]|0))break H;x=z<<24>>24==0;if(!x)k[u>>2]=w;do if(i[y>>0]|0){if(x)v=v+(k[y+40>>2]|0)|0;if(i[u+26>>0]|0)break;w=w+(k[y+40>>2]|0)|0}while(0);if(!x)k[u+4>>2]=w;u=u+32|0;x=u;if((u|0)==(o|0)){u=x;na=521;break}}while(0);if((na|0)==521){na=0;x=u;z=i[C>>0]|0;u=o}B=(x|0)==(o|0);I:do if(!B){A=x;do{y=k[A+8>>2]|0;if((k[y+16>>2]|0)!=(k[y+28>>2]|0))break;if((i[A+25>>0]|0)!=z<<24>>24)break;k[A>>2]=v;if(i[y>>0]|0)v=v+(k[y+40>>2]|0)|0;k[A+4>>2]=v;A=A+32|0}while((A|0)!=(o|0));if(B)break;else y=x;do{x=k[y+8>>2]|0;if((k[x+16>>2]|0)!=(k[x+28>>2]|0))break I;if((i[y+25>>0]|0)!=z<<24>>24)break I;if(i[x>>0]|0)v=v-(k[x+40>>2]|0)|0;y=y+32|0}while((y|0)!=(o|0))}while(0);if((u|0)==(o|0)){y=v;break G}while(1){ka=k[u+8>>2]|0;if((k[ka+16>>2]|0)!=(k[ka+28>>2]|0))break;if((i[u+25>>0]|0)!=z<<24>>24)break;u=u+32|0;if((u|0)==(o|0)){y=v;break G}}if((u|0)==(o|0)){y=v;break}}}while(0);if((E|0)!=(o|0)){u=E;do{if(!(k[u>>2]|0))v=0;else v=(k[u+4>>2]|0)!=0;i[(k[u+8>>2]|0)+1>>0]=v&1;u=u+32|0}while((u|0)!=(o|0))}J:do if(D)while(1){ka=k[q+8>>2]|0;if((k[ka+16>>2]|0)==(k[ka+28>>2]|0)?(i[q+26>>0]|0)==0:0){u=g;break J}q=q+32|0;g=q;if(q>>>0>=o>>>0){u=g;break}}else u=g;while(0);E=u;if(E>>>0<o>>>0){g=E;do{p[g+16>>3]=+(k[(k[g+8>>2]|0)+32>>2]|0);i[g+25>>0]=0;i[g+26>>0]=1;g=g+32|0}while(g>>>0<o>>>0)}if((E|0)==(F|0)){e=G;break}else{x=w;g=u}}while(1){if(i[e+26>>0]|0)break;e=e+32|0;if((e|0)==(F|0)){u=w;q=y;o=F;break E}}if((e|0)==(F|0)){u=w;q=y;o=F;break}g=e+32|0;if((g|0)!=(F|0)){o=e;q=e;while(1){if(!(i[o+58>>0]|0)){k[q>>2]=k[g>>2];k[q+4>>2]=k[g+4>>2];k[q+8>>2]=k[g+8>>2];k[q+12>>2]=k[g+12>>2];k[q+16>>2]=k[g+16>>2];k[q+20>>2]=k[g+20>>2];j[q+24>>1]=j[g+24>>1]|0;i[q+26>>0]=i[g+26>>0]|0;q=e+32|0;e=q}o=g+32|0;if((o|0)==(F|0))break;else{ka=g;g=o;o=ka}}}g=e;if((e|0)==(F|0)){u=w;q=y;o=F;break}ja=G+((g-f>>5)+(u-g>>5)<<5)|0;ka=u-ja|0;he(e|0,ja|0,ka|0)|0;e=e+(ka>>5<<5)|0;if((F|0)==(e|0)){u=w;q=y;o=F;break}n=F+(~((F+-32-e|0)>>>5)<<5)|0;u=w;q=y;o=n}while(0);if((G|0)==(o|0))e=2147483647;else{g=G;e=2147483647;do{ka=k[(k[g+8>>2]|0)+28>>2]|0;e=(ka|0)<(e|0)?ka:e;g=g+32|0}while((g|0)!=(o|0))}g=d;if((g|0)==(T|0)){z=u;y=q;q=G;u=H;continue}ka=k[g+16>>2]|0;z=u;y=q;q=G;e=(ka|0)<(e|0)?ka:e;u=H}if((na|0)==487)xa(1340,1363,303,1438);else if((na|0)==493){Aa=ya(4)|0;k[Aa>>2]=128;La(Aa|0,8,1)}else if((na|0)==575){if(!o)break;$d(o);break}}while(0);g=(k[87]|0)>-1;K:do if(!2){d=1110;na=580}else{e=1110;d=1110;while(1){if(!(i[e>>0]|0))break K;e=e+1|0;d=e;if(!(d&3)){d=e;na=580;break}}}while(0);if((na|0)==580){while(1){e=k[d>>2]|0;if(!((e&-2139062144^-2139062144)&e+-16843009))d=d+4|0;else break}if((e&255)<<24>>24)do d=d+1|0;while((i[d>>0]|0)!=0)}f=d-1110|0;d=k[72]|0;e=(d|0)==0;L:do if(g){do if(e){d=i[346]|0;i[346]=d+255|d;d=k[68]|0;if(!(d&8)){k[70]=0;k[69]=0;e=k[79]|0;k[75]=e;k[73]=e;d=e+(k[80]|0)|0;k[72]=d;break}else{k[68]=d|32;d=0;na=602;break L}}else e=k[73]|0;while(0);if((d-e|0)>>>0<f>>>0){d=Ta[k[308>>2]&7](272,1110,f)|0;na=602;break}else{fe(e|0,1110,f|0)|0;k[73]=(k[73]|0)+f;na=604;break}}else{do if(e){d=i[346]|0;i[346]=d+255|d;d=k[68]|0;if(!(d&8)){k[70]=0;k[69]=0;e=k[79]|0;k[75]=e;k[73]=e;d=e+(k[80]|0)|0;k[72]=d;break}else{k[68]=d|32;d=0;na=602;break L}}else e=k[73]|0;while(0);if((d-e|0)>>>0<f>>>0){d=Ta[k[308>>2]&7](272,1110,f)|0;na=602;break}else{fe(e|0,1110,f|0)|0;k[73]=(k[73]|0)+f;na=604;break}}while(0);do if((na|0)==602){if((d|0)==(f|0)){na=604;break}if(((d>>>0)/(f>>>0)|0|0)>=1)na=604}while(0);M:do if((na|0)==604){f=i[347]|0;do if(f<<24>>24==10)e=k[72]|0;else{d=k[73]|0;e=k[72]|0;if(d>>>0>=e>>>0)break;k[73]=d+1;i[d>>0]=10;break M}while(0);i[oa>>0]=10;do if(!e){f=j[173]|0;d=(f&65535)<<24>>24;i[346]=d+255|d;d=k[68]|0;if(!(d&8)){k[70]=0;k[69]=0;g=k[79]|0;k[75]=g;k[73]=g;e=g+(k[80]|0)|0;k[72]=e;d=(f&65535)>>>8&255;na=613;break}else{k[68]=d|32;break}}else{g=k[73]|0;d=f;na=613}while(0);do if((na|0)==613)if(g>>>0>=e>>>0|d<<24>>24==10){Ta[k[308>>2]&7](272,oa,1)|0;break}else{k[73]=g+1;i[g>>0]=10;break}while(0)}while(0);k[a>>2]=0;S=a+4|0;k[S>>2]=0;k[a+8>>2]=0;do if(!J){aa=c*.5;K=a+8|0;Q=U;N:while(1){O:do if(!(i[Q>>0]|0)){if(!(i[Q+1>>0]|0))break;n=k[Q+12>>2]|0;o=k[Y>>2]|0;A=k[o+(n*24|0)>>2]|0;g=k[o+(n*24|0)+8>>2]|0;z=k[g>>2]|0;f=k[o+(n*24|0)+4>>2]|0;h=+p[f>>3];p[t>>3]=h;d=k[t+4>>2]|0;e=de(k[t>>2]|0,d|0,52)|0;e=e&2047;do if(e>>>0<=1074){d=(d|0)<0;m=d?-h:h;if(e>>>0<1022){h=h*0.0;break}l=m+4503599627370496.0+-4503599627370496.0-m;do if(l>.5)h=m+l+-1.0;else{h=m+l;if(!(l<=-.5))break;h=h+1.0}while(0);h=d?-h:h}while(0);C=~~h;h=+p[f+8>>3];p[t>>3]=h;d=k[t+4>>2]|0;e=de(k[t>>2]|0,d|0,52)|0;e=e&2047;do if(e>>>0<=1074){d=(d|0)<0;m=d?-h:h;if(e>>>0<1022){h=h*0.0;break}l=m+4503599627370496.0+-4503599627370496.0-m;do if(l>.5)h=m+l+-1.0;else{h=m+l;if(!(l<=-.5))break;h=h+1.0}while(0);h=d?-h:h}while(0);B=~~h;f=k[g+4>>2]|0;h=+p[f>>3];p[t>>3]=h;d=k[t+4>>2]|0;e=de(k[t>>2]|0,d|0,52)|0;e=e&2047;do if(e>>>0<=1074){d=(d|0)<0;m=d?-h:h;if(e>>>0<1022){h=h*0.0;break}l=m+4503599627370496.0+-4503599627370496.0-m;do if(l>.5)h=m+l+-1.0;else{h=m+l;if(!(l<=-.5))break;h=h+1.0}while(0);h=d?-h:h}while(0);J=~~h;h=+p[f+8>>3];p[t>>3]=h;d=k[t+4>>2]|0;e=de(k[t>>2]|0,d|0,52)|0;e=e&2047;do if(e>>>0<=1074){d=(d|0)<0;m=d?-h:h;if(e>>>0<1022){h=h*0.0;break}l=m+4503599627370496.0+-4503599627370496.0-m;do if(l>.5)h=m+l+-1.0;else{h=m+l;if(!(l<=-.5))break;h=h+1.0}while(0);h=d?-h:h}while(0);I=~~h;if(!(k[o+(n*24|0)+20>>2]&1)){d=k[A+8>>2]|0;f=k[A>>2]|0;if(!(d&24)){ma=(d&31|0)==1;d=k[wa>>2]|0;g=k[z>>2]|0;o=d+(g<<4)+12|0;q=d+(g<<4)+8|0;n=d+(g<<4)+4|0;g=d+(g<<4)|0;e=ma?d+(f<<4)+4|0:d+(f<<4)+12|0;d=ma?d+(f<<4)|0:d+(f<<4)+8|0}else{la=(k[z+8>>2]&31|0)==1;d=k[z>>2]|0;ma=k[wa>>2]|0;o=ma+(f<<4)+12|0;q=ma+(f<<4)+8|0;n=ma+(f<<4)+4|0;g=ma+(f<<4)|0;e=la?ma+(d<<4)+4|0:ma+(d<<4)+12|0;d=la?ma+(d<<4)|0:ma+(d<<4)+8|0}H=k[d>>2]|0;G=k[e>>2]|0;F=k[g>>2]|0;E=k[n>>2]|0;n=(k[q>>2]|0)-F|0;e=(k[o>>2]|0)-E|0;ma=C-F|0;ka=B-E|0;D=((n|0)<0)<<31>>31;ma=ne(ma|0,((ma|0)<0)<<31>>31|0,n|0,D|0)|0;la=L;d=((e|0)<0)<<31>>31;ka=ne(ka|0,((ka|0)<0)<<31>>31|0,e|0,d|0)|0;la=ge(ka|0,L|0,ma|0,la|0)|0;M=+(n|0);N=+(e|0);P=M*M+N*N;O=(+(la>>>0)+4294967296.0*+(L|0))/P;la=J-F|0;ma=I-E|0;D=ne(la|0,((la|0)<0)<<31>>31|0,n|0,D|0)|0;n=L;d=ne(ma|0,((ma|0)<0)<<31>>31|0,e|0,d|0)|0;n=ge(d|0,L|0,D|0,n|0)|0;P=(+(n>>>0)+4294967296.0*+(L|0))/P-O;R=+$(+aa);n=C;D=B;d=0;e=0;while(1){u=e;while(1){s=O+P*+(d>>>0)/20.0;h=M*s;p[t>>3]=h;e=k[t+4>>2]|0;f=de(k[t>>2]|0,e|0,52)|0;f=f&2047;do if(f>>>0<=1074){e=(e|0)<0;m=e?-h:h;if(f>>>0<1022){h=h*0.0;break}l=m+4503599627370496.0+-4503599627370496.0-m;do if(l>.5)h=m+l+-1.0;else{h=m+l;if(!(l<=-.5))break;h=h+1.0}while(0);h=e?-h:h}while(0);g=~~h+F|0;h=N*s;p[t>>3]=h;e=k[t+4>>2]|0;f=de(k[t>>2]|0,e|0,52)|0;f=f&2047;do if(f>>>0<=1074){e=(e|0)<0;m=e?-h:h;if(f>>>0<1022){h=h*0.0;break}l=m+4503599627370496.0+-4503599627370496.0-m;do if(l>.5)h=m+l+-1.0;else{h=m+l;if(!(l<=-.5))break;h=h+1.0}while(0);h=e?-h:h}while(0);o=~~h+E|0;h=+(H-g|0);c=+(G-o|0);s=h*h+c*c;c=(N*h-M*c)*2.0;h=N*s/c;p[t>>3]=h;e=k[t+4>>2]|0;f=de(k[t>>2]|0,e|0,52)|0;f=f&2047;do if(f>>>0<=1074){e=(e|0)<0;m=e?-h:h;if(f>>>0<1022){h=h*0.0;break}l=m+4503599627370496.0+-4503599627370496.0-m;do if(l>.5)h=m+l+-1.0;else{h=m+l;if(!(l<=-.5))break;h=h+1.0}while(0);h=e?-h:h}while(0);g=~~h+g|0;h=M*s/c;p[t>>3]=h;e=k[t+4>>2]|0;f=de(k[t>>2]|0,e|0,52)|0;f=f&2047;do if(f>>>0<=1074){e=(e|0)<0;m=e?-h:h;if(f>>>0<1022){h=h*0.0;break}l=m+4503599627370496.0+-4503599627370496.0-m;do if(l>.5)h=m+l+-1.0;else{h=m+l;if(!(l<=-.5))break;h=h+1.0}while(0);h=e?-h:h}while(0);B=(d|0)==20;C=B?J:g;B=B?I:o-~~h|0;c=+(C-H|0);h=+(B-G|0);h=+X(+(c*c+h*h))/R;p[t>>3]=h;e=k[t+4>>2]|0;f=de(k[t>>2]|0,e|0,52)|0;f=f&2047;do if(f>>>0<=1074){e=(e|0)<0;m=e?-h:h;if(f>>>0<1022){h=h*0.0;break}l=m+4503599627370496.0+-4503599627370496.0-m;do if(l>.5)h=m+l+-1.0;else{h=m+l;if(!(l<=-.5))break;h=h+1.0}while(0);h=e?-h:h}while(0);e=0-~~h|0;if(!d){d=1;u=e}else break}v=k[S>>2]|0;f=k[K>>2]|0;do if(v>>>0<f>>>0){i[v>>0]=0;i[v+1>>0]=0;i[v+2>>0]=0;k[v+4>>2]=0;k[v+8>>2]=0;k[v+12>>2]=0;g=v+16|0;o=v+16|0;k[o>>2]=n;k[v+20>>2]=D;k[v+24>>2]=u;f=v+28|0;q=v+28|0;k[q>>2]=C;k[v+32>>2]=B;k[v+36>>2]=e;u=v+40|0;k[u>>2]=1;do if((n|0)<=(C|0)){if((n|0)!=(C|0)){g=C;f=1;na=805;break}if((D|0)<=(B|0)){f=1;na=806}else na=804}else na=804;while(0);if((na|0)==804){k[oa>>2]=k[g>>2];k[oa+4>>2]=k[g+4>>2];k[oa+8>>2]=k[g+8>>2];k[g>>2]=k[f>>2];k[g+4>>2]=k[f+4>>2];k[g+8>>2]=k[f+8>>2];k[f>>2]=k[oa>>2];k[f+4>>2]=k[oa+4>>2];k[f+8>>2]=k[oa+8>>2];k[u>>2]=-1;n=k[o>>2]|0;g=k[q>>2]|0;f=-1;na=805}if((na|0)==805?(na=0,(n|0)==(g|0)):0)na=806;if((na|0)==806){na=0;k[u>>2]=0-f}k[S>>2]=v+44}else{A=k[a>>2]|0;g=A;x=v-g|0;y=(x|0)/44|0;z=y+1|0;if(z>>>0>97612893){na=809;break N}f=(f-g|0)/44|0;if(f>>>0<48806446){f=f<<1;f=f>>>0<z>>>0?z:f;if(!f){f=0;g=0}else na=812}else{f=97612893;na=812}if((na|0)==812){o=f*44|0;o=(o|0)==0?1:o;g=_d(o)|0;if(!g)do{g=k[35]|0;k[35]=g+0;if(!g){na=815;break N}Xa[g&0]();g=_d(o)|0}while((g|0)==0)}w=g+(f*44|0)|0;i[g+(y*44|0)>>0]=0;i[g+(y*44|0)+1>>0]=0;i[g+(y*44|0)+2>>0]=0;k[g+(y*44|0)+4>>2]=0;k[g+(y*44|0)+8>>2]=0;k[g+(y*44|0)+12>>2]=0;q=g+(y*44|0)+16|0;k[q>>2]=n;k[g+(y*44|0)+20>>2]=D;k[g+(y*44|0)+24>>2]=u;f=g+(y*44|0)+28|0;k[f>>2]=C;k[g+(y*44|0)+32>>2]=B;k[g+(y*44|0)+36>>2]=e;v=g+(y*44|0)+40|0;k[v>>2]=1;o=g+(y*44|0)+16|0;u=g+(y*44|0)+28|0;do if((n|0)<=(C|0)){if((n|0)!=(C|0)){o=C;f=1;na=821;break}if((D|0)<=(B|0)){f=1;na=822}else na=820}else na=820;while(0);if((na|0)==820){k[oa>>2]=k[q>>2];k[oa+4>>2]=k[q+4>>2];k[oa+8>>2]=k[q+8>>2];k[q>>2]=k[f>>2];k[q+4>>2]=k[f+4>>2];k[q+8>>2]=k[f+8>>2];k[f>>2]=k[oa>>2];k[f+4>>2]=k[oa+4>>2];k[f+8>>2]=k[oa+8>>2];k[v>>2]=-1;n=k[o>>2]|0;o=k[u>>2]|0;f=-1;na=821}if((na|0)==821?(na=0,(n|0)==(o|0)):0)na=822;if((na|0)==822){na=0;k[v>>2]=0-f}ma=g+((((x|0)/-44|0)+y|0)*44|0)|0;fe(ma|0,A|0,x|0)|0;k[a>>2]=ma;k[S>>2]=g+(z*44|0);k[K>>2]=w;if(!A)break;$d(A)}while(0);d=d+1|0;if((d|0)==21)break O;else{n=C;D=B}}}y=k[A>>2]|0;ma=k[wa>>2]|0;n=ma+(y<<4)|0;o=k[n>>2]|0;x=ma+(y<<4)+4|0;q=k[x>>2]|0;u=ma+(y<<4)+8|0;v=k[u>>2]|0;y=ma+(y<<4)+12|0;w=k[y>>2]|0;g=k[z>>2]|0;d=k[ma+(g<<4)>>2]|0;e=k[ma+(g<<4)+4>>2]|0;f=k[ma+(g<<4)+8>>2]|0;g=k[ma+(g<<4)+12>>2]|0;i[sa>>0]=1;do if((d|0)==(o|0)&(e|0)==(q|0)){ia=v-o|0;fa=w-q|0;ma=f-o|0;ja=g-q|0;ha=((ia|0)<0)<<31>>31;la=((ma|0)<0)<<31>>31;da=ne(ma|0,la|0,ia|0,ha|0)|0;ea=L;ga=((fa|0)<0)<<31>>31;ka=((ja|0)<0)<<31>>31;ca=ne(ja|0,ka|0,fa|0,ga|0)|0;ea=ge(ca|0,L|0,da|0,ea|0)|0;R=+(ea>>>0)+4294967296.0*+(L|0);ea=(ia|0)<0;da=be(0,0,ia|0,ha|0)|0;ia=ea?da:ia;ha=ea?L:ha;ea=(fa|0)<0;da=be(0,0,fa|0,ga|0)|0;fa=ea?da:fa;ga=ea?L:ga;ha=ne(ia|0,ha|0,ia|0,ha|0)|0;ia=L;ga=ne(fa|0,ga|0,fa|0,ga|0)|0;ia=ge(ga|0,L|0,ha|0,ia|0)|0;R=R/+X(+(+(ia>>>0)+4294967296.0*+(L|0)));ia=(ma|0)<0;ha=be(0,0,ma|0,la|0)|0;ma=ia?ha:ma;la=ia?L:la;ia=(ja|0)<0;ha=be(0,0,ja|0,ka|0)|0;ja=ia?ha:ja;ka=ia?L:ka;la=ne(ma|0,la|0,ma|0,la|0)|0;ma=L;ka=ne(ja|0,ka|0,ja|0,ka|0)|0;ma=ge(ka|0,L|0,la|0,ma|0)|0;if(!(R/+X(+(+(ma>>>0)+4294967296.0*+(L|0)))<=-.733459594406401))break;i[sa>>0]=0;break O}else{if((f|0)==(o|0)&(g|0)==(q|0)){ia=v-o|0;fa=w-q|0;ma=d-o|0;ja=e-q|0;ha=((ia|0)<0)<<31>>31;la=((ma|0)<0)<<31>>31;da=ne(ma|0,la|0,ia|0,ha|0)|0;ea=L;ga=((fa|0)<0)<<31>>31;ka=((ja|0)<0)<<31>>31;ca=ne(ja|0,ka|0,fa|0,ga|0)|0;ea=ge(ca|0,L|0,da|0,ea|0)|0;R=+(ea>>>0)+4294967296.0*+(L|0);ea=(ia|0)<0;da=be(0,0,ia|0,ha|0)|0;ia=ea?da:ia;ha=ea?L:ha;ea=(fa|0)<0;da=be(0,0,fa|0,ga|0)|0;fa=ea?da:fa;ga=ea?L:ga;ha=ne(ia|0,ha|0,ia|0,ha|0)|0;ia=L;ga=ne(fa|0,ga|0,fa|0,ga|0)|0;ia=ge(ga|0,L|0,ha|0,ia|0)|0;R=R/+X(+(+(ia>>>0)+4294967296.0*+(L|0)));ia=(ma|0)<0;ha=be(0,0,ma|0,la|0)|0;ma=ia?ha:ma;la=ia?L:la;ia=(ja|0)<0;ha=be(0,0,ja|0,ka|0)|0;ja=ia?ha:ja;ka=ia?L:ka;la=ne(ma|0,la|0,ma|0,la|0)|0;ma=L;ka=ne(ja|0,ka|0,ja|0,ka|0)|0;ma=ge(ka|0,L|0,la|0,ma|0)|0;if(!(R/+X(+(+(ma>>>0)+4294967296.0*+(L|0)))<=-.733459594406401))break;i[sa>>0]=0;break O}if((d|0)==(v|0)&(e|0)==(w|0)){ia=o-v|0;fa=q-w|0;ma=f-v|0;ja=g-w|0;ha=((ia|0)<0)<<31>>31;la=((ma|0)<0)<<31>>31;da=ne(ma|0,la|0,ia|0,ha|0)|0;ea=L;ga=((fa|0)<0)<<31>>31;ka=((ja|0)<0)<<31>>31;ca=ne(ja|0,ka|0,fa|0,ga|0)|0;ea=ge(ca|0,L|0,da|0,ea|0)|0;R=+(ea>>>0)+4294967296.0*+(L|0);ea=(ia|0)<0;da=be(0,0,ia|0,ha|0)|0;ia=ea?da:ia;ha=ea?L:ha;ea=(fa|0)<0;da=be(0,0,fa|0,ga|0)|0;fa=ea?da:fa;ga=ea?L:ga;ha=ne(ia|0,ha|0,ia|0,ha|0)|0;ia=L;ga=ne(fa|0,ga|0,fa|0,ga|0)|0;ia=ge(ga|0,L|0,ha|0,ia|0)|0;R=R/+X(+(+(ia>>>0)+4294967296.0*+(L|0)));ia=(ma|0)<0;ha=be(0,0,ma|0,la|0)|0;ma=ia?ha:ma;la=ia?L:la;ia=(ja|0)<0;ha=be(0,0,ja|0,ka|0)|0;ja=ia?ha:ja;ka=ia?L:ka;la=ne(ma|0,la|0,ma|0,la|0)|0;ma=L;ka=ne(ja|0,ka|0,ja|0,ka|0)|0;ma=ge(ka|0,L|0,la|0,ma|0)|0;if(!(R/+X(+(+(ma>>>0)+4294967296.0*+(L|0)))<=-.733459594406401))break;i[sa>>0]=0;break O}if(!((f|0)==(v|0)&(g|0)==(w|0)))break;ia=o-v|0;fa=q-w|0;ma=d-v|0;ja=e-w|0;ha=((ia|0)<0)<<31>>31;la=((ma|0)<0)<<31>>31;da=ne(ma|0,la|0,ia|0,ha|0)|0;ea=L;ga=((fa|0)<0)<<31>>31;ka=((ja|0)<0)<<31>>31;ca=ne(ja|0,ka|0,fa|0,ga|0)|0;ea=ge(ca|0,L|0,da|0,ea|0)|0;R=+(ea>>>0)+4294967296.0*+(L|0);ea=(ia|0)<0;da=be(0,0,ia|0,ha|0)|0;ia=ea?da:ia;ha=ea?L:ha;ea=(fa|0)<0;da=be(0,0,fa|0,ga|0)|0;fa=ea?da:fa;ga=ea?L:ga;ha=ne(ia|0,ha|0,ia|0,ha|0)|0;ia=L;ga=ne(fa|0,ga|0,fa|0,ga|0)|0;ia=ge(ga|0,L|0,ha|0,ia|0)|0;R=R/+X(+(+(ia>>>0)+4294967296.0*+(L|0)));ia=(ma|0)<0;ha=be(0,0,ma|0,la|0)|0;ma=ia?ha:ma;la=ia?L:la;ia=(ja|0)<0;ha=be(0,0,ja|0,ka|0)|0;ja=ia?ha:ja;ka=ia?L:ka;la=ne(ma|0,la|0,ma|0,la|0)|0;ma=L;ka=ne(ja|0,ka|0,ja|0,ka|0)|0;ma=ge(ka|0,L|0,la|0,ma|0)|0;if(!(R/+X(+(+(ma>>>0)+4294967296.0*+(L|0)))<=-.733459594406401))break;i[sa>>0]=0;break O}while(0);if(!(i[sa>>0]|0))break;d=k[A+8>>2]&31;if((d+-1|0)>>>0>=2){c=+(v-o|0);R=+(w-q|0);P=+X(+(c*c+R*R));c=c/P;P=R/P;R=+(o-C|0);N=+(q-B|0);h=R*c+N*P;R=R-c*h;h=N-P*h;N=+(o-J|0);O=+(q-I|0);s=N*c+O*P;c=N-c*s;s=O-P*s;s=+X(+(c*c+s*s));c=+$(+aa);h=+X(+(R*R+h*h))/c;p[t>>3]=h;d=k[t+4>>2]|0;e=de(k[t>>2]|0,d|0,52)|0;e=e&2047;do if(e>>>0<=1074){d=(d|0)<0;m=d?-h:h;if(e>>>0<1022){h=h*0.0;break}l=m+4503599627370496.0+-4503599627370496.0-m;do if(l>.5)h=m+l+-1.0;else{h=m+l;if(!(l<=-.5))break;h=h+1.0}while(0);h=d?-h:h}while(0);g=0-~~h|0;h=s/c;p[t>>3]=h;d=k[t+4>>2]|0;e=de(k[t>>2]|0,d|0,52)|0;e=e&2047;do if(e>>>0<=1074){d=(d|0)<0;m=d?-h:h;if(e>>>0<1022){h=h*0.0;break}l=m+4503599627370496.0+-4503599627370496.0-m;do if(l>.5)h=m+l+-1.0;else{h=m+l;if(!(l<=-.5))break;h=h+1.0}while(0);h=d?-h:h}while(0);f=0-~~h|0;do if((J|0)>=(C|0)){if((J|0)!=(C|0)){e=J;n=I;u=f;d=1;q=C;o=B;na=739;break}if((I|0)>=(B|0)){e=C;n=I;q=C;o=B;d=1;na=740}else{e=C;n=B;u=g;d=-1;q=J;o=I;g=f;na=739}}else{e=C;n=B;u=g;d=-1;q=J;o=I;g=f;na=739}while(0);if((na|0)==739){na=0;if((q|0)==(e|0)){f=u;na=740}else{A=e;z=n;f=u;x=g}}if((na|0)==740){na=0;A=e;z=n;d=0-d|0;x=g}e=k[S>>2]|0;g=k[K>>2]|0;if(e>>>0<g>>>0){i[e>>0]=0;i[e+1>>0]=0;i[e+2>>0]=0;k[e+4>>2]=0;k[e+8>>2]=0;k[e+12>>2]=0;k[e+16>>2]=q;k[e+20>>2]=o;k[e+24>>2]=x;k[e+28>>2]=A;k[e+32>>2]=z;k[e+36>>2]=f;k[e+40>>2]=d;k[S>>2]=e+44;break}y=k[a>>2]|0;n=y;u=e-n|0;v=(u|0)/44|0;w=v+1|0;if(w>>>0>97612893){na=744;break N}e=(g-n|0)/44|0;if(e>>>0<48806446){e=e<<1;e=e>>>0<w>>>0?w:e;if(!e){e=0;g=0}else na=747}else{e=97612893;na=747}if((na|0)==747){na=0;n=e*44|0;n=(n|0)==0?1:n;g=_d(n)|0;if(!g)do{g=k[35]|0;k[35]=g+0;if(!g){na=750;break N}Xa[g&0]();g=_d(n)|0}while((g|0)==0)}ma=g+(v*44|0)|0;i[ma>>0]=0;i[ma+1>>0]=0;i[ma+2>>0]=0;k[ma+4>>2]=0;k[ma+8>>2]=0;k[ma+12>>2]=0;k[ma+16>>2]=q;k[ma+20>>2]=o;k[ma+24>>2]=x;k[ma+28>>2]=A;k[ma+32>>2]=z;k[ma+36>>2]=f;k[ma+40>>2]=d;ma=g+((((u|0)/-44|0)+v|0)*44|0)|0;fe(ma|0,y|0,u|0)|0;k[a>>2]=ma;k[S>>2]=g+(w*44|0);k[K>>2]=g+(e*44|0);if(!y)break;$d(y);break}E=(d|0)==1;F=k[(E?n:u)>>2]|0;E=k[(E?x:y)>>2]|0;P=+(C|0);N=+(J-C|0);O=+(B|0);c=+(I-B|0);M=+$(+aa);A=0;B=0;C=0;D=0;while(1){s=+(C|0);h=P+N*s/20.0;p[t>>3]=h;d=k[t+4>>2]|0;e=de(k[t>>2]|0,d|0,52)|0;e=e&2047;do if(e>>>0<=1074){d=(d|0)<0;m=d?-h:h;if(e>>>0<1022){h=h*0.0;break}l=m+4503599627370496.0+-4503599627370496.0-m;do if(l>.5)h=m+l+-1.0;else{h=m+l;if(!(l<=-.5))break;h=h+1.0}while(0);h=d?-h:h}while(0);f=A;A=~~h;h=O+c*s/20.0;p[t>>3]=h;d=k[t+4>>2]|0;e=de(k[t>>2]|0,d|0,52)|0;e=e&2047;do if(e>>>0<=1074){d=(d|0)<0;m=d?-h:h;if(e>>>0<1022){h=h*0.0;break}l=m+4503599627370496.0+-4503599627370496.0-m;do if(l>.5)h=m+l+-1.0;else{h=m+l;if(!(l<=-.5))break;h=h+1.0}while(0);h=d?-h:h}while(0);z=B;B=~~h;R=+(A-F|0);h=+(B-E|0);h=+X(+(R*R+h*h))/M;p[t>>3]=h;d=k[t+4>>2]|0;e=de(k[t>>2]|0,d|0,52)|0;e=e&2047;do if(e>>>0<=1074){d=(d|0)<0;m=d?-h:h;if(e>>>0<1022){h=h*0.0;break}l=m+4503599627370496.0+-4503599627370496.0-m;do if(l>.5)h=m+l+-1.0;else{h=m+l;if(!(l<=-.5))break;h=h+1.0}while(0);h=d?-h:h}while(0);o=D;D=0-~~h|0;if(!C){C=1;continue}q=k[S>>2]|0;d=k[K>>2]|0;do if(q>>>0<d>>>0){i[q>>0]=0;i[q+1>>0]=0;i[q+2>>0]=0;k[q+4>>2]=0;k[q+8>>2]=0;k[q+12>>2]=0;e=q+16|0;g=q+16|0;k[g>>2]=f;k[q+20>>2]=z;k[q+24>>2]=o;d=q+28|0;n=q+28|0;k[n>>2]=A;k[q+32>>2]=B;k[q+36>>2]=D;o=q+40|0;k[o>>2]=1;do if((f|0)<=(A|0)){if((f|0)!=(A|0)){e=A;d=1;na=699;break}if((z|0)<=(B|0)){d=1;na=700}else na=698}else na=698;while(0);if((na|0)==698){k[oa>>2]=k[e>>2];k[oa+4>>2]=k[e+4>>2];k[oa+8>>2]=k[e+8>>2];k[e>>2]=k[d>>2];k[e+4>>2]=k[d+4>>2];k[e+8>>2]=k[d+8>>2];k[d>>2]=k[oa>>2];k[d+4>>2]=k[oa+4>>2];k[d+8>>2]=k[oa+8>>2];k[o>>2]=-1;f=k[g>>2]|0;e=k[n>>2]|0;d=-1;na=699}if((na|0)==699?(na=0,(f|0)==(e|0)):0)na=700;if((na|0)==700){na=0;k[o>>2]=0-d}k[S>>2]=q+44}else{y=k[a>>2]|0;e=y;v=q-e|0;w=(v|0)/44|0;x=w+1|0;if(x>>>0>97612893){na=703;break N}d=(d-e|0)/44|0;if(d>>>0<48806446){d=d<<1;d=d>>>0<x>>>0?x:d;if(!d){d=0;e=0}else na=706}else{d=97612893;na=706}if((na|0)==706){g=d*44|0;g=(g|0)==0?1:g;e=_d(g)|0;if(!e)do{e=k[35]|0;k[35]=e+0;if(!e){na=709;break N}Xa[e&0]();e=_d(g)|0}while((e|0)==0)}u=e+(d*44|0)|0;i[e+(w*44|0)>>0]=0;i[e+(w*44|0)+1>>0]=0;i[e+(w*44|0)+2>>0]=0;k[e+(w*44|0)+4>>2]=0;k[e+(w*44|0)+8>>2]=0;k[e+(w*44|0)+12>>2]=0;n=e+(w*44|0)+16|0;k[n>>2]=f;k[e+(w*44|0)+20>>2]=z;k[e+(w*44|0)+24>>2]=o;d=e+(w*44|0)+28|0;k[d>>2]=A;k[e+(w*44|0)+32>>2]=B;k[e+(w*44|0)+36>>2]=D;q=e+(w*44|0)+40|0;k[q>>2]=1;g=e+(w*44|0)+16|0;o=e+(w*44|0)+28|0;do if((f|0)<=(A|0)){if((f|0)!=(A|0)){g=A;d=1;na=715;break}if((z|0)<=(B|0)){d=1;na=716}else na=714}else na=714;while(0);if((na|0)==714){k[oa>>2]=k[n>>2];k[oa+4>>2]=k[n+4>>2];k[oa+8>>2]=k[n+8>>2];k[n>>2]=k[d>>2];k[n+4>>2]=k[d+4>>2];k[n+8>>2]=k[d+8>>2];k[d>>2]=k[oa>>2];k[d+4>>2]=k[oa+4>>2];k[d+8>>2]=k[oa+8>>2];k[q>>2]=-1;f=k[g>>2]|0;g=k[o>>2]|0;d=-1;na=715}if((na|0)==715?(na=0,(f|0)==(g|0)):0)na=716;if((na|0)==716){na=0;k[q>>2]=0-d}ma=e+((((v|0)/-44|0)+w|0)*44|0)|0;fe(ma|0,y|0,v|0)|0;k[a>>2]=ma;k[S>>2]=e+(x*44|0);k[K>>2]=u;if(!y)break;$d(y)}while(0);C=C+1|0;if((C|0)>=21)break}}while(0);Q=Q+44|0;if((Q|0)==(T|0)){na=827;break}}if((na|0)==703)xa(1340,1363,303,1438);else if((na|0)==709){Aa=ya(4)|0;k[Aa>>2]=128;La(Aa|0,8,1)}else if((na|0)==744)xa(1340,1363,303,1438);else if((na|0)==750){Aa=ya(4)|0;k[Aa>>2]=128;La(Aa|0,8,1)}else if((na|0)==809)xa(1340,1363,303,1438);else if((na|0)==815){Aa=ya(4)|0;k[Aa>>2]=128;La(Aa|0,8,1)}else if((na|0)==827){pa=k[S>>2]|0;qa=k[a>>2]|0;break}}else{pa=0;qa=0}while(0);k[ua>>2]=(pa-qa|0)/44|0;Nd(1113,ua);if(ta)$d(U);Bc(ra);d=k[Y>>2]|0;e=d;if(d){f=k[Z>>2]|0;if((f|0)!=(d|0))k[Z>>2]=f+(~(((f+-24-e|0)>>>0)/24|0)*24|0);$d(d)}d=k[V>>2]|0;e=d;if(d){f=k[W>>2]|0;if((f|0)!=(d|0))k[W>>2]=f+(~(((f+-24-e|0)>>>0)/24|0)*24|0);$d(d)}f=k[va>>2]|0;g=f;if(f){d=va+4|0;e=k[d>>2]|0;if((e|0)!=(f|0))k[d>>2]=e+(~(((e+-12-g|0)>>>0)/12|0)*12|0);$d(f)}d=k[wa>>2]|0;if(!d){r=Aa;return}e=k[za>>2]|0;if((e|0)!=(d|0))k[za>>2]=e+(~((e+-16-d|0)>>>4)<<4);$d(d);r=Aa;return}function nc(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;var f=0,g=0,h=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0,s=0,t=0;t=r;r=r+32|0;j=t+12|0;l=t;n=a+4|0;o=k[a>>2]|0;f=o;p=(k[n>>2]|0)-f|0;q=p>>5;s=q+1|0;if(s>>>0>134217727)xa(1340,1363,303,1438);m=a+8|0;f=(k[m>>2]|0)-f|0;if(f>>5>>>0<67108863){f=f>>4;f=f>>>0<s>>>0?s:f;if(!f){f=0;g=0}else h=5}else{f=134217727;h=5}if((h|0)==5){h=f<<5;h=(h|0)==0?1:h;g=_d(h)|0;a:do if(!g){while(1){g=k[35]|0;k[35]=g+0;if(!g)break;Xa[g&0]();g=_d(h)|0;if(g)break a}t=ya(4)|0;k[t>>2]=128;La(t|0,8,1)}while(0)}h=g+(q<<5)|0;k[j>>2]=k[b>>2];k[j+4>>2]=k[b+4>>2];k[j+8>>2]=k[b+8>>2];k[l>>2]=k[c>>2];k[l+4>>2]=k[c+4>>2];k[l+8>>2]=k[c+8>>2];d=i[d>>0]|0;e=k[e>>2]|0;k[h>>2]=k[j>>2];k[h+4>>2]=k[j+4>>2];k[h+8>>2]=k[j+8>>2];c=g+(q<<5)+12|0;k[c>>2]=k[l>>2];k[c+4>>2]=k[l+4>>2];k[c+8>>2]=k[l+8>>2];k[g+(q<<5)+24>>2]=e;i[g+(q<<5)+28>>0]=d;i[g+(q<<5)+29>>0]=0;fe(g|0,o|0,p|0)|0;k[a>>2]=g;k[n>>2]=g+(s<<5);k[m>>2]=g+(f<<5);if(!o){r=t;return}$d(o);r=t;return}function oc(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0,l=0,m=0,n=0,o=0,p=0,q=0,s=0,t=0,u=0,v=0,w=0;w=r;r=r+64|0;v=w+24|0;u=w;a:while(1){n=b;p=b+-32|0;o=b+-64|0;q=b+-28|0;s=a;b:while(1){m=s;a=n-m|0;c=a>>5;switch(c|0){case 2:{h=4;break a}case 3:{h=8;break a}case 4:{h=26;break a}case 5:{h=27;break a}case 1:case 0:{h=136;break a}default:{}}if((a|0)<992){h=29;break a}e=(c|0)/2|0;f=s+(e<<5)|0;do if((a|0)>31968){a=(c|0)/4|0;c=f;l=s;a=wc(s,s+(a<<5)|0,f,s+(a+e<<5)|0,p)|0}else{c=k[f>>2]|0;a=k[s>>2]|0;if((c|0)>=(a|0))if((c|0)==(a|0))d=(k[s+(e<<5)+4>>2]|0)<(k[s+4>>2]|0);else d=0;else d=1;a=k[p>>2]|0;if((a|0)>=(c|0))if((a|0)==(c|0))a=(k[q>>2]|0)<(k[s+(e<<5)+4>>2]|0);else a=0;else a=1;if(!d){if(!a){c=f;l=s;a=0;break};k[v>>2]=k[f>>2];k[v+4>>2]=k[f+4>>2];k[v+8>>2]=k[f+8>>2];k[v+12>>2]=k[f+12>>2];k[v+16>>2]=k[f+16>>2];k[v+20>>2]=k[f+20>>2];k[v+24>>2]=k[f+24>>2];k[v+28>>2]=k[f+28>>2];k[f>>2]=k[p>>2];k[f+4>>2]=k[p+4>>2];k[f+8>>2]=k[p+8>>2];k[f+12>>2]=k[p+12>>2];k[f+16>>2]=k[p+16>>2];k[f+20>>2]=k[p+20>>2];k[f+24>>2]=k[p+24>>2];j[f+28>>1]=j[p+28>>1]|0;k[p>>2]=k[v>>2];k[p+4>>2]=k[v+4>>2];k[p+8>>2]=k[v+8>>2];k[p+12>>2]=k[v+12>>2];k[p+16>>2]=k[v+16>>2];k[p+20>>2]=k[v+20>>2];k[p+24>>2]=k[v+24>>2];j[p+28>>1]=j[v+28>>1]|0;a=k[f>>2]|0;c=k[s>>2]|0;if((a|0)>=(c|0)){if((a|0)!=(c|0)){c=f;l=s;a=1;break}if((k[s+(e<<5)+4>>2]|0)>=(k[s+4>>2]|0)){c=f;l=s;a=1;break}};k[v>>2]=k[s>>2];k[v+4>>2]=k[s+4>>2];k[v+8>>2]=k[s+8>>2];k[v+12>>2]=k[s+12>>2];k[v+16>>2]=k[s+16>>2];k[v+20>>2]=k[s+20>>2];k[v+24>>2]=k[s+24>>2];k[v+28>>2]=k[s+28>>2];k[s>>2]=k[f>>2];k[s+4>>2]=k[f+4>>2];k[s+8>>2]=k[f+8>>2];k[s+12>>2]=k[f+12>>2];k[s+16>>2]=k[f+16>>2];k[s+20>>2]=k[f+20>>2];k[s+24>>2]=k[f+24>>2];j[s+28>>1]=j[f+28>>1]|0;k[f>>2]=k[v>>2];k[f+4>>2]=k[v+4>>2];k[f+8>>2]=k[v+8>>2];k[f+12>>2]=k[v+12>>2];k[f+16>>2]=k[v+16>>2];k[f+20>>2]=k[v+20>>2];k[f+24>>2]=k[v+24>>2];j[f+28>>1]=j[v+28>>1]|0;c=f;l=s;a=2;break};k[v>>2]=k[s>>2];k[v+4>>2]=k[s+4>>2];k[v+8>>2]=k[s+8>>2];k[v+12>>2]=k[s+12>>2];k[v+16>>2]=k[s+16>>2];k[v+20>>2]=k[s+20>>2];k[v+24>>2]=k[s+24>>2];k[v+28>>2]=k[s+28>>2];if(a){k[s>>2]=k[p>>2];k[s+4>>2]=k[p+4>>2];k[s+8>>2]=k[p+8>>2];k[s+12>>2]=k[p+12>>2];k[s+16>>2]=k[p+16>>2];k[s+20>>2]=k[p+20>>2];k[s+24>>2]=k[p+24>>2];j[s+28>>1]=j[p+28>>1]|0;k[p>>2]=k[v>>2];k[p+4>>2]=k[v+4>>2];k[p+8>>2]=k[v+8>>2];k[p+12>>2]=k[v+12>>2];k[p+16>>2]=k[v+16>>2];k[p+20>>2]=k[v+20>>2];k[p+24>>2]=k[v+24>>2];j[p+28>>1]=j[v+28>>1]|0;c=f;l=s;a=1;break};k[s>>2]=k[f>>2];k[s+4>>2]=k[f+4>>2];k[s+8>>2]=k[f+8>>2];k[s+12>>2]=k[f+12>>2];k[s+16>>2]=k[f+16>>2];k[s+20>>2]=k[f+20>>2];k[s+24>>2]=k[f+24>>2];j[s+28>>1]=j[f+28>>1]|0;k[f>>2]=k[v>>2];k[f+4>>2]=k[v+4>>2];k[f+8>>2]=k[v+8>>2];k[f+12>>2]=k[v+12>>2];k[f+16>>2]=k[v+16>>2];k[f+20>>2]=k[v+20>>2];k[f+24>>2]=k[v+24>>2];j[f+28>>1]=j[v+28>>1]|0;a=k[p>>2]|0;c=k[f>>2]|0;if((a|0)>=(c|0)){if((a|0)!=(c|0)){c=f;l=s;a=1;break}if((k[q>>2]|0)>=(k[s+(e<<5)+4>>2]|0)){c=f;l=s;a=1;break}};k[v>>2]=k[f>>2];k[v+4>>2]=k[f+4>>2];k[v+8>>2]=k[f+8>>2];k[v+12>>2]=k[f+12>>2];k[v+16>>2]=k[f+16>>2];k[v+20>>2]=k[f+20>>2];k[v+24>>2]=k[f+24>>2];k[v+28>>2]=k[f+28>>2];k[f>>2]=k[p>>2];k[f+4>>2]=k[p+4>>2];k[f+8>>2]=k[p+8>>2];k[f+12>>2]=k[p+12>>2];k[f+16>>2]=k[p+16>>2];k[f+20>>2]=k[p+20>>2];k[f+24>>2]=k[p+24>>2];j[f+28>>1]=j[p+28>>1]|0;k[p>>2]=k[v>>2];k[p+4>>2]=k[v+4>>2];k[p+8>>2]=k[v+8>>2];k[p+12>>2]=k[v+12>>2];k[p+16>>2]=k[v+16>>2];k[p+20>>2]=k[v+20>>2];k[p+24>>2]=k[v+24>>2];j[p+28>>1]=j[v+28>>1]|0;c=f;l=s;a=2}while(0);i=k[l>>2]|0;h=k[c>>2]|0;c:do if((i|0)<(h|0))d=p;else{if((i|0)==(h|0)?(k[s+4>>2]|0)<(k[s+(e<<5)+4>>2]|0):0){d=p;break}d:do if((s|0)!=(o|0)){g=s+(e<<5)+4|0;d=o;e=p;while(1){c=k[d>>2]|0;if((c|0)<(h|0))break;if((c|0)==(h|0)?(k[e+-28>>2]|0)<(k[g>>2]|0):0)break;c=d+-32|0;if((s|0)==(c|0))break d;else{e=d;d=c}}k[v>>2]=k[s>>2];k[v+4>>2]=k[s+4>>2];k[v+8>>2]=k[s+8>>2];k[v+12>>2]=k[s+12>>2];k[v+16>>2]=k[s+16>>2];k[v+20>>2]=k[s+20>>2];k[v+24>>2]=k[s+24>>2];k[v+28>>2]=k[s+28>>2];k[s>>2]=k[d>>2];k[s+4>>2]=k[d+4>>2];k[s+8>>2]=k[d+8>>2];k[s+12>>2]=k[d+12>>2];k[s+16>>2]=k[d+16>>2];k[s+20>>2]=k[d+20>>2];k[s+24>>2]=k[d+24>>2];j[s+28>>1]=j[d+28>>1]|0;k[d>>2]=k[v>>2];k[d+4>>2]=k[v+4>>2];k[d+8>>2]=k[v+8>>2];k[d+12>>2]=k[v+12>>2];k[d+16>>2]=k[v+16>>2];k[d+20>>2]=k[v+20>>2];k[d+24>>2]=k[v+24>>2];j[d+28>>1]=j[v+28>>1]|0;a=a+1|0;break c}while(0);a=s+32|0;c=k[p>>2]|0;do if((i|0)>=(c|0)){if((i|0)==(c|0)?(k[s+4>>2]|0)<(k[q>>2]|0):0)break;if((a|0)==(p|0)){h=136;break a}e=s+4|0;d=s;while(1){c=k[d+32>>2]|0;if((i|0)<(c|0))break;if((i|0)==(c|0)?(k[e>>2]|0)<(k[d+36>>2]|0):0)break;c=a+32|0;if((c|0)==(p|0)){h=136;break a}else{d=a;a=c}}k[v>>2]=k[a>>2];k[v+4>>2]=k[a+4>>2];k[v+8>>2]=k[a+8>>2];k[v+12>>2]=k[a+12>>2];k[v+16>>2]=k[a+16>>2];k[v+20>>2]=k[a+20>>2];k[v+24>>2]=k[a+24>>2];k[v+28>>2]=k[a+28>>2];k[a>>2]=k[p>>2];k[a+4>>2]=k[p+4>>2];k[a+8>>2]=k[p+8>>2];k[a+12>>2]=k[p+12>>2];k[a+16>>2]=k[p+16>>2];k[a+20>>2]=k[p+20>>2];k[a+24>>2]=k[p+24>>2];j[a+28>>1]=j[p+28>>1]|0;k[p>>2]=k[v>>2];k[p+4>>2]=k[v+4>>2];k[p+8>>2]=k[v+8>>2];k[p+12>>2]=k[v+12>>2];k[p+16>>2]=k[v+16>>2];k[p+20>>2]=k[v+20>>2];k[p+24>>2]=k[v+24>>2];j[p+28>>1]=j[v+28>>1]|0;a=d+64|0}while(0);if((a|0)==(p|0)){h=136;break a}g=s+4|0;e=p;while(1){f=k[l>>2]|0;c=k[a>>2]|0;e:do if((f|0)>=(c|0))do{if((f|0)==(c|0)?(k[g>>2]|0)<(k[a+4>>2]|0):0)break e;a=a+32|0;c=k[a>>2]|0}while((f|0)>=(c|0));while(0);while(1){d=e;e=e+-32|0;c=k[e>>2]|0;if((f|0)<(c|0))continue;if((f|0)!=(c|0))break;if((k[g>>2]|0)>=(k[d+-28>>2]|0))break}if(a>>>0>=e>>>0){s=a;continue b};k[v>>2]=k[a>>2];k[v+4>>2]=k[a+4>>2];k[v+8>>2]=k[a+8>>2];k[v+12>>2]=k[a+12>>2];k[v+16>>2]=k[a+16>>2];k[v+20>>2]=k[a+20>>2];k[v+24>>2]=k[a+24>>2];k[v+28>>2]=k[a+28>>2];k[a>>2]=k[e>>2];k[a+4>>2]=k[e+4>>2];k[a+8>>2]=k[e+8>>2];k[a+12>>2]=k[e+12>>2];k[a+16>>2]=k[e+16>>2];k[a+20>>2]=k[e+20>>2];k[a+24>>2]=k[e+24>>2];j[a+28>>1]=j[e+28>>1]|0;k[e>>2]=k[v>>2];k[e+4>>2]=k[v+4>>2];k[e+8>>2]=k[v+8>>2];k[e+12>>2]=k[v+12>>2];k[e+16>>2]=k[v+16>>2];k[e+20>>2]=k[v+20>>2];k[e+24>>2]=k[v+24>>2];j[e+28>>1]=j[v+28>>1]|0;a=a+32|0}}while(0);c=s+32|0;f:do if(c>>>0<d>>>0){e=d;while(1){g=k[f>>2]|0;h=f+4|0;i=c;while(1){c=k[i>>2]|0;if((c|0)>=(g|0)){if((c|0)!=(g|0))break;if((k[i+4>>2]|0)>=(k[h>>2]|0))break}i=i+32|0}d=e+-32|0;c=k[d>>2]|0;g:do if((c|0)>=(g|0))while(1){if((c|0)==(g|0)?(k[e+-28>>2]|0)<(k[h>>2]|0):0)break g;e=d+-32|0;c=k[e>>2]|0;if((c|0)<(g|0)){d=e;break}else{l=d;d=e;e=l}}while(0);if(i>>>0>d>>>0){c=i;break f};k[v>>2]=k[i>>2];k[v+4>>2]=k[i+4>>2];k[v+8>>2]=k[i+8>>2];k[v+12>>2]=k[i+12>>2];k[v+16>>2]=k[i+16>>2];k[v+20>>2]=k[i+20>>2];k[v+24>>2]=k[i+24>>2];k[v+28>>2]=k[i+28>>2];k[i>>2]=k[d>>2];k[i+4>>2]=k[d+4>>2];k[i+8>>2]=k[d+8>>2];k[i+12>>2]=k[d+12>>2];k[i+16>>2]=k[d+16>>2];k[i+20>>2]=k[d+20>>2];k[i+24>>2]=k[d+24>>2];j[i+28>>1]=j[d+28>>1]|0;k[d>>2]=k[v>>2];k[d+4>>2]=k[v+4>>2];k[d+8>>2]=k[v+8>>2];k[d+12>>2]=k[v+12>>2];k[d+16>>2]=k[v+16>>2];k[d+20>>2]=k[v+20>>2];k[d+24>>2]=k[v+24>>2];j[d+28>>1]=j[v+28>>1]|0;c=i+32|0;e=d;f=(f|0)==(i|0)?d:f;a=a+1|0}}while(0);do if((c|0)!=(f|0)){d=k[f>>2]|0;e=k[c>>2]|0;if((d|0)>=(e|0)){if((d|0)!=(e|0))break;if((k[f+4>>2]|0)>=(k[c+4>>2]|0))break};k[v>>2]=k[c>>2];k[v+4>>2]=k[c+4>>2];k[v+8>>2]=k[c+8>>2];k[v+12>>2]=k[c+12>>2];k[v+16>>2]=k[c+16>>2];k[v+20>>2]=k[c+20>>2];k[v+24>>2]=k[c+24>>2];k[v+28>>2]=k[c+28>>2];k[c>>2]=k[f>>2];k[c+4>>2]=k[f+4>>2];k[c+8>>2]=k[f+8>>2];k[c+12>>2]=k[f+12>>2];k[c+16>>2]=k[f+16>>2];k[c+20>>2]=k[f+20>>2];k[c+24>>2]=k[f+24>>2];j[c+28>>1]=j[f+28>>1]|0;k[f>>2]=k[v>>2];k[f+4>>2]=k[v+4>>2];k[f+8>>2]=k[v+8>>2];k[f+12>>2]=k[v+12>>2];k[f+16>>2]=k[v+16>>2];k[f+20>>2]=k[v+20>>2];k[f+24>>2]=k[v+24>>2];j[f+28>>1]=j[v+28>>1]|0;a=a+1|0}while(0);if(!a){d=xc(s,c)|0;a=c+32|0;if(xc(a,b)|0){h=131;break}if(d){s=a;continue}}l=c;if((l-m|0)>=(n-l|0)){h=135;break}oc(s,c);s=c+32|0}if((h|0)==131)if(d){h=136;break}else{a=s;b=c;continue}else if((h|0)==135){oc(c+32|0,b);a=s;b=c;continue}}if((h|0)==4){a=k[p>>2]|0;b=k[s>>2]|0;if((a|0)>=(b|0)){if((a|0)!=(b|0)){r=w;return}if((k[q>>2]|0)>=(k[s+4>>2]|0)){r=w;return}};k[v>>2]=k[s>>2];k[v+4>>2]=k[s+4>>2];k[v+8>>2]=k[s+8>>2];k[v+12>>2]=k[s+12>>2];k[v+16>>2]=k[s+16>>2];k[v+20>>2]=k[s+20>>2];k[v+24>>2]=k[s+24>>2];k[v+28>>2]=k[s+28>>2];k[s>>2]=k[p>>2];k[s+4>>2]=k[p+4>>2];k[s+8>>2]=k[p+8>>2];k[s+12>>2]=k[p+12>>2];k[s+16>>2]=k[p+16>>2];k[s+20>>2]=k[p+20>>2];k[s+24>>2]=k[p+24>>2];j[s+28>>1]=j[p+28>>1]|0;k[p>>2]=k[v>>2];k[p+4>>2]=k[v+4>>2];k[p+8>>2]=k[v+8>>2];k[p+12>>2]=k[v+12>>2];k[p+16>>2]=k[v+16>>2];k[p+20>>2]=k[v+20>>2];k[p+24>>2]=k[v+24>>2];j[p+28>>1]=j[v+28>>1]|0;r=w;return}else if((h|0)==8){d=s+32|0;b=k[d>>2]|0;a=k[s>>2]|0;if((b|0)>=(a|0))if((b|0)==(a|0))c=(k[s+36>>2]|0)<(k[s+4>>2]|0);else c=0;else c=1;a=k[p>>2]|0;if((a|0)>=(b|0))if((a|0)==(b|0))a=(k[q>>2]|0)<(k[s+36>>2]|0);else a=0;else a=1;if(!c){if(!a){r=w;return};k[v>>2]=k[d>>2];k[v+4>>2]=k[d+4>>2];k[v+8>>2]=k[d+8>>2];k[v+12>>2]=k[d+12>>2];k[v+16>>2]=k[d+16>>2];k[v+20>>2]=k[d+20>>2];k[v+24>>2]=k[d+24>>2];k[v+28>>2]=k[d+28>>2];k[d>>2]=k[p>>2];k[d+4>>2]=k[p+4>>2];k[d+8>>2]=k[p+8>>2];k[d+12>>2]=k[p+12>>2];k[d+16>>2]=k[p+16>>2];k[d+20>>2]=k[p+20>>2];k[d+24>>2]=k[p+24>>2];j[d+28>>1]=j[p+28>>1]|0;k[p>>2]=k[v>>2];k[p+4>>2]=k[v+4>>2];k[p+8>>2]=k[v+8>>2];k[p+12>>2]=k[v+12>>2];k[p+16>>2]=k[v+16>>2];k[p+20>>2]=k[v+20>>2];k[p+24>>2]=k[v+24>>2];j[p+28>>1]=j[v+28>>1]|0;a=k[d>>2]|0;b=k[s>>2]|0;if((a|0)>=(b|0)){if((a|0)!=(b|0)){r=w;return}if((k[s+36>>2]|0)>=(k[s+4>>2]|0)){r=w;return}};k[v>>2]=k[s>>2];k[v+4>>2]=k[s+4>>2];k[v+8>>2]=k[s+8>>2];k[v+12>>2]=k[s+12>>2];k[v+16>>2]=k[s+16>>2];k[v+20>>2]=k[s+20>>2];k[v+24>>2]=k[s+24>>2];k[v+28>>2]=k[s+28>>2];k[s>>2]=k[d>>2];k[s+4>>2]=k[d+4>>2];k[s+8>>2]=k[d+8>>2];k[s+12>>2]=k[d+12>>2];k[s+16>>2]=k[d+16>>2];k[s+20>>2]=k[d+20>>2];k[s+24>>2]=k[d+24>>2];j[s+28>>1]=j[d+28>>1]|0;k[d>>2]=k[v>>2];k[d+4>>2]=k[v+4>>2];k[d+8>>2]=k[v+8>>2];k[d+12>>2]=k[v+12>>2];k[d+16>>2]=k[v+16>>2];k[d+20>>2]=k[v+20>>2];k[d+24>>2]=k[v+24>>2];j[d+28>>1]=j[v+28>>1]|0;r=w;return};k[v>>2]=k[s>>2];k[v+4>>2]=k[s+4>>2];k[v+8>>2]=k[s+8>>2];k[v+12>>2]=k[s+12>>2];k[v+16>>2]=k[s+16>>2];k[v+20>>2]=k[s+20>>2];k[v+24>>2]=k[s+24>>2];k[v+28>>2]=k[s+28>>2];if(a){k[s>>2]=k[p>>2];k[s+4>>2]=k[p+4>>2];k[s+8>>2]=k[p+8>>2];k[s+12>>2]=k[p+12>>2];k[s+16>>2]=k[p+16>>2];k[s+20>>2]=k[p+20>>2];k[s+24>>2]=k[p+24>>2];j[s+28>>1]=j[p+28>>1]|0;k[p>>2]=k[v>>2];k[p+4>>2]=k[v+4>>2];k[p+8>>2]=k[v+8>>2];k[p+12>>2]=k[v+12>>2];k[p+16>>2]=k[v+16>>2];k[p+20>>2]=k[v+20>>2];k[p+24>>2]=k[v+24>>2];j[p+28>>1]=j[v+28>>1]|0;r=w;return};k[s>>2]=k[d>>2];k[s+4>>2]=k[d+4>>2];k[s+8>>2]=k[d+8>>2];k[s+12>>2]=k[d+12>>2];k[s+16>>2]=k[d+16>>2];k[s+20>>2]=k[d+20>>2];k[s+24>>2]=k[d+24>>2];j[s+28>>1]=j[d+28>>1]|0;k[d>>2]=k[v>>2];k[d+4>>2]=k[v+4>>2];k[d+8>>2]=k[v+8>>2];k[d+12>>2]=k[v+12>>2];k[d+16>>2]=k[v+16>>2];k[d+20>>2]=k[v+20>>2];k[d+24>>2]=k[v+24>>2];j[d+28>>1]=j[v+28>>1]|0;a=k[p>>2]|0;b=k[d>>2]|0;if((a|0)>=(b|0)){if((a|0)!=(b|0)){r=w;return}if((k[q>>2]|0)>=(k[s+36>>2]|0)){r=w;return}};k[v>>2]=k[d>>2];k[v+4>>2]=k[d+4>>2];k[v+8>>2]=k[d+8>>2];k[v+12>>2]=k[d+12>>2];k[v+16>>2]=k[d+16>>2];k[v+20>>2]=k[d+20>>2];k[v+24>>2]=k[d+24>>2];k[v+28>>2]=k[d+28>>2];k[d>>2]=k[p>>2];k[d+4>>2]=k[p+4>>2];k[d+8>>2]=k[p+8>>2];k[d+12>>2]=k[p+12>>2];k[d+16>>2]=k[p+16>>2];k[d+20>>2]=k[p+20>>2];k[d+24>>2]=k[p+24>>2];j[d+28>>1]=j[p+28>>1]|0;k[p>>2]=k[v>>2];k[p+4>>2]=k[v+4>>2];k[p+8>>2]=k[v+8>>2];k[p+12>>2]=k[v+12>>2];k[p+16>>2]=k[v+16>>2];k[p+20>>2]=k[v+20>>2];k[p+24>>2]=k[v+24>>2];j[p+28>>1]=j[v+28>>1]|0;r=w;return}else if((h|0)==26){vc(s,s+32|0,s+64|0,p)|0;r=w;return}else if((h|0)==27){wc(s,s+32|0,s+64|0,s+96|0,p)|0;r=w;return}else if((h|0)==29){c=s+64|0;g=s+32|0;a=k[g>>2]|0;e=k[s>>2]|0;if((a|0)>=(e|0))if((a|0)==(e|0))d=(k[s+36>>2]|0)<(k[s+4>>2]|0);else d=0;else d=1;f=k[c>>2]|0;if((f|0)>=(a|0))if((f|0)==(a|0))a=(k[s+68>>2]|0)<(k[s+36>>2]|0);else a=0;else a=1;do if(!d){if(a){k[v>>2]=k[g>>2];k[v+4>>2]=k[g+4>>2];k[v+8>>2]=k[g+8>>2];k[v+12>>2]=k[g+12>>2];k[v+16>>2]=k[g+16>>2];k[v+20>>2]=k[g+20>>2];k[v+24>>2]=k[g+24>>2];k[v+28>>2]=k[g+28>>2];k[g>>2]=k[c>>2];k[g+4>>2]=k[c+4>>2];k[g+8>>2]=k[c+8>>2];k[g+12>>2]=k[c+12>>2];k[g+16>>2]=k[c+16>>2];k[g+20>>2]=k[c+20>>2];k[g+24>>2]=k[c+24>>2];j[g+28>>1]=j[c+28>>1]|0;k[c>>2]=k[v>>2];k[c+4>>2]=k[v+4>>2];k[c+8>>2]=k[v+8>>2];k[c+12>>2]=k[v+12>>2];k[c+16>>2]=k[v+16>>2];k[c+20>>2]=k[v+20>>2];k[c+24>>2]=k[v+24>>2];j[c+28>>1]=j[v+28>>1]|0;a=k[g>>2]|0;if((a|0)>=(e|0)){if((a|0)!=(e|0))break;if((k[s+36>>2]|0)>=(k[s+4>>2]|0))break};k[v>>2]=k[s>>2];k[v+4>>2]=k[s+4>>2];k[v+8>>2]=k[s+8>>2];k[v+12>>2]=k[s+12>>2];k[v+16>>2]=k[s+16>>2];k[v+20>>2]=k[s+20>>2];k[v+24>>2]=k[s+24>>2];k[v+28>>2]=k[s+28>>2];k[s>>2]=k[g>>2];k[s+4>>2]=k[g+4>>2];k[s+8>>2]=k[g+8>>2];k[s+12>>2]=k[g+12>>2];k[s+16>>2]=k[g+16>>2];k[s+20>>2]=k[g+20>>2];k[s+24>>2]=k[g+24>>2];j[s+28>>1]=j[g+28>>1]|0;k[g>>2]=k[v>>2];k[g+4>>2]=k[v+4>>2];k[g+8>>2]=k[v+8>>2];k[g+12>>2]=k[v+12>>2];k[g+16>>2]=k[v+16>>2];k[g+20>>2]=k[v+20>>2];k[g+24>>2]=k[v+24>>2];j[g+28>>1]=j[v+28>>1]|0}}else{k[v>>2]=k[s>>2];k[v+4>>2]=k[s+4>>2];k[v+8>>2]=k[s+8>>2];k[v+12>>2]=k[s+12>>2];k[v+16>>2]=k[s+16>>2];k[v+20>>2]=k[s+20>>2];k[v+24>>2]=k[s+24>>2];k[v+28>>2]=k[s+28>>2];if(a){k[s>>2]=k[c>>2];k[s+4>>2]=k[c+4>>2];k[s+8>>2]=k[c+8>>2];k[s+12>>2]=k[c+12>>2];k[s+16>>2]=k[c+16>>2];k[s+20>>2]=k[c+20>>2];k[s+24>>2]=k[c+24>>2];j[s+28>>1]=j[c+28>>1]|0;k[c>>2]=k[v>>2];k[c+4>>2]=k[v+4>>2];k[c+8>>2]=k[v+8>>2];k[c+12>>2]=k[v+12>>2];k[c+16>>2]=k[v+16>>2];k[c+20>>2]=k[v+20>>2];k[c+24>>2]=k[v+24>>2];j[c+28>>1]=j[v+28>>1]|0;break};k[s>>2]=k[g>>2];k[s+4>>2]=k[g+4>>2];k[s+8>>2]=k[g+8>>2];k[s+12>>2]=k[g+12>>2];k[s+16>>2]=k[g+16>>2];k[s+20>>2]=k[g+20>>2];k[s+24>>2]=k[g+24>>2];j[s+28>>1]=j[g+28>>1]|0;k[g>>2]=k[v>>2];k[g+4>>2]=k[v+4>>2];k[g+8>>2]=k[v+8>>2];k[g+12>>2]=k[v+12>>2];k[g+16>>2]=k[v+16>>2];k[g+20>>2]=k[v+20>>2];k[g+24>>2]=k[v+24>>2];j[g+28>>1]=j[v+28>>1]|0;a=k[g>>2]|0;if((f|0)>=(a|0)){if((f|0)!=(a|0))break;if((k[s+68>>2]|0)>=(k[s+36>>2]|0))break};k[v>>2]=k[g>>2];k[v+4>>2]=k[g+4>>2];k[v+8>>2]=k[g+8>>2];k[v+12>>2]=k[g+12>>2];k[v+16>>2]=k[g+16>>2];k[v+20>>2]=k[g+20>>2];k[v+24>>2]=k[g+24>>2];k[v+28>>2]=k[g+28>>2];k[g>>2]=k[c>>2];k[g+4>>2]=k[c+4>>2];k[g+8>>2]=k[c+8>>2];k[g+12>>2]=k[c+12>>2];k[g+16>>2]=k[c+16>>2];k[g+20>>2]=k[c+20>>2];k[g+24>>2]=k[c+24>>2];j[g+28>>1]=j[c+28>>1]|0;k[c>>2]=k[v>>2];k[c+4>>2]=k[v+4>>2];k[c+8>>2]=k[v+8>>2];k[c+12>>2]=k[v+12>>2];k[c+16>>2]=k[v+16>>2];k[c+20>>2]=k[v+20>>2];k[c+24>>2]=k[v+24>>2];j[c+28>>1]=j[v+28>>1]|0}while(0);a=s+96|0;if((a|0)!=(b|0)){g=a;while(1){f=k[g>>2]|0;a=k[c>>2]|0;if((f|0)>=(a|0)){if((f|0)==(a|0)?(t=k[g+4>>2]|0,(t|0)<(k[c+4>>2]|0)):0){e=t;h=52}}else{e=k[g+4>>2]|0;h=52}if((h|0)==52){h=0;v=g+8|0;k[u>>2]=k[v>>2];k[u+4>>2]=k[v+4>>2];k[u+8>>2]=k[v+8>>2];k[u+12>>2]=k[v+12>>2];k[u+16>>2]=k[v+16>>2];k[u+20>>2]=k[v+20>>2];k[g>>2]=k[c>>2];k[g+4>>2]=k[c+4>>2];k[g+8>>2]=k[c+8>>2];k[g+12>>2]=k[c+12>>2];k[g+16>>2]=k[c+16>>2];k[g+20>>2]=k[c+20>>2];k[g+24>>2]=k[c+24>>2];j[g+28>>1]=j[c+28>>1]|0;h:do if((c|0)==(s|0))a=s;else while(1){a=c;c=c+-32|0;d=k[c>>2]|0;if((f|0)>=(d|0)){if((f|0)!=(d|0))break h;if((e|0)>=(k[a+-28>>2]|0))break h};k[a>>2]=k[c>>2];k[a+4>>2]=k[c+4>>2];k[a+8>>2]=k[c+8>>2];k[a+12>>2]=k[c+12>>2];k[a+16>>2]=k[c+16>>2];k[a+20>>2]=k[c+20>>2];k[a+24>>2]=k[c+24>>2];j[a+28>>1]=j[c+28>>1]|0;if((c|0)==(s|0)){a=s;break}}while(0);k[a>>2]=f;k[a+4>>2]=e;v=a+8|0;k[v>>2]=k[u>>2];k[v+4>>2]=k[u+4>>2];k[v+8>>2]=k[u+8>>2];k[v+12>>2]=k[u+12>>2];k[v+16>>2]=k[u+16>>2];j[v+20>>1]=j[u+20>>1]|0}a=g+32|0;if((a|0)==(b|0))break;else{c=g;g=a}}}r=w;return}else if((h|0)==136){r=w;return}}function pc(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,l=0,m=0,n=0,o=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0;s=b+16|0;e=k[s>>2]|0;f=k[e>>2]|0;g=k[e+4>>2]|0;do if((f|0)!=(g|0)){if((k[c+16>>2]|0)==(k[g+-16>>2]|0)?(k[c+20>>2]|0)==(k[g+-12>>2]|0):0){f=g;break}rc(+p[b>>3],k[b+20>>2]|0,e);e=k[s>>2]|0;f=k[e>>2]|0;g=e+4|0;h=k[g>>2]|0;if((h|0)!=(f|0)){k[g>>2]=h+(~(((h+-44-f|0)>>>0)/44|0)*44|0);f=k[s>>2]|0;e=f;f=k[f+4>>2]|0}}while(0);o=e+4|0;q=e+8|0;g=k[q>>2]|0;if(f>>>0>=g>>>0){r=k[e>>2]|0;h=r;l=f-h|0;m=(l|0)/44|0;n=m+1|0;if(n>>>0>97612893)xa(1340,1363,303,1438);f=(g-h|0)/44|0;if(f>>>0<48806446){f=f<<1;f=f>>>0<n>>>0?n:f;if(!f){f=0;g=0}else w=12}else{f=97612893;w=12}if((w|0)==12){h=f*44|0;h=(h|0)==0?1:h;g=_d(h)|0;a:do if(!g){while(1){g=k[35]|0;k[35]=g+0;if(!g)break;Xa[g&0]();g=_d(h)|0;if(g)break a}b=ya(4)|0;k[b>>2]=128;La(b|0,8,1)}while(0)}h=g+(f*44|0)|0;f=g+(m*44|0)|0;i=c;j=f+44|0;do{k[f>>2]=k[i>>2];f=f+4|0;i=i+4|0}while((f|0)<(j|0));m=g+((((l|0)/-44|0)+m|0)*44|0)|0;fe(m|0,r|0,l|0)|0;k[e>>2]=m;k[o>>2]=g+(n*44|0);k[q>>2]=h;if(r)$d(r)}else{i=c;j=f+44|0;do{k[f>>2]=k[i>>2];f=f+4|0;i=i+4|0}while((f|0)<(j|0));k[o>>2]=(k[o>>2]|0)+44}if(!(!d?(k[c+36>>2]|0)!=0:0))w=21;if((w|0)==21?(rc(+p[b>>3],k[b+20>>2]|0,k[s>>2]|0),u=k[s>>2]|0,t=k[u>>2]|0,u=u+4|0,v=k[u>>2]|0,(v|0)!=(t|0)):0)k[u>>2]=v+(~(((v+-44-t|0)>>>0)/44|0)*44|0);w=k[s>>2]|0;e=k[w+4>>2]|0;if((k[w>>2]|0)==(e|0)){b=(k[(k[(k[b+20>>2]|0)+4>>2]|0)+-8>>2]|0)+-12|0;k[a>>2]=k[b>>2];k[a+4>>2]=k[b+4>>2];k[a+8>>2]=k[b+8>>2];return}else{b=e+-16|0;k[a>>2]=k[b>>2];k[a+4>>2]=k[b+4>>2];k[a+8>>2]=k[b+8>>2];return}}function qc(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0.0,h=0,j=0,l=0,m=0,n=0,o=0.0,q=0;n=b;if(i[b+29>>0]|0){a=1;return a|0}c=k[k[a>>2]>>2]|0;h=k[b+8>>2]|0;e=(h|0)==0;d=(k[c+8>>2]|0)==0;m=k[b>>2]|0;if((!(e^d)?(m|0)==(k[c>>2]|0):0)?(f=k[b+4>>2]|0,(f|0)==(k[c+4>>2]|0)):0){c=k[b+20>>2]|0;l=d^(c|0)==0?2:3}else{l=e&1;c=k[b+20>>2]|0;f=k[b+4>>2]|0}e=k[a+4>>2]|0;d=k[e+8>>2]|0;j=d-h|0;j=(j|0)>-1?j:0-j|0;c=d-c|0;c=(c|0)>-1?c:0-c|0;d=k[e>>2]|0;e=k[e+4>>2]|0;o=+(d-m|0);g=+(e-f|0);g=o*o+g*g;b=a+8|0;h=k[k[b>>2]>>2]|0;if((h|0)>0?(q=m-d|0,+(((q|0)>-1?q:0-q|0)|0)>+p[k[a+12>>2]>>3]):0){q=0;return q|0}do if((l|0)<=(h|0)){if((l|0)!=(h|0)){q=1;return q|0}if((m|0)==(d|0)&(e|0)==(f|0)){if((j|0)<(k[k[a+16>>2]>>2]|0))break;if((j|0)!=(k[k[a+16>>2]>>2]|0)){q=1;return q|0}if((c|0)<(k[k[a+20>>2]>>2]|0))break;if((c|0)!=(k[k[a+20>>2]>>2]|0)){q=1;return q|0}}if(!(g<+p[k[a+12>>2]>>3])){q=1;return q|0}}while(0);k[k[a+24>>2]>>2]=n;k[k[a+16>>2]>>2]=j;k[k[a+20>>2]>>2]=c;p[k[a+12>>2]>>3]=g;k[k[b>>2]>>2]=l;q=1;return q|0}function rc(a,b,c){a=+a;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0,j=0,l=0.0,m=0,n=0,o=0,q=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0;V=r;r=r+160|0;U=V+144|0;g=V+24|0;h=V+16|0;L=V+100|0;M=V+56|0;N=V+8|0;O=V;Q=V+44|0;R=V+32|0;d=k[c>>2]|0;P=c+4|0;f=k[P>>2]|0;if((d|0)==(f|0))l=0.0;else{e=0;do{K=k[d+36>>2]|0;T=k[d+24>>2]|0;T=(K|0)<(T|0)?K:T;e=(T|0)<(e|0)?T:e;d=d+44|0}while((d|0)!=(f|0));l=+(e|0)}k[U>>2]=0;T=U+4|0;k[T>>2]=0;k[U+8>>2]=0;p[g>>3]=0.0;l=-a-l;p[h>>3]=l;j=L+1|0;m=L+2|0;n=L+4|0;o=L+8|0;q=L+12|0;s=L+16|0;t=L+20|0;u=L+24|0;v=L+28|0;w=L+32|0;x=L+36|0;y=L+40|0;z=M+1|0;A=M+2|0;B=M+4|0;C=M+8|0;D=M+12|0;E=M+16|0;F=M+20|0;G=M+24|0;H=M+28|0;I=M+32|0;J=M+36|0;K=M+40|0;d=l>0.0?h:g;g=0;while(1){f=~~+p[d>>3];a:do if(!g){d=k[c>>2]|0;e=k[P>>2]|0;if((d|0)!=(e|0))do{_=k[d+16>>2]|0;Z=k[d+20>>2]|0;Y=(k[d+24>>2]|0)+f|0;X=k[d+28>>2]|0;W=k[d+32>>2]|0;h=(k[d+36>>2]|0)+f|0;i[M>>0]=0;i[z>>0]=0;i[A>>0]=0;k[B>>2]=0;k[C>>2]=0;k[D>>2]=0;k[E>>2]=_;k[F>>2]=Z;k[G>>2]=Y;k[H>>2]=X;k[I>>2]=W;k[J>>2]=h;k[K>>2]=1;sc(U,M);d=d+44|0}while((d|0)!=(e|0))}else{d=k[P>>2]|0;while(1){if((d|0)==(k[c>>2]|0))break a;h=k[d+-16>>2]|0;W=k[d+-12>>2]|0;X=(k[d+-8>>2]|0)+f|0;Y=k[d+-28>>2]|0;Z=k[d+-24>>2]|0;_=(k[d+-20>>2]|0)+f|0;i[L>>0]=0;i[j>>0]=0;i[m>>0]=0;k[n>>2]=0;k[o>>2]=0;k[q>>2]=0;k[s>>2]=h;k[t>>2]=W;k[u>>2]=X;k[v>>2]=Y;k[w>>2]=Z;k[x>>2]=_;k[y>>2]=1;sc(U,L);d=d+-44|0}}while(0);if(!f)break;p[N>>3]=0.0;l=+(f|0)-a;p[O>>3]=l;d=l>0.0?O:N;g=g^1}d=k[U>>2]|0;if(k[d+8>>2]|0){_=k[d+4>>2]|0;k[Q>>2]=k[d>>2];k[Q+4>>2]=_;k[Q+8>>2]=0;tc(U,d,Q)}d=k[T>>2]|0;if(k[d+-4>>2]|0){_=k[d+-8>>2]|0;k[R>>2]=k[d+-12>>2];k[R+4>>2]=_;k[R+8>>2]=0;tc(U,d,R)}o=b+4|0;d=k[o>>2]|0;q=b+8|0;e=k[q>>2]|0;if(d>>>0<e>>>0){k[d>>2]=k[U>>2];k[d+4>>2]=k[T>>2];_=U+8|0;k[d+8>>2]=k[_>>2];k[_>>2]=0;k[T>>2]=0;k[U>>2]=0;k[o>>2]=(k[o>>2]|0)+12;r=V;return}f=k[b>>2]|0;g=(d-f|0)/12|0;j=g+1|0;if(j>>>0>357913941)xa(1340,1363,303,1438);d=(e-f|0)/12|0;if(d>>>0<178956970){d=d<<1;d=d>>>0<j>>>0?j:d;if(!d){d=0;e=0}else S=23}else{d=357913941;S=23}if((S|0)==23){f=d*12|0;f=(f|0)==0?1:f;e=_d(f)|0;b:do if(!e){while(1){e=k[35]|0;k[35]=e+0;if(!e)break;Xa[e&0]();e=_d(f)|0;if(e)break b}_=ya(4)|0;k[_>>2]=128;La(_|0,8,1)}while(0)}h=e+(g*12|0)|0;f=h;n=e+(d*12|0)|0;k[e+(g*12|0)+8>>2]=0;k[h>>2]=k[U>>2];k[e+(g*12|0)+4>>2]=k[T>>2];d=U+8|0;k[e+(g*12|0)+8>>2]=k[d>>2];k[d>>2]=0;k[T>>2]=0;k[U>>2]=0;j=e+(j*12|0)|0;g=k[b>>2]|0;d=k[o>>2]|0;if((d|0)==(g|0)){d=g;g=b;h=o;e=f;m=d}else{e=h;do{_=e+-12|0;Z=d;d=d+-12|0;k[_>>2]=0;Y=e+-8|0;k[Y>>2]=0;k[e+-4>>2]=0;k[_>>2]=k[d>>2];_=Z+-8|0;k[Y>>2]=k[_>>2];Z=Z+-4|0;k[e+-4>>2]=k[Z>>2];k[Z>>2]=0;k[_>>2]=0;k[d>>2]=0;e=f+-12|0;f=e}while((d|0)!=(g|0));g=b;h=o;e=f;m=k[b>>2]|0;d=k[o>>2]|0}k[g>>2]=e;k[h>>2]=j;k[q>>2]=n;j=m;if((d|0)!=(j|0))do{e=d;d=d+-12|0;g=k[d>>2]|0;h=g;if(g){e=e+-8|0;f=k[e>>2]|0;if((f|0)!=(g|0))k[e>>2]=f+(~(((f+-12-h|0)>>>0)/12|0)*12|0);$d(g)}}while((d|0)!=(j|0));if(m)$d(m);d=k[U>>2]|0;if(!d){r=V;return}e=k[T>>2]|0;if((e|0)!=(d|0))k[T>>2]=e+(~(((e+-12-d|0)>>>0)/12|0)*12|0);$d(d);r=V;return}function sc(a,b){a=a|0;b=b|0;var c=0,d=0,e=0;e=a+4|0;d=k[e>>2]|0;if(!((((k[a>>2]|0)!=(d|0)?(k[d+-12>>2]|0)==(k[b+16>>2]|0):0)?(k[d+-8>>2]|0)==(k[b+20>>2]|0):0)?(k[d+-4>>2]|0)==(k[b+24>>2]|0):0))c=5;do if((c|0)==5){c=b+16|0;if((d|0)==(k[a+8>>2]|0)){uc(a,c);d=k[e>>2]|0;break}else{k[d>>2]=k[c>>2];k[d+4>>2]=k[c+4>>2];k[d+8>>2]=k[c+8>>2];d=(k[e>>2]|0)+12|0;k[e>>2]=d;break}}while(0);if((((k[a>>2]|0)!=(d|0)?(k[d+-12>>2]|0)==(k[b+28>>2]|0):0)?(k[d+-8>>2]|0)==(k[b+32>>2]|0):0)?(k[d+-4>>2]|0)==(k[b+36>>2]|0):0)return;c=b+28|0;if((d|0)==(k[a+8>>2]|0)){uc(a,c);return}else{k[d>>2]=k[c>>2];k[d+4>>2]=k[c+4>>2];k[d+8>>2]=k[c+8>>2];k[e>>2]=(k[e>>2]|0)+12;return}}function tc(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,l=0,m=0,n=0,o=0,p=0;m=k[a>>2]|0;n=b;d=m;j=n-d|0;l=(j|0)/12|0;p=a+4|0;g=k[p>>2]|0;o=a+8|0;f=k[o>>2]|0;if(g>>>0<f>>>0){if((g|0)==(b|0)){k[b>>2]=k[c>>2];k[b+4>>2]=k[c+4>>2];k[b+8>>2]=k[c+8>>2];k[p>>2]=(k[p>>2]|0)+12;return}f=g-(m+((l+1|0)*12|0))|0;d=b+(((f|0)/12|0)*12|0)|0;if(d>>>0<g>>>0){e=g;do{k[e>>2]=k[d>>2];k[e+4>>2]=k[d+4>>2];k[e+8>>2]=k[d+8>>2];d=d+12|0;e=(k[p>>2]|0)+12|0;k[p>>2]=e}while(d>>>0<g>>>0)}he(g+(((f|0)/-12|0)*12|0)|0,b|0,f|0)|0;k[b>>2]=k[c>>2];k[b+4>>2]=k[c+4>>2];k[b+8>>2]=k[c+8>>2];return}e=((g-d|0)/12|0)+1|0;if(e>>>0>357913941)xa(1340,1363,303,1438);d=(f-d|0)/12|0;if(d>>>0<178956970){d=d<<1;d=d>>>0<e>>>0?e:d;if(!d){d=0;i=0}else h=11}else{d=357913941;h=11}if((h|0)==11){f=d*12|0;f=(f|0)==0?1:f;e=_d(f)|0;a:do if(!e){while(1){e=k[35]|0;k[35]=e+0;if(!e)break;Xa[e&0]();e=_d(f)|0;if(e)break a}p=ya(4)|0;k[p>>2]=128;La(p|0,8,1)}while(0);i=e}f=i+(l*12|0)|0;g=f;e=i+(d*12|0)|0;do if((l|0)==(d|0)){if((j|0)>0){g=i+((((l+1|0)/-2|0)+l|0)*12|0)|0;f=g;d=m;break}h=(m|0)==(b|0)?1:l<<1;f=h>>>2;if(!h)d=0;else{e=h*12|0;e=(e|0)==0?1:e;d=_d(e)|0;b:do if(!d){while(1){d=k[35]|0;k[35]=d+0;if(!d)break;Xa[d&0]();d=_d(e)|0;if(d)break b}p=ya(4)|0;k[p>>2]=128;La(p|0,8,1)}while(0)}f=d+(f*12|0)|0;g=f;e=d+(h*12|0)|0;if(!i)d=m;else{$d(i);d=k[a>>2]|0}}else d=m;while(0);k[f>>2]=k[c>>2];k[f+4>>2]=k[c+4>>2];k[f+8>>2]=k[c+8>>2];m=g;c=n-d|0;l=m+(((c|0)/-12|0)*12|0)|0;fe(l|0,d|0,c|0)|0;c=(k[p>>2]|0)-n|0;fe(m+12|0,b|0,c|0)|0;d=k[a>>2]|0;k[a>>2]=l;k[p>>2]=m+((((c|0)/12|0)+1|0)*12|0);k[o>>2]=e;if(!d)return;$d(d);return}function uc(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,l=0;f=a+4|0;g=k[a>>2]|0;c=g;h=(k[f>>2]|0)-c|0;i=(h|0)/12|0;j=i+1|0;if(j>>>0>357913941)xa(1340,1363,303,1438);l=a+8|0;c=((k[l>>2]|0)-c|0)/12|0;if(c>>>0<178956970){c=c<<1;c=c>>>0<j>>>0?j:c;if(!c){c=0;d=0}else e=5}else{c=357913941;e=5}if((e|0)==5){e=c*12|0;e=(e|0)==0?1:e;d=_d(e)|0;a:do if(!d){while(1){d=k[35]|0;k[35]=d+0;if(!d)break;Xa[d&0]();d=_d(e)|0;if(d)break a}a=ya(4)|0;k[a>>2]=128;La(a|0,8,1)}while(0)}e=d+(i*12|0)|0;k[e>>2]=k[b>>2];k[e+4>>2]=k[b+4>>2];k[e+8>>2]=k[b+8>>2];b=d+((((h|0)/-12|0)+i|0)*12|0)|0;fe(b|0,g|0,h|0)|0;k[a>>2]=b;k[f>>2]=d+(j*12|0);k[l>>2]=d+(c*12|0);if(!g)return;$d(g);return}function vc(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,l=0;l=r;r=r+32|0;i=l;f=k[b>>2]|0;e=k[a>>2]|0;if((f|0)>=(e|0))if((f|0)==(e|0))g=(k[b+4>>2]|0)<(k[a+4>>2]|0);else g=0;else g=1;e=k[c>>2]|0;if((e|0)>=(f|0))if((e|0)==(f|0))e=(k[c+4>>2]|0)<(k[b+4>>2]|0);else e=0;else e=1;do if(!g)if(e){k[i>>2]=k[b>>2];k[i+4>>2]=k[b+4>>2];k[i+8>>2]=k[b+8>>2];k[i+12>>2]=k[b+12>>2];k[i+16>>2]=k[b+16>>2];k[i+20>>2]=k[b+20>>2];k[i+24>>2]=k[b+24>>2];k[i+28>>2]=k[b+28>>2];k[b>>2]=k[c>>2];k[b+4>>2]=k[c+4>>2];k[b+8>>2]=k[c+8>>2];k[b+12>>2]=k[c+12>>2];k[b+16>>2]=k[c+16>>2];k[b+20>>2]=k[c+20>>2];k[b+24>>2]=k[c+24>>2];j[b+28>>1]=j[c+28>>1]|0;k[c>>2]=k[i>>2];k[c+4>>2]=k[i+4>>2];k[c+8>>2]=k[i+8>>2];k[c+12>>2]=k[i+12>>2];k[c+16>>2]=k[i+16>>2];k[c+20>>2]=k[i+20>>2];k[c+24>>2]=k[i+24>>2];j[c+28>>1]=j[i+28>>1]|0;e=k[b>>2]|0;f=k[a>>2]|0;if((e|0)>=(f|0)){if((e|0)!=(f|0)){h=1;break}if((k[b+4>>2]|0)>=(k[a+4>>2]|0)){h=1;break}};k[i>>2]=k[a>>2];k[i+4>>2]=k[a+4>>2];k[i+8>>2]=k[a+8>>2];k[i+12>>2]=k[a+12>>2];k[i+16>>2]=k[a+16>>2];k[i+20>>2]=k[a+20>>2];k[i+24>>2]=k[a+24>>2];k[i+28>>2]=k[a+28>>2];k[a>>2]=k[b>>2];k[a+4>>2]=k[b+4>>2];k[a+8>>2]=k[b+8>>2];k[a+12>>2]=k[b+12>>2];k[a+16>>2]=k[b+16>>2];k[a+20>>2]=k[b+20>>2];k[a+24>>2]=k[b+24>>2];j[a+28>>1]=j[b+28>>1]|0;k[b>>2]=k[i>>2];k[b+4>>2]=k[i+4>>2];k[b+8>>2]=k[i+8>>2];k[b+12>>2]=k[i+12>>2];k[b+16>>2]=k[i+16>>2];k[b+20>>2]=k[i+20>>2];k[b+24>>2]=k[i+24>>2];j[b+28>>1]=j[i+28>>1]|0;h=2}else h=0;else{k[i>>2]=k[a>>2];k[i+4>>2]=k[a+4>>2];k[i+8>>2]=k[a+8>>2];k[i+12>>2]=k[a+12>>2];k[i+16>>2]=k[a+16>>2];k[i+20>>2]=k[a+20>>2];k[i+24>>2]=k[a+24>>2];k[i+28>>2]=k[a+28>>2];if(e){k[a>>2]=k[c>>2];k[a+4>>2]=k[c+4>>2];k[a+8>>2]=k[c+8>>2];k[a+12>>2]=k[c+12>>2];k[a+16>>2]=k[c+16>>2];k[a+20>>2]=k[c+20>>2];k[a+24>>2]=k[c+24>>2];j[a+28>>1]=j[c+28>>1]|0;k[c>>2]=k[i>>2];k[c+4>>2]=k[i+4>>2];k[c+8>>2]=k[i+8>>2];k[c+12>>2]=k[i+12>>2];k[c+16>>2]=k[i+16>>2];k[c+20>>2]=k[i+20>>2];k[c+24>>2]=k[i+24>>2];j[c+28>>1]=j[i+28>>1]|0;h=1;break};k[a>>2]=k[b>>2];k[a+4>>2]=k[b+4>>2];k[a+8>>2]=k[b+8>>2];k[a+12>>2]=k[b+12>>2];k[a+16>>2]=k[b+16>>2];k[a+20>>2]=k[b+20>>2];k[a+24>>2]=k[b+24>>2];j[a+28>>1]=j[b+28>>1]|0;k[b>>2]=k[i>>2];k[b+4>>2]=k[i+4>>2];k[b+8>>2]=k[i+8>>2];k[b+12>>2]=k[i+12>>2];k[b+16>>2]=k[i+16>>2];k[b+20>>2]=k[i+20>>2];k[b+24>>2]=k[i+24>>2];j[b+28>>1]=j[i+28>>1]|0;e=k[c>>2]|0;f=k[b>>2]|0;if((e|0)>=(f|0)){if((e|0)!=(f|0)){h=1;break}if((k[c+4>>2]|0)>=(k[b+4>>2]|0)){h=1;break}};k[i>>2]=k[b>>2];k[i+4>>2]=k[b+4>>2];k[i+8>>2]=k[b+8>>2];k[i+12>>2]=k[b+12>>2];k[i+16>>2]=k[b+16>>2];k[i+20>>2]=k[b+20>>2];k[i+24>>2]=k[b+24>>2];k[i+28>>2]=k[b+28>>2];k[b>>2]=k[c>>2];k[b+4>>2]=k[c+4>>2];k[b+8>>2]=k[c+8>>2];k[b+12>>2]=k[c+12>>2];k[b+16>>2]=k[c+16>>2];k[b+20>>2]=k[c+20>>2];k[b+24>>2]=k[c+24>>2];j[b+28>>1]=j[c+28>>1]|0;k[c>>2]=k[i>>2];k[c+4>>2]=k[i+4>>2];k[c+8>>2]=k[i+8>>2];k[c+12>>2]=k[i+12>>2];k[c+16>>2]=k[i+16>>2];k[c+20>>2]=k[i+20>>2];k[c+24>>2]=k[i+24>>2];j[c+28>>1]=j[i+28>>1]|0;h=2}while(0);e=k[d>>2]|0;f=k[c>>2]|0;if((e|0)>=(f|0)){if((e|0)!=(f|0)){b=h;r=l;return b|0}if((k[d+4>>2]|0)>=(k[c+4>>2]|0)){b=h;r=l;return b|0}};k[i>>2]=k[c>>2];k[i+4>>2]=k[c+4>>2];k[i+8>>2]=k[c+8>>2];k[i+12>>2]=k[c+12>>2];k[i+16>>2]=k[c+16>>2];k[i+20>>2]=k[c+20>>2];k[i+24>>2]=k[c+24>>2];k[i+28>>2]=k[c+28>>2];k[c>>2]=k[d>>2];k[c+4>>2]=k[d+4>>2];k[c+8>>2]=k[d+8>>2];k[c+12>>2]=k[d+12>>2];k[c+16>>2]=k[d+16>>2];k[c+20>>2]=k[d+20>>2];k[c+24>>2]=k[d+24>>2];j[c+28>>1]=j[d+28>>1]|0;k[d>>2]=k[i>>2];k[d+4>>2]=k[i+4>>2];k[d+8>>2]=k[i+8>>2];k[d+12>>2]=k[i+12>>2];k[d+16>>2]=k[i+16>>2];k[d+20>>2]=k[i+20>>2];k[d+24>>2]=k[i+24>>2];j[d+28>>1]=j[i+28>>1]|0;e=h+1|0;f=k[c>>2]|0;g=k[b>>2]|0;if((f|0)>=(g|0)){if((f|0)!=(g|0)){b=e;r=l;return b|0}if((k[c+4>>2]|0)>=(k[b+4>>2]|0)){b=e;r=l;return b|0}};k[i>>2]=k[b>>2];k[i+4>>2]=k[b+4>>2];k[i+8>>2]=k[b+8>>2];k[i+12>>2]=k[b+12>>2];k[i+16>>2]=k[b+16>>2];k[i+20>>2]=k[b+20>>2];k[i+24>>2]=k[b+24>>2];k[i+28>>2]=k[b+28>>2];k[b>>2]=k[c>>2];k[b+4>>2]=k[c+4>>2];k[b+8>>2]=k[c+8>>2];k[b+12>>2]=k[c+12>>2];k[b+16>>2]=k[c+16>>2];k[b+20>>2]=k[c+20>>2];k[b+24>>2]=k[c+24>>2];j[b+28>>1]=j[c+28>>1]|0;k[c>>2]=k[i>>2];k[c+4>>2]=k[i+4>>2];k[c+8>>2]=k[i+8>>2];k[c+12>>2]=k[i+12>>2];k[c+16>>2]=k[i+16>>2];k[c+20>>2]=k[i+20>>2];k[c+24>>2]=k[i+24>>2];j[c+28>>1]=j[i+28>>1]|0;e=h+2|0;f=k[b>>2]|0;g=k[a>>2]|0;if((f|0)>=(g|0)){if((f|0)!=(g|0)){b=e;r=l;return b|0}if((k[b+4>>2]|0)>=(k[a+4>>2]|0)){b=e;r=l;return b|0}};k[i>>2]=k[a>>2];k[i+4>>2]=k[a+4>>2];k[i+8>>2]=k[a+8>>2];k[i+12>>2]=k[a+12>>2];k[i+16>>2]=k[a+16>>2];k[i+20>>2]=k[a+20>>2];k[i+24>>2]=k[a+24>>2];k[i+28>>2]=k[a+28>>2];k[a>>2]=k[b>>2];k[a+4>>2]=k[b+4>>2];k[a+8>>2]=k[b+8>>2];k[a+12>>2]=k[b+12>>2];k[a+16>>2]=k[b+16>>2];k[a+20>>2]=k[b+20>>2];k[a+24>>2]=k[b+24>>2];j[a+28>>1]=j[b+28>>1]|0;k[b>>2]=k[i>>2];k[b+4>>2]=k[i+4>>2];k[b+8>>2]=k[i+8>>2];k[b+12>>2]=k[i+12>>2];k[b+16>>2]=k[i+16>>2];k[b+20>>2]=k[i+20>>2];k[b+24>>2]=k[i+24>>2];j[b+28>>1]=j[i+28>>1]|0;b=h+3|0;r=l;return b|0}function wc(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0,l=0;l=r;r=r+32|0;i=l;h=vc(a,b,c,d)|0;f=k[e>>2]|0;g=k[d>>2]|0;if((f|0)>=(g|0)){if((f|0)!=(g|0)){b=h;r=l;return b|0}if((k[e+4>>2]|0)>=(k[d+4>>2]|0)){b=h;r=l;return b|0}};k[i>>2]=k[d>>2];k[i+4>>2]=k[d+4>>2];k[i+8>>2]=k[d+8>>2];k[i+12>>2]=k[d+12>>2];k[i+16>>2]=k[d+16>>2];k[i+20>>2]=k[d+20>>2];k[i+24>>2]=k[d+24>>2];k[i+28>>2]=k[d+28>>2];k[d>>2]=k[e>>2];k[d+4>>2]=k[e+4>>2];k[d+8>>2]=k[e+8>>2];k[d+12>>2]=k[e+12>>2];k[d+16>>2]=k[e+16>>2];k[d+20>>2]=k[e+20>>2];k[d+24>>2]=k[e+24>>2];j[d+28>>1]=j[e+28>>1]|0;k[e>>2]=k[i>>2];k[e+4>>2]=k[i+4>>2];k[e+8>>2]=k[i+8>>2];k[e+12>>2]=k[i+12>>2];k[e+16>>2]=k[i+16>>2];k[e+20>>2]=k[i+20>>2];k[e+24>>2]=k[i+24>>2];j[e+28>>1]=j[i+28>>1]|0;f=h+1|0;g=k[d>>2]|0;e=k[c>>2]|0;if((g|0)>=(e|0)){if((g|0)!=(e|0)){b=f;r=l;return b|0}if((k[d+4>>2]|0)>=(k[c+4>>2]|0)){b=f;r=l;return b|0}};k[i>>2]=k[c>>2];k[i+4>>2]=k[c+4>>2];k[i+8>>2]=k[c+8>>2];k[i+12>>2]=k[c+12>>2];k[i+16>>2]=k[c+16>>2];k[i+20>>2]=k[c+20>>2];k[i+24>>2]=k[c+24>>2];k[i+28>>2]=k[c+28>>2];k[c>>2]=k[d>>2];k[c+4>>2]=k[d+4>>2];k[c+8>>2]=k[d+8>>2];k[c+12>>2]=k[d+12>>2];k[c+16>>2]=k[d+16>>2];k[c+20>>2]=k[d+20>>2];k[c+24>>2]=k[d+24>>2];j[c+28>>1]=j[d+28>>1]|0;k[d>>2]=k[i>>2];k[d+4>>2]=k[i+4>>2];k[d+8>>2]=k[i+8>>2];k[d+12>>2]=k[i+12>>2];k[d+16>>2]=k[i+16>>2];k[d+20>>2]=k[i+20>>2];k[d+24>>2]=k[i+24>>2];j[d+28>>1]=j[i+28>>1]|0;f=h+2|0;g=k[c>>2]|0;e=k[b>>2]|0;if((g|0)>=(e|0)){if((g|0)!=(e|0)){b=f;r=l;return b|0}if((k[c+4>>2]|0)>=(k[b+4>>2]|0)){b=f;r=l;return b|0}};k[i>>2]=k[b>>2];k[i+4>>2]=k[b+4>>2];k[i+8>>2]=k[b+8>>2];k[i+12>>2]=k[b+12>>2];k[i+16>>2]=k[b+16>>2];k[i+20>>2]=k[b+20>>2];k[i+24>>2]=k[b+24>>2];k[i+28>>2]=k[b+28>>2];k[b>>2]=k[c>>2];k[b+4>>2]=k[c+4>>2];k[b+8>>2]=k[c+8>>2];k[b+12>>2]=k[c+12>>2];k[b+16>>2]=k[c+16>>2];k[b+20>>2]=k[c+20>>2];k[b+24>>2]=k[c+24>>2];j[b+28>>1]=j[c+28>>1]|0;k[c>>2]=k[i>>2];k[c+4>>2]=k[i+4>>2];k[c+8>>2]=k[i+8>>2];k[c+12>>2]=k[i+12>>2];k[c+16>>2]=k[i+16>>2];k[c+20>>2]=k[i+20>>2];k[c+24>>2]=k[i+24>>2];j[c+28>>1]=j[i+28>>1]|0;f=h+3|0;g=k[b>>2]|0;e=k[a>>2]|0;if((g|0)>=(e|0)){if((g|0)!=(e|0)){b=f;r=l;return b|0}if((k[b+4>>2]|0)>=(k[a+4>>2]|0)){b=f;r=l;return b|0}};k[i>>2]=k[a>>2];k[i+4>>2]=k[a+4>>2];k[i+8>>2]=k[a+8>>2];k[i+12>>2]=k[a+12>>2];k[i+16>>2]=k[a+16>>2];k[i+20>>2]=k[a+20>>2];k[i+24>>2]=k[a+24>>2];k[i+28>>2]=k[a+28>>2];k[a>>2]=k[b>>2];k[a+4>>2]=k[b+4>>2];k[a+8>>2]=k[b+8>>2];k[a+12>>2]=k[b+12>>2];k[a+16>>2]=k[b+16>>2];k[a+20>>2]=k[b+20>>2];k[a+24>>2]=k[b+24>>2];j[a+28>>1]=j[b+28>>1]|0;k[b>>2]=k[i>>2];k[b+4>>2]=k[i+4>>2];k[b+8>>2]=k[i+8>>2];k[b+12>>2]=k[i+12>>2];k[b+16>>2]=k[i+16>>2];k[b+20>>2]=k[i+20>>2];k[b+24>>2]=k[i+24>>2];j[b+28>>1]=j[i+28>>1]|0;b=h+4|0;r=l;return b|0}function xc(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0,l=0,m=0,n=0,o=0;o=r;r=r+64|0;i=o+24|0;m=o;switch(b-a>>5|0){case 2:{c=b+-32|0;d=k[c>>2]|0;e=k[a>>2]|0;if((d|0)>=(e|0)){if((d|0)!=(e|0)){a=1;r=o;return a|0}if((k[b+-28>>2]|0)>=(k[a+4>>2]|0)){a=1;r=o;return a|0}};k[i>>2]=k[a>>2];k[i+4>>2]=k[a+4>>2];k[i+8>>2]=k[a+8>>2];k[i+12>>2]=k[a+12>>2];k[i+16>>2]=k[a+16>>2];k[i+20>>2]=k[a+20>>2];k[i+24>>2]=k[a+24>>2];k[i+28>>2]=k[a+28>>2];k[a>>2]=k[c>>2];k[a+4>>2]=k[c+4>>2];k[a+8>>2]=k[c+8>>2];k[a+12>>2]=k[c+12>>2];k[a+16>>2]=k[c+16>>2];k[a+20>>2]=k[c+20>>2];k[a+24>>2]=k[c+24>>2];j[a+28>>1]=j[c+28>>1]|0;k[c>>2]=k[i>>2];k[c+4>>2]=k[i+4>>2];k[c+8>>2]=k[i+8>>2];k[c+12>>2]=k[i+12>>2];k[c+16>>2]=k[i+16>>2];k[c+20>>2]=k[i+20>>2];k[c+24>>2]=k[i+24>>2];j[c+28>>1]=j[i+28>>1]|0;a=1;r=o;return a|0}case 3:{g=a+32|0;f=b+-32|0;e=k[g>>2]|0;c=k[a>>2]|0;if((e|0)>=(c|0))if((e|0)==(c|0))d=(k[a+36>>2]|0)<(k[a+4>>2]|0);else d=0;else d=1;c=k[f>>2]|0;if((c|0)>=(e|0))if((c|0)==(e|0))c=(k[b+-28>>2]|0)<(k[a+36>>2]|0);else c=0;else c=1;if(!d){if(!c){a=1;r=o;return a|0};k[i>>2]=k[g>>2];k[i+4>>2]=k[g+4>>2];k[i+8>>2]=k[g+8>>2];k[i+12>>2]=k[g+12>>2];k[i+16>>2]=k[g+16>>2];k[i+20>>2]=k[g+20>>2];k[i+24>>2]=k[g+24>>2];k[i+28>>2]=k[g+28>>2];k[g>>2]=k[f>>2];k[g+4>>2]=k[f+4>>2];k[g+8>>2]=k[f+8>>2];k[g+12>>2]=k[f+12>>2];k[g+16>>2]=k[f+16>>2];k[g+20>>2]=k[f+20>>2];k[g+24>>2]=k[f+24>>2];j[g+28>>1]=j[f+28>>1]|0;k[f>>2]=k[i>>2];k[f+4>>2]=k[i+4>>2];k[f+8>>2]=k[i+8>>2];k[f+12>>2]=k[i+12>>2];k[f+16>>2]=k[i+16>>2];k[f+20>>2]=k[i+20>>2];k[f+24>>2]=k[i+24>>2];j[f+28>>1]=j[i+28>>1]|0;c=k[g>>2]|0;d=k[a>>2]|0;if((c|0)>=(d|0)){if((c|0)!=(d|0)){a=1;r=o;return a|0}if((k[a+36>>2]|0)>=(k[a+4>>2]|0)){a=1;r=o;return a|0}};k[i>>2]=k[a>>2];k[i+4>>2]=k[a+4>>2];k[i+8>>2]=k[a+8>>2];k[i+12>>2]=k[a+12>>2];k[i+16>>2]=k[a+16>>2];k[i+20>>2]=k[a+20>>2];k[i+24>>2]=k[a+24>>2];k[i+28>>2]=k[a+28>>2];k[a>>2]=k[g>>2];k[a+4>>2]=k[g+4>>2];k[a+8>>2]=k[g+8>>2];k[a+12>>2]=k[g+12>>2];k[a+16>>2]=k[g+16>>2];k[a+20>>2]=k[g+20>>2];k[a+24>>2]=k[g+24>>2];j[a+28>>1]=j[g+28>>1]|0;k[g>>2]=k[i>>2];k[g+4>>2]=k[i+4>>2];k[g+8>>2]=k[i+8>>2];k[g+12>>2]=k[i+12>>2];k[g+16>>2]=k[i+16>>2];k[g+20>>2]=k[i+20>>2];k[g+24>>2]=k[i+24>>2];j[g+28>>1]=j[i+28>>1]|0;a=1;r=o;return a|0};k[i>>2]=k[a>>2];k[i+4>>2]=k[a+4>>2];k[i+8>>2]=k[a+8>>2];k[i+12>>2]=k[a+12>>2];k[i+16>>2]=k[a+16>>2];k[i+20>>2]=k[a+20>>2];k[i+24>>2]=k[a+24>>2];k[i+28>>2]=k[a+28>>2];if(c){k[a>>2]=k[f>>2];k[a+4>>2]=k[f+4>>2];k[a+8>>2]=k[f+8>>2];k[a+12>>2]=k[f+12>>2];k[a+16>>2]=k[f+16>>2];k[a+20>>2]=k[f+20>>2];k[a+24>>2]=k[f+24>>2];j[a+28>>1]=j[f+28>>1]|0;k[f>>2]=k[i>>2];k[f+4>>2]=k[i+4>>2];k[f+8>>2]=k[i+8>>2];k[f+12>>2]=k[i+12>>2];k[f+16>>2]=k[i+16>>2];k[f+20>>2]=k[i+20>>2];k[f+24>>2]=k[i+24>>2];j[f+28>>1]=j[i+28>>1]|0;a=1;r=o;return a|0};k[a>>2]=k[g>>2];k[a+4>>2]=k[g+4>>2];k[a+8>>2]=k[g+8>>2];k[a+12>>2]=k[g+12>>2];k[a+16>>2]=k[g+16>>2];k[a+20>>2]=k[g+20>>2];k[a+24>>2]=k[g+24>>2];j[a+28>>1]=j[g+28>>1]|0;k[g>>2]=k[i>>2];k[g+4>>2]=k[i+4>>2];k[g+8>>2]=k[i+8>>2];k[g+12>>2]=k[i+12>>2];k[g+16>>2]=k[i+16>>2];k[g+20>>2]=k[i+20>>2];k[g+24>>2]=k[i+24>>2];j[g+28>>1]=j[i+28>>1]|0;c=k[f>>2]|0;d=k[g>>2]|0;if((c|0)>=(d|0)){if((c|0)!=(d|0)){a=1;r=o;return a|0}if((k[b+-28>>2]|0)>=(k[a+36>>2]|0)){a=1;r=o;return a|0}};k[i>>2]=k[g>>2];k[i+4>>2]=k[g+4>>2];k[i+8>>2]=k[g+8>>2];k[i+12>>2]=k[g+12>>2];k[i+16>>2]=k[g+16>>2];k[i+20>>2]=k[g+20>>2];k[i+24>>2]=k[g+24>>2];k[i+28>>2]=k[g+28>>2];k[g>>2]=k[f>>2];k[g+4>>2]=k[f+4>>2];k[g+8>>2]=k[f+8>>2];k[g+12>>2]=k[f+12>>2];k[g+16>>2]=k[f+16>>2];k[g+20>>2]=k[f+20>>2];k[g+24>>2]=k[f+24>>2];j[g+28>>1]=j[f+28>>1]|0;k[f>>2]=k[i>>2];k[f+4>>2]=k[i+4>>2];k[f+8>>2]=k[i+8>>2];k[f+12>>2]=k[i+12>>2];k[f+16>>2]=k[i+16>>2];k[f+20>>2]=k[i+20>>2];k[f+24>>2]=k[i+24>>2];j[f+28>>1]=j[i+28>>1]|0;a=1;r=o;return a|0}case 4:{vc(a,a+32|0,a+64|0,b+-32|0)|0;a=1;r=o;return a|0}case 5:{wc(a,a+32|0,a+64|0,a+96|0,b+-32|0)|0;a=1;r=o;return a|0}case 1:case 0:{a=1;r=o;return a|0}default:{f=a+64|0;h=a+32|0;c=k[h>>2]|0;e=k[a>>2]|0;if((c|0)>=(e|0))if((c|0)==(e|0))d=(k[a+36>>2]|0)<(k[a+4>>2]|0);else d=0;else d=1;g=k[f>>2]|0;if((g|0)>=(c|0))if((g|0)==(c|0))c=(k[a+68>>2]|0)<(k[a+36>>2]|0);else c=0;else c=1;do if(!d){if(c){k[i>>2]=k[h>>2];k[i+4>>2]=k[h+4>>2];k[i+8>>2]=k[h+8>>2];k[i+12>>2]=k[h+12>>2];k[i+16>>2]=k[h+16>>2];k[i+20>>2]=k[h+20>>2];k[i+24>>2]=k[h+24>>2];k[i+28>>2]=k[h+28>>2];k[h>>2]=k[f>>2];k[h+4>>2]=k[f+4>>2];k[h+8>>2]=k[f+8>>2];k[h+12>>2]=k[f+12>>2];k[h+16>>2]=k[f+16>>2];k[h+20>>2]=k[f+20>>2];k[h+24>>2]=k[f+24>>2];j[h+28>>1]=j[f+28>>1]|0;k[f>>2]=k[i>>2];k[f+4>>2]=k[i+4>>2];k[f+8>>2]=k[i+8>>2];k[f+12>>2]=k[i+12>>2];k[f+16>>2]=k[i+16>>2];k[f+20>>2]=k[i+20>>2];k[f+24>>2]=k[i+24>>2];j[f+28>>1]=j[i+28>>1]|0;c=k[h>>2]|0;if((c|0)>=(e|0)){if((c|0)!=(e|0))break;if((k[a+36>>2]|0)>=(k[a+4>>2]|0))break};k[i>>2]=k[a>>2];k[i+4>>2]=k[a+4>>2];k[i+8>>2]=k[a+8>>2];k[i+12>>2]=k[a+12>>2];k[i+16>>2]=k[a+16>>2];k[i+20>>2]=k[a+20>>2];k[i+24>>2]=k[a+24>>2];k[i+28>>2]=k[a+28>>2];k[a>>2]=k[h>>2];k[a+4>>2]=k[h+4>>2];k[a+8>>2]=k[h+8>>2];k[a+12>>2]=k[h+12>>2];k[a+16>>2]=k[h+16>>2];k[a+20>>2]=k[h+20>>2];k[a+24>>2]=k[h+24>>2];j[a+28>>1]=j[h+28>>1]|0;k[h>>2]=k[i>>2];k[h+4>>2]=k[i+4>>2];k[h+8>>2]=k[i+8>>2];k[h+12>>2]=k[i+12>>2];k[h+16>>2]=k[i+16>>2];k[h+20>>2]=k[i+20>>2];k[h+24>>2]=k[i+24>>2];j[h+28>>1]=j[i+28>>1]|0}}else{k[i>>2]=k[a>>2];k[i+4>>2]=k[a+4>>2];k[i+8>>2]=k[a+8>>2];k[i+12>>2]=k[a+12>>2];k[i+16>>2]=k[a+16>>2];k[i+20>>2]=k[a+20>>2];k[i+24>>2]=k[a+24>>2];k[i+28>>2]=k[a+28>>2];if(c){k[a>>2]=k[f>>2];k[a+4>>2]=k[f+4>>2];k[a+8>>2]=k[f+8>>2];k[a+12>>2]=k[f+12>>2];k[a+16>>2]=k[f+16>>2];k[a+20>>2]=k[f+20>>2];k[a+24>>2]=k[f+24>>2];j[a+28>>1]=j[f+28>>1]|0;k[f>>2]=k[i>>2];k[f+4>>2]=k[i+4>>2];k[f+8>>2]=k[i+8>>2];k[f+12>>2]=k[i+12>>2];k[f+16>>2]=k[i+16>>2];k[f+20>>2]=k[i+20>>2];k[f+24>>2]=k[i+24>>2];j[f+28>>1]=j[i+28>>1]|0;break};k[a>>2]=k[h>>2];k[a+4>>2]=k[h+4>>2];k[a+8>>2]=k[h+8>>2];k[a+12>>2]=k[h+12>>2];k[a+16>>2]=k[h+16>>2];k[a+20>>2]=k[h+20>>2];k[a+24>>2]=k[h+24>>2];j[a+28>>1]=j[h+28>>1]|0;k[h>>2]=k[i>>2];k[h+4>>2]=k[i+4>>2];k[h+8>>2]=k[i+8>>2];k[h+12>>2]=k[i+12>>2];k[h+16>>2]=k[i+16>>2];k[h+20>>2]=k[i+20>>2];k[h+24>>2]=k[i+24>>2];j[h+28>>1]=j[i+28>>1]|0;c=k[h>>2]|0;if((g|0)>=(c|0)){if((g|0)!=(c|0))break;if((k[a+68>>2]|0)>=(k[a+36>>2]|0))break};k[i>>2]=k[h>>2];k[i+4>>2]=k[h+4>>2];k[i+8>>2]=k[h+8>>2];k[i+12>>2]=k[h+12>>2];k[i+16>>2]=k[h+16>>2];k[i+20>>2]=k[h+20>>2];k[i+24>>2]=k[h+24>>2];k[i+28>>2]=k[h+28>>2];k[h>>2]=k[f>>2];k[h+4>>2]=k[f+4>>2];k[h+8>>2]=k[f+8>>2];k[h+12>>2]=k[f+12>>2];k[h+16>>2]=k[f+16>>2];k[h+20>>2]=k[f+20>>2];k[h+24>>2]=k[f+24>>2];j[h+28>>1]=j[f+28>>1]|0;k[f>>2]=k[i>>2];k[f+4>>2]=k[i+4>>2];k[f+8>>2]=k[i+8>>2];k[f+12>>2]=k[i+12>>2];k[f+16>>2]=k[i+16>>2];k[f+20>>2]=k[i+20>>2];k[f+24>>2]=k[i+24>>2];j[f+28>>1]=j[i+28>>1]|0}while(0);d=a+96|0;if((d|0)==(b|0)){a=1;r=o;return a|0}c=0;while(1){i=k[d>>2]|0;e=k[f>>2]|0;if((i|0)>=(e|0)){if((i|0)==(e|0)?(l=k[d+4>>2]|0,(l|0)<(k[f+4>>2]|0)):0){h=l;n=50}}else{h=k[d+4>>2]|0;n=50}if((n|0)==50){n=0;g=d+8|0;k[m>>2]=k[g>>2];k[m+4>>2]=k[g+4>>2];k[m+8>>2]=k[g+8>>2];k[m+12>>2]=k[g+12>>2];k[m+16>>2]=k[g+16>>2];k[m+20>>2]=k[g+20>>2];k[d>>2]=k[f>>2];k[d+4>>2]=k[f+4>>2];k[d+8>>2]=k[f+8>>2];k[d+12>>2]=k[f+12>>2];k[d+16>>2]=k[f+16>>2];k[d+20>>2]=k[f+20>>2];k[d+24>>2]=k[f+24>>2];j[d+28>>1]=j[f+28>>1]|0;a:do if((f|0)==(a|0))e=a;else while(1){e=f;f=f+-32|0;g=k[f>>2]|0;if((i|0)>=(g|0)){if((i|0)!=(g|0))break a;if((h|0)>=(k[e+-28>>2]|0))break a};k[e>>2]=k[f>>2];k[e+4>>2]=k[f+4>>2];k[e+8>>2]=k[f+8>>2];k[e+12>>2]=k[f+12>>2];k[e+16>>2]=k[f+16>>2];k[e+20>>2]=k[f+20>>2];k[e+24>>2]=k[f+24>>2];j[e+28>>1]=j[f+28>>1]|0;if((f|0)==(a|0)){e=a;break}}while(0);k[e>>2]=i;k[e+4>>2]=h;i=e+8|0;k[i>>2]=k[m>>2];k[i+4>>2]=k[m+4>>2];k[i+8>>2]=k[m+8>>2];k[i+12>>2]=k[m+12>>2];k[i+16>>2]=k[m+16>>2];j[i+20>>1]=j[m+20>>1]|0;c=c+1|0;if((c|0)==8)break}e=d+32|0;if((e|0)==(b|0)){c=1;n=58;break}else{f=d;d=e}}if((n|0)==58){r=o;return c|0}a=(d+32|0)==(b|0);r=o;return a|0}}return 0}function yc(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,l=0,m=0,n=0,o=0;n=a+4|0;f=k[n>>2]|0;m=k[a>>2]|0;d=m;j=f-d>>4;l=j+1|0;if(l>>>0>268435455)xa(1340,1363,303,1438);o=a+8|0;e=(k[o>>2]|0)-d|0;if(e>>4>>>0<134217727){e=e>>3;e=e>>>0<l>>>0?l:e;if(!e){h=0;g=0}else i=5}else{e=268435455;i=5}if((i|0)==5){h=e<<4;h=(h|0)==0?1:h;g=_d(h)|0;a:do if(!g){while(1){g=k[35]|0;k[35]=g+0;if(!g)break;Xa[g&0]();g=_d(h)|0;if(g)break a}o=ya(4)|0;k[o>>2]=128;La(o|0,8,1)}while(0);h=e}i=g+(j<<4)|0;e=i;h=g+(h<<4)|0;k[i>>2]=0;k[i+4>>2]=0;k[i+8>>2]=0;k[i+12>>2]=0;k[i>>2]=k[b>>2];k[g+(j<<4)+4>>2]=k[b+4>>2];k[g+(j<<4)+8>>2]=k[c>>2];k[g+(j<<4)+12>>2]=k[c+4>>2];g=g+(l<<4)|0;if((f|0)==(m|0))f=a;else{d=i;do{b=d+-16|0;c=f;f=f+-16|0;k[b>>2]=0;k[b+4>>2]=0;k[b+8>>2]=0;k[b+12>>2]=0;k[b>>2]=k[f>>2];k[d+-12>>2]=k[c+-12>>2];k[d+-8>>2]=k[c+-8>>2];k[d+-4>>2]=k[c+-4>>2];d=e+-16|0;e=d}while((f|0)!=(m|0));f=a;d=k[a>>2]|0}k[f>>2]=e;k[n>>2]=g;k[o>>2]=h;if(!d)return;$d(d);return}function zc(a,b){a=a|0;b=b|0;return (k[a+16>>2]|0)<(k[b+16>>2]|0)|0}function Ac(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0,s=0,t=0;t=r;r=r+48|0;s=t;q=b;a:while(1){n=q;p=q+-44|0;b:while(1){j=a;b=n-j|0;switch((b|0)/44|0|0){case 2:{o=4;break a}case 3:{o=6;break a}case 4:{o=14;break a}case 5:{o=15;break a}case 1:case 0:{o=82;break a}default:{}}if((b|0)<1364){o=21;break a}d=(b|0)/88|0;i=a+(d*44|0)|0;do if((b|0)>43956){e=(b|0)/176|0;f=a+(e*44|0)|0;e=a+((e+d|0)*44|0)|0;b=Hc(a,f,i,e,c)|0;if(Za[k[c>>2]&7](p,e)|0){d=s;l=e;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));d=e;l=p;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));d=p;l=s;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));d=b+1|0;if(Za[k[c>>2]&7](e,i)|0){d=s;l=i;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));d=i;l=e;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));d=e;l=s;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));d=b+2|0;if(Za[k[c>>2]&7](i,f)|0){d=s;l=f;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));d=f;l=i;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));d=i;l=s;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));d=b+3|0;if(Za[k[c>>2]&7](f,a)|0){d=s;l=a;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));d=a;l=f;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));d=f;l=s;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));b=b+4|0}else b=d}else b=d}else b=d}}else{m=Za[k[c>>2]&7](i,a)|0;b=Za[k[c>>2]&7](p,i)|0;if(!m){if(!b){b=0;break}d=s;l=i;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));d=i;l=p;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));d=p;l=s;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));if(!(Za[k[c>>2]&7](i,a)|0)){b=1;break}d=s;l=a;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));d=a;l=i;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));d=i;l=s;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));b=2;break}if(b){d=s;l=a;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));d=a;l=p;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));d=p;l=s;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));b=1;break}d=s;l=a;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));d=a;l=i;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));d=i;l=s;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));if(Za[k[c>>2]&7](p,i)|0){d=s;l=i;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));d=i;l=p;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));d=p;l=s;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));b=2}else b=1}while(0);do if(Za[k[c>>2]&7](a,i)|0)e=p;else{e=p;while(1){e=e+-44|0;if((a|0)==(e|0))break;if(Za[k[c>>2]&7](e,i)|0){o=65;break}}if((o|0)==65){o=0;d=s;l=a;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));d=a;l=e;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));d=e;l=s;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));b=b+1|0;break}b=a+44|0;if(!(Za[k[c>>2]&7](a,p)|0)){if((b|0)==(p|0)){o=82;break a}else e=a;while(1){d=b+44|0;if(Za[k[c>>2]&7](a,b)|0)break;if((d|0)==(p|0)){o=82;break a}else{e=b;b=d}}b=e+44|0;d=s;l=b;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));d=b;l=p;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));d=p;l=s;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));b=e+88|0}if((b|0)==(p|0)){o=82;break a}else d=p;while(1){e=b;while(1){b=e+44|0;if(Za[k[c>>2]&7](a,e)|0){f=d;break}else e=b}do f=f+-44|0;while(Za[k[c>>2]&7](a,f)|0);if(e>>>0>=f>>>0){a=e;continue b}d=s;l=e;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));d=e;l=f;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));d=f;l=s;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));d=f}}while(0);d=a+44|0;c:do if(d>>>0<e>>>0)while(1){g=d;while(1){f=g+44|0;if(Za[k[c>>2]&7](g,i)|0)g=f;else{h=e;break}}do h=h+-44|0;while(!(Za[k[c>>2]&7](h,i)|0));if(g>>>0>h>>>0){e=i;break c}d=s;l=g;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));d=g;l=h;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));d=h;l=s;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));d=f;e=h;i=(i|0)==(g|0)?h:i;b=b+1|0}else{g=d;e=i}while(0);if((g|0)!=(e|0)?Za[k[c>>2]&7](e,g)|0:0){d=s;l=g;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));d=g;l=e;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));d=e;l=s;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));b=b+1|0}if(!b){b=Ic(a,g,c)|0;d=g+44|0;if(Ic(d,q,c)|0){o=77;break}if(b){a=d;continue}}m=g;if((m-j|0)>=(n-m|0)){o=81;break}Ac(a,g,c);a=g+44|0}if((o|0)==77){o=0;if(b){o=82;break}else{q=g;continue}}else if((o|0)==81){o=0;Ac(g+44|0,q,c);q=g;continue}}if((o|0)==4){if(!(Za[k[c>>2]&7](p,a)|0)){r=t;return}d=s;l=a;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));d=a;l=p;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));d=p;l=s;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));r=t;return}else if((o|0)==6){e=a+44|0;q=Za[k[c>>2]&7](e,a)|0;b=Za[k[c>>2]&7](p,e)|0;if(!q){if(!b){r=t;return}d=s;l=e;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));d=e;l=p;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));d=p;l=s;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));if(!(Za[k[c>>2]&7](e,a)|0)){r=t;return}d=s;l=a;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));d=a;l=e;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));d=e;l=s;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));r=t;return}if(b){d=s;l=a;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));d=a;l=p;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));d=p;l=s;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));r=t;return}d=s;l=a;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));d=a;l=e;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));d=e;l=s;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));if(!(Za[k[c>>2]&7](p,e)|0)){r=t;return}d=s;l=e;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));d=e;l=p;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));d=p;l=s;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));r=t;return}else if((o|0)==14){Hc(a,a+44|0,a+88|0,p,c)|0;r=t;return}else if((o|0)==15){b=a+44|0;e=a+88|0;f=a+132|0;Hc(a,b,e,f,c)|0;if(!(Za[k[c>>2]&7](p,f)|0)){r=t;return}d=s;l=f;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));d=f;l=p;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));d=p;l=s;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));if(!(Za[k[c>>2]&7](f,e)|0)){r=t;return}d=s;l=e;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));d=e;l=f;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));d=f;l=s;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));if(!(Za[k[c>>2]&7](e,b)|0)){r=t;return}d=s;l=b;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));d=b;l=e;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));d=e;l=s;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));if(!(Za[k[c>>2]&7](b,a)|0)){r=t;return}d=s;l=a;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));d=a;l=b;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));d=b;l=s;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));r=t;return}else if((o|0)==21){f=a+88|0;e=a+44|0;p=Za[k[c>>2]&7](e,a)|0;b=Za[k[c>>2]&7](f,e)|0;do if(p){if(b){d=s;l=a;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));d=a;l=f;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));d=f;l=s;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));break}d=s;l=a;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));d=a;l=e;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));d=e;l=s;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));if(Za[k[c>>2]&7](f,e)|0){d=s;l=e;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));d=e;l=f;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));d=f;l=s;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0))}}else if(b){d=s;l=e;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));d=e;l=f;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));d=f;l=s;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));if(Za[k[c>>2]&7](e,a)|0){d=s;l=a;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));d=a;l=e;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));d=e;l=s;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0))}}while(0);b=a+132|0;if((b|0)==(q|0)){r=t;return}e=f;while(1){if(Za[k[c>>2]&7](b,e)|0){d=s;l=b;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));d=b;while(1){l=e;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0));if((e|0)==(a|0))break;d=e+-44|0;if(Za[k[c>>2]&7](s,d)|0){p=e;e=d;d=p}else break}d=e;l=s;m=d+44|0;do{k[d>>2]=k[l>>2];d=d+4|0;l=l+4|0}while((d|0)<(m|0))}d=b+44|0;if((d|0)==(q|0))break;else{e=b;b=d}}r=t;return}else if((o|0)==82){r=t;return}}function Bc(a){a=a|0;var b=0,c=0,d=0,e=0,f=0;Cc(k[a+68>>2]|0);d=a+52|0;c=a+60|0;if((k[c>>2]|0)!=0?(b=k[a+56>>2]|0,e=(k[d>>2]|0)+4|0,f=k[b>>2]|0,k[f+4>>2]=k[e>>2],k[k[e>>2]>>2]=f,k[c>>2]=0,(b|0)!=(d|0)):0)do{f=b;b=k[b+4>>2]|0;$d(f)}while((b|0)!=(d|0));b=k[a+36>>2]|0;c=b;if(b){d=a+40|0;e=k[d>>2]|0;if((e|0)!=(b|0))k[d>>2]=e+(~((e+-4-c|0)>>>2)<<2);$d(b)}b=k[a+20>>2]|0;c=b;if(b){d=a+24|0;e=k[d>>2]|0;if((e|0)!=(b|0))k[d>>2]=e+(~(((e+-12-c|0)>>>0)/12|0)*12|0);$d(b)}d=k[a+4>>2]|0;if(!d)return;b=a+8|0;c=k[b>>2]|0;if((c|0)!=(d|0))k[b>>2]=c+(~(((c+-28-d|0)>>>0)/28|0)*28|0);$d(d);return}function Cc(a){a=a|0;if(!a)return;else{Cc(k[a>>2]|0);Cc(k[a+4>>2]|0);$d(a);return}}function Dc(a,b){a=a|0;b=b|0;var c=0.0,d=0.0,e=0,f=0,g=0,h=0,j=0,l=0,m=0;c=+p[a+16>>3];d=+p[b+16>>3];if(c<d){m=1;return m|0}if(d<c){m=0;return m|0}e=i[a+24>>0]|0;f=i[b+24>>0]|0;if((e&255)<(f&255)){m=1;return m|0}if((f&255)<(e&255)){m=0;return m|0}g=k[a+8>>2]|0;b=k[b+8>>2]|0;e=k[g+28>>2]|0;f=k[g+16>>2]|0;a=e-f|0;g=(k[g+32>>2]|0)-(k[g+20>>2]|0)|0;h=k[b+28>>2]|0;j=k[b+16>>2]|0;l=h-j|0;b=(k[b+32>>2]|0)-(k[b+20>>2]|0)|0;if((a|0)>=0){if((e|0)==(f|0)){m=0;return m|0}}else{a=0-a|0;g=0-g|0}if((l|0)>=0)if((h|0)==(j|0)){m=(a|0)!=0;return m|0}else e=l;else{e=0-l|0;b=0-b|0}j=(e|0)<0?0-e|0:e;h=(g|0)<0?0-g|0:g;h=ne(j|0,((j|0)<0)<<31>>31|0,h|0,((h|0)<0)<<31>>31|0)|0;j=L;l=(a|0)<0?0-a|0:a;m=(b|0)<0?0-b|0:b;l=ne(m|0,((m|0)<0)<<31>>31|0,l|0,((l|0)<0)<<31>>31|0)|0;m=L;f=ha(e>>31|1,g>>31|1)|0;e=ha(b>>31|1,a>>31|1)|0;if((f|0)<(e|0)){m=1;return m|0}if((e|0)<(f|0)){m=0;return m|0}if((f|0)==-1){m=m>>>0<j>>>0|(m|0)==(j|0)&l>>>0<h>>>0;return m|0}else{m=j>>>0<m>>>0|(j|0)==(m|0)&h>>>0<l>>>0;return m|0}return 0}function Ec(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0,l=0,m=0,n=0,o=0,p=0,q=0,s=0,t=0;t=r;r=r+64|0;q=t+32|0;p=t;o=b;a:while(1){l=o;n=o+-32|0;s=a;b:while(1){h=s;a=l-h|0;b=a>>5;switch(b|0){case 2:{m=4;break a}case 3:{m=6;break a}case 4:{m=14;break a}case 5:{m=15;break a}case 1:case 0:{m=82;break a}default:{}}if((a|0)<992){m=21;break a}d=(b|0)/2|0;g=s+(d<<5)|0;do if((a|0)>31968){b=(b|0)/4|0;e=s+(b<<5)|0;b=s+(b+d<<5)|0;a=Fc(s,e,g,b,c)|0;if(Za[k[c>>2]&7](n,b)|0){k[p>>2]=k[b>>2];k[p+4>>2]=k[b+4>>2];k[p+8>>2]=k[b+8>>2];k[p+12>>2]=k[b+12>>2];k[p+16>>2]=k[b+16>>2];k[p+20>>2]=k[b+20>>2];k[p+24>>2]=k[b+24>>2];k[p+28>>2]=k[b+28>>2];k[b>>2]=k[n>>2];k[b+4>>2]=k[n+4>>2];k[b+8>>2]=k[n+8>>2];k[b+12>>2]=k[n+12>>2];k[b+16>>2]=k[n+16>>2];k[b+20>>2]=k[n+20>>2];j[b+24>>1]=j[n+24>>1]|0;i[b+26>>0]=i[n+26>>0]|0;k[n>>2]=k[p>>2];k[n+4>>2]=k[p+4>>2];k[n+8>>2]=k[p+8>>2];k[n+12>>2]=k[p+12>>2];k[n+16>>2]=k[p+16>>2];k[n+20>>2]=k[p+20>>2];j[n+24>>1]=j[p+24>>1]|0;i[n+26>>0]=i[p+26>>0]|0;d=a+1|0;if(Za[k[c>>2]&7](b,g)|0){k[p>>2]=k[g>>2];k[p+4>>2]=k[g+4>>2];k[p+8>>2]=k[g+8>>2];k[p+12>>2]=k[g+12>>2];k[p+16>>2]=k[g+16>>2];k[p+20>>2]=k[g+20>>2];k[p+24>>2]=k[g+24>>2];k[p+28>>2]=k[g+28>>2];k[g>>2]=k[b>>2];k[g+4>>2]=k[b+4>>2];k[g+8>>2]=k[b+8>>2];k[g+12>>2]=k[b+12>>2];k[g+16>>2]=k[b+16>>2];k[g+20>>2]=k[b+20>>2];j[g+24>>1]=j[b+24>>1]|0;i[g+26>>0]=i[b+26>>0]|0;k[b>>2]=k[p>>2];k[b+4>>2]=k[p+4>>2];k[b+8>>2]=k[p+8>>2];k[b+12>>2]=k[p+12>>2];k[b+16>>2]=k[p+16>>2];k[b+20>>2]=k[p+20>>2];j[b+24>>1]=j[p+24>>1]|0;i[b+26>>0]=i[p+26>>0]|0;b=a+2|0;if(Za[k[c>>2]&7](g,e)|0){k[p>>2]=k[e>>2];k[p+4>>2]=k[e+4>>2];k[p+8>>2]=k[e+8>>2];k[p+12>>2]=k[e+12>>2];k[p+16>>2]=k[e+16>>2];k[p+20>>2]=k[e+20>>2];k[p+24>>2]=k[e+24>>2];k[p+28>>2]=k[e+28>>2];k[e>>2]=k[g>>2];k[e+4>>2]=k[g+4>>2];k[e+8>>2]=k[g+8>>2];k[e+12>>2]=k[g+12>>2];k[e+16>>2]=k[g+16>>2];k[e+20>>2]=k[g+20>>2];j[e+24>>1]=j[g+24>>1]|0;i[e+26>>0]=i[g+26>>0]|0;k[g>>2]=k[p>>2];k[g+4>>2]=k[p+4>>2];k[g+8>>2]=k[p+8>>2];k[g+12>>2]=k[p+12>>2];k[g+16>>2]=k[p+16>>2];k[g+20>>2]=k[p+20>>2];j[g+24>>1]=j[p+24>>1]|0;i[g+26>>0]=i[p+26>>0]|0;if(Za[k[c>>2]&7](e,s)|0){k[p>>2]=k[s>>2];k[p+4>>2]=k[s+4>>2];k[p+8>>2]=k[s+8>>2];k[p+12>>2]=k[s+12>>2];k[p+16>>2]=k[s+16>>2];k[p+20>>2]=k[s+20>>2];k[p+24>>2]=k[s+24>>2];k[p+28>>2]=k[s+28>>2];k[s>>2]=k[e>>2];k[s+4>>2]=k[e+4>>2];k[s+8>>2]=k[e+8>>2];k[s+12>>2]=k[e+12>>2];k[s+16>>2]=k[e+16>>2];k[s+20>>2]=k[e+20>>2];j[s+24>>1]=j[e+24>>1]|0;i[s+26>>0]=i[e+26>>0]|0;k[e>>2]=k[p>>2];k[e+4>>2]=k[p+4>>2];k[e+8>>2]=k[p+8>>2];k[e+12>>2]=k[p+12>>2];k[e+16>>2]=k[p+16>>2];k[e+20>>2]=k[p+20>>2];j[e+24>>1]=j[p+24>>1]|0;i[e+26>>0]=i[p+26>>0]|0;a=a+4|0}else a=a+3|0}else a=b}else a=d}}else{f=Za[k[c>>2]&7](g,s)|0;a=Za[k[c>>2]&7](n,g)|0;if(!f){if(!a){a=0;break};k[p>>2]=k[g>>2];k[p+4>>2]=k[g+4>>2];k[p+8>>2]=k[g+8>>2];k[p+12>>2]=k[g+12>>2];k[p+16>>2]=k[g+16>>2];k[p+20>>2]=k[g+20>>2];k[p+24>>2]=k[g+24>>2];k[p+28>>2]=k[g+28>>2];k[g>>2]=k[n>>2];k[g+4>>2]=k[n+4>>2];k[g+8>>2]=k[n+8>>2];k[g+12>>2]=k[n+12>>2];k[g+16>>2]=k[n+16>>2];k[g+20>>2]=k[n+20>>2];j[g+24>>1]=j[n+24>>1]|0;i[g+26>>0]=i[n+26>>0]|0;k[n>>2]=k[p>>2];k[n+4>>2]=k[p+4>>2];k[n+8>>2]=k[p+8>>2];k[n+12>>2]=k[p+12>>2];k[n+16>>2]=k[p+16>>2];k[n+20>>2]=k[p+20>>2];j[n+24>>1]=j[p+24>>1]|0;i[n+26>>0]=i[p+26>>0]|0;if(!(Za[k[c>>2]&7](g,s)|0)){a=1;break};k[p>>2]=k[s>>2];k[p+4>>2]=k[s+4>>2];k[p+8>>2]=k[s+8>>2];k[p+12>>2]=k[s+12>>2];k[p+16>>2]=k[s+16>>2];k[p+20>>2]=k[s+20>>2];k[p+24>>2]=k[s+24>>2];k[p+28>>2]=k[s+28>>2];k[s>>2]=k[g>>2];k[s+4>>2]=k[g+4>>2];k[s+8>>2]=k[g+8>>2];k[s+12>>2]=k[g+12>>2];k[s+16>>2]=k[g+16>>2];k[s+20>>2]=k[g+20>>2];j[s+24>>1]=j[g+24>>1]|0;i[s+26>>0]=i[g+26>>0]|0;k[g>>2]=k[p>>2];k[g+4>>2]=k[p+4>>2];k[g+8>>2]=k[p+8>>2];k[g+12>>2]=k[p+12>>2];k[g+16>>2]=k[p+16>>2];k[g+20>>2]=k[p+20>>2];j[g+24>>1]=j[p+24>>1]|0;i[g+26>>0]=i[p+26>>0]|0;a=2;break};k[p>>2]=k[s>>2];k[p+4>>2]=k[s+4>>2];k[p+8>>2]=k[s+8>>2];k[p+12>>2]=k[s+12>>2];k[p+16>>2]=k[s+16>>2];k[p+20>>2]=k[s+20>>2];k[p+24>>2]=k[s+24>>2];k[p+28>>2]=k[s+28>>2];if(a){k[s>>2]=k[n>>2];k[s+4>>2]=k[n+4>>2];k[s+8>>2]=k[n+8>>2];k[s+12>>2]=k[n+12>>2];k[s+16>>2]=k[n+16>>2];k[s+20>>2]=k[n+20>>2];j[s+24>>1]=j[n+24>>1]|0;i[s+26>>0]=i[n+26>>0]|0;k[n>>2]=k[p>>2];k[n+4>>2]=k[p+4>>2];k[n+8>>2]=k[p+8>>2];k[n+12>>2]=k[p+12>>2];k[n+16>>2]=k[p+16>>2];k[n+20>>2]=k[p+20>>2];j[n+24>>1]=j[p+24>>1]|0;i[n+26>>0]=i[p+26>>0]|0;a=1;break};k[s>>2]=k[g>>2];k[s+4>>2]=k[g+4>>2];k[s+8>>2]=k[g+8>>2];k[s+12>>2]=k[g+12>>2];k[s+16>>2]=k[g+16>>2];k[s+20>>2]=k[g+20>>2];j[s+24>>1]=j[g+24>>1]|0;i[s+26>>0]=i[g+26>>0]|0;k[g>>2]=k[p>>2];k[g+4>>2]=k[p+4>>2];k[g+8>>2]=k[p+8>>2];k[g+12>>2]=k[p+12>>2];k[g+16>>2]=k[p+16>>2];k[g+20>>2]=k[p+20>>2];j[g+24>>1]=j[p+24>>1]|0;i[g+26>>0]=i[p+26>>0]|0;if(Za[k[c>>2]&7](n,g)|0){k[p>>2]=k[g>>2];k[p+4>>2]=k[g+4>>2];k[p+8>>2]=k[g+8>>2];k[p+12>>2]=k[g+12>>2];k[p+16>>2]=k[g+16>>2];k[p+20>>2]=k[g+20>>2];k[p+24>>2]=k[g+24>>2];k[p+28>>2]=k[g+28>>2];k[g>>2]=k[n>>2];k[g+4>>2]=k[n+4>>2];k[g+8>>2]=k[n+8>>2];k[g+12>>2]=k[n+12>>2];k[g+16>>2]=k[n+16>>2];k[g+20>>2]=k[n+20>>2];j[g+24>>1]=j[n+24>>1]|0;i[g+26>>0]=i[n+26>>0]|0;k[n>>2]=k[p>>2];k[n+4>>2]=k[p+4>>2];k[n+8>>2]=k[p+8>>2];k[n+12>>2]=k[p+12>>2];k[n+16>>2]=k[p+16>>2];k[n+20>>2]=k[p+20>>2];j[n+24>>1]=j[p+24>>1]|0;i[n+26>>0]=i[p+26>>0]|0;a=2}else a=1}while(0);do if(Za[k[c>>2]&7](s,g)|0)b=n;else{b=n;while(1){b=b+-32|0;if((s|0)==(b|0))break;if(Za[k[c>>2]&7](b,g)|0){m=65;break}}if((m|0)==65){m=0;k[p>>2]=k[s>>2];k[p+4>>2]=k[s+4>>2];k[p+8>>2]=k[s+8>>2];k[p+12>>2]=k[s+12>>2];k[p+16>>2]=k[s+16>>2];k[p+20>>2]=k[s+20>>2];k[p+24>>2]=k[s+24>>2];k[p+28>>2]=k[s+28>>2];k[s>>2]=k[b>>2];k[s+4>>2]=k[b+4>>2];k[s+8>>2]=k[b+8>>2];k[s+12>>2]=k[b+12>>2];k[s+16>>2]=k[b+16>>2];k[s+20>>2]=k[b+20>>2];j[s+24>>1]=j[b+24>>1]|0;i[s+26>>0]=i[b+26>>0]|0;k[b>>2]=k[p>>2];k[b+4>>2]=k[p+4>>2];k[b+8>>2]=k[p+8>>2];k[b+12>>2]=k[p+12>>2];k[b+16>>2]=k[p+16>>2];k[b+20>>2]=k[p+20>>2];j[b+24>>1]=j[p+24>>1]|0;i[b+26>>0]=i[p+26>>0]|0;a=a+1|0;break}a=s+32|0;if(!(Za[k[c>>2]&7](s,n)|0)){if((a|0)==(n|0)){m=82;break a}else b=s;while(1){if(Za[k[c>>2]&7](s,a)|0)break;b=a+32|0;if((b|0)==(n|0)){m=82;break a}else{h=a;a=b;b=h}}k[p>>2]=k[a>>2];k[p+4>>2]=k[a+4>>2];k[p+8>>2]=k[a+8>>2];k[p+12>>2]=k[a+12>>2];k[p+16>>2]=k[a+16>>2];k[p+20>>2]=k[a+20>>2];k[p+24>>2]=k[a+24>>2];k[p+28>>2]=k[a+28>>2];k[a>>2]=k[n>>2];k[a+4>>2]=k[n+4>>2];k[a+8>>2]=k[n+8>>2];k[a+12>>2]=k[n+12>>2];k[a+16>>2]=k[n+16>>2];k[a+20>>2]=k[n+20>>2];j[a+24>>1]=j[n+24>>1]|0;i[a+26>>0]=i[n+26>>0]|0;k[n>>2]=k[p>>2];k[n+4>>2]=k[p+4>>2];k[n+8>>2]=k[p+8>>2];k[n+12>>2]=k[p+12>>2];k[n+16>>2]=k[p+16>>2];k[n+20>>2]=k[p+20>>2];j[n+24>>1]=j[p+24>>1]|0;i[n+26>>0]=i[p+26>>0]|0;a=b+64|0}if((a|0)==(n|0)){m=82;break a}else d=n;while(1){b=a;while(1){a=b+32|0;if(Za[k[c>>2]&7](s,b)|0)break;else b=a}do d=d+-32|0;while(Za[k[c>>2]&7](s,d)|0);if(b>>>0>=d>>>0){s=b;continue b};k[p>>2]=k[b>>2];k[p+4>>2]=k[b+4>>2];k[p+8>>2]=k[b+8>>2];k[p+12>>2]=k[b+12>>2];k[p+16>>2]=k[b+16>>2];k[p+20>>2]=k[b+20>>2];k[p+24>>2]=k[b+24>>2];k[p+28>>2]=k[b+28>>2];k[b>>2]=k[d>>2];k[b+4>>2]=k[d+4>>2];k[b+8>>2]=k[d+8>>2];k[b+12>>2]=k[d+12>>2];k[b+16>>2]=k[d+16>>2];k[b+20>>2]=k[d+20>>2];j[b+24>>1]=j[d+24>>1]|0;i[b+26>>0]=i[d+26>>0]|0;k[d>>2]=k[p>>2];k[d+4>>2]=k[p+4>>2];k[d+8>>2]=k[p+8>>2];k[d+12>>2]=k[p+12>>2];k[d+16>>2]=k[p+16>>2];k[d+20>>2]=k[p+20>>2];j[d+24>>1]=j[p+24>>1]|0;i[d+26>>0]=i[p+26>>0]|0}}while(0);d=s+32|0;c:do if(d>>>0<b>>>0)while(1){e=d;while(1){d=e+32|0;if(Za[k[c>>2]&7](e,g)|0)e=d;else{f=b;break}}do f=f+-32|0;while(!(Za[k[c>>2]&7](f,g)|0));if(e>>>0>f>>>0){d=e;b=g;break c};k[p>>2]=k[e>>2];k[p+4>>2]=k[e+4>>2];k[p+8>>2]=k[e+8>>2];k[p+12>>2]=k[e+12>>2];k[p+16>>2]=k[e+16>>2];k[p+20>>2]=k[e+20>>2];k[p+24>>2]=k[e+24>>2];k[p+28>>2]=k[e+28>>2];k[e>>2]=k[f>>2];k[e+4>>2]=k[f+4>>2];k[e+8>>2]=k[f+8>>2];k[e+12>>2]=k[f+12>>2];k[e+16>>2]=k[f+16>>2];k[e+20>>2]=k[f+20>>2];j[e+24>>1]=j[f+24>>1]|0;i[e+26>>0]=i[f+26>>0]|0;k[f>>2]=k[p>>2];k[f+4>>2]=k[p+4>>2];k[f+8>>2]=k[p+8>>2];k[f+12>>2]=k[p+12>>2];k[f+16>>2]=k[p+16>>2];k[f+20>>2]=k[p+20>>2];j[f+24>>1]=j[p+24>>1]|0;i[f+26>>0]=i[p+26>>0]|0;b=f;g=(g|0)==(e|0)?f:g;a=a+1|0}else b=g;while(0);if((d|0)!=(b|0)?Za[k[c>>2]&7](b,d)|0:0){k[p>>2]=k[d>>2];k[p+4>>2]=k[d+4>>2];k[p+8>>2]=k[d+8>>2];k[p+12>>2]=k[d+12>>2];k[p+16>>2]=k[d+16>>2];k[p+20>>2]=k[d+20>>2];k[p+24>>2]=k[d+24>>2];k[p+28>>2]=k[d+28>>2];k[d>>2]=k[b>>2];k[d+4>>2]=k[b+4>>2];k[d+8>>2]=k[b+8>>2];k[d+12>>2]=k[b+12>>2];k[d+16>>2]=k[b+16>>2];k[d+20>>2]=k[b+20>>2];j[d+24>>1]=j[b+24>>1]|0;i[d+26>>0]=i[b+26>>0]|0;k[b>>2]=k[p>>2];k[b+4>>2]=k[p+4>>2];k[b+8>>2]=k[p+8>>2];k[b+12>>2]=k[p+12>>2];k[b+16>>2]=k[p+16>>2];k[b+20>>2]=k[p+20>>2];j[b+24>>1]=j[p+24>>1]|0;i[b+26>>0]=i[p+26>>0]|0;a=a+1|0}if(!a){a=Gc(s,d,c)|0;b=d+32|0;if(Gc(b,o,c)|0){m=77;break}if(a){s=b;continue}}g=d;if((g-h|0)>=(l-g|0)){m=81;break}Ec(s,d,c);s=d+32|0}if((m|0)==77){m=0;if(a){m=82;break}else{a=s;o=d;continue}}else if((m|0)==81){m=0;Ec(d+32|0,o,c);a=s;o=d;continue}}if((m|0)==4){if(!(Za[k[c>>2]&7](n,s)|0)){r=t;return};k[p>>2]=k[s>>2];k[p+4>>2]=k[s+4>>2];k[p+8>>2]=k[s+8>>2];k[p+12>>2]=k[s+12>>2];k[p+16>>2]=k[s+16>>2];k[p+20>>2]=k[s+20>>2];k[p+24>>2]=k[s+24>>2];k[p+28>>2]=k[s+28>>2];k[s>>2]=k[n>>2];k[s+4>>2]=k[n+4>>2];k[s+8>>2]=k[n+8>>2];k[s+12>>2]=k[n+12>>2];k[s+16>>2]=k[n+16>>2];k[s+20>>2]=k[n+20>>2];j[s+24>>1]=j[n+24>>1]|0;i[s+26>>0]=i[n+26>>0]|0;k[n>>2]=k[p>>2];k[n+4>>2]=k[p+4>>2];k[n+8>>2]=k[p+8>>2];k[n+12>>2]=k[p+12>>2];k[n+16>>2]=k[p+16>>2];k[n+20>>2]=k[p+20>>2];j[n+24>>1]=j[p+24>>1]|0;i[n+26>>0]=i[p+26>>0]|0;r=t;return}else if((m|0)==6){b=s+32|0;q=Za[k[c>>2]&7](b,s)|0;a=Za[k[c>>2]&7](n,b)|0;if(!q){if(!a){r=t;return};k[p>>2]=k[b>>2];k[p+4>>2]=k[b+4>>2];k[p+8>>2]=k[b+8>>2];k[p+12>>2]=k[b+12>>2];k[p+16>>2]=k[b+16>>2];k[p+20>>2]=k[b+20>>2];k[p+24>>2]=k[b+24>>2];k[p+28>>2]=k[b+28>>2];k[b>>2]=k[n>>2];k[b+4>>2]=k[n+4>>2];k[b+8>>2]=k[n+8>>2];k[b+12>>2]=k[n+12>>2];k[b+16>>2]=k[n+16>>2];k[b+20>>2]=k[n+20>>2];j[b+24>>1]=j[n+24>>1]|0;i[b+26>>0]=i[n+26>>0]|0;k[n>>2]=k[p>>2];k[n+4>>2]=k[p+4>>2];k[n+8>>2]=k[p+8>>2];k[n+12>>2]=k[p+12>>2];k[n+16>>2]=k[p+16>>2];k[n+20>>2]=k[p+20>>2];j[n+24>>1]=j[p+24>>1]|0;i[n+26>>0]=i[p+26>>0]|0;if(!(Za[k[c>>2]&7](b,s)|0)){r=t;return};k[p>>2]=k[s>>2];k[p+4>>2]=k[s+4>>2];k[p+8>>2]=k[s+8>>2];k[p+12>>2]=k[s+12>>2];k[p+16>>2]=k[s+16>>2];k[p+20>>2]=k[s+20>>2];k[p+24>>2]=k[s+24>>2];k[p+28>>2]=k[s+28>>2];k[s>>2]=k[b>>2];k[s+4>>2]=k[b+4>>2];k[s+8>>2]=k[b+8>>2];k[s+12>>2]=k[b+12>>2];k[s+16>>2]=k[b+16>>2];k[s+20>>2]=k[b+20>>2];j[s+24>>1]=j[b+24>>1]|0;i[s+26>>0]=i[b+26>>0]|0;k[b>>2]=k[p>>2];k[b+4>>2]=k[p+4>>2];k[b+8>>2]=k[p+8>>2];k[b+12>>2]=k[p+12>>2];k[b+16>>2]=k[p+16>>2];k[b+20>>2]=k[p+20>>2];j[b+24>>1]=j[p+24>>1]|0;i[b+26>>0]=i[p+26>>0]|0;r=t;return};k[p>>2]=k[s>>2];k[p+4>>2]=k[s+4>>2];k[p+8>>2]=k[s+8>>2];k[p+12>>2]=k[s+12>>2];k[p+16>>2]=k[s+16>>2];k[p+20>>2]=k[s+20>>2];k[p+24>>2]=k[s+24>>2];k[p+28>>2]=k[s+28>>2];if(a){k[s>>2]=k[n>>2];k[s+4>>2]=k[n+4>>2];k[s+8>>2]=k[n+8>>2];k[s+12>>2]=k[n+12>>2];k[s+16>>2]=k[n+16>>2];k[s+20>>2]=k[n+20>>2];j[s+24>>1]=j[n+24>>1]|0;i[s+26>>0]=i[n+26>>0]|0;k[n>>2]=k[p>>2];k[n+4>>2]=k[p+4>>2];k[n+8>>2]=k[p+8>>2];k[n+12>>2]=k[p+12>>2];k[n+16>>2]=k[p+16>>2];k[n+20>>2]=k[p+20>>2];j[n+24>>1]=j[p+24>>1]|0;i[n+26>>0]=i[p+26>>0]|0;r=t;return};k[s>>2]=k[b>>2];k[s+4>>2]=k[b+4>>2];k[s+8>>2]=k[b+8>>2];k[s+12>>2]=k[b+12>>2];k[s+16>>2]=k[b+16>>2];k[s+20>>2]=k[b+20>>2];j[s+24>>1]=j[b+24>>1]|0;i[s+26>>0]=i[b+26>>0]|0;k[b>>2]=k[p>>2];k[b+4>>2]=k[p+4>>2];k[b+8>>2]=k[p+8>>2];k[b+12>>2]=k[p+12>>2];k[b+16>>2]=k[p+16>>2];k[b+20>>2]=k[p+20>>2];j[b+24>>1]=j[p+24>>1]|0;i[b+26>>0]=i[p+26>>0]|0;if(!(Za[k[c>>2]&7](n,b)|0)){r=t;return};k[p>>2]=k[b>>2];k[p+4>>2]=k[b+4>>2];k[p+8>>2]=k[b+8>>2];k[p+12>>2]=k[b+12>>2];k[p+16>>2]=k[b+16>>2];k[p+20>>2]=k[b+20>>2];k[p+24>>2]=k[b+24>>2];k[p+28>>2]=k[b+28>>2];k[b>>2]=k[n>>2];k[b+4>>2]=k[n+4>>2];k[b+8>>2]=k[n+8>>2];k[b+12>>2]=k[n+12>>2];k[b+16>>2]=k[n+16>>2];k[b+20>>2]=k[n+20>>2];j[b+24>>1]=j[n+24>>1]|0;i[b+26>>0]=i[n+26>>0]|0;k[n>>2]=k[p>>2];k[n+4>>2]=k[p+4>>2];k[n+8>>2]=k[p+8>>2];k[n+12>>2]=k[p+12>>2];k[n+16>>2]=k[p+16>>2];k[n+20>>2]=k[p+20>>2];j[n+24>>1]=j[p+24>>1]|0;i[n+26>>0]=i[p+26>>0]|0;r=t;return}else if((m|0)==14){Fc(s,s+32|0,s+64|0,n,c)|0;r=t;return}else if((m|0)==15){a=s+32|0;b=s+64|0;d=s+96|0;Fc(s,a,b,d,c)|0;if(!(Za[k[c>>2]&7](n,d)|0)){r=t;return};k[p>>2]=k[d>>2];k[p+4>>2]=k[d+4>>2];k[p+8>>2]=k[d+8>>2];k[p+12>>2]=k[d+12>>2];k[p+16>>2]=k[d+16>>2];k[p+20>>2]=k[d+20>>2];k[p+24>>2]=k[d+24>>2];k[p+28>>2]=k[d+28>>2];k[d>>2]=k[n>>2];k[d+4>>2]=k[n+4>>2];k[d+8>>2]=k[n+8>>2];k[d+12>>2]=k[n+12>>2];k[d+16>>2]=k[n+16>>2];k[d+20>>2]=k[n+20>>2];j[d+24>>1]=j[n+24>>1]|0;i[d+26>>0]=i[n+26>>0]|0;k[n>>2]=k[p>>2];k[n+4>>2]=k[p+4>>2];k[n+8>>2]=k[p+8>>2];k[n+12>>2]=k[p+12>>2];k[n+16>>2]=k[p+16>>2];k[n+20>>2]=k[p+20>>2];j[n+24>>1]=j[p+24>>1]|0;i[n+26>>0]=i[p+26>>0]|0;if(!(Za[k[c>>2]&7](d,b)|0)){r=t;return};k[p>>2]=k[b>>2];k[p+4>>2]=k[b+4>>2];k[p+8>>2]=k[b+8>>2];k[p+12>>2]=k[b+12>>2];k[p+16>>2]=k[b+16>>2];k[p+20>>2]=k[b+20>>2];k[p+24>>2]=k[b+24>>2];k[p+28>>2]=k[b+28>>2];k[b>>2]=k[d>>2];k[b+4>>2]=k[d+4>>2];k[b+8>>2]=k[d+8>>2];k[b+12>>2]=k[d+12>>2];k[b+16>>2]=k[d+16>>2];k[b+20>>2]=k[d+20>>2];j[b+24>>1]=j[d+24>>1]|0;i[b+26>>0]=i[d+26>>0]|0;k[d>>2]=k[p>>2];k[d+4>>2]=k[p+4>>2];k[d+8>>2]=k[p+8>>2];k[d+12>>2]=k[p+12>>2];k[d+16>>2]=k[p+16>>2];k[d+20>>2]=k[p+20>>2];j[d+24>>1]=j[p+24>>1]|0;i[d+26>>0]=i[p+26>>0]|0;if(!(Za[k[c>>2]&7](b,a)|0)){r=t;return};k[p>>2]=k[a>>2];k[p+4>>2]=k[a+4>>2];k[p+8>>2]=k[a+8>>2];k[p+12>>2]=k[a+12>>2];k[p+16>>2]=k[a+16>>2];k[p+20>>2]=k[a+20>>2];k[p+24>>2]=k[a+24>>2];k[p+28>>2]=k[a+28>>2];k[a>>2]=k[b>>2];k[a+4>>2]=k[b+4>>2];k[a+8>>2]=k[b+8>>2];k[a+12>>2]=k[b+12>>2];k[a+16>>2]=k[b+16>>2];k[a+20>>2]=k[b+20>>2];j[a+24>>1]=j[b+24>>1]|0;i[a+26>>0]=i[b+26>>0]|0;k[b>>2]=k[p>>2];k[b+4>>2]=k[p+4>>2];k[b+8>>2]=k[p+8>>2];k[b+12>>2]=k[p+12>>2];k[b+16>>2]=k[p+16>>2];k[b+20>>2]=k[p+20>>2];j[b+24>>1]=j[p+24>>1]|0;i[b+26>>0]=i[p+26>>0]|0;if(!(Za[k[c>>2]&7](a,s)|0)){r=t;return};k[p>>2]=k[s>>2];k[p+4>>2]=k[s+4>>2];k[p+8>>2]=k[s+8>>2];k[p+12>>2]=k[s+12>>2];k[p+16>>2]=k[s+16>>2];k[p+20>>2]=k[s+20>>2];k[p+24>>2]=k[s+24>>2];k[p+28>>2]=k[s+28>>2];k[s>>2]=k[a>>2];k[s+4>>2]=k[a+4>>2];k[s+8>>2]=k[a+8>>2];k[s+12>>2]=k[a+12>>2];k[s+16>>2]=k[a+16>>2];k[s+20>>2]=k[a+20>>2];j[s+24>>1]=j[a+24>>1]|0;i[s+26>>0]=i[a+26>>0]|0;k[a>>2]=k[p>>2];k[a+4>>2]=k[p+4>>2];k[a+8>>2]=k[p+8>>2];k[a+12>>2]=k[p+12>>2];k[a+16>>2]=k[p+16>>2];k[a+20>>2]=k[p+20>>2];j[a+24>>1]=j[p+24>>1]|0;i[a+26>>0]=i[p+26>>0]|0;r=t;return}else if((m|0)==21){b=s+64|0;a=s+32|0;n=Za[k[c>>2]&7](a,s)|0;d=Za[k[c>>2]&7](b,a)|0;do if(n){k[p>>2]=k[s>>2];k[p+4>>2]=k[s+4>>2];k[p+8>>2]=k[s+8>>2];k[p+12>>2]=k[s+12>>2];k[p+16>>2]=k[s+16>>2];k[p+20>>2]=k[s+20>>2];k[p+24>>2]=k[s+24>>2];k[p+28>>2]=k[s+28>>2];if(d){k[s>>2]=k[b>>2];k[s+4>>2]=k[b+4>>2];k[s+8>>2]=k[b+8>>2];k[s+12>>2]=k[b+12>>2];k[s+16>>2]=k[b+16>>2];k[s+20>>2]=k[b+20>>2];j[s+24>>1]=j[b+24>>1]|0;i[s+26>>0]=i[b+26>>0]|0;k[b>>2]=k[p>>2];k[b+4>>2]=k[p+4>>2];k[b+8>>2]=k[p+8>>2];k[b+12>>2]=k[p+12>>2];k[b+16>>2]=k[p+16>>2];k[b+20>>2]=k[p+20>>2];j[b+24>>1]=j[p+24>>1]|0;i[b+26>>0]=i[p+26>>0]|0;break};k[s>>2]=k[a>>2];k[s+4>>2]=k[a+4>>2];k[s+8>>2]=k[a+8>>2];k[s+12>>2]=k[a+12>>2];k[s+16>>2]=k[a+16>>2];k[s+20>>2]=k[a+20>>2];j[s+24>>1]=j[a+24>>1]|0;i[s+26>>0]=i[a+26>>0]|0;k[a>>2]=k[p>>2];k[a+4>>2]=k[p+4>>2];k[a+8>>2]=k[p+8>>2];k[a+12>>2]=k[p+12>>2];k[a+16>>2]=k[p+16>>2];k[a+20>>2]=k[p+20>>2];j[a+24>>1]=j[p+24>>1]|0;i[a+26>>0]=i[p+26>>0]|0;if(Za[k[c>>2]&7](b,a)|0){k[p>>2]=k[a>>2];k[p+4>>2]=k[a+4>>2];k[p+8>>2]=k[a+8>>2];k[p+12>>2]=k[a+12>>2];k[p+16>>2]=k[a+16>>2];k[p+20>>2]=k[a+20>>2];k[p+24>>2]=k[a+24>>2];k[p+28>>2]=k[a+28>>2];k[a>>2]=k[b>>2];k[a+4>>2]=k[b+4>>2];k[a+8>>2]=k[b+8>>2];k[a+12>>2]=k[b+12>>2];k[a+16>>2]=k[b+16>>2];k[a+20>>2]=k[b+20>>2];j[a+24>>1]=j[b+24>>1]|0;i[a+26>>0]=i[b+26>>0]|0;k[b>>2]=k[p>>2];k[b+4>>2]=k[p+4>>2];k[b+8>>2]=k[p+8>>2];k[b+12>>2]=k[p+12>>2];k[b+16>>2]=k[p+16>>2];k[b+20>>2]=k[p+20>>2];j[b+24>>1]=j[p+24>>1]|0;i[b+26>>0]=i[p+26>>0]|0}}else if(d?(k[p>>2]=k[a>>2],k[p+4>>2]=k[a+4>>2],k[p+8>>2]=k[a+8>>2],k[p+12>>2]=k[a+12>>2],k[p+16>>2]=k[a+16>>2],k[p+20>>2]=k[a+20>>2],k[p+24>>2]=k[a+24>>2],k[p+28>>2]=k[a+28>>2],k[a>>2]=k[b>>2],k[a+4>>2]=k[b+4>>2],k[a+8>>2]=k[b+8>>2],k[a+12>>2]=k[b+12>>2],k[a+16>>2]=k[b+16>>2],k[a+20>>2]=k[b+20>>2],j[a+24>>1]=j[b+24>>1]|0,i[a+26>>0]=i[b+26>>0]|0,k[b>>2]=k[p>>2],k[b+4>>2]=k[p+4>>2],k[b+8>>2]=k[p+8>>2],k[b+12>>2]=k[p+12>>2],k[b+16>>2]=k[p+16>>2],k[b+20>>2]=k[p+20>>2],j[b+24>>1]=j[p+24>>1]|0,i[b+26>>0]=i[p+26>>0]|0,Za[k[c>>2]&7](a,s)|0):0){k[p>>2]=k[s>>2];k[p+4>>2]=k[s+4>>2];k[p+8>>2]=k[s+8>>2];k[p+12>>2]=k[s+12>>2];k[p+16>>2]=k[s+16>>2];k[p+20>>2]=k[s+20>>2];k[p+24>>2]=k[s+24>>2];k[p+28>>2]=k[s+28>>2];k[s>>2]=k[a>>2];k[s+4>>2]=k[a+4>>2];k[s+8>>2]=k[a+8>>2];k[s+12>>2]=k[a+12>>2];k[s+16>>2]=k[a+16>>2];k[s+20>>2]=k[a+20>>2];j[s+24>>1]=j[a+24>>1]|0;i[s+26>>0]=i[a+26>>0]|0;k[a>>2]=k[p>>2];k[a+4>>2]=k[p+4>>2];k[a+8>>2]=k[p+8>>2];k[a+12>>2]=k[p+12>>2];k[a+16>>2]=k[p+16>>2];k[a+20>>2]=k[p+20>>2];j[a+24>>1]=j[p+24>>1]|0;i[a+26>>0]=i[p+26>>0]|0}while(0);a=s+96|0;if((a|0)!=(o|0))while(1){if(Za[k[c>>2]&7](a,b)|0){k[q>>2]=k[a>>2];k[q+4>>2]=k[a+4>>2];k[q+8>>2]=k[a+8>>2];k[q+12>>2]=k[a+12>>2];k[q+16>>2]=k[a+16>>2];k[q+20>>2]=k[a+20>>2];k[q+24>>2]=k[a+24>>2];k[q+28>>2]=k[a+28>>2];d=a;e=b;while(1){k[d>>2]=k[e>>2];k[d+4>>2]=k[e+4>>2];k[d+8>>2]=k[e+8>>2];k[d+12>>2]=k[e+12>>2];k[d+16>>2]=k[e+16>>2];k[d+20>>2]=k[e+20>>2];j[d+24>>1]=j[e+24>>1]|0;i[d+26>>0]=i[e+26>>0]|0;if((e|0)==(s|0))break;b=e+-32|0;if(Za[k[c>>2]&7](q,b)|0){d=e;e=b}else break}k[e>>2]=k[q>>2];k[e+4>>2]=k[q+4>>2];k[e+8>>2]=k[q+8>>2];k[e+12>>2]=k[q+12>>2];k[e+16>>2]=k[q+16>>2];k[e+20>>2]=k[q+20>>2];j[e+24>>1]=j[q+24>>1]|0;i[e+26>>0]=i[q+26>>0]|0}b=a+32|0;if((b|0)==(o|0))break;else{p=a;a=b;b=p}}r=t;return}else if((m|0)==82){r=t;return}}function Fc(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;var f=0,g=0,h=0,l=0;h=r;r=r+32|0;g=h;l=Za[k[e>>2]&7](b,a)|0;f=Za[k[e>>2]&7](c,b)|0;do if(l){k[g>>2]=k[a>>2];k[g+4>>2]=k[a+4>>2];k[g+8>>2]=k[a+8>>2];k[g+12>>2]=k[a+12>>2];k[g+16>>2]=k[a+16>>2];k[g+20>>2]=k[a+20>>2];k[g+24>>2]=k[a+24>>2];k[g+28>>2]=k[a+28>>2];if(f){k[a>>2]=k[c>>2];k[a+4>>2]=k[c+4>>2];k[a+8>>2]=k[c+8>>2];k[a+12>>2]=k[c+12>>2];k[a+16>>2]=k[c+16>>2];k[a+20>>2]=k[c+20>>2];j[a+24>>1]=j[c+24>>1]|0;i[a+26>>0]=i[c+26>>0]|0;k[c>>2]=k[g>>2];k[c+4>>2]=k[g+4>>2];k[c+8>>2]=k[g+8>>2];k[c+12>>2]=k[g+12>>2];k[c+16>>2]=k[g+16>>2];k[c+20>>2]=k[g+20>>2];j[c+24>>1]=j[g+24>>1]|0;i[c+26>>0]=i[g+26>>0]|0;f=1;break};k[a>>2]=k[b>>2];k[a+4>>2]=k[b+4>>2];k[a+8>>2]=k[b+8>>2];k[a+12>>2]=k[b+12>>2];k[a+16>>2]=k[b+16>>2];k[a+20>>2]=k[b+20>>2];j[a+24>>1]=j[b+24>>1]|0;i[a+26>>0]=i[b+26>>0]|0;k[b>>2]=k[g>>2];k[b+4>>2]=k[g+4>>2];k[b+8>>2]=k[g+8>>2];k[b+12>>2]=k[g+12>>2];k[b+16>>2]=k[g+16>>2];k[b+20>>2]=k[g+20>>2];j[b+24>>1]=j[g+24>>1]|0;i[b+26>>0]=i[g+26>>0]|0;if(Za[k[e>>2]&7](c,b)|0){k[g>>2]=k[b>>2];k[g+4>>2]=k[b+4>>2];k[g+8>>2]=k[b+8>>2];k[g+12>>2]=k[b+12>>2];k[g+16>>2]=k[b+16>>2];k[g+20>>2]=k[b+20>>2];k[g+24>>2]=k[b+24>>2];k[g+28>>2]=k[b+28>>2];k[b>>2]=k[c>>2];k[b+4>>2]=k[c+4>>2];k[b+8>>2]=k[c+8>>2];k[b+12>>2]=k[c+12>>2];k[b+16>>2]=k[c+16>>2];k[b+20>>2]=k[c+20>>2];j[b+24>>1]=j[c+24>>1]|0;i[b+26>>0]=i[c+26>>0]|0;k[c>>2]=k[g>>2];k[c+4>>2]=k[g+4>>2];k[c+8>>2]=k[g+8>>2];k[c+12>>2]=k[g+12>>2];k[c+16>>2]=k[g+16>>2];k[c+20>>2]=k[g+20>>2];j[c+24>>1]=j[g+24>>1]|0;i[c+26>>0]=i[g+26>>0]|0;f=2}else f=1}else if(f){k[g>>2]=k[b>>2];k[g+4>>2]=k[b+4>>2];k[g+8>>2]=k[b+8>>2];k[g+12>>2]=k[b+12>>2];k[g+16>>2]=k[b+16>>2];k[g+20>>2]=k[b+20>>2];k[g+24>>2]=k[b+24>>2];k[g+28>>2]=k[b+28>>2];k[b>>2]=k[c>>2];k[b+4>>2]=k[c+4>>2];k[b+8>>2]=k[c+8>>2];k[b+12>>2]=k[c+12>>2];k[b+16>>2]=k[c+16>>2];k[b+20>>2]=k[c+20>>2];j[b+24>>1]=j[c+24>>1]|0;i[b+26>>0]=i[c+26>>0]|0;k[c>>2]=k[g>>2];k[c+4>>2]=k[g+4>>2];k[c+8>>2]=k[g+8>>2];k[c+12>>2]=k[g+12>>2];k[c+16>>2]=k[g+16>>2];k[c+20>>2]=k[g+20>>2];j[c+24>>1]=j[g+24>>1]|0;i[c+26>>0]=i[g+26>>0]|0;if(Za[k[e>>2]&7](b,a)|0){k[g>>2]=k[a>>2];k[g+4>>2]=k[a+4>>2];k[g+8>>2]=k[a+8>>2];k[g+12>>2]=k[a+12>>2];k[g+16>>2]=k[a+16>>2];k[g+20>>2]=k[a+20>>2];k[g+24>>2]=k[a+24>>2];k[g+28>>2]=k[a+28>>2];k[a>>2]=k[b>>2];k[a+4>>2]=k[b+4>>2];k[a+8>>2]=k[b+8>>2];k[a+12>>2]=k[b+12>>2];k[a+16>>2]=k[b+16>>2];k[a+20>>2]=k[b+20>>2];j[a+24>>1]=j[b+24>>1]|0;i[a+26>>0]=i[b+26>>0]|0;k[b>>2]=k[g>>2];k[b+4>>2]=k[g+4>>2];k[b+8>>2]=k[g+8>>2];k[b+12>>2]=k[g+12>>2];k[b+16>>2]=k[g+16>>2];k[b+20>>2]=k[g+20>>2];j[b+24>>1]=j[g+24>>1]|0;i[b+26>>0]=i[g+26>>0]|0;f=2}else f=1}else f=0;while(0);if(!(Za[k[e>>2]&7](d,c)|0)){l=f;r=h;return l|0};k[g>>2]=k[c>>2];k[g+4>>2]=k[c+4>>2];k[g+8>>2]=k[c+8>>2];k[g+12>>2]=k[c+12>>2];k[g+16>>2]=k[c+16>>2];k[g+20>>2]=k[c+20>>2];k[g+24>>2]=k[c+24>>2];k[g+28>>2]=k[c+28>>2];k[c>>2]=k[d>>2];k[c+4>>2]=k[d+4>>2];k[c+8>>2]=k[d+8>>2];k[c+12>>2]=k[d+12>>2];k[c+16>>2]=k[d+16>>2];k[c+20>>2]=k[d+20>>2];j[c+24>>1]=j[d+24>>1]|0;i[c+26>>0]=i[d+26>>0]|0;k[d>>2]=k[g>>2];k[d+4>>2]=k[g+4>>2];k[d+8>>2]=k[g+8>>2];k[d+12>>2]=k[g+12>>2];k[d+16>>2]=k[g+16>>2];k[d+20>>2]=k[g+20>>2];j[d+24>>1]=j[g+24>>1]|0;i[d+26>>0]=i[g+26>>0]|0;if(!(Za[k[e>>2]&7](c,b)|0)){l=f+1|0;r=h;return l|0};k[g>>2]=k[b>>2];k[g+4>>2]=k[b+4>>2];k[g+8>>2]=k[b+8>>2];k[g+12>>2]=k[b+12>>2];k[g+16>>2]=k[b+16>>2];k[g+20>>2]=k[b+20>>2];k[g+24>>2]=k[b+24>>2];k[g+28>>2]=k[b+28>>2];k[b>>2]=k[c>>2];k[b+4>>2]=k[c+4>>2];k[b+8>>2]=k[c+8>>2];k[b+12>>2]=k[c+12>>2];k[b+16>>2]=k[c+16>>2];k[b+20>>2]=k[c+20>>2];j[b+24>>1]=j[c+24>>1]|0;i[b+26>>0]=i[c+26>>0]|0;k[c>>2]=k[g>>2];k[c+4>>2]=k[g+4>>2];k[c+8>>2]=k[g+8>>2];k[c+12>>2]=k[g+12>>2];k[c+16>>2]=k[g+16>>2];k[c+20>>2]=k[g+20>>2];j[c+24>>1]=j[g+24>>1]|0;i[c+26>>0]=i[g+26>>0]|0;if(!(Za[k[e>>2]&7](b,a)|0)){l=f+2|0;r=h;return l|0};k[g>>2]=k[a>>2];k[g+4>>2]=k[a+4>>2];k[g+8>>2]=k[a+8>>2];k[g+12>>2]=k[a+12>>2];k[g+16>>2]=k[a+16>>2];k[g+20>>2]=k[a+20>>2];k[g+24>>2]=k[a+24>>2];k[g+28>>2]=k[a+28>>2];k[a>>2]=k[b>>2];k[a+4>>2]=k[b+4>>2];k[a+8>>2]=k[b+8>>2];k[a+12>>2]=k[b+12>>2];k[a+16>>2]=k[b+16>>2];k[a+20>>2]=k[b+20>>2];j[a+24>>1]=j[b+24>>1]|0;i[a+26>>0]=i[b+26>>0]|0;k[b>>2]=k[g>>2];k[b+4>>2]=k[g+4>>2];k[b+8>>2]=k[g+8>>2];k[b+12>>2]=k[g+12>>2];k[b+16>>2]=k[g+16>>2];k[b+20>>2]=k[g+20>>2];j[b+24>>1]=j[g+24>>1]|0;i[b+26>>0]=i[g+26>>0]|0;l=f+3|0;r=h;return l|0}function Gc(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0,l=0,m=0,n=0;n=r;r=r+64|0;h=n+32|0;l=n;switch(b-a>>5|0){case 2:{d=b+-32|0;if(!(Za[k[c>>2]&7](d,a)|0)){a=1;r=n;return a|0};k[h>>2]=k[a>>2];k[h+4>>2]=k[a+4>>2];k[h+8>>2]=k[a+8>>2];k[h+12>>2]=k[a+12>>2];k[h+16>>2]=k[a+16>>2];k[h+20>>2]=k[a+20>>2];k[h+24>>2]=k[a+24>>2];k[h+28>>2]=k[a+28>>2];k[a>>2]=k[d>>2];k[a+4>>2]=k[d+4>>2];k[a+8>>2]=k[d+8>>2];k[a+12>>2]=k[d+12>>2];k[a+16>>2]=k[d+16>>2];k[a+20>>2]=k[d+20>>2];j[a+24>>1]=j[d+24>>1]|0;i[a+26>>0]=i[d+26>>0]|0;k[d>>2]=k[h>>2];k[d+4>>2]=k[h+4>>2];k[d+8>>2]=k[h+8>>2];k[d+12>>2]=k[h+12>>2];k[d+16>>2]=k[h+16>>2];k[d+20>>2]=k[h+20>>2];j[d+24>>1]=j[h+24>>1]|0;i[d+26>>0]=i[h+26>>0]|0;a=1;r=n;return a|0}case 3:{f=a+32|0;e=b+-32|0;b=Za[k[c>>2]&7](f,a)|0;d=Za[k[c>>2]&7](e,f)|0;if(!b){if(!d){a=1;r=n;return a|0};k[h>>2]=k[f>>2];k[h+4>>2]=k[f+4>>2];k[h+8>>2]=k[f+8>>2];k[h+12>>2]=k[f+12>>2];k[h+16>>2]=k[f+16>>2];k[h+20>>2]=k[f+20>>2];k[h+24>>2]=k[f+24>>2];k[h+28>>2]=k[f+28>>2];k[f>>2]=k[e>>2];k[f+4>>2]=k[e+4>>2];k[f+8>>2]=k[e+8>>2];k[f+12>>2]=k[e+12>>2];k[f+16>>2]=k[e+16>>2];k[f+20>>2]=k[e+20>>2];j[f+24>>1]=j[e+24>>1]|0;i[f+26>>0]=i[e+26>>0]|0;k[e>>2]=k[h>>2];k[e+4>>2]=k[h+4>>2];k[e+8>>2]=k[h+8>>2];k[e+12>>2]=k[h+12>>2];k[e+16>>2]=k[h+16>>2];k[e+20>>2]=k[h+20>>2];j[e+24>>1]=j[h+24>>1]|0;i[e+26>>0]=i[h+26>>0]|0;if(!(Za[k[c>>2]&7](f,a)|0)){a=1;r=n;return a|0};k[h>>2]=k[a>>2];k[h+4>>2]=k[a+4>>2];k[h+8>>2]=k[a+8>>2];k[h+12>>2]=k[a+12>>2];k[h+16>>2]=k[a+16>>2];k[h+20>>2]=k[a+20>>2];k[h+24>>2]=k[a+24>>2];k[h+28>>2]=k[a+28>>2];k[a>>2]=k[f>>2];k[a+4>>2]=k[f+4>>2];k[a+8>>2]=k[f+8>>2];k[a+12>>2]=k[f+12>>2];k[a+16>>2]=k[f+16>>2];k[a+20>>2]=k[f+20>>2];j[a+24>>1]=j[f+24>>1]|0;i[a+26>>0]=i[f+26>>0]|0;k[f>>2]=k[h>>2];k[f+4>>2]=k[h+4>>2];k[f+8>>2]=k[h+8>>2];k[f+12>>2]=k[h+12>>2];k[f+16>>2]=k[h+16>>2];k[f+20>>2]=k[h+20>>2];j[f+24>>1]=j[h+24>>1]|0;i[f+26>>0]=i[h+26>>0]|0;a=1;r=n;return a|0};k[h>>2]=k[a>>2];k[h+4>>2]=k[a+4>>2];k[h+8>>2]=k[a+8>>2];k[h+12>>2]=k[a+12>>2];k[h+16>>2]=k[a+16>>2];k[h+20>>2]=k[a+20>>2];k[h+24>>2]=k[a+24>>2];k[h+28>>2]=k[a+28>>2];if(d){k[a>>2]=k[e>>2];k[a+4>>2]=k[e+4>>2];k[a+8>>2]=k[e+8>>2];k[a+12>>2]=k[e+12>>2];k[a+16>>2]=k[e+16>>2];k[a+20>>2]=k[e+20>>2];j[a+24>>1]=j[e+24>>1]|0;i[a+26>>0]=i[e+26>>0]|0;k[e>>2]=k[h>>2];k[e+4>>2]=k[h+4>>2];k[e+8>>2]=k[h+8>>2];k[e+12>>2]=k[h+12>>2];k[e+16>>2]=k[h+16>>2];k[e+20>>2]=k[h+20>>2];j[e+24>>1]=j[h+24>>1]|0;i[e+26>>0]=i[h+26>>0]|0;a=1;r=n;return a|0};k[a>>2]=k[f>>2];k[a+4>>2]=k[f+4>>2];k[a+8>>2]=k[f+8>>2];k[a+12>>2]=k[f+12>>2];k[a+16>>2]=k[f+16>>2];k[a+20>>2]=k[f+20>>2];j[a+24>>1]=j[f+24>>1]|0;i[a+26>>0]=i[f+26>>0]|0;k[f>>2]=k[h>>2];k[f+4>>2]=k[h+4>>2];k[f+8>>2]=k[h+8>>2];k[f+12>>2]=k[h+12>>2];k[f+16>>2]=k[h+16>>2];k[f+20>>2]=k[h+20>>2];j[f+24>>1]=j[h+24>>1]|0;i[f+26>>0]=i[h+26>>0]|0;if(!(Za[k[c>>2]&7](e,f)|0)){a=1;r=n;return a|0};k[h>>2]=k[f>>2];k[h+4>>2]=k[f+4>>2];k[h+8>>2]=k[f+8>>2];k[h+12>>2]=k[f+12>>2];k[h+16>>2]=k[f+16>>2];k[h+20>>2]=k[f+20>>2];k[h+24>>2]=k[f+24>>2];k[h+28>>2]=k[f+28>>2];k[f>>2]=k[e>>2];k[f+4>>2]=k[e+4>>2];k[f+8>>2]=k[e+8>>2];k[f+12>>2]=k[e+12>>2];k[f+16>>2]=k[e+16>>2];k[f+20>>2]=k[e+20>>2];j[f+24>>1]=j[e+24>>1]|0;i[f+26>>0]=i[e+26>>0]|0;k[e>>2]=k[h>>2];k[e+4>>2]=k[h+4>>2];k[e+8>>2]=k[h+8>>2];k[e+12>>2]=k[h+12>>2];k[e+16>>2]=k[h+16>>2];k[e+20>>2]=k[h+20>>2];j[e+24>>1]=j[h+24>>1]|0;i[e+26>>0]=i[h+26>>0]|0;a=1;r=n;return a|0}case 4:{Fc(a,a+32|0,a+64|0,b+-32|0,c)|0;a=1;r=n;return a|0}case 5:{e=a+32|0;f=a+64|0;g=a+96|0;d=b+-32|0;Fc(a,e,f,g,c)|0;if(!(Za[k[c>>2]&7](d,g)|0)){a=1;r=n;return a|0};k[h>>2]=k[g>>2];k[h+4>>2]=k[g+4>>2];k[h+8>>2]=k[g+8>>2];k[h+12>>2]=k[g+12>>2];k[h+16>>2]=k[g+16>>2];k[h+20>>2]=k[g+20>>2];k[h+24>>2]=k[g+24>>2];k[h+28>>2]=k[g+28>>2];k[g>>2]=k[d>>2];k[g+4>>2]=k[d+4>>2];k[g+8>>2]=k[d+8>>2];k[g+12>>2]=k[d+12>>2];k[g+16>>2]=k[d+16>>2];k[g+20>>2]=k[d+20>>2];j[g+24>>1]=j[d+24>>1]|0;i[g+26>>0]=i[d+26>>0]|0;k[d>>2]=k[h>>2];k[d+4>>2]=k[h+4>>2];k[d+8>>2]=k[h+8>>2];k[d+12>>2]=k[h+12>>2];k[d+16>>2]=k[h+16>>2];k[d+20>>2]=k[h+20>>2];j[d+24>>1]=j[h+24>>1]|0;i[d+26>>0]=i[h+26>>0]|0;if(!(Za[k[c>>2]&7](g,f)|0)){a=1;r=n;return a|0};k[h>>2]=k[f>>2];k[h+4>>2]=k[f+4>>2];k[h+8>>2]=k[f+8>>2];k[h+12>>2]=k[f+12>>2];k[h+16>>2]=k[f+16>>2];k[h+20>>2]=k[f+20>>2];k[h+24>>2]=k[f+24>>2];k[h+28>>2]=k[f+28>>2];k[f>>2]=k[g>>2];k[f+4>>2]=k[g+4>>2];k[f+8>>2]=k[g+8>>2];k[f+12>>2]=k[g+12>>2];k[f+16>>2]=k[g+16>>2];k[f+20>>2]=k[g+20>>2];j[f+24>>1]=j[g+24>>1]|0;i[f+26>>0]=i[g+26>>0]|0;k[g>>2]=k[h>>2];k[g+4>>2]=k[h+4>>2];k[g+8>>2]=k[h+8>>2];k[g+12>>2]=k[h+12>>2];k[g+16>>2]=k[h+16>>2];k[g+20>>2]=k[h+20>>2];j[g+24>>1]=j[h+24>>1]|0;i[g+26>>0]=i[h+26>>0]|0;if(!(Za[k[c>>2]&7](f,e)|0)){a=1;r=n;return a|0};k[h>>2]=k[e>>2];k[h+4>>2]=k[e+4>>2];k[h+8>>2]=k[e+8>>2];k[h+12>>2]=k[e+12>>2];k[h+16>>2]=k[e+16>>2];k[h+20>>2]=k[e+20>>2];k[h+24>>2]=k[e+24>>2];k[h+28>>2]=k[e+28>>2];k[e>>2]=k[f>>2];k[e+4>>2]=k[f+4>>2];k[e+8>>2]=k[f+8>>2];k[e+12>>2]=k[f+12>>2];k[e+16>>2]=k[f+16>>2];k[e+20>>2]=k[f+20>>2];j[e+24>>1]=j[f+24>>1]|0;i[e+26>>0]=i[f+26>>0]|0;k[f>>2]=k[h>>2];k[f+4>>2]=k[h+4>>2];k[f+8>>2]=k[h+8>>2];k[f+12>>2]=k[h+12>>2];k[f+16>>2]=k[h+16>>2];k[f+20>>2]=k[h+20>>2];j[f+24>>1]=j[h+24>>1]|0;i[f+26>>0]=i[h+26>>0]|0;if(!(Za[k[c>>2]&7](e,a)|0)){a=1;r=n;return a|0};k[h>>2]=k[a>>2];k[h+4>>2]=k[a+4>>2];k[h+8>>2]=k[a+8>>2];k[h+12>>2]=k[a+12>>2];k[h+16>>2]=k[a+16>>2];k[h+20>>2]=k[a+20>>2];k[h+24>>2]=k[a+24>>2];k[h+28>>2]=k[a+28>>2];k[a>>2]=k[e>>2];k[a+4>>2]=k[e+4>>2];k[a+8>>2]=k[e+8>>2];k[a+12>>2]=k[e+12>>2];k[a+16>>2]=k[e+16>>2];k[a+20>>2]=k[e+20>>2];j[a+24>>1]=j[e+24>>1]|0;i[a+26>>0]=i[e+26>>0]|0;k[e>>2]=k[h>>2];k[e+4>>2]=k[h+4>>2];k[e+8>>2]=k[h+8>>2];k[e+12>>2]=k[h+12>>2];k[e+16>>2]=k[h+16>>2];k[e+20>>2]=k[h+20>>2];j[e+24>>1]=j[h+24>>1]|0;i[e+26>>0]=i[h+26>>0]|0;a=1;r=n;return a|0}case 1:case 0:{a=1;r=n;return a|0}default:{f=a+64|0;d=a+32|0;g=Za[k[c>>2]&7](d,a)|0;e=Za[k[c>>2]&7](f,d)|0;do if(g){k[h>>2]=k[a>>2];k[h+4>>2]=k[a+4>>2];k[h+8>>2]=k[a+8>>2];k[h+12>>2]=k[a+12>>2];k[h+16>>2]=k[a+16>>2];k[h+20>>2]=k[a+20>>2];k[h+24>>2]=k[a+24>>2];k[h+28>>2]=k[a+28>>2];if(e){k[a>>2]=k[f>>2];k[a+4>>2]=k[f+4>>2];k[a+8>>2]=k[f+8>>2];k[a+12>>2]=k[f+12>>2];k[a+16>>2]=k[f+16>>2];k[a+20>>2]=k[f+20>>2];j[a+24>>1]=j[f+24>>1]|0;i[a+26>>0]=i[f+26>>0]|0;k[f>>2]=k[h>>2];k[f+4>>2]=k[h+4>>2];k[f+8>>2]=k[h+8>>2];k[f+12>>2]=k[h+12>>2];k[f+16>>2]=k[h+16>>2];k[f+20>>2]=k[h+20>>2];j[f+24>>1]=j[h+24>>1]|0;i[f+26>>0]=i[h+26>>0]|0;break};k[a>>2]=k[d>>2];k[a+4>>2]=k[d+4>>2];k[a+8>>2]=k[d+8>>2];k[a+12>>2]=k[d+12>>2];k[a+16>>2]=k[d+16>>2];k[a+20>>2]=k[d+20>>2];j[a+24>>1]=j[d+24>>1]|0;i[a+26>>0]=i[d+26>>0]|0;k[d>>2]=k[h>>2];k[d+4>>2]=k[h+4>>2];k[d+8>>2]=k[h+8>>2];k[d+12>>2]=k[h+12>>2];k[d+16>>2]=k[h+16>>2];k[d+20>>2]=k[h+20>>2];j[d+24>>1]=j[h+24>>1]|0;i[d+26>>0]=i[h+26>>0]|0;if(Za[k[c>>2]&7](f,d)|0){k[h>>2]=k[d>>2];k[h+4>>2]=k[d+4>>2];k[h+8>>2]=k[d+8>>2];k[h+12>>2]=k[d+12>>2];k[h+16>>2]=k[d+16>>2];k[h+20>>2]=k[d+20>>2];k[h+24>>2]=k[d+24>>2];k[h+28>>2]=k[d+28>>2];k[d>>2]=k[f>>2];k[d+4>>2]=k[f+4>>2];k[d+8>>2]=k[f+8>>2];k[d+12>>2]=k[f+12>>2];k[d+16>>2]=k[f+16>>2];k[d+20>>2]=k[f+20>>2];j[d+24>>1]=j[f+24>>1]|0;i[d+26>>0]=i[f+26>>0]|0;k[f>>2]=k[h>>2];k[f+4>>2]=k[h+4>>2];k[f+8>>2]=k[h+8>>2];k[f+12>>2]=k[h+12>>2];k[f+16>>2]=k[h+16>>2];k[f+20>>2]=k[h+20>>2];j[f+24>>1]=j[h+24>>1]|0;i[f+26>>0]=i[h+26>>0]|0}}else if(e?(k[h>>2]=k[d>>2],k[h+4>>2]=k[d+4>>2],k[h+8>>2]=k[d+8>>2],k[h+12>>2]=k[d+12>>2],k[h+16>>2]=k[d+16>>2],k[h+20>>2]=k[d+20>>2],k[h+24>>2]=k[d+24>>2],k[h+28>>2]=k[d+28>>2],k[d>>2]=k[f>>2],k[d+4>>2]=k[f+4>>2],k[d+8>>2]=k[f+8>>2],k[d+12>>2]=k[f+12>>2],k[d+16>>2]=k[f+16>>2],k[d+20>>2]=k[f+20>>2],j[d+24>>1]=j[f+24>>1]|0,i[d+26>>0]=i[f+26>>0]|0,k[f>>2]=k[h>>2],k[f+4>>2]=k[h+4>>2],k[f+8>>2]=k[h+8>>2],k[f+12>>2]=k[h+12>>2],k[f+16>>2]=k[h+16>>2],k[f+20>>2]=k[h+20>>2],j[f+24>>1]=j[h+24>>1]|0,i[f+26>>0]=i[h+26>>0]|0,Za[k[c>>2]&7](d,a)|0):0){k[h>>2]=k[a>>2];k[h+4>>2]=k[a+4>>2];k[h+8>>2]=k[a+8>>2];k[h+12>>2]=k[a+12>>2];k[h+16>>2]=k[a+16>>2];k[h+20>>2]=k[a+20>>2];k[h+24>>2]=k[a+24>>2];k[h+28>>2]=k[a+28>>2];k[a>>2]=k[d>>2];k[a+4>>2]=k[d+4>>2];k[a+8>>2]=k[d+8>>2];k[a+12>>2]=k[d+12>>2];k[a+16>>2]=k[d+16>>2];k[a+20>>2]=k[d+20>>2];j[a+24>>1]=j[d+24>>1]|0;i[a+26>>0]=i[d+26>>0]|0;k[d>>2]=k[h>>2];k[d+4>>2]=k[h+4>>2];k[d+8>>2]=k[h+8>>2];k[d+12>>2]=k[h+12>>2];k[d+16>>2]=k[h+16>>2];k[d+20>>2]=k[h+20>>2];j[d+24>>1]=j[h+24>>1]|0;i[d+26>>0]=i[h+26>>0]|0}while(0);e=a+96|0;if((e|0)==(b|0)){a=1;r=n;return a|0}d=0;while(1){if(Za[k[c>>2]&7](e,f)|0){k[l>>2]=k[e>>2];k[l+4>>2]=k[e+4>>2];k[l+8>>2]=k[e+8>>2];k[l+12>>2]=k[e+12>>2];k[l+16>>2]=k[e+16>>2];k[l+20>>2]=k[e+20>>2];k[l+24>>2]=k[e+24>>2];k[l+28>>2]=k[e+28>>2];g=e;h=f;while(1){k[g>>2]=k[h>>2];k[g+4>>2]=k[h+4>>2];k[g+8>>2]=k[h+8>>2];k[g+12>>2]=k[h+12>>2];k[g+16>>2]=k[h+16>>2];k[g+20>>2]=k[h+20>>2];j[g+24>>1]=j[h+24>>1]|0;i[g+26>>0]=i[h+26>>0]|0;if((h|0)==(a|0))break;f=h+-32|0;if(Za[k[c>>2]&7](l,f)|0){g=h;h=f}else break}k[h>>2]=k[l>>2];k[h+4>>2]=k[l+4>>2];k[h+8>>2]=k[l+8>>2];k[h+12>>2]=k[l+12>>2];k[h+16>>2]=k[l+16>>2];k[h+20>>2]=k[l+20>>2];j[h+24>>1]=j[l+24>>1]|0;i[h+26>>0]=i[l+26>>0]|0;d=d+1|0;if((d|0)==8)break}f=e+32|0;if((f|0)==(b|0)){d=1;m=35;break}else{h=e;e=f;f=h}}if((m|0)==35){r=n;return d|0}a=(e+32|0)==(b|0);r=n;return a|0}}return 0}function Hc(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0,j=0,l=0;l=r;r=r+48|0;j=l;i=Za[k[e>>2]&7](b,a)|0;f=Za[k[e>>2]&7](c,b)|0;do if(i){if(f){g=j;h=a;i=g+44|0;do{k[g>>2]=k[h>>2];g=g+4|0;h=h+4|0}while((g|0)<(i|0));g=a;h=c;i=g+44|0;do{k[g>>2]=k[h>>2];g=g+4|0;h=h+4|0}while((g|0)<(i|0));g=c;h=j;i=g+44|0;do{k[g>>2]=k[h>>2];g=g+4|0;h=h+4|0}while((g|0)<(i|0));f=1;break}g=j;h=a;i=g+44|0;do{k[g>>2]=k[h>>2];g=g+4|0;h=h+4|0}while((g|0)<(i|0));g=a;h=b;i=g+44|0;do{k[g>>2]=k[h>>2];g=g+4|0;h=h+4|0}while((g|0)<(i|0));g=b;h=j;i=g+44|0;do{k[g>>2]=k[h>>2];g=g+4|0;h=h+4|0}while((g|0)<(i|0));if(Za[k[e>>2]&7](c,b)|0){g=j;h=b;i=g+44|0;do{k[g>>2]=k[h>>2];g=g+4|0;h=h+4|0}while((g|0)<(i|0));g=b;h=c;i=g+44|0;do{k[g>>2]=k[h>>2];g=g+4|0;h=h+4|0}while((g|0)<(i|0));g=c;h=j;i=g+44|0;do{k[g>>2]=k[h>>2];g=g+4|0;h=h+4|0}while((g|0)<(i|0));f=2}else f=1}else if(f){g=j;h=b;i=g+44|0;do{k[g>>2]=k[h>>2];g=g+4|0;h=h+4|0}while((g|0)<(i|0));g=b;h=c;i=g+44|0;do{k[g>>2]=k[h>>2];g=g+4|0;h=h+4|0}while((g|0)<(i|0));g=c;h=j;i=g+44|0;do{k[g>>2]=k[h>>2];g=g+4|0;h=h+4|0}while((g|0)<(i|0));if(Za[k[e>>2]&7](b,a)|0){g=j;h=a;i=g+44|0;do{k[g>>2]=k[h>>2];g=g+4|0;h=h+4|0}while((g|0)<(i|0));g=a;h=b;i=g+44|0;do{k[g>>2]=k[h>>2];g=g+4|0;h=h+4|0}while((g|0)<(i|0));g=b;h=j;i=g+44|0;do{k[g>>2]=k[h>>2];g=g+4|0;h=h+4|0}while((g|0)<(i|0));f=2}else f=1}else f=0;while(0);if(!(Za[k[e>>2]&7](d,c)|0)){d=f;r=l;return d|0}g=j;h=c;i=g+44|0;do{k[g>>2]=k[h>>2];g=g+4|0;h=h+4|0}while((g|0)<(i|0));g=c;h=d;i=g+44|0;do{k[g>>2]=k[h>>2];g=g+4|0;h=h+4|0}while((g|0)<(i|0));g=d;h=j;i=g+44|0;do{k[g>>2]=k[h>>2];g=g+4|0;h=h+4|0}while((g|0)<(i|0));if(!(Za[k[e>>2]&7](c,b)|0)){d=f+1|0;r=l;return d|0}g=j;h=b;i=g+44|0;do{k[g>>2]=k[h>>2];g=g+4|0;h=h+4|0}while((g|0)<(i|0));g=b;h=c;i=g+44|0;do{k[g>>2]=k[h>>2];g=g+4|0;h=h+4|0}while((g|0)<(i|0));g=c;h=j;i=g+44|0;do{k[g>>2]=k[h>>2];g=g+4|0;h=h+4|0}while((g|0)<(i|0));if(!(Za[k[e>>2]&7](b,a)|0)){d=f+2|0;r=l;return d|0}g=j;h=a;i=g+44|0;do{k[g>>2]=k[h>>2];g=g+4|0;h=h+4|0}while((g|0)<(i|0));g=a;h=b;i=g+44|0;do{k[g>>2]=k[h>>2];g=g+4|0;h=h+4|0}while((g|0)<(i|0));g=b;h=j;i=g+44|0;do{k[g>>2]=k[h>>2];g=g+4|0;h=h+4|0}while((g|0)<(i|0));d=f+3|0;r=l;return d|0}function Ic(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,l=0,m=0,n=0;n=r;r=r+48|0;m=n;switch((b-a|0)/44|0|0){case 2:{d=b+-44|0;if(!(Za[k[c>>2]&7](d,a)|0)){m=1;r=n;return m|0}g=m;j=a;l=g+44|0;do{k[g>>2]=k[j>>2];g=g+4|0;j=j+4|0}while((g|0)<(l|0));g=a;j=d;l=g+44|0;do{k[g>>2]=k[j>>2];g=g+4|0;j=j+4|0}while((g|0)<(l|0));g=d;j=m;l=g+44|0;do{k[g>>2]=k[j>>2];g=g+4|0;j=j+4|0}while((g|0)<(l|0));m=1;r=n;return m|0}case 3:{f=a+44|0;e=b+-44|0;b=Za[k[c>>2]&7](f,a)|0;d=Za[k[c>>2]&7](e,f)|0;if(!b){if(!d){m=1;r=n;return m|0}g=m;j=f;l=g+44|0;do{k[g>>2]=k[j>>2];g=g+4|0;j=j+4|0}while((g|0)<(l|0));g=f;j=e;l=g+44|0;do{k[g>>2]=k[j>>2];g=g+4|0;j=j+4|0}while((g|0)<(l|0));g=e;j=m;l=g+44|0;do{k[g>>2]=k[j>>2];g=g+4|0;j=j+4|0}while((g|0)<(l|0));if(!(Za[k[c>>2]&7](f,a)|0)){m=1;r=n;return m|0}g=m;j=a;l=g+44|0;do{k[g>>2]=k[j>>2];g=g+4|0;j=j+4|0}while((g|0)<(l|0));g=a;j=f;l=g+44|0;do{k[g>>2]=k[j>>2];g=g+4|0;j=j+4|0}while((g|0)<(l|0));g=f;j=m;l=g+44|0;do{k[g>>2]=k[j>>2];g=g+4|0;j=j+4|0}while((g|0)<(l|0));m=1;r=n;return m|0}if(d){g=m;j=a;l=g+44|0;do{k[g>>2]=k[j>>2];g=g+4|0;j=j+4|0}while((g|0)<(l|0));g=a;j=e;l=g+44|0;do{k[g>>2]=k[j>>2];g=g+4|0;j=j+4|0}while((g|0)<(l|0));g=e;j=m;l=g+44|0;do{k[g>>2]=k[j>>2];g=g+4|0;j=j+4|0}while((g|0)<(l|0));m=1;r=n;return m|0}g=m;j=a;l=g+44|0;do{k[g>>2]=k[j>>2];g=g+4|0;j=j+4|0}while((g|0)<(l|0));g=a;j=f;l=g+44|0;do{k[g>>2]=k[j>>2];g=g+4|0;j=j+4|0}while((g|0)<(l|0));g=f;j=m;l=g+44|0;do{k[g>>2]=k[j>>2];g=g+4|0;j=j+4|0}while((g|0)<(l|0));if(!(Za[k[c>>2]&7](e,f)|0)){m=1;r=n;return m|0}g=m;j=f;l=g+44|0;do{k[g>>2]=k[j>>2];g=g+4|0;j=j+4|0}while((g|0)<(l|0));g=f;j=e;l=g+44|0;do{k[g>>2]=k[j>>2];g=g+4|0;j=j+4|0}while((g|0)<(l|0));g=e;j=m;l=g+44|0;do{k[g>>2]=k[j>>2];g=g+4|0;j=j+4|0}while((g|0)<(l|0));m=1;r=n;return m|0}case 4:{Hc(a,a+44|0,a+88|0,b+-44|0,c)|0;m=1;r=n;return m|0}case 5:{e=a+44|0;f=a+88|0;h=a+132|0;d=b+-44|0;Hc(a,e,f,h,c)|0;if(!(Za[k[c>>2]&7](d,h)|0)){m=1;r=n;return m|0}g=m;j=h;l=g+44|0;do{k[g>>2]=k[j>>2];g=g+4|0;j=j+4|0}while((g|0)<(l|0));g=h;j=d;l=g+44|0;do{k[g>>2]=k[j>>2];g=g+4|0;j=j+4|0}while((g|0)<(l|0));g=d;j=m;l=g+44|0;do{k[g>>2]=k[j>>2];g=g+4|0;j=j+4|0}while((g|0)<(l|0));if(!(Za[k[c>>2]&7](h,f)|0)){m=1;r=n;return m|0}g=m;j=f;l=g+44|0;do{k[g>>2]=k[j>>2];g=g+4|0;j=j+4|0}while((g|0)<(l|0));g=f;j=h;l=g+44|0;do{k[g>>2]=k[j>>2];g=g+4|0;j=j+4|0}while((g|0)<(l|0));g=h;j=m;l=g+44|0;do{k[g>>2]=k[j>>2];g=g+4|0;j=j+4|0}while((g|0)<(l|0));if(!(Za[k[c>>2]&7](f,e)|0)){m=1;r=n;return m|0}g=m;j=e;l=g+44|0;do{k[g>>2]=k[j>>2];g=g+4|0;j=j+4|0}while((g|0)<(l|0));g=e;j=f;l=g+44|0;do{k[g>>2]=k[j>>2];g=g+4|0;j=j+4|0}while((g|0)<(l|0));g=f;j=m;l=g+44|0;do{k[g>>2]=k[j>>2];g=g+4|0;j=j+4|0}while((g|0)<(l|0));if(!(Za[k[c>>2]&7](e,a)|0)){m=1;r=n;return m|0}g=m;j=a;l=g+44|0;do{k[g>>2]=k[j>>2];g=g+4|0;j=j+4|0}while((g|0)<(l|0));g=a;j=e;l=g+44|0;do{k[g>>2]=k[j>>2];g=g+4|0;j=j+4|0}while((g|0)<(l|0));g=e;j=m;l=g+44|0;do{k[g>>2]=k[j>>2];g=g+4|0;j=j+4|0}while((g|0)<(l|0));m=1;r=n;return m|0}case 1:case 0:{m=1;r=n;return m|0}default:{f=a+88|0;e=a+44|0;l=Za[k[c>>2]&7](e,a)|0;d=Za[k[c>>2]&7](f,e)|0;do if(l){if(d){g=m;j=a;l=g+44|0;do{k[g>>2]=k[j>>2];g=g+4|0;j=j+4|0}while((g|0)<(l|0));g=a;j=f;l=g+44|0;do{k[g>>2]=k[j>>2];g=g+4|0;j=j+4|0}while((g|0)<(l|0));g=f;j=m;l=g+44|0;do{k[g>>2]=k[j>>2];g=g+4|0;j=j+4|0}while((g|0)<(l|0));break}g=m;j=a;l=g+44|0;do{k[g>>2]=k[j>>2];g=g+4|0;j=j+4|0}while((g|0)<(l|0));g=a;j=e;l=g+44|0;do{k[g>>2]=k[j>>2];g=g+4|0;j=j+4|0}while((g|0)<(l|0));g=e;j=m;l=g+44|0;do{k[g>>2]=k[j>>2];g=g+4|0;j=j+4|0}while((g|0)<(l|0));if(Za[k[c>>2]&7](f,e)|0){g=m;j=e;l=g+44|0;do{k[g>>2]=k[j>>2];g=g+4|0;j=j+4|0}while((g|0)<(l|0));g=e;j=f;l=g+44|0;do{k[g>>2]=k[j>>2];g=g+4|0;j=j+4|0}while((g|0)<(l|0));g=f;j=m;l=g+44|0;do{k[g>>2]=k[j>>2];g=g+4|0;j=j+4|0}while((g|0)<(l|0))}}else if(d){g=m;j=e;l=g+44|0;do{k[g>>2]=k[j>>2];g=g+4|0;j=j+4|0}while((g|0)<(l|0));g=e;j=f;l=g+44|0;do{k[g>>2]=k[j>>2];g=g+4|0;j=j+4|0}while((g|0)<(l|0));g=f;j=m;l=g+44|0;do{k[g>>2]=k[j>>2];g=g+4|0;j=j+4|0}while((g|0)<(l|0));if(Za[k[c>>2]&7](e,a)|0){g=m;j=a;l=g+44|0;do{k[g>>2]=k[j>>2];g=g+4|0;j=j+4|0}while((g|0)<(l|0));g=a;j=e;l=g+44|0;do{k[g>>2]=k[j>>2];g=g+4|0;j=j+4|0}while((g|0)<(l|0));g=e;j=m;l=g+44|0;do{k[g>>2]=k[j>>2];g=g+4|0;j=j+4|0}while((g|0)<(l|0))}}while(0);e=a+132|0;if((e|0)==(b|0)){m=1;r=n;return m|0}d=0;i=0;while(1){if(Za[k[c>>2]&7](e,f)|0){g=m;j=e;l=g+44|0;do{k[g>>2]=k[j>>2];g=g+4|0;j=j+4|0}while((g|0)<(l|0));g=e;h=f;while(1){j=h;l=g+44|0;do{k[g>>2]=k[j>>2];g=g+4|0;j=j+4|0}while((g|0)<(l|0));if((h|0)==(a|0))break;f=h+-44|0;if(Za[k[c>>2]&7](m,f)|0){g=h;h=f}else break}g=h;j=m;l=g+44|0;do{k[g>>2]=k[j>>2];g=g+4|0;j=j+4|0}while((g|0)<(l|0));f=i+1|0;h=(f|0)==8;i=e+44|0;d=h?(i|0)==(b|0):d;if(h){e=34;break}else{g=f;f=h?i:e}}else{g=i;f=e}e=f+44|0;if((e|0)==(b|0)){d=1;e=34;break}else i=g}if((e|0)==34){r=n;return d|0}}}return 0}\r\nfunction $a(a){a=a|0;var b=0;b=r;r=r+a|0;r=r+15&-16;return b|0}function ab(){return r|0}function bb(a){a=a|0;r=a}function cb(a,b){a=a|0;b=b|0;r=a;s=b}function db(a,b){a=a|0;b=b|0;if(!w){w=a;x=b}}function eb(a){a=a|0;i[t>>0]=i[a>>0];i[t+1>>0]=i[a+1>>0];i[t+2>>0]=i[a+2>>0];i[t+3>>0]=i[a+3>>0]}function fb(a){a=a|0;i[t>>0]=i[a>>0];i[t+1>>0]=i[a+1>>0];i[t+2>>0]=i[a+2>>0];i[t+3>>0]=i[a+3>>0];i[t+4>>0]=i[a+4>>0];i[t+5>>0]=i[a+5>>0];i[t+6>>0]=i[a+6>>0];i[t+7>>0]=i[a+7>>0]}function gb(a){a=a|0;L=a}function hb(){return L|0}function ib(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0;i=d+4|0;e=_d((((k[i>>2]|0)-(k[d>>2]|0)|0)/12|0)<<2)|0;k[a>>2]=e;e=((k[i>>2]|0)-(k[d>>2]|0)|0)/12|0;k[b>>2]=e;e=_d(e<<2)|0;k[c>>2]=e;b=k[d>>2]|0;if((k[i>>2]|0)==(b|0))return;f=0;while(1){j=b+(f*12|0)+4|0;h=b+(f*12|0)|0;g=(k[j>>2]|0)-(k[h>>2]|0)|0;k[e+(f<<2)>>2]=g>>3;g=_d(g<<1|4)|0;k[(k[a>>2]|0)+(f<<2)>>2]=g;g=(g&4|0)==0?g:g+4|0;b=k[j>>2]|0;h=k[h>>2]|0;if((b|0)!=(h|0)){b=b-h>>3;e=0;do{j=e<<1;p[g+(j<<3)>>3]=+(k[h+(e<<3)>>2]|0);p[g+((j|1)<<3)>>3]=+(k[h+(e<<3)+4>>2]|0);e=e+1|0}while(e>>>0<b>>>0)}f=f+1|0;b=k[d>>2]|0;if(f>>>0>=(((k[i>>2]|0)-b|0)/12|0)>>>0)break;e=k[c>>2]|0}return}function jb(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,g=0,h=0,l=0,m=0,n=0,o=0,q=0,s=0;q=r;r=r+16|0;n=q+8|0;e=q;l=d+4|0;h=((k[l>>2]|0)-(k[d>>2]|0)|0)/12|0;k[e>>2]=h;k[e+4>>2]=h<<2;Nd(880,e);e=_d((((k[l>>2]|0)-(k[d>>2]|0)|0)/12|0)<<2)|0;k[a>>2]=e;e=((k[l>>2]|0)-(k[d>>2]|0)|0)/12|0;k[b>>2]=e;k[n>>2]=e;k[n+4>>2]=e<<2;Nd(892,n);e=_d((((k[l>>2]|0)-(k[d>>2]|0)|0)/12|0)<<2)|0;k[c>>2]=e;b=k[d>>2]|0;a:do if((k[l>>2]|0)!=(b|0)){f=0;while(1){s=b+(f*12|0)+4|0;h=b+(f*12|0)|0;g=((k[s>>2]|0)-(k[h>>2]|0)|0)/12|0;k[e+(f<<2)>>2]=g;g=_d(g*24|4)|0;k[(k[a>>2]|0)+(f<<2)>>2]=g;g=(g&4|0)==0?g:g+4|0;b=k[s>>2]|0;h=k[h>>2]|0;if((b|0)!=(h|0)){b=(b-h|0)/12|0;e=0;do{s=e*3|0;p[g+(s<<3)>>3]=+(k[h+(e*12|0)>>2]|0);p[g+(s+1<<3)>>3]=+(k[h+(e*12|0)+4>>2]|0);p[g+(s+2<<3)>>3]=+(k[h+(e*12|0)+8>>2]|0);e=e+1|0}while(e>>>0<b>>>0)}f=f+1|0;b=k[d>>2]|0;if(f>>>0>=(((k[l>>2]|0)-b|0)/12|0)>>>0)break a;e=k[c>>2]|0}}while(0);g=(k[87]|0)>-1;b:do if(!0){b=904;o=11}else{b=904;e=904;while(1){if(!(i[b>>0]|0)){b=e;break b}b=b+1|0;e=b;if(!(e&3)){o=11;break}}}while(0);if((o|0)==11){while(1){e=k[b>>2]|0;if(!((e&-2139062144^-2139062144)&e+-16843009))b=b+4|0;else break}if((e&255)<<24>>24)do b=b+1|0;while((i[b>>0]|0)!=0)}f=b-904|0;b=k[72]|0;e=(b|0)==0;c:do if(g){do if(e){b=i[346]|0;i[346]=b+255|b;b=k[68]|0;if(!(b&8)){k[70]=0;k[69]=0;e=k[79]|0;k[75]=e;k[73]=e;b=e+(k[80]|0)|0;k[72]=b;break}else{k[68]=b|32;m=0;o=33;break c}}else e=k[73]|0;while(0);if((b-e|0)>>>0<f>>>0){m=Ta[k[308>>2]&7](272,904,f)|0;o=33;break}else{fe(e|0,904,f|0)|0;k[73]=(k[73]|0)+f;break}}else{do if(e){b=i[346]|0;i[346]=b+255|b;b=k[68]|0;if(!(b&8)){k[70]=0;k[69]=0;e=k[79]|0;k[75]=e;k[73]=e;b=e+(k[80]|0)|0;k[72]=b;break}else{k[68]=b|32;m=0;o=33;break c}}else e=k[73]|0;while(0);if((b-e|0)>>>0<f>>>0){m=Ta[k[308>>2]&7](272,904,f)|0;o=33;break}else{fe(e|0,904,f|0)|0;k[73]=(k[73]|0)+f;break}}while(0);if(((o|0)==33?(m|0)!=(f|0):0)?(((m>>>0)/(f>>>0)|0)+-1|0)<0:0){r=q;return}f=i[347]|0;if(f<<24>>24!=10){b=k[73]|0;e=k[72]|0;if(b>>>0<e>>>0){k[73]=b+1;i[b>>0]=10;r=q;return}}else e=k[72]|0;i[n>>0]=10;do if(!e){f=j[173]|0;b=(f&65535)<<24>>24;i[346]=b+255|b;b=k[68]|0;if(!(b&8)){k[70]=0;k[69]=0;g=k[79]|0;k[75]=g;k[73]=g;e=g+(k[80]|0)|0;k[72]=e;b=(f&65535)>>>8&255;o=44;break}else{k[68]=b|32;break}}else{g=k[73]|0;b=f;o=44}while(0);do if((o|0)==44)if(g>>>0>=e>>>0|b<<24>>24==10){Ta[k[308>>2]&7](272,n,1)|0;break}else{k[73]=g+1;i[g>>0]=10;break}while(0);r=q;return}function kb(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,g=0,h=0.0,i=0,j=0,l=0,m=0,n=0.0,o=0,q=0.0,r=0,s=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0;k[a>>2]=0;C=a+4|0;k[C>>2]=0;k[a+8>>2]=0;if((c|0)<=0)return;D=a+8|0;i=0;g=0;e=0;a:while(1){if(i>>>0>=g>>>0){l=k[a>>2]|0;f=l;m=(i-f|0)/12|0;o=m+1|0;if(o>>>0>357913941){E=6;break}f=(g-f|0)/12|0;if(f>>>0<178956970){f=f<<1;f=f>>>0<o>>>0?o:f;if(!f){f=0;g=0;j=l}else E=9}else{f=357913941;E=9}if((E|0)==9){E=0;j=f*12|0;j=(j|0)==0?1:j;g=_d(j)|0;if(!g){do{g=k[35]|0;k[35]=g+0;if(!g){E=12;break a}Xa[g&0]();g=_d(j)|0}while((g|0)==0);j=k[a>>2]|0;i=k[C>>2]|0}else j=l}l=g+(m*12|0)|0;m=l;r=g+(f*12|0)|0;s=g+(o*12|0)|0;o=s;k[l>>2]=0;k[l+4>>2]=0;k[l+8>>2]=0;if((i|0)==(j|0)){f=i;g=m;i=f}else{f=l;g=m;do{B=f+-12|0;A=i;i=i+-12|0;k[B>>2]=0;z=f+-8|0;k[z>>2]=0;k[f+-4>>2]=0;k[B>>2]=k[i>>2];B=A+-8|0;k[z>>2]=k[B>>2];A=A+-4|0;k[f+-4>>2]=k[A>>2];k[A>>2]=0;k[B>>2]=0;k[i>>2]=0;f=g+-12|0;g=f}while((i|0)!=(j|0));i=k[a>>2]|0;f=k[C>>2]|0}k[a>>2]=g;k[C>>2]=o;k[D>>2]=r;o=i;if((f|0)!=(o|0))do{g=f;f=f+-12|0;l=k[f>>2]|0;m=l;if(l){g=g+-8|0;j=k[g>>2]|0;if((j|0)!=(l|0))k[g>>2]=j+(~((j+-8-m|0)>>>3)<<3);$d(l)}}while((f|0)!=(o|0));if(!i)f=s;else{$d(i);f=s}}else{k[i>>2]=0;k[i+4>>2]=0;k[i+8>>2]=0;f=i+12|0;k[C>>2]=f}y=f+-12|0;z=k[b+(e<<2)>>2]|0;A=k[d+(e<<2)>>2]|0;if((A|0)>0){B=f+-8|0;w=f+-4|0;x=0;do{i=x<<1;h=+p[z+(i<<3)>>3];p[t>>3]=h;f=k[t+4>>2]|0;g=de(k[t>>2]|0,f|0,52)|0;g=g&2047;do if(g>>>0<=1074){f=(f|0)<0;q=f?-h:h;if(g>>>0<1022){h=h*0.0;break}n=q+4503599627370496.0+-4503599627370496.0-q;if(!(n>.5)){h=q+n;if(n<=-.5)h=h+1.0}else h=q+n+-1.0;h=f?-h:h}while(0);v=~~h;h=+p[z+((i|1)<<3)>>3];p[t>>3]=h;f=k[t+4>>2]|0;g=de(k[t>>2]|0,f|0,52)|0;g=g&2047;do if(g>>>0<=1074){f=(f|0)<0;q=f?-h:h;if(g>>>0<1022){h=h*0.0;break}n=q+4503599627370496.0+-4503599627370496.0-q;if(!(n>.5)){h=q+n;if(n<=-.5)h=h+1.0}else h=q+n+-1.0;h=f?-h:h}while(0);l=~~h;g=k[B>>2]|0;f=k[w>>2]|0;if(g>>>0>=f>>>0){u=k[y>>2]|0;r=u;s=g-r>>3;o=s+1|0;if(o>>>0>536870911){E=48;break a}f=f-r|0;if(f>>3>>>0<268435455){f=f>>2;f=f>>>0<o>>>0?o:f;if(!f){j=0;i=0}else E=51}else{f=536870911;E=51}if((E|0)==51){E=0;j=f<<3;j=(j|0)==0?1:j;i=_d(j)|0;if(!i)do{i=k[35]|0;k[35]=i+0;if(!i){E=54;break a}Xa[i&0]();i=_d(j)|0}while((i|0)==0);j=f}f=i+(s<<3)|0;m=i+(j<<3)|0;k[f>>2]=v;k[i+(s<<3)+4>>2]=l;l=i+(o<<3)|0;if((g|0)!=(u|0)){j=g+-8|0;while(1){v=g;g=g+-8|0;k[f+-8>>2]=k[g>>2];k[f+-4>>2]=k[v+-4>>2];if((g|0)==(u|0))break;else f=f+-8|0}f=i+(s+~((j-r|0)>>>3)<<3)|0}k[y>>2]=f;k[B>>2]=l;k[w>>2]=m;if(u)$d(u)}else{k[g>>2]=v;k[g+4>>2]=l;k[B>>2]=g+8}x=x+1|0}while((x|0)<(A|0))}e=e+1|0;if((e|0)>=(c|0)){E=65;break}i=k[C>>2]|0;g=k[D>>2]|0}if((E|0)==6)xa(1340,1363,303,1438);else if((E|0)==12){E=ya(4)|0;k[E>>2]=128;La(E|0,8,1)}else if((E|0)==48)xa(1340,1363,303,1438);else if((E|0)==54){E=ya(4)|0;k[E>>2]=128;La(E|0,8,1)}else if((E|0)==65)return}function lb(a,b,c,d,e,f,g,h,m,n){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;m=m|0;n=n|0;var o=0,q=0,s=0,t=0,u=0.0,v=0.0,w=0,x=0.0,y=0,z=0.0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0,U=0,V=0,W=0,X=0,Y=0;Y=r;r=r+112|0;P=Y+96|0;N=Y+72|0;O=Y+56|0;W=Y+44|0;V=Y+32|0;T=Y+20|0;R=Y+8|0;Q=Y;kb(W,a,b,c);kb(V,d,e,f);k[g>>2]=0;b=k[W>>2]|0;X=W+4|0;e=k[X>>2]|0;if((b|0)!=(e|0)?(o=k[V>>2]|0,q=k[V+4>>2]|0,(o|0)!=(q|0)):0){k[T>>2]=0;S=T+4|0;k[S>>2]=0;k[T+8>>2]=0;if(b>>>0<e>>>0){do{mb(T,k[b>>2]|0,k[b+4>>2]|0,0);b=b+12|0}while(b>>>0<e>>>0);e=k[T>>2]|0;a=k[S>>2]|0;c=a;if((e|0)==(a|0)){f=e;b=e;e=c}else{b=e;do{i[b+4>>0]=1;b=b+32|0}while((b|0)!=(a|0));f=e;b=a;e=c}}else{f=0;b=0;e=0}if(o>>>0<q>>>0){do{mb(T,k[o>>2]|0,k[o+4>>2]|0,1);o=o+12|0}while(o>>>0<q>>>0);c=k[S>>2]|0;b=c;o=k[T>>2]|0}else{o=f;c=e}if((b|0)!=(o|0)){a=o;b=b-a>>5;e=0;do{k[o+(e<<5)+4+4>>2]=e;e=e+1|0}while(e>>>0<b>>>0);o=a}k[P>>2]=0;J=P+4|0;k[J>>2]=0;k[P+8>>2]=0;I=o;C=c-o>>5;A=P+8|0;B=(C|0)!=0;a:do if(B){b=C*24|0;o=_d(b)|0;b:do if(!o){while(1){o=k[35]|0;k[35]=o+0;if(!o)break;Xa[o&0]();o=_d(b)|0;if(o)break b}Y=ya(4)|0;k[Y>>2]=128;La(Y|0,8,1)}while(0);s=o;q=o+(C*24|0)|0;k[P>>2]=s;k[J>>2]=s;k[A>>2]=q;s=N+4|0;t=N+8|0;w=N+12|0;y=N+16|0;b=0;while(1){e=k[I+(b<<5)+12>>2]|0;a=k[I+(b<<5)+16>>2]|0;c=k[I+(b<<5)+20>>2]|0;f=k[I+(b<<5)+24>>2]|0;d=k[I+(b<<5)+28>>2]|0;k[N>>2]=e;k[s>>2]=a;k[t>>2]=c;k[w>>2]=f;H=y;k[H>>2]=b;k[H+4>>2]=d;if(o>>>0<q>>>0){k[o>>2]=e;k[o+4>>2]=a;k[o+8>>2]=c;k[o+12>>2]=f;k[o+16>>2]=b;k[o+20>>2]=d;k[J>>2]=o+24}else Db(P,N);b=b+1|0;if(b>>>0>=C>>>0){o=0;break a}o=k[J>>2]|0;q=k[A>>2]|0}}else o=1;while(0);k[O>>2]=0;H=O+4|0;k[H>>2]=0;k[O+8>>2]=0;e=O+8|0;if(B){if(o)o=0;else{b=C*24|0;o=_d(b)|0;c:do if(!o){while(1){o=k[35]|0;k[35]=o+0;if(!o)break;Xa[o&0]();o=_d(b)|0;if(o)break c}Y=ya(4)|0;k[Y>>2]=128;La(Y|0,8,1)}while(0)}G=o;k[O>>2]=G;k[H>>2]=G;k[e>>2]=o+(C*24|0)}Eb(O,k[P>>2]|0,k[J>>2]|0);G=k[H>>2]|0;a=k[O>>2]|0;e=(G-a|0)/24|0;c=(G|0)==(a|0);d:do if(!c){b=e<<5;b=(b|0)==0?1:b;o=_d(b)|0;do if(!o){while(1){o=k[35]|0;k[35]=o+0;if(!o){U=39;break}Xa[o&0]();o=_d(b)|0;if(o){U=40;break}}if((U|0)==39){Y=ya(4)|0;k[Y>>2]=128;La(Y|0,8,1)}else if((U|0)==40){f=o;b=o+(e<<5)|0;e=b;if(c){M=f;K=f;L=e;break d}else{F=a;E=f;a=f;break}}}else{D=o;e=o+(e<<5)|0;F=a;b=e;E=D;a=D}while(0);e:while(1){t=k[F+16>>2]|0;q=k[I+(t<<5)>>2]|0;t=I+(t<<5)+4|0;s=k[t>>2]|0;t=k[t+4>>2]|0;w=k[F>>2]|0;y=k[F+4>>2]|0;A=k[F+8>>2]|0;B=k[F+12>>2]|0;C=k[F+20>>2]|0;if((o|0)==(b|0)){c=a;D=E;f=a-E>>5;d=f+1|0;if(d>>>0>134217727){U=44;break}o=e-E|0;if(o>>5>>>0<67108863){o=o>>4;o=o>>>0<d>>>0?d:o;if(!o){e=0;a=0}else U=47}else{o=134217727;U=47}if((U|0)==47){U=0;e=o<<5;e=(e|0)==0?1:e;b=_d(e)|0;if(!b)do{b=k[35]|0;k[35]=b+0;if(!b){U=50;break e}Xa[b&0]();b=_d(e)|0}while((b|0)==0);e=o;a=b}b=a+(f<<5)|0;o=b;e=a+(e<<5)|0;k[b>>2]=q;q=a+(f<<5)+4|0;k[q>>2]=s;k[q+4>>2]=t;k[a+(f<<5)+12>>2]=w;k[a+(f<<5)+16>>2]=y;k[a+(f<<5)+20>>2]=A;k[a+(f<<5)+24>>2]=B;k[a+(f<<5)+28>>2]=C;a=a+(d<<5)|0;if((c|0)!=(D|0))do{C=c;c=c+-32|0;k[b+-32>>2]=k[c>>2];y=C+-28|0;A=k[y+4>>2]|0;B=b+-28|0;k[B>>2]=k[y>>2];k[B+4>>2]=A;k[b+-20>>2]=k[C+-20>>2];k[b+-16>>2]=k[C+-16>>2];k[b+-12>>2]=k[C+-12>>2];k[b+-8>>2]=k[C+-8>>2];k[b+-4>>2]=k[C+-4>>2];b=o+-32|0;o=b}while((c|0)!=(D|0));if(!E)c=o;else{$d(E);c=o}}else{k[o>>2]=q;c=o+4|0;k[c>>2]=s;k[c+4>>2]=t;k[o+12>>2]=w;k[o+16>>2]=y;k[o+20>>2]=A;k[o+24>>2]=B;k[o+28>>2]=C;c=E;a=a+32|0}o=F+24|0;if((o|0)==(G|0)){M=c;K=a;L=e;break d}F=o;o=a;b=e;E=c}if((U|0)==44)xa(1340,1363,303,1438);else if((U|0)==50){Y=ya(4)|0;k[Y>>2]=128;La(Y|0,8,1)}}else{M=0;K=0;L=0}while(0);o=k[T>>2]|0;b=o;if(!o)o=T+8|0;else{e=k[S>>2]|0;if((e|0)!=(o|0))k[S>>2]=e+(~((e+-32-b|0)>>>5)<<5);$d(o);o=T+8|0;k[o>>2]=0;k[S>>2]=0;k[T>>2]=0}k[T>>2]=M;k[S>>2]=K;k[o>>2]=L;b=k[O>>2]|0;e=b;a=M;if(b){o=k[H>>2]|0;if((o|0)!=(b|0))k[H>>2]=o+(~(((o+-24-e|0)>>>0)/24|0)*24|0);$d(b)}o=k[P>>2]|0;b=o;if(o){e=k[J>>2]|0;if((e|0)!=(o|0))k[J>>2]=e+(~(((e+-24-b|0)>>>0)/24|0)*24|0);$d(o)}J=k[S>>2]|0;k[P>>2]=1;ob(a,J,P);do if((a|0)!=(J|0)){K=N+4|0;I=k[a+12>>2]|0;f=0;E=0;d=0;w=0;s=0;o=a;b=0;c=0;e=0;f:while(1){if(d){F=0;t=E;H=J;G=b}else{t=o;q=b;while(1){if((k[t+12>>2]|0)!=(I|0)){o=1;a=t;b=q;break};k[K>>2]=0;k[K+4>>2]=0;i[K+8>>0]=0;i[O>>0]=0;o=e;do if((o|0)==(c|0)){d=e-q|0;a=d>>5;f=a+1|0;if(f>>>0>134217727){U=78;break f}if(a>>>0<67108863){e=d>>4;e=e>>>0<f>>>0?f:e}else e=134217727;b=e<<5;b=(b|0)==0?1:b;o=_d(b)|0;if(!o)do{o=k[35]|0;k[35]=o+0;if(!o){U=84;break f}Xa[o&0]();o=_d(b)|0}while((o|0)==0);c=o+(e<<5)|0;k[o+(a<<5)>>2]=0;k[o+(a<<5)+4>>2]=0;k[o+(a<<5)+8>>2]=t;b=o+(a<<5)+12|0;k[b>>2]=k[N>>2];k[b+4>>2]=k[N+4>>2];k[b+8>>2]=k[N+8>>2];i[b+12>>0]=i[N+12>>0]|0;i[o+(a<<5)+25>>0]=1;a=o+(a<<5)+26|0;j[a>>1]=j[O>>1]|0;j[a+2>>1]=j[O+2>>1]|0;j[a+4>>1]=j[O+4>>1]|0;a=o+(f<<5)|0;b=o;e=q;fe(o|0,e|0,d|0)|0;if(!q){e=a;break}$d(e);e=a}else{k[o>>2]=0;k[o+4>>2]=0;k[o+8>>2]=t;b=o+12|0;k[b>>2]=k[N>>2];k[b+4>>2]=k[N+4>>2];k[b+8>>2]=k[N+8>>2];i[b+12>>0]=i[N+12>>0]|0;i[o+25>>0]=1;b=o+26|0;j[b>>1]=j[O>>1]|0;j[b+2>>1]=j[O+2>>1]|0;j[b+4>>1]=j[O+4>>1]|0;b=q;e=o+32|0}while(0);t=t+32|0;if((t|0)==(J|0)){o=0;a=J;break}else q=b}F=o;t=b;f=e;H=a;G=b}if((t|0)!=(f|0)){z=+(I|0);d=t;do{o=k[d+8>>2]|0;b=k[o+16>>2]|0;q=k[o+20>>2]|0;a=k[o+24>>2]|0;do if((b|0)==(a|0)){u=+(b|0);o=k[o+12>>2]|0}else{o=k[o+12>>2]|0;x=+(o|0);u=+(b|0);v=z-x;if(v==0.0)break;u=u+(+(a|0)-u)*v/(+(q|0)-x)}while(0);p[d+16>>3]=u;i[d+24>>0]=((I|0)==(q|0)|(I|0)==(o|0))&1;d=d+32|0}while((d|0)!=(f|0))}k[P>>2]=2;qb(t,f,P);E=G;D=e;if((E|0)==(D|0)){o=E;q=w}else{C=E;o=G;t=w;while(1){a=C+32|0;b=a;g:do if(!((a|0)==(D|0)|(i[C+24>>0]|0)==0)){d=C+16|0;f=C;while(1){if(!(i[f+56>>0]|0))break g;if(!(+p[f+48>>3]==+p[d>>3]))break g;f=a+32|0;b=f;if((f|0)==(D|0))break;else{M=a;a=f;f=M}}}while(0);a=o;B=a>>>0<b>>>0;if(B){f=a;do{q=k[f+8>>2]|0;d=k[q+12>>2]|0;q=k[q+20>>2]|0;if((d|0)!=(q|0)){i[f+25>>0]=(I|0)==(d|0)&1;i[f+26>>0]=(I|0)==(q|0)&1}f=f+32|0}while(f>>>0<b>>>0)}if((C|0)==(b|0))q=t;else{A=b+25|0;d=o;q=t;while(1){f=d;h:do if((f|0)==(b|0)){f=d;d=q;U=111}else{w=q;while(1){t=k[f+8>>2]|0;q=i[f+25>>0]|0;if((k[t+12>>2]|0)==(k[t+20>>2]|0)){f=d;y=s;d=w;break h}q=q<<24>>24==0;if(!q)k[f>>2]=s;do if(!(i[t+4>>0]|0)){if(q)d=(k[t+28>>2]|0)+w|0;else d=w;if(i[f+26>>0]|0){t=d;break}s=(k[t+28>>2]|0)+s|0;t=d}else t=w;while(0);if(!q)k[f+4>>2]=s;f=f+32|0;d=f;if((f|0)==(b|0)){f=d;d=t;U=111;break}else w=t}}while(0);if((U|0)==111){U=0;q=i[A>>0]|0;y=s}w=f;i:do if((w|0)==(b|0))q=d;else{t=w;while(1){s=k[t+8>>2]|0;if((k[s+12>>2]|0)!=(k[s+20>>2]|0)){t=w;break}if((i[t+25>>0]|0)!=q<<24>>24){t=w;break}k[t>>2]=d;if(!(i[s+4>>0]|0))d=(k[s+28>>2]|0)+d|0;k[t+4>>2]=d;t=t+32|0;if((t|0)==(b|0)){t=w;break}}do{s=k[t+8>>2]|0;if((k[s+12>>2]|0)!=(k[s+20>>2]|0))break;if((i[t+25>>0]|0)!=q<<24>>24)break;if(!(i[s+4>>0]|0))d=d-(k[s+28>>2]|0)|0;t=t+32|0}while((t|0)!=(b|0));s=w;while(1){M=k[s+8>>2]|0;if((k[M+12>>2]|0)!=(k[M+20>>2]|0)){q=d;break i}if((i[s+25>>0]|0)!=q<<24>>24){q=d;break i}s=s+32|0;f=s;if((s|0)==(b|0)){q=d;break}}}while(0);if((f|0)==(b|0)){f=C;break}else{d=f;s=y}}do{if(!(k[f>>2]|0))d=0;else d=(k[f+4>>2]|0)!=0;i[(k[f+8>>2]|0)+5>>0]=d&1;f=f+32|0}while((f|0)!=(b|0));s=y}j:do if(B)do{M=k[a+8>>2]|0;if((k[M+12>>2]|0)==(k[M+20>>2]|0)?(i[a+26>>0]|0)==0:0)break j;a=a+32|0;o=a}while(a>>>0<b>>>0);while(0);C=o;if(C>>>0<b>>>0){a=C;do{p[a+16>>3]=+(k[(k[a+8>>2]|0)+24>>2]|0);i[a+25>>0]=0;i[a+26>>0]=1;a=a+32|0}while(a>>>0<b>>>0)}if((C|0)==(D|0)){o=D;break}else t=q}}k:do if((E|0)==(o|0)){b=E;U=151}else{b=E;do{if(i[b+26>>0]|0){U=151;break k}b=b+32|0}while((b|0)!=(o|0))}while(0);l:do if((U|0)==151){U=0;a=b;if((b|0)==(o|0)){o=a;break}else{d=a;b=a}while(1){do{a=b;f=a+32|0;b=f;if((f|0)==(o|0)){o=d;break l}}while((i[a+58>>0]|0)!=0);M=d;k[M>>2]=k[f>>2];k[M+4>>2]=k[f+4>>2];k[M+8>>2]=k[f+8>>2];k[M+12>>2]=k[f+12>>2];k[M+16>>2]=k[f+16>>2];k[M+20>>2]=k[f+20>>2];j[M+24>>1]=j[f+24>>1]|0;i[M+26>>0]=i[f+26>>0]|0;d=d+32|0}}while(0);b=o;do if((b|0)==(D|0))f=D;else{L=E+((o-G>>5)+(e-o>>5)<<5)|0;M=e-L|0;he(o|0,L|0,M|0)|0;o=b+(M>>5<<5)|0;if((D|0)==(o|0)){f=D;break}e=D+(~((D+-32-o|0)>>>5)<<5)|0;f=e}while(0);a=(E|0)==(f|0);if(a)o=2147483647;else{b=E;o=2147483647;do{M=k[(k[b+8>>2]|0)+20>>2]|0;o=(M|0)<(o|0)?M:o;b=b+32|0}while((b|0)!=(f|0))}if(F){M=k[H+12>>2]|0;o=(M|0)<(o|0)?M:o}d=(H|0)==(J|0);if(a&d){U=164;break}else{I=o;w=q;o=H;b=G}}if((U|0)==78)xa(1340,1363,303,1438);else if((U|0)==84){Y=ya(4)|0;k[Y>>2]=128;La(Y|0,8,1)}else if((U|0)==164){if(!G)break;$d(G);break}}while(0);o=k[T>>2]|0;f=k[S>>2]|0;rb(o,f);if((o|0)!=(f|0))do{P=k[o+28>>2]|0;b=o+12|0;e=k[b>>2]|0;a=o+20|0;c=k[a>>2]|0;if((((e|0)==(c|0)?0-P|0:P)|0)<0){N=o+16|0;O=k[N>>2]|0;k[b>>2]=c;P=o+24|0;k[N>>2]=k[P>>2];k[a>>2]=e;k[P>>2]=O}o=o+32|0}while((o|0)!=(f|0));k[R>>2]=0;K=R+4|0;k[K>>2]=0;k[R+8>>2]=0;o=_d(12)|0;m:do if(!o){while(1){o=k[35]|0;k[35]=o+0;if(!o)break;Xa[o&0]();o=_d(12)|0;if(o)break m}Y=ya(4)|0;k[Y>>2]=128;La(Y|0,8,1)}while(0);k[K>>2]=o;k[R>>2]=o;J=R+8|0;k[J>>2]=o+12;k[o>>2]=0;k[o+4>>2]=0;k[o+8>>2]=0;c=o+12|0;k[K>>2]=c;e=k[k[W>>2]>>2]|0;a=k[e>>2]|0;e=k[e+4>>2]|0;o=k[T>>2]|0;b=k[S>>2]|0;k[Q>>2]=a;I=Q+4|0;k[I>>2]=e;n:do if((o|0)!=(b|0)){f=o;H=o;s=c;t=0;o:while(1){o=f+4|0;if(!(i[o>>0]|0)){U=222;break n}G=H;p:do if((G|0)==(b|0))F=H;else{d=o+4|0;q=G;o=H;while(1){f=q+4|0;if(!(i[f>>0]|0)){F=o;b=q;break p}if((k[f+4>>2]|0)!=(k[d>>2]|0)){F=o;b=q;break p}q=q+32|0;o=q;if((q|0)==(b|0)){F=o;break}}}while(0);if((G|0)==(b|0)){U=218;break}else o=G;q:while(1){f=o+4|0;E=f+2|0;do if(!(i[E>>0]|0)){if((k[o+12>>2]|0)!=(a|0))break;if((k[o+16>>2]|0)==(e|0))break q}while(0);o=o+32|0;if((o|0)==(b|0)){U=218;break o}}D=f+1|0;if((l[D>>0]|0)==(t&1|0))q=t;else{c=s+-12|0;f=s+-8|0;d=k[f>>2]|0;do if((k[c>>2]|0)!=(d|0))if(d>>>0<(k[s+-4>>2]|0)>>>0){k[d>>2]=a;k[d+4>>2]=e;k[f>>2]=d+8;q=s;break}else{sb(c,Q);q=k[K>>2]|0;break}else q=s;while(0);c=k[J>>2]|0;do if(q>>>0<c>>>0){k[q>>2]=0;k[q+4>>2]=0;k[q+8>>2]=0;c=q+12|0;k[K>>2]=c}else{C=k[R>>2]|0;f=q;y=C;A=(f-y|0)/12|0;B=A+1|0;if(B>>>0>357913941){U=194;break o}c=(c-y|0)/12|0;if(c>>>0<178956970){c=c<<1;c=c>>>0<B>>>0?B:c;if(!c){c=0;s=0}else U=197}else{c=357913941;U=197}if((U|0)==197){U=0;s=c*12|0;s=(s|0)==0?1:s;d=_d(s)|0;if(!d)do{d=k[35]|0;k[35]=d+0;if(!d){U=200;break o}Xa[d&0]();d=_d(s)|0}while((d|0)==0);s=d}d=s+(A*12|0)|0;t=d;w=s+(c*12|0)|0;k[d>>2]=0;k[s+(A*12|0)+4>>2]=0;k[s+(A*12|0)+8>>2]=0;c=s+(B*12|0)|0;s=c;if((q|0)==(C|0))d=t;else{f=t;do{P=d+-12|0;O=q;q=q+-12|0;k[P>>2]=0;N=d+-8|0;k[N>>2]=0;k[d+-4>>2]=0;k[P>>2]=k[q>>2];P=O+-8|0;k[N>>2]=k[P>>2];O=O+-4|0;k[d+-4>>2]=k[O>>2];k[O>>2]=0;k[P>>2]=0;k[q>>2]=0;d=f+-12|0;f=d}while((q|0)!=(C|0));d=f;y=k[R>>2]|0;f=k[K>>2]|0}k[R>>2]=d;k[K>>2]=s;k[J>>2]=w;w=y;if((f|0)!=(w|0))do{d=f;f=f+-12|0;s=k[f>>2]|0;t=s;if(s){d=d+-8|0;q=k[d>>2]|0;if((q|0)!=(s|0))k[d>>2]=q+(~((q+-8-t|0)>>>3)<<3);$d(s)}}while((f|0)!=(w|0));if(!y)break;$d(y)}while(0);s=c;q=(i[D>>0]|0)!=0}f=s+-8|0;d=k[f>>2]|0;if(d>>>0<(k[s+-4>>2]|0)>>>0){k[d>>2]=a;k[d+4>>2]=e;k[f>>2]=d+8}else sb(s+-12|0,Q);a=k[o+20>>2]|0;k[Q>>2]=a;e=k[o+24>>2]|0;k[I>>2]=e;i[E>>0]=1;o=G;f=1;do{f=f&(i[o+4+2>>0]|0)!=0;o=o+32|0}while((o|0)!=(b|0));H=f?F:H;b=k[S>>2]|0;f=H;if((f|0)==(b|0)){U=222;break n}else t=q}if((U|0)==194)xa(1340,1363,303,1438);else if((U|0)==200){Y=ya(4)|0;k[Y>>2]=128;La(Y|0,8,1)}else if((U|0)==218){k[g>>2]=1;ib(h,m,n,W);break}}else U=222;while(0);if((U|0)==222){o=c+-8|0;b=k[o>>2]|0;if(b>>>0<(k[c+-4>>2]|0)>>>0){k[b>>2]=a;k[b+4>>2]=e;k[o>>2]=b+8}else sb(c+-12|0,Q);ib(h,m,n,R)}f=k[R>>2]|0;if(f){o=k[K>>2]|0;if((o|0)!=(f|0)){do{b=o;o=o+-12|0;a=k[o>>2]|0;c=a;if(a){b=b+-8|0;e=k[b>>2]|0;if((e|0)!=(a|0))k[b>>2]=e+(~((e+-8-c|0)>>>3)<<3);$d(a)}}while((o|0)!=(f|0));k[K>>2]=f}$d(f)}o=k[T>>2]|0;b=o;if(!o)o=V;else{e=k[S>>2]|0;if((e|0)!=(o|0))k[S>>2]=e+(~((e+-32-b|0)>>>5)<<5);$d(o);o=V}}else{o=V;U=3}if((U|0)==3)ib(h,m,n,W);d=k[o>>2]|0;if(d){f=V+4|0;o=k[f>>2]|0;if((o|0)!=(d|0)){do{b=o;o=o+-12|0;a=k[o>>2]|0;c=a;if(a){b=b+-8|0;e=k[b>>2]|0;if((e|0)!=(a|0))k[b>>2]=e+(~((e+-8-c|0)>>>3)<<3);$d(a)}}while((o|0)!=(d|0));k[f>>2]=d}$d(d)}f=k[W>>2]|0;if(!f){r=Y;return}o=k[X>>2]|0;if((o|0)!=(f|0)){do{b=o;o=o+-12|0;a=k[o>>2]|0;c=a;if(a){b=b+-8|0;e=k[b>>2]|0;if((e|0)!=(a|0))k[b>>2]=e+(~((e+-8-c|0)>>>3)<<3);$d(a)}}while((o|0)!=(f|0));k[X>>2]=f}$d(f);r=Y;return}function mb(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,g=0,h=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0;B=r;r=r+32|0;A=B;v=c-b>>3;if(!v){r=B;return}w=A+4|0;x=w+1|0;y=w+2|0;z=w+4|0;n=A+12|0;o=A+16|0;p=A+20|0;q=A+24|0;s=A+28|0;t=a+4|0;u=a+8|0;if(d){l=0;do{d=l;l=l+1|0;g=l>>>0<v>>>0?b+(l<<3)|0:b;f=k[b+(d<<3)>>2]|0;d=k[b+(d<<3)+4>>2]|0;c=k[g>>2]|0;g=k[g+4>>2]|0;do if((f|0)!=(c|0)|(d|0)!=(g|0)){k[A>>2]=0;i[w>>0]=0;i[x>>0]=0;i[y>>0]=0;k[z>>2]=0;k[n>>2]=f;k[o>>2]=d;k[p>>2]=c;k[q>>2]=g;k[s>>2]=1;if((f|0)<=(c|0))if((f|0)==(c|0))if((d|0)>(g|0))m=8;else{e=1;c=f;m=10}else{h=f;f=g;e=1;m=9}else m=8;if((m|0)==8){k[n>>2]=c;k[o>>2]=g;k[p>>2]=f;k[q>>2]=d;k[s>>2]=-1;h=c;c=f;f=d;d=g;e=-1;m=9}if((m|0)==9){m=0;if((h|0)==(c|0)){g=f;m=10}else j=d}if((m|0)==10){e=0-e|0;k[s>>2]=e;h=c;j=d;f=g}d=k[t>>2]|0;if(d>>>0<(k[u>>2]|0)>>>0){k[d>>2]=0;C=w;g=k[C+4>>2]|0;m=d+4|0;k[m>>2]=k[C>>2];k[m+4>>2]=g;k[d+12>>2]=h;k[d+16>>2]=j;k[d+20>>2]=c;k[d+24>>2]=f;k[d+28>>2]=e;k[t>>2]=(k[t>>2]|0)+32;break}else{kc(a,A);break}}while(0)}while((l|0)!=(v|0));r=B;return}if(v>>>0>1){j=1;c=0}else{r=B;return}while(1){h=k[b+(c<<3)>>2]|0;d=k[b+(c<<3)+4>>2]|0;g=k[b+(j<<3)>>2]|0;c=k[b+(j<<3)+4>>2]|0;do if((h|0)!=(g|0)|(d|0)!=(c|0)){k[A>>2]=0;i[w>>0]=0;i[x>>0]=0;i[y>>0]=0;k[z>>2]=0;k[n>>2]=h;k[o>>2]=d;k[p>>2]=g;k[q>>2]=c;k[s>>2]=1;if((h|0)<=(g|0))if((h|0)==(g|0))if((d|0)>(c|0))m=19;else{f=c;g=h;c=1;m=21}else{f=c;c=1;e=h;m=20}else m=19;if((m|0)==19){k[n>>2]=g;k[o>>2]=c;k[p>>2]=h;k[q>>2]=d;k[s>>2]=-1;f=d;d=c;c=-1;e=g;g=h;m=20}if((m|0)==20){m=0;if((e|0)==(g|0))m=21;else h=d}if((m|0)==21){c=0-c|0;k[s>>2]=c;e=g;h=d}d=k[t>>2]|0;if(d>>>0<(k[u>>2]|0)>>>0){k[d>>2]=0;l=w;m=k[l+4>>2]|0;C=d+4|0;k[C>>2]=k[l>>2];k[C+4>>2]=m;k[d+12>>2]=e;k[d+16>>2]=h;k[d+20>>2]=g;k[d+24>>2]=f;k[d+28>>2]=c;k[t>>2]=(k[t>>2]|0)+32;break}else{kc(a,A);break}}while(0);c=j+1|0;if(c>>>0<v>>>0){C=j;j=c;c=C}else break}r=B;return}function nb(a,b){a=a|0;b=b|0;return (k[a+12>>2]|0)<(k[b+12>>2]|0)|0}function ob(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0;w=r;r=r+32|0;v=w;a:while(1){l=b;m=b+-32|0;n=b+-28|0;o=b+-20|0;p=b+-16|0;q=b+-12|0;s=b+-8|0;t=b+-4|0;b:while(1){j=a;f=l-j|0;d=f>>5;switch(d|0){case 2:{u=4;break a}case 3:{u=6;break a}case 4:{u=7;break a}case 5:{u=8;break a}case 1:case 0:{u=53;break a}default:{}}if((f|0)<224){u=10;break a}e=(d|0)/2|0;i=a+(e<<5)|0;if((f|0)>31968){d=(d|0)/4|0;d=Bb(a,a+(d<<5)|0,i,a+(d+e<<5)|0,m,c)|0}else d=zb(a,i,m,c)|0;do if(Za[k[c>>2]&7](a,i)|0)f=m;else{f=b;g=m;while(1){e=g+-32|0;if((a|0)==(e|0))break;if(Za[k[c>>2]&7](e,i)|0){u=36;break}else{f=g;g=e}}if((u|0)==36){u=0;H=k[a>>2]|0;C=a+4|0;F=C;G=k[F>>2]|0;F=k[F+4>>2]|0;A=a+12|0;D=k[A>>2]|0;y=a+16|0;B=k[y>>2]|0;g=a+20|0;z=k[g>>2]|0;J=a+24|0;x=k[J>>2]|0;I=a+28|0;h=k[I>>2]|0;k[a>>2]=k[e>>2];E=f+-60|0;L=E;K=k[L+4>>2]|0;k[C>>2]=k[L>>2];k[C+4>>2]=K;C=f+-52|0;k[A>>2]=k[C>>2];A=f+-48|0;k[y>>2]=k[A>>2];y=f+-44|0;k[g>>2]=k[y>>2];g=f+-40|0;k[J>>2]=k[g>>2];f=f+-36|0;k[I>>2]=k[f>>2];k[e>>2]=H;k[E>>2]=G;k[E+4>>2]=F;k[C>>2]=D;k[A>>2]=B;k[y>>2]=z;k[g>>2]=x;k[f>>2]=h;f=e;d=d+1|0;break}d=a+32|0;if(!(Za[k[c>>2]&7](a,m)|0)){if((d|0)==(m|0)){u=53;break a}else e=a;while(1){if(Za[k[c>>2]&7](a,d)|0)break;e=d+32|0;if((e|0)==(m|0)){u=53;break a}else{L=d;d=e;e=L}}E=k[d>>2]|0;j=e+36|0;G=j;F=k[G>>2]|0;G=k[G+4>>2]|0;z=e+44|0;H=k[z>>2]|0;A=e+48|0;I=k[A>>2]|0;B=e+52|0;J=k[B>>2]|0;C=e+56|0;K=k[C>>2]|0;D=e+60|0;L=k[D>>2]|0;k[d>>2]=k[m>>2];x=n;y=k[x+4>>2]|0;d=j;k[d>>2]=k[x>>2];k[d+4>>2]=y;k[z>>2]=k[o>>2];k[A>>2]=k[p>>2];k[B>>2]=k[q>>2];k[C>>2]=k[s>>2];k[D>>2]=k[t>>2];k[m>>2]=E;d=n;k[d>>2]=F;k[d+4>>2]=G;k[o>>2]=H;k[p>>2]=I;k[q>>2]=J;k[s>>2]=K;k[t>>2]=L;d=e+64|0}if((d|0)==(m|0)){u=53;break a}else e=m;while(1){g=d;while(1){d=g+32|0;if(Za[k[c>>2]&7](a,g)|0){f=e;break}else g=d}while(1){e=f+-32|0;if(Za[k[c>>2]&7](a,e)|0)f=e;else break}if(g>>>0>=e>>>0){a=g;continue b}y=k[g>>2]|0;D=g+4|0;A=D;z=k[A>>2]|0;A=k[A+4>>2]|0;F=g+12|0;C=k[F>>2]|0;H=g+16|0;E=k[H>>2]|0;J=g+20|0;G=k[J>>2]|0;L=g+24|0;I=k[L>>2]|0;x=g+28|0;K=k[x>>2]|0;k[g>>2]=k[e>>2];B=f+-28|0;i=B;j=k[i+4>>2]|0;k[D>>2]=k[i>>2];k[D+4>>2]=j;D=f+-20|0;k[F>>2]=k[D>>2];F=f+-16|0;k[H>>2]=k[F>>2];H=f+-12|0;k[J>>2]=k[H>>2];J=f+-8|0;k[L>>2]=k[J>>2];L=f+-4|0;k[x>>2]=k[L>>2];k[e>>2]=y;k[B>>2]=z;k[B+4>>2]=A;k[D>>2]=C;k[F>>2]=E;k[H>>2]=G;k[J>>2]=I;k[L>>2]=K}}while(0);e=a+32|0;c:do if(e>>>0<f>>>0)while(1){h=e;while(1){e=h+32|0;if(Za[k[c>>2]&7](h,i)|0)h=e;else break}while(1){g=f+-32|0;if(Za[k[c>>2]&7](g,i)|0)break;else f=g}if(h>>>0>g>>>0){e=i;break c}z=k[h>>2]|0;E=h+4|0;B=E;A=k[B>>2]|0;B=k[B+4>>2]|0;G=h+12|0;D=k[G>>2]|0;I=h+16|0;F=k[I>>2]|0;K=h+20|0;H=k[K>>2]|0;x=h+24|0;J=k[x>>2]|0;y=h+28|0;L=k[y>>2]|0;k[h>>2]=k[g>>2];C=f+-28|0;N=C;M=k[N+4>>2]|0;k[E>>2]=k[N>>2];k[E+4>>2]=M;E=f+-20|0;k[G>>2]=k[E>>2];G=f+-16|0;k[I>>2]=k[G>>2];I=f+-12|0;k[K>>2]=k[I>>2];K=f+-8|0;k[x>>2]=k[K>>2];f=f+-4|0;k[y>>2]=k[f>>2];k[g>>2]=z;k[C>>2]=A;k[C+4>>2]=B;k[E>>2]=D;k[G>>2]=F;k[I>>2]=H;k[K>>2]=J;k[f>>2]=L;f=g;i=(i|0)==(h|0)?g:i;d=d+1|0}else{h=e;e=i}while(0);if((h|0)!=(e|0)?Za[k[c>>2]&7](e,h)|0:0){A=k[h>>2]|0;F=h+4|0;C=F;B=k[C>>2]|0;C=k[C+4>>2]|0;H=h+12|0;E=k[H>>2]|0;J=h+16|0;G=k[J>>2]|0;L=h+20|0;I=k[L>>2]|0;N=h+24|0;K=k[N>>2]|0;z=h+28|0;M=k[z>>2]|0;k[h>>2]=k[e>>2];D=e+4|0;x=D;y=k[x+4>>2]|0;k[F>>2]=k[x>>2];k[F+4>>2]=y;F=e+12|0;k[H>>2]=k[F>>2];H=e+16|0;k[J>>2]=k[H>>2];J=e+20|0;k[L>>2]=k[J>>2];L=e+24|0;k[N>>2]=k[L>>2];N=e+28|0;k[z>>2]=k[N>>2];k[e>>2]=A;k[D>>2]=B;k[D+4>>2]=C;k[F>>2]=E;k[H>>2]=G;k[J>>2]=I;k[L>>2]=K;k[N>>2]=M;d=d+1|0}if(!d){d=Cb(a,h,c)|0;e=h+32|0;if(Cb(e,b,c)|0){u=48;break}if(d){a=e;continue}}N=h;if((N-j|0)>=(l-N|0)){u=52;break}ob(a,h,c);a=h+32|0}if((u|0)==48){u=0;if(d){u=53;break}else{b=h;continue}}else if((u|0)==52){u=0;ob(h+32|0,b,c);b=h;continue}}if((u|0)==4){if(!(Za[k[c>>2]&7](m,a)|0)){r=w;return}I=k[a>>2]|0;A=a+4|0;H=A;G=k[H>>2]|0;H=k[H+4>>2]|0;B=a+12|0;J=k[B>>2]|0;C=a+16|0;K=k[C>>2]|0;D=a+20|0;L=k[D>>2]|0;E=a+24|0;M=k[E>>2]|0;F=a+28|0;N=k[F>>2]|0;k[a>>2]=k[m>>2];y=n;z=k[y+4>>2]|0;k[A>>2]=k[y>>2];k[A+4>>2]=z;k[B>>2]=k[o>>2];k[C>>2]=k[p>>2];k[D>>2]=k[q>>2];k[E>>2]=k[s>>2];k[F>>2]=k[t>>2];k[m>>2]=I;I=n;k[I>>2]=G;k[I+4>>2]=H;k[o>>2]=J;k[p>>2]=K;k[q>>2]=L;k[s>>2]=M;k[t>>2]=N;r=w;return}else if((u|0)==6){zb(a,a+32|0,m,c)|0;r=w;return}else if((u|0)==7){Ab(a,a+32|0,a+64|0,m,c)|0;r=w;return}else if((u|0)==8){Bb(a,a+32|0,a+64|0,a+96|0,m,c)|0;r=w;return}else if((u|0)==10){e=a+64|0;zb(a,a+32|0,e,c)|0;d=a+96|0;if((d|0)!=(b|0)){n=v+4|0;o=v+12|0;p=v+16|0;q=v+20|0;s=v+24|0;t=v+28|0;m=d;while(1){if(Za[k[c>>2]&7](m,e)|0){k[v>>2]=k[m>>2];M=m+4|0;N=k[M+4>>2]|0;d=n;k[d>>2]=k[M>>2];k[d+4>>2]=N;k[o>>2]=k[m+12>>2];k[p>>2]=k[m+16>>2];k[q>>2]=k[m+20>>2];k[s>>2]=k[m+24>>2];k[t>>2]=k[m+28>>2];d=m;while(1){k[d>>2]=k[e>>2];l=e+4|0;h=l;g=k[h+4>>2]|0;f=d+4|0;k[f>>2]=k[h>>2];k[f+4>>2]=g;f=e+12|0;k[d+12>>2]=k[f>>2];g=e+16|0;k[d+16>>2]=k[g>>2];h=e+20|0;k[d+20>>2]=k[h>>2];i=e+24|0;k[d+24>>2]=k[i>>2];j=e+28|0;k[d+28>>2]=k[j>>2];if((e|0)==(a|0))break;d=e+-32|0;if(Za[k[c>>2]&7](v,d)|0){N=e;e=d;d=N}else break}k[e>>2]=k[v>>2];L=n;M=k[L+4>>2]|0;N=l;k[N>>2]=k[L>>2];k[N+4>>2]=M;k[f>>2]=k[o>>2];k[g>>2]=k[p>>2];k[h>>2]=k[q>>2];k[i>>2]=k[s>>2];k[j>>2]=k[t>>2]}d=m+32|0;if((d|0)==(b|0))break;else{e=m;m=d}}}r=w;return}else if((u|0)==53){r=w;return}}function pb(a,b){a=a|0;b=b|0;var c=0.0,d=0.0,e=0,f=0,g=0,h=0,j=0,l=0,m=0;c=+p[a+16>>3];d=+p[b+16>>3];if(c<d){m=1;return m|0}if(d<c){m=0;return m|0}e=i[a+24>>0]|0;f=i[b+24>>0]|0;if((e&255)<(f&255)){m=1;return m|0}if((f&255)<(e&255)){m=0;return m|0}g=k[a+8>>2]|0;b=k[b+8>>2]|0;e=k[g+20>>2]|0;f=k[g+12>>2]|0;a=e-f|0;g=(k[g+24>>2]|0)-(k[g+16>>2]|0)|0;h=k[b+20>>2]|0;j=k[b+12>>2]|0;l=h-j|0;b=(k[b+24>>2]|0)-(k[b+16>>2]|0)|0;if((a|0)>=0){if((e|0)==(f|0)){m=0;return m|0}}else{a=0-a|0;g=0-g|0}if((l|0)>=0)if((h|0)==(j|0)){m=(a|0)!=0;return m|0}else e=l;else{e=0-l|0;b=0-b|0}j=(e|0)<0?0-e|0:e;h=(g|0)<0?0-g|0:g;h=ne(j|0,((j|0)<0)<<31>>31|0,h|0,((h|0)<0)<<31>>31|0)|0;j=L;l=(a|0)<0?0-a|0:a;m=(b|0)<0?0-b|0:b;l=ne(m|0,((m|0)<0)<<31>>31|0,l|0,((l|0)<0)<<31>>31|0)|0;m=L;f=ha(e>>31|1,g>>31|1)|0;e=ha(b>>31|1,a>>31|1)|0;if((f|0)<(e|0)){m=1;return m|0}if((e|0)<(f|0)){m=0;return m|0}if((f|0)==-1){m=m>>>0<j>>>0|(m|0)==(j|0)&l>>>0<h>>>0;return m|0}else{m=j>>>0<m>>>0|(j|0)==(m|0)&h>>>0<l>>>0;return m|0}return 0}function qb(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0,l=0,m=0,n=0,o=0,p=0,q=0,s=0,t=0;t=r;r=r+64|0;q=t+32|0;p=t;o=b;a:while(1){l=o;n=o+-32|0;s=a;b:while(1){h=s;a=l-h|0;b=a>>5;switch(b|0){case 2:{m=4;break a}case 3:{m=6;break a}case 4:{m=14;break a}case 5:{m=15;break a}case 1:case 0:{m=82;break a}default:{}}if((a|0)<992){m=21;break a}d=(b|0)/2|0;g=s+(d<<5)|0;do if((a|0)>31968){b=(b|0)/4|0;e=s+(b<<5)|0;b=s+(b+d<<5)|0;a=xb(s,e,g,b,c)|0;if(Za[k[c>>2]&7](n,b)|0){k[p>>2]=k[b>>2];k[p+4>>2]=k[b+4>>2];k[p+8>>2]=k[b+8>>2];k[p+12>>2]=k[b+12>>2];k[p+16>>2]=k[b+16>>2];k[p+20>>2]=k[b+20>>2];k[p+24>>2]=k[b+24>>2];k[p+28>>2]=k[b+28>>2];k[b>>2]=k[n>>2];k[b+4>>2]=k[n+4>>2];k[b+8>>2]=k[n+8>>2];k[b+12>>2]=k[n+12>>2];k[b+16>>2]=k[n+16>>2];k[b+20>>2]=k[n+20>>2];j[b+24>>1]=j[n+24>>1]|0;i[b+26>>0]=i[n+26>>0]|0;k[n>>2]=k[p>>2];k[n+4>>2]=k[p+4>>2];k[n+8>>2]=k[p+8>>2];k[n+12>>2]=k[p+12>>2];k[n+16>>2]=k[p+16>>2];k[n+20>>2]=k[p+20>>2];j[n+24>>1]=j[p+24>>1]|0;i[n+26>>0]=i[p+26>>0]|0;d=a+1|0;if(Za[k[c>>2]&7](b,g)|0){k[p>>2]=k[g>>2];k[p+4>>2]=k[g+4>>2];k[p+8>>2]=k[g+8>>2];k[p+12>>2]=k[g+12>>2];k[p+16>>2]=k[g+16>>2];k[p+20>>2]=k[g+20>>2];k[p+24>>2]=k[g+24>>2];k[p+28>>2]=k[g+28>>2];k[g>>2]=k[b>>2];k[g+4>>2]=k[b+4>>2];k[g+8>>2]=k[b+8>>2];k[g+12>>2]=k[b+12>>2];k[g+16>>2]=k[b+16>>2];k[g+20>>2]=k[b+20>>2];j[g+24>>1]=j[b+24>>1]|0;i[g+26>>0]=i[b+26>>0]|0;k[b>>2]=k[p>>2];k[b+4>>2]=k[p+4>>2];k[b+8>>2]=k[p+8>>2];k[b+12>>2]=k[p+12>>2];k[b+16>>2]=k[p+16>>2];k[b+20>>2]=k[p+20>>2];j[b+24>>1]=j[p+24>>1]|0;i[b+26>>0]=i[p+26>>0]|0;b=a+2|0;if(Za[k[c>>2]&7](g,e)|0){k[p>>2]=k[e>>2];k[p+4>>2]=k[e+4>>2];k[p+8>>2]=k[e+8>>2];k[p+12>>2]=k[e+12>>2];k[p+16>>2]=k[e+16>>2];k[p+20>>2]=k[e+20>>2];k[p+24>>2]=k[e+24>>2];k[p+28>>2]=k[e+28>>2];k[e>>2]=k[g>>2];k[e+4>>2]=k[g+4>>2];k[e+8>>2]=k[g+8>>2];k[e+12>>2]=k[g+12>>2];k[e+16>>2]=k[g+16>>2];k[e+20>>2]=k[g+20>>2];j[e+24>>1]=j[g+24>>1]|0;i[e+26>>0]=i[g+26>>0]|0;k[g>>2]=k[p>>2];k[g+4>>2]=k[p+4>>2];k[g+8>>2]=k[p+8>>2];k[g+12>>2]=k[p+12>>2];k[g+16>>2]=k[p+16>>2];k[g+20>>2]=k[p+20>>2];j[g+24>>1]=j[p+24>>1]|0;i[g+26>>0]=i[p+26>>0]|0;if(Za[k[c>>2]&7](e,s)|0){k[p>>2]=k[s>>2];k[p+4>>2]=k[s+4>>2];k[p+8>>2]=k[s+8>>2];k[p+12>>2]=k[s+12>>2];k[p+16>>2]=k[s+16>>2];k[p+20>>2]=k[s+20>>2];k[p+24>>2]=k[s+24>>2];k[p+28>>2]=k[s+28>>2];k[s>>2]=k[e>>2];k[s+4>>2]=k[e+4>>2];k[s+8>>2]=k[e+8>>2];k[s+12>>2]=k[e+12>>2];k[s+16>>2]=k[e+16>>2];k[s+20>>2]=k[e+20>>2];j[s+24>>1]=j[e+24>>1]|0;i[s+26>>0]=i[e+26>>0]|0;k[e>>2]=k[p>>2];k[e+4>>2]=k[p+4>>2];k[e+8>>2]=k[p+8>>2];k[e+12>>2]=k[p+12>>2];k[e+16>>2]=k[p+16>>2];k[e+20>>2]=k[p+20>>2];j[e+24>>1]=j[p+24>>1]|0;i[e+26>>0]=i[p+26>>0]|0;a=a+4|0}else a=a+3|0}else a=b}else a=d}}else{f=Za[k[c>>2]&7](g,s)|0;a=Za[k[c>>2]&7](n,g)|0;if(!f){if(!a){a=0;break};k[p>>2]=k[g>>2];k[p+4>>2]=k[g+4>>2];k[p+8>>2]=k[g+8>>2];k[p+12>>2]=k[g+12>>2];k[p+16>>2]=k[g+16>>2];k[p+20>>2]=k[g+20>>2];k[p+24>>2]=k[g+24>>2];k[p+28>>2]=k[g+28>>2];k[g>>2]=k[n>>2];k[g+4>>2]=k[n+4>>2];k[g+8>>2]=k[n+8>>2];k[g+12>>2]=k[n+12>>2];k[g+16>>2]=k[n+16>>2];k[g+20>>2]=k[n+20>>2];j[g+24>>1]=j[n+24>>1]|0;i[g+26>>0]=i[n+26>>0]|0;k[n>>2]=k[p>>2];k[n+4>>2]=k[p+4>>2];k[n+8>>2]=k[p+8>>2];k[n+12>>2]=k[p+12>>2];k[n+16>>2]=k[p+16>>2];k[n+20>>2]=k[p+20>>2];j[n+24>>1]=j[p+24>>1]|0;i[n+26>>0]=i[p+26>>0]|0;if(!(Za[k[c>>2]&7](g,s)|0)){a=1;break};k[p>>2]=k[s>>2];k[p+4>>2]=k[s+4>>2];k[p+8>>2]=k[s+8>>2];k[p+12>>2]=k[s+12>>2];k[p+16>>2]=k[s+16>>2];k[p+20>>2]=k[s+20>>2];k[p+24>>2]=k[s+24>>2];k[p+28>>2]=k[s+28>>2];k[s>>2]=k[g>>2];k[s+4>>2]=k[g+4>>2];k[s+8>>2]=k[g+8>>2];k[s+12>>2]=k[g+12>>2];k[s+16>>2]=k[g+16>>2];k[s+20>>2]=k[g+20>>2];j[s+24>>1]=j[g+24>>1]|0;i[s+26>>0]=i[g+26>>0]|0;k[g>>2]=k[p>>2];k[g+4>>2]=k[p+4>>2];k[g+8>>2]=k[p+8>>2];k[g+12>>2]=k[p+12>>2];k[g+16>>2]=k[p+16>>2];k[g+20>>2]=k[p+20>>2];j[g+24>>1]=j[p+24>>1]|0;i[g+26>>0]=i[p+26>>0]|0;a=2;break};k[p>>2]=k[s>>2];k[p+4>>2]=k[s+4>>2];k[p+8>>2]=k[s+8>>2];k[p+12>>2]=k[s+12>>2];k[p+16>>2]=k[s+16>>2];k[p+20>>2]=k[s+20>>2];k[p+24>>2]=k[s+24>>2];k[p+28>>2]=k[s+28>>2];if(a){k[s>>2]=k[n>>2];k[s+4>>2]=k[n+4>>2];k[s+8>>2]=k[n+8>>2];k[s+12>>2]=k[n+12>>2];k[s+16>>2]=k[n+16>>2];k[s+20>>2]=k[n+20>>2];j[s+24>>1]=j[n+24>>1]|0;i[s+26>>0]=i[n+26>>0]|0;k[n>>2]=k[p>>2];k[n+4>>2]=k[p+4>>2];k[n+8>>2]=k[p+8>>2];k[n+12>>2]=k[p+12>>2];k[n+16>>2]=k[p+16>>2];k[n+20>>2]=k[p+20>>2];j[n+24>>1]=j[p+24>>1]|0;i[n+26>>0]=i[p+26>>0]|0;a=1;break};k[s>>2]=k[g>>2];k[s+4>>2]=k[g+4>>2];k[s+8>>2]=k[g+8>>2];k[s+12>>2]=k[g+12>>2];k[s+16>>2]=k[g+16>>2];k[s+20>>2]=k[g+20>>2];j[s+24>>1]=j[g+24>>1]|0;i[s+26>>0]=i[g+26>>0]|0;k[g>>2]=k[p>>2];k[g+4>>2]=k[p+4>>2];k[g+8>>2]=k[p+8>>2];k[g+12>>2]=k[p+12>>2];k[g+16>>2]=k[p+16>>2];k[g+20>>2]=k[p+20>>2];j[g+24>>1]=j[p+24>>1]|0;i[g+26>>0]=i[p+26>>0]|0;if(Za[k[c>>2]&7](n,g)|0){k[p>>2]=k[g>>2];k[p+4>>2]=k[g+4>>2];k[p+8>>2]=k[g+8>>2];k[p+12>>2]=k[g+12>>2];k[p+16>>2]=k[g+16>>2];k[p+20>>2]=k[g+20>>2];k[p+24>>2]=k[g+24>>2];k[p+28>>2]=k[g+28>>2];k[g>>2]=k[n>>2];k[g+4>>2]=k[n+4>>2];k[g+8>>2]=k[n+8>>2];k[g+12>>2]=k[n+12>>2];k[g+16>>2]=k[n+16>>2];k[g+20>>2]=k[n+20>>2];j[g+24>>1]=j[n+24>>1]|0;i[g+26>>0]=i[n+26>>0]|0;k[n>>2]=k[p>>2];k[n+4>>2]=k[p+4>>2];k[n+8>>2]=k[p+8>>2];k[n+12>>2]=k[p+12>>2];k[n+16>>2]=k[p+16>>2];k[n+20>>2]=k[p+20>>2];j[n+24>>1]=j[p+24>>1]|0;i[n+26>>0]=i[p+26>>0]|0;a=2}else a=1}while(0);do if(Za[k[c>>2]&7](s,g)|0)b=n;else{b=n;while(1){b=b+-32|0;if((s|0)==(b|0))break;if(Za[k[c>>2]&7](b,g)|0){m=65;break}}if((m|0)==65){m=0;k[p>>2]=k[s>>2];k[p+4>>2]=k[s+4>>2];k[p+8>>2]=k[s+8>>2];k[p+12>>2]=k[s+12>>2];k[p+16>>2]=k[s+16>>2];k[p+20>>2]=k[s+20>>2];k[p+24>>2]=k[s+24>>2];k[p+28>>2]=k[s+28>>2];k[s>>2]=k[b>>2];k[s+4>>2]=k[b+4>>2];k[s+8>>2]=k[b+8>>2];k[s+12>>2]=k[b+12>>2];k[s+16>>2]=k[b+16>>2];k[s+20>>2]=k[b+20>>2];j[s+24>>1]=j[b+24>>1]|0;i[s+26>>0]=i[b+26>>0]|0;k[b>>2]=k[p>>2];k[b+4>>2]=k[p+4>>2];k[b+8>>2]=k[p+8>>2];k[b+12>>2]=k[p+12>>2];k[b+16>>2]=k[p+16>>2];k[b+20>>2]=k[p+20>>2];j[b+24>>1]=j[p+24>>1]|0;i[b+26>>0]=i[p+26>>0]|0;a=a+1|0;break}a=s+32|0;if(!(Za[k[c>>2]&7](s,n)|0)){if((a|0)==(n|0)){m=82;break a}else b=s;while(1){if(Za[k[c>>2]&7](s,a)|0)break;b=a+32|0;if((b|0)==(n|0)){m=82;break a}else{h=a;a=b;b=h}}k[p>>2]=k[a>>2];k[p+4>>2]=k[a+4>>2];k[p+8>>2]=k[a+8>>2];k[p+12>>2]=k[a+12>>2];k[p+16>>2]=k[a+16>>2];k[p+20>>2]=k[a+20>>2];k[p+24>>2]=k[a+24>>2];k[p+28>>2]=k[a+28>>2];k[a>>2]=k[n>>2];k[a+4>>2]=k[n+4>>2];k[a+8>>2]=k[n+8>>2];k[a+12>>2]=k[n+12>>2];k[a+16>>2]=k[n+16>>2];k[a+20>>2]=k[n+20>>2];j[a+24>>1]=j[n+24>>1]|0;i[a+26>>0]=i[n+26>>0]|0;k[n>>2]=k[p>>2];k[n+4>>2]=k[p+4>>2];k[n+8>>2]=k[p+8>>2];k[n+12>>2]=k[p+12>>2];k[n+16>>2]=k[p+16>>2];k[n+20>>2]=k[p+20>>2];j[n+24>>1]=j[p+24>>1]|0;i[n+26>>0]=i[p+26>>0]|0;a=b+64|0}if((a|0)==(n|0)){m=82;break a}else d=n;while(1){b=a;while(1){a=b+32|0;if(Za[k[c>>2]&7](s,b)|0)break;else b=a}do d=d+-32|0;while(Za[k[c>>2]&7](s,d)|0);if(b>>>0>=d>>>0){s=b;continue b};k[p>>2]=k[b>>2];k[p+4>>2]=k[b+4>>2];k[p+8>>2]=k[b+8>>2];k[p+12>>2]=k[b+12>>2];k[p+16>>2]=k[b+16>>2];k[p+20>>2]=k[b+20>>2];k[p+24>>2]=k[b+24>>2];k[p+28>>2]=k[b+28>>2];k[b>>2]=k[d>>2];k[b+4>>2]=k[d+4>>2];k[b+8>>2]=k[d+8>>2];k[b+12>>2]=k[d+12>>2];k[b+16>>2]=k[d+16>>2];k[b+20>>2]=k[d+20>>2];j[b+24>>1]=j[d+24>>1]|0;i[b+26>>0]=i[d+26>>0]|0;k[d>>2]=k[p>>2];k[d+4>>2]=k[p+4>>2];k[d+8>>2]=k[p+8>>2];k[d+12>>2]=k[p+12>>2];k[d+16>>2]=k[p+16>>2];k[d+20>>2]=k[p+20>>2];j[d+24>>1]=j[p+24>>1]|0;i[d+26>>0]=i[p+26>>0]|0}}while(0);d=s+32|0;c:do if(d>>>0<b>>>0)while(1){e=d;while(1){d=e+32|0;if(Za[k[c>>2]&7](e,g)|0)e=d;else{f=b;break}}do f=f+-32|0;while(!(Za[k[c>>2]&7](f,g)|0));if(e>>>0>f>>>0){d=e;b=g;break c};k[p>>2]=k[e>>2];k[p+4>>2]=k[e+4>>2];k[p+8>>2]=k[e+8>>2];k[p+12>>2]=k[e+12>>2];k[p+16>>2]=k[e+16>>2];k[p+20>>2]=k[e+20>>2];k[p+24>>2]=k[e+24>>2];k[p+28>>2]=k[e+28>>2];k[e>>2]=k[f>>2];k[e+4>>2]=k[f+4>>2];k[e+8>>2]=k[f+8>>2];k[e+12>>2]=k[f+12>>2];k[e+16>>2]=k[f+16>>2];k[e+20>>2]=k[f+20>>2];j[e+24>>1]=j[f+24>>1]|0;i[e+26>>0]=i[f+26>>0]|0;k[f>>2]=k[p>>2];k[f+4>>2]=k[p+4>>2];k[f+8>>2]=k[p+8>>2];k[f+12>>2]=k[p+12>>2];k[f+16>>2]=k[p+16>>2];k[f+20>>2]=k[p+20>>2];j[f+24>>1]=j[p+24>>1]|0;i[f+26>>0]=i[p+26>>0]|0;b=f;g=(g|0)==(e|0)?f:g;a=a+1|0}else b=g;while(0);if((d|0)!=(b|0)?Za[k[c>>2]&7](b,d)|0:0){k[p>>2]=k[d>>2];k[p+4>>2]=k[d+4>>2];k[p+8>>2]=k[d+8>>2];k[p+12>>2]=k[d+12>>2];k[p+16>>2]=k[d+16>>2];k[p+20>>2]=k[d+20>>2];k[p+24>>2]=k[d+24>>2];k[p+28>>2]=k[d+28>>2];k[d>>2]=k[b>>2];k[d+4>>2]=k[b+4>>2];k[d+8>>2]=k[b+8>>2];k[d+12>>2]=k[b+12>>2];k[d+16>>2]=k[b+16>>2];k[d+20>>2]=k[b+20>>2];j[d+24>>1]=j[b+24>>1]|0;i[d+26>>0]=i[b+26>>0]|0;k[b>>2]=k[p>>2];k[b+4>>2]=k[p+4>>2];k[b+8>>2]=k[p+8>>2];k[b+12>>2]=k[p+12>>2];k[b+16>>2]=k[p+16>>2];k[b+20>>2]=k[p+20>>2];j[b+24>>1]=j[p+24>>1]|0;i[b+26>>0]=i[p+26>>0]|0;a=a+1|0}if(!a){a=yb(s,d,c)|0;b=d+32|0;if(yb(b,o,c)|0){m=77;break}if(a){s=b;continue}}g=d;if((g-h|0)>=(l-g|0)){m=81;break}qb(s,d,c);s=d+32|0}if((m|0)==77){m=0;if(a){m=82;break}else{a=s;o=d;continue}}else if((m|0)==81){m=0;qb(d+32|0,o,c);a=s;o=d;continue}}if((m|0)==4){if(!(Za[k[c>>2]&7](n,s)|0)){r=t;return};k[p>>2]=k[s>>2];k[p+4>>2]=k[s+4>>2];k[p+8>>2]=k[s+8>>2];k[p+12>>2]=k[s+12>>2];k[p+16>>2]=k[s+16>>2];k[p+20>>2]=k[s+20>>2];k[p+24>>2]=k[s+24>>2];k[p+28>>2]=k[s+28>>2];k[s>>2]=k[n>>2];k[s+4>>2]=k[n+4>>2];k[s+8>>2]=k[n+8>>2];k[s+12>>2]=k[n+12>>2];k[s+16>>2]=k[n+16>>2];k[s+20>>2]=k[n+20>>2];j[s+24>>1]=j[n+24>>1]|0;i[s+26>>0]=i[n+26>>0]|0;k[n>>2]=k[p>>2];k[n+4>>2]=k[p+4>>2];k[n+8>>2]=k[p+8>>2];k[n+12>>2]=k[p+12>>2];k[n+16>>2]=k[p+16>>2];k[n+20>>2]=k[p+20>>2];j[n+24>>1]=j[p+24>>1]|0;i[n+26>>0]=i[p+26>>0]|0;r=t;return}else if((m|0)==6){b=s+32|0;q=Za[k[c>>2]&7](b,s)|0;a=Za[k[c>>2]&7](n,b)|0;if(!q){if(!a){r=t;return};k[p>>2]=k[b>>2];k[p+4>>2]=k[b+4>>2];k[p+8>>2]=k[b+8>>2];k[p+12>>2]=k[b+12>>2];k[p+16>>2]=k[b+16>>2];k[p+20>>2]=k[b+20>>2];k[p+24>>2]=k[b+24>>2];k[p+28>>2]=k[b+28>>2];k[b>>2]=k[n>>2];k[b+4>>2]=k[n+4>>2];k[b+8>>2]=k[n+8>>2];k[b+12>>2]=k[n+12>>2];k[b+16>>2]=k[n+16>>2];k[b+20>>2]=k[n+20>>2];j[b+24>>1]=j[n+24>>1]|0;i[b+26>>0]=i[n+26>>0]|0;k[n>>2]=k[p>>2];k[n+4>>2]=k[p+4>>2];k[n+8>>2]=k[p+8>>2];k[n+12>>2]=k[p+12>>2];k[n+16>>2]=k[p+16>>2];k[n+20>>2]=k[p+20>>2];j[n+24>>1]=j[p+24>>1]|0;i[n+26>>0]=i[p+26>>0]|0;if(!(Za[k[c>>2]&7](b,s)|0)){r=t;return};k[p>>2]=k[s>>2];k[p+4>>2]=k[s+4>>2];k[p+8>>2]=k[s+8>>2];k[p+12>>2]=k[s+12>>2];k[p+16>>2]=k[s+16>>2];k[p+20>>2]=k[s+20>>2];k[p+24>>2]=k[s+24>>2];k[p+28>>2]=k[s+28>>2];k[s>>2]=k[b>>2];k[s+4>>2]=k[b+4>>2];k[s+8>>2]=k[b+8>>2];k[s+12>>2]=k[b+12>>2];k[s+16>>2]=k[b+16>>2];k[s+20>>2]=k[b+20>>2];j[s+24>>1]=j[b+24>>1]|0;i[s+26>>0]=i[b+26>>0]|0;k[b>>2]=k[p>>2];k[b+4>>2]=k[p+4>>2];k[b+8>>2]=k[p+8>>2];k[b+12>>2]=k[p+12>>2];k[b+16>>2]=k[p+16>>2];k[b+20>>2]=k[p+20>>2];j[b+24>>1]=j[p+24>>1]|0;i[b+26>>0]=i[p+26>>0]|0;r=t;return};k[p>>2]=k[s>>2];k[p+4>>2]=k[s+4>>2];k[p+8>>2]=k[s+8>>2];k[p+12>>2]=k[s+12>>2];k[p+16>>2]=k[s+16>>2];k[p+20>>2]=k[s+20>>2];k[p+24>>2]=k[s+24>>2];k[p+28>>2]=k[s+28>>2];if(a){k[s>>2]=k[n>>2];k[s+4>>2]=k[n+4>>2];k[s+8>>2]=k[n+8>>2];k[s+12>>2]=k[n+12>>2];k[s+16>>2]=k[n+16>>2];k[s+20>>2]=k[n+20>>2];j[s+24>>1]=j[n+24>>1]|0;i[s+26>>0]=i[n+26>>0]|0;k[n>>2]=k[p>>2];k[n+4>>2]=k[p+4>>2];k[n+8>>2]=k[p+8>>2];k[n+12>>2]=k[p+12>>2];k[n+16>>2]=k[p+16>>2];k[n+20>>2]=k[p+20>>2];j[n+24>>1]=j[p+24>>1]|0;i[n+26>>0]=i[p+26>>0]|0;r=t;return};k[s>>2]=k[b>>2];k[s+4>>2]=k[b+4>>2];k[s+8>>2]=k[b+8>>2];k[s+12>>2]=k[b+12>>2];k[s+16>>2]=k[b+16>>2];k[s+20>>2]=k[b+20>>2];j[s+24>>1]=j[b+24>>1]|0;i[s+26>>0]=i[b+26>>0]|0;k[b>>2]=k[p>>2];k[b+4>>2]=k[p+4>>2];k[b+8>>2]=k[p+8>>2];k[b+12>>2]=k[p+12>>2];k[b+16>>2]=k[p+16>>2];k[b+20>>2]=k[p+20>>2];j[b+24>>1]=j[p+24>>1]|0;i[b+26>>0]=i[p+26>>0]|0;if(!(Za[k[c>>2]&7](n,b)|0)){r=t;return};k[p>>2]=k[b>>2];k[p+4>>2]=k[b+4>>2];k[p+8>>2]=k[b+8>>2];k[p+12>>2]=k[b+12>>2];k[p+16>>2]=k[b+16>>2];k[p+20>>2]=k[b+20>>2];k[p+24>>2]=k[b+24>>2];k[p+28>>2]=k[b+28>>2];k[b>>2]=k[n>>2];k[b+4>>2]=k[n+4>>2];k[b+8>>2]=k[n+8>>2];k[b+12>>2]=k[n+12>>2];k[b+16>>2]=k[n+16>>2];k[b+20>>2]=k[n+20>>2];j[b+24>>1]=j[n+24>>1]|0;i[b+26>>0]=i[n+26>>0]|0;k[n>>2]=k[p>>2];k[n+4>>2]=k[p+4>>2];k[n+8>>2]=k[p+8>>2];k[n+12>>2]=k[p+12>>2];k[n+16>>2]=k[p+16>>2];k[n+20>>2]=k[p+20>>2];j[n+24>>1]=j[p+24>>1]|0;i[n+26>>0]=i[p+26>>0]|0;r=t;return}else if((m|0)==14){xb(s,s+32|0,s+64|0,n,c)|0;r=t;return}else if((m|0)==15){a=s+32|0;b=s+64|0;d=s+96|0;xb(s,a,b,d,c)|0;if(!(Za[k[c>>2]&7](n,d)|0)){r=t;return};k[p>>2]=k[d>>2];k[p+4>>2]=k[d+4>>2];k[p+8>>2]=k[d+8>>2];k[p+12>>2]=k[d+12>>2];k[p+16>>2]=k[d+16>>2];k[p+20>>2]=k[d+20>>2];k[p+24>>2]=k[d+24>>2];k[p+28>>2]=k[d+28>>2];k[d>>2]=k[n>>2];k[d+4>>2]=k[n+4>>2];k[d+8>>2]=k[n+8>>2];k[d+12>>2]=k[n+12>>2];k[d+16>>2]=k[n+16>>2];k[d+20>>2]=k[n+20>>2];j[d+24>>1]=j[n+24>>1]|0;i[d+26>>0]=i[n+26>>0]|0;k[n>>2]=k[p>>2];k[n+4>>2]=k[p+4>>2];k[n+8>>2]=k[p+8>>2];k[n+12>>2]=k[p+12>>2];k[n+16>>2]=k[p+16>>2];k[n+20>>2]=k[p+20>>2];j[n+24>>1]=j[p+24>>1]|0;i[n+26>>0]=i[p+26>>0]|0;if(!(Za[k[c>>2]&7](d,b)|0)){r=t;return};k[p>>2]=k[b>>2];k[p+4>>2]=k[b+4>>2];k[p+8>>2]=k[b+8>>2];k[p+12>>2]=k[b+12>>2];k[p+16>>2]=k[b+16>>2];k[p+20>>2]=k[b+20>>2];k[p+24>>2]=k[b+24>>2];k[p+28>>2]=k[b+28>>2];k[b>>2]=k[d>>2];k[b+4>>2]=k[d+4>>2];k[b+8>>2]=k[d+8>>2];k[b+12>>2]=k[d+12>>2];k[b+16>>2]=k[d+16>>2];k[b+20>>2]=k[d+20>>2];j[b+24>>1]=j[d+24>>1]|0;i[b+26>>0]=i[d+26>>0]|0;k[d>>2]=k[p>>2];k[d+4>>2]=k[p+4>>2];k[d+8>>2]=k[p+8>>2];k[d+12>>2]=k[p+12>>2];k[d+16>>2]=k[p+16>>2];k[d+20>>2]=k[p+20>>2];j[d+24>>1]=j[p+24>>1]|0;i[d+26>>0]=i[p+26>>0]|0;if(!(Za[k[c>>2]&7](b,a)|0)){r=t;return};k[p>>2]=k[a>>2];k[p+4>>2]=k[a+4>>2];k[p+8>>2]=k[a+8>>2];k[p+12>>2]=k[a+12>>2];k[p+16>>2]=k[a+16>>2];k[p+20>>2]=k[a+20>>2];k[p+24>>2]=k[a+24>>2];k[p+28>>2]=k[a+28>>2];k[a>>2]=k[b>>2];k[a+4>>2]=k[b+4>>2];k[a+8>>2]=k[b+8>>2];k[a+12>>2]=k[b+12>>2];k[a+16>>2]=k[b+16>>2];k[a+20>>2]=k[b+20>>2];j[a+24>>1]=j[b+24>>1]|0;i[a+26>>0]=i[b+26>>0]|0;k[b>>2]=k[p>>2];k[b+4>>2]=k[p+4>>2];k[b+8>>2]=k[p+8>>2];k[b+12>>2]=k[p+12>>2];k[b+16>>2]=k[p+16>>2];k[b+20>>2]=k[p+20>>2];j[b+24>>1]=j[p+24>>1]|0;i[b+26>>0]=i[p+26>>0]|0;if(!(Za[k[c>>2]&7](a,s)|0)){r=t;return};k[p>>2]=k[s>>2];k[p+4>>2]=k[s+4>>2];k[p+8>>2]=k[s+8>>2];k[p+12>>2]=k[s+12>>2];k[p+16>>2]=k[s+16>>2];k[p+20>>2]=k[s+20>>2];k[p+24>>2]=k[s+24>>2];k[p+28>>2]=k[s+28>>2];k[s>>2]=k[a>>2];k[s+4>>2]=k[a+4>>2];k[s+8>>2]=k[a+8>>2];k[s+12>>2]=k[a+12>>2];k[s+16>>2]=k[a+16>>2];k[s+20>>2]=k[a+20>>2];j[s+24>>1]=j[a+24>>1]|0;i[s+26>>0]=i[a+26>>0]|0;k[a>>2]=k[p>>2];k[a+4>>2]=k[p+4>>2];k[a+8>>2]=k[p+8>>2];k[a+12>>2]=k[p+12>>2];k[a+16>>2]=k[p+16>>2];k[a+20>>2]=k[p+20>>2];j[a+24>>1]=j[p+24>>1]|0;i[a+26>>0]=i[p+26>>0]|0;r=t;return}else if((m|0)==21){b=s+64|0;a=s+32|0;n=Za[k[c>>2]&7](a,s)|0;d=Za[k[c>>2]&7](b,a)|0;do if(n){k[p>>2]=k[s>>2];k[p+4>>2]=k[s+4>>2];k[p+8>>2]=k[s+8>>2];k[p+12>>2]=k[s+12>>2];k[p+16>>2]=k[s+16>>2];k[p+20>>2]=k[s+20>>2];k[p+24>>2]=k[s+24>>2];k[p+28>>2]=k[s+28>>2];if(d){k[s>>2]=k[b>>2];k[s+4>>2]=k[b+4>>2];k[s+8>>2]=k[b+8>>2];k[s+12>>2]=k[b+12>>2];k[s+16>>2]=k[b+16>>2];k[s+20>>2]=k[b+20>>2];j[s+24>>1]=j[b+24>>1]|0;i[s+26>>0]=i[b+26>>0]|0;k[b>>2]=k[p>>2];k[b+4>>2]=k[p+4>>2];k[b+8>>2]=k[p+8>>2];k[b+12>>2]=k[p+12>>2];k[b+16>>2]=k[p+16>>2];k[b+20>>2]=k[p+20>>2];j[b+24>>1]=j[p+24>>1]|0;i[b+26>>0]=i[p+26>>0]|0;break};k[s>>2]=k[a>>2];k[s+4>>2]=k[a+4>>2];k[s+8>>2]=k[a+8>>2];k[s+12>>2]=k[a+12>>2];k[s+16>>2]=k[a+16>>2];k[s+20>>2]=k[a+20>>2];j[s+24>>1]=j[a+24>>1]|0;i[s+26>>0]=i[a+26>>0]|0;k[a>>2]=k[p>>2];k[a+4>>2]=k[p+4>>2];k[a+8>>2]=k[p+8>>2];k[a+12>>2]=k[p+12>>2];k[a+16>>2]=k[p+16>>2];k[a+20>>2]=k[p+20>>2];j[a+24>>1]=j[p+24>>1]|0;i[a+26>>0]=i[p+26>>0]|0;if(Za[k[c>>2]&7](b,a)|0){k[p>>2]=k[a>>2];k[p+4>>2]=k[a+4>>2];k[p+8>>2]=k[a+8>>2];k[p+12>>2]=k[a+12>>2];k[p+16>>2]=k[a+16>>2];k[p+20>>2]=k[a+20>>2];k[p+24>>2]=k[a+24>>2];k[p+28>>2]=k[a+28>>2];k[a>>2]=k[b>>2];k[a+4>>2]=k[b+4>>2];k[a+8>>2]=k[b+8>>2];k[a+12>>2]=k[b+12>>2];k[a+16>>2]=k[b+16>>2];k[a+20>>2]=k[b+20>>2];j[a+24>>1]=j[b+24>>1]|0;i[a+26>>0]=i[b+26>>0]|0;k[b>>2]=k[p>>2];k[b+4>>2]=k[p+4>>2];k[b+8>>2]=k[p+8>>2];k[b+12>>2]=k[p+12>>2];k[b+16>>2]=k[p+16>>2];k[b+20>>2]=k[p+20>>2];j[b+24>>1]=j[p+24>>1]|0;i[b+26>>0]=i[p+26>>0]|0}}else if(d?(k[p>>2]=k[a>>2],k[p+4>>2]=k[a+4>>2],k[p+8>>2]=k[a+8>>2],k[p+12>>2]=k[a+12>>2],k[p+16>>2]=k[a+16>>2],k[p+20>>2]=k[a+20>>2],k[p+24>>2]=k[a+24>>2],k[p+28>>2]=k[a+28>>2],k[a>>2]=k[b>>2],k[a+4>>2]=k[b+4>>2],k[a+8>>2]=k[b+8>>2],k[a+12>>2]=k[b+12>>2],k[a+16>>2]=k[b+16>>2],k[a+20>>2]=k[b+20>>2],j[a+24>>1]=j[b+24>>1]|0,i[a+26>>0]=i[b+26>>0]|0,k[b>>2]=k[p>>2],k[b+4>>2]=k[p+4>>2],k[b+8>>2]=k[p+8>>2],k[b+12>>2]=k[p+12>>2],k[b+16>>2]=k[p+16>>2],k[b+20>>2]=k[p+20>>2],j[b+24>>1]=j[p+24>>1]|0,i[b+26>>0]=i[p+26>>0]|0,Za[k[c>>2]&7](a,s)|0):0){k[p>>2]=k[s>>2];k[p+4>>2]=k[s+4>>2];k[p+8>>2]=k[s+8>>2];k[p+12>>2]=k[s+12>>2];k[p+16>>2]=k[s+16>>2];k[p+20>>2]=k[s+20>>2];k[p+24>>2]=k[s+24>>2];k[p+28>>2]=k[s+28>>2];k[s>>2]=k[a>>2];k[s+4>>2]=k[a+4>>2];k[s+8>>2]=k[a+8>>2];k[s+12>>2]=k[a+12>>2];k[s+16>>2]=k[a+16>>2];k[s+20>>2]=k[a+20>>2];j[s+24>>1]=j[a+24>>1]|0;i[s+26>>0]=i[a+26>>0]|0;k[a>>2]=k[p>>2];k[a+4>>2]=k[p+4>>2];k[a+8>>2]=k[p+8>>2];k[a+12>>2]=k[p+12>>2];k[a+16>>2]=k[p+16>>2];k[a+20>>2]=k[p+20>>2];j[a+24>>1]=j[p+24>>1]|0;i[a+26>>0]=i[p+26>>0]|0}while(0);a=s+96|0;if((a|0)!=(o|0))while(1){if(Za[k[c>>2]&7](a,b)|0){k[q>>2]=k[a>>2];k[q+4>>2]=k[a+4>>2];k[q+8>>2]=k[a+8>>2];k[q+12>>2]=k[a+12>>2];k[q+16>>2]=k[a+16>>2];k[q+20>>2]=k[a+20>>2];k[q+24>>2]=k[a+24>>2];k[q+28>>2]=k[a+28>>2];d=a;e=b;while(1){k[d>>2]=k[e>>2];k[d+4>>2]=k[e+4>>2];k[d+8>>2]=k[e+8>>2];k[d+12>>2]=k[e+12>>2];k[d+16>>2]=k[e+16>>2];k[d+20>>2]=k[e+20>>2];j[d+24>>1]=j[e+24>>1]|0;i[d+26>>0]=i[e+26>>0]|0;if((e|0)==(s|0))break;b=e+-32|0;if(Za[k[c>>2]&7](q,b)|0){d=e;e=b}else break}k[e>>2]=k[q>>2];k[e+4>>2]=k[q+4>>2];k[e+8>>2]=k[q+8>>2];k[e+12>>2]=k[q+12>>2];k[e+16>>2]=k[q+16>>2];k[e+20>>2]=k[q+20>>2];j[e+24>>1]=j[q+24>>1]|0;i[e+26>>0]=i[q+26>>0]|0}b=a+32|0;if((b|0)==(o|0))break;else{p=a;a=b;b=p}}r=t;return}else if((m|0)==82){r=t;return}}function rb(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0;a:while(1){p=b;r=b+-32|0;q=b+-64|0;z=b+-28|0;s=z+4|0;t=b+-20|0;u=b+-16|0;v=b+-12|0;w=b+-8|0;x=b+-4|0;b:while(1){o=a;c=p-o|0;d=c>>5;switch(d|0){case 2:{y=4;break a}case 3:{y=8;break a}case 4:{y=9;break a}case 5:{y=10;break a}case 1:case 0:{y=83;break a}default:{}}if((c|0)<224){y=12;break a}e=(d|0)/2|0;j=a+(e<<5)|0;if((c|0)>31968){c=(d|0)/4|0;c=vb(a,a+(c<<5)|0,j,a+(c+e<<5)|0,r)|0}else c=tb(a,j,r)|0;n=a+4|0;d=a+(e<<5)+4|0;m=i[n>>0]^1;l=i[d>>0]^1;c:do if((m&255)<(l&255))e=r;else{if((l&255)>=(m&255)?(k[n+4>>2]|0)>>>0<(k[d+4>>2]|0)>>>0:0){e=r;break}d:do if((a|0)!=(q|0)){h=d+4|0;e=q;f=r;while(1){g=f+-28|0;d=i[g>>0]^1;if((d&255)<(l&255))break;if((l&255)>=(d&255)?(k[g+4>>2]|0)>>>0<(k[h>>2]|0)>>>0:0)break;d=e+-32|0;if((a|0)==(d|0))break d;else{f=e;e=d}}G=k[a>>2]|0;E=n;F=k[E>>2]|0;E=k[E+4>>2]|0;A=a+12|0;D=k[A>>2]|0;h=a+16|0;B=k[h>>2]|0;I=a+20|0;d=k[I>>2]|0;y=a+24|0;l=k[y>>2]|0;H=a+28|0;m=k[H>>2]|0;k[a>>2]=k[e>>2];K=g;J=k[K+4>>2]|0;C=n;k[C>>2]=k[K>>2];k[C+4>>2]=J;C=f+-20|0;k[A>>2]=k[C>>2];A=f+-16|0;k[h>>2]=k[A>>2];h=f+-12|0;k[I>>2]=k[h>>2];n=f+-8|0;k[y>>2]=k[n>>2];y=f+-4|0;k[H>>2]=k[y>>2];k[e>>2]=G;k[g>>2]=F;k[g+4>>2]=E;k[C>>2]=D;k[A>>2]=B;k[h>>2]=d;k[n>>2]=l;k[y>>2]=m;c=c+1|0;break c}while(0);d=a+32|0;c=i[z>>0]^1;do if((m&255)<(c&255))a=d;else{if((c&255)>=(m&255)?(k[n+4>>2]|0)>>>0<(k[s>>2]|0)>>>0:0){a=d;break}if((d|0)==(r|0)){y=83;break a}f=n+4|0;while(1){e=a+36|0;c=i[e>>0]^1;if((m&255)<(c&255))break;if((c&255)>=(m&255)?(k[f>>2]|0)>>>0<(k[e+4>>2]|0)>>>0:0)break;a=d+32|0;if((a|0)==(r|0)){y=83;break a}else{K=d;d=a;a=K}}F=k[d>>2]|0;E=e;D=k[E>>2]|0;E=k[E+4>>2]|0;o=a+44|0;G=k[o>>2]|0;y=a+48|0;H=k[y>>2]|0;A=a+52|0;I=k[A>>2]|0;B=a+56|0;J=k[B>>2]|0;C=a+60|0;K=k[C>>2]|0;k[d>>2]=k[r>>2];j=z;l=k[j+4>>2]|0;m=e;k[m>>2]=k[j>>2];k[m+4>>2]=l;k[o>>2]=k[t>>2];k[y>>2]=k[u>>2];k[A>>2]=k[v>>2];k[B>>2]=k[w>>2];k[C>>2]=k[x>>2];k[r>>2]=F;F=z;k[F>>2]=D;k[F+4>>2]=E;k[t>>2]=G;k[u>>2]=H;k[v>>2]=I;k[w>>2]=J;k[x>>2]=K;a=a+64|0}while(0);if((a|0)==(r|0)){y=83;break a}h=n+4|0;f=r;while(1){g=i[n>>0]^1;c=i[a+4>>0]^1;e:do if((g&255)>=(c&255)){d=a;while(1){if((c&255)>=(g&255)?(k[h>>2]|0)>>>0<(k[d+4+4>>2]|0)>>>0:0){a=d;break e}a=d+32|0;c=i[d+36>>0]^1;if((g&255)<(c&255))break;else d=a}}while(0);d=f;while(1){f=d+-32|0;e=d+-28|0;c=i[e>>0]^1;if((g&255)<(c&255)){d=f;continue}if((c&255)<(g&255))break;if((k[h>>2]|0)>>>0<(k[e+4>>2]|0)>>>0)d=f;else break}if(a>>>0>=f>>>0)continue b;A=k[a>>2]|0;C=a+4|0;y=C;o=k[y>>2]|0;y=k[y+4>>2]|0;E=a+12|0;B=k[E>>2]|0;G=a+16|0;D=k[G>>2]|0;I=a+20|0;F=k[I>>2]|0;K=a+24|0;H=k[K>>2]|0;m=a+28|0;J=k[m>>2]|0;k[a>>2]=k[f>>2];j=e;l=k[j+4>>2]|0;k[C>>2]=k[j>>2];k[C+4>>2]=l;C=d+-20|0;k[E>>2]=k[C>>2];E=d+-16|0;k[G>>2]=k[E>>2];G=d+-12|0;k[I>>2]=k[G>>2];I=d+-8|0;k[K>>2]=k[I>>2];K=d+-4|0;k[m>>2]=k[K>>2];k[f>>2]=A;A=e;k[A>>2]=o;k[A+4>>2]=y;k[C>>2]=B;k[E>>2]=D;k[G>>2]=F;k[I>>2]=H;k[K>>2]=J;a=a+32|0}}while(0);d=a+32|0;f:do if(d>>>0<e>>>0)while(1){l=j+4|0;h=i[l>>0]^1;l=l+4|0;n=d;while(1){m=n+4|0;d=i[m>>0]^1;if((d&255)>=(h&255)){if((h&255)<(d&255))break;if((k[m+4>>2]|0)>>>0>=(k[l>>2]|0)>>>0)break}n=n+32|0}f=e+-32|0;d=i[e+-28>>0]^1;g:do if((d&255)>=(h&255)){g=f;while(1){if((h&255)>=(d&255)?(k[e+-28+4>>2]|0)>>>0<(k[l>>2]|0)>>>0:0){f=g;break g}f=g+-32|0;d=i[e+-60>>0]^1;if((d&255)<(h&255)){e=g;break}else{e=g;g=f}}}while(0);if(n>>>0>f>>>0){d=n;break f}l=k[n>>2]|0;B=m;A=k[B>>2]|0;B=k[B+4>>2]|0;F=n+12|0;C=k[F>>2]|0;H=n+16|0;E=k[H>>2]|0;J=n+20|0;G=k[J>>2]|0;d=n+24|0;I=k[d>>2]|0;h=n+28|0;K=k[h>>2]|0;k[n>>2]=k[f>>2];y=e+-28|0;L=y;g=k[L+4>>2]|0;D=m;k[D>>2]=k[L>>2];k[D+4>>2]=g;D=e+-20|0;k[F>>2]=k[D>>2];F=e+-16|0;k[H>>2]=k[F>>2];H=e+-12|0;k[J>>2]=k[H>>2];J=e+-8|0;k[d>>2]=k[J>>2];d=e+-4|0;k[h>>2]=k[d>>2];k[f>>2]=l;e=y;k[e>>2]=A;k[e+4>>2]=B;k[D>>2]=C;k[F>>2]=E;k[H>>2]=G;k[J>>2]=I;k[d>>2]=K;d=n+32|0;e=f;j=(j|0)==(n|0)?f:j;c=c+1|0}while(0);do if((d|0)!=(j|0)){g=j+4|0;h=d+4|0;e=i[g>>0]^1;f=i[h>>0]^1;if((e&255)>=(f&255)){if((f&255)<(e&255))break;if((k[g+4>>2]|0)>>>0>=(k[h+4>>2]|0)>>>0)break}B=k[d>>2]|0;A=h;y=k[A>>2]|0;A=k[A+4>>2]|0;F=d+12|0;C=k[F>>2]|0;H=d+16|0;E=k[H>>2]|0;J=d+20|0;G=k[J>>2]|0;L=d+24|0;I=k[L>>2]|0;n=d+28|0;K=k[n>>2]|0;k[d>>2]=k[j>>2];l=g;m=k[l+4>>2]|0;D=h;k[D>>2]=k[l>>2];k[D+4>>2]=m;D=j+12|0;k[F>>2]=k[D>>2];F=j+16|0;k[H>>2]=k[F>>2];H=j+20|0;k[J>>2]=k[H>>2];J=j+24|0;k[L>>2]=k[J>>2];L=j+28|0;k[n>>2]=k[L>>2];k[j>>2]=B;B=g;k[B>>2]=y;k[B+4>>2]=A;k[D>>2]=C;k[F>>2]=E;k[H>>2]=G;k[J>>2]=I;k[L>>2]=K;c=c+1|0}while(0);if(!c){e=wb(a,d)|0;c=d+32|0;if(wb(c,b)|0){y=78;break}if(e){a=c;continue}}L=d;if((L-o|0)>=(p-L|0)){y=82;break}rb(a,d);a=d+32|0}if((y|0)==78)if(e){y=83;break}else{b=d;continue}else if((y|0)==82){rb(d+32|0,b);b=d;continue}}if((y|0)==4){d=a+4|0;b=i[z>>0]^1;c=i[d>>0]^1;if((b&255)>=(c&255)){if((c&255)<(b&255))return;if((k[s>>2]|0)>>>0>=(k[d+4>>2]|0)>>>0)return}G=k[a>>2]|0;F=d;E=k[F>>2]|0;F=k[F+4>>2]|0;y=a+12|0;H=k[y>>2]|0;A=a+16|0;I=k[A>>2]|0;B=a+20|0;J=k[B>>2]|0;C=a+24|0;K=k[C>>2]|0;D=a+28|0;L=k[D>>2]|0;k[a>>2]=k[r>>2];p=z;q=k[p+4>>2]|0;s=d;k[s>>2]=k[p>>2];k[s+4>>2]=q;k[y>>2]=k[t>>2];k[A>>2]=k[u>>2];k[B>>2]=k[v>>2];k[C>>2]=k[w>>2];k[D>>2]=k[x>>2];k[r>>2]=G;G=z;k[G>>2]=E;k[G+4>>2]=F;k[t>>2]=H;k[u>>2]=I;k[v>>2]=J;k[w>>2]=K;k[x>>2]=L;return}else if((y|0)==8){tb(a,a+32|0,r)|0;return}else if((y|0)==9){ub(a,a+32|0,a+64|0,r)|0;return}else if((y|0)==10){vb(a,a+32|0,a+64|0,a+96|0,r)|0;return}else if((y|0)==12){d=a+64|0;tb(a,a+32|0,d)|0;c=a+96|0;if((c|0)==(b|0))return;else x=c;while(1){f=x+4|0;l=d+4|0;c=i[f>>0]^1;e=i[l>>0]^1;if((c&255)>=(e&255)){if((e&255)>=(c&255)?(k[f+4>>2]|0)>>>0<(k[l+4>>2]|0)>>>0:0)y=16}else y=16;if((y|0)==16){y=0;p=k[x>>2]|0;r=f;q=k[r>>2]|0;r=k[r+4>>2]|0;e=x+12|0;s=k[e>>2]|0;g=x+16|0;t=k[g>>2]|0;h=x+20|0;u=k[h>>2]|0;K=x+24|0;v=k[K>>2]|0;L=x+28|0;w=k[L>>2]|0;k[x>>2]=k[d>>2];I=l;J=k[I+4>>2]|0;c=f;k[c>>2]=k[I>>2];k[c+4>>2]=J;c=d+12|0;k[e>>2]=k[c>>2];e=d+16|0;k[g>>2]=k[e>>2];g=d+20|0;k[h>>2]=k[g>>2];h=d+24|0;k[K>>2]=k[h>>2];f=d+28|0;k[L>>2]=k[f>>2];h:do if((d|0)==(a|0)){j=e;e=l}else{n=q&255^1;m=d;o=f;j=e;e=l;while(1){d=m+-32|0;l=m+-28|0;f=i[l>>0]^1;if((n&255)>=(f&255)){if((f&255)<(n&255)){d=m;f=o;break h}if(r>>>0>=(k[m+-24>>2]|0)>>>0){d=m;f=o;break h}}k[m>>2]=k[d>>2];g=l;e=k[g+4>>2]|0;c=m+4|0;k[c>>2]=k[g>>2];k[c+4>>2]=e;c=m+-20|0;k[m+12>>2]=k[c>>2];e=m+-16|0;k[m+16>>2]=k[e>>2];g=m+-12|0;k[m+20>>2]=k[g>>2];h=m+-8|0;k[m+24>>2]=k[h>>2];f=m+-4|0;k[m+28>>2]=k[f>>2];if((d|0)==(a|0)){j=e;e=l;break}else{m=d;o=f;j=e;e=l}}}while(0);k[d>>2]=p;L=e;k[L>>2]=q;k[L+4>>2]=r;k[c>>2]=s;k[j>>2]=t;k[g>>2]=u;k[h>>2]=v;k[f>>2]=w}c=x+32|0;if((c|0)==(b|0))break;else{d=x;x=c}}return}else if((y|0)==83)return}function sb(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,l=0,m=0,n=0,o=0;m=a+4|0;e=k[m>>2]|0;n=k[a>>2]|0;j=n;l=e-j>>3;i=l+1|0;if(i>>>0>536870911)xa(1340,1363,303,1438);o=a+8|0;c=(k[o>>2]|0)-j|0;if(c>>3>>>0<268435455){c=c>>2;c=c>>>0<i>>>0?i:c;if(!c){f=0;d=0}else g=5}else{c=536870911;g=5}if((g|0)==5){f=c<<3;f=(f|0)==0?1:f;d=_d(f)|0;a:do if(!d){while(1){d=k[35]|0;k[35]=d+0;if(!d)break;Xa[d&0]();d=_d(f)|0;if(d)break a}a=ya(4)|0;k[a>>2]=128;La(a|0,8,1)}while(0);f=c}c=d+(l<<3)|0;h=d+(f<<3)|0;k[c>>2]=k[b>>2];k[d+(l<<3)+4>>2]=k[b+4>>2];g=d+(i<<3)|0;if((e|0)!=(n|0)){f=e+-8|0;while(1){b=e;e=e+-8|0;k[c+-8>>2]=k[e>>2];k[c+-4>>2]=k[b+-4>>2];if((e|0)==(n|0))break;else c=c+-8|0}c=d+(l+~((f-j|0)>>>3)<<3)|0}k[a>>2]=c;k[m>>2]=g;k[o>>2]=h;if(!n)return;$d(n);return}function tb(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0;x=b+4|0;v=a+4|0;e=i[x>>0]^1;d=i[v>>0]^1;if((e&255)>=(d&255))if((d&255)<(e&255))f=0;else f=(k[x+4>>2]|0)>>>0<(k[v+4>>2]|0)>>>0;else f=1;w=c+4|0;d=i[w>>0]^1;if((d&255)>=(e&255))if((e&255)<(d&255))e=0;else e=(k[w+4>>2]|0)>>>0<(k[x+4>>2]|0)>>>0;else e=1;if(!f){if(!e){x=0;return x|0}z=k[b>>2]|0;m=x;y=k[m>>2]|0;m=k[m+4>>2]|0;f=b+12|0;n=k[f>>2]|0;g=b+16|0;p=k[g>>2]|0;h=b+20|0;r=k[h>>2]|0;j=b+24|0;t=k[j>>2]|0;l=b+28|0;e=k[l>>2]|0;k[b>>2]=k[c>>2];s=w;q=k[s+4>>2]|0;o=x;k[o>>2]=k[s>>2];k[o+4>>2]=q;o=c+12|0;k[f>>2]=k[o>>2];q=c+16|0;k[g>>2]=k[q>>2];s=c+20|0;k[h>>2]=k[s>>2];u=c+24|0;k[j>>2]=k[u>>2];d=c+28|0;k[l>>2]=k[d>>2];k[c>>2]=z;c=w;k[c>>2]=y;k[c+4>>2]=m;k[o>>2]=n;k[q>>2]=p;k[s>>2]=r;k[u>>2]=t;k[d>>2]=e;d=i[x>>0]^1;e=i[v>>0]^1;if((d&255)>=(e&255)){if((e&255)<(d&255)){z=1;return z|0}if((k[x+4>>2]|0)>>>0>=(k[v+4>>2]|0)>>>0){z=1;return z|0}}r=k[a>>2]|0;t=v;s=k[t>>2]|0;t=k[t+4>>2]|0;m=a+12|0;u=k[m>>2]|0;n=a+16|0;w=k[n>>2]|0;o=a+20|0;c=k[o>>2]|0;p=a+24|0;y=k[p>>2]|0;q=a+28|0;z=k[q>>2]|0;k[a>>2]=k[b>>2];e=x;a=k[e+4>>2]|0;k[v>>2]=k[e>>2];k[v+4>>2]=a;k[m>>2]=k[f>>2];k[n>>2]=k[g>>2];k[o>>2]=k[h>>2];k[p>>2]=k[j>>2];k[q>>2]=k[l>>2];k[b>>2]=r;k[x>>2]=s;k[x+4>>2]=t;k[f>>2]=u;k[g>>2]=w;k[h>>2]=c;k[j>>2]=y;k[l>>2]=z;z=2;return z|0}n=k[a>>2]|0;p=v;o=k[p>>2]|0;p=k[p+4>>2]|0;d=a+12|0;q=k[d>>2]|0;f=a+16|0;r=k[f>>2]|0;g=a+20|0;s=k[g>>2]|0;l=a+24|0;t=k[l>>2]|0;m=a+28|0;u=k[m>>2]|0;if(e){k[a>>2]=k[c>>2];x=w;b=k[x+4>>2]|0;k[v>>2]=k[x>>2];k[v+4>>2]=b;v=c+12|0;k[d>>2]=k[v>>2];b=c+16|0;k[f>>2]=k[b>>2];x=c+20|0;k[g>>2]=k[x>>2];y=c+24|0;k[l>>2]=k[y>>2];z=c+28|0;k[m>>2]=k[z>>2];k[c>>2]=n;c=w;k[c>>2]=o;k[c+4>>2]=p;k[v>>2]=q;k[b>>2]=r;k[x>>2]=s;k[y>>2]=t;k[z>>2]=u;z=1;return z|0}k[a>>2]=k[b>>2];h=x;j=k[h+4>>2]|0;a=v;k[a>>2]=k[h>>2];k[a+4>>2]=j;a=b+12|0;k[d>>2]=k[a>>2];j=b+16|0;k[f>>2]=k[j>>2];h=b+20|0;k[g>>2]=k[h>>2];g=b+24|0;k[l>>2]=k[g>>2];f=b+28|0;k[m>>2]=k[f>>2];k[b>>2]=n;d=x;k[d>>2]=o;k[d+4>>2]=p;k[a>>2]=q;k[j>>2]=r;k[h>>2]=s;k[g>>2]=t;k[f>>2]=u;d=i[w>>0]^1;e=o&255^1;if((d&255)>=(e&255)){if((e&255)<(d&255)){z=1;return z|0}if((k[w+4>>2]|0)>>>0>=p>>>0){z=1;return z|0}}k[b>>2]=k[c>>2];y=w;b=k[y+4>>2]|0;v=x;k[v>>2]=k[y>>2];k[v+4>>2]=b;v=c+12|0;k[a>>2]=k[v>>2];b=c+16|0;k[j>>2]=k[b>>2];x=c+20|0;k[h>>2]=k[x>>2];y=c+24|0;k[g>>2]=k[y>>2];z=c+28|0;k[f>>2]=k[z>>2];k[c>>2]=n;c=w;k[c>>2]=o;k[c+4>>2]=p;k[v>>2]=q;k[b>>2]=r;k[x>>2]=s;k[y>>2]=t;k[z>>2]=u;z=2;return z|0}function ub(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,g=0,h=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0;v=tb(a,b,c)|0;g=d+4|0;t=c+4|0;e=i[g>>0]^1;f=i[t>>0]^1;if((e&255)>=(f&255)){if((f&255)<(e&255)){b=v;return b|0}if((k[g+4>>2]|0)>>>0>=(k[t+4>>2]|0)>>>0){b=v;return b|0}}A=k[c>>2]|0;y=t;z=k[y>>2]|0;y=k[y+4>>2]|0;o=c+12|0;x=k[o>>2]|0;p=c+16|0;h=k[p>>2]|0;q=c+20|0;l=k[q>>2]|0;r=c+24|0;n=k[r>>2]|0;s=c+28|0;u=k[s>>2]|0;k[c>>2]=k[d>>2];m=g;j=k[m+4>>2]|0;w=t;k[w>>2]=k[m>>2];k[w+4>>2]=j;w=d+12|0;k[o>>2]=k[w>>2];j=d+16|0;k[p>>2]=k[j>>2];m=d+20|0;k[q>>2]=k[m>>2];f=d+24|0;k[r>>2]=k[f>>2];e=d+28|0;k[s>>2]=k[e>>2];k[d>>2]=A;d=g;k[d>>2]=z;k[d+4>>2]=y;k[w>>2]=x;k[j>>2]=h;k[m>>2]=l;k[f>>2]=n;k[e>>2]=u;e=v+1|0;u=b+4|0;f=i[t>>0]^1;d=i[u>>0]^1;if((f&255)>=(d&255)){if((d&255)<(f&255)){A=e;return A|0}if((k[t+4>>2]|0)>>>0>=(k[u+4>>2]|0)>>>0){A=e;return A|0}}z=k[b>>2]|0;y=u;x=k[y>>2]|0;y=k[y+4>>2]|0;h=b+12|0;A=k[h>>2]|0;j=b+16|0;f=k[j>>2]|0;l=b+20|0;e=k[l>>2]|0;m=b+24|0;g=k[m>>2]|0;n=b+28|0;d=k[n>>2]|0;k[b>>2]=k[c>>2];C=t;B=k[C+4>>2]|0;w=u;k[w>>2]=k[C>>2];k[w+4>>2]=B;k[h>>2]=k[o>>2];k[j>>2]=k[p>>2];k[l>>2]=k[q>>2];k[m>>2]=k[r>>2];k[n>>2]=k[s>>2];k[c>>2]=z;z=t;k[z>>2]=x;k[z+4>>2]=y;k[o>>2]=A;k[p>>2]=f;k[q>>2]=e;k[r>>2]=g;k[s>>2]=d;d=v+2|0;g=a+4|0;e=i[u>>0]^1;f=i[g>>0]^1;if((e&255)>=(f&255)){if((f&255)<(e&255)){C=d;return C|0}if((k[u+4>>2]|0)>>>0>=(k[g+4>>2]|0)>>>0){C=d;return C|0}}x=k[a>>2]|0;w=g;t=k[w>>2]|0;w=k[w+4>>2]|0;p=a+12|0;y=k[p>>2]|0;q=a+16|0;z=k[q>>2]|0;r=a+20|0;A=k[r>>2]|0;s=a+24|0;B=k[s>>2]|0;c=a+28|0;C=k[c>>2]|0;k[a>>2]=k[b>>2];d=u;o=k[d+4>>2]|0;a=g;k[a>>2]=k[d>>2];k[a+4>>2]=o;k[p>>2]=k[h>>2];k[q>>2]=k[j>>2];k[r>>2]=k[l>>2];k[s>>2]=k[m>>2];k[c>>2]=k[n>>2];k[b>>2]=x;x=u;k[x>>2]=t;k[x+4>>2]=w;k[h>>2]=y;k[j>>2]=z;k[l>>2]=A;k[m>>2]=B;k[n>>2]=C;C=v+3|0;return C|0}function vb(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;var f=0,g=0,h=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0;v=ub(a,b,c,d)|0;h=e+4|0;p=d+4|0;f=i[h>>0]^1;g=i[p>>0]^1;if((f&255)>=(g&255)){if((g&255)<(f&255)){b=v;return b|0}if((k[h+4>>2]|0)>>>0>=(k[p+4>>2]|0)>>>0){b=v;return b|0}}B=k[d>>2]|0;z=p;A=k[z>>2]|0;z=k[z+4>>2]|0;j=d+12|0;y=k[j>>2]|0;l=d+16|0;w=k[l>>2]|0;m=d+20|0;r=k[m>>2]|0;n=d+24|0;t=k[n>>2]|0;o=d+28|0;u=k[o>>2]|0;k[d>>2]=k[e>>2];s=h;q=k[s+4>>2]|0;x=p;k[x>>2]=k[s>>2];k[x+4>>2]=q;x=e+12|0;k[j>>2]=k[x>>2];q=e+16|0;k[l>>2]=k[q>>2];s=e+20|0;k[m>>2]=k[s>>2];g=e+24|0;k[n>>2]=k[g>>2];f=e+28|0;k[o>>2]=k[f>>2];k[e>>2]=B;e=h;k[e>>2]=A;k[e+4>>2]=z;k[x>>2]=y;k[q>>2]=w;k[s>>2]=r;k[g>>2]=t;k[f>>2]=u;f=v+1|0;u=c+4|0;g=i[p>>0]^1;e=i[u>>0]^1;if((g&255)>=(e&255)){if((e&255)<(g&255)){B=f;return B|0}if((k[p+4>>2]|0)>>>0>=(k[u+4>>2]|0)>>>0){B=f;return B|0}}x=k[c>>2]|0;z=u;y=k[z>>2]|0;z=k[z+4>>2]|0;h=c+12|0;A=k[h>>2]|0;q=c+16|0;B=k[q>>2]|0;r=c+20|0;g=k[r>>2]|0;s=c+24|0;f=k[s>>2]|0;t=c+28|0;e=k[t>>2]|0;k[c>>2]=k[d>>2];D=p;C=k[D+4>>2]|0;w=u;k[w>>2]=k[D>>2];k[w+4>>2]=C;k[h>>2]=k[j>>2];k[q>>2]=k[l>>2];k[r>>2]=k[m>>2];k[s>>2]=k[n>>2];k[t>>2]=k[o>>2];k[d>>2]=x;d=p;k[d>>2]=y;k[d+4>>2]=z;k[j>>2]=A;k[l>>2]=B;k[m>>2]=g;k[n>>2]=f;k[o>>2]=e;e=v+2|0;d=b+4|0;f=i[u>>0]^1;g=i[d>>0]^1;if((f&255)>=(g&255)){if((g&255)<(f&255)){D=e;return D|0}if((k[u+4>>2]|0)>>>0>=(k[d+4>>2]|0)>>>0){D=e;return D|0}}B=k[b>>2]|0;A=d;z=k[A>>2]|0;A=k[A+4>>2]|0;j=b+12|0;C=k[j>>2]|0;l=b+16|0;D=k[l>>2]|0;m=b+20|0;e=k[m>>2]|0;n=b+24|0;g=k[n>>2]|0;o=b+28|0;f=k[o>>2]|0;k[b>>2]=k[c>>2];w=u;x=k[w+4>>2]|0;y=d;k[y>>2]=k[w>>2];k[y+4>>2]=x;k[j>>2]=k[h>>2];k[l>>2]=k[q>>2];k[m>>2]=k[r>>2];k[n>>2]=k[s>>2];k[o>>2]=k[t>>2];k[c>>2]=B;B=u;k[B>>2]=z;k[B+4>>2]=A;k[h>>2]=C;k[q>>2]=D;k[r>>2]=e;k[s>>2]=g;k[t>>2]=f;f=v+3|0;h=a+4|0;g=i[d>>0]^1;e=i[h>>0]^1;if((g&255)>=(e&255)){if((e&255)<(g&255)){D=f;return D|0}if((k[d+4>>2]|0)>>>0>=(k[h+4>>2]|0)>>>0){D=f;return D|0}}y=k[a>>2]|0;x=h;w=k[x>>2]|0;x=k[x+4>>2]|0;r=a+12|0;z=k[r>>2]|0;s=a+16|0;A=k[s>>2]|0;t=a+20|0;B=k[t>>2]|0;u=a+24|0;C=k[u>>2]|0;c=a+28|0;D=k[c>>2]|0;k[a>>2]=k[b>>2];p=d;q=k[p+4>>2]|0;a=h;k[a>>2]=k[p>>2];k[a+4>>2]=q;k[r>>2]=k[j>>2];k[s>>2]=k[l>>2];k[t>>2]=k[m>>2];k[u>>2]=k[n>>2];k[c>>2]=k[o>>2];k[b>>2]=y;y=d;k[y>>2]=w;k[y+4>>2]=x;k[j>>2]=z;k[l>>2]=A;k[m>>2]=B;k[n>>2]=C;k[o>>2]=D;D=v+4|0;return D|0}function wb(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0;switch(b-a>>5|0){case 2:{c=b+-32|0;f=b+-28|0;g=a+4|0;d=i[f>>0]^1;e=i[g>>0]^1;if((d&255)>=(e&255)){if((e&255)<(d&255)){b=1;return b|0}if((k[f+4>>2]|0)>>>0>=(k[g+4>>2]|0)>>>0){b=1;return b|0}}r=k[a>>2]|0;q=g;p=k[q>>2]|0;q=k[q+4>>2]|0;v=a+12|0;s=k[v>>2]|0;x=a+16|0;u=k[x>>2]|0;m=a+20|0;w=k[m>>2]|0;n=a+24|0;y=k[n>>2]|0;o=a+28|0;z=k[o>>2]|0;k[a>>2]=k[c>>2];l=f;a=k[l+4>>2]|0;t=g;k[t>>2]=k[l>>2];k[t+4>>2]=a;t=b+-20|0;k[v>>2]=k[t>>2];v=b+-16|0;k[x>>2]=k[v>>2];x=b+-12|0;k[m>>2]=k[x>>2];a=b+-8|0;k[n>>2]=k[a>>2];b=b+-4|0;k[o>>2]=k[b>>2];k[c>>2]=r;r=f;k[r>>2]=p;k[r+4>>2]=q;k[t>>2]=s;k[v>>2]=u;k[x>>2]=w;k[a>>2]=y;k[b>>2]=z;b=1;return b|0}case 3:{tb(a,a+32|0,b+-32|0)|0;b=1;return b|0}case 4:{ub(a,a+32|0,a+64|0,b+-32|0)|0;b=1;return b|0}case 5:{vb(a,a+32|0,a+64|0,a+96|0,b+-32|0)|0;b=1;return b|0}case 1:case 0:{b=1;return b|0}default:{e=a+64|0;tb(a,a+32|0,e)|0;d=a+96|0;if((d|0)==(b|0)){b=1;return b|0}else c=0;while(1){h=d+4|0;j=e+4|0;f=i[h>>0]^1;g=i[j>>0]^1;if((f&255)>=(g&255)){if((g&255)>=(f&255)?(k[h+4>>2]|0)>>>0<(k[j+4>>2]|0)>>>0:0)z=13}else z=13;if((z|0)==13){z=0;r=k[d>>2]|0;t=h;s=k[t>>2]|0;t=k[t+4>>2]|0;m=d+12|0;u=k[m>>2]|0;p=d+16|0;v=k[p>>2]|0;g=d+20|0;w=k[g>>2]|0;f=d+24|0;x=k[f>>2]|0;q=d+28|0;y=k[q>>2]|0;k[d>>2]=k[e>>2];n=j;o=k[n+4>>2]|0;l=h;k[l>>2]=k[n>>2];k[l+4>>2]=o;l=e+12|0;k[m>>2]=k[l>>2];m=e+16|0;k[p>>2]=k[m>>2];h=e+20|0;k[g>>2]=k[h>>2];g=e+24|0;k[f>>2]=k[g>>2];f=e+28|0;k[q>>2]=k[f>>2];a:do if((e|0)!=(a|0)){q=s&255^1;p=e;o=h;while(1){e=p+-32|0;n=p+-28|0;h=i[n>>0]^1;if((q&255)>=(h&255)){if((h&255)<(q&255)){e=p;h=o;break a}if(t>>>0>=(k[p+-24>>2]|0)>>>0){e=p;h=o;break a}}k[p>>2]=k[e>>2];h=n;m=k[h+4>>2]|0;l=p+4|0;k[l>>2]=k[h>>2];k[l+4>>2]=m;l=p+-20|0;k[p+12>>2]=k[l>>2];m=p+-16|0;k[p+16>>2]=k[m>>2];h=p+-12|0;k[p+20>>2]=k[h>>2];g=p+-8|0;k[p+24>>2]=k[g>>2];f=p+-4|0;k[p+28>>2]=k[f>>2];if((e|0)==(a|0)){j=n;break}else{p=e;o=h;j=n}}}while(0);k[e>>2]=r;r=j;k[r>>2]=s;k[r+4>>2]=t;k[l>>2]=u;k[m>>2]=v;k[h>>2]=w;k[g>>2]=x;k[f>>2]=y;c=c+1|0;if((c|0)==8)break}e=d+32|0;if((e|0)==(b|0)){c=1;z=22;break}else{y=d;d=e;e=y}}if((z|0)==22)return c|0;b=(d+32|0)==(b|0);return b|0}}return 0}function xb(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;var f=0,g=0,h=0,l=0;h=r;r=r+32|0;g=h;l=Za[k[e>>2]&7](b,a)|0;f=Za[k[e>>2]&7](c,b)|0;do if(l){k[g>>2]=k[a>>2];k[g+4>>2]=k[a+4>>2];k[g+8>>2]=k[a+8>>2];k[g+12>>2]=k[a+12>>2];k[g+16>>2]=k[a+16>>2];k[g+20>>2]=k[a+20>>2];k[g+24>>2]=k[a+24>>2];k[g+28>>2]=k[a+28>>2];if(f){k[a>>2]=k[c>>2];k[a+4>>2]=k[c+4>>2];k[a+8>>2]=k[c+8>>2];k[a+12>>2]=k[c+12>>2];k[a+16>>2]=k[c+16>>2];k[a+20>>2]=k[c+20>>2];j[a+24>>1]=j[c+24>>1]|0;i[a+26>>0]=i[c+26>>0]|0;k[c>>2]=k[g>>2];k[c+4>>2]=k[g+4>>2];k[c+8>>2]=k[g+8>>2];k[c+12>>2]=k[g+12>>2];k[c+16>>2]=k[g+16>>2];k[c+20>>2]=k[g+20>>2];j[c+24>>1]=j[g+24>>1]|0;i[c+26>>0]=i[g+26>>0]|0;f=1;break};k[a>>2]=k[b>>2];k[a+4>>2]=k[b+4>>2];k[a+8>>2]=k[b+8>>2];k[a+12>>2]=k[b+12>>2];k[a+16>>2]=k[b+16>>2];k[a+20>>2]=k[b+20>>2];j[a+24>>1]=j[b+24>>1]|0;i[a+26>>0]=i[b+26>>0]|0;k[b>>2]=k[g>>2];k[b+4>>2]=k[g+4>>2];k[b+8>>2]=k[g+8>>2];k[b+12>>2]=k[g+12>>2];k[b+16>>2]=k[g+16>>2];k[b+20>>2]=k[g+20>>2];j[b+24>>1]=j[g+24>>1]|0;i[b+26>>0]=i[g+26>>0]|0;if(Za[k[e>>2]&7](c,b)|0){k[g>>2]=k[b>>2];k[g+4>>2]=k[b+4>>2];k[g+8>>2]=k[b+8>>2];k[g+12>>2]=k[b+12>>2];k[g+16>>2]=k[b+16>>2];k[g+20>>2]=k[b+20>>2];k[g+24>>2]=k[b+24>>2];k[g+28>>2]=k[b+28>>2];k[b>>2]=k[c>>2];k[b+4>>2]=k[c+4>>2];k[b+8>>2]=k[c+8>>2];k[b+12>>2]=k[c+12>>2];k[b+16>>2]=k[c+16>>2];k[b+20>>2]=k[c+20>>2];j[b+24>>1]=j[c+24>>1]|0;i[b+26>>0]=i[c+26>>0]|0;k[c>>2]=k[g>>2];k[c+4>>2]=k[g+4>>2];k[c+8>>2]=k[g+8>>2];k[c+12>>2]=k[g+12>>2];k[c+16>>2]=k[g+16>>2];k[c+20>>2]=k[g+20>>2];j[c+24>>1]=j[g+24>>1]|0;i[c+26>>0]=i[g+26>>0]|0;f=2}else f=1}else if(f){k[g>>2]=k[b>>2];k[g+4>>2]=k[b+4>>2];k[g+8>>2]=k[b+8>>2];k[g+12>>2]=k[b+12>>2];k[g+16>>2]=k[b+16>>2];k[g+20>>2]=k[b+20>>2];k[g+24>>2]=k[b+24>>2];k[g+28>>2]=k[b+28>>2];k[b>>2]=k[c>>2];k[b+4>>2]=k[c+4>>2];k[b+8>>2]=k[c+8>>2];k[b+12>>2]=k[c+12>>2];k[b+16>>2]=k[c+16>>2];k[b+20>>2]=k[c+20>>2];j[b+24>>1]=j[c+24>>1]|0;i[b+26>>0]=i[c+26>>0]|0;k[c>>2]=k[g>>2];k[c+4>>2]=k[g+4>>2];k[c+8>>2]=k[g+8>>2];k[c+12>>2]=k[g+12>>2];k[c+16>>2]=k[g+16>>2];k[c+20>>2]=k[g+20>>2];j[c+24>>1]=j[g+24>>1]|0;i[c+26>>0]=i[g+26>>0]|0;if(Za[k[e>>2]&7](b,a)|0){k[g>>2]=k[a>>2];k[g+4>>2]=k[a+4>>2];k[g+8>>2]=k[a+8>>2];k[g+12>>2]=k[a+12>>2];k[g+16>>2]=k[a+16>>2];k[g+20>>2]=k[a+20>>2];k[g+24>>2]=k[a+24>>2];k[g+28>>2]=k[a+28>>2];k[a>>2]=k[b>>2];k[a+4>>2]=k[b+4>>2];k[a+8>>2]=k[b+8>>2];k[a+12>>2]=k[b+12>>2];k[a+16>>2]=k[b+16>>2];k[a+20>>2]=k[b+20>>2];j[a+24>>1]=j[b+24>>1]|0;i[a+26>>0]=i[b+26>>0]|0;k[b>>2]=k[g>>2];k[b+4>>2]=k[g+4>>2];k[b+8>>2]=k[g+8>>2];k[b+12>>2]=k[g+12>>2];k[b+16>>2]=k[g+16>>2];k[b+20>>2]=k[g+20>>2];j[b+24>>1]=j[g+24>>1]|0;i[b+26>>0]=i[g+26>>0]|0;f=2}else f=1}else f=0;while(0);if(!(Za[k[e>>2]&7](d,c)|0)){l=f;r=h;return l|0};k[g>>2]=k[c>>2];k[g+4>>2]=k[c+4>>2];k[g+8>>2]=k[c+8>>2];k[g+12>>2]=k[c+12>>2];k[g+16>>2]=k[c+16>>2];k[g+20>>2]=k[c+20>>2];k[g+24>>2]=k[c+24>>2];k[g+28>>2]=k[c+28>>2];k[c>>2]=k[d>>2];k[c+4>>2]=k[d+4>>2];k[c+8>>2]=k[d+8>>2];k[c+12>>2]=k[d+12>>2];k[c+16>>2]=k[d+16>>2];k[c+20>>2]=k[d+20>>2];j[c+24>>1]=j[d+24>>1]|0;i[c+26>>0]=i[d+26>>0]|0;k[d>>2]=k[g>>2];k[d+4>>2]=k[g+4>>2];k[d+8>>2]=k[g+8>>2];k[d+12>>2]=k[g+12>>2];k[d+16>>2]=k[g+16>>2];k[d+20>>2]=k[g+20>>2];j[d+24>>1]=j[g+24>>1]|0;i[d+26>>0]=i[g+26>>0]|0;if(!(Za[k[e>>2]&7](c,b)|0)){l=f+1|0;r=h;return l|0};k[g>>2]=k[b>>2];k[g+4>>2]=k[b+4>>2];k[g+8>>2]=k[b+8>>2];k[g+12>>2]=k[b+12>>2];k[g+16>>2]=k[b+16>>2];k[g+20>>2]=k[b+20>>2];k[g+24>>2]=k[b+24>>2];k[g+28>>2]=k[b+28>>2];k[b>>2]=k[c>>2];k[b+4>>2]=k[c+4>>2];k[b+8>>2]=k[c+8>>2];k[b+12>>2]=k[c+12>>2];k[b+16>>2]=k[c+16>>2];k[b+20>>2]=k[c+20>>2];j[b+24>>1]=j[c+24>>1]|0;i[b+26>>0]=i[c+26>>0]|0;k[c>>2]=k[g>>2];k[c+4>>2]=k[g+4>>2];k[c+8>>2]=k[g+8>>2];k[c+12>>2]=k[g+12>>2];k[c+16>>2]=k[g+16>>2];k[c+20>>2]=k[g+20>>2];j[c+24>>1]=j[g+24>>1]|0;i[c+26>>0]=i[g+26>>0]|0;if(!(Za[k[e>>2]&7](b,a)|0)){l=f+2|0;r=h;return l|0};k[g>>2]=k[a>>2];k[g+4>>2]=k[a+4>>2];k[g+8>>2]=k[a+8>>2];k[g+12>>2]=k[a+12>>2];k[g+16>>2]=k[a+16>>2];k[g+20>>2]=k[a+20>>2];k[g+24>>2]=k[a+24>>2];k[g+28>>2]=k[a+28>>2];k[a>>2]=k[b>>2];k[a+4>>2]=k[b+4>>2];k[a+8>>2]=k[b+8>>2];k[a+12>>2]=k[b+12>>2];k[a+16>>2]=k[b+16>>2];k[a+20>>2]=k[b+20>>2];j[a+24>>1]=j[b+24>>1]|0;i[a+26>>0]=i[b+26>>0]|0;k[b>>2]=k[g>>2];k[b+4>>2]=k[g+4>>2];k[b+8>>2]=k[g+8>>2];k[b+12>>2]=k[g+12>>2];k[b+16>>2]=k[g+16>>2];k[b+20>>2]=k[g+20>>2];j[b+24>>1]=j[g+24>>1]|0;i[b+26>>0]=i[g+26>>0]|0;l=f+3|0;r=h;return l|0}function yb(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0,l=0,m=0,n=0;n=r;r=r+64|0;h=n+32|0;l=n;switch(b-a>>5|0){case 2:{d=b+-32|0;if(!(Za[k[c>>2]&7](d,a)|0)){a=1;r=n;return a|0};k[h>>2]=k[a>>2];k[h+4>>2]=k[a+4>>2];k[h+8>>2]=k[a+8>>2];k[h+12>>2]=k[a+12>>2];k[h+16>>2]=k[a+16>>2];k[h+20>>2]=k[a+20>>2];k[h+24>>2]=k[a+24>>2];k[h+28>>2]=k[a+28>>2];k[a>>2]=k[d>>2];k[a+4>>2]=k[d+4>>2];k[a+8>>2]=k[d+8>>2];k[a+12>>2]=k[d+12>>2];k[a+16>>2]=k[d+16>>2];k[a+20>>2]=k[d+20>>2];j[a+24>>1]=j[d+24>>1]|0;i[a+26>>0]=i[d+26>>0]|0;k[d>>2]=k[h>>2];k[d+4>>2]=k[h+4>>2];k[d+8>>2]=k[h+8>>2];k[d+12>>2]=k[h+12>>2];k[d+16>>2]=k[h+16>>2];k[d+20>>2]=k[h+20>>2];j[d+24>>1]=j[h+24>>1]|0;i[d+26>>0]=i[h+26>>0]|0;a=1;r=n;return a|0}case 3:{f=a+32|0;e=b+-32|0;b=Za[k[c>>2]&7](f,a)|0;d=Za[k[c>>2]&7](e,f)|0;if(!b){if(!d){a=1;r=n;return a|0};k[h>>2]=k[f>>2];k[h+4>>2]=k[f+4>>2];k[h+8>>2]=k[f+8>>2];k[h+12>>2]=k[f+12>>2];k[h+16>>2]=k[f+16>>2];k[h+20>>2]=k[f+20>>2];k[h+24>>2]=k[f+24>>2];k[h+28>>2]=k[f+28>>2];k[f>>2]=k[e>>2];k[f+4>>2]=k[e+4>>2];k[f+8>>2]=k[e+8>>2];k[f+12>>2]=k[e+12>>2];k[f+16>>2]=k[e+16>>2];k[f+20>>2]=k[e+20>>2];j[f+24>>1]=j[e+24>>1]|0;i[f+26>>0]=i[e+26>>0]|0;k[e>>2]=k[h>>2];k[e+4>>2]=k[h+4>>2];k[e+8>>2]=k[h+8>>2];k[e+12>>2]=k[h+12>>2];k[e+16>>2]=k[h+16>>2];k[e+20>>2]=k[h+20>>2];j[e+24>>1]=j[h+24>>1]|0;i[e+26>>0]=i[h+26>>0]|0;if(!(Za[k[c>>2]&7](f,a)|0)){a=1;r=n;return a|0};k[h>>2]=k[a>>2];k[h+4>>2]=k[a+4>>2];k[h+8>>2]=k[a+8>>2];k[h+12>>2]=k[a+12>>2];k[h+16>>2]=k[a+16>>2];k[h+20>>2]=k[a+20>>2];k[h+24>>2]=k[a+24>>2];k[h+28>>2]=k[a+28>>2];k[a>>2]=k[f>>2];k[a+4>>2]=k[f+4>>2];k[a+8>>2]=k[f+8>>2];k[a+12>>2]=k[f+12>>2];k[a+16>>2]=k[f+16>>2];k[a+20>>2]=k[f+20>>2];j[a+24>>1]=j[f+24>>1]|0;i[a+26>>0]=i[f+26>>0]|0;k[f>>2]=k[h>>2];k[f+4>>2]=k[h+4>>2];k[f+8>>2]=k[h+8>>2];k[f+12>>2]=k[h+12>>2];k[f+16>>2]=k[h+16>>2];k[f+20>>2]=k[h+20>>2];j[f+24>>1]=j[h+24>>1]|0;i[f+26>>0]=i[h+26>>0]|0;a=1;r=n;return a|0};k[h>>2]=k[a>>2];k[h+4>>2]=k[a+4>>2];k[h+8>>2]=k[a+8>>2];k[h+12>>2]=k[a+12>>2];k[h+16>>2]=k[a+16>>2];k[h+20>>2]=k[a+20>>2];k[h+24>>2]=k[a+24>>2];k[h+28>>2]=k[a+28>>2];if(d){k[a>>2]=k[e>>2];k[a+4>>2]=k[e+4>>2];k[a+8>>2]=k[e+8>>2];k[a+12>>2]=k[e+12>>2];k[a+16>>2]=k[e+16>>2];k[a+20>>2]=k[e+20>>2];j[a+24>>1]=j[e+24>>1]|0;i[a+26>>0]=i[e+26>>0]|0;k[e>>2]=k[h>>2];k[e+4>>2]=k[h+4>>2];k[e+8>>2]=k[h+8>>2];k[e+12>>2]=k[h+12>>2];k[e+16>>2]=k[h+16>>2];k[e+20>>2]=k[h+20>>2];j[e+24>>1]=j[h+24>>1]|0;i[e+26>>0]=i[h+26>>0]|0;a=1;r=n;return a|0};k[a>>2]=k[f>>2];k[a+4>>2]=k[f+4>>2];k[a+8>>2]=k[f+8>>2];k[a+12>>2]=k[f+12>>2];k[a+16>>2]=k[f+16>>2];k[a+20>>2]=k[f+20>>2];j[a+24>>1]=j[f+24>>1]|0;i[a+26>>0]=i[f+26>>0]|0;k[f>>2]=k[h>>2];k[f+4>>2]=k[h+4>>2];k[f+8>>2]=k[h+8>>2];k[f+12>>2]=k[h+12>>2];k[f+16>>2]=k[h+16>>2];k[f+20>>2]=k[h+20>>2];j[f+24>>1]=j[h+24>>1]|0;i[f+26>>0]=i[h+26>>0]|0;if(!(Za[k[c>>2]&7](e,f)|0)){a=1;r=n;return a|0};k[h>>2]=k[f>>2];k[h+4>>2]=k[f+4>>2];k[h+8>>2]=k[f+8>>2];k[h+12>>2]=k[f+12>>2];k[h+16>>2]=k[f+16>>2];k[h+20>>2]=k[f+20>>2];k[h+24>>2]=k[f+24>>2];k[h+28>>2]=k[f+28>>2];k[f>>2]=k[e>>2];k[f+4>>2]=k[e+4>>2];k[f+8>>2]=k[e+8>>2];k[f+12>>2]=k[e+12>>2];k[f+16>>2]=k[e+16>>2];k[f+20>>2]=k[e+20>>2];j[f+24>>1]=j[e+24>>1]|0;i[f+26>>0]=i[e+26>>0]|0;k[e>>2]=k[h>>2];k[e+4>>2]=k[h+4>>2];k[e+8>>2]=k[h+8>>2];k[e+12>>2]=k[h+12>>2];k[e+16>>2]=k[h+16>>2];k[e+20>>2]=k[h+20>>2];j[e+24>>1]=j[h+24>>1]|0;i[e+26>>0]=i[h+26>>0]|0;a=1;r=n;return a|0}case 4:{xb(a,a+32|0,a+64|0,b+-32|0,c)|0;a=1;r=n;return a|0}case 5:{e=a+32|0;f=a+64|0;g=a+96|0;d=b+-32|0;xb(a,e,f,g,c)|0;if(!(Za[k[c>>2]&7](d,g)|0)){a=1;r=n;return a|0};k[h>>2]=k[g>>2];k[h+4>>2]=k[g+4>>2];k[h+8>>2]=k[g+8>>2];k[h+12>>2]=k[g+12>>2];k[h+16>>2]=k[g+16>>2];k[h+20>>2]=k[g+20>>2];k[h+24>>2]=k[g+24>>2];k[h+28>>2]=k[g+28>>2];k[g>>2]=k[d>>2];k[g+4>>2]=k[d+4>>2];k[g+8>>2]=k[d+8>>2];k[g+12>>2]=k[d+12>>2];k[g+16>>2]=k[d+16>>2];k[g+20>>2]=k[d+20>>2];j[g+24>>1]=j[d+24>>1]|0;i[g+26>>0]=i[d+26>>0]|0;k[d>>2]=k[h>>2];k[d+4>>2]=k[h+4>>2];k[d+8>>2]=k[h+8>>2];k[d+12>>2]=k[h+12>>2];k[d+16>>2]=k[h+16>>2];k[d+20>>2]=k[h+20>>2];j[d+24>>1]=j[h+24>>1]|0;i[d+26>>0]=i[h+26>>0]|0;if(!(Za[k[c>>2]&7](g,f)|0)){a=1;r=n;return a|0};k[h>>2]=k[f>>2];k[h+4>>2]=k[f+4>>2];k[h+8>>2]=k[f+8>>2];k[h+12>>2]=k[f+12>>2];k[h+16>>2]=k[f+16>>2];k[h+20>>2]=k[f+20>>2];k[h+24>>2]=k[f+24>>2];k[h+28>>2]=k[f+28>>2];k[f>>2]=k[g>>2];k[f+4>>2]=k[g+4>>2];k[f+8>>2]=k[g+8>>2];k[f+12>>2]=k[g+12>>2];k[f+16>>2]=k[g+16>>2];k[f+20>>2]=k[g+20>>2];j[f+24>>1]=j[g+24>>1]|0;i[f+26>>0]=i[g+26>>0]|0;k[g>>2]=k[h>>2];k[g+4>>2]=k[h+4>>2];k[g+8>>2]=k[h+8>>2];k[g+12>>2]=k[h+12>>2];k[g+16>>2]=k[h+16>>2];k[g+20>>2]=k[h+20>>2];j[g+24>>1]=j[h+24>>1]|0;i[g+26>>0]=i[h+26>>0]|0;if(!(Za[k[c>>2]&7](f,e)|0)){a=1;r=n;return a|0};k[h>>2]=k[e>>2];k[h+4>>2]=k[e+4>>2];k[h+8>>2]=k[e+8>>2];k[h+12>>2]=k[e+12>>2];k[h+16>>2]=k[e+16>>2];k[h+20>>2]=k[e+20>>2];k[h+24>>2]=k[e+24>>2];k[h+28>>2]=k[e+28>>2];k[e>>2]=k[f>>2];k[e+4>>2]=k[f+4>>2];k[e+8>>2]=k[f+8>>2];k[e+12>>2]=k[f+12>>2];k[e+16>>2]=k[f+16>>2];k[e+20>>2]=k[f+20>>2];j[e+24>>1]=j[f+24>>1]|0;i[e+26>>0]=i[f+26>>0]|0;k[f>>2]=k[h>>2];k[f+4>>2]=k[h+4>>2];k[f+8>>2]=k[h+8>>2];k[f+12>>2]=k[h+12>>2];k[f+16>>2]=k[h+16>>2];k[f+20>>2]=k[h+20>>2];j[f+24>>1]=j[h+24>>1]|0;i[f+26>>0]=i[h+26>>0]|0;if(!(Za[k[c>>2]&7](e,a)|0)){a=1;r=n;return a|0};k[h>>2]=k[a>>2];k[h+4>>2]=k[a+4>>2];k[h+8>>2]=k[a+8>>2];k[h+12>>2]=k[a+12>>2];k[h+16>>2]=k[a+16>>2];k[h+20>>2]=k[a+20>>2];k[h+24>>2]=k[a+24>>2];k[h+28>>2]=k[a+28>>2];k[a>>2]=k[e>>2];k[a+4>>2]=k[e+4>>2];k[a+8>>2]=k[e+8>>2];k[a+12>>2]=k[e+12>>2];k[a+16>>2]=k[e+16>>2];k[a+20>>2]=k[e+20>>2];j[a+24>>1]=j[e+24>>1]|0;i[a+26>>0]=i[e+26>>0]|0;k[e>>2]=k[h>>2];k[e+4>>2]=k[h+4>>2];k[e+8>>2]=k[h+8>>2];k[e+12>>2]=k[h+12>>2];k[e+16>>2]=k[h+16>>2];k[e+20>>2]=k[h+20>>2];j[e+24>>1]=j[h+24>>1]|0;i[e+26>>0]=i[h+26>>0]|0;a=1;r=n;return a|0}case 1:case 0:{a=1;r=n;return a|0}default:{f=a+64|0;d=a+32|0;g=Za[k[c>>2]&7](d,a)|0;e=Za[k[c>>2]&7](f,d)|0;do if(g){k[h>>2]=k[a>>2];k[h+4>>2]=k[a+4>>2];k[h+8>>2]=k[a+8>>2];k[h+12>>2]=k[a+12>>2];k[h+16>>2]=k[a+16>>2];k[h+20>>2]=k[a+20>>2];k[h+24>>2]=k[a+24>>2];k[h+28>>2]=k[a+28>>2];if(e){k[a>>2]=k[f>>2];k[a+4>>2]=k[f+4>>2];k[a+8>>2]=k[f+8>>2];k[a+12>>2]=k[f+12>>2];k[a+16>>2]=k[f+16>>2];k[a+20>>2]=k[f+20>>2];j[a+24>>1]=j[f+24>>1]|0;i[a+26>>0]=i[f+26>>0]|0;k[f>>2]=k[h>>2];k[f+4>>2]=k[h+4>>2];k[f+8>>2]=k[h+8>>2];k[f+12>>2]=k[h+12>>2];k[f+16>>2]=k[h+16>>2];k[f+20>>2]=k[h+20>>2];j[f+24>>1]=j[h+24>>1]|0;i[f+26>>0]=i[h+26>>0]|0;break};k[a>>2]=k[d>>2];k[a+4>>2]=k[d+4>>2];k[a+8>>2]=k[d+8>>2];k[a+12>>2]=k[d+12>>2];k[a+16>>2]=k[d+16>>2];k[a+20>>2]=k[d+20>>2];j[a+24>>1]=j[d+24>>1]|0;i[a+26>>0]=i[d+26>>0]|0;k[d>>2]=k[h>>2];k[d+4>>2]=k[h+4>>2];k[d+8>>2]=k[h+8>>2];k[d+12>>2]=k[h+12>>2];k[d+16>>2]=k[h+16>>2];k[d+20>>2]=k[h+20>>2];j[d+24>>1]=j[h+24>>1]|0;i[d+26>>0]=i[h+26>>0]|0;if(Za[k[c>>2]&7](f,d)|0){k[h>>2]=k[d>>2];k[h+4>>2]=k[d+4>>2];k[h+8>>2]=k[d+8>>2];k[h+12>>2]=k[d+12>>2];k[h+16>>2]=k[d+16>>2];k[h+20>>2]=k[d+20>>2];k[h+24>>2]=k[d+24>>2];k[h+28>>2]=k[d+28>>2];k[d>>2]=k[f>>2];k[d+4>>2]=k[f+4>>2];k[d+8>>2]=k[f+8>>2];k[d+12>>2]=k[f+12>>2];k[d+16>>2]=k[f+16>>2];k[d+20>>2]=k[f+20>>2];j[d+24>>1]=j[f+24>>1]|0;i[d+26>>0]=i[f+26>>0]|0;k[f>>2]=k[h>>2];k[f+4>>2]=k[h+4>>2];k[f+8>>2]=k[h+8>>2];k[f+12>>2]=k[h+12>>2];k[f+16>>2]=k[h+16>>2];k[f+20>>2]=k[h+20>>2];j[f+24>>1]=j[h+24>>1]|0;i[f+26>>0]=i[h+26>>0]|0}}else if(e?(k[h>>2]=k[d>>2],k[h+4>>2]=k[d+4>>2],k[h+8>>2]=k[d+8>>2],k[h+12>>2]=k[d+12>>2],k[h+16>>2]=k[d+16>>2],k[h+20>>2]=k[d+20>>2],k[h+24>>2]=k[d+24>>2],k[h+28>>2]=k[d+28>>2],k[d>>2]=k[f>>2],k[d+4>>2]=k[f+4>>2],k[d+8>>2]=k[f+8>>2],k[d+12>>2]=k[f+12>>2],k[d+16>>2]=k[f+16>>2],k[d+20>>2]=k[f+20>>2],j[d+24>>1]=j[f+24>>1]|0,i[d+26>>0]=i[f+26>>0]|0,k[f>>2]=k[h>>2],k[f+4>>2]=k[h+4>>2],k[f+8>>2]=k[h+8>>2],k[f+12>>2]=k[h+12>>2],k[f+16>>2]=k[h+16>>2],k[f+20>>2]=k[h+20>>2],j[f+24>>1]=j[h+24>>1]|0,i[f+26>>0]=i[h+26>>0]|0,Za[k[c>>2]&7](d,a)|0):0){k[h>>2]=k[a>>2];k[h+4>>2]=k[a+4>>2];k[h+8>>2]=k[a+8>>2];k[h+12>>2]=k[a+12>>2];k[h+16>>2]=k[a+16>>2];k[h+20>>2]=k[a+20>>2];k[h+24>>2]=k[a+24>>2];k[h+28>>2]=k[a+28>>2];k[a>>2]=k[d>>2];k[a+4>>2]=k[d+4>>2];k[a+8>>2]=k[d+8>>2];k[a+12>>2]=k[d+12>>2];k[a+16>>2]=k[d+16>>2];k[a+20>>2]=k[d+20>>2];j[a+24>>1]=j[d+24>>1]|0;i[a+26>>0]=i[d+26>>0]|0;k[d>>2]=k[h>>2];k[d+4>>2]=k[h+4>>2];k[d+8>>2]=k[h+8>>2];k[d+12>>2]=k[h+12>>2];k[d+16>>2]=k[h+16>>2];k[d+20>>2]=k[h+20>>2];j[d+24>>1]=j[h+24>>1]|0;i[d+26>>0]=i[h+26>>0]|0}while(0);e=a+96|0;if((e|0)==(b|0)){a=1;r=n;return a|0}d=0;while(1){if(Za[k[c>>2]&7](e,f)|0){k[l>>2]=k[e>>2];k[l+4>>2]=k[e+4>>2];k[l+8>>2]=k[e+8>>2];k[l+12>>2]=k[e+12>>2];k[l+16>>2]=k[e+16>>2];k[l+20>>2]=k[e+20>>2];k[l+24>>2]=k[e+24>>2];k[l+28>>2]=k[e+28>>2];g=e;h=f;while(1){k[g>>2]=k[h>>2];k[g+4>>2]=k[h+4>>2];k[g+8>>2]=k[h+8>>2];k[g+12>>2]=k[h+12>>2];k[g+16>>2]=k[h+16>>2];k[g+20>>2]=k[h+20>>2];j[g+24>>1]=j[h+24>>1]|0;i[g+26>>0]=i[h+26>>0]|0;if((h|0)==(a|0))break;f=h+-32|0;if(Za[k[c>>2]&7](l,f)|0){g=h;h=f}else break}k[h>>2]=k[l>>2];k[h+4>>2]=k[l+4>>2];k[h+8>>2]=k[l+8>>2];k[h+12>>2]=k[l+12>>2];k[h+16>>2]=k[l+16>>2];k[h+20>>2]=k[l+20>>2];j[h+24>>1]=j[l+24>>1]|0;i[h+26>>0]=i[l+26>>0]|0;d=d+1|0;if((d|0)==8)break}f=e+32|0;if((f|0)==(b|0)){d=1;m=35;break}else{h=e;e=f;f=h}}if((m|0)==35){r=n;return d|0}a=(e+32|0)==(b|0);r=n;return a|0}}return 0}function zb(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0;v=Za[k[d>>2]&7](b,a)|0;e=Za[k[d>>2]&7](c,b)|0;if(!v){if(!e){c=0;return c|0}y=k[b>>2]|0;j=b+4|0;l=j;w=k[l>>2]|0;l=k[l+4>>2]|0;e=b+12|0;m=k[e>>2]|0;f=b+16|0;o=k[f>>2]|0;g=b+20|0;q=k[g>>2]|0;h=b+24|0;s=k[h>>2]|0;i=b+28|0;u=k[i>>2]|0;k[b>>2]=k[c>>2];x=c+4|0;r=x;p=k[r+4>>2]|0;n=j;k[n>>2]=k[r>>2];k[n+4>>2]=p;n=c+12|0;k[e>>2]=k[n>>2];p=c+16|0;k[f>>2]=k[p>>2];r=c+20|0;k[g>>2]=k[r>>2];t=c+24|0;k[h>>2]=k[t>>2];v=c+28|0;k[i>>2]=k[v>>2];k[c>>2]=y;c=x;k[c>>2]=w;k[c+4>>2]=l;k[n>>2]=m;k[p>>2]=o;k[r>>2]=q;k[t>>2]=s;k[v>>2]=u;if(!(Za[k[d>>2]&7](b,a)|0)){y=1;return y|0}t=k[a>>2]|0;n=a+4|0;v=n;u=k[v>>2]|0;v=k[v+4>>2]|0;o=a+12|0;d=k[o>>2]|0;p=a+16|0;c=k[p>>2]|0;q=a+20|0;w=k[q>>2]|0;r=a+24|0;x=k[r>>2]|0;s=a+28|0;y=k[s>>2]|0;k[a>>2]=k[b>>2];a=j;m=k[a+4>>2]|0;k[n>>2]=k[a>>2];k[n+4>>2]=m;k[o>>2]=k[e>>2];k[p>>2]=k[f>>2];k[q>>2]=k[g>>2];k[r>>2]=k[h>>2];k[s>>2]=k[i>>2];k[b>>2]=t;b=j;k[b>>2]=u;k[b+4>>2]=v;k[e>>2]=d;k[f>>2]=c;k[g>>2]=w;k[h>>2]=x;k[i>>2]=y;y=2;return y|0}r=k[a>>2]|0;f=a+4|0;t=f;s=k[t>>2]|0;t=k[t+4>>2]|0;g=a+12|0;u=k[g>>2]|0;j=a+16|0;v=k[j>>2]|0;l=a+20|0;n=k[l>>2]|0;m=a+24|0;o=k[m>>2]|0;p=a+28|0;q=k[p>>2]|0;if(e){k[a>>2]=k[c>>2];a=c+4|0;w=a;b=k[w+4>>2]|0;d=f;k[d>>2]=k[w>>2];k[d+4>>2]=b;d=c+12|0;k[g>>2]=k[d>>2];b=c+16|0;k[j>>2]=k[b>>2];w=c+20|0;k[l>>2]=k[w>>2];x=c+24|0;k[m>>2]=k[x>>2];y=c+28|0;k[p>>2]=k[y>>2];k[c>>2]=r;c=a;k[c>>2]=s;k[c+4>>2]=t;k[d>>2]=u;k[b>>2]=v;k[w>>2]=n;k[x>>2]=o;k[y>>2]=q;y=1;return y|0}k[a>>2]=k[b>>2];a=b+4|0;e=a;h=k[e+4>>2]|0;i=f;k[i>>2]=k[e>>2];k[i+4>>2]=h;i=b+12|0;k[g>>2]=k[i>>2];h=b+16|0;k[j>>2]=k[h>>2];g=b+20|0;k[l>>2]=k[g>>2];f=b+24|0;k[m>>2]=k[f>>2];e=b+28|0;k[p>>2]=k[e>>2];k[b>>2]=r;y=a;k[y>>2]=s;k[y+4>>2]=t;k[i>>2]=u;k[h>>2]=v;k[g>>2]=n;k[f>>2]=o;k[e>>2]=q;if(!(Za[k[d>>2]&7](c,b)|0)){y=1;return y|0}n=k[b>>2]|0;q=a;p=k[q>>2]|0;q=k[q+4>>2]|0;r=k[i>>2]|0;t=k[h>>2]|0;v=k[g>>2]|0;d=k[f>>2]|0;x=k[e>>2]|0;k[b>>2]=k[c>>2];o=c+4|0;b=o;u=k[b+4>>2]|0;s=a;k[s>>2]=k[b>>2];k[s+4>>2]=u;s=c+12|0;k[i>>2]=k[s>>2];u=c+16|0;k[h>>2]=k[u>>2];b=c+20|0;k[g>>2]=k[b>>2];w=c+24|0;k[f>>2]=k[w>>2];y=c+28|0;k[e>>2]=k[y>>2];k[c>>2]=n;c=o;k[c>>2]=p;k[c+4>>2]=q;k[s>>2]=r;k[u>>2]=t;k[b>>2]=v;k[w>>2]=d;k[y>>2]=x;y=2;return y|0}function Ab(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0;l=zb(a,b,c,e)|0;if(!(Za[k[e>>2]&7](d,c)|0)){c=l;return c|0}A=k[c>>2]|0;r=c+4|0;x=r;y=k[x>>2]|0;x=k[x+4>>2]|0;m=c+12|0;w=k[m>>2]|0;n=c+16|0;u=k[n>>2]|0;o=c+20|0;s=k[o>>2]|0;p=c+24|0;g=k[p>>2]|0;q=c+28|0;i=k[q>>2]|0;k[c>>2]=k[d>>2];z=d+4|0;f=z;t=k[f+4>>2]|0;v=r;k[v>>2]=k[f>>2];k[v+4>>2]=t;v=d+12|0;k[m>>2]=k[v>>2];t=d+16|0;k[n>>2]=k[t>>2];f=d+20|0;k[o>>2]=k[f>>2];h=d+24|0;k[p>>2]=k[h>>2];j=d+28|0;k[q>>2]=k[j>>2];k[d>>2]=A;d=z;k[d>>2]=y;k[d+4>>2]=x;k[v>>2]=w;k[t>>2]=u;k[f>>2]=s;k[h>>2]=g;k[j>>2]=i;if(!(Za[k[e>>2]&7](c,b)|0)){A=l+1|0;return A|0}v=k[b>>2]|0;d=b+4|0;u=d;t=k[u>>2]|0;u=k[u+4>>2]|0;f=b+12|0;w=k[f>>2]|0;g=b+16|0;x=k[g>>2]|0;h=b+20|0;y=k[h>>2]|0;i=b+24|0;z=k[i>>2]|0;j=b+28|0;A=k[j>>2]|0;k[b>>2]=k[c>>2];C=r;B=k[C+4>>2]|0;s=d;k[s>>2]=k[C>>2];k[s+4>>2]=B;k[f>>2]=k[m>>2];k[g>>2]=k[n>>2];k[h>>2]=k[o>>2];k[i>>2]=k[p>>2];k[j>>2]=k[q>>2];k[c>>2]=v;v=r;k[v>>2]=t;k[v+4>>2]=u;k[m>>2]=w;k[n>>2]=x;k[o>>2]=y;k[p>>2]=z;k[q>>2]=A;if(!(Za[k[e>>2]&7](b,a)|0)){C=l+2|0;return C|0}x=k[a>>2]|0;p=a+4|0;w=p;v=k[w>>2]|0;w=k[w+4>>2]|0;e=a+12|0;y=k[e>>2]|0;c=a+16|0;z=k[c>>2]|0;s=a+20|0;A=k[s>>2]|0;t=a+24|0;B=k[t>>2]|0;u=a+28|0;C=k[u>>2]|0;k[a>>2]=k[b>>2];q=d;r=k[q+4>>2]|0;a=p;k[a>>2]=k[q>>2];k[a+4>>2]=r;k[e>>2]=k[f>>2];k[c>>2]=k[g>>2];k[s>>2]=k[h>>2];k[t>>2]=k[i>>2];k[u>>2]=k[j>>2];k[b>>2]=x;x=d;k[x>>2]=v;k[x+4>>2]=w;k[f>>2]=y;k[g>>2]=z;k[h>>2]=A;k[i>>2]=B;k[j>>2]=C;C=l+3|0;return C|0}function Bb(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0;t=Ab(a,b,c,d,f)|0;if(!(Za[k[f>>2]&7](e,d)|0)){c=t;return c|0}B=k[d>>2]|0;m=d+4|0;y=m;z=k[y>>2]|0;y=k[y+4>>2]|0;g=d+12|0;x=k[g>>2]|0;h=d+16|0;v=k[h>>2]|0;i=d+20|0;n=k[i>>2]|0;j=d+24|0;p=k[j>>2]|0;l=d+28|0;r=k[l>>2]|0;k[d>>2]=k[e>>2];A=e+4|0;o=A;u=k[o+4>>2]|0;w=m;k[w>>2]=k[o>>2];k[w+4>>2]=u;w=e+12|0;k[g>>2]=k[w>>2];u=e+16|0;k[h>>2]=k[u>>2];o=e+20|0;k[i>>2]=k[o>>2];q=e+24|0;k[j>>2]=k[q>>2];s=e+28|0;k[l>>2]=k[s>>2];k[e>>2]=B;e=A;k[e>>2]=z;k[e+4>>2]=y;k[w>>2]=x;k[u>>2]=v;k[o>>2]=n;k[q>>2]=p;k[s>>2]=r;if(!(Za[k[f>>2]&7](d,c)|0)){B=t+1|0;return B|0}w=k[c>>2]|0;n=c+4|0;v=n;u=k[v>>2]|0;v=k[v+4>>2]|0;o=c+12|0;x=k[o>>2]|0;p=c+16|0;y=k[p>>2]|0;q=c+20|0;z=k[q>>2]|0;r=c+24|0;A=k[r>>2]|0;s=c+28|0;B=k[s>>2]|0;k[c>>2]=k[d>>2];D=m;C=k[D+4>>2]|0;e=n;k[e>>2]=k[D>>2];k[e+4>>2]=C;k[o>>2]=k[g>>2];k[p>>2]=k[h>>2];k[q>>2]=k[i>>2];k[r>>2]=k[j>>2];k[s>>2]=k[l>>2];k[d>>2]=w;w=m;k[w>>2]=u;k[w+4>>2]=v;k[g>>2]=x;k[h>>2]=y;k[i>>2]=z;k[j>>2]=A;k[l>>2]=B;if(!(Za[k[f>>2]&7](c,b)|0)){D=t+2|0;return D|0}y=k[b>>2]|0;j=b+4|0;x=j;w=k[x>>2]|0;x=k[x+4>>2]|0;l=b+12|0;z=k[l>>2]|0;e=b+16|0;A=k[e>>2]|0;g=b+20|0;B=k[g>>2]|0;h=b+24|0;C=k[h>>2]|0;i=b+28|0;D=k[i>>2]|0;k[b>>2]=k[c>>2];d=n;u=k[d+4>>2]|0;v=j;k[v>>2]=k[d>>2];k[v+4>>2]=u;k[l>>2]=k[o>>2];k[e>>2]=k[p>>2];k[g>>2]=k[q>>2];k[h>>2]=k[r>>2];k[i>>2]=k[s>>2];k[c>>2]=y;y=n;k[y>>2]=w;k[y+4>>2]=x;k[o>>2]=z;k[p>>2]=A;k[q>>2]=B;k[r>>2]=C;k[s>>2]=D;if(!(Za[k[f>>2]&7](b,a)|0)){D=t+3|0;return D|0}y=k[a>>2]|0;p=a+4|0;x=p;w=k[x>>2]|0;x=k[x+4>>2]|0;s=a+12|0;z=k[s>>2]|0;f=a+16|0;A=k[f>>2]|0;c=a+20|0;B=k[c>>2]|0;u=a+24|0;C=k[u>>2]|0;v=a+28|0;D=k[v>>2]|0;k[a>>2]=k[b>>2];q=j;r=k[q+4>>2]|0;a=p;k[a>>2]=k[q>>2];k[a+4>>2]=r;k[s>>2]=k[l>>2];k[f>>2]=k[e>>2];k[c>>2]=k[g>>2];k[u>>2]=k[h>>2];k[v>>2]=k[i>>2];k[b>>2]=y;y=j;k[y>>2]=w;k[y+4>>2]=x;k[l>>2]=z;k[e>>2]=A;k[g>>2]=B;k[h>>2]=C;k[i>>2]=D;D=t+4|0;return D|0}function Cb(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0,s=0,t=0,u=0,v=0,w=0,x=0;x=r;r=r+32|0;v=x;switch(b-a>>5|0){case 2:{d=b+-32|0;if(!(Za[k[c>>2]&7](d,a)|0)){w=1;r=x;return w|0}j=k[a>>2]|0;p=a+4|0;n=p;m=k[n>>2]|0;n=k[n+4>>2]|0;s=a+12|0;o=k[s>>2]|0;u=a+16|0;q=k[u>>2]|0;h=a+20|0;t=k[h>>2]|0;w=a+24|0;v=k[w>>2]|0;i=a+28|0;c=k[i>>2]|0;k[a>>2]=k[d>>2];l=b+-28|0;g=l;a=k[g+4>>2]|0;k[p>>2]=k[g>>2];k[p+4>>2]=a;p=b+-20|0;k[s>>2]=k[p>>2];s=b+-16|0;k[u>>2]=k[s>>2];u=b+-12|0;k[h>>2]=k[u>>2];a=b+-8|0;k[w>>2]=k[a>>2];w=b+-4|0;k[i>>2]=k[w>>2];k[d>>2]=j;b=l;k[b>>2]=m;k[b+4>>2]=n;k[p>>2]=o;k[s>>2]=q;k[u>>2]=t;k[a>>2]=v;k[w>>2]=c;w=1;r=x;return w|0}case 3:{zb(a,a+32|0,b+-32|0,c)|0;w=1;r=x;return w|0}case 4:{Ab(a,a+32|0,a+64|0,b+-32|0,c)|0;w=1;r=x;return w|0}case 5:{Bb(a,a+32|0,a+64|0,a+96|0,b+-32|0,c)|0;w=1;r=x;return w|0}case 1:case 0:{w=1;r=x;return w|0}default:{f=a+64|0;zb(a,a+32|0,f,c)|0;e=a+96|0;if((e|0)==(b|0)){w=1;r=x;return w|0}o=v+4|0;p=v+12|0;q=v+16|0;s=v+20|0;t=v+24|0;u=v+28|0;d=0;while(1){if(Za[k[c>>2]&7](e,f)|0){k[v>>2]=k[e>>2];m=e+4|0;n=k[m+4>>2]|0;g=o;k[g>>2]=k[m>>2];k[g+4>>2]=n;k[p>>2]=k[e+12>>2];k[q>>2]=k[e+16>>2];k[s>>2]=k[e+20>>2];k[t>>2]=k[e+24>>2];k[u>>2]=k[e+28>>2];g=e;while(1){k[g>>2]=k[f>>2];n=f+4|0;j=n;i=k[j+4>>2]|0;h=g+4|0;k[h>>2]=k[j>>2];k[h+4>>2]=i;h=f+12|0;k[g+12>>2]=k[h>>2];i=f+16|0;k[g+16>>2]=k[i>>2];j=f+20|0;k[g+20>>2]=k[j>>2];l=f+24|0;k[g+24>>2]=k[l>>2];m=f+28|0;k[g+28>>2]=k[m>>2];if((f|0)==(a|0))break;g=f+-32|0;if(Za[k[c>>2]&7](v,g)|0){n=f;f=g;g=n}else break}k[f>>2]=k[v>>2];f=o;g=k[f+4>>2]|0;k[n>>2]=k[f>>2];k[n+4>>2]=g;k[h>>2]=k[p>>2];k[i>>2]=k[q>>2];k[j>>2]=k[s>>2];k[l>>2]=k[t>>2];k[m>>2]=k[u>>2];d=d+1|0;if((d|0)==8)break}f=e+32|0;if((f|0)==(b|0)){d=1;w=16;break}else{n=e;e=f;f=n}}if((w|0)==16){r=x;return d|0}w=(e+32|0)==(b|0);r=x;return w|0}}return 0}function Db(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,l=0,m=0,n=0;m=a+4|0;e=k[m>>2]|0;l=k[a>>2]|0;c=l;i=(e-c|0)/24|0;j=i+1|0;if(j>>>0>178956970)xa(1340,1363,303,1438);n=a+8|0;d=((k[n>>2]|0)-c|0)/24|0;if(d>>>0<89478485){d=d<<1;d=d>>>0<j>>>0?j:d;if(!d){g=0;f=0}else h=5}else{d=178956970;h=5}if((h|0)==5){g=d*24|0;g=(g|0)==0?1:g;f=_d(g)|0;a:do if(!f){while(1){f=k[35]|0;k[35]=f+0;if(!f)break;Xa[f&0]();f=_d(g)|0;if(f)break a}n=ya(4)|0;k[n>>2]=128;La(n|0,8,1)}while(0);g=d}h=f+(i*24|0)|0;d=h;g=f+(g*24|0)|0;k[h>>2]=k[b>>2];k[f+(i*24|0)+4>>2]=k[b+4>>2];k[f+(i*24|0)+8>>2]=k[b+8>>2];k[f+(i*24|0)+12>>2]=k[b+12>>2];k[f+(i*24|0)+16>>2]=k[b+16>>2];k[f+(i*24|0)+20>>2]=k[b+20>>2];f=f+(j*24|0)|0;if((e|0)==(l|0))e=a;else{c=h;do{i=e;e=e+-24|0;k[c+-24>>2]=k[e>>2];k[c+-20>>2]=k[i+-20>>2];k[c+-16>>2]=k[i+-16>>2];k[c+-12>>2]=k[i+-12>>2];i=i+-8|0;j=k[i+4>>2]|0;b=c+-8|0;k[b>>2]=k[i>>2];k[b+4>>2]=j;c=d+-24|0;d=c}while((e|0)!=(l|0));e=a;c=k[a>>2]|0}k[e>>2]=d;k[m>>2]=f;k[n>>2]=g;if(!c)return;$d(c);return}function Eb(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0,U=0,V=0;V=r;r=r+160|0;K=V+132|0;y=V+8|0;z=V;A=V+120|0;B=V+108|0;I=V+52|0;H=V+40|0;G=V+28|0;M=V+16|0;S=V+96|0;O=V+84|0;v=V+64|0;k[S>>2]=0;T=S+4|0;k[T>>2]=0;k[S+8>>2]=0;k[O>>2]=0;R=O+4|0;k[R>>2]=0;k[O+8>>2]=0;do if((b|0)!=(c|0)){p=v+4|0;q=v+8|0;s=v+12|0;t=v+16|0;u=S+8|0;f=0;g=0;o=0;n=0;h=0;e=0;a:while(1){l=b+16|0;if((f|0)==(g|0)){m=e-n|0;i=m>>3;j=i+1|0;if(j>>>0>536870911){N=6;break}d=h-n|0;if(d>>3>>>0<268435455){d=d>>2;d=d>>>0<j>>>0?j:d;if(!d){d=0;g=0}else N=9}else{d=536870911;N=9}if((N|0)==9){N=0;f=d<<3;f=(f|0)==0?1:f;e=_d(f)|0;if(!e)do{e=k[35]|0;k[35]=e+0;if(!e){N=12;break a}Xa[e&0]();e=_d(f)|0}while((e|0)==0);g=e}h=g+(d<<3)|0;e=l;d=k[e+4>>2]|0;f=g+(i<<3)|0;k[f>>2]=k[e>>2];k[f+4>>2]=d;f=g+(j<<3)|0;d=g;e=n;fe(g|0,e|0,m|0)|0;if(!n){l=h;j=f}else{$d(e);l=h;j=f}}else{j=l;l=k[j+4>>2]|0;d=f;k[d>>2]=k[j>>2];k[d+4>>2]=l;d=n;l=h;j=e+8|0}e=k[b>>2]|0;k[v>>2]=e;f=k[b+4>>2]|0;k[p>>2]=f;g=k[b+8>>2]|0;k[q>>2]=g;h=k[b+12>>2]|0;k[s>>2]=h;k[t>>2]=o;i=k[T>>2]|0;if(i>>>0<(k[u>>2]|0)>>>0){k[i>>2]=e;k[i+4>>2]=f;k[i+8>>2]=g;k[i+12>>2]=h;k[i+16>>2]=o;k[T>>2]=i+20}else Fb(S,v);b=b+24|0;if((b|0)==(c|0)){N=21;break}f=j;g=l;o=o+1|0;n=d;h=l;e=j}if((N|0)==6)xa(1340,1363,303,1438);else if((N|0)==12){V=ya(4)|0;k[V>>2]=128;La(V|0,8,1)}else if((N|0)==21){x=k[T>>2]|0;w=k[S>>2]|0;U=d;break}}else{x=0;w=0;U=0}while(0);n=(x-w|0)/20|0;k[M>>2]=0;J=M+4|0;k[J>>2]=0;k[M+8>>2]=0;g=(x|0)==(w|0);if(!g){if(n>>>0>357913941)xa(1340,1363,303,1438);d=n*12|0;b=_d(d)|0;b:do if(!b){while(1){b=k[35]|0;k[35]=b+0;if(!b)break;Xa[b&0]();b=_d(d)|0;if(b)break b}V=ya(4)|0;k[V>>2]=128;La(V|0,8,1)}while(0);k[J>>2]=b;k[M>>2]=b;k[M+8>>2]=b+(n*12|0);e=n;f=b;while(1){k[f+4>>2]=0;k[f+8>>2]=0;k[f>>2]=f+4;d=b+12|0;k[J>>2]=d;b=e+-1|0;if(!b)break;else{e=b;f=d;b=d}}}k[I>>2]=0;E=I+4|0;k[E>>2]=0;k[I+8>>2]=0;k[K>>2]=0;m=K+4|0;k[m>>2]=0;k[K+8>>2]=0;e=n<<1;j=K+8|0;if(g){f=0;g=0;d=0}else{d=n<<4;b=_d(d)|0;c:do if(!b){while(1){b=k[35]|0;k[35]=b+0;if(!b)break;Xa[b&0]();b=_d(d)|0;if(b)break c}V=ya(4)|0;k[V>>2]=128;La(V|0,8,1)}while(0);f=b;d=b+(e<<3)|0;k[K>>2]=f;k[m>>2]=f;k[j>>2]=d;f=b;g=b}F=w;D=(F|0)==(x|0);if(D){e=g;b=g;d=f;j=f}else{h=y+4|0;i=z+4|0;b=F;while(1){C=k[b+4>>2]|0;e=b+12|0;f=(C|0)<(k[e>>2]|0)?1:-1;k[y>>2]=C;k[h>>2]=f;if(g>>>0<d>>>0){w=y;C=k[w+4>>2]|0;d=g;k[d>>2]=k[w>>2];k[d+4>>2]=C;d=(k[m>>2]|0)+8|0;k[m>>2]=d}else{dc(K,y);d=k[m>>2]|0}k[z>>2]=k[e>>2];k[i>>2]=0-f;if(d>>>0<(k[j>>2]|0)>>>0){c=z;w=k[c+4>>2]|0;C=d;k[C>>2]=k[c>>2];k[C+4>>2]=w;k[m>>2]=d+8}else dc(K,z);b=b+20|0;if((b|0)==(x|0))break;g=k[m>>2]|0;d=k[j>>2]|0}j=k[K>>2]|0;d=k[m>>2]|0;e=j;b=d}ec(e,b);h=d-j>>3;l=I+8|0;b=k[l>>2]|0;i=k[I>>2]|0;e=i;d=k[E>>2]|0;if(((b-e|0)/12|0)>>>0<h>>>0){f=d-e|0;g=(f|0)/12|0;if(!h)e=0;else{d=h*12|0;d=(d|0)==0?1:d;b=_d(d)|0;d:do if(!b){while(1){b=k[35]|0;k[35]=b+0;if(!b)break;Xa[b&0]();b=_d(d)|0;if(b)break d}V=ya(4)|0;k[V>>2]=128;La(V|0,8,1)}while(0);e=b}d=e+(g*12|0)|0;b=e+(h*12|0)|0;C=e+((((f|0)/-12|0)+g|0)*12|0)|0;fe(C|0,i|0,f|0)|0;k[I>>2]=C;k[E>>2]=d;k[l>>2]=b;if(!i)e=j;else{$d(i);e=k[K>>2]|0}}else e=j;k[A>>2]=k[e>>2];k[A+4>>2]=0;k[A+8>>2]=0;if(d>>>0<b>>>0){k[d>>2]=k[A>>2];k[d+4>>2]=k[A+4>>2];k[d+8>>2]=k[A+8>>2];k[E>>2]=(k[E>>2]|0)+12}else fc(I,A);i=k[K>>2]|0;d=k[m>>2]|0;if((i|0)==(d|0))d=i;else{f=B+4|0;g=B+8|0;h=i;e=k[E>>2]|0;do{b=k[h>>2]|0;do if((b|0)!=(k[e+-12>>2]|0)){k[B>>2]=b;k[f>>2]=k[e+-8>>2];k[g>>2]=k[e+-4>>2];if(e>>>0<(k[l>>2]|0)>>>0){k[e>>2]=k[B>>2];k[e+4>>2]=k[B+4>>2];k[e+8>>2]=k[B+8>>2];e=e+12|0;k[E>>2]=e;break}else{fc(I,B);e=k[E>>2]|0;break}}while(0);b=k[h+4>>2]|0;if((b|0)<0){C=e+-4|0;k[C>>2]=(k[C>>2]|0)-b}C=e+-8|0;k[C>>2]=(k[C>>2]|0)+b;h=h+8|0}while((h|0)!=(d|0))}b=i;if(i){if((d|0)!=(i|0))k[m>>2]=d+(~((d+-8-b|0)>>>3)<<3);$d(i)}k[H>>2]=0;C=H+4|0;k[C>>2]=0;k[H+8>>2]=0;d=k[I>>2]|0;Mb(H,d,k[E>>2]|0,n);z=G+4|0;k[z>>2]=0;A=G+8|0;k[A>>2]=0;B=G+4|0;k[G>>2]=B;b=_d(32)|0;e:do if(!b){while(1){b=k[35]|0;k[35]=b+0;if(!b)break;Xa[b&0]();b=_d(32)|0;if(b)break e}V=ya(4)|0;k[V>>2]=128;La(V|0,8,1)}while(0);y=B;k[b+16>>2]=k[d>>2];g=b+20|0;k[g>>2]=0;h=b+24|0;k[h>>2]=0;f=b+28|0;k[f>>2]=0;k[b>>2]=0;k[b+4>>2]=0;k[b+8>>2]=y;k[B>>2]=b;d=k[k[G>>2]>>2]|0;if(!d)d=b;else{k[G>>2]=d;d=b}Nb(b,d);k[A>>2]=(k[A>>2]|0)+1;b=k[g>>2]|0;d=b;if(!b)b=f;else{e=k[h>>2]|0;if((e|0)!=(b|0))k[h>>2]=e+(~(((e+-20-d|0)>>>0)/20|0)*20|0);$d(b);k[f>>2]=0;k[h>>2]=0;k[g>>2]=0;b=f}k[g>>2]=0;k[h>>2]=0;k[b>>2]=0;b=k[H>>2]|0;f:do if((b|0)!=(k[C>>2]|0)){g:while(1){d=k[B>>2]|0;do if(d){g=k[b>>2]|0;while(1){e=k[d+16>>2]|0;if((g|0)<(e|0)){e=k[d>>2]|0;if(!e){N=90;break}else d=e}else{if((e|0)>=(g|0)){N=96;break}f=d+4|0;e=k[f>>2]|0;if(!e){N=94;break}else d=e}}if((N|0)==90){k[K>>2]=d;f=d;N=97;break}else if((N|0)==94){k[K>>2]=d;N=97;break}else if((N|0)==96){N=0;k[K>>2]=d;if(!d){f=K;N=97;break}else break}}else{k[K>>2]=B;f=B;d=y;N=97}while(0);if((N|0)==97){N=0;e=_d(32)|0;if(!e)do{e=k[35]|0;k[35]=e+0;if(!e)break g;Xa[e&0]();e=_d(32)|0}while((e|0)==0);k[e+16>>2]=k[b>>2];k[e+20>>2]=0;k[e+24>>2]=0;k[e+28>>2]=0;k[e>>2]=0;k[e+4>>2]=0;k[e+8>>2]=d;k[f>>2]=e;d=k[k[G>>2]>>2]|0;if(!d)d=e;else{k[G>>2]=d;d=k[f>>2]|0}Nb(k[z>>2]|0,d);k[A>>2]=(k[A>>2]|0)+1;d=e}i=d+20|0;e=k[i>>2]|0;f=e;h=d+24|0;if(!e)d=d+28|0;else{g=k[h>>2]|0;if((g|0)!=(e|0))k[h>>2]=g+(~(((g+-20-f|0)>>>0)/20|0)*20|0);$d(e);d=d+28|0;k[d>>2]=0;k[h>>2]=0;k[i>>2]=0}k[i>>2]=0;k[h>>2]=0;k[d>>2]=0;b=b+4|0;if((b|0)==(k[C>>2]|0))break f}V=ya(4)|0;k[V>>2]=128;La(V|0,8,1)}while(0);h:do if(!D){c=F;i:while(1){v=c+4|0;h=k[v>>2]|0;w=c+12|0;i=k[w>>2]|0;e=k[B>>2]|0;j=(e|0)==0;j:do if(j)d=B;else{g=(i|0)<(h|0)?i:h;d=B;f=e;while(1){b=f;while(1){if((k[b+16>>2]|0)>=(g|0))break;b=k[b+4>>2]|0;if(!b)break j}f=k[b>>2]|0;if(!f){d=b;break}else d=b}}while(0);if((d|0)!=(k[G>>2]|0)){b=k[d>>2]|0;if(!b)while(1){b=k[d+8>>2]|0;if((k[b>>2]|0)==(d|0))d=b;else{d=b;break}}else{d=b;while(1){b=k[d+4>>2]|0;if(!b)break;else d=b}}}k:do if(j)f=B;else{g=(h|0)<(i|0)?i:h;f=B;while(1){b=e;while(1){if((g|0)<(k[b+16>>2]|0))break;b=k[b+4>>2]|0;if(!b)break k}e=k[b>>2]|0;if(!e){f=b;break}else f=b}}while(0);if((d|0)!=(f|0)){t=c+8|0;u=c+16|0;while(1){o=d+24|0;l=k[o>>2]|0;p=d+28|0;do if((l|0)==(k[p>>2]|0)){q=d+20|0;s=k[q>>2]|0;m=s;n=(l-m|0)/20|0;h=n+1|0;if(h>>>0>214748364){N=135;break i}if(n>>>0<107374182){b=n<<1;b=b>>>0<h>>>0?h:b;if(!b){g=0;e=0}else N=138}else{b=214748364;N=138}if((N|0)==138){N=0;g=b*20|0;g=(g|0)==0?1:g;e=_d(g)|0;if(!e)do{e=k[35]|0;k[35]=e+0;if(!e){N=141;break i}Xa[e&0]();e=_d(g)|0}while((e|0)==0);g=b}b=e+(n*20|0)|0;j=e+(g*20|0)|0;k[b>>2]=k[c>>2];k[e+(n*20|0)+4>>2]=k[v>>2];k[e+(n*20|0)+8>>2]=k[t>>2];k[e+(n*20|0)+12>>2]=k[w>>2];k[e+(n*20|0)+16>>2]=k[u>>2];i=e+(h*20|0)|0;if((l|0)!=(s|0)){h=l+-20|0;g=l;while(1){l=g;g=g+-20|0;k[b+-20>>2]=k[g>>2];k[b+-16>>2]=k[l+-16>>2];k[b+-12>>2]=k[l+-12>>2];k[b+-8>>2]=k[l+-8>>2];k[b+-4>>2]=k[l+-4>>2];if((g|0)==(s|0))break;else b=b+-20|0}b=e+((n+~(((h-m|0)>>>0)/20|0)|0)*20|0)|0}k[q>>2]=b;k[o>>2]=i;k[p>>2]=j;if(!s)break;$d(s)}else{k[l>>2]=k[c>>2];k[l+4>>2]=k[v>>2];k[l+8>>2]=k[t>>2];k[l+12>>2]=k[w>>2];k[l+16>>2]=k[u>>2];k[o>>2]=l+20}while(0);b=k[d+4>>2]|0;if(!b)while(1){b=k[d+8>>2]|0;if((k[b>>2]|0)==(d|0))break;else d=b}else while(1){d=k[b>>2]|0;if(!d)break;else b=d}if((b|0)==(f|0))break;else d=b}}c=c+20|0;if((c|0)==(x|0))break h}if((N|0)==135)xa(1340,1363,303,1438);else if((N|0)==141){V=ya(4)|0;k[V>>2]=128;La(V|0,8,1)}}while(0);h=k[I>>2]|0;b=k[B>>2]|0;do if(b){g=k[h>>2]|0;f=b;while(1){d=k[f+16>>2]|0;if((g|0)<(d|0)){d=k[f>>2]|0;if(!d){N=159;break}}else{if((d|0)>=(g|0)){N=165;break}e=f+4|0;d=k[e>>2]|0;if(!d){N=163;break}}f=d}if((N|0)==159){k[K>>2]=f;e=f;N=166;break}else if((N|0)==163){k[K>>2]=f;N=166;break}else if((N|0)==165){k[K>>2]=f;if(!f){e=K;N=166;break}else{d=f;break}}}else{k[K>>2]=B;e=B;f=y;N=166}while(0);if((N|0)==166){b=_d(32)|0;l:do if(!b){while(1){b=k[35]|0;k[35]=b+0;if(!b)break;Xa[b&0]();b=_d(32)|0;if(b){d=b;break l}}V=ya(4)|0;k[V>>2]=128;La(V|0,8,1)}else d=b;while(0);k[d+16>>2]=k[h>>2];k[d+20>>2]=0;k[d+24>>2]=0;k[d+28>>2]=0;k[d>>2]=0;k[d+4>>2]=0;k[d+8>>2]=f;k[e>>2]=d;b=k[k[G>>2]>>2]|0;if(!b)b=d;else{k[G>>2]=b;b=k[e>>2]|0}Nb(k[z>>2]|0,b);k[A>>2]=(k[A>>2]|0)+1;b=k[B>>2]|0;h=k[I>>2]|0}g=k[d+20>>2]|0;do if(b){f=k[h>>2]|0;while(1){d=k[b+16>>2]|0;if((f|0)<(d|0)){d=k[b>>2]|0;if(!d){N=177;break}else b=d}else{if((d|0)>=(f|0)){N=183;break}e=b+4|0;d=k[e>>2]|0;if(!d){N=181;break}else b=d}}if((N|0)==177){k[K>>2]=b;e=b;d=b;N=184;break}else if((N|0)==181){k[K>>2]=b;d=b;N=184;break}else if((N|0)==183){k[K>>2]=b;if(!b){e=K;d=b;N=184;break}else break}}else{k[K>>2]=B;e=B;d=y;N=184}while(0);if((N|0)==184){b=_d(32)|0;m:do if(!b){while(1){b=k[35]|0;k[35]=b+0;if(!b)break;Xa[b&0]();b=_d(32)|0;if(b)break m}V=ya(4)|0;k[V>>2]=128;La(V|0,8,1)}while(0);k[b+16>>2]=k[h>>2];k[b+20>>2]=0;k[b+24>>2]=0;k[b+28>>2]=0;k[b>>2]=0;k[b+4>>2]=0;k[b+8>>2]=d;k[e>>2]=b;d=k[k[G>>2]>>2]|0;if(!d)d=b;else{k[G>>2]=d;d=k[e>>2]|0}Nb(k[z>>2]|0,d);k[A>>2]=(k[A>>2]|0)+1}Pb(M,g,k[b+24>>2]|0,-2147483648);b=k[H>>2]|0;n:do if((b|0)!=(k[C>>2]|0)){o:while(1){g=k[B>>2]|0;do if(g){h=k[b>>2]|0;f=g;while(1){d=k[f+16>>2]|0;if((h|0)<(d|0)){d=k[f>>2]|0;if(!d){N=197;break}}else{if((d|0)>=(h|0)){N=203;break}e=f+4|0;d=k[e>>2]|0;if(!d){N=201;break}}f=d}if((N|0)==197){k[K>>2]=f;g=f;N=204;break}else if((N|0)==201){k[K>>2]=f;g=e;N=204;break}else if((N|0)==203){N=0;k[K>>2]=f;if(!f){g=K;N=204;break}else{d=f;break}}}else{k[K>>2]=B;g=B;f=y;N=204}while(0);if((N|0)==204){d=_d(32)|0;if(!d)while(1){d=k[35]|0;k[35]=d+0;if(!d){N=207;break o}Xa[d&0]();d=_d(32)|0;if(d){e=d;break}}else e=d;k[e+16>>2]=k[b>>2];k[e+20>>2]=0;k[e+24>>2]=0;k[e+28>>2]=0;k[e>>2]=0;k[e+4>>2]=0;k[e+8>>2]=f;k[g>>2]=e;d=k[k[G>>2]>>2]|0;if(!d)d=e;else{k[G>>2]=d;d=k[g>>2]|0}Nb(k[z>>2]|0,d);k[A>>2]=(k[A>>2]|0)+1;g=k[B>>2]|0;d=e}h=k[d+20>>2]|0;do if(g){f=k[b>>2]|0;while(1){d=k[g+16>>2]|0;if((f|0)<(d|0)){d=k[g>>2]|0;if(!d){N=215;break}}else{if((d|0)>=(f|0)){N=221;break}e=g+4|0;d=k[e>>2]|0;if(!d){N=219;break}}g=d}if((N|0)==215){k[K>>2]=g;f=g;N=222;break}else if((N|0)==219){k[K>>2]=g;f=e;N=222;break}else if((N|0)==221){N=0;k[K>>2]=g;if(!g){f=K;N=222;break}else{d=g;break}}}else{k[K>>2]=B;f=B;g=y;N=222}while(0);if((N|0)==222){N=0;d=_d(32)|0;if(!d)do{d=k[35]|0;k[35]=d+0;if(!d){N=225;break o}Xa[d&0]();d=_d(32)|0}while((d|0)==0);k[d+16>>2]=k[b>>2];k[d+20>>2]=0;k[d+24>>2]=0;k[d+28>>2]=0;k[d>>2]=0;k[d+4>>2]=0;k[d+8>>2]=g;k[f>>2]=d;e=k[k[G>>2]>>2]|0;if(!e)e=d;else{k[G>>2]=e;e=k[f>>2]|0}Nb(k[z>>2]|0,e);k[A>>2]=(k[A>>2]|0)+1}Pb(M,h,k[d+24>>2]|0,k[b>>2]|0);b=b+4|0;if((b|0)==(k[C>>2]|0))break n}if((N|0)==207){V=ya(4)|0;k[V>>2]=128;La(V|0,8,1)}else if((N|0)==225){V=ya(4)|0;k[V>>2]=128;La(V|0,8,1)}}while(0);Ob(k[B>>2]|0);b=k[H>>2]|0;d=b;if(b){e=k[C>>2]|0;if((e|0)!=(b|0))k[C>>2]=e+(~((e+-4-d|0)>>>2)<<2);$d(b)}b=k[I>>2]|0;d=b;if(b){e=k[E>>2]|0;if((e|0)!=(b|0))k[E>>2]=e+(~(((e+-12-d|0)>>>0)/12|0)*12|0);$d(b)}p:do if(!D){c=K+4|0;w=K+8|0;y=K+12|0;z=K+16|0;A=O+8|0;B=K+4|0;C=K+8|0;D=K+12|0;E=K+16|0;u=F;q:while(1){v=k[u+16>>2]|0;n=k[M>>2]|0;m=n+(v*12|0)|0;b=k[u>>2]|0;d=k[u+8>>2]|0;do if((b|0)==(d|0))N=320;else{H=k[u+4>>2]|0;l=b+1|0;h=k[u+12>>2]|0;H=be(h|0,((h|0)<0)<<31>>31|0,H|0,((H|0)<0)<<31>>31|0)|0;h=L;e=((b|0)<0)<<31>>31;l=be(l|0,((l|0)<0)<<31>>31|0,b|0,e|0)|0;g=L;e=be(d|0,((d|0)<0)<<31>>31|0,b|0,e|0)|0;i=L;I=(i|0)<0;b=be(0,0,H|0,h|0)|0;d=L;f=be(0,0,e|0,i|0)|0;j=L;b=I?b:H;d=I?d:h;e=(g|0)<0;f=be(0,0,l|0,g|0)|0;g=e?L:g;h=(d|0)<0;i=((I?j:i)|0)<0?-1:1;j=ha(h?-1:1,(g|0)<0?-1:1)|0;if((j|0)>=(i|0)?(I=be(0,0,b|0,d|0)|0,I=ne((h?I:b)|0,(h?L:d)|0,(e?f:l)|0,g|0)|0,!(((I|0)!=0|(L|0)!=0)&((i|0)>=(j|0)&(j|0)==-1))):0){N=320;break}e=k[n+(v*12|0)+8>>2]|0;if(!e){s=0;t=0;i=0}else{d=e<<3;d=(d|0)==0?1:d;b=_d(d)|0;if(!b)do{b=k[35]|0;k[35]=b+0;if(!b){N=247;break q}Xa[b&0]();b=_d(d)|0}while((b|0)==0);s=b;t=b;i=b+(e<<3)|0}q=s;h=k[m>>2]|0;m=n+(v*12|0)+4|0;l=m;n=t;o=q-t>>3;f=h;do if((f|0)==(m|0)){j=t;b=t}else{e=h;d=e;g=0;while(1){j=g+1|0;b=k[d+4>>2]|0;if(!b)while(1){b=k[d+8>>2]|0;if((k[b>>2]|0)==(d|0))break;else d=b}else while(1){d=k[b>>2]|0;if(!d)break;else b=d}if((b|0)==(m|0))break;else{d=b;g=j}}if((g|0)<=-1){j=t;b=t;break}p=t;if((g|0)>=(i-t>>3|0)){d=(t-t>>3)+j|0;if(d>>>0>536870911){N=290;break q}b=i-t|0;if(b>>3>>>0<268435455){b=b>>2;b=b>>>0<d>>>0?d:b;if(!b)g=0;else N=293}else{b=536870911;N=293}if((N|0)==293){N=0;d=b<<3;d=(d|0)==0?1:d;b=_d(d)|0;if(!b)do{b=k[35]|0;k[35]=b+0;if(!b){N=296;break q}Xa[b&0]();b=_d(d)|0}while((b|0)==0);g=b}d=g+(o<<3)|0;h=d;while(1){k[h>>2]=k[f+16>>2];k[h+4>>2]=k[f+20>>2];b=h+8|0;f=k[e+4>>2]|0;if(!f)while(1){f=k[e+8>>2]|0;if((k[f>>2]|0)==(e|0)){e=f;break}else e=f}else{e=f;while(1){f=k[e>>2]|0;if(!f)break;else e=f}}if((e|0)==(m|0))break;else{f=e;h=b}}if((n|0)!=(s|0)){f=s+-8|0;e=s;while(1){I=e;e=e+-8|0;k[d+-8>>2]=k[e>>2];k[d+-4>>2]=k[I+-4>>2];if((e|0)==(n|0))break;else d=d+-8|0}d=g+(o+~((f-t|0)>>>3)<<3)|0}if((p|0)!=(s|0)){g=p+-8|0;e=s;f=h;while(1){k[f+8>>2]=k[e>>2];k[f+12>>2]=k[e+4>>2];e=e+8|0;if((e|0)==(p|0))break;else{f=b;b=b+8|0}}b=h+(((g-q|0)>>>3)+2<<3)|0}if(!t){j=d;break}$d(t);j=d;break}i=t-q|0;b=i>>3;if((g|0)>=(b|0)){do if((i|0)>-8){if((i|0)>0){d=e;g=b}else{l=h;break}while(1){b=k[d+4>>2]|0;if(!b)while(1){b=k[d+8>>2]|0;if((k[b>>2]|0)==(d|0))break;else d=b}else while(1){d=k[b>>2]|0;if(!d)break;else b=d}if((g|0)>1){d=b;g=g+-1|0}else break}l=b}else{d=e;g=b;while(1){b=k[d>>2]|0;if(!b)while(1){b=k[d+8>>2]|0;if((k[b>>2]|0)==(d|0))d=b;else break}else while(1){d=k[b+4>>2]|0;if(!d)break;else b=d}if((g|0)<-1){d=b;g=g+1|0}else break}l=b}while(0);b=l;if((b|0)==(m|0)){d=p;b=t}else{g=p;d=l;while(1){k[g>>2]=k[b+16>>2];k[g+4>>2]=k[b+20>>2];g=g+8|0;b=k[d+4>>2]|0;if(!b){b=d;while(1){d=k[b+8>>2]|0;if((k[d>>2]|0)==(b|0))break;else b=d}}else while(1){d=k[b>>2]|0;if(!d){d=b;break}else b=d}if((d|0)==(m|0))break;else b=d}d=g;b=g}if((i|0)<=0){j=t;break}}else{d=p;b=t}j=d-(n+(j+o<<3))>>3;g=s+(j<<3)|0;if(g>>>0<p>>>0){i=p+(0-j<<3)+~q|0;b=d;h=g;while(1){k[b>>2]=k[h>>2];k[b+4>>2]=k[h+4>>2];h=h+8|0;if(h>>>0>=p>>>0)break;else b=b+8|0}b=d+((i>>>3)+1<<3)|0}if(j)do{I=d;d=d+-8|0;H=g;g=g+-8|0;k[d>>2]=k[g>>2];k[I+-4>>2]=k[H+-4>>2]}while((g|0)!=(s|0));h=l;if((f|0)==(h|0)){j=t;break}else g=s;while(1){k[g>>2]=k[f+16>>2];k[g+4>>2]=k[f+20>>2];d=k[e+4>>2]|0;if(!d)while(1){d=k[e+8>>2]|0;if((k[d>>2]|0)==(e|0))break;else e=d}else while(1){e=k[d>>2]|0;if(!e)break;else d=e}if((d|0)==(h|0)){j=t;break}else{g=g+8|0;f=d;e=d}}}while(0);e=j;Hb(e,b);d=e+8|0;if((d|0)!=(b|0)){i=d;while(1){g=k[e>>2]|0;h=k[e+4>>2]|0;f=k[e+8>>2]|0;d=k[e+12>>2]|0;k[K>>2]=g;k[B>>2]=h;k[C>>2]=f;k[D>>2]=d;k[E>>2]=v;e=k[R>>2]|0;if(e>>>0<(k[A>>2]|0)>>>0){k[e>>2]=g;k[e+4>>2]=h;k[e+8>>2]=f;k[e+12>>2]=d;k[e+16>>2]=v;k[R>>2]=e+20}else Fb(O,K);d=i+8|0;if((d|0)==(b|0))break;else{e=i;i=d}}}if(!j)break;$d(j)}while(0);if((N|0)==320){N=0;d=k[m>>2]|0;j=n+(v*12|0)+4|0;e=d;b=k[d+4>>2]|0;if(!b)while(1){b=k[d+8>>2]|0;if((k[b>>2]|0)==(d|0))break;else d=b}else while(1){d=k[b>>2]|0;if(!d)break;else b=d}if((b|0)!=(j|0)){d=b;i=e;while(1){e=i;i=d;b=k[e+16>>2]|0;e=k[e+20>>2]|0;f=k[d+16>>2]|0;g=k[d+20>>2]|0;k[K>>2]=b;k[c>>2]=e;k[w>>2]=f;k[y>>2]=g;k[z>>2]=v;h=k[R>>2]|0;if(h>>>0<(k[A>>2]|0)>>>0){k[h>>2]=b;k[h+4>>2]=e;k[h+8>>2]=f;k[h+12>>2]=g;k[h+16>>2]=v;k[R>>2]=h+20}else Fb(O,K);b=k[d+4>>2]|0;if(!b)while(1){b=k[d+8>>2]|0;if((k[b>>2]|0)==(d|0))break;else d=b}else while(1){d=k[b>>2]|0;if(!d)break;else b=d}if((b|0)==(j|0))break;else d=b}}}u=u+20|0;if((u|0)==(x|0))break p}if((N|0)==247){V=ya(4)|0;k[V>>2]=128;La(V|0,8,1)}else if((N|0)==290)xa(1340,1363,303,1438);else if((N|0)==296){V=ya(4)|0;k[V>>2]=128;La(V|0,8,1)}}while(0);d=k[M>>2]|0;if(d){b=k[J>>2]|0;if((b|0)!=(d|0)){do{Gb(k[b+-8>>2]|0);b=b+-12|0}while((b|0)!=(d|0));k[J>>2]=d}$d(d)}b=k[R>>2]|0;d=k[O>>2]|0;r:do if((b|0)!=(d|0)){v=a+4|0;c=a+8|0;w=U;e=k[v>>2]|0;u=0;s:while(1){m=k[d+(u*20|0)+16>>2]|0;p=k[d+(u*20|0)>>2]|0;q=k[d+(u*20|0)+4>>2]|0;s=k[d+(u*20|0)+8>>2]|0;j=k[d+(u*20|0)+12>>2]|0;l=k[w+(m<<3)>>2]|0;m=k[w+(m<<3)+4>>2]|0;d=k[c>>2]|0;do if(e>>>0<d>>>0){k[e>>2]=p;k[e+4>>2]=q;k[e+8>>2]=s;k[e+12>>2]=j;e=e+16|0;k[e>>2]=l;k[e+4>>2]=m;e=(k[v>>2]|0)+24|0;k[v>>2]=e}else{t=k[a>>2]|0;b=t;n=(e-b|0)/24|0;o=n+1|0;if(o>>>0>178956970){N=344;break s}d=(d-b|0)/24|0;if(d>>>0<89478485){d=d<<1;d=d>>>0<o>>>0?o:d;if(!d){g=0;f=0}else N=347}else{d=178956970;N=347}if((N|0)==347){N=0;g=d*24|0;g=(g|0)==0?1:g;f=_d(g)|0;if(!f)do{f=k[35]|0;k[35]=f+0;if(!f){N=350;break s}Xa[f&0]();f=_d(g)|0}while((f|0)==0);g=d}h=f+(n*24|0)|0;d=h;i=f+(g*24|0)|0;k[h>>2]=p;k[f+(n*24|0)+4>>2]=q;k[f+(n*24|0)+8>>2]=s;k[f+(n*24|0)+12>>2]=j;g=f+(n*24|0)+16|0;k[g>>2]=l;k[g+4>>2]=m;f=f+(o*24|0)|0;g=f;if((e|0)!=(t|0)){b=h;do{J=e;e=e+-24|0;k[b+-24>>2]=k[e>>2];k[b+-20>>2]=k[J+-20>>2];k[b+-16>>2]=k[J+-16>>2];k[b+-12>>2]=k[J+-12>>2];J=J+-8|0;K=k[J+4>>2]|0;M=b+-8|0;k[M>>2]=k[J>>2];k[M+4>>2]=K;b=d+-24|0;d=b}while((e|0)!=(t|0));b=k[a>>2]|0}k[a>>2]=d;k[v>>2]=g;k[c>>2]=i;if(!b){e=f;break}$d(b);e=k[v>>2]|0}while(0);m=e+-24|0;n=k[m>>2]|0;o=e+-16|0;p=k[o>>2]|0;do if((n|0)<(p|0))f=1;else{if((n|0)==(p|0)?(k[e+-20>>2]|0)<(k[e+-12>>2]|0):0){f=1;break}f=0}while(0);d=k[O>>2]|0;h=k[d+(u*20|0)+16>>2]|0;i=k[S>>2]|0;j=i+(h*20|0)|0;g=k[j>>2]|0;l=i+(h*20|0)+8|0;b=k[l>>2]|0;do if((g|0)>=(b|0)){if((g|0)==(b|0)?(k[i+(h*20|0)+4>>2]|0)<(k[i+(h*20|0)+12>>2]|0):0){N=364;break}if(f)N=366}else N=364;while(0);if((N|0)==364){N=0;if(!f)N=366}if((N|0)==366){N=0;g=e+-4|0;k[g>>2]=0-(k[g>>2]|0);g=k[j>>2]|0;b=k[l>>2]|0}f=(n|0)==(p|0);if((g|0)!=(b|0)&f){M=e+-4|0;k[M>>2]=0-(k[M>>2]|0)}do if((p|0)>=(n|0)){if(!f)break;b=e+-12|0;h=k[b>>2]|0;g=e+-20|0;f=k[g>>2]|0;if((h|0)<(f|0))N=373}else{f=e+-20|0;h=e+-12|0;b=h;g=f;h=k[h>>2]|0;f=k[f>>2]|0;N=373}while(0);if((N|0)==373){N=0;k[m>>2]=p;k[g>>2]=h;k[o>>2]=n;k[b>>2]=f}u=u+1|0;b=k[R>>2]|0;if(u>>>0>=((b-d|0)/20|0)>>>0){P=d;Q=b;break r}}if((N|0)==344)xa(1340,1363,303,1438);else if((N|0)==350){V=ya(4)|0;k[V>>2]=128;La(V|0,8,1)}}else{P=b;Q=b}while(0);b=P;if(P){if((Q|0)!=(P|0))k[R>>2]=Q+(~(((Q+-20-b|0)>>>0)/20|0)*20|0);$d(P)}b=k[S>>2]|0;d=b;if(b){e=k[T>>2]|0;if((e|0)!=(b|0))k[T>>2]=e+(~(((e+-20-d|0)>>>0)/20|0)*20|0);$d(b)}if(!U){r=V;return}$d(U);r=V;return}function Fb(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,l=0,m=0,n=0,o=0;m=a+4|0;e=k[m>>2]|0;n=k[a>>2]|0;j=n;l=(e-j|0)/20|0;i=l+1|0;if(i>>>0>214748364)xa(1340,1363,303,1438);o=a+8|0;c=((k[o>>2]|0)-j|0)/20|0;if(c>>>0<107374182){c=c<<1;c=c>>>0<i>>>0?i:c;if(!c){f=0;d=0}else g=5}else{c=214748364;g=5}if((g|0)==5){f=c*20|0;f=(f|0)==0?1:f;d=_d(f)|0;a:do if(!d){while(1){d=k[35]|0;k[35]=d+0;if(!d)break;Xa[d&0]();d=_d(f)|0;if(d)break a}a=ya(4)|0;k[a>>2]=128;La(a|0,8,1)}while(0);f=c}c=d+(l*20|0)|0;h=d+(f*20|0)|0;k[c>>2]=k[b>>2];k[d+(l*20|0)+4>>2]=k[b+4>>2];k[d+(l*20|0)+8>>2]=k[b+8>>2];k[d+(l*20|0)+12>>2]=k[b+12>>2];k[d+(l*20|0)+16>>2]=k[b+16>>2];g=d+(i*20|0)|0;if((e|0)!=(n|0)){f=e+-20|0;while(1){b=e;e=e+-20|0;k[c+-20>>2]=k[e>>2];k[c+-16>>2]=k[b+-16>>2];k[c+-12>>2]=k[b+-12>>2];k[c+-8>>2]=k[b+-8>>2];k[c+-4>>2]=k[b+-4>>2];if((e|0)==(n|0))break;else c=c+-20|0}c=d+((l+~(((f-j|0)>>>0)/20|0)|0)*20|0)|0}k[a>>2]=c;k[m>>2]=g;k[o>>2]=h;if(!n)return;$d(n);return}function Gb(a){a=a|0;if(!a)return;else{Gb(k[a>>2]|0);Gb(k[a+4>>2]|0);$d(a);return}}function Hb(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0;t=b;a:while(1){m=t;n=t+-8|0;o=t+-16|0;s=t+-4|0;y=a;b:while(1){l=y;a=m-l|0;b=a>>3;switch(b|0){case 2:{x=4;break a}case 3:{x=9;break a}case 4:{x=10;break a}case 5:{x=11;break a}case 1:case 0:{x=88;break a}default:{}}if((a|0)<56){x=13;break a}c=(b|0)/2|0;g=y+(c<<3)|0;if((a|0)>7992){a=(b|0)/4|0;a=Kb(y,y+(a<<3)|0,g,y+(a+c<<3)|0,n)|0}else a=Ib(y,g,n)|0;h=k[y>>2]|0;f=k[g>>2]|0;c:do if((h|0)<(f|0))c=n;else{if((h|0)==(f|0)?(k[y+4>>2]|0)>(k[y+(c<<3)+4>>2]|0):0){c=n;break}d:do if((y|0)!=(o|0)){e=y+(c<<3)+4|0;c=o;d=n;while(1){b=k[c>>2]|0;if((b|0)<(f|0)){x=58;break}if((b|0)==(f|0)?(p=d+-4|0,(k[p>>2]|0)>(k[e>>2]|0)):0){d=p;b=f;break}b=c+-8|0;if((y|0)==(b|0))break d;else{d=c;c=b}}if((x|0)==58){x=0;d=d+-4|0}i=y+4|0;j=k[i>>2]|0;k[y>>2]=b;k[i>>2]=k[d>>2];k[c>>2]=h;k[d>>2]=j;a=a+1|0;break c}while(0);a=y+8|0;f=k[n>>2]|0;do if((h|0)>=(f|0)){if((h|0)==(f|0)?(k[y+4>>2]|0)>(k[s>>2]|0):0)break;if((a|0)==(n|0)){x=88;break a}c=y+4|0;e=y;while(1){d=e+8|0;b=k[d>>2]|0;if((h|0)<(b|0)){x=40;break}if((h|0)==(b|0)?(q=e+12|0,r=k[q>>2]|0,(k[c>>2]|0)>(r|0)):0){c=q;a=h;b=r;break}b=a+8|0;if((b|0)==(n|0)){x=88;break a}else{e=a;a=b}}if((x|0)==40){x=0;l=e+12|0;c=l;a=b;b=k[l>>2]|0}k[d>>2]=f;k[c>>2]=k[s>>2];k[n>>2]=a;k[s>>2]=b;a=e+16|0}while(0);if((a|0)==(n|0)){x=88;break a}h=y+4|0;c=n;while(1){g=k[y>>2]|0;b=k[a>>2]|0;e:do if((g|0)<(b|0)){f=a;e=a}else while(1){if((g|0)==(b|0)?(k[h>>2]|0)>(k[a+4>>2]|0):0){f=a;b=g;e=a;break e}a=a+8|0;b=k[a>>2]|0;if((g|0)<(b|0)){f=a;e=a;break}}while(0);while(1){d=c+-8|0;a=k[d>>2]|0;if((g|0)<(a|0)){c=d;continue}if((g|0)!=(a|0))break;if((k[h>>2]|0)>(k[c+-4>>2]|0))c=d;else{a=g;break}}if(e>>>0>=d>>>0){y=e;continue b}j=e+4|0;l=k[j>>2]|0;k[f>>2]=a;a=c+-4|0;k[j>>2]=k[a>>2];k[d>>2]=b;k[a>>2]=l;a=e+8|0;c=d}}while(0);b=y+8|0;f:do if(b>>>0<c>>>0)while(1){i=k[g>>2]|0;f=g+4|0;j=b;while(1){b=k[j>>2]|0;if((b|0)>=(i|0)){if((b|0)!=(i|0))break;if((k[j+4>>2]|0)<=(k[f>>2]|0)){b=i;break}}j=j+8|0}d=c+-8|0;e=k[d>>2]|0;g:do if((e|0)<(i|0)){h=d;f=d}else while(1){if((e|0)==(i|0)?(k[c+-4>>2]|0)>(k[f>>2]|0):0){h=d;f=d;e=i;break g}c=d+-8|0;e=k[c>>2]|0;if((e|0)<(i|0)){h=c;f=c;c=d;break}else{h=d;d=c;c=h}}while(0);if(j>>>0>h>>>0){h=j;break f}d=j+4|0;i=k[d>>2]|0;k[j>>2]=e;c=c+-4|0;k[d>>2]=k[c>>2];k[f>>2]=b;k[c>>2]=i;b=j+8|0;c=h;g=(g|0)==(j|0)?h:g;a=a+1|0}else h=b;while(0);do if((h|0)!=(g|0)){e=k[g>>2]|0;f=k[h>>2]|0;if((e|0)>=(f|0)){if((e|0)!=(f|0))break;b=g+4|0;d=h+4|0;c=k[d>>2]|0;if((k[b>>2]|0)<=(c|0))break}else{c=h+4|0;b=g+4|0;d=c;c=k[c>>2]|0}k[h>>2]=e;k[d>>2]=k[b>>2];k[g>>2]=f;k[b>>2]=c;a=a+1|0}while(0);if(!a){a=Lb(y,h)|0;b=h+8|0;if(Lb(b,t)|0){x=83;break}if(a){y=b;continue}}j=h;if((j-l|0)>=(m-j|0)){x=87;break}Hb(y,h);y=h+8|0}if((x|0)==83){x=0;if(a){x=88;break}else{a=y;t=h;continue}}else if((x|0)==87){x=0;Hb(h+8|0,t);a=y;t=h;continue}}if((x|0)==4){c=t+-8|0;d=k[c>>2]|0;e=k[y>>2]|0;if((d|0)>=(e|0)){if((d|0)!=(e|0))return;a=y+4|0;b=k[a>>2]|0;if((k[s>>2]|0)<=(b|0))return}else{b=y+4|0;a=b;b=k[b>>2]|0}k[y>>2]=d;k[a>>2]=k[s>>2];k[c>>2]=e;k[s>>2]=b;return}else if((x|0)==9){Ib(y,y+8|0,n)|0;return}else if((x|0)==10){Jb(y,y+8|0,y+16|0,n)|0;return}else if((x|0)==11){Kb(y,y+8|0,y+16|0,y+24|0,n)|0;return}else if((x|0)==13){b=y+16|0;Ib(y,y+8|0,b)|0;a=y+24|0;if((a|0)==(t|0))return;while(1){h=k[a>>2]|0;e=k[b>>2]|0;if((h|0)>=(e|0)){if((h|0)==(e|0)?(u=a+4|0,v=k[u>>2]|0,w=b+4|0,(v|0)>(k[w>>2]|0)):0){d=u;c=w;i=v;x=18}}else{i=a+4|0;d=i;c=b+4|0;i=k[i>>2]|0;x=18}if((x|0)==18){x=0;k[a>>2]=e;k[d>>2]=k[c>>2];h:do if((b|0)!=(y|0)){f=b;while(1){b=f+-8|0;g=k[b>>2]|0;if((h|0)>=(g|0)){if((h|0)!=(g|0)){b=f;break h}e=f+-4|0;d=k[e>>2]|0;if((i|0)>(d|0))c=e;else{b=f;break h}}else{d=f+-4|0;c=d;d=k[d>>2]|0}k[f>>2]=g;k[f+4>>2]=d;if((b|0)==(y|0))break;else f=b}}while(0);k[b>>2]=h;k[c>>2]=i}b=a+8|0;if((b|0)==(t|0))break;else{s=a;a=b;b=s}}return}else if((x|0)==88)return}function Ib(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0,i=0;f=k[b>>2]|0;i=k[a>>2]|0;do if((f|0)<(i|0))d=1;else{if((f|0)==(i|0)?(k[b+4>>2]|0)>(k[a+4>>2]|0):0){d=1;break}d=0}while(0);g=k[c>>2]|0;do if((g|0)<(f|0))e=1;else{if((g|0)==(f|0)?(k[c+4>>2]|0)>(k[b+4>>2]|0):0){e=1;break}e=0}while(0);if(!d){if(!e){b=0;return b|0}h=b+4|0;i=k[h>>2]|0;k[b>>2]=g;g=c+4|0;k[h>>2]=k[g>>2];k[c>>2]=f;k[g>>2]=i;f=k[b>>2]|0;g=k[a>>2]|0;if((f|0)>=(g|0)){if((f|0)!=(g|0)){b=1;return b|0}d=a+4|0;e=k[d>>2]|0;if((k[h>>2]|0)<=(e|0)){b=1;return b|0}}else{e=a+4|0;d=e;e=k[e>>2]|0}k[a>>2]=f;k[d>>2]=k[h>>2];k[b>>2]=g;k[h>>2]=e;b=2;return b|0}d=a+4|0;h=k[d>>2]|0;if(e){k[a>>2]=g;b=c+4|0;k[d>>2]=k[b>>2];k[c>>2]=i;k[b>>2]=h;b=1;return b|0}k[a>>2]=f;f=b+4|0;k[d>>2]=k[f>>2];k[b>>2]=i;k[f>>2]=h;e=k[c>>2]|0;if((e|0)>=(i|0)){if((e|0)!=(i|0)){b=1;return b|0}d=c+4|0;if((k[d>>2]|0)<=(h|0)){b=1;return b|0}}else d=c+4|0;k[b>>2]=e;k[f>>2]=k[d>>2];k[c>>2]=i;k[d>>2]=h;b=2;return b|0}function Jb(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,l=0;l=Ib(a,b,c)|0;h=k[d>>2]|0;i=k[c>>2]|0;if((h|0)>=(i|0)){if((h|0)!=(i|0)){b=l;return b|0}f=d+4|0;g=c+4|0;e=k[g>>2]|0;if((k[f>>2]|0)>(e|0))j=g;else{b=l;return b|0}}else{e=c+4|0;f=d+4|0;j=e;e=k[e>>2]|0}k[c>>2]=h;k[j>>2]=k[f>>2];k[d>>2]=i;k[f>>2]=e;f=l+1|0;h=k[c>>2]|0;i=k[b>>2]|0;if((h|0)>=(i|0)){if((h|0)!=(i|0)){b=f;return b|0}g=b+4|0;e=k[g>>2]|0;if((k[j>>2]|0)>(e|0))d=g;else{b=f;return b|0}}else{e=b+4|0;d=e;e=k[e>>2]|0}k[b>>2]=h;k[d>>2]=k[j>>2];k[c>>2]=i;k[j>>2]=e;g=l+2|0;h=k[b>>2]|0;i=k[a>>2]|0;if((h|0)>=(i|0)){if((h|0)!=(i|0)){b=g;return b|0}f=a+4|0;e=k[f>>2]|0;if((k[d>>2]|0)<=(e|0)){b=g;return b|0}}else{e=a+4|0;f=e;e=k[e>>2]|0}k[a>>2]=h;k[f>>2]=k[d>>2];k[b>>2]=i;k[d>>2]=e;b=l+3|0;return b|0}function Kb(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0,j=0,l=0,m=0,n=0;n=Jb(a,b,c,d)|0;i=k[e>>2]|0;j=k[d>>2]|0;if((i|0)>=(j|0)){if((i|0)!=(j|0)){b=n;return b|0}g=e+4|0;h=d+4|0;f=k[h>>2]|0;if((k[g>>2]|0)>(f|0))m=h;else{b=n;return b|0}}else{f=d+4|0;g=e+4|0;m=f;f=k[f>>2]|0}k[d>>2]=i;k[m>>2]=k[g>>2];k[e>>2]=j;k[g>>2]=f;g=n+1|0;i=k[d>>2]|0;j=k[c>>2]|0;if((i|0)>=(j|0)){if((i|0)!=(j|0)){b=g;return b|0}h=c+4|0;f=k[h>>2]|0;if((k[m>>2]|0)>(f|0))l=h;else{b=g;return b|0}}else{f=c+4|0;l=f;f=k[f>>2]|0}k[c>>2]=i;k[l>>2]=k[m>>2];k[d>>2]=j;k[m>>2]=f;g=n+2|0;i=k[c>>2]|0;j=k[b>>2]|0;if((i|0)>=(j|0)){if((i|0)!=(j|0)){b=g;return b|0}h=b+4|0;f=k[h>>2]|0;if((k[l>>2]|0)>(f|0))e=h;else{b=g;return b|0}}else{f=b+4|0;e=f;f=k[f>>2]|0}k[b>>2]=i;k[e>>2]=k[l>>2];k[c>>2]=j;k[l>>2]=f;h=n+3|0;i=k[b>>2]|0;j=k[a>>2]|0;if((i|0)>=(j|0)){if((i|0)!=(j|0)){b=h;return b|0}g=a+4|0;f=k[g>>2]|0;if((k[e>>2]|0)<=(f|0)){b=h;return b|0}}else{f=a+4|0;g=f;f=k[f>>2]|0}k[a>>2]=i;k[g>>2]=k[e>>2];k[b>>2]=j;k[e>>2]=f;b=n+4|0;return b|0}function Lb(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0;switch(b-a>>3|0){case 2:{f=b+-8|0;g=k[f>>2]|0;h=k[a>>2]|0;if((g|0)>=(h|0)){if((g|0)!=(h|0)){a=1;return a|0}e=b+-4|0;c=a+4|0;d=k[c>>2]|0;if((k[e>>2]|0)<=(d|0)){a=1;return a|0}}else{d=a+4|0;c=d;e=b+-4|0;d=k[d>>2]|0}k[a>>2]=g;k[c>>2]=k[e>>2];k[f>>2]=h;k[e>>2]=d;a=1;return a|0}case 3:{Ib(a,a+8|0,b+-8|0)|0;a=1;return a|0}case 4:{Jb(a,a+8|0,a+16|0,b+-8|0)|0;a=1;return a|0}case 5:{Kb(a,a+8|0,a+16|0,a+24|0,b+-8|0)|0;a=1;return a|0}case 1:case 0:{a=1;return a|0}default:{e=a+16|0;Ib(a,a+8|0,e)|0;d=a+24|0;if((d|0)==(b|0)){a=1;return a|0}else c=0;while(1){l=k[d>>2]|0;h=k[e>>2]|0;if((l|0)>=(h|0)){if((l|0)==(h|0)?(n=d+4|0,o=k[n>>2]|0,p=e+4|0,(o|0)>(k[p>>2]|0)):0){f=p;g=n;m=o;q=15}}else{m=d+4|0;f=e+4|0;g=m;m=k[m>>2]|0;q=15}if((q|0)==15){q=0;k[d>>2]=h;k[g>>2]=k[f>>2];a:do if((e|0)!=(a|0)){j=e;while(1){e=j+-8|0;i=k[e>>2]|0;if((l|0)>=(i|0)){if((l|0)!=(i|0)){e=j;break a}h=j+-4|0;g=k[h>>2]|0;if((m|0)>(g|0))f=h;else{e=j;break a}}else{g=j+-4|0;f=g;g=k[g>>2]|0}k[j>>2]=i;k[j+4>>2]=g;if((e|0)==(a|0))break;else j=e}}while(0);k[e>>2]=l;k[f>>2]=m;c=c+1|0;if((c|0)==8)break}e=d+8|0;if((e|0)==(b|0)){c=1;q=24;break}else{m=d;d=e;e=m}}if((q|0)==24)return c|0;a=(d+8|0)==(b|0);return a|0}}return 0}function Mb(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,l=0,m=0,n=0,o=0,p=0;e=b;if(d>>>0<30|(b|0)==(c|0))return;l=(c-e|0)/12|0;m=(l>>>0)/3|0;j=b;f=e;g=e;e=0;h=d;i=0;while(1){if(i>>>0>=m>>>0){if((l-i|0)>>>0<m>>>0)break;o=k[j+4>>2]|0;n=o>>>0<h>>>0;f=n?g:f;e=n?i:e;h=n?o:h}g=j+12|0;if((g|0)==(c|0))break;else{j=g;i=i+1|0}}if(!e)return;e=k[f+4>>2]|0;if(e>>>0>((d>>>0)/9|0)>>>0)return;o=f+8|0;Mb(a,b,f,(k[o>>2]|0)+e|0);m=a+4|0;e=k[m>>2]|0;b=a+8|0;if((e|0)==(k[b>>2]|0)){n=k[a>>2]|0;i=e-n|0;j=i>>2;l=j+1|0;if(l>>>0>1073741823)xa(1340,1363,303,1438);if(j>>>0<536870911){e=i>>1;e=e>>>0<l>>>0?l:e;if(!e){e=0;g=0}else p=15}else{e=1073741823;p=15}if((p|0)==15){h=e<<2;h=(h|0)==0?1:h;g=_d(h)|0;a:do if(!g){while(1){g=k[35]|0;k[35]=g+0;if(!g)break;Xa[g&0]();g=_d(h)|0;if(g)break a}a=ya(4)|0;k[a>>2]=128;La(a|0,8,1)}while(0)}k[g+(j<<2)>>2]=k[f>>2];fe(g|0,n|0,i|0)|0;k[a>>2]=g;k[m>>2]=g+(l<<2);k[b>>2]=g+(e<<2);if(n)$d(n)}else{k[e>>2]=k[f>>2];k[m>>2]=e+4}Mb(a,f,c,d-(k[o>>2]|0)|0);return}function Nb(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0;h=(b|0)==(a|0);i[b+12>>0]=h&1;if(h)return;while(1){f=b+8|0;g=k[f>>2]|0;d=g+12|0;if(i[d>>0]|0){c=37;break}h=g+8|0;e=k[h>>2]|0;c=k[e>>2]|0;if((c|0)==(g|0)){c=k[e+4>>2]|0;if(!c){c=7;break}c=c+12|0;if(i[c>>0]|0){c=7;break}i[d>>0]=1;i[e+12>>0]=(e|0)==(a|0)&1;i[c>>0]=1}else{if(!c){c=24;break}c=c+12|0;if(i[c>>0]|0){c=24;break}i[d>>0]=1;i[e+12>>0]=(e|0)==(a|0)&1;i[c>>0]=1}if((e|0)==(a|0)){c=37;break}else b=e}if((c|0)==7){if((k[g>>2]|0)==(b|0)){b=g;a=e}else{f=g+4|0;b=k[f>>2]|0;c=k[b>>2]|0;k[f>>2]=c;if(!c)c=e;else{k[c+8>>2]=g;c=k[h>>2]|0}d=b+8|0;k[d>>2]=c;c=k[h>>2]|0;if((k[c>>2]|0)==(g|0))k[c>>2]=b;else k[c+4>>2]=b;k[b>>2]=g;k[h>>2]=b;a=k[d>>2]|0}i[b+12>>0]=1;i[a+12>>0]=0;d=k[a>>2]|0;e=d+4|0;b=k[e>>2]|0;k[a>>2]=b;if(b)k[b+8>>2]=a;b=a+8|0;k[d+8>>2]=k[b>>2];c=k[b>>2]|0;if((k[c>>2]|0)==(a|0))k[c>>2]=d;else k[c+4>>2]=d;k[e>>2]=a;k[b>>2]=d;return}else if((c|0)==24){if((k[g>>2]|0)==(b|0)){d=b+4|0;c=k[d>>2]|0;k[g>>2]=c;if(!c)c=e;else{k[c+8>>2]=g;c=k[h>>2]|0}k[f>>2]=c;c=k[h>>2]|0;if((k[c>>2]|0)==(g|0))k[c>>2]=b;else k[c+4>>2]=b;k[d>>2]=g;k[h>>2]=b;e=k[f>>2]|0}else b=g;i[b+12>>0]=1;i[e+12>>0]=0;h=e+4|0;d=k[h>>2]|0;b=k[d>>2]|0;k[h>>2]=b;if(b)k[b+8>>2]=e;b=e+8|0;k[d+8>>2]=k[b>>2];c=k[b>>2]|0;if((k[c>>2]|0)==(e|0))k[c>>2]=d;else k[c+4>>2]=d;k[d>>2]=e;k[b>>2]=d;return}else if((c|0)==37)return}function Ob(a){a=a|0;var b=0,c=0,d=0,e=0;if(!a)return;Ob(k[a>>2]|0);Ob(k[a+4>>2]|0);b=k[a+20>>2]|0;c=b;if(b){d=a+24|0;e=k[d>>2]|0;if((e|0)!=(b|0))k[d>>2]=e+(~(((e+-20-c|0)>>>0)/20|0)*20|0);$d(b)}$d(a);return}function Pb(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,l=0,m=0,n=0,o=0,p=0.0,q=0,s=0.0,t=0.0,u=0,v=0,w=0,x=0,y=0.0,z=0.0,A=0.0,B=0.0,C=0.0,D=0.0,E=0.0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0,ba=0,ca=0,da=0.0;ca=r;r=r+48|0;g=b;$=ca+40|0;X=ca+32|0;Z=ca+16|0;Y=ca;aa=ca+8|0;k[Z>>2]=0;ba=Z+4|0;k[ba>>2]=0;k[Z+8>>2]=0;f=c-g|0;do if((c|0)!=(b|0)){if(((f|0)/20|0)>>>0>214748364)xa(1340,1363,303,1438);e=_d(f)|0;a:do if(!e){while(1){e=k[35]|0;k[35]=e+0;if(!e)break;Xa[e&0]();e=_d(f)|0;if(e)break a}ca=ya(4)|0;k[ca>>2]=128;La(ca|0,8,1)}while(0);if((b|0)!=(c|0)){g=c+-20-g|0;f=e;while(1){k[f>>2]=k[b>>2];k[f+4>>2]=k[b+4>>2];k[f+8>>2]=k[b+8>>2];k[f+12>>2]=k[b+12>>2];k[f+16>>2]=k[b+16>>2];b=b+20|0;if((b|0)==(c|0))break;else f=f+20|0}q=e+((((g>>>0)/20|0)+1|0)*20|0)|0;g=(q|0)==(e|0);if(g){Qb(e,q);h=g;break}c=(q-e|0)/20|0;o=0;do{h=e+(o*20|0)+8|0;i=k[h>>2]|0;j=e+(o*20|0)|0;l=k[j>>2]|0;if((i|0)>=(l|0)){if((i|0)==(l|0)?(u=e+(o*20|0)+12|0,v=k[u>>2]|0,w=e+(o*20|0)+4|0,x=k[w>>2]|0,(v|0)<(x|0)):0){b=u;f=w;m=v;n=x;_=19}}else{n=e+(o*20|0)+4|0;m=e+(o*20|0)+12|0;b=m;f=n;m=k[m>>2]|0;n=k[n>>2]|0;_=19}if((_|0)==19){_=0;k[j>>2]=i;k[f>>2]=m;k[h>>2]=l;k[b>>2]=n}o=o+1|0}while(o>>>0<c>>>0);W=g;Qb(e,q);if(W)h=W;else{S=Z+8|0;T=Y+4|0;U=$+4|0;V=X+4|0;R=e;while(1){b=k[ba>>2]|0;f=k[S>>2]|0;if((b|0)==(f|0)){Rb(Z,R);b=k[ba>>2]|0;f=k[S>>2]|0}else{k[b>>2]=k[R>>2];k[b+4>>2]=k[R+4>>2];b=b+8|0;k[ba>>2]=b}Q=R+8|0;if((b|0)==(f|0))Rb(Z,Q);else{k[b>>2]=k[Q>>2];k[b+4>>2]=k[R+12>>2];k[ba>>2]=b+8}P=R+16|0;h=k[P>>2]|0;O=k[a>>2]|0;b=k[O+(h*12|0)>>2]|0;h=O+(h*12|0)+4|0;if((b|0)!=(h|0)){f=b;while(1){b=f+16|0;g=f+20|0;do if((k[g>>2]|0)>=(d|0)){c=k[ba>>2]|0;if((c|0)==(k[S>>2]|0)){Rb(Z,b);break}else{k[c>>2]=k[b>>2];k[c+4>>2]=k[g>>2];k[ba>>2]=c+8;break}}while(0);b=k[f+4>>2]|0;if(!b)while(1){b=k[f+8>>2]|0;if((k[b>>2]|0)==(f|0))break;else f=b}else while(1){f=k[b>>2]|0;if(!f)break;else b=f}if((b|0)==(h|0))break;else f=b}}L=R+4|0;if((k[L>>2]|0)<(d|0))O=0;else O=(k[R+12>>2]|0)>=(d|0);M=R+8|0;N=R+12|0;K=R;b:do{if(!O){if((k[K+4>>2]|0)>=(d|0)?(k[K+12>>2]|0)>=(d|0):0)_=46}else _=46;c:do if((_|0)==46){_=0;b=k[R>>2]|0;f=k[K>>2]|0;g=(b|0)==(f|0);if(((g?(k[L>>2]|0)==(k[K+4>>2]|0):0)?(k[M>>2]|0)==(k[K+8>>2]|0):0)?(k[N>>2]|0)==(k[K+12>>2]|0):0)break;J=K+8|0;c=k[J>>2]|0;h=k[Q>>2]|0;if((((c|0)<(f|0)?c:f)|0)>=(((h|0)<(b|0)?b:h)|0))break b;if(g?(k[L>>2]|0)==(k[K+4>>2]|0):0)break;if((h|0)==(c|0)?(k[N>>2]|0)==(k[K+12>>2]|0):0)break;I=Y;k[I>>2]=0;k[I+4>>2]=0;if(!(Sb(R,K)|0))break;b=k[R>>2]|0;h=k[M>>2]|0;g=k[L>>2]|0;n=k[N>>2]|0;m=(h|0)<(b|0);j=m?h:b;m=m?b:h;G=(n|0)<(g|0);x=G?n:g;G=G?g:n;o=k[K>>2]|0;c=k[J>>2]|0;H=K+4|0;u=k[H>>2]|0;I=K+12|0;v=k[I>>2]|0;l=(c|0)<(o|0);i=l?c:o;l=l?o:c;F=(v|0)<(u|0);w=F?v:u;F=F?u:v;d:do if((m|0)>=(i|0)&(j|0)<=(l|0)){if(!((x|0)<=(F|0)&(G|0)>=(w|0))){_=79;break}f=(c|0)==(o|0);do if((h|0)==(b|0)){if(f){_=79;break d}do if((v|0)==(u|0))g=u;else{p=+(o|0);s=+(u|0);t=+(b|0)-p;if(t==0.0){g=u;break}g=~~(s+(+(v|0)-s)*t/(+(c|0)-p))}while(0);if(!((x|0)<=(g|0)&(G|0)>=(g|0))){_=79;break d}k[Y>>2]=b;k[T>>2]=g}else{if(!f){z=+(v-u|0);A=+(n-g|0);y=+(c-o|0);p=+(h-b|0);s=z*p;t=A*y;if(s==t){_=79;break d}da=+(o|0);C=+(u|0);E=A*+(b|0);B=+(g|0)*p;D=(y*E-z*da*p+y*(C*p)-y*B)/(t-s);E=(z*(A*da)+(z*B-A*(C*y))-z*E)/(s-t);b=~~D;o=~~E;b=((D<+(b|0))<<31>>31)+b|0;g=(v|0)==(u|0)?u:(n|0)==(g|0)?g:((E<+(o|0))<<31>>31)+o|0;if(!((x|0)<=(g|0)&(((j|0)>(b|0)|(m|0)<(b|0)|(G|0)<(g|0))^1))){_=79;break d}if(!((w|0)<=(g|0)&(((i|0)>(b|0)|(l|0)<(b|0)|(F|0)<(g|0))^1))){_=79;break d}k[Y>>2]=b;k[T>>2]=g;break}do if((n|0)!=(g|0)){p=+(b|0);s=+(g|0);t=+(o|0)-p;if(t==0.0)break;g=~~(s+(+(n|0)-s)*t/(+(h|0)-p))}while(0);if(!((w|0)<=(g|0)&(F|0)>=(g|0))){_=79;break d}k[Y>>2]=o;k[T>>2]=g;b=o}while(0);k[$>>2]=b;k[U>>2]=g;if(!(Tb($,R)|0)){_=79;break}k[X>>2]=b;k[V>>2]=g;if(!(Tb(X,K)|0)){_=79;break}}else _=79;while(0);e:do if((_|0)==79){_=0;f:do if(Sb(R,K)|0){b=k[R>>2]|0;i=k[M>>2]|0;n=k[L>>2]|0;v=k[N>>2]|0;u=(b|0)>(i|0);o=u?i:b;u=u?b:i;G=(n|0)>(v|0);F=G?v:n;G=G?n:v;j=k[K>>2]|0;g=k[J>>2]|0;l=k[H>>2]|0;m=k[I>>2]|0;h=(j|0)>(g|0);c=h?g:j;h=h?j:g;x=(l|0)>(m|0);w=x?m:l;x=x?l:m;if(!((u|0)>=(c|0)&(o|0)<=(h|0)))break;if(!((F|0)<=(x|0)&(G|0)>=(w|0)))break;f=(j|0)==(g|0);do if((b|0)==(i|0)){if(f)break f;do if((l|0)==(m|0))p=+(l|0);else{t=+(j|0);p=+(l|0);s=+(b|0)-t;if(s==0.0)break;p=p+(+(m|0)-p)*s/(+(g|0)-t)}while(0);g=~~p;g=((p<+(g|0))<<31>>31)+g|0;if(!((G|0)>=(g|0)&(F|0)<=(g|0)))break f;k[Y>>2]=b;k[T>>2]=g}else{if(!f){B=+(l|0);C=+(m|0)-B;D=+(n|0);E=+(v|0)-D;A=+(j|0);z=+(g|0)-A;y=+(b|0);p=+(i|0)-y;s=C*p;t=z*E;if(s==t)break f;da=y*E;y=p*D;D=(da*z-A*C*p+z*(B*p)-z*y)/(t-s);da=(y*C-B*z*E+C*(E*A)-C*da)/(s-t);b=~~D;g=~~da;b=((D<+(b|0))<<31>>31)+b|0;g=(l|0)==(m|0)?l:(n|0)==(v|0)?n:((da<+(g|0))<<31>>31)+g|0;if(!((F|0)<=(g|0)&(((o|0)>(b|0)|(u|0)<(b|0)|(G|0)<(g|0))^1)))break f;if(!((w|0)<=(g|0)&(((c|0)>(b|0)|(h|0)<(b|0)|(x|0)<(g|0))^1)))break f;k[Y>>2]=b;k[T>>2]=g;break}do if((n|0)==(v|0))p=+(n|0);else{t=+(b|0);p=+(n|0);s=+(j|0)-t;if(s==0.0)break;p=p+(+(v|0)-p)*s/(+(i|0)-t)}while(0);g=~~p;g=((p<+(g|0))<<31>>31)+g|0;if(!((x|0)>=(g|0)&(w|0)<=(g|0)))break f;k[Y>>2]=j;k[T>>2]=g;b=j}while(0);break e}while(0);break c}while(0);f=k[ba>>2]|0;if((f|0)==(k[S>>2]|0))Rb(Z,Y);else{k[f>>2]=b;k[f+4>>2]=g;k[ba>>2]=f+8}Ub($,(k[a>>2]|0)+((k[K+16>>2]|0)*12|0)|0,Y);Ub($,(k[a>>2]|0)+((k[P>>2]|0)*12|0)|0,Y)}while(0);K=K+20|0}while((K|0)!=(q|0));R=R+20|0;if((R|0)==(q|0)){h=W;break}}}}else{b=e;_=11}}else{b=0;_=11}while(0);if((_|0)==11){Qb(b,b);h=(b|0)==(b|0);e=b;q=b}n=k[Z>>2]|0;o=k[ba>>2]|0;Vb(n,o);u=(n|0)==(o|0);g:do if(!u){b=n+8|0;if((b|0)==(o|0))m=o;else{f=b;b=n;while(1){if((k[b>>2]|0)==(k[b+8>>2]|0)?(k[b+4>>2]|0)==(k[b+12>>2]|0):0){_=114;break g}b=f+8|0;if((b|0)==(o|0)){m=o;break}else{Z=f;f=b;b=Z}}}}else{b=n;_=114}while(0);if((_|0)==114)if((b|0)==(o|0))m=o;else{f=b+16|0;if((f|0)!=(o|0)){c=b;b=b+8|0;while(1){g=k[f>>2]|0;if((k[c>>2]|0)==(g|0)){b=b+12|0;if((k[c+4>>2]|0)==(k[b>>2]|0))b=c;else _=120}else{b=b+12|0;_=120}if((_|0)==120){_=0;Z=c+8|0;k[Z>>2]=g;k[c+12>>2]=k[b>>2];b=Z}g=f+8|0;if((g|0)==(o|0))break;else{Z=f;f=g;c=b;b=Z}}}m=b+8|0}if(!h){i=aa+4|0;j=e;f=n;do{l=k[j+16>>2]|0;b=j+8|0;c=k[b>>2]|0;h=k[j>>2]|0;if((c|0)>=(h|0))if((c|0)==(h|0))g=(k[j+12>>2]|0)<(k[j+4>>2]|0)?b:j;else g=j;else g=b;g=k[g>>2]|0;if((h|0)>=(c|0))if((h|0)==(c|0))b=(k[j+4>>2]|0)<(k[j+12>>2]|0)?b:j;else b=j;c=k[b>>2]|0;b=f;h:do if((b|0)!=(m|0))do{if((k[b>>2]|0)>=(g|0))break h;b=b+8|0;f=b}while((b|0)!=(m|0));while(0);b=f;i:do if((b|0)!=(m|0))do{g=k[b>>2]|0;if((g|0)>(c|0))break i;k[aa>>2]=g;k[i>>2]=k[b+4>>2];if(Tb(aa,j)|0)Ub($,(k[a>>2]|0)+(l*12|0)|0,b);b=b+8|0}while((b|0)!=(m|0));while(0);j=j+20|0}while((j|0)!=(q|0))}if(e)$d(e);if(!n){r=ca;return}if(!u)k[ba>>2]=o+(~((o+-8-n|0)>>>3)<<3);$d(n);r=ca;return}\r\nfunction Jc(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0;L=r;r=r+176|0;D=L+72|0;E=L;K=L+40|0;B=L+104|0;F=L+168|0;G=L+164|0;H=L+160|0;I=a+16|0;c=k[I>>2]|0;k[K>>2]=k[c>>2];k[K+4>>2]=k[c+4>>2];k[K+8>>2]=k[c+8>>2];k[K+12>>2]=k[c+12>>2];k[K+16>>2]=k[c+16>>2];k[K+20>>2]=k[c+20>>2];k[K+24>>2]=k[c+24>>2];h=c+28|0;l=k[K>>2]|0;J=K+8|0;if((l|0)==(k[J>>2]|0)?(t=K+4|0,e=k[t>>2]|0,(e|0)==(k[K+12>>2]|0)):0){u=a+20|0;d=k[u>>2]|0;v=a+24|0;f=k[v>>2]|0;if((d|0)!=(f|0)?(w=a+64|0,x=a+72|0,y=a+68|0,(k[d>>2]|0)==(l|0)):0){c=f;while(1){l=d+4|0;if((k[l>>2]|0)!=(e|0))break;s=k[d+8>>2]|0;e=c-d|0;if((e|0)>12){f=(e|0)/12|0;m=c+-12|0;q=d;C=k[q>>2]|0;q=k[q+4>>2]|0;n=m;o=k[n+4>>2]|0;p=d;k[p>>2]=k[n>>2];k[p+4>>2]=o;k[m>>2]=C;k[m+4>>2]=q;m=d+8|0;q=c+-4|0;C=k[m>>2]|0;k[m>>2]=k[q>>2];k[q>>2]=C;q=f+-1|0;do if((e|0)>=36?(C=f+-3|0,z=(C|0)/2|0,(C|0)>=-1):0){c=d+12|0;e=c;do if((q|0)>2){f=d+24|0;g=k[f>>2]|0;c=k[c>>2]|0;if((g|0)==(c|0)){if((k[d+28>>2]|0)>=(k[d+16>>2]|0)){j=1;break}}else if((g|0)>=(c|0)){j=1;break}e=f;j=2}else j=1;while(0);c=e;f=k[d>>2]|0;g=k[c>>2]|0;if((f|0)==(g|0)){if((k[l>>2]|0)<(k[c+4>>2]|0))break}else if((f|0)<(g|0))break;o=d;n=k[o>>2]|0;o=k[o+4>>2]|0;p=k[m>>2]|0;g=e;l=k[g+4>>2]|0;C=d;k[C>>2]=k[g>>2];k[C+4>>2]=l;k[m>>2]=k[c+8>>2];a:do if((z|0)>=(j|0)){m=c;c=j;while(1){f=c<<1|1;c=d+(f*12|0)|0;g=c;l=f+1|0;do if((l|0)<(q|0)){e=d+(l*12|0)|0;j=k[e>>2]|0;c=k[c>>2]|0;if((j|0)==(c|0)){if((k[d+(l*12|0)+4>>2]|0)>=(k[d+(f*12|0)+4>>2]|0))break}else if((j|0)>=(c|0))break;g=e;f=l}while(0);c=g;e=k[c>>2]|0;if((n|0)==(e|0)){if((o|0)<(k[c+4>>2]|0)){c=m;break a}}else if((n|0)<(e|0)){c=m;break a}j=g;l=k[j+4>>2]|0;C=m;k[C>>2]=k[j>>2];k[C+4>>2]=l;k[m+8>>2]=k[c+8>>2];if((z|0)<(f|0))break;else{m=c;c=f}}}while(0);C=c;k[C>>2]=n;k[C+4>>2]=o;k[c+8>>2]=p}while(0);c=k[v>>2]|0}k[v>>2]=c+-12;e=s;c=k[e+4>>2]|0;if(!c){d=s;while(1){c=k[d+8>>2]|0;if((k[c>>2]|0)==(d|0))break;else d=c}}else while(1){d=k[c>>2]|0;if(!d)break;else c=d}if((k[w>>2]|0)==(e|0))k[w>>2]=c;k[x>>2]=(k[x>>2]|0)+-1;Mc(k[y>>2]|0,s);$d(s);d=k[u>>2]|0;c=k[v>>2]|0;if((d|0)==(c|0))break;if((k[d>>2]|0)!=(k[K>>2]|0))break;e=k[t>>2]|0}c=k[I>>2]|0}d=c;f=c}else A=3;b:do if((A|0)==3){j=k[a+8>>2]|0;if((h|0)==(j|0)){d=c;f=c}else{g=k[K+4>>2]|0;f=c;while(1){e=k[f+28>>2]|0;if((e|0)==(k[f+36>>2]|0)){d=k[f+32>>2]|0;if(!((e|0)==(l|0)?(d|0)!=(k[f+40>>2]|0):0)){d=c;f=c;break b}}else{if((e|0)!=(l|0)){d=c;f=c;break b}d=k[f+32>>2]|0}if((d|0)!=(g|0)){d=c;f=c;break b}d=h+28|0;if((d|0)==(j|0)){d=c;f=c;h=j;break}else{f=h;h=d}}}}while(0);k[B>>2]=k[d>>2];k[B+4>>2]=k[d+4>>2];k[B+8>>2]=k[d+8>>2];k[B+12>>2]=k[d+12>>2];k[B+16>>2]=k[d+16>>2];k[B+20>>2]=k[d+20>>2];k[B+24>>2]=k[d+24>>2];C=B+28|0;k[C>>2]=k[d>>2];k[C+4>>2]=k[d+4>>2];k[C+8>>2]=k[d+8>>2];k[C+12>>2]=k[d+12>>2];k[C+16>>2]=k[d+16>>2];k[C+20>>2]=k[d+20>>2];k[C+24>>2]=k[d+24>>2];C=a+68|0;c=k[C>>2]|0;c:do if(!c)d=C;else{e=C;while(1){d=c;while(1){if(!(cd(d+16|0,B)|0))break;c=k[d+4>>2]|0;if(!c){d=e;break c}else d=c}c=k[d>>2]|0;if(!c)break;else e=d}}while(0);if((f|0)==(h|0)){r=L;return}m=D+24|0;n=a+80|0;o=a+36|0;p=E+32|0;q=a+64|0;s=K+4|0;t=K+12|0;u=D+24|0;v=E+32|0;w=K+8|0;x=K+24|0;y=D+24|0;z=E+32|0;A=D+24|0;B=E+32|0;c=f;do{k[K>>2]=k[c>>2];k[K+4>>2]=k[c+4>>2];k[K+8>>2]=k[c+8>>2];k[K+12>>2]=k[c+12>>2];k[K+16>>2]=k[c+16>>2];k[K+20>>2]=k[c+20>>2];k[K+24>>2]=k[c+24>>2];e=d;do if((e|0)==(C|0)){e=d;c=k[e>>2]|0;if(!c)while(1){c=k[e+8>>2]|0;if((k[c>>2]|0)==(e|0))e=c;else break}else while(1){e=k[c+4>>2]|0;if(!e)break;else c=e}l=c+44|0;k[F>>2]=d;k[D>>2]=k[F>>2];e=dd(a,l,l,K,D,b)|0;d=e;i[m>>0]=1;if(Nc(n,c+16|0,l,K,D)|0){k[E>>2]=k[D>>2];k[E+4>>2]=k[D+4>>2];k[E+8>>2]=k[D+8>>2];k[E+12>>2]=k[D+12>>2];k[E+16>>2]=k[D+16>>2];k[E+20>>2]=k[D+20>>2];k[E+24>>2]=k[D+24>>2];k[E+28>>2]=k[D+28>>2];k[p>>2]=d;l=Oc(o,E)|0;k[e+72>>2]=l}}else{l=e+16|0;if((e|0)==(k[q>>2]|0)){k[G>>2]=d;k[D>>2]=k[G>>2];c=dd(a,l,l,K,D,b)|0;if(!((k[K>>2]|0)==(k[J>>2]|0)?(k[s>>2]|0)==(k[t>>2]|0):0)){g=K;f=k[g>>2]|0;g=k[g+4>>2]|0;N=w;M=k[N+4>>2]|0;j=K;k[j>>2]=k[N>>2];k[j+4>>2]=M;j=w;k[j>>2]=f;k[j+4>>2]=g;k[x>>2]=k[x>>2]^32}i[u>>0]=1;if(Nc(n,K,l,e+44|0,D)|0){k[E>>2]=k[D>>2];k[E+4>>2]=k[D+4>>2];k[E+8>>2]=k[D+8>>2];k[E+12>>2]=k[D+12>>2];k[E+16>>2]=k[D+16>>2];k[E+20>>2]=k[D+20>>2];k[E+24>>2]=k[D+24>>2];k[E+28>>2]=k[D+28>>2];k[v>>2]=d;N=Oc(o,E)|0;k[e+72>>2]=N}d=c;break}j=e+44|0;g=e+72|0;c=k[g>>2]|0;if(c){i[c+24>>0]=0;k[g>>2]=0}c=d;e=k[c>>2]|0;if(!e)while(1){e=k[c+8>>2]|0;if((k[e>>2]|0)==(c|0))c=e;else{c=e;break}}else{c=e;while(1){e=k[c+4>>2]|0;if(!e)break;else c=e}}N=c+44|0;k[H>>2]=d;k[D>>2]=k[H>>2];e=dd(a,N,l,K,D,b)|0;f=e;i[y>>0]=1;if(Nc(n,c+16|0,N,K,D)|0){k[E>>2]=k[D>>2];k[E+4>>2]=k[D+4>>2];k[E+8>>2]=k[D+8>>2];k[E+12>>2]=k[D+12>>2];k[E+16>>2]=k[D+16>>2];k[E+20>>2]=k[D+20>>2];k[E+24>>2]=k[D+24>>2];k[E+28>>2]=k[D+28>>2];k[z>>2]=f;N=Oc(o,E)|0;k[e+72>>2]=N}if(!((k[K>>2]|0)==(k[J>>2]|0)?(k[s>>2]|0)==(k[t>>2]|0):0)){M=K;e=k[M>>2]|0;M=k[M+4>>2]|0;O=w;c=k[O+4>>2]|0;N=K;k[N>>2]=k[O>>2];k[N+4>>2]=c;N=w;k[N>>2]=e;k[N+4>>2]=M;k[x>>2]=k[x>>2]^32}i[A>>0]=1;if(Nc(n,K,l,j,D)|0){k[E>>2]=k[D>>2];k[E+4>>2]=k[D+4>>2];k[E+8>>2]=k[D+8>>2];k[E+12>>2]=k[D+12>>2];k[E+16>>2]=k[D+16>>2];k[E+20>>2]=k[D+20>>2];k[E+24>>2]=k[D+24>>2];k[E+28>>2]=k[D+28>>2];k[B>>2]=d;O=Oc(o,E)|0;k[g>>2]=O}d=f}while(0);c=(k[I>>2]|0)+28|0;k[I>>2]=c}while((c|0)!=(h|0));r=L;return}function Kc(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,j=0,l=0,m=0,n=0,o=0,q=0.0,s=0.0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0;J=r;r=r+144|0;E=J+72|0;F=J+32|0;I=J;H=J+104|0;G=a+36|0;h=k[k[G>>2]>>2]|0;A=k[h+40>>2]|0;B=A;y=B+44|0;k[I>>2]=k[y>>2];k[I+4>>2]=k[y+4>>2];k[I+8>>2]=k[y+8>>2];k[I+12>>2]=k[y+12>>2];k[I+16>>2]=k[y+16>>2];k[I+20>>2]=k[y+20>>2];k[I+24>>2]=k[y+24>>2];y=k[B+76>>2]|0;z=A;c=k[z>>2]|0;if(!c){d=z;while(1){c=k[d+8>>2]|0;if((k[c>>2]|0)==(d|0))d=c;else break}}else while(1){d=k[c+4>>2]|0;if(!d)break;else c=d}C=c;d=c+16|0;D=c+72|0;w=D+4|0;x=k[w>>2]|0;k[H>>2]=k[d>>2];k[H+4>>2]=k[d+4>>2];k[H+8>>2]=k[d+8>>2];k[H+12>>2]=k[d+12>>2];k[H+16>>2]=k[d+16>>2];k[H+20>>2]=k[d+20>>2];k[H+24>>2]=k[d+24>>2];d=k[H>>2]|0;u=H+8|0;do if((d|0)==(k[u>>2]|0)?(g=k[H+4>>2]|0,(g|0)==(k[H+12>>2]|0)):0){e=k[I+8>>2]|0;if((k[I>>2]|0)==(e|0)?(k[I+4>>2]|0)==(k[I+12>>2]|0):0)break;f=I+8|0;if((e|0)==(d|0)?(k[I+12>>2]|0)==(g|0):0){o=I;n=k[o>>2]|0;o=k[o+4>>2]|0;l=f;m=k[l+4>>2]|0;t=I;k[t>>2]=k[l>>2];k[t+4>>2]=m;t=f;k[t>>2]=n;k[t+4>>2]=o;t=I+24|0;k[t>>2]=k[t>>2]^32}}while(0);m=c+44|0;k[m>>2]=k[I>>2];k[m+4>>2]=k[I+4>>2];k[m+8>>2]=k[I+8>>2];k[m+12>>2]=k[I+12>>2];k[m+16>>2]=k[I+16>>2];k[m+20>>2]=k[I+20>>2];k[m+24>>2]=k[I+24>>2];s=+p[h+8>>3];q=+p[h+16>>3];m=b+16|0;d=k[m>>2]|0;n=b+20|0;e=k[n>>2]|0;if(d>>>0>=e>>>0){o=b+12|0;t=k[o>>2]|0;f=t;j=d-f|0;l=(j|0)/24|0;h=l+1|0;if(h>>>0>178956970)xa(1340,1363,303,1438);d=(e-f|0)/24|0;if(d>>>0<89478485){g=d<<1;g=g>>>0<h>>>0?h:g}else g=178956970;f=g*24|0;f=(f|0)==0?1:f;e=_d(f)|0;a:do if(!e){while(1){d=k[35]|0;k[35]=d+0;if(!d)break;Xa[d&0]();e=_d(f)|0;if(e)break a}J=ya(4)|0;k[J>>2]=128;La(J|0,8,1)}while(0);p[e+(l*24|0)>>3]=s;p[e+(l*24|0)+8>>3]=q;k[e+(l*24|0)+16>>2]=0;k[e+(l*24|0)+20>>2]=0;d=e+(h*24|0)|0;l=e+((((j|0)/-24|0)+l|0)*24|0)|0;fe(l|0,t|0,j|0)|0;k[o>>2]=l;k[m>>2]=d;k[n>>2]=e+(g*24|0);if(t){$d(t);d=k[m>>2]|0}}else{p[d>>3]=s;p[d+8>>3]=q;k[d+16>>2]=0;k[d+20>>2]=0;d=(k[m>>2]|0)+24|0;k[m>>2]=d}t=d+-24|0;k[x+4>>2]=t;k[y+4>>2]=t;o=k[H>>2]|0;l=k[u>>2]|0;h=(o|0)==(l|0);if(h)f=(k[H+4>>2]|0)!=(k[H+12>>2]|0);else f=1;m=k[I>>2]|0;n=k[I+8>>2]|0;j=(m|0)==(n|0);do if(j){e=k[I+4>>2]|0;d=(e|0)!=(k[I+12>>2]|0);if(!(d|f^1)){if((o|0)==(m|0)?(k[H+4>>2]|0)==(e|0):0){g=1;break}if((l|0)==(m|0)?(k[H+12>>2]|0)==(e|0):0)g=1;else v=36}else v=31}else{d=1;v=31}while(0);do if((v|0)==31)if(!(f|d^1)){if((m|0)==(o|0)?(k[I+4>>2]|0)==(k[H+4>>2]|0):0){g=1;break}if((n|0)==(o|0)?(k[I+12>>2]|0)==(k[H+4>>2]|0):0)g=1;else v=36}else v=36;while(0);if((v|0)==36){if(h)d=(k[H+4>>2]|0)!=(k[H+12>>2]|0);else d=1;if(j)e=(k[I+4>>2]|0)!=(k[I+12>>2]|0);else e=1;g=d^e^1}if(h)f=(k[H+4>>2]|0)!=(k[H+12>>2]|0);else f=1;do if(j){e=k[I+4>>2]|0;d=(e|0)!=(k[I+12>>2]|0);if(!(d|f^1)){if((o|0)==(m|0)?(k[H+4>>2]|0)==(e|0):0){d=0;break}if((l|0)==(m|0))d=(k[H+12>>2]|0)!=(e|0);else d=1}else v=49}else{d=1;v=49}while(0);do if((v|0)==49)if(!(f|d^1)){if((m|0)==(o|0)?(k[I+4>>2]|0)==(k[H+4>>2]|0):0){d=0;break}if((n|0)==(o|0))d=(k[I+12>>2]|0)!=(k[H+4>>2]|0);else d=1}else d=1;while(0);l=b+24|0;e=g&1;e=d?e|2:e;k[E>>2]=0;k[E+4>>2]=0;k[E+8>>2]=0;k[E+12>>2]=0;k[E+16>>2]=0;k[E+20>>2]=e;f=b+28|0;d=k[f>>2]|0;g=b+32|0;if(d>>>0<(k[g>>2]|0)>>>0){k[d>>2]=k[E>>2];k[d+4>>2]=k[E+4>>2];k[d+8>>2]=k[E+8>>2];k[d+12>>2]=k[E+12>>2];k[d+16>>2]=k[E+16>>2];k[d+20>>2]=k[E+20>>2];j=(k[f>>2]|0)+24|0;k[f>>2]=j}else{bd(l,E);j=k[f>>2]|0}h=j+-24|0;k[h>>2]=(k[b>>2]|0)+((k[H+16>>2]|0)*12|0);k[F>>2]=0;k[F+4>>2]=0;k[F+8>>2]=0;k[F+12>>2]=0;k[F+16>>2]=0;k[F+20>>2]=e;if(j>>>0<(k[g>>2]|0)>>>0){k[j>>2]=k[F>>2];k[j+4>>2]=k[F+4>>2];k[j+8>>2]=k[F+8>>2];k[j+12>>2]=k[F+12>>2];k[j+16>>2]=k[F+16>>2];k[j+20>>2]=k[F+20>>2];d=(k[f>>2]|0)+24|0;k[f>>2]=d}else{bd(l,F);d=k[f>>2]|0}v=d+-24|0;k[v>>2]=(k[b>>2]|0)+((k[I+16>>2]|0)*12|0);k[j+-16>>2]=v;k[d+-16>>2]=h;k[d+-20>>2]=t;k[x+16>>2]=h;k[j+-12>>2]=x;j=k[x+8>>2]|0;k[j+12>>2]=y;k[y+16>>2]=j;j=k[y+8>>2]|0;k[j+12>>2]=v;k[d+-8>>2]=j;k[w>>2]=h;j=a+64|0;d=k[B+4>>2]|0;if(!d){e=z;while(1){d=k[e+8>>2]|0;if((k[d>>2]|0)==(e|0))break;else e=d}}else while(1){e=k[d>>2]|0;if(!e)break;else d=e}if((k[j>>2]|0)==(B|0))k[j>>2]=d;e=a+72|0;k[e>>2]=(k[e>>2]|0)+-1;Mc(k[a+68>>2]|0,z);$d(A);e=k[G>>2]|0;g=k[e>>2]|0;h=a+40|0;d=k[h>>2]|0;f=d-e|0;if((f|0)>4){d=d+-4|0;k[e>>2]=k[d>>2];k[d>>2]=g;Lc(e,(f>>2)+-1|0,e);d=k[h>>2]|0}k[h>>2]=d+-4;B=g+4|0;A=k[g>>2]|0;k[A+4>>2]=k[B>>2];k[k[B>>2]>>2]=A;B=a+60|0;k[B>>2]=(k[B>>2]|0)+-1;$d(g);if((c|0)!=(k[j>>2]|0)){d=k[D>>2]|0;if(d){i[d+24>>0]=0;k[D>>2]=0}d=k[c>>2]|0;if(!d){e=c;while(1){d=k[e+8>>2]|0;if((k[d>>2]|0)==(e|0))e=d;else break}}else while(1){e=k[d+4>>2]|0;if(!e)break;else d=e}i[E+24>>0]=1;if(Nc(a+80|0,d+16|0,H,I,E)|0){k[F>>2]=k[E>>2];k[F+4>>2]=k[E+4>>2];k[F+8>>2]=k[E+8>>2];k[F+12>>2]=k[E+12>>2];k[F+16>>2]=k[E+16>>2];k[F+20>>2]=k[E+20>>2];k[F+24>>2]=k[E+24>>2];k[F+28>>2]=k[E+28>>2];k[F+32>>2]=C;C=Oc(G,F)|0;k[D>>2]=C}}d=k[c+4>>2]|0;if(!d)while(1){d=k[c+8>>2]|0;if((k[d>>2]|0)==(c|0)){c=d;break}else c=d}else{c=d;while(1){d=k[c>>2]|0;if(!d)break;else c=d}}if((c|0)==(a+68|0)){r=J;return}d=c+72|0;e=k[d>>2]|0;if(e){i[e+24>>0]=0;k[d>>2]=0}i[E+24>>0]=1;if(Nc(a+80|0,H,I,c+44|0,E)|0){k[F>>2]=k[E>>2];k[F+4>>2]=k[E+4>>2];k[F+8>>2]=k[E+8>>2];k[F+12>>2]=k[E+12>>2];k[F+16>>2]=k[E+16>>2];k[F+20>>2]=k[E+20>>2];k[F+24>>2]=k[E+24>>2];k[F+28>>2]=k[E+28>>2];k[F+32>>2]=c;a=Oc(G,F)|0;k[d>>2]=a}r=J;return}function Lc(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0.0,h=0.0,i=0,j=0,l=0,m=0.0,n=0,o=0,q=0;d=c-a|0;if((b|0)<2)return;q=(b+-2|0)/2|0;if((q|0)<(d>>2|0))return;l=d>>1|1;f=a+(l<<2)|0;d=f;e=l+1|0;do if((e|0)<(b|0)){j=a+(e<<2)|0;f=k[f>>2]|0;i=k[j>>2]|0;g=+p[i+24>>3];h=+p[f+24>>3];if(g!=h){if(!(g<h)){e=l;break}}else if(!(+p[i+16>>3]<+p[f+16>>3])){e=l;break}d=j}else e=l;while(0);f=k[d>>2]|0;i=k[c>>2]|0;g=+p[i+24>>3];h=+p[f+24>>3];o=i;if(g!=h){if(g<h)return}else if(+p[i+16>>3]<+p[f+16>>3])return;n=i+16|0;k[c>>2]=k[d>>2];a:do if((q|0)>=(e|0)){m=+p[i+24>>3];while(1){e=e<<1|1;i=a+(e<<2)|0;f=i;c=e+1|0;do if((c|0)<(b|0)){l=a+(c<<2)|0;i=k[i>>2]|0;j=k[l>>2]|0;g=+p[j+24>>3];h=+p[i+24>>3];if(g!=h){if(!(g<h))break}else if(!(+p[j+16>>3]<+p[i+16>>3]))break;f=l;e=c}while(0);i=k[f>>2]|0;g=+p[i+24>>3];if(m!=g){if(m<g)break a}else if(+p[n>>3]<+p[i+16>>3])break a;k[d>>2]=k[f>>2];if((q|0)<(e|0)){d=f;break}else d=f}}while(0);k[d>>2]=o;return}function Mc(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,j=0,l=0,m=0,n=0,o=0;d=k[b>>2]|0;if(d){c=k[b+4>>2]|0;if(!c){e=b;c=b;h=6}else while(1){d=k[c>>2]|0;if(!d){h=4;break}else c=d}}else{c=b;h=4}if((h|0)==4){d=k[c+4>>2]|0;if(!d){l=c+8|0;e=c;d=0;m=0;j=c}else{e=c;h=6}}if((h|0)==6){l=e+8|0;k[d+8>>2]=k[l>>2];m=1;j=c}c=k[l>>2]|0;f=k[c>>2]|0;if((f|0)==(e|0)){k[c>>2]=d;if((e|0)==(a|0)){a=d;f=0}else f=k[c+4>>2]|0}else k[c+4>>2]=d;g=e+12|0;h=(i[g>>0]|0)!=0;if((e|0)!=(b|0)){o=b+8|0;c=k[o>>2]|0;k[l>>2]=c;if((k[k[o>>2]>>2]|0)==(b|0))k[c>>2]=e;else k[c+4>>2]=e;c=k[b>>2]|0;k[j>>2]=c;k[c+8>>2]=e;c=k[b+4>>2]|0;k[e+4>>2]=c;if(c)k[c+8>>2]=e;i[g>>0]=i[b+12>>0]|0;a=(a|0)==(b|0)?e:a}if(!(h&(a|0)!=0))return;if(m){i[d+12>>0]=1;return}else g=f;while(1){f=g+8|0;h=k[f>>2]|0;c=g+12|0;d=(i[c>>0]|0)!=0;if((k[h>>2]|0)==(g|0)){if(!d){i[c>>0]=1;i[h+12>>0]=0;e=g+4|0;c=k[e>>2]|0;k[h>>2]=c;if(c)k[c+8>>2]=h;d=h+8|0;k[f>>2]=k[d>>2];c=k[d>>2]|0;if((k[c>>2]|0)==(h|0))k[c>>2]=g;else k[c+4>>2]=g;k[e>>2]=h;k[d>>2]=g;a=(a|0)==(h|0)?g:a;g=k[h>>2]|0}e=k[g>>2]|0;f=(e|0)==0;if(!f?(i[e+12>>0]|0)==0:0){c=e;a=g;h=76;break}c=g+4|0;d=k[c>>2]|0;if((d|0)!=0?(i[d+12>>0]|0)==0:0){h=67;break}i[g+12>>0]=0;c=k[g+8>>2]|0;d=c+12|0;if((c|0)==(a|0)|(i[d>>0]|0)==0){h=64;break}o=k[c+8>>2]|0;c=(k[o>>2]|0)==(c|0)?o+4|0:o}else{if(d)f=g;else{i[c>>0]=1;i[h+12>>0]=0;o=h+4|0;e=k[o>>2]|0;c=k[e>>2]|0;k[o>>2]=c;if(c)k[c+8>>2]=h;c=h+8|0;k[e+8>>2]=k[c>>2];d=k[c>>2]|0;if((k[d>>2]|0)==(h|0))k[d>>2]=e;else k[d+4>>2]=e;k[e>>2]=h;k[c>>2]=e;f=k[g>>2]|0;a=(a|0)==(f|0)?g:a;f=k[f+4>>2]|0}c=k[f>>2]|0;if((c|0)!=0?(n=c+12|0,(i[n>>0]|0)==0):0){h=37;break}c=k[f+4>>2]|0;if((c|0)!=0?(i[c+12>>0]|0)==0:0){a=c;c=f;h=46;break}i[f+12>>0]=0;c=k[f+8>>2]|0;if((c|0)==(a|0)){h=35;break}if(!(i[c+12>>0]|0)){a=c;h=35;break}o=k[c+8>>2]|0;c=(k[o>>2]|0)==(c|0)?o+4|0:o}g=k[c>>2]|0}do if((h|0)==35){i[a+12>>0]=1;return}else if((h|0)==37){a=k[f+4>>2]|0;if(!a)a=n;else{if(!(i[a+12>>0]|0)){c=f;h=46;break}a=c+12|0}i[a>>0]=1;i[f+12>>0]=0;e=c+4|0;a=k[e>>2]|0;k[f>>2]=a;if(a)k[a+8>>2]=f;a=f+8|0;k[c+8>>2]=k[a>>2];d=k[a>>2]|0;if((k[d>>2]|0)==(f|0))k[d>>2]=c;else k[d+4>>2]=c;k[e>>2]=f;k[a>>2]=c;a=f;h=46}else if((h|0)==64){i[d>>0]=1;return}else if((h|0)==67){if(!f){if(!(i[e+12>>0]|0)){c=e;a=g;h=76;break}d=g+4|0;c=d;d=k[d>>2]|0}i[d+12>>0]=1;i[g+12>>0]=0;a=k[d>>2]|0;k[c>>2]=a;if(a)k[a+8>>2]=g;a=g+8|0;k[d+8>>2]=k[a>>2];c=k[a>>2]|0;if((k[c>>2]|0)==(g|0))k[c>>2]=d;else k[c+4>>2]=d;k[d>>2]=g;k[a>>2]=d;c=g;a=d;h=76}while(0);if((h|0)==46){e=k[c+8>>2]|0;o=e+12|0;i[c+12>>0]=i[o>>0]|0;i[o>>0]=1;i[a+12>>0]=1;o=e+4|0;d=k[o>>2]|0;a=k[d>>2]|0;k[o>>2]=a;if(a)k[a+8>>2]=e;a=e+8|0;k[d+8>>2]=k[a>>2];c=k[a>>2]|0;if((k[c>>2]|0)==(e|0))k[c>>2]=d;else k[c+4>>2]=d;k[d>>2]=e;k[a>>2]=d;return}else if((h|0)==76){f=k[a+8>>2]|0;d=f+12|0;i[a+12>>0]=i[d>>0]|0;i[d>>0]=1;i[c+12>>0]=1;d=k[f>>2]|0;e=d+4|0;a=k[e>>2]|0;k[f>>2]=a;if(a)k[a+8>>2]=f;a=f+8|0;k[d+8>>2]=k[a>>2];c=k[a>>2]|0;if((k[c>>2]|0)==(f|0))k[c>>2]=d;else k[c+4>>2]=d;k[e>>2]=f;k[a>>2]=d;return}}function Nc(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;var f=0,g=0,h=0,j=0,l=0,m=0.0,n=0.0,o=0.0,q=0.0,s=0.0,u=0.0,v=0.0,w=0.0,x=0.0,y=0.0,z=0.0,A=0.0,B=0.0,C=0.0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,M=0,N=0.0,O=0.0,P=0,Q=0,R=0,S=0,T=0,U=0,V=0,W=0,Y=0,Z=0,_=0,$=0,aa=0,ba=0,ca=0,da=0,ea=0,fa=0,ga=0,ha=0.0,ia=0,ja=0.0,ka=0.0,la=0,ma=0.0,na=0.0,oa=0.0,pa=0.0,qa=0.0,ra=0.0,sa=0.0,ta=0.0,ua=0.0,va=0.0,wa=0.0,xa=0.0,ya=0,za=0,Aa=0,Ba=0,Ca=0,Da=0,Ea=0,Fa=0,Ga=0,Ha=0,Ia=0,Ja=0,Ka=0,La=0,Ma=0,Na=0,Oa=0,Pa=0,Qa=0,Ra=0,Sa=0,Ta=0,Ua=0,Va=0,Wa=0,Xa=0,Ya=0,Za=0,_a=0,$a=0,ab=0,bb=0,cb=0,db=0,eb=0,fb=0,gb=0,hb=0;gb=r;r=r+11200|0;Na=gb+10416|0;Oa=gb+9376|0;Ma=gb+8336|0;Ea=gb+8072|0;Fa=gb+7812|0;Xa=gb+7552|0;Ga=gb+7292|0;Ha=gb+7032|0;Ya=gb+6772|0;Ia=gb+792|0;Ja=gb+6512|0;Za=gb+6252|0;Ka=gb+5992|0;La=gb+528|0;Wa=gb+5732|0;Pa=gb+5472|0;Qa=gb+5212|0;Ra=gb+4952|0;Sa=gb+4692|0;Ua=gb+264|0;Va=gb;_a=gb+3912|0;Ta=gb+3132|0;Z=gb+2872|0;_=gb+2612|0;$=gb+2352|0;aa=gb+2092|0;ca=gb+1832|0;ba=gb+1572|0;fa=gb+1312|0;ga=gb+1052|0;U=k[b>>2]|0;$a=b+8|0;T=k[$a>>2]|0;if((U|0)==(T|0))f=(k[b+4>>2]|0)!=(k[b+12>>2]|0);else f=1;V=k[c>>2]|0;cb=c+8|0;S=k[cb>>2]|0;if((V|0)==(S|0))g=(k[c+4>>2]|0)!=(k[c+12>>2]|0);else g=1;ea=k[d>>2]|0;fb=d+8|0;da=k[fb>>2]|0;if((ea|0)==(da|0))h=(k[d+4>>2]|0)!=(k[d+12>>2]|0);else h=1;do if(!f){if(g){if(h)if((k[c+16>>2]|0)==(k[d+16>>2]|0)){e=0;r=gb;return e|0}else{Rc(a+4|0,b,c,d,1,e);break}if(((V|0)==(U|0)?((S|0)==(ea|0)?(k[c+4>>2]|0)==(k[b+4>>2]|0):0):0)?(k[c+12>>2]|0)==(k[d+4>>2]|0):0){e=0;r=gb;return e|0}Qc(a+4|0,b,d,c,2,e);break}D=b+4|0;f=k[D>>2]|0;G=c+4|0;j=k[G>>2]|0;P=d+4|0;l=k[P>>2]|0;g=Pc(U,f,V,j,ea,l)|0;if(h){f=Pc(U,f,V,j,da,k[d+12>>2]|0)|0;if((V|0)<(U|0)){if((g|0)!=-1&(f|0)!=-1){e=0;r=gb;return e|0}}else if((f|0)!=-1){e=0;r=gb;return e|0}Qc(a+4|0,b,c,d,3,e);break}if((g|0)!=-1){e=0;r=gb;return e|0}v=+(U|0);w=+(V|0);O=v-w;q=+(ea|0);ha=w-q;s=+(f|0);n=+(j|0);ja=s-n;u=+(l|0);ka=n-u;Ba=((V|0)<0)<<31>>31;g=be(U|0,((U|0)<0)<<31>>31|0,V|0,Ba|0)|0;Ca=L;Ba=be(V|0,Ba|0,ea|0,((ea|0)<0)<<31>>31|0)|0;h=L;da=((j|0)<0)<<31>>31;za=be(f|0,((f|0)<0)<<31>>31|0,j|0,da|0)|0;Aa=L;da=be(j|0,da|0,l|0,((l|0)<0)<<31>>31|0)|0;ea=L;Da=(Ca|0)<0;la=be(0,0,g|0,Ca|0)|0;f=Da?L:Ca;Ca=(h|0)<0;j=be(0,0,Ba|0,h|0)|0;h=Ca?L:h;l=(Aa|0)<0;ya=be(0,0,za|0,Aa|0)|0;Aa=l?L:Aa;a=(ea|0)<0;Y=be(0,0,da|0,ea|0)|0;f=ne((a?Y:da)|0,(a?L:ea)|0,(Da?la:g)|0,f|0)|0;g=L;h=ne((l?ya:za)|0,Aa|0,(Ca?j:Ba)|0,h|0)|0;j=L;l=Ca^l;do if(Da^a){if(!l){a=ge(f|0,g|0,h|0,j|0)|0;m=-(+(a>>>0)+4294967296.0*+(L>>>0));break}if(g>>>0>j>>>0|(g|0)==(j|0)&f>>>0>h>>>0){a=be(f|0,g|0,h|0,j|0)|0;m=-(+(a>>>0)+4294967296.0*+(L>>>0));break}else{a=be(h|0,j|0,f|0,g|0)|0;m=+(a>>>0)+4294967296.0*+(L>>>0);break}}else{if(l){a=ge(f|0,g|0,h|0,j|0)|0;m=+(a>>>0)+4294967296.0*+(L>>>0);break}if(g>>>0<j>>>0|(g|0)==(j|0)&f>>>0<h>>>0){a=be(h|0,j|0,f|0,g|0)|0;m=-(+(a>>>0)+4294967296.0*+(L>>>0));break}else{a=be(f|0,g|0,h|0,j|0)|0;m=+(a>>>0)+4294967296.0*+(L>>>0);break}}while(0);ma=.5/m;x=w+q;o=s+n;y=n+u;C=v-q;B=s-u;z=O*(v+w);m=ka*z;if(m<0.0){n=0.0-m;if(m>0.0){m=(m*2.0+0.0)/n;m=m<0.0?-m:m}else m=2.0;u=0.0;v=0.0;q=m+1.0}else{u=m+0.0;v=3.0;n=0.0;q=0.0}A=ja*o;m=ka*A;do if(m<0.0){o=n-m;if(m>0.0|n<0.0){m=(m*2.0+n*q)/o;m=m<0.0?-m:m}else m=q<2.0?2.0:q;n=o;q=m+1.0}else{o=m+u;if(u<0.0?m>0.0|u>0.0:0){v=(u*v-m*2.0)/o;u=o;v=(v<0.0?-v:v)+1.0;break}u=o;v=v<2.0?3.0:v+1.0}while(0);w=ha*x;o=ja*w;do if(o<0.0){s=u-o;if(o>0.0|u<0.0){m=(o*2.0+u*v)/s;m=m<0.0?-m:m}else m=v<2.0?2.0:v;v=m+1.0}else{m=o+n;if(n<0.0?o>0.0|n>0.0:0){q=(n*q-o*2.0)/m;n=m;q=(q<0.0?-q:q)+1.0;s=u;break}n=m;q=q<2.0?3.0:q+1.0;s=u}while(0);y=ka*y;o=ja*y;do if(o<0.0){u=s-o;if(o>0.0|s<0.0){m=(o*2.0+s*v)/u;m=m<0.0?-m:m}else m=v<2.0?2.0:v;N=n;s=u;v=m+1.0}else{m=o+n;if(n<0.0?o>0.0|n>0.0:0){q=(n*q-o*2.0)/m;N=m;q=(q<0.0?-q:q)+1.0;break}N=m;q=q<2.0?3.0:q+1.0}while(0);m=O*w;if(m<0.0){n=0.0-m;if(m>0.0){m=(m*2.0+0.0)/n;m=m<0.0?-m:m}else m=2.0;x=0.0;w=0.0;u=m+1.0}else{x=m+0.0;w=3.0;n=0.0;u=0.0}m=O*y;do if(m<0.0){o=n-m;if(m>0.0|n<0.0){m=(m*2.0+n*u)/o;m=m<0.0?-m:m}else m=u<2.0?2.0:u;n=o;y=m+1.0}else{o=m+x;if(x<0.0?m>0.0|x>0.0:0){w=(x*w-m*2.0)/o;y=u;x=o;w=(w<0.0?-w:w)+1.0;break}y=u;x=o;w=w<2.0?3.0:w+1.0}while(0);o=ha*z;do if(o<0.0){u=x-o;if(o>0.0|x<0.0){m=(o*2.0+x*w)/u;m=m<0.0?-m:m}else m=w<2.0?2.0:w;z=n;w=m+1.0}else{m=o+n;if(n<0.0?o>0.0|n>0.0:0){y=(n*y-o*2.0)/m;z=m;y=(y<0.0?-y:y)+1.0;u=x;break}z=m;y=y<2.0?3.0:y+1.0;u=x}while(0);n=ha*A;a:do if(n<0.0){o=u-n;if(n>0.0|u<0.0){m=(n*2.0+u*w)/o;m=m<0.0?-m:m}else m=w<2.0?2.0:w;w=m+1.0}else{m=n+z;do if(z<0.0){if(!(n>0.0|z>0.0))break;y=(z*y-n*2.0)/m;z=m;o=u;y=(y<0.0?-y:y)+1.0;break a}while(0);z=m;o=u;y=y<2.0?3.0:y+1.0}while(0);n=+X(+((O*O+ja*ja)*(ha*ha+ka*ka)*(C*C+B*B)));b:do if(n<0.0){m=s-n;if(s<0.0|n>0.0){n=(s*v+n*5.0)/m;n=n<0.0?-n:n}else n=v<5.0?5.0:v;C=N;A=m;B=q;x=n+1.0}else{m=N+n;do if(N<0.0){if(!(N>0.0|n>0.0))break;B=(N*q-n*5.0)/m;C=m;A=s;B=(B<0.0?-B:B)+1.0;x=v;break b}while(0);C=m;A=s;B=q<5.0?6.0:q+1.0;x=v}while(0);m=s-N;n=o-z;f=o<0.0|z>0.0;u=A-C;g=C>0.0|A<0.0;p[e>>3]=ma*m;Y=e+8|0;p[Y>>3]=ma*n;W=e+16|0;p[W>>3]=ma*u;i[e+24>>0]=1;do if(s<0.0|N>0.0){if(!(s>0.0|N<0.0)){ia=97;break}m=(s*v+N*q)/m;if(!(m<0.0))break;m=-m}else ia=97;while(0);if((ia|0)==97)m=v<q?q:v;T=m+1.0>64.0;do if(f){if(!(o>0.0|z<0.0)){ia=102;break}m=(o*w+z*y)/n;if(!(m<0.0))break;m=-m}else ia=102;while(0);if((ia|0)==102)m=w<y?y:w;V=m+1.0>64.0;do if(g){if(!(C<0.0|A>0.0)){ia=107;break}m=(B*C+x*A)/u;if(!(m<0.0))break;m=-m}else ia=107;while(0);if((ia|0)==107)m=x<B?B:x;S=m+1.0>64.0;if(!(T|V|S))break;E=k[b>>2]|0;F=((E|0)<0)<<31>>31;K=k[c>>2]|0;M=((K|0)<0)<<31>>31;f=be(E|0,F|0,K|0,M|0)|0;g=L;do if(!((g|0)>0|(g|0)==0&f>>>0>0))if((g|0)<0){Da=be(0,0,f|0,g|0)|0;a=L;k[_a>>2]=Da;k[_a+4>>2]=a;k[_a+256>>2]=(a|0)!=0?-2:-1;break}else{k[_a+256>>2]=0;break}else{k[_a>>2]=f;k[_a+4>>2]=g;k[_a+256>>2]=(g|0)!=0?2:1}while(0);U=_a+260|0;I=k[d>>2]|0;J=((I|0)<0)<<31>>31;f=be(K|0,M|0,I|0,J|0)|0;g=L;do if(!((g|0)>0|(g|0)==0&f>>>0>0))if((g|0)<0){Da=be(0,0,f|0,g|0)|0;a=L;k[U>>2]=Da;k[_a+264>>2]=a;k[_a+516>>2]=(a|0)!=0?-2:-1;break}else{k[_a+516>>2]=0;break}else{k[U>>2]=f;k[_a+264>>2]=g;k[_a+516>>2]=(g|0)!=0?2:1}while(0);R=_a+520|0;f=be(E|0,F|0,I|0,J|0)|0;g=L;do if(!((g|0)>0|(g|0)==0&f>>>0>0))if((g|0)<0){Da=be(0,0,f|0,g|0)|0;a=L;k[R>>2]=Da;k[_a+524>>2]=a;k[_a+776>>2]=(a|0)!=0?-2:-1;break}else{k[_a+776>>2]=0;break}else{k[R>>2]=f;k[_a+524>>2]=g;k[_a+776>>2]=(g|0)!=0?2:1}while(0);j=k[D>>2]|0;D=((j|0)<0)<<31>>31;G=k[G>>2]|0;H=((G|0)<0)<<31>>31;f=be(j|0,D|0,G|0,H|0)|0;g=L;do if(!((g|0)>0|(g|0)==0&f>>>0>0))if((g|0)<0){Da=be(0,0,f|0,g|0)|0;a=L;k[Ta>>2]=Da;k[Ta+4>>2]=a;k[Ta+256>>2]=(a|0)!=0?-2:-1;break}else{k[Ta+256>>2]=0;break}else{k[Ta>>2]=f;k[Ta+4>>2]=g;k[Ta+256>>2]=(g|0)!=0?2:1}while(0);Q=Ta+260|0;h=k[P>>2]|0;l=((h|0)<0)<<31>>31;f=be(G|0,H|0,h|0,l|0)|0;g=L;do if(!((g|0)>0|(g|0)==0&f>>>0>0))if((g|0)<0){Da=be(0,0,f|0,g|0)|0;a=L;k[Q>>2]=Da;k[Ta+264>>2]=a;k[Ta+516>>2]=(a|0)!=0?-2:-1;break}else{k[Ta+516>>2]=0;break}else{k[Q>>2]=f;k[Ta+264>>2]=g;k[Ta+516>>2]=(g|0)!=0?2:1}while(0);P=Ta+520|0;f=be(j|0,D|0,h|0,l|0)|0;g=L;do if(!((g|0)>0|(g|0)==0&f>>>0>0))if((g|0)<0){Da=be(0,0,f|0,g|0)|0;a=L;k[P>>2]=Da;k[Ta+524>>2]=a;k[Ta+776>>2]=(a|0)!=0?-2:-1;break}else{k[Ta+776>>2]=0;break}else{k[P>>2]=f;k[Ta+524>>2]=g;k[Ta+776>>2]=(g|0)!=0?2:1}while(0);f=ge(K|0,M|0,E|0,F|0)|0;g=L;do if(!((g|0)>0|(g|0)==0&f>>>0>0))if((g|0)<0){Da=be(0,0,f|0,g|0)|0;a=L;k[Na>>2]=Da;k[Na+4>>2]=a;k[Na+256>>2]=(a|0)!=0?-2:-1;break}else{k[Na+256>>2]=0;break}else{k[Na>>2]=f;k[Na+4>>2]=g;k[Na+256>>2]=(g|0)!=0?2:1}while(0);E=Na+260|0;f=ge(I|0,J|0,K|0,M|0)|0;g=L;do if(!((g|0)>0|(g|0)==0&f>>>0>0))if((g|0)<0){Da=be(0,0,f|0,g|0)|0;a=L;k[E>>2]=Da;k[Na+264>>2]=a;k[Na+516>>2]=(a|0)!=0?-2:-1;break}else{k[Na+516>>2]=0;break}else{k[E>>2]=f;k[Na+264>>2]=g;k[Na+516>>2]=(g|0)!=0?2:1}while(0);f=ge(G|0,H|0,j|0,D|0)|0;g=L;do if(!((g|0)>0|(g|0)==0&f>>>0>0))if((g|0)<0){Da=be(0,0,f|0,g|0)|0;a=L;k[Oa>>2]=Da;k[Oa+4>>2]=a;k[Oa+256>>2]=(a|0)!=0?-2:-1;break}else{k[Oa+256>>2]=0;break}else{k[Oa>>2]=f;k[Oa+4>>2]=g;k[Oa+256>>2]=(g|0)!=0?2:1}while(0);j=Oa+260|0;f=ge(h|0,l|0,G|0,H|0)|0;g=L;do if(!((g|0)>0|(g|0)==0&f>>>0>0))if((g|0)<0){Da=be(0,0,f|0,g|0)|0;a=L;k[j>>2]=Da;k[Oa+264>>2]=a;k[Oa+516>>2]=(a|0)!=0?-2:-1;break}else{k[Oa+516>>2]=0;break}else{k[j>>2]=f;k[Oa+264>>2]=g;k[Oa+516>>2]=(g|0)!=0?2:1}while(0);Sc(Ea,_a,Q);Sc(Fa,U,Ta);Uc(Ma,Ea,Fa);g=k[Ma+256>>2]|0;f=(g|0)>-1?g:0-g|0;c:do switch(f|0){case 0:{f=0;m=0.0;break}case 1:{m=+((k[Ma>>2]|0)>>>0);ia=164;break}case 2:{m=+((k[Ma+4>>2]|0)>>>0)*4294967296.0+ +((k[Ma>>2]|0)>>>0);ia=164;break}default:{m=+((k[Ma+(f+-3<<2)>>2]|0)>>>0)+(+((k[Ma+(f+-1<<2)>>2]|0)>>>0)*4294967296.0+ +((k[Ma+(f+-2<<2)>>2]|0)>>>0))*4294967296.0;h=f<<5;f=h+-96|0;m=(g|0)<0?-m:m;if((f|0)>1023){m=m*89884656743115795.0e291;f=h+-1119|0;if((f|0)<=1023)break c;f=h+-2142|0;f=(f|0)>1023?1023:f;m=m*89884656743115795.0e291;break c}if((f|0)>=-1022)break c;m=m*2.2250738585072014e-308;f=h+926|0;if((f|0)>=-1022)break c;f=h+1948|0;f=(f|0)<-1022?-1022:f;m=m*2.2250738585072014e-308}}while(0);if((ia|0)==164){f=0;m=(g|0)<0?-m:m}Fa=ee(f+1023|0,0,52)|0;Ma=L;k[t>>2]=Fa;k[t+4>>2]=Ma;q=.5/(m*+p[t>>3]);Sc(Ga,_a,Na);Sc(Ha,Ta,Oa);Tc(Xa,Ga,Ha);Sc(Ia,U,E);Sc(Ja,Q,j);Tc(Ya,Ia,Ja);if(T|S){Sc(Ka,Xa,Q);Sc(La,Ya,Ta);Uc(Za,Ka,La);j=Za+256|0;g=k[j>>2]|0;f=(g|0)>-1?g:0-g|0;d:do switch(f|0){case 0:{f=0;m=0.0;break}case 1:{m=+((k[Za>>2]|0)>>>0);ia=175;break}case 2:{m=+((k[Za+4>>2]|0)>>>0)*4294967296.0+ +((k[Za>>2]|0)>>>0);ia=175;break}default:{m=+((k[Za+(f+-3<<2)>>2]|0)>>>0)+(+((k[Za+(f+-1<<2)>>2]|0)>>>0)*4294967296.0+ +((k[Za+(f+-2<<2)>>2]|0)>>>0))*4294967296.0;h=f<<5;f=h+-96|0;m=(g|0)<0?-m:m;if((f|0)>1023){m=m*89884656743115795.0e291;f=h+-1119|0;if((f|0)<=1023)break d;f=h+-2142|0;f=(f|0)>1023?1023:f;m=m*89884656743115795.0e291;break d}if((f|0)>=-1022)break d;m=m*2.2250738585072014e-308;f=h+926|0;if((f|0)>=-1022)break d;f=h+1948|0;f=(f|0)<-1022?-1022:f;m=m*2.2250738585072014e-308}}while(0);if((ia|0)==175){f=0;m=(g|0)<0?-m:m}Na=ee(f+1023|0,0,52)|0;Oa=L;k[t>>2]=Na;k[t+4>>2]=Oa;p[e>>3]=q*(m*+p[t>>3]);if(S){Sc(Pa,_a,_a);Sc(Qa,Ta,Ta);Tc(Ra,Pa,Qa);Sc(Ua,U,U);Sc(Va,Q,Q);Tc(Sa,Ua,Va);Sc(Z,Ra,Sa);Sc($,R,R);Sc(aa,P,P);Tc(_,$,aa);Sc(Wa,Z,_);g=k[Wa+256>>2]|0;f=(g|0)>-1?g:0-g|0;e:do switch(f|0){case 0:{f=0;m=0.0;break}case 1:{m=+((k[Wa>>2]|0)>>>0);ia=186;break}case 2:{m=+((k[Wa+4>>2]|0)>>>0)*4294967296.0+ +((k[Wa>>2]|0)>>>0);ia=186;break}default:{m=+((k[Wa+(f+-3<<2)>>2]|0)>>>0)+(+((k[Wa+(f+-1<<2)>>2]|0)>>>0)*4294967296.0+ +((k[Wa+(f+-2<<2)>>2]|0)>>>0))*4294967296.0;h=f<<5;f=h+-96|0;m=(g|0)<0?-m:m;if((f|0)>1023){m=m*89884656743115795.0e291;f=h+-1119|0;if((f|0)<=1023)break e;f=h+-2142|0;f=(f|0)>1023?1023:f;m=m*89884656743115795.0e291;break e}if((f|0)>=-1022)break e;m=m*2.2250738585072014e-308;f=h+926|0;if((f|0)>=-1022)break e;f=h+1948|0;f=(f|0)<-1022?-1022:f;m=m*2.2250738585072014e-308}}while(0);if((ia|0)==186){f=0;m=(g|0)<0?-m:m}Ua=ee(f+1023|0,0,52)|0;Va=L;k[t>>2]=Ua;k[t+4>>2]=Va;o=+X(+(m*+p[t>>3]));n=+p[e>>3];do if(!(n<0.0)){m=q*o;if(q<0.0){p[W>>3]=n-m;break}else{p[W>>3]=n+m;break}}else{Sc(ba,Za,Za);Uc(ca,ba,Wa);g=k[ca+256>>2]|0;f=(g|0)>-1?g:0-g|0;f:do switch(f|0){case 0:{f=0;m=0.0;break}case 1:{m=+((k[ca>>2]|0)>>>0);ia=200;break}case 2:{m=+((k[ca+4>>2]|0)>>>0)*4294967296.0+ +((k[ca>>2]|0)>>>0);ia=200;break}default:{m=+((k[ca+(f+-3<<2)>>2]|0)>>>0)+(+((k[ca+(f+-1<<2)>>2]|0)>>>0)*4294967296.0+ +((k[ca+(f+-2<<2)>>2]|0)>>>0))*4294967296.0;h=f<<5;f=h+-96|0;m=(g|0)<0?-m:m;if((f|0)>1023){m=m*89884656743115795.0e291;f=h+-1119|0;if((f|0)<=1023)break f;f=h+-2142|0;f=(f|0)>1023?1023:f;m=m*89884656743115795.0e291;break f}if((f|0)>=-1022)break f;m=m*2.2250738585072014e-308;f=h+926|0;if((f|0)>=-1022)break f;f=h+1948|0;f=(f|0)<-1022?-1022:f;m=m*2.2250738585072014e-308}}while(0);if((ia|0)==200){f=0;m=(g|0)<0?-m:m}f=ee(f+1023|0,0,52)|0;g=L;k[t>>2]=f;k[t+4>>2]=g;n=q*(m*+p[t>>3]);g=k[j>>2]|0;f=(g|0)>-1?g:0-g|0;g:do switch(f|0){case 0:{f=0;m=0.0;break}case 1:{m=+((k[Za>>2]|0)>>>0);ia=210;break}case 2:{m=+((k[Za+4>>2]|0)>>>0)*4294967296.0+ +((k[Za>>2]|0)>>>0);ia=210;break}default:{m=+((k[Za+(f+-3<<2)>>2]|0)>>>0)+(+((k[Za+(f+-1<<2)>>2]|0)>>>0)*4294967296.0+ +((k[Za+(f+-2<<2)>>2]|0)>>>0))*4294967296.0;h=f<<5;f=h+-96|0;m=(g|0)<0?-m:m;if((f|0)>1023){m=m*89884656743115795.0e291;f=h+-1119|0;if((f|0)<=1023)break g;f=h+-2142|0;f=(f|0)>1023?1023:f;m=m*89884656743115795.0e291;break g}if((f|0)>=-1022)break g;m=m*2.2250738585072014e-308;f=h+926|0;if((f|0)>=-1022)break g;f=h+1948|0;f=(f|0)<-1022?-1022:f;m=m*2.2250738585072014e-308}}while(0);if((ia|0)==210){f=0;m=(g|0)<0?-m:m}Va=ee(f+1023|0,0,52)|0;Wa=L;k[t>>2]=Va;k[t+4>>2]=Wa;p[W>>3]=n/(o+m*+p[t>>3])}while(0)}}if(V){Sc(fa,Ya,_a);Sc(ga,Xa,U);Uc(Za,fa,ga);g=k[Za+256>>2]|0;f=(g|0)>-1?g:0-g|0;h:do switch(f|0){case 0:{f=0;m=0.0;break}case 1:{m=+((k[Za>>2]|0)>>>0);ia=224;break}case 2:{m=+((k[Za+4>>2]|0)>>>0)*4294967296.0+ +((k[Za>>2]|0)>>>0);ia=224;break}default:{m=+((k[Za+(f+-3<<2)>>2]|0)>>>0)+(+((k[Za+(f+-1<<2)>>2]|0)>>>0)*4294967296.0+ +((k[Za+(f+-2<<2)>>2]|0)>>>0))*4294967296.0;h=f<<5;f=h+-96|0;m=(g|0)<0?-m:m;if((f|0)>1023){m=m*89884656743115795.0e291;f=h+-1119|0;if((f|0)<=1023)break h;f=h+-2142|0;f=(f|0)>1023?1023:f;m=m*89884656743115795.0e291;break h}if((f|0)>=-1022)break h;m=m*2.2250738585072014e-308;f=h+926|0;if((f|0)>=-1022)break h;f=h+1948|0;f=(f|0)<-1022?-1022:f;m=m*2.2250738585072014e-308}}while(0);if((ia|0)==224){f=0;m=(g|0)<0?-m:m}Za=ee(f+1023|0,0,52)|0;_a=L;k[t>>2]=Za;k[t+4>>2]=_a;p[Y>>3]=q*(m*+p[t>>3])}}else{if(!g){if(!h){g=k[c+4>>2]|0;h=k[d+4>>2]|0;f=Pc(V,g,ea,h,U,k[b+4>>2]|0)|0;if((V|0)<(ea|0)){if((f|0)!=-1&(Pc(V,g,ea,h,T,k[b+12>>2]|0)|0)!=-1){e=0;r=gb;return e|0}}else if((f|0)!=-1){e=0;r=gb;return e|0}Qc(a+4|0,c,d,b,1,e);break}if((k[b+16>>2]|0)==(k[d+16>>2]|0)){e=0;r=gb;return e|0}f=(k[d+24>>2]&32|0)==0;if(!(k[b+24>>2]&32))if(f)ia=254;else{e=0;r=gb;return e|0}else if(!f)ia=254;if((ia|0)==254?(Pc(U,k[b+4>>2]|0,V,k[c+4>>2]|0,da,k[d+12>>2]|0)|0)!=-1:0){e=0;r=gb;return e|0}Rc(a+4|0,c,b,d,2,e);break}f=k[b+16>>2]|0;g=k[c+16>>2]|0;if(!h)if((f|0)==(g|0)){e=0;r=gb;return e|0}else{Rc(a+4|0,d,b,c,3,e);break}if(!((f|0)!=(g|0)?(g|0)!=(k[d+16>>2]|0):0)){e=0;r=gb;return e|0}O=+(T|0)-+(U|0);ya=b+12|0;J=k[ya>>2]|0;za=b+4|0;K=k[za>>2]|0;xa=+(J|0)-+(K|0);M=((U|0)<0)<<31>>31;P=((K|0)<0)<<31>>31;Q=((T|0)<0)<<31>>31;R=((J|0)<0)<<31>>31;Ca=(U|0)<0;g=be(0,0,U|0,M|0)|0;f=Ca?L:M;l=(K|0)<0;la=be(0,0,K|0,P|0)|0;Aa=l?L:P;Ba=(T|0)<0;j=be(0,0,T|0,Q|0)|0;h=Ba?L:Q;Da=(J|0)<0;ga=be(0,0,J|0,R|0)|0;f=ne((Da?ga:J)|0,(Da?L:R)|0,(Ca?g:U)|0,f|0)|0;g=L;h=ne((l?la:K)|0,Aa|0,(Ba?j:T)|0,h|0)|0;j=L;l=Ba^l;do if(Ca^Da){if(!l){Da=ge(h|0,j|0,f|0,g|0)|0;wa=-(+(Da>>>0)+4294967296.0*+(L>>>0));break}if(g>>>0>j>>>0|(g|0)==(j|0)&f>>>0>h>>>0){Da=be(f|0,g|0,h|0,j|0)|0;wa=-(+(Da>>>0)+4294967296.0*+(L>>>0));break}else{Da=be(h|0,j|0,f|0,g|0)|0;wa=+(Da>>>0)+4294967296.0*+(L>>>0);break}}else{if(l){Da=ge(h|0,j|0,f|0,g|0)|0;wa=+(Da>>>0)+4294967296.0*+(L>>>0);break}if(g>>>0<j>>>0|(g|0)==(j|0)&f>>>0<h>>>0){Da=be(h|0,j|0,f|0,g|0)|0;wa=-(+(Da>>>0)+4294967296.0*+(L>>>0));break}else{Da=be(f|0,g|0,h|0,j|0)|0;wa=+(Da>>>0)+4294967296.0*+(L>>>0);break}}while(0);B=+(S|0)-+(V|0);Aa=c+12|0;D=k[Aa>>2]|0;Ba=c+4|0;E=k[Ba>>2]|0;ra=+(D|0)-+(E|0);F=((V|0)<0)<<31>>31;G=((E|0)<0)<<31>>31;H=((S|0)<0)<<31>>31;I=((D|0)<0)<<31>>31;Ca=(V|0)<0;g=be(0,0,V|0,F|0)|0;f=Ca?L:F;l=(E|0)<0;fa=be(0,0,E|0,G|0)|0;ga=l?L:G;la=(S|0)<0;j=be(0,0,S|0,H|0)|0;h=la?L:H;Da=(D|0)<0;ca=be(0,0,D|0,I|0)|0;f=ne((Da?ca:D)|0,(Da?L:I)|0,(Ca?g:V)|0,f|0)|0;g=L;h=ne((l?fa:E)|0,ga|0,(la?j:S)|0,h|0)|0;j=L;l=la^l;do if(Ca^Da){if(!l){Da=ge(h|0,j|0,f|0,g|0)|0;sa=-(+(Da>>>0)+4294967296.0*+(L>>>0));break}if(g>>>0>j>>>0|(g|0)==(j|0)&f>>>0>h>>>0){Da=be(f|0,g|0,h|0,j|0)|0;sa=-(+(Da>>>0)+4294967296.0*+(L>>>0));break}else{Da=be(h|0,j|0,f|0,g|0)|0;sa=+(Da>>>0)+4294967296.0*+(L>>>0);break}}else{if(l){Da=ge(h|0,j|0,f|0,g|0)|0;sa=+(Da>>>0)+4294967296.0*+(L>>>0);break}if(g>>>0<j>>>0|(g|0)==(j|0)&f>>>0<h>>>0){Da=be(h|0,j|0,f|0,g|0)|0;sa=-(+(Da>>>0)+4294967296.0*+(L>>>0));break}else{Da=be(f|0,g|0,h|0,j|0)|0;sa=+(Da>>>0)+4294967296.0*+(L>>>0);break}}while(0);C=+(da|0)-+(ea|0);Ca=d+12|0;Z=k[Ca>>2]|0;Da=d+4|0;_=k[Da>>2]|0;ta=+(Z|0)-+(_|0);$=((ea|0)<0)<<31>>31;aa=((_|0)<0)<<31>>31;ba=((da|0)<0)<<31>>31;ca=((Z|0)<0)<<31>>31;ga=(ea|0)<0;g=be(0,0,ea|0,$|0)|0;f=ga?L:$;l=(_|0)<0;W=be(0,0,_|0,aa|0)|0;Y=l?L:aa;fa=(da|0)<0;j=be(0,0,da|0,ba|0)|0;h=fa?L:ba;la=(Z|0)<0;hb=be(0,0,Z|0,ca|0)|0;f=ne((la?hb:Z)|0,(la?L:ca)|0,(ga?g:ea)|0,f|0)|0;g=L;h=ne((l?W:_)|0,Y|0,(fa?j:da)|0,h|0)|0;j=L;l=fa^l;do if(ga^la){if(!l){hb=ge(h|0,j|0,f|0,g|0)|0;ua=-(+(hb>>>0)+4294967296.0*+(L>>>0));break}if(g>>>0>j>>>0|(g|0)==(j|0)&f>>>0>h>>>0){hb=be(f|0,g|0,h|0,j|0)|0;ua=-(+(hb>>>0)+4294967296.0*+(L>>>0));break}else{hb=be(h|0,j|0,f|0,g|0)|0;ua=+(hb>>>0)+4294967296.0*+(L>>>0);break}}else{if(l){hb=ge(h|0,j|0,f|0,g|0)|0;ua=+(hb>>>0)+4294967296.0*+(L>>>0);break}if(g>>>0<j>>>0|(g|0)==(j|0)&f>>>0<h>>>0){hb=be(h|0,j|0,f|0,g|0)|0;ua=-(+(hb>>>0)+4294967296.0*+(L>>>0));break}else{hb=be(f|0,g|0,h|0,j|0)|0;ua=+(hb>>>0)+4294967296.0*+(L>>>0);break}}while(0);qa=+X(+(O*O+xa*xa));va=+X(+(B*B+ra*ra));pa=+X(+(C*C+ta*ta));U=be(T|0,Q|0,U|0,M|0)|0;Y=L;R=be(J|0,R|0,K|0,P|0)|0;T=L;J=be(S|0,H|0,V|0,F|0)|0;K=L;M=be(D|0,I|0,E|0,G|0)|0;P=L;W=(Y|0)<0;V=be(0,0,U|0,Y|0)|0;U=W?V:U;V=W?L:Y;Y=(T|0)<0;S=be(0,0,R|0,T|0)|0;S=Y?S:R;T=Y?L:T;R=(K|0)<0;Q=be(0,0,J|0,K|0)|0;J=R?Q:J;K=R?L:K;Q=(P|0)<0;f=be(0,0,M|0,P|0)|0;M=Q?f:M;P=Q?L:P;f=ne(M|0,P|0,U|0,V|0)|0;g=L;h=ne(J|0,K|0,S|0,T|0)|0;j=L;l=Y^R;do if(W^Q){if(!l){hb=ge(f|0,g|0,h|0,j|0)|0;w=-(+(hb>>>0)+4294967296.0*+(L>>>0));break}if(g>>>0>j>>>0|(g|0)==(j|0)&f>>>0>h>>>0){hb=be(f|0,g|0,h|0,j|0)|0;w=-(+(hb>>>0)+4294967296.0*+(L>>>0));break}else{hb=be(h|0,j|0,f|0,g|0)|0;w=+(hb>>>0)+4294967296.0*+(L>>>0);break}}else{if(l){hb=ge(f|0,g|0,h|0,j|0)|0;w=+(hb>>>0)+4294967296.0*+(L>>>0);break}if(g>>>0<j>>>0|(g|0)==(j|0)&f>>>0<h>>>0){hb=be(h|0,j|0,f|0,g|0)|0;w=-(+(hb>>>0)+4294967296.0*+(L>>>0));break}else{hb=be(f|0,g|0,h|0,j|0)|0;w=+(hb>>>0)+4294967296.0*+(L>>>0);break}}while(0);D=be(da|0,ba|0,ea|0,$|0)|0;E=L;F=be(Z|0,ca|0,_|0,aa|0)|0;G=L;I=(E|0)<0;H=be(0,0,D|0,E|0)|0;D=I?H:D;E=I?L:E;H=(G|0)<0;j=be(0,0,F|0,G|0)|0;F=H?j:F;G=H?L:G;j=ne(F|0,G|0,J|0,K|0)|0;l=L;g=ne(D|0,E|0,M|0,P|0)|0;h=L;f=Q^I;do if(R^H){if(!f){hb=ge(j|0,l|0,g|0,h|0)|0;z=-(+(hb>>>0)+4294967296.0*+(L>>>0));break}if(l>>>0>h>>>0|(l|0)==(h|0)&j>>>0>g>>>0){hb=be(j|0,l|0,g|0,h|0)|0;z=-(+(hb>>>0)+4294967296.0*+(L>>>0));break}else{hb=be(g|0,h|0,j|0,l|0)|0;z=+(hb>>>0)+4294967296.0*+(L>>>0);break}}else{if(f){hb=ge(j|0,l|0,g|0,h|0)|0;z=+(hb>>>0)+4294967296.0*+(L>>>0);break}if(l>>>0<h>>>0|(l|0)==(h|0)&j>>>0<g>>>0){hb=be(g|0,h|0,j|0,l|0)|0;z=-(+(hb>>>0)+4294967296.0*+(L>>>0));break}else{hb=be(j|0,l|0,g|0,h|0)|0;z=+(hb>>>0)+4294967296.0*+(L>>>0);break}}while(0);j=ne(S|0,T|0,D|0,E|0)|0;l=L;g=ne(U|0,V|0,F|0,G|0)|0;h=L;f=H^W;do if(I^Y){if(!f){hb=ge(j|0,l|0,g|0,h|0)|0;y=-(+(hb>>>0)+4294967296.0*+(L>>>0));break}if(l>>>0>h>>>0|(l|0)==(h|0)&j>>>0>g>>>0){hb=be(j|0,l|0,g|0,h|0)|0;y=-(+(hb>>>0)+4294967296.0*+(L>>>0));break}else{hb=be(g|0,h|0,j|0,l|0)|0;y=+(hb>>>0)+4294967296.0*+(L>>>0);break}}else{if(f){hb=ge(j|0,l|0,g|0,h|0)|0;y=+(hb>>>0)+4294967296.0*+(L>>>0);break}if(l>>>0<h>>>0|(l|0)==(h|0)&j>>>0<g>>>0){hb=be(g|0,h|0,j|0,l|0)|0;y=-(+(hb>>>0)+4294967296.0*+(L>>>0));break}else{hb=be(j|0,l|0,g|0,h|0)|0;y=+(hb>>>0)+4294967296.0*+(L>>>0);break}}while(0);m=pa*w;if(m<0.0){n=0.0-m;if(m>0.0){m=(m*4.0+0.0)/n;m=m<0.0?-m:m}else m=4.0;u=0.0;v=0.0;s=m+1.0}else{u=m+0.0;v=5.0;n=0.0;s=0.0}o=qa*z;do if(o<0.0){q=n-o;if(o>0.0|n<0.0){o=(o*4.0+n*s)/q;o=o<0.0?-o:o}else o=s<4.0?4.0:s;m=u;n=q;s=o+1.0}else{m=o+u;if(u<0.0?o>0.0|u>0.0:0){v=(u*v-o*4.0)/m;v=(v<0.0?-v:v)+1.0;break}v=v<4.0?5.0:v+1.0}while(0);o=va*y;i:do if(o<0.0){q=n-o;if(o>0.0|n<0.0){n=(o*4.0+n*s)/q;n=n<0.0?-n:n}else n=s<4.0?4.0:s;oa=q;q=m;s=n+1.0;na=v}else{q=o+m;do if(m<0.0){if(!(o>0.0|m>0.0))break;na=(m*v-o*4.0)/q;oa=n;na=(na<0.0?-na:na)+1.0;break i}while(0);oa=n;na=v<4.0?5.0:v+1.0}while(0);m=ua*w;if(m<0.0){n=0.0-m;if(m>0.0){m=(m*3.0+0.0)/n;m=m<0.0?-m:m}else m=3.0;w=0.0;x=0.0;u=m+1.0}else{w=m+0.0;x=4.0;n=0.0;u=0.0}o=wa*z;j:do if(o<0.0){v=n-o;if(o>0.0|n<0.0){m=(o*3.0+n*u)/v;m=m<0.0?-m:m}else m=u<3.0?3.0:u;n=v;u=m+1.0}else{m=o+w;do if(w<0.0){if(!(o>0.0|w>0.0))break;x=(w*x-o*3.0)/m;w=m;x=(x<0.0?-x:x)+1.0;break j}while(0);w=m;x=x<3.0?4.0:x+1.0}while(0);m=sa*y;k:do if(m<0.0){o=n-m;if(m>0.0|n<0.0){m=(m*3.0+n*u)/o;m=m<0.0?-m:m}else m=u<3.0?3.0:u;A=o;z=m+1.0;ma=w;N=x}else{o=m+w;do if(w<0.0){if(!(m>0.0|w>0.0))break;N=(w*x-m*3.0)/o;A=n;z=u;ma=o;N=(N<0.0?-N:N)+1.0;break k}while(0);A=n;z=u;ma=o;N=x<3.0?4.0:x+1.0}while(0);n=O*sa*pa;if(n<0.0){m=0.0-n;if(n>0.0){n=(n*5.0+0.0)/m;n=n<0.0?-n:n}else n=5.0;w=n+1.0;u=0.0;v=0.0}else{m=0.0;w=0.0;u=n+0.0;v=6.0}n=wa*B*pa;l:do if(n<0.0){o=u-n;if(n>0.0|u<0.0){n=(n*5.0+u*v)/o;n=n<0.0?-n:n}else n=v<5.0?5.0:v;u=o;v=n+1.0}else{o=n+m;do if(m<0.0){if(!(n>0.0|m>0.0))break;w=(m*w-n*5.0)/o;m=o;w=(w<0.0?-w:w)+1.0;break l}while(0);m=o;w=w<5.0?6.0:w+1.0}while(0);n=B*ua*qa;m:do if(n<0.0){o=m-n;if(n>0.0|m<0.0){n=(n*5.0+m*w)/o;n=n<0.0?-n:n}else n=w<5.0?5.0:w;m=o;w=n+1.0}else{o=n+u;do if(u<0.0){if(!(n>0.0|u>0.0))break;v=(u*v-n*5.0)/o;u=o;v=(v<0.0?-v:v)+1.0;break m}while(0);u=o;v=v<5.0?6.0:v+1.0}while(0);n=sa*C*qa;n:do if(n<0.0){o=u-n;if(n>0.0|u<0.0){n=(n*5.0+u*v)/o;n=n<0.0?-n:n}else n=v<5.0?5.0:v;x=o;v=n+1.0}else{o=n+m;do if(m<0.0){if(!(n>0.0|m>0.0))break;w=(m*w-n*5.0)/o;x=u;m=o;w=(w<0.0?-w:w)+1.0;break n}while(0);x=u;m=o;w=w<5.0?6.0:w+1.0}while(0);n=wa*C*va;o:do if(n<0.0){o=m-n;if(n>0.0|m<0.0){m=(n*5.0+m*w)/o;m=m<0.0?-m:m}else m=w<5.0?5.0:w;w=m+1.0;u=x}else{u=n+x;do if(x<0.0){if(!(n>0.0|x>0.0))break;v=(x*v-n*5.0)/u;o=m;v=(v<0.0?-v:v)+1.0;break o}while(0);o=m;v=v<5.0?6.0:v+1.0}while(0);m=O*ua*va;p:do if(m<0.0){n=u-m;if(m>0.0|u<0.0){m=(m*5.0+u*v)/n;m=m<0.0?-m:m}else m=v<5.0?5.0:v;ka=n;ja=m+1.0;ha=o}else{n=m+o;do if(o<0.0){if(!(m>0.0|o>0.0))break;w=(o*w-m*5.0)/n;ka=u;ja=v;ha=n;w=(w<0.0?-w:w)+1.0;break p}while(0);ka=u;ja=v;ha=n;w=w<5.0?6.0:w+1.0}while(0);n=xa*sa*pa;if(n<0.0){m=0.0-n;if(n>0.0){n=(n*5.0+0.0)/m;n=n<0.0?-n:n}else n=5.0;x=n+1.0;u=0.0;v=0.0}else{m=0.0;x=0.0;u=n+0.0;v=6.0}n=wa*ra*pa;q:do if(n<0.0){o=u-n;if(n>0.0|u<0.0){n=(n*5.0+u*v)/o;n=n<0.0?-n:n}else n=v<5.0?5.0:v;y=o;v=n+1.0}else{o=n+m;do if(m<0.0){if(!(n>0.0|m>0.0))break;x=(m*x-n*5.0)/o;y=u;m=o;x=(x<0.0?-x:x)+1.0;break q}while(0);y=u;m=o;x=x<5.0?6.0:x+1.0}while(0);n=ra*ua*qa;r:do if(n<0.0){o=m-n;if(n>0.0|m<0.0){n=(n*5.0+m*x)/o;n=n<0.0?-n:n}else n=x<5.0?5.0:x;m=o;x=n+1.0;u=y}else{u=n+y;do if(y<0.0){if(!(n>0.0|y>0.0))break;v=(y*v-n*5.0)/u;v=(v<0.0?-v:v)+1.0;break r}while(0);v=v<5.0?6.0:v+1.0}while(0);n=sa*ta*qa;s:do if(n<0.0){o=u-n;if(n>0.0|u<0.0){n=(n*5.0+u*v)/o;n=n<0.0?-n:n}else n=v<5.0?5.0:v;u=o;o=m;v=n+1.0}else{o=n+m;do if(m<0.0){if(!(n>0.0|m>0.0))break;x=(m*x-n*5.0)/o;x=(x<0.0?-x:x)+1.0;break s}while(0);x=x<5.0?6.0:x+1.0}while(0);m=wa*ta*va;t:do if(m<0.0){n=o-m;if(m>0.0|o<0.0){m=(m*5.0+o*x)/n;m=m<0.0?-m:m}else m=x<5.0?5.0:x;y=n;x=m+1.0}else{n=m+u;do if(u<0.0){if(!(m>0.0|u>0.0))break;v=(u*v-m*5.0)/n;y=o;u=n;v=(v<0.0?-v:v)+1.0;break t}while(0);y=o;u=n;v=v<5.0?6.0:v+1.0}while(0);n=xa*ua*va;u:do if(n<0.0){o=u-n;if(n>0.0|u<0.0){m=(n*5.0+u*v)/o;m=m<0.0?-m:m}else m=v<5.0?5.0:v;v=m+1.0}else{m=n+y;do if(y<0.0){if(!(n>0.0|y>0.0))break;x=(y*x-n*5.0)/m;y=m;o=u;x=(x<0.0?-x:x)+1.0;break u}while(0);y=m;o=u;x=x<5.0?6.0:x+1.0}while(0);O=A+ka;g=ka<0.0;do if(A<0.0|g){if(!(A>0.0|ka>0.0)){ia=474;break}m=(ka*ja-A*z)/O;if(!(m<0.0))break;m=-m}else ia=474;while(0);if((ia|0)==474)m=ja<z?z:ja;C=m+1.0;B=ma+ha;f=ha<0.0;do if(ma<0.0|f){if(!(ma>0.0|ha>0.0)){ia=479;break}m=(ha*w-ma*N)/B;if(!(m<0.0))break;m=-m}else ia=479;while(0);if((ia|0)==479)m=w<N?N:w;A=m+1.0;N=q-oa;do if(q<0.0|oa>0.0){if(!(q>0.0|oa<0.0)){ia=484;break}m=(q*na+oa*s)/N;if(!(m<0.0))break;m=-m}else ia=484;while(0);if((ia|0)==484)m=na<s?s:na;z=m+1.0;n=ka-ha;do if((g|ha>0.0)&(ka>0.0|f)){m=(ka*ja+ha*w)/n;if(!(m<0.0))break;m=-m}else m=ja<w?w:ja;while(0);u=n/N;s=z+(m+1.0)+1.0;n=o-y;do if(o<0.0|y>0.0){if(!(o>0.0|y<0.0)){ia=493;break}m=(o*v+y*x)/n;if(!(m<0.0))break;m=-m}else ia=493;while(0);if((ia|0)==493)m=v<x?x:v;o=n/N;n=z+(m+1.0)+1.0;q=O-B;do if(O<0.0|B>0.0){if(!(O>0.0|B<0.0)){ia=498;break}m=(O*C+B*A)/q;if(!(m<0.0))break;m=-m}else ia=498;while(0);if((ia|0)==498)m=C<A?A:C;ga=s>64.0;da=n>64.0;ia=z+(m+1.0)+1.0>64.0;p[e>>3]=u;fa=e+8|0;p[fa>>3]=o;la=e+16|0;p[la>>3]=q/N;i[e+24>>0]=1;if(!(ga|da|ia))break;P=k[$a>>2]|0;Q=((P|0)<0)<<31>>31;R=k[b>>2]|0;S=((R|0)<0)<<31>>31;f=be(P|0,Q|0,R|0,S|0)|0;g=L;do if(!((g|0)>0|(g|0)==0&f>>>0>0))if((g|0)<0){ea=be(0,0,f|0,g|0)|0;hb=L;k[_a>>2]=ea;k[_a+4>>2]=hb;k[_a+256>>2]=(hb|0)!=0?-2:-1;break}else{k[_a+256>>2]=0;break}else{k[_a>>2]=f;k[_a+4>>2]=g;k[_a+256>>2]=(g|0)!=0?2:1}while(0);ea=_a+260|0;T=k[cb>>2]|0;U=((T|0)<0)<<31>>31;V=k[c>>2]|0;W=((V|0)<0)<<31>>31;f=be(T|0,U|0,V|0,W|0)|0;g=L;do if(!((g|0)>0|(g|0)==0&f>>>0>0))if((g|0)<0){ca=be(0,0,f|0,g|0)|0;hb=L;k[ea>>2]=ca;k[_a+264>>2]=hb;k[_a+516>>2]=(hb|0)!=0?-2:-1;break}else{k[_a+516>>2]=0;break}else{k[ea>>2]=f;k[_a+264>>2]=g;k[_a+516>>2]=(g|0)!=0?2:1}while(0);ca=_a+520|0;Y=k[fb>>2]|0;Z=((Y|0)<0)<<31>>31;_=k[d>>2]|0;$=((_|0)<0)<<31>>31;f=be(Y|0,Z|0,_|0,$|0)|0;g=L;do if(!((g|0)>0|(g|0)==0&f>>>0>0))if((g|0)<0){ba=be(0,0,f|0,g|0)|0;hb=L;k[ca>>2]=ba;k[_a+524>>2]=hb;k[_a+776>>2]=(hb|0)!=0?-2:-1;break}else{k[_a+776>>2]=0;break}else{k[ca>>2]=f;k[_a+524>>2]=g;k[_a+776>>2]=(g|0)!=0?2:1}while(0);K=k[ya>>2]|0;M=((K|0)<0)<<31>>31;G=k[za>>2]|0;H=((G|0)<0)<<31>>31;f=be(K|0,M|0,G|0,H|0)|0;g=L;do if(!((g|0)>0|(g|0)==0&f>>>0>0))if((g|0)<0){za=be(0,0,f|0,g|0)|0;hb=L;k[Ta>>2]=za;k[Ta+4>>2]=hb;k[Ta+256>>2]=(hb|0)!=0?-2:-1;break}else{k[Ta+256>>2]=0;break}else{k[Ta>>2]=f;k[Ta+4>>2]=g;k[Ta+256>>2]=(g|0)!=0?2:1}while(0);ba=Ta+260|0;I=k[Aa>>2]|0;J=((I|0)<0)<<31>>31;l=k[Ba>>2]|0;D=((l|0)<0)<<31>>31;f=be(I|0,J|0,l|0,D|0)|0;g=L;do if(!((g|0)>0|(g|0)==0&f>>>0>0))if((g|0)<0){Ba=be(0,0,f|0,g|0)|0;hb=L;k[ba>>2]=Ba;k[Ta+264>>2]=hb;k[Ta+516>>2]=(hb|0)!=0?-2:-1;break}else{k[Ta+516>>2]=0;break}else{k[ba>>2]=f;k[Ta+264>>2]=g;k[Ta+516>>2]=(g|0)!=0?2:1}while(0);aa=Ta+520|0;E=k[Ca>>2]|0;F=((E|0)<0)<<31>>31;h=k[Da>>2]|0;j=((h|0)<0)<<31>>31;f=be(E|0,F|0,h|0,j|0)|0;g=L;do if(!((g|0)>0|(g|0)==0&f>>>0>0))if((g|0)<0){Da=be(0,0,f|0,g|0)|0;hb=L;k[aa>>2]=Da;k[Ta+524>>2]=hb;k[Ta+776>>2]=(hb|0)!=0?-2:-1;break}else{k[Ta+776>>2]=0;break}else{k[aa>>2]=f;k[Ta+524>>2]=g;k[Ta+776>>2]=(g|0)!=0?2:1}while(0);hb=ne(K|0,M|0,R|0,S|0)|0;g=L;f=ne(P|0,Q|0,G|0,H|0)|0;f=be(hb|0,g|0,f|0,L|0)|0;g=L;do if(!((g|0)>0|(g|0)==0&f>>>0>0))if((g|0)<0){Da=be(0,0,f|0,g|0)|0;hb=L;k[Na>>2]=Da;k[Na+4>>2]=hb;k[Na+256>>2]=(hb|0)!=0?-2:-1;break}else{k[Na+256>>2]=0;break}else{k[Na>>2]=f;k[Na+4>>2]=g;k[Na+256>>2]=(g|0)!=0?2:1}while(0);G=Na+260|0;hb=ne(I|0,J|0,V|0,W|0)|0;g=L;f=ne(T|0,U|0,l|0,D|0)|0;f=be(hb|0,g|0,f|0,L|0)|0;g=L;do if(!((g|0)>0|(g|0)==0&f>>>0>0))if((g|0)<0){Da=be(0,0,f|0,g|0)|0;hb=L;k[G>>2]=Da;k[Na+264>>2]=hb;k[Na+516>>2]=(hb|0)!=0?-2:-1;break}else{k[Na+516>>2]=0;break}else{k[G>>2]=f;k[Na+264>>2]=g;k[Na+516>>2]=(g|0)!=0?2:1}while(0);D=Na+520|0;hb=ne(E|0,F|0,_|0,$|0)|0;g=L;f=ne(Y|0,Z|0,h|0,j|0)|0;f=be(hb|0,g|0,f|0,L|0)|0;g=L;do if(!((g|0)>0|(g|0)==0&f>>>0>0))if((g|0)<0){Da=be(0,0,f|0,g|0)|0;hb=L;k[D>>2]=Da;k[Na+524>>2]=hb;k[Na+776>>2]=(hb|0)!=0?-2:-1;break}else{k[Na+776>>2]=0;break}else{k[D>>2]=f;k[Na+524>>2]=g;k[Na+776>>2]=(g|0)!=0?2:1}while(0);Sc(Fa,_a,_a);Sc(Xa,Ta,Ta);Tc(Ea,Fa,Xa);fe(Ma|0,Ea|0,260)|0;Sc(Fa,ea,ea);Sc(Xa,ba,ba);Tc(Ea,Fa,Xa);fe(Ma+260|0,Ea|0,260)|0;Sc(Fa,ca,ca);Sc(Xa,aa,aa);Tc(Ea,Fa,Xa);fe(Ma+520|0,Ea|0,260)|0;Sc(Ha,ea,aa);Sc(Ya,ca,ba);Uc(Ga,Ha,Ya);fe(Oa|0,Ga|0,260)|0;h=Oa+260|0;Sc(Ha,ca,Ta);Sc(Ya,_a,aa);Uc(Ga,Ha,Ya);fe(h|0,Ga|0,260)|0;j=Oa+520|0;Sc(Ha,_a,ba);Sc(Ya,ea,Ta);Uc(Ga,Ha,Ya);fe(j|0,Ga|0,260)|0;l=a+4|0;Vc(Ia,l,Oa,Ma);m=+p[Ia>>3];g=k[Ia+8>>2]|0;do if((g|0)>1023){m=m*89884656743115795.0e291;f=g+-1023|0;if((f|0)<=1023)break;f=g+-2046|0;f=(f|0)>1023?1023:f;m=m*89884656743115795.0e291}else{if((g|0)>=-1022){f=g;break}m=m*2.2250738585072014e-308;f=g+1022|0;if((f|0)>=-1022)break;f=g+2044|0;f=(f|0)<-1022?-1022:f;m=m*2.2250738585072014e-308}while(0);Ya=ee(f+1023|0,0,52)|0;hb=L;k[t>>2]=Ya;k[t+4>>2]=hb;n=m*+p[t>>3];if(da){Sc(Za,ba,D);Sc(Ka,aa,G);Uc(Ja,Za,Ka);fe(Oa|0,Ja|0,260)|0;Sc(Za,aa,Na);Sc(Ka,Ta,D);Uc(Ja,Za,Ka);fe(h|0,Ja|0,260)|0;Sc(Za,Ta,G);Sc(Ka,ba,Na);Uc(Ja,Za,Ka);fe(j|0,Ja|0,260)|0;Vc(La,l,Oa,Ma);m=+p[La>>3];g=k[La+8>>2]|0;do if((g|0)>1023){m=m*89884656743115795.0e291;f=g+-1023|0;if((f|0)<=1023)break;f=g+-2046|0;f=(f|0)>1023?1023:f;m=m*89884656743115795.0e291}else{if((g|0)>=-1022){f=g;break}m=m*2.2250738585072014e-308;f=g+1022|0;if((f|0)>=-1022)break;f=g+2044|0;f=(f|0)<-1022?-1022:f;m=m*2.2250738585072014e-308}while(0);Za=ee(f+1023|0,0,52)|0;hb=L;k[t>>2]=Za;k[t+4>>2]=hb;p[fa>>3]=m*+p[t>>3]/n}do if(ga|ia){f=Oa+780|0;k[Oa+1036>>2]=0;Sc(Pa,ea,D);Sc(Qa,ca,G);Uc(Wa,Pa,Qa);fe(Oa|0,Wa|0,260)|0;if(ia){Sc(Sa,Oa,Ta);Tc(Ra,f,Sa);fe(f|0,Ra|0,260)|0;Sc(Pa,ca,Na);Sc(Qa,_a,D);Uc(Wa,Pa,Qa);fe(h|0,Wa|0,260)|0;Sc(Sa,h,ba);Tc(Ra,f,Sa);fe(f|0,Ra|0,260)|0;Sc(Pa,_a,G);Sc(Qa,ea,Na);Uc(Wa,Pa,Qa);fe(j|0,Wa|0,260)|0;Sc(Sa,j,aa);Tc(Ra,f,Sa);fe(f|0,Ra|0,260)|0}else{Sc(Pa,ca,Na);Sc(Qa,_a,D);Uc(Wa,Pa,Qa);fe(h|0,Wa|0,260)|0;Sc(Pa,_a,G);Sc(Qa,ea,Na);Uc(Wa,Pa,Qa);fe(j|0,Wa|0,260)|0}if(ga){Vc(Ua,l,Oa,Ma);m=+p[Ua>>3];g=k[Ua+8>>2]|0;do if((g|0)>1023){m=m*89884656743115795.0e291;f=g+-1023|0;if((f|0)<=1023)break;f=g+-2046|0;f=(f|0)>1023?1023:f;m=m*89884656743115795.0e291}else{if((g|0)>=-1022){f=g;break}m=m*2.2250738585072014e-308;f=g+1022|0;if((f|0)>=-1022)break;f=g+2044|0;f=(f|0)<-1022?-1022:f;m=m*2.2250738585072014e-308}while(0);_a=ee(f+1023|0,0,52)|0;hb=L;k[t>>2]=_a;k[t+4>>2]=hb;p[e>>3]=m*+p[t>>3]/n}if(!ia)break;k[Ma+780>>2]=1;k[Ma+1036>>2]=1;Wc(Va,l,Oa,Ma);m=+p[Va>>3];g=k[Va+8>>2]|0;do if((g|0)>1023){m=m*89884656743115795.0e291;f=g+-1023|0;if((f|0)<=1023)break;f=g+-2046|0;f=(f|0)>1023?1023:f;m=m*89884656743115795.0e291}else{if((g|0)>=-1022){f=g;break}m=m*2.2250738585072014e-308;f=g+1022|0;if((f|0)>=-1022)break;f=g+2044|0;f=(f|0)<-1022?-1022:f;m=m*2.2250738585072014e-308}while(0);_a=ee(f+1023|0,0,52)|0;hb=L;k[t>>2]=_a;k[t+4>>2]=hb;p[la>>3]=m*+p[t>>3]/n}while(0)}while(0);if((k[b>>2]|0)==(k[$a>>2]|0)?(ab=k[b+4>>2]|0,bb=k[b+12>>2]|0,(ab|0)!=(bb|0)):0){f=(k[b+24>>2]&32|0)!=0;h=e+8|0;g=k[h>>2]|0;h=k[h+4>>2]|0;p[t>>3]=+((f?bb:ab)|0);$a=k[t>>2]|0;_a=k[t+4>>2]|0;hb=(h|0)>-1|(h|0)==-1&g>>>0>4294967295;b=be(0,-2147483648,g|0,h|0)|0;g=hb?b:g;h=hb?L:h;hb=(_a|0)>-1|(_a|0)==-1&$a>>>0>4294967295;b=be(0,-2147483648,$a|0,_a|0)|0;$a=hb?b:$a;_a=hb?L:_a;hb=be(g|0,h|0,$a|0,_a|0)|0;b=L;if((h>>>0>_a>>>0|(h|0)==(_a|0)&g>>>0>$a>>>0)&(b>>>0>0|(b|0)==0&hb>>>0>64)){hb=0;r=gb;return hb|0}p[t>>3]=+((f?ab:bb)|0);$a=k[t>>2]|0;_a=k[t+4>>2]|0;ab=(_a|0)>-1|(_a|0)==-1&$a>>>0>4294967295;b=be(0,-2147483648,$a|0,_a|0)|0;$a=ab?b:$a;_a=ab?L:_a;ab=be(g|0,h|0,$a|0,_a|0)|0;b=L;hb=be($a|0,_a|0,g|0,h|0)|0;bb=L;if(((h>>>0>_a>>>0|(h|0)==(_a|0)&g>>>0>$a>>>0?(b>>>0>0|(b|0)==0&ab>>>0>64)<<31>>31:(bb>>>0>0|(bb|0)==0&hb>>>0>64)&1)|0)==1){hb=0;r=gb;return hb|0}}if((k[c>>2]|0)==(k[cb>>2]|0)?(db=k[c+4>>2]|0,eb=k[c+12>>2]|0,(db|0)!=(eb|0)):0){f=(k[c+24>>2]&32|0)!=0;h=e+8|0;g=k[h>>2]|0;h=k[h+4>>2]|0;p[t>>3]=+((f?eb:db)|0);cb=k[t>>2]|0;bb=k[t+4>>2]|0;hb=(h|0)>-1|(h|0)==-1&g>>>0>4294967295;c=be(0,-2147483648,g|0,h|0)|0;g=hb?c:g;h=hb?L:h;hb=(bb|0)>-1|(bb|0)==-1&cb>>>0>4294967295;c=be(0,-2147483648,cb|0,bb|0)|0;cb=hb?c:cb;bb=hb?L:bb;hb=be(g|0,h|0,cb|0,bb|0)|0;c=L;if((h>>>0>bb>>>0|(h|0)==(bb|0)&g>>>0>cb>>>0)&(c>>>0>0|(c|0)==0&hb>>>0>64)){hb=0;r=gb;return hb|0}p[t>>3]=+((f?db:eb)|0);cb=k[t>>2]|0;bb=k[t+4>>2]|0;db=(bb|0)>-1|(bb|0)==-1&cb>>>0>4294967295;c=be(0,-2147483648,cb|0,bb|0)|0;cb=db?c:cb;bb=db?L:bb;db=be(g|0,h|0,cb|0,bb|0)|0;c=L;hb=be(cb|0,bb|0,g|0,h|0)|0;eb=L;if(((h>>>0>bb>>>0|(h|0)==(bb|0)&g>>>0>cb>>>0?(c>>>0>0|(c|0)==0&db>>>0>64)<<31>>31:(eb>>>0>0|(eb|0)==0&hb>>>0>64)&1)|0)==1){hb=0;r=gb;return hb|0}}if((k[d>>2]|0)!=(k[fb>>2]|0)){hb=1;r=gb;return hb|0}j=k[d+4>>2]|0;l=k[d+12>>2]|0;if((j|0)==(l|0)){hb=1;r=gb;return hb|0}h=(k[d+24>>2]&32|0)!=0;g=e+8|0;f=k[g>>2]|0;g=k[g+4>>2]|0;p[t>>3]=+((h?l:j)|0);d=k[t>>2]|0;fb=k[t+4>>2]|0;hb=(g|0)>-1|(g|0)==-1&f>>>0>4294967295;e=be(0,-2147483648,f|0,g|0)|0;f=hb?e:f;g=hb?L:g;hb=(fb|0)>-1|(fb|0)==-1&d>>>0>4294967295;e=be(0,-2147483648,d|0,fb|0)|0;d=hb?e:d;fb=hb?L:fb;hb=be(f|0,g|0,d|0,fb|0)|0;e=L;if((g>>>0>fb>>>0|(g|0)==(fb|0)&f>>>0>d>>>0)&(e>>>0>0|(e|0)==0&hb>>>0>64)){hb=0;r=gb;return hb|0}p[t>>3]=+((h?j:l)|0);eb=k[t>>2]|0;db=k[t+4>>2]|0;d=(db|0)>-1|(db|0)==-1&eb>>>0>4294967295;fb=be(0,-2147483648,eb|0,db|0)|0;eb=d?fb:eb;db=d?L:db;d=be(f|0,g|0,eb|0,db|0)|0;fb=L;hb=be(eb|0,db|0,f|0,g|0)|0;e=L;hb=((g>>>0>db>>>0|(g|0)==(db|0)&f>>>0>eb>>>0?(fb>>>0>0|(fb|0)==0&d>>>0>64)<<31>>31:(e>>>0>0|(e|0)==0&hb>>>0>64)&1)|0)!=1;r=gb;return hb|0}function Oc(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0.0,h=0,i=0.0,j=0,l=0,m=0,n=0,o=0,q=0;f=a+16|0;c=_d(48)|0;a:do if(!c){while(1){c=k[35]|0;k[35]=c+0;if(!c)break;Xa[c&0]();c=_d(48)|0;if(c)break a}q=ya(4)|0;k[q>>2]=128;La(q|0,8,1)}while(0);e=c+8|0;d=e+40|0;do{k[e>>2]=k[b>>2];e=e+4|0;b=b+4|0}while((e|0)<(d|0));k[c>>2]=f;q=a+20|0;n=k[q>>2]|0;k[c+4>>2]=n;k[n>>2]=c;k[q>>2]=c;n=a+24|0;k[n>>2]=(k[n>>2]|0)+1;n=a+4|0;b=k[n>>2]|0;l=a+8|0;d=k[l>>2]|0;if(b>>>0>=d>>>0){m=k[a>>2]|0;e=m;j=b-e|0;f=j>>2;h=f+1|0;if(h>>>0>1073741823)xa(1340,1363,303,1438);b=d-e|0;if(b>>2>>>0<536870911){b=b>>1;b=b>>>0<h>>>0?h:b;if(!b){b=0;d=0}else o=11}else{b=1073741823;o=11}if((o|0)==11){e=b<<2;e=(e|0)==0?1:e;d=_d(e)|0;b:do if(!d){while(1){d=k[35]|0;k[35]=d+0;if(!d)break;Xa[d&0]();d=_d(e)|0;if(d)break b}q=ya(4)|0;k[q>>2]=128;La(q|0,8,1)}while(0)}k[d+(f<<2)>>2]=c;c=d+(h<<2)|0;fe(d|0,m|0,j|0)|0;k[a>>2]=d;k[n>>2]=c;k[l>>2]=d+(b<<2);if(m){$d(m);c=k[n>>2]|0}}else{k[b>>2]=c;c=(k[n>>2]|0)+4|0;k[n>>2]=c}j=k[a>>2]|0;o=c-j|0;f=o>>2;if((o|0)<=4){q=k[q>>2]|0;q=q+8|0;return q|0}h=(f+-2|0)/2|0;a=j+(h<<2)|0;d=c+-4|0;b=k[a>>2]|0;c=k[d>>2]|0;i=+p[c+24>>3];g=+p[b+24>>3];e=b;l=c;do if(i!=g)if(i<g){c=c+16|0;break}else{q=k[q>>2]|0;q=q+8|0;return q|0}else{c=c+16|0;if(!(+p[c>>3]<+p[b+16>>3])){q=k[q>>2]|0;q=q+8|0;return q|0}}while(0);k[d>>2]=e;c:do if((f+-1|0)>>>0>=3)while(1){b=h;h=(h+-1|0)/2|0;d=j+(h<<2)|0;e=k[d>>2]|0;g=+p[e+24>>3];f=e;if(i!=g){if(!(i<g))break c}else if(!(+p[c>>3]<+p[e+16>>3]))break c;k[a>>2]=f;if(b>>>0<3){a=d;break}else a=d}while(0);k[a>>2]=l;q=k[q>>2]|0;q=q+8|0;return q|0}function Pc(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0.0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0;j=((c|0)<0)<<31>>31;n=be(a|0,((a|0)<0)<<31>>31|0,c|0,j|0)|0;a=L;j=be(c|0,j|0,e|0,((e|0)<0)<<31>>31|0)|0;c=L;p=((d|0)<0)<<31>>31;l=be(b|0,((b|0)<0)<<31>>31|0,d|0,p|0)|0;k=L;p=be(d|0,p|0,f|0,((f|0)<0)<<31>>31|0)|0;o=L;h=(a|0)<0;b=be(0,0,n|0,a|0)|0;a=h?L:a;e=(k|0)<0;m=be(0,0,l|0,k|0)|0;k=e?L:k;i=(c|0)<0;d=be(0,0,j|0,c|0)|0;c=i?L:c;f=(o|0)<0;q=be(0,0,p|0,o|0)|0;a=ne((f?q:p)|0,(f?L:o)|0,(h?b:n)|0,a|0)|0;b=L;c=ne((e?m:l)|0,k|0,(i?d:j)|0,c|0)|0;d=L;e=i^e;do if(h^f){if(!e){q=ge(a|0,b|0,c|0,d|0)|0;g=-(+(q>>>0)+4294967296.0*+(L>>>0));break}if(b>>>0>d>>>0|(b|0)==(d|0)&a>>>0>c>>>0){q=be(a|0,b|0,c|0,d|0)|0;g=-(+(q>>>0)+4294967296.0*+(L>>>0));break}else{q=be(c|0,d|0,a|0,b|0)|0;g=+(q>>>0)+4294967296.0*+(L>>>0);break}}else{if(e){q=ge(a|0,b|0,c|0,d|0)|0;g=+(q>>>0)+4294967296.0*+(L>>>0);break}if(b>>>0<d>>>0|(b|0)==(d|0)&a>>>0<c>>>0){q=be(c|0,d|0,a|0,b|0)|0;g=-(+(q>>>0)+4294967296.0*+(L>>>0));break}else{q=be(a|0,b|0,c|0,d|0)|0;g=+(q>>>0)+4294967296.0*+(L>>>0);break}}while(0);return (g==0.0?0:g<0.0?-1:1)|0}function Qc(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0.0,h=0,j=0,l=0,m=0.0,n=0,o=0,q=0,s=0,u=0,v=0,w=0,x=0.0,y=0.0,z=0.0,A=0.0,B=0.0,C=0.0,D=0.0,E=0.0,F=0.0,G=0,H=0.0,I=0,J=0,K=0.0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0,U=0,V=0,W=0,Y=0,Z=0,_=0,$=0,aa=0.0,ba=0.0,ca=0.0,da=0.0,ea=0.0,fa=0.0,ga=0.0,ha=0.0,ia=0.0,ja=0.0,ka=0.0,la=0.0,ma=0.0,na=0.0,oa=0,pa=0,qa=0,ra=0,sa=0,ta=0,ua=0,va=0,wa=0,xa=0,ya=0,za=0,Aa=0,Ba=0,Ca=0,Da=0,Ea=0,Fa=0,Ga=0,Ha=0,Ia=0,Ja=0,Ka=0,La=0,Ma=0,Na=0,Oa=0,Pa=0,Qa=0,Ra=0,Sa=0,Ta=0,Ua=0,Va=0,Wa=0,Xa=0,Ya=0,Za=0,_a=0,$a=0,ab=0,bb=0,cb=0,db=0,eb=0,fb=0,gb=0,hb=0,ib=0,jb=0,kb=0,lb=0,mb=0,nb=0,ob=0,pb=0,qb=0,rb=0,sb=0,tb=0,ub=0,vb=0,wb=0,xb=0,yb=0,zb=0,Ab=0,Bb=0,Cb=0,Db=0,Eb=0,Fb=0,Gb=0,Hb=0,Ib=0,Jb=0,Kb=0,Lb=0;Ib=r;r=r+18272|0;bb=Ib+18008|0;Eb=Ib+16968|0;Fb=Ib+15928|0;Fa=Ib+15664|0;Ga=Ib+15404|0;Gb=Ib+15144|0;pa=Ib+14884|0;qa=Ib+14624|0;ib=Ib+14364|0;rb=Ib+14104|0;hb=Ib+13844|0;pb=Ib+13584|0;zb=Ib+13324|0;ra=Ib+13064|0;sa=Ib+12804|0;Cb=Ib+12544|0;ta=Ib+12284|0;ua=Ib+12024|0;Da=Ib+11764|0;Ea=Ib+11504|0;Xa=Ib+11244|0;xa=Ib+10984|0;za=Ib+10724|0;Ya=Ib+10464|0;Ba=Ib+10204|0;Ca=Ib+9944|0;yb=Ib+9684|0;Bb=Ib+9424|0;Ha=Ib+9164|0;Ia=Ib+8904|0;Ja=Ib+8644|0;Ka=Ib+8384|0;La=Ib+8124|0;Ma=Ib+7864|0;Na=Ib+7604|0;Oa=Ib+7344|0;Pa=Ib+7084|0;Qa=Ib+6824|0;Ra=Ib+6564|0;Za=Ib+6304|0;_a=Ib+6044|0;$a=Ib+5784|0;ab=Ib+5524|0;Db=Ib+48|0;Sa=Ib+5264|0;Ta=Ib+5004|0;Ua=Ib+4744|0;Va=Ib+4484|0;Wa=Ib+4224|0;cb=Ib+3964|0;db=Ib+3704|0;eb=Ib+3444|0;fb=Ib+3184|0;gb=Ib+2924|0;jb=Ib+32|0;kb=Ib+2664|0;lb=Ib+2404|0;mb=Ib+2144|0;nb=Ib+1884|0;ob=Ib+1624|0;qb=Ib+16|0;sb=Ib+1364|0;tb=Ib+1104|0;ub=Ib+844|0;vb=Ib+584|0;wb=Ib+324|0;xb=Ib+64|0;Ab=Ib;wa=d+12|0;v=k[wa>>2]|0;oa=d+4|0;q=k[oa>>2]|0;la=+(q|0);ma=+(v|0)-la;M=k[d>>2]|0;ja=+(M|0);Aa=d+8|0;N=k[Aa>>2]|0;na=ja-+(N|0);ya=c+4|0;O=k[ya>>2]|0;ga=+(O|0);va=b+4|0;P=k[va>>2]|0;ha=+(P|0);ba=ga-ha;Q=k[b>>2]|0;F=+(Q|0);R=k[c>>2]|0;aa=+(R|0);ia=F-aa;w=((v|0)<0)<<31>>31;s=((q|0)<0)<<31>>31;Z=be(v|0,w|0,q|0,s|0)|0;_=L;S=((M|0)<0)<<31>>31;T=((N|0)<0)<<31>>31;G=be(M|0,S|0,N|0,T|0)|0;I=L;U=((R|0)<0)<<31>>31;V=((Q|0)<0)<<31>>31;n=be(R|0,U|0,Q|0,V|0)|0;l=L;W=((O|0)<0)<<31>>31;Y=((P|0)<0)<<31>>31;j=be(O|0,W|0,P|0,Y|0)|0;h=L;$=(_|0)<0;J=be(0,0,Z|0,_|0)|0;Z=$?J:Z;_=$?L:_;J=(I|0)<0;o=be(0,0,G|0,I|0)|0;G=J?o:G;I=J?L:I;o=(l|0)<0;Jb=be(0,0,n|0,l|0)|0;l=o?L:l;u=(h|0)<0;Kb=be(0,0,j|0,h|0)|0;h=ne((u?Kb:j)|0,(u?L:h)|0,Z|0,_|0)|0;j=L;l=ne((o?Jb:n)|0,l|0,G|0,I|0)|0;n=L;o=J^o;do if($^u){if(!o){Kb=ge(l|0,n|0,h|0,j|0)|0;E=-(+(Kb>>>0)+4294967296.0*+(L>>>0));break}if(j>>>0>n>>>0|(j|0)==(n|0)&h>>>0>l>>>0){Kb=be(h|0,j|0,l|0,n|0)|0;E=-(+(Kb>>>0)+4294967296.0*+(L>>>0));break}else{Kb=be(l|0,n|0,h|0,j|0)|0;E=+(Kb>>>0)+4294967296.0*+(L>>>0);break}}else{if(o){Kb=ge(l|0,n|0,h|0,j|0)|0;E=+(Kb>>>0)+4294967296.0*+(L>>>0);break}if(j>>>0<n>>>0|(j|0)==(n|0)&h>>>0<l>>>0){Kb=be(l|0,n|0,h|0,j|0)|0;E=-(+(Kb>>>0)+4294967296.0*+(L>>>0));break}else{Kb=be(h|0,j|0,l|0,n|0)|0;E=+(Kb>>>0)+4294967296.0*+(L>>>0);break}}while(0);q=be(q|0,s|0,v|0,w|0)|0;s=L;n=be(v|0,w|0,P|0,Y|0)|0;l=L;j=be(N|0,T|0,Q|0,V|0)|0;h=L;u=(s|0)<0;o=be(0,0,q|0,s|0)|0;q=u?o:q;s=u?L:s;o=(l|0)<0;Jb=be(0,0,n|0,l|0)|0;l=o?L:l;Kb=(h|0)<0;Lb=be(0,0,j|0,h|0)|0;h=ne((Kb?Lb:j)|0,(Kb?L:h)|0,q|0,s|0)|0;j=L;l=ne((o?Jb:n)|0,l|0,G|0,I|0)|0;n=L;o=J^o;do if(u^Kb){if(!o){Lb=ge(h|0,j|0,l|0,n|0)|0;D=-(+(Lb>>>0)+4294967296.0*+(L>>>0));break}if(j>>>0>n>>>0|(j|0)==(n|0)&h>>>0>l>>>0){Lb=be(h|0,j|0,l|0,n|0)|0;D=-(+(Lb>>>0)+4294967296.0*+(L>>>0));break}else{Lb=be(l|0,n|0,h|0,j|0)|0;D=+(Lb>>>0)+4294967296.0*+(L>>>0);break}}else{if(o){Lb=ge(h|0,j|0,l|0,n|0)|0;D=+(Lb>>>0)+4294967296.0*+(L>>>0);break}if(j>>>0<n>>>0|(j|0)==(n|0)&h>>>0<l>>>0){Lb=be(l|0,n|0,h|0,j|0)|0;D=-(+(Lb>>>0)+4294967296.0*+(L>>>0));break}else{Lb=be(h|0,j|0,l|0,n|0)|0;D=+(Lb>>>0)+4294967296.0*+(L>>>0);break}}while(0);l=be(v|0,w|0,O|0,W|0)|0;j=L;o=be(N|0,T|0,R|0,U|0)|0;n=L;h=(j|0)<0;Kb=be(0,0,l|0,j|0)|0;j=h?L:j;Lb=(n|0)<0;Jb=be(0,0,o|0,n|0)|0;n=ne((Lb?Jb:o)|0,(Lb?L:n)|0,q|0,s|0)|0;o=L;j=ne((h?Kb:l)|0,j|0,G|0,I|0)|0;l=L;h=J^h;do if(u^Lb){if(!h){Lb=ge(n|0,o|0,j|0,l|0)|0;z=-(+(Lb>>>0)+4294967296.0*+(L>>>0));break}if(o>>>0>l>>>0|(o|0)==(l|0)&n>>>0>j>>>0){Lb=be(n|0,o|0,j|0,l|0)|0;z=-(+(Lb>>>0)+4294967296.0*+(L>>>0));break}else{Lb=be(j|0,l|0,n|0,o|0)|0;z=+(Lb>>>0)+4294967296.0*+(L>>>0);break}}else{if(h){Lb=ge(n|0,o|0,j|0,l|0)|0;z=+(Lb>>>0)+4294967296.0*+(L>>>0);break}if(o>>>0<l>>>0|(o|0)==(l|0)&n>>>0<j>>>0){Lb=be(j|0,l|0,n|0,o|0)|0;z=-(+(Lb>>>0)+4294967296.0*+(L>>>0));break}else{Lb=be(n|0,o|0,j|0,l|0)|0;z=+(Lb>>>0)+4294967296.0*+(L>>>0);break}}while(0);o=be(P|0,Y|0,O|0,W|0)|0;n=L;l=be(Q|0,V|0,R|0,U|0)|0;j=L;V=be(N|0,T|0,M|0,S|0)|0;W=L;Kb=(n|0)<0;Y=be(0,0,o|0,n|0)|0;n=Kb?L:n;h=(j|0)<0;Jb=be(0,0,l|0,j|0)|0;j=h?L:j;Lb=(W|0)<0;U=be(0,0,V|0,W|0)|0;n=ne((Lb?U:V)|0,(Lb?L:W)|0,(Kb?Y:o)|0,n|0)|0;o=L;j=ne(Z|0,_|0,(h?Jb:l)|0,j|0)|0;l=L;h=h^$;do if(Kb^Lb){if(!h){Lb=ge(n|0,o|0,j|0,l|0)|0;y=-(+(Lb>>>0)+4294967296.0*+(L>>>0));break}if(o>>>0>l>>>0|(o|0)==(l|0)&n>>>0>j>>>0){Lb=be(n|0,o|0,j|0,l|0)|0;y=-(+(Lb>>>0)+4294967296.0*+(L>>>0));break}else{Lb=be(j|0,l|0,n|0,o|0)|0;y=+(Lb>>>0)+4294967296.0*+(L>>>0);break}}else{if(h){Lb=ge(n|0,o|0,j|0,l|0)|0;y=+(Lb>>>0)+4294967296.0*+(L>>>0);break}if(o>>>0<l>>>0|(o|0)==(l|0)&n>>>0<j>>>0){Lb=be(j|0,l|0,n|0,o|0)|0;y=-(+(Lb>>>0)+4294967296.0*+(L>>>0));break}else{Lb=be(n|0,o|0,j|0,l|0)|0;y=+(Lb>>>0)+4294967296.0*+(L>>>0);break}}while(0);ka=1.0/+X(+(ma*ma+na*na));do if(y==0.0){m=E/(D*8.0);if(m<0.0){g=0.0-m;if(m>0.0){m=(m*4.0+0.0)/g;m=m<0.0?-m:m}else m=4.0;A=g;z=m+1.0;y=0.0;x=0.0}else{A=0.0;z=0.0;y=m+0.0;x=5.0}g=D/(E*2.0);if(g<0.0){m=y-g;if(y<0.0|g>0.0){g=(y*x+g*4.0)/m;g=g<0.0?-g:g}else g=x<4.0?4.0:x;x=g+1.0;K=z;y=m;H=A;break}else{m=A+g;if(A<0.0?A>0.0|g>0.0:0){K=(A*z-g*4.0)/m;K=(K<0.0?-K:K)+1.0;H=m;break}K=z<4.0?5.0:z+1.0;H=m;break}}else{m=y*y;m=+X(+(z*(D*(E*E+m))))/m;h=m<0.0;do if((e|0)==2){if(!h){C=0.0;x=0.0;B=m+0.0;A=10.0;break}g=0.0-m;if(m>0.0){m=(m*9.0+0.0)/g;m=m<0.0?-m:m}else m=9.0;C=g;x=m+1.0;B=0.0;A=0.0}else{if(!h){C=m+0.0;x=10.0;B=0.0;A=0.0;break}g=0.0-m;if(m>0.0){m=(m*9.0+0.0)/g;m=m<0.0?-m:m}else m=9.0;C=0.0;x=0.0;B=g;A=m+1.0}while(0);m=D+z;if(D<0.0|z<0.0?D>0.0|z>0.0:0){g=(D-z)/m;if(g<0.0)g=-g}else g=1.0;m=E*m/(y*(y*2.0));g=g+1.0+1.0+1.0+4.0+1.0;if(m<0.0){z=B-m;if(B<0.0|m>0.0){g=(B*A+m*g)/z;g=g<0.0?-g:g}else g=A<g?g:A;K=g+1.0;y=C;H=z;break}else{y=C+m;if(C<0.0?C>0.0|m>0.0:0){x=(C*x-m*g)/y;x=(x<0.0?-x:x)+1.0;K=A;H=B;break}x=(x<g?g:x)+1.0;K=A;H=B;break}}while(0);g=(F+aa)*.5;if(g<0.0){m=0.0-g;if(g>0.0){g=(g*0.0+0.0)/m;g=g<0.0?-g:g}else g=0.0;C=0.0;D=0.0;F=g+1.0}else{C=g+0.0;D=1.0;m=0.0;F=0.0}if(ba<0.0){A=-ba;g=x;E=y*A;z=K;A=H*A}else{g=K;E=ba*H;z=x;A=ba*y}B=g+0.0+1.0;g=z+0.0+1.0;fa=C+A;if(C<0.0|A<0.0?C>0.0|A>0.0:0){g=(C*D-A*g)/fa;g=g<0.0?-g:g}else g=D<g?g:D;da=g+1.0;ea=m+E;if(m<0.0|E<0.0?m>0.0|E>0.0:0){g=(m*F-E*B)/ea;g=g<0.0?-g:g}else g=F<B?B:F;ca=g+1.0;g=(ha+ga)*.5;if(g<0.0){m=0.0-g;if(g>0.0){g=(g*0.0+0.0)/m;g=g<0.0?-g:g}else g=0.0;A=0.0;B=0.0;D=g+1.0}else{A=g+0.0;B=1.0;m=0.0;D=0.0}if(ia<0.0){ia=-ia;z=x;C=y*ia;g=K;x=H*ia}else{z=K;C=ia*H;g=x;x=ia*y}y=z+0.0+1.0;g=g+0.0+1.0;ba=A+x;if(A<0.0|x<0.0?A>0.0|x>0.0:0){g=(A*B-x*g)/ba;g=g<0.0?-g:g}else g=B<g?g:B;K=g+1.0;aa=m+C;if(m<0.0|C<0.0?m>0.0|C>0.0:0){g=(m*D-C*y)/aa;g=g<0.0?-g:g}else g=D<y?y:D;H=g+1.0;g=ma*ja;if(g<0.0){m=0.0-g;if(g>0.0){g=(g+0.0)/m;g=g<0.0?-g:g}else g=1.0;z=0.0;A=0.0;y=g+1.0}else{z=g+0.0;A=2.0;m=0.0;y=0.0}g=na*la;do if(g<0.0){x=m-g;if(m<0.0|g>0.0){g=(m*y+g)/x;g=g<0.0?-g:g}else g=y<1.0?1.0:y;m=x;C=g+1.0;x=z;D=A}else{x=z+g;if(z<0.0?z>0.0|g>0.0:0){D=(z*A-g)/x;C=y;D=(D<0.0?-D:D)+1.0;break}C=y;D=A<1.0?2.0:A+1.0}while(0);if(ma<0.0){z=-ma;g=da;B=fa*z;y=ca;z=ea*z}else{g=ca;B=ma*ea;y=da;z=ma*fa}A=g+0.0+1.0;g=y+0.0+1.0;F=m+z;if(m<0.0|z<0.0?m>0.0|z>0.0:0){g=(m*C-z*g)/F;g=g<0.0?-g:g}else g=C<g?g:C;C=g+1.0;E=x+B;if(x<0.0|B<0.0?x>0.0|B>0.0:0){g=(x*D-B*A)/E;g=g<0.0?-g:g}else g=D<A?A:D;B=g+1.0;if(na<0.0){x=-na;g=K;z=ba*x;m=H;x=aa*x}else{g=H;z=na*aa;m=K;x=na*ba}y=g+0.0+1.0;g=m+0.0+1.0;m=F+x;do if(F<0.0|x<0.0){if(!(F>0.0|x>0.0)){Hb=146;break}g=(F*C-x*g)/m;g=g<0.0?-g:g}else Hb=146;while(0);if((Hb|0)==146)g=C<g?g:C;x=g+1.0;A=E+z;do if(E<0.0|z<0.0){if(!(E>0.0|z>0.0)){Hb=150;break}g=(E*B-z*y)/A;g=g<0.0?-g:g}else Hb=150;while(0);if((Hb|0)==150)g=B<y?y:B;g=g+1.0;if(m<A){y=g;g=x;z=A}else{y=x;z=m;m=A}if(ka<0.0){x=g;g=y;A=-(ka*z);m=-(ka*m)}else{x=y;A=ka*m;m=ka*z}y=g+3.0+1.0;g=x+3.0+1.0;C=fa+m;l=fa<0.0;do if(l|m<0.0){if(!(fa>0.0|m>0.0)){Hb=159;break}g=(fa*da-m*g)/C;g=g<0.0?-g:g}else Hb=159;while(0);if((Hb|0)==159)g=da<g?g:da;z=g+1.0;B=ea+A;h=ea<0.0;do if(h|A<0.0){if(!(ea>0.0|A>0.0)){Hb=163;break}g=(ea*ca-A*y)/B;g=g<0.0?-g:g}else Hb=163;while(0);if((Hb|0)==163)g=ca<y?y:ca;x=g+1.0;g=fa-ea;m=ba-aa;j=ba<0.0|aa>0.0;y=C-B;n=C<0.0|B>0.0;p[f>>3]=g;O=f+8|0;p[O>>3]=m;P=f+16|0;p[P>>3]=y;i[f+24>>0]=1;do if((l|ea>0.0)&(fa>0.0|h)){g=(fa*da+ea*ca)/g;if(!(g<0.0))break;g=-g}else g=da<ca?ca:da;while(0);J=g+1.0>64.0;do if(j){if(!(ba>0.0|aa<0.0)){Hb=171;break}g=(ba*K+aa*H)/m;if(!(g<0.0))break;g=-g}else Hb=171;while(0);if((Hb|0)==171)g=K<H?H:K;M=g+1.0>64.0;do if(n){if(!(C>0.0|B<0.0)){Hb=176;break}g=(C*z+B*x)/y;if(!(g<0.0))break;g=-g}else Hb=176;while(0);if((Hb|0)==176)g=z<x?x:z;N=g+1.0>64.0;if(!(J|M|N)){r=Ib;return}j=k[wa>>2]|0;h=k[oa>>2]|0;h=be(j|0,((j|0)<0)<<31>>31|0,h|0,((h|0)<0)<<31>>31|0)|0;j=L;do if(!((j|0)>0|(j|0)==0&h>>>0>0))if((j|0)<0){Kb=be(0,0,h|0,j|0)|0;Lb=L;k[Fa>>2]=Kb;k[Fa+4>>2]=Lb;k[Fa+256>>2]=(Lb|0)!=0?-2:-1;break}else{k[Fa+256>>2]=0;break}else{k[Fa>>2]=h;k[Fa+4>>2]=j;k[Fa+256>>2]=(j|0)!=0?2:1}while(0);j=k[d>>2]|0;h=k[Aa>>2]|0;h=be(j|0,((j|0)<0)<<31>>31|0,h|0,((h|0)<0)<<31>>31|0)|0;j=L;do if(!((j|0)>0|(j|0)==0&h>>>0>0))if((j|0)<0){Kb=be(0,0,h|0,j|0)|0;Lb=L;k[Ga>>2]=Kb;k[Ga+4>>2]=Lb;k[Ga+256>>2]=(Lb|0)!=0?-2:-1;break}else{k[Ga+256>>2]=0;break}else{k[Ga>>2]=h;k[Ga+4>>2]=j;k[Ga+256>>2]=(j|0)!=0?2:1}while(0);Sc(pa,Fa,Fa);Sc(qa,Ga,Ga);Tc(Gb,pa,qa);s=k[ya>>2]|0;u=((s|0)<0)<<31>>31;v=k[va>>2]|0;w=((v|0)<0)<<31>>31;h=be(s|0,u|0,v|0,w|0)|0;j=L;do if(!((j|0)>0|(j|0)==0&h>>>0>0))if((j|0)<0){Lb=be(0,0,h|0,j|0)|0;G=L;k[ib>>2]=Lb;k[ib+4>>2]=G;G=(G|0)!=0?-2:-1;k[ib+256>>2]=G;break}else{k[ib+256>>2]=0;G=0;break}else{k[ib>>2]=h;k[ib+4>>2]=j;G=(j|0)!=0?2:1;k[ib+256>>2]=G}while(0);l=k[b>>2]|0;n=((l|0)<0)<<31>>31;o=k[c>>2]|0;q=((o|0)<0)<<31>>31;h=be(l|0,n|0,o|0,q|0)|0;j=L;do if(!((j|0)>0|(j|0)==0&h>>>0>0))if((j|0)<0){Lb=be(0,0,h|0,j|0)|0;I=L;k[rb>>2]=Lb;k[rb+4>>2]=I;I=(I|0)!=0?-2:-1;k[rb+256>>2]=I;break}else{k[rb+256>>2]=0;I=0;break}else{k[rb>>2]=h;k[rb+4>>2]=j;I=(j|0)!=0?2:1;k[rb+256>>2]=I}while(0);h=ge(o|0,q|0,l|0,n|0)|0;j=L;do if(!((j|0)>0|(j|0)==0&h>>>0>0))if((j|0)<0){Kb=be(0,0,h|0,j|0)|0;Lb=L;k[hb>>2]=Kb;k[hb+4>>2]=Lb;k[hb+256>>2]=(Lb|0)!=0?-2:-1;break}else{k[hb+256>>2]=0;break}else{k[hb>>2]=h;k[hb+4>>2]=j;k[hb+256>>2]=(j|0)!=0?2:1}while(0);h=ge(s|0,u|0,v|0,w|0)|0;j=L;do if(!((j|0)>0|(j|0)==0&h>>>0>0))if((j|0)<0){Kb=be(0,0,h|0,j|0)|0;Lb=L;k[pb>>2]=Kb;k[pb+4>>2]=Lb;k[pb+256>>2]=(Lb|0)!=0?-2:-1;break}else{k[pb+256>>2]=0;break}else{k[pb>>2]=h;k[pb+4>>2]=j;k[pb+256>>2]=(j|0)!=0?2:1}while(0);Sc(ra,Fa,ib);Sc(sa,Ga,rb);Tc(zb,ra,sa);Sc(ta,ib,Ga);Sc(ua,rb,Fa);Uc(Cb,ta,ua);j=k[wa>>2]|0;h=k[va>>2]|0;h=be(j|0,((j|0)<0)<<31>>31|0,h|0,((h|0)<0)<<31>>31|0)|0;j=L;do if(!((j|0)>0|(j|0)==0&h>>>0>0))if((j|0)<0){Kb=be(0,0,h|0,j|0)|0;Lb=L;k[Da>>2]=Kb;k[Da+4>>2]=Lb;k[Da+256>>2]=(Lb|0)!=0?-2:-1;break}else{k[Da+256>>2]=0;break}else{k[Da>>2]=h;k[Da+4>>2]=j;k[Da+256>>2]=(j|0)!=0?2:1}while(0);j=k[b>>2]|0;h=k[Aa>>2]|0;h=be(j|0,((j|0)<0)<<31>>31|0,h|0,((h|0)<0)<<31>>31|0)|0;j=L;do if(!((j|0)>0|(j|0)==0&h>>>0>0))if((j|0)<0){Kb=be(0,0,h|0,j|0)|0;Lb=L;k[Ea>>2]=Kb;k[Ea+4>>2]=Lb;k[Ea+256>>2]=(Lb|0)!=0?-2:-1;break}else{k[Ea+256>>2]=0;break}else{k[Ea>>2]=h;k[Ea+4>>2]=j;k[Ea+256>>2]=(j|0)!=0?2:1}while(0);Sc(xa,Fa,Ea);Sc(za,Ga,Da);Uc(Xa,xa,za);j=k[wa>>2]|0;h=k[ya>>2]|0;h=be(j|0,((j|0)<0)<<31>>31|0,h|0,((h|0)<0)<<31>>31|0)|0;j=L;do if(!((j|0)>0|(j|0)==0&h>>>0>0))if((j|0)<0){Kb=be(0,0,h|0,j|0)|0;Lb=L;k[Da>>2]=Kb;k[Da+4>>2]=Lb;k[Da+256>>2]=(Lb|0)!=0?-2:-1;break}else{k[Da+256>>2]=0;break}else{k[Da>>2]=h;k[Da+4>>2]=j;k[Da+256>>2]=(j|0)!=0?2:1}while(0);j=k[c>>2]|0;h=k[Aa>>2]|0;h=be(j|0,((j|0)<0)<<31>>31|0,h|0,((h|0)<0)<<31>>31|0)|0;j=L;do if(!((j|0)>0|(j|0)==0&h>>>0>0))if((j|0)<0){Kb=be(0,0,h|0,j|0)|0;Lb=L;k[Ea>>2]=Kb;k[Ea+4>>2]=Lb;k[Ea+256>>2]=(Lb|0)!=0?-2:-1;break}else{k[Ea+256>>2]=0;break}else{k[Ea>>2]=h;k[Ea+4>>2]=j;k[Ea+256>>2]=(j|0)!=0?2:1}while(0);Sc(Ba,Fa,Ea);Sc(Ca,Ga,Da);Uc(Ya,Ba,Ca);Tc(yb,Xa,Ya);h=Cb+256|0;if(!(k[h>>2]|0)){Sc(Ha,zb,zb);Sc(Ia,yb,yb);Uc(Bb,Ha,Ia);Sc(Ja,zb,yb);fe(Cb|0,Ja|0,260)|0;Sc(La,Cb,hb);k[bb>>2]=2;k[bb+256>>2]=1;Sc(Ma,La,bb);Sc(Na,Bb,ib);Tc(Ka,Ma,Na);fe(Eb|0,Ka|0,260)|0;fe(Fb|0,Gb|0,260)|0;Sc(Pa,Cb,yb);k[bb>>2]=2;k[bb+256>>2]=1;Sc(Qa,Pa,bb);Sc(Ra,Bb,zb);Tc(Oa,Qa,Ra);fe(Eb+260|0,Oa|0,260)|0;k[Fb+260>>2]=1;k[Fb+516>>2]=1;n=Eb+520|0;Sc(_a,Cb,pb);k[bb>>2]=2;k[bb+256>>2]=1;Sc($a,_a,bb);Sc(ab,Bb,rb);Tc(Za,$a,ab);fe(n|0,Za|0,260)|0;j=k[h>>2]|0;h=(j|0)>-1?j:0-j|0;a:do switch(h|0){case 0:{h=0;g=0.0;break}case 1:{g=+((k[Cb>>2]|0)>>>0);Hb=234;break}case 2:{g=+((k[Cb+4>>2]|0)>>>0)*4294967296.0+ +((k[Cb>>2]|0)>>>0);Hb=234;break}default:{g=+((k[Cb+(h+-3<<2)>>2]|0)>>>0)+(+((k[Cb+(h+-1<<2)>>2]|0)>>>0)*4294967296.0+ +((k[Cb+(h+-2<<2)>>2]|0)>>>0))*4294967296.0;l=h<<5;h=l+-96|0;g=(j|0)<0?-g:g;if((h|0)>1023){g=g*89884656743115795.0e291;h=l+-1119|0;if((h|0)<=1023)break a;h=l+-2142|0;h=(h|0)>1023?1023:h;g=g*89884656743115795.0e291;break a}if((h|0)>=-1022)break a;g=g*2.2250738585072014e-308;h=l+926|0;if((h|0)>=-1022)break a;h=l+1948|0;h=(h|0)<-1022?-1022:h;g=g*2.2250738585072014e-308}}while(0);if((Hb|0)==234){h=0;g=(j|0)<0?-g:g}Kb=ee(h+1023|0,0,52)|0;Lb=L;k[t>>2]=Kb;k[t+4>>2]=Lb;m=1.0/(g*+p[t>>3]);if(J){j=k[Eb+256>>2]|0;h=(j|0)>-1?j:0-j|0;b:do switch(h|0){case 0:{h=0;g=0.0;break}case 1:{g=+((k[Eb>>2]|0)>>>0);Hb=245;break}case 2:{g=+((k[Eb+4>>2]|0)>>>0)*4294967296.0+ +((k[Eb>>2]|0)>>>0);Hb=245;break}default:{g=+((k[Eb+(h+-3<<2)>>2]|0)>>>0)+(+((k[Eb+(h+-1<<2)>>2]|0)>>>0)*4294967296.0+ +((k[Eb+(h+-2<<2)>>2]|0)>>>0))*4294967296.0;l=h<<5;h=l+-96|0;g=(j|0)<0?-g:g;if((h|0)>1023){g=g*89884656743115795.0e291;h=l+-1119|0;if((h|0)<=1023)break b;h=l+-2142|0;h=(h|0)>1023?1023:h;g=g*89884656743115795.0e291;break b}if((h|0)>=-1022)break b;g=g*2.2250738585072014e-308;h=l+926|0;if((h|0)>=-1022)break b;h=l+1948|0;h=(h|0)<-1022?-1022:h;g=g*2.2250738585072014e-308}}while(0);if((Hb|0)==245){h=0;g=(j|0)<0?-g:g}Kb=ee(h+1023|0,0,52)|0;Lb=L;k[t>>2]=Kb;k[t+4>>2]=Lb;p[f>>3]=m*(g*+p[t>>3]*.25)}if(M){j=k[Eb+776>>2]|0;h=(j|0)>-1?j:0-j|0;c:do switch(h|0){case 0:{h=0;g=0.0;break}case 1:{g=+((k[n>>2]|0)>>>0);Hb=257;break}case 2:{g=+((k[Eb+524>>2]|0)>>>0)*4294967296.0+ +((k[n>>2]|0)>>>0);Hb=257;break}default:{g=+((k[Eb+520+(h+-3<<2)>>2]|0)>>>0)+(+((k[Eb+520+(h+-1<<2)>>2]|0)>>>0)*4294967296.0+ +((k[Eb+520+(h+-2<<2)>>2]|0)>>>0))*4294967296.0;l=h<<5;h=l+-96|0;g=(j|0)<0?-g:g;if((h|0)>1023){g=g*89884656743115795.0e291;h=l+-1119|0;if((h|0)<=1023)break c;h=l+-2142|0;h=(h|0)>1023?1023:h;g=g*89884656743115795.0e291;break c}if((h|0)>=-1022)break c;g=g*2.2250738585072014e-308;h=l+926|0;if((h|0)>=-1022)break c;h=l+1948|0;h=(h|0)<-1022?-1022:h;g=g*2.2250738585072014e-308}}while(0);if((Hb|0)==257){h=0;g=(j|0)<0?-g:g}Kb=ee(h+1023|0,0,52)|0;Lb=L;k[t>>2]=Kb;k[t+4>>2]=Lb;p[O>>3]=m*(g*+p[t>>3]*.25)}if(N){Xc(Db,Eb,Fb);g=+p[Db>>3];j=k[Db+8>>2]|0;do if((j|0)>1023){g=g*89884656743115795.0e291;h=j+-1023|0;if((h|0)<=1023)break;h=j+-2046|0;h=(h|0)>1023?1023:h;g=g*89884656743115795.0e291}else{if((j|0)>=-1022){h=j;break}g=g*2.2250738585072014e-308;h=j+1022|0;if((h|0)>=-1022)break;h=j+2044|0;h=(h|0)<-1022?-1022:h;g=g*2.2250738585072014e-308}while(0);h=ee(h+1023|0,0,52)|0;j=L;k[t>>2]=h;k[t+4>>2]=j;m=m*(g*+p[t>>3]*.25);j=k[Gb+256>>2]|0;h=(j|0)>-1?j:0-j|0;d:do switch(h|0){case 0:{h=0;g=0.0;break}case 1:{g=+((k[Gb>>2]|0)>>>0);Hb=275;break}case 2:{g=+((k[Gb+4>>2]|0)>>>0)*4294967296.0+ +((k[Gb>>2]|0)>>>0);Hb=275;break}default:{g=+((k[Gb+(h+-3<<2)>>2]|0)>>>0)+(+((k[Gb+(h+-1<<2)>>2]|0)>>>0)*4294967296.0+ +((k[Gb+(h+-2<<2)>>2]|0)>>>0))*4294967296.0;l=h<<5;h=l+-96|0;g=(j|0)<0?-g:g;if((h|0)>1023){g=g*89884656743115795.0e291;h=l+-1119|0;if((h|0)<=1023)break d;h=l+-2142|0;h=(h|0)>1023?1023:h;g=g*89884656743115795.0e291;break d}if((h|0)>=-1022)break d;g=g*2.2250738585072014e-308;h=l+926|0;if((h|0)>=-1022)break d;h=l+1948|0;h=(h|0)<-1022?-1022:h;g=g*2.2250738585072014e-308}}while(0);if((Hb|0)==275){h=0;g=(j|0)<0?-g:g}Kb=ee(h+1023|0,0,52)|0;Lb=L;k[t>>2]=Kb;k[t+4>>2]=Lb;na=m/+X(+(g*+p[t>>3]));p[P>>3]=na}}else{Sc(Sa,zb,zb);Sc(Ta,Cb,Cb);Tc(Ua,Sa,Ta);Sc(Va,Ua,Xa);Sc(Wa,Va,Ya);k[bb>>2]=4;k[bb+256>>2]=1;Sc(Bb,Wa,bb);j=k[h>>2]|0;h=(j|0)>-1?j:0-j|0;e:do switch(h|0){case 0:{h=0;g=0.0;break}case 1:{g=+((k[Cb>>2]|0)>>>0);Hb=287;break}case 2:{g=+((k[Cb+4>>2]|0)>>>0)*4294967296.0+ +((k[Cb>>2]|0)>>>0);Hb=287;break}default:{g=+((k[Cb+(h+-3<<2)>>2]|0)>>>0)+(+((k[Cb+(h+-1<<2)>>2]|0)>>>0)*4294967296.0+ +((k[Cb+(h+-2<<2)>>2]|0)>>>0))*4294967296.0;l=h<<5;h=l+-96|0;g=(j|0)<0?-g:g;if((h|0)>1023){g=g*89884656743115795.0e291;h=l+-1119|0;if((h|0)<=1023)break e;h=l+-2142|0;h=(h|0)>1023?1023:h;g=g*89884656743115795.0e291;break e}if((h|0)>=-1022)break e;g=g*2.2250738585072014e-308;h=l+926|0;if((h|0)>=-1022)break e;h=l+1948|0;h=(h|0)<-1022?-1022:h;g=g*2.2250738585072014e-308}}while(0);if((Hb|0)==287){h=0;g=(j|0)<0?-g:g}Kb=ee(h+1023|0,0,52)|0;Lb=L;k[t>>2]=Kb;k[t+4>>2]=Lb;m=1.0/(g*+p[t>>3]);m=m*m;do if(J|N){Sc(db,hb,Cb);Sc(eb,db,Cb);Sc(gb,zb,yb);Sc(fb,gb,ib);Tc(cb,eb,fb);fe(Eb|0,cb|0,260)|0;k[Fb>>2]=1;k[Fb+256>>2]=1;fe(Eb+260|0,ib|0,256)|0;k[Eb+516>>2]=(e|0)==2?0-G|0:G;fe(Fb+260|0,Bb|0,260)|0;if(!J)break;Xc(jb,Eb,Fb);g=+p[jb>>3];j=k[jb+8>>2]|0;do if((j|0)>1023){g=g*89884656743115795.0e291;h=j+-1023|0;if((h|0)<=1023)break;h=j+-2046|0;h=(h|0)>1023?1023:h;g=g*89884656743115795.0e291}else{if((j|0)>=-1022){h=j;break}g=g*2.2250738585072014e-308;h=j+1022|0;if((h|0)>=-1022)break;h=j+2044|0;h=(h|0)<-1022?-1022:h;g=g*2.2250738585072014e-308}while(0);Kb=ee(h+1023|0,0,52)|0;Lb=L;k[t>>2]=Kb;k[t+4>>2]=Lb;p[f>>3]=m*(g*+p[t>>3]*.5)}while(0);do if(M|N){j=Eb+520|0;Sc(lb,pb,Cb);Sc(mb,lb,Cb);Sc(ob,zb,yb);Sc(nb,ob,rb);Tc(kb,mb,nb);fe(j|0,kb|0,260)|0;h=Fb+520|0;k[h>>2]=1;k[Fb+776>>2]=1;fe(Eb+780|0,rb|0,256)|0;k[Eb+1036>>2]=(e|0)==2?0-I|0:I;fe(Fb+780|0,Bb|0,260)|0;if(!M)break;Xc(qb,j,h);g=+p[qb>>3];j=k[qb+8>>2]|0;do if((j|0)>1023){g=g*89884656743115795.0e291;h=j+-1023|0;if((h|0)<=1023)break;h=j+-2046|0;h=(h|0)>1023?1023:h;g=g*89884656743115795.0e291}else{if((j|0)>=-1022){h=j;break}g=g*2.2250738585072014e-308;h=j+1022|0;if((h|0)>=-1022)break;h=j+2044|0;h=(h|0)<-1022?-1022:h;g=g*2.2250738585072014e-308}while(0);Kb=ee(h+1023|0,0,52)|0;Lb=L;k[t>>2]=Kb;k[t+4>>2]=Lb;p[O>>3]=m*(g*+p[t>>3]*.5)}while(0);if(N){Sc(sb,Fb,Gb);fe(Fb|0,sb|0,260)|0;j=Fb+260|0;Sc(tb,j,Gb);fe(j|0,tb|0,260)|0;Sc(wb,Cb,Cb);Sc(xb,zb,zb);Tc(vb,wb,xb);Sc(ub,yb,vb);fe(Eb+520|0,ub|0,260)|0;k[Fb+520>>2]=1;k[Fb+776>>2]=1;j=k[zb+256>>2]|0;fe(Eb+780|0,zb|0,256)|0;k[Eb+1036>>2]=(e|0)==2?0-j|0:j;fe(Fb+780|0,Bb|0,260)|0;Wc(Ab,a,Eb,Fb);g=+p[Ab>>3];j=k[Ab+8>>2]|0;do if((j|0)>1023){g=g*89884656743115795.0e291;h=j+-1023|0;if((h|0)<=1023)break;h=j+-2046|0;h=(h|0)>1023?1023:h;g=g*89884656743115795.0e291}else{if((j|0)>=-1022){h=j;break}g=g*2.2250738585072014e-308;h=j+1022|0;if((h|0)>=-1022)break;h=j+2044|0;h=(h|0)<-1022?-1022:h;g=g*2.2250738585072014e-308}while(0);h=ee(h+1023|0,0,52)|0;j=L;k[t>>2]=h;k[t+4>>2]=j;m=m*(g*+p[t>>3]*.5);j=k[Gb+256>>2]|0;h=(j|0)>-1?j:0-j|0;f:do switch(h|0){case 0:{h=0;g=0.0;break}case 1:{g=+((k[Gb>>2]|0)>>>0);Hb=322;break}case 2:{g=+((k[Gb+4>>2]|0)>>>0)*4294967296.0+ +((k[Gb>>2]|0)>>>0);Hb=322;break}default:{g=+((k[Gb+(h+-3<<2)>>2]|0)>>>0)+(+((k[Gb+(h+-1<<2)>>2]|0)>>>0)*4294967296.0+ +((k[Gb+(h+-2<<2)>>2]|0)>>>0))*4294967296.0;l=h<<5;h=l+-96|0;g=(j|0)<0?-g:g;if((h|0)>1023){g=g*89884656743115795.0e291;h=l+-1119|0;if((h|0)<=1023)break f;h=l+-2142|0;h=(h|0)>1023?1023:h;g=g*89884656743115795.0e291;break f}if((h|0)>=-1022)break f;g=g*2.2250738585072014e-308;h=l+926|0;if((h|0)>=-1022)break f;h=l+1948|0;h=(h|0)<-1022?-1022:h;g=g*2.2250738585072014e-308}}while(0);if((Hb|0)==322){h=0;g=(j|0)<0?-g:g}Kb=ee(h+1023|0,0,52)|0;Lb=L;k[t>>2]=Kb;k[t+4>>2]=Lb;na=m/+X(+(g*+p[t>>3]));p[P>>3]=na}}r=Ib;return}function Rc(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0.0,h=0,j=0,l=0,m=0.0,n=0,o=0.0,q=0,s=0,u=0.0,v=0.0,w=0.0,x=0.0,y=0.0,z=0.0,A=0.0,B=0.0,C=0,D=0.0,E=0.0,F=0,G=0.0,H=0,I=0.0,J=0.0,K=0.0,M=0,N=0,O=0.0,P=0,Q=0,R=0,S=0,T=0.0,U=0.0,V=0,W=0,Y=0,Z=0,_=0,$=0,aa=0.0,ba=0,ca=0.0,da=0,ea=0.0,fa=0.0,ga=0.0,ia=0.0,ja=0.0,ka=0,la=0,ma=0.0,na=0,oa=0,pa=0,qa=0.0,ra=0,sa=0.0,ta=0.0,ua=0,va=0,wa=0,xa=0,ya=0,za=0,Aa=0,Ba=0.0,Ca=0,Da=0,Ea=0,Fa=0,Ga=0,Ha=0,Ia=0,Ja=0,Ka=0,La=0,Ma=0,Na=0,Oa=0,Pa=0,Qa=0,Ra=0,Sa=0,Ta=0,Ua=0,Va=0,Wa=0,Xa=0,Ya=0,Za=0,_a=0,$a=0,ab=0,bb=0,cb=0,db=0,eb=0,fb=0,gb=0,hb=0,ib=0,jb=0,kb=0,lb=0,mb=0,nb=0,ob=0,pb=0,qb=0,rb=0,sb=0,tb=0,ub=0,vb=0,wb=0,xb=0,yb=0,zb=0,Ab=0,Bb=0,Cb=0,Db=0,Eb=0,Fb=0,Gb=0,Hb=0,Ib=0,Jb=0,Kb=0,Lb=0,Mb=0,Nb=0,Ob=0,Pb=0,Qb=0,Rb=0,Sb=0,Tb=0,Ub=0,Vb=0,Wb=0,Xb=0,Yb=0,Zb=0,_b=0,$b=0,ac=0,bc=0,cc=0,dc=0,ec=0,fc=0,gc=0,hc=0,ic=0,jc=0,kc=0,lc=0,mc=0,nc=0,oc=0,pc=0,qc=0,rc=0,sc=0,tc=0,uc=0,vc=0,wc=0,xc=0,yc=0,zc=0,Ac=0,Bc=0,Cc=0,Dc=0,Ec=0,Fc=0,Gc=0,Hc=0,Ic=0,Jc=0,Kc=0,Lc=0,Mc=0,Nc=0,Oc=0,Pc=0,Qc=0,Rc=0,Wc=0,Yc=0,Zc=0,_c=0,$c=0,bd=0,cd=0,dd=0,ed=0,fd=0,gd=0,hd=0,id=0,jd=0,kd=0,ld=0;ld=r;r=r+34960|0;id=ld+34696|0;gd=ld+34176|0;hd=ld+33656|0;cd=ld+33136|0;jd=ld+32096|0;kd=ld+31056|0;Oc=ld+30792|0;Ca=ld+30532|0;Da=ld+30272|0;Ha=ld+30012|0;Ea=ld+29752|0;Fa=ld+29492|0;wb=ld+29232|0;xb=ld+28972|0;yb=ld+28712|0;dd=ld+28452|0;zb=ld+28192|0;Ab=ld+27932|0;fd=ld+27672|0;Bb=ld+27412|0;Cb=ld+27152|0;$b=ld+26892|0;Db=ld+26632|0;Eb=ld+26372|0;Fb=ld+26112|0;Gb=ld+25852|0;ac=ld+25592|0;bc=ld+25332|0;cc=ld+25072|0;dc=ld+96|0;Pc=ld+24812|0;Cc=ld+24552|0;Dc=ld+24292|0;Ec=ld+24032|0;Fc=ld+23772|0;Qc=ld+23512|0;Rc=ld+23252|0;Wc=ld+22992|0;Yc=ld+80|0;Zc=ld+22732|0;_c=ld+22472|0;$c=ld+22212|0;bd=ld+64|0;Ia=ld+21952|0;Ja=ld+21692|0;Ka=ld+21432|0;Na=ld+21172|0;Oa=ld+20912|0;Pa=ld+20652|0;Qa=ld+20392|0;Ra=ld+20132|0;Sa=ld+19872|0;Ta=ld+19612|0;Lc=ld+19352|0;Ua=ld+19092|0;Mc=ld+18832|0;Va=ld+18572|0;xc=ld+18312|0;Wa=ld+18052|0;Xa=ld+17792|0;Ya=ld+17532|0;Za=ld+17272|0;_a=ld+17012|0;$a=ld+16752|0;ab=ld+16492|0;bb=ld+16232|0;cb=ld+15972|0;db=ld+15712|0;eb=ld+15452|0;fb=ld+15192|0;gb=ld+14932|0;hb=ld+14672|0;ib=ld+14412|0;jb=ld+14152|0;kb=ld+13892|0;lb=ld+13632|0;mb=ld+13372|0;nb=ld+13112|0;ob=ld+12852|0;pb=ld+12592|0;qb=ld+12332|0;rb=ld+12072|0;sb=ld+11812|0;tb=ld+11552|0;ub=ld+11292|0;vb=ld+48|0;Hb=ld+11032|0;Ib=ld+10772|0;Jb=ld+10512|0;Kb=ld+10252|0;Lb=ld+9992|0;Mb=ld+9732|0;Nb=ld+9472|0;Ob=ld+9212|0;Pb=ld+8952|0;Qb=ld+8692|0;Rb=ld+8432|0;Sb=ld+8172|0;Tb=ld+7912|0;Ub=ld+7652|0;Vb=ld+7392|0;Wb=ld+7132|0;Xb=ld+6872|0;Yb=ld+6612|0;Zb=ld+6352|0;_b=ld+32|0;rc=ld+6092|0;sc=ld+5832|0;tc=ld+5572|0;uc=ld+5312|0;vc=ld+5052|0;wc=ld+4792|0;ec=ld+4532|0;fc=ld+4272|0;gc=ld+4012|0;hc=ld+3752|0;ic=ld+3492|0;jc=ld+3232|0;kc=ld+2972|0;lc=ld+2712|0;mc=ld+2452|0;nc=ld+2192|0;oc=ld+1932|0;pc=ld+1672|0;qc=ld+1412|0;yc=ld+16|0;Gc=ld+1152|0;Hc=ld+892|0;Ic=ld+632|0;Jc=ld+372|0;Kc=ld+112|0;Nc=ld;C=k[c>>2]|0;zc=c+8|0;s=k[zc>>2]|0;o=+(s|0);aa=+(C|0)-o;Ga=c+4|0;W=k[Ga>>2]|0;Ac=c+12|0;M=k[Ac>>2]|0;x=+(M|0);ca=+(W|0)-x;Ma=d+8|0;$=k[Ma>>2]|0;P=k[d>>2]|0;u=+(P|0);B=+($|0)-u;La=d+12|0;Y=k[La>>2]|0;Bc=d+4|0;R=k[Bc>>2]|0;y=+(R|0);I=+(Y|0)-y;F=((W|0)<0)<<31>>31;N=((M|0)<0)<<31>>31;ua=be(W|0,F|0,M|0,N|0)|0;va=L;V=((C|0)<0)<<31>>31;H=((s|0)<0)<<31>>31;wa=be(C|0,V|0,s|0,H|0)|0;xa=L;Z=((Y|0)<0)<<31>>31;S=((R|0)<0)<<31>>31;na=be(Y|0,Z|0,R|0,S|0)|0;oa=L;_=(($|0)<0)<<31>>31;Q=((P|0)<0)<<31>>31;ka=be($|0,_|0,P|0,Q|0)|0;la=L;ya=(va|0)<0;za=be(0,0,ua|0,va|0)|0;ua=ya?za:ua;va=ya?L:va;za=(xa|0)<0;pa=be(0,0,wa|0,xa|0)|0;wa=za?pa:wa;xa=za?L:xa;pa=(oa|0)<0;ra=be(0,0,na|0,oa|0)|0;na=pa?ra:na;oa=pa?L:oa;ra=(la|0)<0;h=be(0,0,ka|0,la|0)|0;ka=ra?h:ka;la=ra?L:la;h=ne(ka|0,la|0,ua|0,va|0)|0;j=L;l=ne(na|0,oa|0,wa|0,xa|0)|0;n=L;q=za^pa;do if(ya^ra){if(!q){Aa=ge(l|0,n|0,h|0,j|0)|0;Ba=-(+(Aa>>>0)+4294967296.0*+(L>>>0));break}if(j>>>0>n>>>0|(j|0)==(n|0)&h>>>0>l>>>0){Aa=be(h|0,j|0,l|0,n|0)|0;Ba=-(+(Aa>>>0)+4294967296.0*+(L>>>0));break}else{Aa=be(l|0,n|0,h|0,j|0)|0;Ba=+(Aa>>>0)+4294967296.0*+(L>>>0);break}}else{if(q){Aa=ge(l|0,n|0,h|0,j|0)|0;Ba=+(Aa>>>0)+4294967296.0*+(L>>>0);break}if(j>>>0<n>>>0|(j|0)==(n|0)&h>>>0<l>>>0){Aa=be(l|0,n|0,h|0,j|0)|0;Ba=-(+(Aa>>>0)+4294967296.0*+(L>>>0));break}else{Aa=be(h|0,j|0,l|0,n|0)|0;Ba=+(Aa>>>0)+4294967296.0*+(L>>>0);break}}while(0);Aa=Ba<0.0;U=aa*aa+ca*ca;if(Ba==0.0){n=be(R|0,S|0,M|0,N|0)|0;l=L;j=be(P|0,Q|0,s|0,H|0)|0;h=L;q=(l|0)<0;ra=be(0,0,n|0,l|0)|0;l=q?L:l;Aa=(h|0)<0;pa=be(0,0,j|0,h|0)|0;h=ne((Aa?pa:j)|0,(Aa?L:h)|0,ua|0,va|0)|0;j=L;l=ne((q?ra:n)|0,l|0,wa|0,xa|0)|0;n=L;q=za^q;do if(ya^Aa){if(!q){Aa=ge(h|0,j|0,l|0,n|0)|0;T=-(+(Aa>>>0)+4294967296.0*+(L>>>0));break}if(j>>>0>n>>>0|(j|0)==(n|0)&h>>>0>l>>>0){Aa=be(h|0,j|0,l|0,n|0)|0;T=-(+(Aa>>>0)+4294967296.0*+(L>>>0));break}else{Aa=be(l|0,n|0,h|0,j|0)|0;T=+(Aa>>>0)+4294967296.0*+(L>>>0);break}}else{if(q){Aa=ge(h|0,j|0,l|0,n|0)|0;T=+(Aa>>>0)+4294967296.0*+(L>>>0);break}if(j>>>0<n>>>0|(j|0)==(n|0)&h>>>0<l>>>0){Aa=be(l|0,n|0,h|0,j|0)|0;T=-(+(Aa>>>0)+4294967296.0*+(L>>>0));break}else{Aa=be(h|0,j|0,l|0,n|0)|0;T=+(Aa>>>0)+4294967296.0*+(L>>>0);break}}while(0);F=k[b>>2]|0;C=((F|0)<0)<<31>>31;n=be(F|0,C|0,s|0,H|0)|0;l=L;H=k[b+4>>2]|0;s=((H|0)<0)<<31>>31;j=be(H|0,s|0,M|0,N|0)|0;h=L;q=(l|0)<0;ra=be(0,0,n|0,l|0)|0;l=q?L:l;Aa=(h|0)<0;pa=be(0,0,j|0,h|0)|0;h=ne((Aa?pa:j)|0,(Aa?L:h)|0,wa|0,xa|0)|0;j=L;l=ne((q?ra:n)|0,l|0,ua|0,va|0)|0;n=L;q=ya^q;do if(za^Aa){if(!q){Aa=ge(h|0,j|0,l|0,n|0)|0;m=-(+(Aa>>>0)+4294967296.0*+(L>>>0));break}if(j>>>0>n>>>0|(j|0)==(n|0)&h>>>0>l>>>0){Aa=be(h|0,j|0,l|0,n|0)|0;m=-(+(Aa>>>0)+4294967296.0*+(L>>>0));break}else{Aa=be(l|0,n|0,h|0,j|0)|0;m=+(Aa>>>0)+4294967296.0*+(L>>>0);break}}else{if(q){Aa=ge(h|0,j|0,l|0,n|0)|0;m=+(Aa>>>0)+4294967296.0*+(L>>>0);break}if(j>>>0<n>>>0|(j|0)==(n|0)&h>>>0<l>>>0){Aa=be(l|0,n|0,h|0,j|0)|0;m=-(+(Aa>>>0)+4294967296.0*+(L>>>0));break}else{Aa=be(h|0,j|0,l|0,n|0)|0;m=+(Aa>>>0)+4294967296.0*+(L>>>0);break}}while(0);l=be(H|0,s|0,R|0,S|0)|0;j=L;q=be(F|0,C|0,P|0,Q|0)|0;n=L;h=(j|0)<0;ra=be(0,0,l|0,j|0)|0;j=h?L:j;Aa=(n|0)<0;pa=be(0,0,q|0,n|0)|0;n=ne((Aa?pa:q)|0,(Aa?L:n)|0,ua|0,va|0)|0;q=L;j=ne((h?ra:l)|0,j|0,wa|0,xa|0)|0;l=L;h=za^h;do if(ya^Aa){if(!h){Aa=ge(n|0,q|0,j|0,l|0)|0;g=-(+(Aa>>>0)+4294967296.0*+(L>>>0));break}if(q>>>0>l>>>0|(q|0)==(l|0)&n>>>0>j>>>0){Aa=be(n|0,q|0,j|0,l|0)|0;g=-(+(Aa>>>0)+4294967296.0*+(L>>>0));break}else{Aa=be(j|0,l|0,n|0,q|0)|0;g=+(Aa>>>0)+4294967296.0*+(L>>>0);break}}else{if(h){Aa=ge(n|0,q|0,j|0,l|0)|0;g=+(Aa>>>0)+4294967296.0*+(L>>>0);break}if(q>>>0<l>>>0|(q|0)==(l|0)&n>>>0<j>>>0){Aa=be(j|0,l|0,n|0,q|0)|0;g=-(+(Aa>>>0)+4294967296.0*+(L>>>0));break}else{Aa=be(n|0,q|0,j|0,l|0)|0;g=+(Aa>>>0)+4294967296.0*+(L>>>0);break}}while(0);z=m*g;G=(o+u)*.5;g=aa*(G-+(F|0));if(g<0.0){m=0.0-g;if(g>0.0){g=(g+0.0)/m;g=g<0.0?-g:g}else g=1.0;v=0.0;w=0.0;u=g+1.0}else{v=g+0.0;w=2.0;m=0.0;u=0.0}O=(x+y)*.5;g=ca*(O-+(H|0));do if(g<0.0){o=m-g;if(m<0.0|g>0.0){g=(m*u+g)/o;g=g<0.0?-g:g}else g=u<1.0?1.0:u;m=o;x=g+1.0;y=v}else{o=v+g;if(v<0.0?v>0.0|g>0.0:0){w=(v*w-g)/o;x=u;y=o;w=(w<0.0?-w:w)+1.0;break}x=u;y=o;w=w<1.0?2.0:w+1.0}while(0);u=+X(+z);h=u<0.0;do if((e|0)==2)if(h){v=y-u;if(y<0.0|u>0.0){g=(y*w+u*2.5)/v;g=g<0.0?-g:g}else g=w<2.5?2.5:w;u=x;o=g+1.0;g=v;break}else{g=m+u;if(m<0.0?m>0.0|u>0.0:0){u=(m*x-u*2.5)/g;u=(u<0.0?-u:u)+1.0;m=g;o=w;g=y;break}u=x<2.5?3.5:x+1.0;m=g;o=w;g=y;break}else if(h){o=m-u;if(m<0.0|u>0.0){g=(m*x+u*2.5)/o;g=g<0.0?-g:g}else g=x<2.5?2.5:x;u=g+1.0;m=o;o=w;g=y;break}else{g=y+u;if(y<0.0?y>0.0|u>0.0:0){o=(y*w-u*2.5)/g;u=x;o=(o<0.0?-o:o)+1.0;break}u=x;o=w<2.5?3.5:w+1.0;break}while(0);D=u+3.0;E=m/U;A=o+3.0;B=g/U;if(G<0.0){g=0.0-G;if(G>0.0){m=(G*0.0+0.0)/g;m=m<0.0?-m:m}else m=0.0;v=0.0;w=0.0;z=g;y=m+1.0}else{v=G+0.0;w=1.0;z=0.0;y=0.0}if(aa<0.0){o=-aa;g=D;x=E*o;m=A;o=B*o}else{g=A;x=aa*B;m=D;o=aa*E}u=g+0.0+1.0;g=m+0.0+1.0;K=v+o;if(v<0.0|o<0.0?v>0.0|o>0.0:0){g=(v*w-o*g)/K;g=g<0.0?-g:g}else g=w<g?g:w;I=g+1.0;J=z+x;if(z<0.0|x<0.0?z>0.0|x>0.0:0){g=(z*y-x*u)/J;g=g<0.0?-g:g}else g=y<u?u:y;G=g+1.0;if(O<0.0){g=0.0-O;if(O>0.0){m=(O*0.0+0.0)/g;m=m<0.0?-m:m}else m=0.0;u=0.0;v=0.0;y=g;x=m+1.0}else{u=O+0.0;v=1.0;y=0.0;x=0.0}if(ca<0.0){m=-ca;o=D;w=E*m;g=A;m=B*m}else{o=A;w=ca*B;g=D;m=ca*E}o=o+0.0+1.0;g=g+0.0+1.0;D=u+m;if(u<0.0|m<0.0?u>0.0|m>0.0:0){g=(u*v-m*g)/D;g=g<0.0?-g:g}else g=v<g?g:v;A=g+1.0;B=y+w;if(y<0.0|w<0.0?y>0.0|w>0.0:0){g=(y*x-w*o)/B;g=g<0.0?-g:g}else g=x<o?o:x;u=g+1.0;o=T*.5/+X(+U);h=o<0.0;a:do if(T<0.0)if(h){m=K-o;if(K<0.0|o>0.0){o=(K*I+o*5.0)/m;o=o<0.0?-o:o}else o=I<5.0?5.0:I;g=J;z=m;x=G;w=o+1.0;break}else{g=J+o;do if(J<0.0){if(!(J>0.0|o>0.0))break;x=(J*G-o*5.0)/g;z=K;x=(x<0.0?-x:x)+1.0;w=I;break a}while(0);z=K;x=G<5.0?6.0:G+1.0;w=I;break}else if(h){g=J-o;if(J<0.0|o>0.0){m=(J*G+o*5.0)/g;m=m<0.0?-m:m}else m=G<5.0?5.0:G;z=K;x=m+1.0;w=I;break}else{m=K+o;do if(K<0.0){if(!(K>0.0|o>0.0))break;w=(K*I-o*5.0)/m;g=J;z=m;x=G;w=(w<0.0?-w:w)+1.0;break a}while(0);g=J;z=m;x=G;w=I<5.0?6.0:I+1.0;break}while(0);y=K-J;do if(K<0.0|J>0.0){if(!(K>0.0|J<0.0)){ed=132;break}o=(K*I+J*G)/y;if(!(o<0.0))break;o=-o}else ed=132;while(0);if((ed|0)==132)o=I<G?G:I;v=D-B;do if(D<0.0|B>0.0){if(!(D>0.0|B<0.0)){ed=137;break}m=(D*A+B*u)/v;if(!(m<0.0))break;m=-m}else ed=137;while(0);if((ed|0)==137)m=A<u?u:A;u=z-g;do if(g>0.0|z<0.0){if(!(g<0.0|z>0.0)){ed=142;break}g=(x*g+w*z)/u;if(!(g<0.0))break;g=-g}else ed=142;while(0);if((ed|0)==142)g=w<x?x:w;p[f>>3]=y;p[f+8>>3]=v;p[f+16>>3]=u;i[f+24>>0]=1}else{J=+X(+U);qa=+X(+(B*B+I*I));n=be(R|0,S|0,Y|0,Z|0)|0;l=L;q=(l|0)<0;da=be(0,0,n|0,l|0)|0;l=q?L:l;h=ne(ka|0,la|0,wa|0,xa|0)|0;j=L;l=ne((q?da:n)|0,l|0,ua|0,va|0)|0;n=L;q=ya^q;do if(za^ra){if(!q){da=ge(h|0,j|0,l|0,n|0)|0;o=-(+(da>>>0)+4294967296.0*+(L>>>0));break}if(j>>>0>n>>>0|(j|0)==(n|0)&h>>>0>l>>>0){da=be(h|0,j|0,l|0,n|0)|0;o=-(+(da>>>0)+4294967296.0*+(L>>>0));break}else{da=be(l|0,n|0,h|0,j|0)|0;o=+(da>>>0)+4294967296.0*+(L>>>0);break}}else{if(q){da=ge(h|0,j|0,l|0,n|0)|0;o=+(da>>>0)+4294967296.0*+(L>>>0);break}if(j>>>0<n>>>0|(j|0)==(n|0)&h>>>0<l>>>0){da=be(l|0,n|0,h|0,j|0)|0;o=-(+(da>>>0)+4294967296.0*+(L>>>0));break}else{da=be(h|0,j|0,l|0,n|0)|0;o=+(da>>>0)+4294967296.0*+(L>>>0);break}}while(0);if(!(o<0.0)){g=J*qa;m=g+o;if(g<0.0?g>0.0|o>0.0:0){sa=(o-g*5.0)/m;ta=m;sa=(sa<0.0?-sa:sa)+1.0}else{ta=m;sa=6.0}}else{m=Ba*Ba;g=J*qa;u=g-o;if(g<0.0|o>0.0){g=(g*5.0+o)/u;if(g<0.0)g=-g}else g=5.0;ta=m/u;sa=g+1.0+3.0+1.0}H=k[b+4>>2]|0;s=((H|0)<0)<<31>>31;n=be(W|0,F|0,H|0,s|0)|0;l=L;ba=k[b>>2]|0;da=((ba|0)<0)<<31>>31;j=be(C|0,V|0,ba|0,da|0)|0;h=L;q=(l|0)<0;R=be(0,0,n|0,l|0)|0;l=q?L:l;S=(h|0)<0;Q=be(0,0,j|0,h|0)|0;h=ne((S?Q:j)|0,(S?L:h)|0,ua|0,va|0)|0;j=L;l=ne((q?R:n)|0,l|0,wa|0,xa|0)|0;n=L;q=za^q;do if(ya^S){if(!q){S=ge(h|0,j|0,l|0,n|0)|0;m=-(+(S>>>0)+4294967296.0*+(L>>>0));break}if(j>>>0>n>>>0|(j|0)==(n|0)&h>>>0>l>>>0){S=be(h|0,j|0,l|0,n|0)|0;m=-(+(S>>>0)+4294967296.0*+(L>>>0));break}else{S=be(l|0,n|0,h|0,j|0)|0;m=+(S>>>0)+4294967296.0*+(L>>>0);break}}else{if(q){S=ge(h|0,j|0,l|0,n|0)|0;m=+(S>>>0)+4294967296.0*+(L>>>0);break}if(j>>>0<n>>>0|(j|0)==(n|0)&h>>>0<l>>>0){S=be(l|0,n|0,h|0,j|0)|0;m=-(+(S>>>0)+4294967296.0*+(L>>>0));break}else{S=be(h|0,j|0,l|0,n|0)|0;m=+(S>>>0)+4294967296.0*+(L>>>0);break}}while(0);n=be($|0,_|0,ba|0,da|0)|0;l=L;j=be(Y|0,Z|0,H|0,s|0)|0;h=L;q=(l|0)<0;R=be(0,0,n|0,l|0)|0;l=q?L:l;S=(h|0)<0;Q=be(0,0,j|0,h|0)|0;h=ne((S?Q:j)|0,(S?L:h)|0,ka|0,la|0)|0;j=L;l=ne((q?R:n)|0,l|0,na|0,oa|0)|0;n=L;q=pa^q;do if(ra^S){if(!q){S=ge(h|0,j|0,l|0,n|0)|0;g=-(+(S>>>0)+4294967296.0*+(L>>>0));break}if(j>>>0>n>>>0|(j|0)==(n|0)&h>>>0>l>>>0){S=be(h|0,j|0,l|0,n|0)|0;g=-(+(S>>>0)+4294967296.0*+(L>>>0));break}else{S=be(l|0,n|0,h|0,j|0)|0;g=+(S>>>0)+4294967296.0*+(L>>>0);break}}else{if(q){S=ge(h|0,j|0,l|0,n|0)|0;g=+(S>>>0)+4294967296.0*+(L>>>0);break}if(j>>>0<n>>>0|(j|0)==(n|0)&h>>>0<l>>>0){S=be(l|0,n|0,h|0,j|0)|0;g=-(+(S>>>0)+4294967296.0*+(L>>>0));break}else{S=be(h|0,j|0,l|0,n|0)|0;g=+(S>>>0)+4294967296.0*+(L>>>0);break}}while(0);T=ta*2.0*m*g;fa=sa+0.0+1.0+1.0+1.0+1.0+1.0;l=(W|0)<0;j=be(0,0,W|0,F|0)|0;h=l?L:F;S=(C|0)<0;n=be(0,0,C|0,V|0)|0;n=ne(ua|0,va|0,(S?n:C)|0,(S?L:V)|0)|0;q=L;h=ne(wa|0,xa|0,(l?j:W)|0,h|0)|0;j=L;l=l^za;do if(S^ya){if(!l){W=ge(h|0,j|0,n|0,q|0)|0;A=-(+(W>>>0)+4294967296.0*+(L>>>0));break}if(q>>>0>j>>>0|(q|0)==(j|0)&n>>>0>h>>>0){W=be(n|0,q|0,h|0,j|0)|0;A=-(+(W>>>0)+4294967296.0*+(L>>>0));break}else{W=be(h|0,j|0,n|0,q|0)|0;A=+(W>>>0)+4294967296.0*+(L>>>0);break}}else{if(l){W=ge(h|0,j|0,n|0,q|0)|0;A=+(W>>>0)+4294967296.0*+(L>>>0);break}if(q>>>0<j>>>0|(q|0)==(j|0)&n>>>0<h>>>0){W=be(h|0,j|0,n|0,q|0)|0;A=-(+(W>>>0)+4294967296.0*+(L>>>0));break}else{W=be(n|0,q|0,h|0,j|0)|0;A=+(W>>>0)+4294967296.0*+(L>>>0);break}}while(0);l=($|0)<0;j=be(0,0,$|0,_|0)|0;h=l?L:_;_=(Y|0)<0;n=be(0,0,Y|0,Z|0)|0;n=ne(ka|0,la|0,(_?n:Y)|0,(_?L:Z)|0)|0;q=L;h=ne(na|0,oa|0,(l?j:$)|0,h|0)|0;j=L;l=l^pa;do if(_^ra){if(!l){$=ge(h|0,j|0,n|0,q|0)|0;y=-(+($>>>0)+4294967296.0*+(L>>>0));break}if(q>>>0>j>>>0|(q|0)==(j|0)&n>>>0>h>>>0){$=be(n|0,q|0,h|0,j|0)|0;y=-(+($>>>0)+4294967296.0*+(L>>>0));break}else{$=be(h|0,j|0,n|0,q|0)|0;y=+($>>>0)+4294967296.0*+(L>>>0);break}}else{if(l){$=ge(h|0,j|0,n|0,q|0)|0;y=+($>>>0)+4294967296.0*+(L>>>0);break}if(q>>>0<j>>>0|(q|0)==(j|0)&n>>>0<h>>>0){$=be(h|0,j|0,n|0,q|0)|0;y=-(+($>>>0)+4294967296.0*+(L>>>0));break}else{$=be(n|0,q|0,h|0,j|0)|0;y=+($>>>0)+4294967296.0*+(L>>>0);break}}while(0);z=1.0/Ba;g=B*A*z;if(g<0.0){m=0.0-g;if(g>0.0){g=(g*5.0+0.0)/m;g=g<0.0?-g:g}else g=5.0;v=0.0;x=0.0;w=g+1.0}else{v=g+0.0;x=6.0;m=0.0;w=0.0}o=aa*y*z;do if(o<0.0){u=m-o;if(o>0.0|m<0.0){g=(o*5.0+m*w)/u;g=g<0.0?-g:g}else g=w<5.0?5.0:w;U=v;ea=u;K=x;O=g+1.0}else{g=o+v;if(v<0.0?o>0.0|v>0.0:0){K=(v*x-o*5.0)/g;U=g;ea=m;K=(K<0.0?-K:K)+1.0;O=w;break}U=g;ea=m;K=x<5.0?6.0:x+1.0;O=w}while(0);g=ca*y*z;if(g<0.0){m=0.0-g;if(g>0.0){g=(g*5.0+0.0)/m;g=g<0.0?-g:g}else g=5.0;v=0.0;x=0.0;w=g+1.0}else{v=g+0.0;x=6.0;m=0.0;w=0.0}o=I*A*z;do if(o<0.0){u=m-o;if(o>0.0|m<0.0){g=(o*5.0+m*w)/u;g=g<0.0?-g:g}else g=w<5.0?5.0:w;ja=v;ma=u;ga=x;ia=g+1.0}else{g=o+v;if(v<0.0?o>0.0|v>0.0:0){ga=(v*x-o*5.0)/g;ja=g;ma=m;ga=(ga<0.0?-ga:ga)+1.0;ia=w;break}ja=g;ma=m;ga=x<5.0?6.0:x+1.0;ia=w}while(0);E=aa*qa;P=E<0.0;if(P){m=O;g=K;v=-(E*U);o=-(E*ea)}else{m=K;g=O;v=E*ea;o=E*U}u=g+3.0+1.0;g=m+3.0+1.0;y=o+0.0;if(o<0.0&o>0.0){g=(0.0-o*g)/y;g=g<0.0?-g:g}else g=g>0.0?g:0.0;w=g+1.0;z=v+0.0;if(v<0.0&v>0.0){g=(0.0-v*u)/z;g=g<0.0?-g:g}else g=u>0.0?u:0.0;x=g+1.0;G=B*J;S=G<0.0;if(S){m=O;g=K;v=-(G*U);o=-(G*ea)}else{m=K;g=O;v=G*ea;o=G*U}u=g+3.0+1.0;g=m+3.0+1.0;B=y+o;if(y<0.0|o<0.0?y>0.0|o>0.0:0){g=(y*w-o*g)/B;g=g<0.0?-g:g}else g=w<g?g:w;y=g+1.0;A=z+v;do if(z<0.0|v<0.0){if(!(z>0.0|v>0.0)){ed=255;break}g=(z*x-v*u)/A;g=g<0.0?-g:g}else ed=255;while(0);if((ed|0)==255)g=x<u?u:x;w=g+1.0;ca=ca*qa;R=ca<0.0;if(R){m=ia;g=ga;v=-(ca*ja);o=-(ca*ma)}else{m=ga;g=ia;v=ca*ma;o=ca*ja}u=g+3.0+1.0;g=m+3.0+1.0;D=B+o;do if(B<0.0|o<0.0){if(!(B>0.0|o>0.0)){ed=262;break}g=(B*y-o*g)/D;g=g<0.0?-g:g}else ed=262;while(0);if((ed|0)==262)g=y<g?g:y;z=g+1.0;B=A+v;do if(A<0.0|v<0.0){if(!(A>0.0|v>0.0)){ed=266;break}g=(A*w-v*u)/B;g=g<0.0?-g:g}else ed=266;while(0);if((ed|0)==266)g=w<u?u:w;y=g+1.0;aa=I*J;Q=aa<0.0;if(Q){m=ia;g=ga;x=-(aa*ja);o=-(aa*ma)}else{m=ga;g=ia;x=aa*ma;o=aa*ja}u=g+3.0+1.0;g=m+3.0+1.0;w=D+o;do if(D<0.0|o<0.0){if(!(D>0.0|o>0.0)){ed=273;break}g=(D*z-o*g)/w;g=g<0.0?-g:g}else ed=273;while(0);if((ed|0)==273)g=z<g?g:z;v=g+1.0;z=B+x;do if(B<0.0|x<0.0){if(!(B>0.0|x>0.0)){ed=277;break}g=(B*y-x*u)/z;g=g<0.0?-g:g}else ed=277;while(0);if((ed|0)==277)g=y<u?u:y;u=g+1.0;F=0-H|0;N=((F|0)<0)<<31>>31;M=(H|0)>0;H=be(0,0,F|0,N|0)|0;F=M?H:F;H=M?L:N;N=(ba|0)<0;C=be(0,0,ba|0,da|0)|0;C=N?C:ba;s=N?L:da;n=ne(C|0,s|0,ka|0,la|0)|0;q=L;j=ne(na|0,oa|0,F|0,H|0)|0;l=L;h=M^pa;do if(ra^N){if(!h){ra=ge(n|0,q|0,j|0,l|0)|0;g=-(+(ra>>>0)+4294967296.0*+(L>>>0));break}if(q>>>0>l>>>0|(q|0)==(l|0)&n>>>0>j>>>0){ra=be(n|0,q|0,j|0,l|0)|0;g=-(+(ra>>>0)+4294967296.0*+(L>>>0));break}else{ra=be(j|0,l|0,n|0,q|0)|0;g=+(ra>>>0)+4294967296.0*+(L>>>0);break}}else{if(h){ra=ge(n|0,q|0,j|0,l|0)|0;g=+(ra>>>0)+4294967296.0*+(L>>>0);break}if(q>>>0<l>>>0|(q|0)==(l|0)&n>>>0<j>>>0){ra=be(j|0,l|0,n|0,q|0)|0;g=-(+(ra>>>0)+4294967296.0*+(L>>>0));break}else{ra=be(n|0,q|0,j|0,l|0)|0;g=+(ra>>>0)+4294967296.0*+(L>>>0);break}}while(0);m=J*g;b:do if(m<0.0){o=w-m;if(w<0.0|m>0.0){g=(w*v+m*4.0)/o;g=g<0.0?-g:g}else g=v<4.0?4.0:v;x=z;w=o;v=g+1.0}else{g=z+m;do if(z<0.0){if(!(z>0.0|m>0.0))break;u=(z*u-m*4.0)/g;x=g;u=(u<0.0?-u:u)+1.0;break b}while(0);x=g;u=u<4.0?5.0:u+1.0}while(0);n=ne(C|0,s|0,wa|0,xa|0)|0;q=L;j=ne(ua|0,va|0,F|0,H|0)|0;l=L;h=M^ya;do if(za^N){if(!h){za=ge(n|0,q|0,j|0,l|0)|0;g=-(+(za>>>0)+4294967296.0*+(L>>>0));break}if(q>>>0>l>>>0|(q|0)==(l|0)&n>>>0>j>>>0){za=be(n|0,q|0,j|0,l|0)|0;g=-(+(za>>>0)+4294967296.0*+(L>>>0));break}else{za=be(j|0,l|0,n|0,q|0)|0;g=+(za>>>0)+4294967296.0*+(L>>>0);break}}else{if(h){za=ge(n|0,q|0,j|0,l|0)|0;g=+(za>>>0)+4294967296.0*+(L>>>0);break}if(q>>>0<l>>>0|(q|0)==(l|0)&n>>>0<j>>>0){za=be(j|0,l|0,n|0,q|0)|0;g=-(+(za>>>0)+4294967296.0*+(L>>>0));break}else{za=be(n|0,q|0,j|0,l|0)|0;g=+(za>>>0)+4294967296.0*+(L>>>0);break}}while(0);m=qa*g;c:do if(m<0.0){o=w-m;if(w<0.0|m>0.0){m=(w*v+m*4.0)/o;m=m<0.0?-m:m}else m=v<4.0?4.0:v;g=x;m=m+1.0}else{g=x+m;do if(x<0.0){if(!(x>0.0|m>0.0))break;u=(x*u-m*4.0)/g;u=(u<0.0?-u:u)+1.0;o=w;m=v;break c}while(0);u=u<4.0?5.0:u+1.0;o=w;m=v}while(0);z=g+0.0;if(g<0.0&g>0.0){g=(0.0-g*u)/z;g=g<0.0?-g:g}else g=u>0.0?u:0.0;x=g+1.0;y=o+0.0;if(o<0.0&o>0.0){g=(0.0-o*m)/y;g=g<0.0?-g:g}else g=m>0.0?m:0.0;o=g+1.0;v=+X(+T);w=fa*.5+1.0;h=v<0.0;d:do if((e|0)==2)if(h){u=y-v;if(y<0.0|v>0.0){g=(y*o+w*v)/u;g=g<0.0?-g:g}else g=o<w?w:o;v=x;m=z;o=g+1.0;g=u;break}else{g=z+v;do if(z<0.0){if(!(z>0.0|v>0.0))break;v=(z*x-w*v)/g;v=(v<0.0?-v:v)+1.0;m=g;g=y;break d}while(0);v=(x<w?w:x)+1.0;m=g;g=y;break}else if(h){m=z-v;if(z<0.0|v>0.0){g=(z*x+w*v)/m;g=g<0.0?-g:g}else g=x<w?w:x;v=g+1.0;g=y;break}else{g=y+v;do if(y<0.0){if(!(y>0.0|v>0.0))break;o=(y*o-w*v)/g;v=x;m=z;o=(o<0.0?-o:o)+1.0;break d}while(0);v=x;m=z;o=(o<w?w:o)+1.0;break}while(0);I=ta*ta;T=sa+sa+1.0+1.0;v=T+v;J=m/I;T=T+o;I=g/I;if(P){m=T;g=v;w=-(E*J);o=-(E*I)}else{m=v;g=T;w=E*I;o=E*J}u=g+3.0+1.0;g=m+3.0+1.0;A=U+o;do if(U<0.0|o<0.0){if(!(U>0.0|o>0.0)){ed=349;break}g=(U*K-o*g)/A;g=g<0.0?-g:g}else ed=349;while(0);if((ed|0)==349)g=K<g?g:K;y=g+1.0;z=ea+w;do if(ea<0.0|w<0.0){if(!(ea>0.0|w>0.0)){ed=353;break}g=(ea*O-w*u)/z;g=g<0.0?-g:g}else ed=353;while(0);if((ed|0)==353)g=O<u?u:O;x=g+1.0;if(S){m=T;g=v;w=-(G*J);o=-(G*I)}else{m=v;g=T;w=G*I;o=G*J}u=g+3.0+1.0;g=m+3.0+1.0;U=A+o;do if(A<0.0|o<0.0){if(!(A>0.0|o>0.0)){ed=360;break}g=(A*y-o*g)/U;g=g<0.0?-g:g}else ed=360;while(0);if((ed|0)==360)g=y<g?g:y;K=g+1.0;O=z+w;do if(z<0.0|w<0.0){if(!(z>0.0|w>0.0)){ed=364;break}g=(z*x-w*u)/O;g=g<0.0?-g:g}else ed=364;while(0);if((ed|0)==364)g=x<u?u:x;G=g+1.0;if(R){m=T;g=v;w=-(ca*J);o=-(ca*I)}else{m=v;g=T;w=ca*I;o=ca*J}u=g+3.0+1.0;g=m+3.0+1.0;A=ja+o;do if(ja<0.0|o<0.0){if(!(ja>0.0|o>0.0)){ed=371;break}g=(ja*ga-o*g)/A;g=g<0.0?-g:g}else ed=371;while(0);if((ed|0)==371)g=ga<g?g:ga;y=g+1.0;z=ma+w;do if(ma<0.0|w<0.0){if(!(ma>0.0|w>0.0)){ed=375;break}g=(ma*ia-w*u)/z;g=g<0.0?-g:g}else ed=375;while(0);if((ed|0)==375)g=ia<u?u:ia;x=g+1.0;if(Q){m=T;g=v;w=-(aa*J);o=-(aa*I)}else{m=v;g=T;w=aa*I;o=aa*J}u=g+3.0+1.0;g=m+3.0+1.0;E=A+o;do if(A<0.0|o<0.0){if(!(A>0.0|o>0.0)){ed=382;break}g=(A*y-o*g)/E;g=g<0.0?-g:g}else ed=382;while(0);if((ed|0)==382)g=y<g?g:y;B=g+1.0;D=z+w;do if(z<0.0|w<0.0){if(!(z>0.0|w>0.0)){ed=386;break}g=(z*x-w*u)/D;g=g<0.0?-g:g}else ed=386;while(0);if((ed|0)==386)g=x<u?u:x;A=g+1.0;if(J<I){o=J;g=I;x=T}else{o=I;g=J;x=v;v=T}e:do if(Aa){w=Ba*o;m=Ba*g;g=x+1.0+1.0;o=v+1.0+1.0;u=U-m;do if(U<0.0|m>-0.0){if(!(U>0.0|m<-0.0)){ed=393;break}g=(U*K+m*g)/u;g=g<0.0?-g:g}else ed=393;while(0);if((ed|0)==393)g=K<g?g:K;m=g+1.0;g=O-w;do if(O<0.0|w>-0.0){if(!(O>0.0|w<-0.0))break;o=(O*G+w*o)/g;o=o<0.0?-o:o;z=u;x=m;break e}while(0);o=G<o?o:G;z=u;x=m}else{m=Ba*g;u=Ba*o;o=v+1.0+1.0;g=x+1.0+1.0;v=U+m;do if(U<0.0|m<0.0){if(!(U>0.0|m>0.0)){ed=401;break}g=(U*K-m*g)/v;g=g<0.0?-g:g}else ed=401;while(0);if((ed|0)==401)g=K<g?g:K;m=g+1.0;g=O+u;do if(O<0.0|u<0.0){if(!(O>0.0|u>0.0))break;o=(O*G-u*o)/g;o=o<0.0?-o:o;z=v;x=m;break e}while(0);o=G<o?o:G;z=v;x=m}while(0);w=o+1.0;y=U-O;do if(U<0.0|O>0.0){if(!(U>0.0|O<0.0)){ed=409;break}o=(U*K+O*G)/y;if(!(o<0.0))break;o=-o}else ed=409;while(0);if((ed|0)==409)o=K<G?G:K;v=E-D;do if(E<0.0|D>0.0){if(!(E>0.0|D<0.0)){ed=414;break}m=(E*B+D*A)/v;if(!(m<0.0))break;m=-m}else ed=414;while(0);if((ed|0)==414)m=B<A?A:B;u=z-g;do if(g>0.0|z<0.0){if(!(g<0.0|z>0.0)){ed=419;break}g=(g*w+x*z)/u;if(!(g<0.0))break;g=-g}else ed=419;while(0);if((ed|0)==419)g=x<w?w:x;p[f>>3]=y;p[f+8>>3]=v;p[f+16>>3]=u;i[f+24>>0]=1}N=g+1.0>64.0;H=m+1.0>64.0;M=o+1.0>64.0;if(!(M|H|N)){r=ld;return}j=k[c>>2]|0;h=k[zc>>2]|0;h=be(j|0,((j|0)<0)<<31>>31|0,h|0,((h|0)<0)<<31>>31|0)|0;j=L;do if(!((j|0)>0|(j|0)==0&h>>>0>0))if((j|0)<0){za=be(0,0,h|0,j|0)|0;Aa=L;k[gd>>2]=za;k[gd+4>>2]=Aa;k[gd+256>>2]=(Aa|0)!=0?-2:-1;break}else{k[gd+256>>2]=0;break}else{k[gd>>2]=h;k[gd+4>>2]=j;k[gd+256>>2]=(j|0)!=0?2:1}while(0);j=k[Ga>>2]|0;h=k[Ac>>2]|0;h=be(j|0,((j|0)<0)<<31>>31|0,h|0,((h|0)<0)<<31>>31|0)|0;j=L;do if(!((j|0)>0|(j|0)==0&h>>>0>0))if((j|0)<0){za=be(0,0,h|0,j|0)|0;Aa=L;k[hd>>2]=za;k[hd+4>>2]=Aa;k[hd+256>>2]=(Aa|0)!=0?-2:-1;break}else{k[hd+256>>2]=0;break}else{k[hd>>2]=h;k[hd+4>>2]=j;k[hd+256>>2]=(j|0)!=0?2:1}while(0);F=gd+260|0;j=k[Ma>>2]|0;h=k[d>>2]|0;h=be(j|0,((j|0)<0)<<31>>31|0,h|0,((h|0)<0)<<31>>31|0)|0;j=L;do if(!((j|0)>0|(j|0)==0&h>>>0>0))if((j|0)<0){za=be(0,0,h|0,j|0)|0;Aa=L;k[F>>2]=za;k[gd+264>>2]=Aa;k[gd+516>>2]=(Aa|0)!=0?-2:-1;break}else{k[gd+516>>2]=0;break}else{k[F>>2]=h;k[gd+264>>2]=j;k[gd+516>>2]=(j|0)!=0?2:1}while(0);C=hd+260|0;j=k[La>>2]|0;h=k[Bc>>2]|0;h=be(j|0,((j|0)<0)<<31>>31|0,h|0,((h|0)<0)<<31>>31|0)|0;j=L;do if(!((j|0)>0|(j|0)==0&h>>>0>0))if((j|0)<0){za=be(0,0,h|0,j|0)|0;Aa=L;k[C>>2]=za;k[hd+264>>2]=Aa;k[hd+516>>2]=(Aa|0)!=0?-2:-1;break}else{k[hd+516>>2]=0;break}else{k[C>>2]=h;k[hd+264>>2]=j;k[hd+516>>2]=(j|0)!=0?2:1}while(0);Sc(Ca,F,hd);Sc(Da,gd,C);Uc(Oc,Ca,Da);l=Oc+256|0;if(k[l>>2]|0){h=k[c>>2]|0;do if((h|0)<=0)if((h|0)<0){k[id>>2]=0-h;k[id+256>>2]=-1;break}else{k[id+256>>2]=0;break}else{k[id>>2]=h;k[id+256>>2]=1}while(0);Sc(Ja,hd,id);h=k[Ga>>2]|0;do if((h|0)<=0)if((h|0)<0){k[id>>2]=0-h;k[id+256>>2]=-1;break}else{k[id+256>>2]=0;break}else{k[id>>2]=h;k[id+256>>2]=1}while(0);Sc(Ka,gd,id);Uc(Ia,Ja,Ka);fe(cd|0,Ia|0,260)|0;j=cd+260|0;h=k[La>>2]|0;do if((h|0)<=0)if((h|0)<0){k[id>>2]=0-h;k[id+256>>2]=-1;break}else{k[id+256>>2]=0;break}else{k[id>>2]=h;k[id+256>>2]=1}while(0);Sc(Oa,F,id);h=k[Ma>>2]|0;do if((h|0)<=0)if((h|0)<0){k[id>>2]=0-h;k[id+256>>2]=-1;break}else{k[id+256>>2]=0;break}else{k[id>>2]=h;k[id+256>>2]=1}while(0);Sc(Pa,C,id);Uc(Na,Oa,Pa);fe(j|0,Na|0,260)|0;Sc(Qa,gd,j);Sc(Ra,F,cd);Tc(dd,Qa,Ra);Sc(Sa,hd,j);Sc(Ta,C,cd);Tc(fd,Sa,Ta);h=k[b>>2]|0;do if((h|0)<=0)if((h|0)<0){k[id>>2]=0-h;k[id+256>>2]=-1;break}else{k[id+256>>2]=0;break}else{k[id>>2]=h;k[id+256>>2]=1}while(0);Sc(Ua,Oc,id);Uc(Lc,dd,Ua);h=k[b+4>>2]|0;do if((h|0)<=0)if((h|0)<0){k[id>>2]=0-h;k[id+256>>2]=-1;break}else{k[id+256>>2]=0;break}else{k[id>>2]=h;k[id+256>>2]=1}while(0);Sc(Va,Oc,id);Uc(Mc,fd,Va);if((k[Lc+256>>2]|0)==0?(k[Mc+256>>2]|0)==0:0){j=k[l>>2]|0;h=(j|0)>-1?j:0-j|0;f:do switch(h|0){case 0:{h=0;g=0.0;break}case 1:{g=+((k[Oc>>2]|0)>>>0);ed=576;break}case 2:{g=+((k[Oc+4>>2]|0)>>>0)*4294967296.0+ +((k[Oc>>2]|0)>>>0);ed=576;break}default:{g=+((k[Oc+(h+-3<<2)>>2]|0)>>>0)+(+((k[Oc+(h+-1<<2)>>2]|0)>>>0)*4294967296.0+ +((k[Oc+(h+-2<<2)>>2]|0)>>>0))*4294967296.0;l=h<<5;h=l+-96|0;g=(j|0)<0?-g:g;if((h|0)>1023){g=g*89884656743115795.0e291;h=l+-1119|0;if((h|0)<=1023)break f;h=l+-2142|0;h=(h|0)>1023?1023:h;g=g*89884656743115795.0e291;break f}if((h|0)>=-1022)break f;g=g*2.2250738585072014e-308;h=l+926|0;if((h|0)>=-1022)break f;h=l+1948|0;h=(h|0)<-1022?-1022:h;g=g*2.2250738585072014e-308}}while(0);if((ed|0)==576){h=0;g=(j|0)<0?-g:g}h=ee(h+1023|0,0,52)|0;j=L;k[t>>2]=h;k[t+4>>2]=j;o=g*+p[t>>3];j=k[dd+256>>2]|0;h=(j|0)>-1?j:0-j|0;g:do switch(h|0){case 0:{h=0;g=0.0;break}case 1:{g=+((k[dd>>2]|0)>>>0);ed=586;break}case 2:{g=+((k[dd+4>>2]|0)>>>0)*4294967296.0+ +((k[dd>>2]|0)>>>0);ed=586;break}default:{g=+((k[dd+(h+-3<<2)>>2]|0)>>>0)+(+((k[dd+(h+-1<<2)>>2]|0)>>>0)*4294967296.0+ +((k[dd+(h+-2<<2)>>2]|0)>>>0))*4294967296.0;l=h<<5;h=l+-96|0;g=(j|0)<0?-g:g;if((h|0)>1023){g=g*89884656743115795.0e291;h=l+-1119|0;if((h|0)<=1023)break g;h=l+-2142|0;h=(h|0)>1023?1023:h;g=g*89884656743115795.0e291;break g}if((h|0)>=-1022)break g;g=g*2.2250738585072014e-308;h=l+926|0;if((h|0)>=-1022)break g;h=l+1948|0;h=(h|0)<-1022?-1022:h;g=g*2.2250738585072014e-308}}while(0);if((ed|0)==586){h=0;g=(j|0)<0?-g:g}h=ee(h+1023|0,0,52)|0;j=L;k[t>>2]=h;k[t+4>>2]=j;m=g*+p[t>>3]/o;j=k[fd+256>>2]|0;h=(j|0)>-1?j:0-j|0;h:do switch(h|0){case 0:{h=0;g=0.0;break}case 1:{g=+((k[fd>>2]|0)>>>0);ed=596;break}case 2:{g=+((k[fd+4>>2]|0)>>>0)*4294967296.0+ +((k[fd>>2]|0)>>>0);ed=596;break}default:{g=+((k[fd+(h+-3<<2)>>2]|0)>>>0)+(+((k[fd+(h+-1<<2)>>2]|0)>>>0)*4294967296.0+ +((k[fd+(h+-2<<2)>>2]|0)>>>0))*4294967296.0;l=h<<5;h=l+-96|0;g=(j|0)<0?-g:g;if((h|0)>1023){g=g*89884656743115795.0e291;h=l+-1119|0;if((h|0)<=1023)break h;h=l+-2142|0;h=(h|0)>1023?1023:h;g=g*89884656743115795.0e291;break h}if((h|0)>=-1022)break h;g=g*2.2250738585072014e-308;h=l+926|0;if((h|0)>=-1022)break h;h=l+1948|0;h=(h|0)<-1022?-1022:h;g=g*2.2250738585072014e-308}}while(0);if((ed|0)==596){h=0;g=(j|0)<0?-g:g}kd=ee(h+1023|0,0,52)|0;a=L;k[t>>2]=kd;k[t+4>>2]=a;Ba=g*+p[t>>3]/o;p[f>>3]=m;p[f+8>>3]=Ba;p[f+16>>3]=m;i[f+24>>0]=1}else{h=ha((k[l>>2]>>31&2)+-1|0,(e|0)==2?1:-1)|0;do if((h|0)<=0)if((h|0)<0){k[xc>>2]=0-h;k[xc+256>>2]=-1;break}else{k[xc+256>>2]=0;break}else{k[xc>>2]=h;k[xc+256>>2]=1}while(0);fe(Xa|0,Lc|0,260)|0;q=Xa+256|0;k[q>>2]=0-(k[q>>2]|0);Sc(Ya,F,Xa);fe(_a|0,Mc|0,260)|0;q=_a+256|0;k[q>>2]=0-(k[q>>2]|0);Sc(Za,C,_a);Tc(Wa,Ya,Za);fe(jd|0,Wa|0,260)|0;q=jd+260|0;fe(ab|0,Lc|0,260)|0;n=ab+256|0;k[n>>2]=0-(k[n>>2]|0);Sc(bb,gd,ab);fe(db|0,Mc|0,260)|0;n=db+256|0;k[n>>2]=0-(k[n>>2]|0);Sc(cb,hd,db);Tc($a,bb,cb);fe(q|0,$a|0,260)|0;n=jd+520|0;fe(n|0,xc|0,260)|0;s=jd+780|0;k[jd+1036>>2]=0;Sc(fb,gd,gd);Sc(gb,hd,hd);Tc(eb,fb,gb);fe(kd|0,eb|0,260)|0;Sc(ib,F,F);Sc(jb,C,C);Tc(hb,ib,jb);fe(kd+260|0,hb|0,260)|0;Sc(lb,gd,F);Sc(mb,hd,C);Tc(kb,lb,mb);fe(kd+520|0,kb|0,260)|0;Sc(ob,gd,Mc);Sc(pb,hd,Lc);Uc(qb,ob,pb);Sc(sb,F,Mc);Sc(tb,C,Lc);Uc(rb,sb,tb);Sc(ub,qb,rb);k[id>>2]=2;k[id+256>>2]=-1;Sc(nb,ub,id);fe(kd+780|0,nb|0,260)|0;ad(vb,a,jd,kd);g=+p[vb>>3];j=k[vb+8>>2]|0;do if((j|0)>1023){g=g*89884656743115795.0e291;h=j+-1023|0;if((h|0)<=1023)break;h=j+-2046|0;h=(h|0)>1023?1023:h;g=g*89884656743115795.0e291}else{if((j|0)>=-1022){h=j;break}g=g*2.2250738585072014e-308;h=j+1022|0;if((h|0)>=-1022)break;h=j+2044|0;h=(h|0)<-1022?-1022:h;g=g*2.2250738585072014e-308}while(0);h=ee(h+1023|0,0,52)|0;j=L;k[t>>2]=h;k[t+4>>2]=j;o=g*+p[t>>3];j=k[l>>2]|0;h=(j|0)>-1?j:0-j|0;i:do switch(h|0){case 0:{h=0;g=0.0;break}case 1:{g=+((k[Oc>>2]|0)>>>0);ed=618;break}case 2:{g=+((k[Oc+4>>2]|0)>>>0)*4294967296.0+ +((k[Oc>>2]|0)>>>0);ed=618;break}default:{g=+((k[Oc+(h+-3<<2)>>2]|0)>>>0)+(+((k[Oc+(h+-1<<2)>>2]|0)>>>0)*4294967296.0+ +((k[Oc+(h+-2<<2)>>2]|0)>>>0))*4294967296.0;l=h<<5;h=l+-96|0;g=(j|0)<0?-g:g;if((h|0)>1023){g=g*89884656743115795.0e291;h=l+-1119|0;if((h|0)<=1023)break i;h=l+-2142|0;h=(h|0)>1023?1023:h;g=g*89884656743115795.0e291;break i}if((h|0)>=-1022)break i;g=g*2.2250738585072014e-308;h=l+926|0;if((h|0)>=-1022)break i;h=l+1948|0;h=(h|0)<-1022?-1022:h;g=g*2.2250738585072014e-308}}while(0);if((ed|0)==618){h=0;g=(j|0)<0?-g:g}cd=ee(h+1023|0,0,52)|0;ed=L;k[t>>2]=cd;k[t+4>>2]=ed;m=o*(g*+p[t>>3]);if(H){Sc(Jb,Lc,Lc);Sc(Kb,Mc,Mc);Tc(Ib,Jb,Kb);Sc(Lb,C,Ib);Sc(Ob,Lc,F);Sc(Pb,Mc,C);Tc(Nb,Ob,Pb);Sc(Mb,fd,Nb);Uc(Hb,Lb,Mb);fe(jd|0,Hb|0,260)|0;Sc(Sb,Lc,Lc);Sc(Tb,Mc,Mc);Tc(Rb,Sb,Tb);Sc(Ub,hd,Rb);Sc(Xb,Lc,gd);Sc(Yb,Mc,hd);Tc(Wb,Xb,Yb);Sc(Vb,fd,Wb);Uc(Qb,Ub,Vb);fe(q|0,Qb|0,260)|0;Sc(Zb,fd,xc);fe(n|0,Zb|0,260)|0;ad(_b,a,jd,kd);g=+p[_b>>3];j=k[_b+8>>2]|0;do if((j|0)>1023){g=g*89884656743115795.0e291;h=j+-1023|0;if((h|0)<=1023)break;h=j+-2046|0;h=(h|0)>1023?1023:h;g=g*89884656743115795.0e291}else{if((j|0)>=-1022){h=j;break}g=g*2.2250738585072014e-308;h=j+1022|0;if((h|0)>=-1022)break;h=j+2044|0;h=(h|0)<-1022?-1022:h;g=g*2.2250738585072014e-308}while(0);ed=ee(h+1023|0,0,52)|0;fd=L;k[t>>2]=ed;k[t+4>>2]=fd;p[f+8>>3]=g*+p[t>>3]/m}do if(M|N){Sc(tc,Lc,Lc);Sc(uc,Mc,Mc);Tc(sc,tc,uc);Sc(vc,F,sc);Sc(fc,Lc,F);Sc(gc,Mc,C);Tc(ec,fc,gc);Sc(wc,dd,ec);Uc(rc,vc,wc);fe(jd|0,rc|0,260)|0;Sc(jc,Lc,Lc);Sc(kc,Mc,Mc);Tc(ic,jc,kc);Sc(lc,gd,ic);Sc(oc,Lc,gd);Sc(pc,Mc,hd);Tc(nc,oc,pc);Sc(mc,dd,nc);Uc(hc,lc,mc);fe(q|0,hc|0,260)|0;Sc(qc,dd,xc);fe(n|0,qc|0,260)|0;if(M){ad(yc,a,jd,kd);g=+p[yc>>3];j=k[yc+8>>2]|0;do if((j|0)>1023){g=g*89884656743115795.0e291;h=j+-1023|0;if((h|0)<=1023)break;h=j+-2046|0;h=(h|0)>1023?1023:h;g=g*89884656743115795.0e291}else{if((j|0)>=-1022){h=j;break}g=g*2.2250738585072014e-308;h=j+1022|0;if((h|0)>=-1022)break;h=j+2044|0;h=(h|0)<-1022?-1022:h;g=g*2.2250738585072014e-308}while(0);gd=ee(h+1023|0,0,52)|0;hd=L;k[t>>2]=gd;k[t+4>>2]=hd;p[f>>3]=g*+p[t>>3]/m}if(!N)break;Sc(Ic,Lc,Lc);Sc(Jc,Mc,Mc);Tc(Hc,Ic,Jc);Sc(Kc,Oc,Hc);k[id>>2]=1;k[id+256>>2]=o<0.0?-1:1;Sc(Gc,Kc,id);fe(s|0,Gc|0,260)|0;ad(Nc,a,jd,kd);g=+p[Nc>>3];j=k[Nc+8>>2]|0;do if((j|0)>1023){g=g*89884656743115795.0e291;h=j+-1023|0;if((h|0)<=1023)break;h=j+-2046|0;h=(h|0)>1023?1023:h;g=g*89884656743115795.0e291}else{if((j|0)>=-1022){h=j;break}g=g*2.2250738585072014e-308;h=j+1022|0;if((h|0)>=-1022)break;h=j+2044|0;h=(h|0)<-1022?-1022:h;g=g*2.2250738585072014e-308}while(0);kd=ee(h+1023|0,0,52)|0;a=L;k[t>>2]=kd;k[t+4>>2]=a;p[f+16>>3]=g*+p[t>>3]/m}while(0)}}else{Sc(Ea,gd,gd);Sc(Fa,hd,hd);Tc(Ha,Ea,Fa);j=k[Ha+256>>2]|0;h=(j|0)>-1?j:0-j|0;j:do switch(h|0){case 0:{h=0;g=0.0;break}case 1:{g=+((k[Ha>>2]|0)>>>0);ed=448;break}case 2:{g=+((k[Ha+4>>2]|0)>>>0)*4294967296.0+ +((k[Ha>>2]|0)>>>0);ed=448;break}default:{g=+((k[Ha+(h+-3<<2)>>2]|0)>>>0)+(+((k[Ha+(h+-1<<2)>>2]|0)>>>0)*4294967296.0+ +((k[Ha+(h+-2<<2)>>2]|0)>>>0))*4294967296.0;l=h<<5;h=l+-96|0;g=(j|0)<0?-g:g;if((h|0)>1023){g=g*89884656743115795.0e291;h=l+-1119|0;if((h|0)<=1023)break j;h=l+-2142|0;h=(h|0)>1023?1023:h;g=g*89884656743115795.0e291;break j}if((h|0)<-1022){g=g*2.2250738585072014e-308;h=l+926|0;if((h|0)<-1022){h=l+1948|0;h=(h|0)<-1022?-1022:h;g=g*2.2250738585072014e-308}}}}while(0);if((ed|0)==448){h=0;g=(j|0)<0?-g:g}h=ee(h+1023|0,0,52)|0;j=L;k[t>>2]=h;k[t+4>>2]=j;m=g*+p[t>>3]*2.0;j=k[d>>2]|0;h=k[zc>>2]|0;h=be(j|0,((j|0)<0)<<31>>31|0,h|0,((h|0)<0)<<31>>31|0)|0;j=L;do if(!((j|0)>0|(j|0)==0&h>>>0>0))if((j|0)<0){Oc=be(0,0,h|0,j|0)|0;ed=L;k[id>>2]=Oc;k[id+4>>2]=ed;k[id+256>>2]=(ed|0)!=0?-2:-1;break}else{k[id+256>>2]=0;break}else{k[id>>2]=h;k[id+4>>2]=j;k[id+256>>2]=(j|0)!=0?2:1}while(0);Sc(xb,hd,id);j=k[Bc>>2]|0;h=k[Ac>>2]|0;h=be(j|0,((j|0)<0)<<31>>31|0,h|0,((h|0)<0)<<31>>31|0)|0;j=L;do if(!((j|0)>0|(j|0)==0&h>>>0>0))if((j|0)<0){Oc=be(0,0,h|0,j|0)|0;ed=L;k[id>>2]=Oc;k[id+4>>2]=ed;k[id+256>>2]=(ed|0)!=0?-2:-1;break}else{k[id+256>>2]=0;break}else{k[id>>2]=h;k[id+4>>2]=j;k[id+256>>2]=(j|0)!=0?2:1}while(0);Sc(yb,gd,id);Uc(wb,xb,yb);fe(cd|0,wb|0,260)|0;s=b+4|0;j=k[s>>2]|0;h=k[Ac>>2]|0;h=be(j|0,((j|0)<0)<<31>>31|0,h|0,((h|0)<0)<<31>>31|0)|0;j=L;do if(!((j|0)>0|(j|0)==0&h>>>0>0))if((j|0)<0){Oc=be(0,0,h|0,j|0)|0;ed=L;k[id>>2]=Oc;k[id+4>>2]=ed;k[id+256>>2]=(ed|0)!=0?-2:-1;break}else{k[id+256>>2]=0;break}else{k[id>>2]=h;k[id+4>>2]=j;k[id+256>>2]=(j|0)!=0?2:1}while(0);Sc(zb,gd,id);j=k[b>>2]|0;h=k[zc>>2]|0;h=be(j|0,((j|0)<0)<<31>>31|0,h|0,((h|0)<0)<<31>>31|0)|0;j=L;do if(!((j|0)>0|(j|0)==0&h>>>0>0))if((j|0)<0){Oc=be(0,0,h|0,j|0)|0;ed=L;k[id>>2]=Oc;k[id+4>>2]=ed;k[id+256>>2]=(ed|0)!=0?-2:-1;break}else{k[id+256>>2]=0;break}else{k[id>>2]=h;k[id+4>>2]=j;k[id+256>>2]=(j|0)!=0?2:1}while(0);Sc(Ab,hd,id);Uc(dd,zb,Ab);j=k[b>>2]|0;h=k[d>>2]|0;h=be(j|0,((j|0)<0)<<31>>31|0,h|0,((h|0)<0)<<31>>31|0)|0;j=L;do if(!((j|0)>0|(j|0)==0&h>>>0>0))if((j|0)<0){Oc=be(0,0,h|0,j|0)|0;ed=L;k[id>>2]=Oc;k[id+4>>2]=ed;k[id+256>>2]=(ed|0)!=0?-2:-1;break}else{k[id+256>>2]=0;break}else{k[id>>2]=h;k[id+4>>2]=j;k[id+256>>2]=(j|0)!=0?2:1}while(0);Sc(Bb,hd,id);j=k[s>>2]|0;h=k[Bc>>2]|0;h=be(j|0,((j|0)<0)<<31>>31|0,h|0,((h|0)<0)<<31>>31|0)|0;j=L;do if(!((j|0)>0|(j|0)==0&h>>>0>0))if((j|0)<0){Oc=be(0,0,h|0,j|0)|0;ed=L;k[id>>2]=Oc;k[id+4>>2]=ed;k[id+256>>2]=(ed|0)!=0?-2:-1;break}else{k[id+256>>2]=0;break}else{k[id>>2]=h;k[id+4>>2]=j;k[id+256>>2]=(j|0)!=0?2:1}while(0);Sc(Cb,gd,id);Uc(fd,Bb,Cb);Sc(kd,dd,fd);k[kd+260>>2]=1;k[kd+516>>2]=1;if(H){k[id>>2]=2;k[id+256>>2]=(e|0)==2?1:-1;Sc(jd,hd,id);q=jd+260|0;Sc(Db,gd,gd);h=k[Ac>>2]|0;j=k[Bc>>2]|0;h=ge(j|0,((j|0)<0)<<31>>31|0,h|0,((h|0)<0)<<31>>31|0)|0;j=L;do if(!((j|0)>0|(j|0)==0&h>>>0>0))if((j|0)<0){ed=be(0,0,h|0,j|0)|0;fd=L;k[id>>2]=ed;k[id+4>>2]=fd;k[id+256>>2]=(fd|0)!=0?-2:-1;break}else{k[id+256>>2]=0;break}else{k[id>>2]=h;k[id+4>>2]=j;k[id+256>>2]=(j|0)!=0?2:1}while(0);Sc(Eb,Db,id);Sc(Gb,gd,hd);fd=k[zc>>2]|0;j=k[d>>2]|0;fd=ge(j|0,((j|0)<0)<<31>>31|0,fd|0,((fd|0)<0)<<31>>31|0)|0;j=L;h=k[b>>2]|0;h=ee(h|0,((h|0)<0)<<31>>31|0,1)|0;h=be(fd|0,j|0,h|0,L|0)|0;j=L;do if(!((j|0)>0|(j|0)==0&h>>>0>0))if((j|0)<0){ed=be(0,0,h|0,j|0)|0;fd=L;k[id>>2]=ed;k[id+4>>2]=fd;k[id+256>>2]=(fd|0)!=0?-2:-1;break}else{k[id+256>>2]=0;break}else{k[id>>2]=h;k[id+4>>2]=j;k[id+256>>2]=(j|0)!=0?2:1}while(0);Sc(Fb,Gb,id);Uc(ac,Eb,Fb);Sc(cc,hd,hd);h=k[s>>2]|0;j=((h|0)<0)<<31>>31;l=ee(h|0,j|0,1)|0;n=L;do if((h|0)<=0)if((h|0)<0){ed=be(0,0,l|0,n|0)|0;fd=L;k[id>>2]=ed;k[id+4>>2]=fd;k[id+256>>2]=(fd|0)!=0?-2:-1;break}else{k[id+256>>2]=0;break}else{k[id>>2]=l;fd=de(h|0,j|0,31)|0;k[id+4>>2]=fd;k[id+256>>2]=(fd|0)!=0?2:1}while(0);Sc(bc,cc,id);Tc($b,ac,bc);fe(q|0,$b|0,260)|0;Xc(dc,jd,kd);g=+p[dc>>3];j=k[dc+8>>2]|0;do if((j|0)>1023){g=g*89884656743115795.0e291;h=j+-1023|0;if((h|0)<=1023)break;h=j+-2046|0;h=(h|0)>1023?1023:h;g=g*89884656743115795.0e291}else{if((j|0)>=-1022){h=j;break}g=g*2.2250738585072014e-308;h=j+1022|0;if((h|0)>=-1022)break;h=j+2044|0;h=(h|0)<-1022?-1022:h;g=g*2.2250738585072014e-308}while(0);ed=ee(h+1023|0,0,52)|0;fd=L;k[t>>2]=ed;k[t+4>>2]=fd;p[f+8>>3]=g*+p[t>>3]/m}do if(M|N){k[id>>2]=2;k[id+256>>2]=(e|0)==2?1:-1;Sc(jd,gd,id);q=jd+260|0;Sc(Cc,hd,hd);h=k[zc>>2]|0;j=k[d>>2]|0;h=ge(j|0,((j|0)<0)<<31>>31|0,h|0,((h|0)<0)<<31>>31|0)|0;j=L;do if(!((j|0)>0|(j|0)==0&h>>>0>0))if((j|0)<0){ed=be(0,0,h|0,j|0)|0;fd=L;k[id>>2]=ed;k[id+4>>2]=fd;k[id+256>>2]=(fd|0)!=0?-2:-1;break}else{k[id+256>>2]=0;break}else{k[id>>2]=h;k[id+4>>2]=j;k[id+256>>2]=(j|0)!=0?2:1}while(0);Sc(Dc,Cc,id);Sc(Fc,gd,hd);fd=k[Ac>>2]|0;j=k[Bc>>2]|0;fd=ge(j|0,((j|0)<0)<<31>>31|0,fd|0,((fd|0)<0)<<31>>31|0)|0;j=L;h=k[s>>2]|0;h=ee(h|0,((h|0)<0)<<31>>31|0,1)|0;h=be(fd|0,j|0,h|0,L|0)|0;j=L;do if(!((j|0)>0|(j|0)==0&h>>>0>0))if((j|0)<0){ed=be(0,0,h|0,j|0)|0;fd=L;k[id>>2]=ed;k[id+4>>2]=fd;k[id+256>>2]=(fd|0)!=0?-2:-1;break}else{k[id+256>>2]=0;break}else{k[id>>2]=h;k[id+4>>2]=j;k[id+256>>2]=(j|0)!=0?2:1}while(0);Sc(Ec,Fc,id);Uc(Qc,Dc,Ec);Sc(Wc,gd,gd);h=k[b>>2]|0;j=((h|0)<0)<<31>>31;l=ee(h|0,j|0,1)|0;n=L;do if((h|0)<=0)if((h|0)<0){ed=be(0,0,l|0,n|0)|0;fd=L;k[id>>2]=ed;k[id+4>>2]=fd;k[id+256>>2]=(fd|0)!=0?-2:-1;break}else{k[id+256>>2]=0;break}else{k[id>>2]=l;fd=de(h|0,j|0,31)|0;k[id+4>>2]=fd;k[id+256>>2]=(fd|0)!=0?2:1}while(0);Sc(Rc,Wc,id);Tc(Pc,Qc,Rc);fe(q|0,Pc|0,260)|0;if(M){Xc(Yc,jd,kd);g=+p[Yc>>3];j=k[Yc+8>>2]|0;do if((j|0)>1023){g=g*89884656743115795.0e291;h=j+-1023|0;if((h|0)<=1023)break;h=j+-2046|0;h=(h|0)>1023?1023:h;g=g*89884656743115795.0e291}else{if((j|0)>=-1022){h=j;break}g=g*2.2250738585072014e-308;h=j+1022|0;if((h|0)>=-1022)break;h=j+2044|0;h=(h|0)<-1022?-1022:h;g=g*2.2250738585072014e-308}while(0);fd=ee(h+1023|0,0,52)|0;id=L;k[t>>2]=fd;k[t+4>>2]=id;p[f>>3]=g*+p[t>>3]/m}if(!N)break;j=k[cd+256>>2]|0;fe(jd+520|0,cd|0,256)|0;k[jd+776>>2]=(j|0)<0?0-j|0:j;Sc(_c,gd,gd);Sc($c,hd,hd);Tc(Zc,_c,$c);fe(kd+520|0,Zc|0,260)|0;Vc(bd,a,jd,kd);g=+p[bd>>3];j=k[bd+8>>2]|0;do if((j|0)>1023){g=g*89884656743115795.0e291;h=j+-1023|0;if((h|0)<=1023)break;h=j+-2046|0;h=(h|0)>1023?1023:h;g=g*89884656743115795.0e291}else{if((j|0)>=-1022){h=j;break}g=g*2.2250738585072014e-308;h=j+1022|0;if((h|0)>=-1022)break;h=j+2044|0;h=(h|0)<-1022?-1022:h;g=g*2.2250738585072014e-308}while(0);kd=ee(h+1023|0,0,52)|0;a=L;k[t>>2]=kd;k[t+4>>2]=a;p[f+16>>3]=g*+p[t>>3]/m}while(0)}r=ld;return}function Sc(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0;r=b+256|0;d=k[r>>2]|0;if((d|0)!=0?(s=c+256|0,e=k[s>>2]|0,(e|0)!=0):0){d=(d|0)>-1?d:0-d|0;p=(e|0)>-1?e:0-e|0;o=d+-1+p|0;o=o>>>0<64?o:64;q=a+256|0;k[q>>2]=o;if(o){o=(d|0)==0;l=0-d|0;e=0;g=0;m=-1;n=0;while(1){j=0-(m>>>0>l>>>0?m:l)|0;if(o){f=0;d=0}else{f=0;d=0;i=0;do{h=n-i|0;if(h>>>0<p>>>0){t=ne(k[c+(h<<2)>>2]|0,0,k[b+(i<<2)>>2]|0,0)|0;h=L;e=ge(t|0,0,e|0,g|0)|0;g=L;f=ge(h|0,0,f|0,d|0)|0;d=L}i=i+1|0}while((i|0)!=(j|0))}k[a+(n<<2)>>2]=e;e=ge(g|0,0,f|0,d|0)|0;g=L;n=n+1|0;d=k[q>>2]|0;if(n>>>0>=d>>>0)break;else m=m+-1|0}if(!((e|0)==0&(g|0)==0|(d|0)==64)){k[a+(d<<2)>>2]=e;d=(k[q>>2]|0)+1|0;k[q>>2]=d}}else d=0;if(!((k[r>>2]|0)>0^(k[s>>2]|0)>0))return;k[q>>2]=0-d;return}k[a+256>>2]=0;return}\r\nfunction Tc(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,l=0,m=0;j=b+256|0;d=k[j>>2]|0;if(!d){fe(a|0,c|0,260)|0;return}e=k[c+256>>2]|0;if(!e){fe(a|0,b|0,260)|0;return}f=(d|0)>-1?d:0-d|0;g=(e|0)>-1?e:0-e|0;if(!((d|0)>0^(e|0)>0)){while(1)if(f>>>0<g>>>0){h=g;i=c;g=f;f=h;c=b;b=i}else break;i=a+256|0;k[i>>2]=f;if(!g){e=0;d=0;c=0}else{e=0;d=0;h=0;while(1){m=k[c+(h<<2)>>2]|0;d=ge(k[b+(h<<2)>>2]|0,0,e|0,d|0)|0;d=ge(d|0,L|0,m|0,0)|0;e=L;k[a+(h<<2)>>2]=d;h=h+1|0;if((h|0)==(g|0)){d=0;c=g;break}else d=0}}if(c>>>0<f>>>0)while(1){m=ge(k[b+(c<<2)>>2]|0,0,e|0,d|0)|0;e=L;k[a+(c<<2)>>2]=m;c=c+1|0;if((c|0)==(f|0)){d=0;break}else d=0}if(!((e|0)==0&(d|0)==0)?(l=k[i>>2]|0,(l|0)!=64):0){k[a+(l<<2)>>2]=e;k[i>>2]=(k[i>>2]|0)+1}}else $c(a,b,f,c,g,0);if((k[j>>2]|0)>=0)return;m=a+256|0;k[m>>2]=0-(k[m>>2]|0);return}function Uc(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,l=0,m=0;j=b+256|0;d=k[j>>2]|0;if(!d){fe(a|0,c|0,260)|0;a=a+256|0;k[a>>2]=0-(k[a>>2]|0);return}e=k[c+256>>2]|0;if(!e){fe(a|0,b|0,260)|0;return}f=(d|0)>-1?d:0-d|0;g=(e|0)>-1?e:0-e|0;if((d|0)>0^(e|0)>0){while(1)if(f>>>0<g>>>0){h=g;i=c;g=f;f=h;c=b;b=i}else break;i=a+256|0;k[i>>2]=f;if(!g){e=0;d=0;c=0}else{e=0;d=0;h=0;while(1){m=k[c+(h<<2)>>2]|0;d=ge(k[b+(h<<2)>>2]|0,0,e|0,d|0)|0;d=ge(d|0,L|0,m|0,0)|0;e=L;k[a+(h<<2)>>2]=d;h=h+1|0;if((h|0)==(g|0)){d=0;c=g;break}else d=0}}if(c>>>0<f>>>0)while(1){m=ge(k[b+(c<<2)>>2]|0,0,e|0,d|0)|0;e=L;k[a+(c<<2)>>2]=m;c=c+1|0;if((c|0)==(f|0)){d=0;break}else d=0}if(!((e|0)==0&(d|0)==0)?(l=k[i>>2]|0,(l|0)!=64):0){k[a+(l<<2)>>2]=e;k[i>>2]=(k[i>>2]|0)+1}}else $c(a,b,f,c,g,0);if((k[j>>2]|0)>=0)return;m=a+256|0;k[m>>2]=0-(k[m>>2]|0);return}function Vc(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,l=0,m=0.0,n=0,o=0,q=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0.0,A=0,B=0,C=0,D=0,E=0;C=r;r=r+3184|0;A=C+2924|0;x=C+48|0;y=C+32|0;e=C+2664|0;f=C+2404|0;n=C+2144|0;o=C+1884|0;q=C+1624|0;s=C+1364|0;t=C+1104|0;u=C+844|0;v=C+584|0;w=C+324|0;g=C+64|0;h=C+16|0;i=C;Xc(x,c,d);j=c+520|0;l=d+520|0;_c(y,j,l);m=+p[x>>3];if(!(!(m<0.0)?!(+p[y>>3]<0.0):0))B=3;if((B|0)==3?(z=+p[y>>3],m>0.0|z>0.0):0){D=b+780|0;Sc(f,c,c);Sc(n,f,d);E=c+260|0;Sc(q,E,E);f=d+260|0;Sc(o,q,f);Tc(s,n,o);Sc(u,j,j);Sc(t,u,l);Uc(e,s,t);fe(D|0,e|0,260)|0;B=b+2080|0;k[B>>2]=1;k[b+2336>>2]=1;Sc(w,c,E);k[A>>2]=2;k[A+256>>2]=1;Sc(v,w,A);fe(b+1040|0,v|0,260)|0;Sc(g,d,f);fe(b+2340|0,g|0,260)|0;Xc(h,D,B);Zc(i,x,z,k[y+8>>2]|0);b=(k[h+8>>2]|0)-(k[i+8>>2]|0)|0;B=a+8|0;z=+Kd(+p[h>>3]/+p[i>>3],B);p[a>>3]=z;k[B>>2]=b+(k[B>>2]|0);r=C;return}Yc(a,x,y);r=C;return}function Wc(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,l=0,m=0,n=0,o=0,q=0,s=0,t=0,u=0,v=0.0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0.0,G=0,H=0,I=0,J=0;I=r;r=r+4752|0;G=I+4484|0;D=I+48|0;E=I+32|0;e=I+4224|0;f=I+3964|0;t=I+3704|0;w=I+3444|0;x=I+3184|0;y=I+2924|0;z=I+2664|0;A=I+2404|0;B=I+2144|0;C=I+1884|0;g=I+1624|0;h=I+1364|0;i=I+1104|0;j=I+844|0;l=I+584|0;m=I+324|0;n=I+64|0;o=I+16|0;q=I;Xc(D,c,d);s=c+520|0;u=d+520|0;Xc(E,s,u);v=+p[D>>3];if(!(!(v<0.0)?!(+p[E>>3]<0.0):0))H=3;if((H|0)==3?(F=+p[E>>3],v>0.0|F>0.0):0){Sc(f,c,c);Sc(t,f,d);J=c+260|0;Sc(x,J,J);f=d+260|0;Sc(w,x,f);Tc(y,t,w);Sc(A,s,s);Sc(z,A,u);Uc(B,y,z);z=c+780|0;Sc(g,z,z);A=d+780|0;Sc(C,g,A);Uc(e,B,C);fe(b|0,e|0,260)|0;H=b+1300|0;k[H>>2]=1;k[b+1556>>2]=1;Sc(i,c,J);k[G>>2]=2;k[G+256>>2]=1;Sc(h,i,G);fe(b+260|0,h|0,260)|0;Sc(j,d,f);fe(b+1560|0,j|0,260)|0;Sc(m,s,z);k[G>>2]=2;k[G+256>>2]=-1;Sc(l,m,G);fe(b+520|0,l|0,260)|0;Sc(n,u,A);fe(b+1820|0,n|0,260)|0;Vc(o,b,b,H);Zc(q,D,F,k[E+8>>2]|0);b=(k[o+8>>2]|0)-(k[q+8>>2]|0)|0;H=a+8|0;F=+Kd(+p[o>>3]/+p[q>>3],H);p[a>>3]=F;k[H>>2]=b+(k[H>>2]|0);r=I;return}Yc(a,D,E);r=I;return}function Xc(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0.0,f=0,g=0,h=0,i=0,j=0,l=0,m=0,n=0,o=0,q=0,s=0,t=0;t=r;r=r+1376|0;o=t+48|0;q=t+32|0;l=t+1104|0;d=t+844|0;f=t+584|0;g=t+324|0;h=t+64|0;m=t+16|0;n=t;_c(o,b,c);i=b+260|0;j=c+260|0;_c(q,i,j);e=+p[o>>3];if(!(!(e<0.0)?!(+p[q>>3]<0.0):0))s=3;do if((s|0)==3){if(!(e>0.0)?!(+p[q>>3]>0.0):0)break;Sc(d,b,b);Sc(f,d,c);Sc(h,i,i);Sc(g,h,j);Uc(l,f,g);f=k[l+256>>2]|0;d=(f|0)>-1?f:0-f|0;switch(d|0){case 0:{e=0.0;d=0;break}case 1:{e=+((k[l>>2]|0)>>>0);d=0;s=10;break}case 2:{e=+((k[l+4>>2]|0)>>>0)*4294967296.0+ +((k[l>>2]|0)>>>0);d=0;s=10;break}default:{e=+((k[l+(d+-3<<2)>>2]|0)>>>0)+(+((k[l+(d+-1<<2)>>2]|0)>>>0)*4294967296.0+ +((k[l+(d+-2<<2)>>2]|0)>>>0))*4294967296.0;d=(d<<5)+-96|0;s=10}}if((s|0)==10)e=(f|0)<0?-e:e;l=m+8|0;e=+Kd(e,l);p[m>>3]=e;s=(k[l>>2]|0)+d|0;k[l>>2]=s;Zc(n,o,+p[q>>3],k[q+8>>2]|0);q=s-(k[n+8>>2]|0)|0;s=a+8|0;e=+Kd(e/+p[n>>3],s);p[a>>3]=e;k[s>>2]=q+(k[s>>2]|0);r=t;return}while(0);Yc(a,o,q);r=t;return}function Yc(a,b,c){a=a|0;b=b|0;c=c|0;var d=0.0,e=0.0,f=0,g=0;d=+p[b>>3];if(!(d==0.0)?(f=k[c+8>>2]|0,g=k[b+8>>2]|0,(f|0)<=(g+54|0)):0){e=+p[c>>3];if((g|0)>(f+54|0)|e==0.0){k[a>>2]=k[b>>2];k[a+4>>2]=k[b+4>>2];k[a+8>>2]=k[b+8>>2];k[a+12>>2]=k[b+12>>2];return}if((g|0)<(f|0)){b=f-g|0;if((b|0)>1023){e=e*89884656743115795.0e291;c=b+-1023|0;if((c|0)>1023){c=b+-2046|0;c=(c|0)>1023?1023:c;e=e*89884656743115795.0e291}}else if((b|0)<-1022){e=e*2.2250738585072014e-308;c=b+1022|0;if((c|0)<-1022){c=b+2044|0;c=(c|0)<-1022?-1022:c;e=e*2.2250738585072014e-308}}else c=b;b=ee(c+1023|0,0,52)|0;f=L;k[t>>2]=b;k[t+4>>2]=f;f=a+8|0;e=+Kd(d+e*+p[t>>3],f);p[a>>3]=e;k[f>>2]=(k[f>>2]|0)+g;return}else{b=g-f|0;if((b|0)>1023){d=d*89884656743115795.0e291;c=b+-1023|0;if((c|0)>1023){c=b+-2046|0;c=(c|0)>1023?1023:c;d=d*89884656743115795.0e291}}else if((b|0)<-1022){d=d*2.2250738585072014e-308;c=b+1022|0;if((c|0)<-1022){c=b+2044|0;c=(c|0)<-1022?-1022:c;d=d*2.2250738585072014e-308}}else c=b;b=ee(c+1023|0,0,52)|0;g=L;k[t>>2]=b;k[t+4>>2]=g;g=a+8|0;e=+Kd(e+d*+p[t>>3],g);p[a>>3]=e;k[g>>2]=(k[g>>2]|0)+f;return}};k[a>>2]=k[c>>2];k[a+4>>2]=k[c+4>>2];k[a+8>>2]=k[c+8>>2];k[a+12>>2]=k[c+12>>2];return}function Zc(a,b,c,d){a=a|0;b=b|0;c=+c;d=d|0;var e=0.0,f=0.0,g=0,h=0;e=+p[b>>3];if(!(e==0.0)?(h=k[b+8>>2]|0,(h+54|0)>=(d|0)):0){if((h|0)>(d+54|0)|c==0.0){k[a>>2]=k[b>>2];k[a+4>>2]=k[b+4>>2];k[a+8>>2]=k[b+8>>2];k[a+12>>2]=k[b+12>>2];return}if((h|0)<(d|0)){g=d-h|0;if((g|0)>1023){f=c*-89884656743115795.0e291;b=g+-1023|0;if((b|0)>1023){b=g+-2046|0;b=(b|0)>1023?1023:b;f=f*89884656743115795.0e291}}else{f=-c;if((g|0)<-1022){f=c*-2.2250738585072014e-308;b=g+1022|0;if((b|0)<-1022){b=g+2044|0;b=(b|0)<-1022?-1022:b;f=f*2.2250738585072014e-308}}else b=g}g=ee(b+1023|0,0,52)|0;d=L;k[t>>2]=g;k[t+4>>2]=d;d=a+8|0;c=+Kd(e+f*+p[t>>3],d);p[a>>3]=c;k[d>>2]=(k[d>>2]|0)+h;return}else{g=h-d|0;if((g|0)>1023){e=e*89884656743115795.0e291;b=g+-1023|0;if((b|0)>1023){b=g+-2046|0;b=(b|0)>1023?1023:b;e=e*89884656743115795.0e291}}else if((g|0)<-1022){e=e*2.2250738585072014e-308;b=g+1022|0;if((b|0)<-1022){b=g+2044|0;b=(b|0)<-1022?-1022:b;e=e*2.2250738585072014e-308}}else b=g;g=ee(b+1023|0,0,52)|0;h=L;k[t>>2]=g;k[t+4>>2]=h;h=a+8|0;c=+Kd(e*+p[t>>3]-c,h);p[a>>3]=c;k[h>>2]=(k[h>>2]|0)+d;return}}h=a+8|0;c=+Kd(-c,h);p[a>>3]=c;k[h>>2]=(k[h>>2]|0)+d;return}function _c(a,b,c){a=a|0;b=b|0;c=c|0;var d=0.0,e=0,f=0,g=0,h=0.0,i=0,j=0,l=0,m=0;m=r;r=r+48|0;g=m+32|0;j=m+16|0;i=m;f=k[b+256>>2]|0;e=(f|0)>-1?f:0-f|0;switch(e|0){case 0:{d=0.0;b=0;break}case 1:{d=+((k[b>>2]|0)>>>0);b=0;l=5;break}case 2:{d=+((k[b+4>>2]|0)>>>0)*4294967296.0+ +((k[b>>2]|0)>>>0);b=0;l=5;break}default:{d=+((k[b+(e+-3<<2)>>2]|0)>>>0)+(+((k[b+(e+-1<<2)>>2]|0)>>>0)*4294967296.0+ +((k[b+(e+-2<<2)>>2]|0)>>>0))*4294967296.0;b=(e<<5)+-96|0;l=5}}if((l|0)==5)d=(f|0)<0?-d:d;e=g+8|0;h=+Kd(d,e);p[g>>3]=h;f=(k[e>>2]|0)+b|0;k[e>>2]=f;e=k[c+256>>2]|0;b=(e|0)>-1?e:0-e|0;switch(b|0){case 0:{d=0.0;b=0;break}case 1:{d=+((k[c>>2]|0)>>>0);b=0;l=10;break}case 2:{d=+((k[c+4>>2]|0)>>>0)*4294967296.0+ +((k[c>>2]|0)>>>0);b=0;l=10;break}default:{d=+((k[c+(b+-3<<2)>>2]|0)>>>0)+(+((k[c+(b+-1<<2)>>2]|0)>>>0)*4294967296.0+ +((k[c+(b+-2<<2)>>2]|0)>>>0))*4294967296.0;b=(b<<5)+-96|0;l=10}}if((l|0)==10)d=(e|0)<0?-d:d;l=j+8|0;d=+Kd(d,l);p[j>>3]=d;l=(k[l>>2]|0)+b|0;c=(l&1|0)==0;j=i+8|0;d=+Kd(+X(+(c?d:d*2.0)),j);p[i>>3]=d;j=(((c^1)<<31>>31)+l>>1)+(k[j>>2]|0)+f|0;l=a+8|0;h=+Kd(h*d,l);p[a>>3]=h;k[l>>2]=j+(k[l>>2]|0);r=m;return}function $c(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0;if(c>>>0<e>>>0){$c(a,d,e,b,c,1);a=a+256|0;k[a>>2]=0-(k[a>>2]|0);return}do if((c|0)!=(e|0)|f){f=a+256|0;k[f>>2]=c+-1;if(!e){e=0;h=f;f=0}else{j=f;i=12}}else{while(1){f=c+-1|0;e=k[b+(f<<2)>>2]|0;g=k[d+(f<<2)>>2]|0;if(e>>>0<g>>>0){i=5;break}if(e>>>0>g>>>0){i=8;break}if(!f)break;else c=f}if((i|0)==5){$c(a,d,c,b,c,1);a=a+256|0;k[a>>2]=0-(k[a>>2]|0);return}if((i|0)==8?(c|0)!=0:0){j=a+256|0;k[j>>2]=f;e=c;i=12;break}k[a+256>>2]=0;return}while(0);if((i|0)==12){f=0;i=0;do{g=b+(i<<2)|0;h=d+(i<<2)|0;k[a+(i<<2)>>2]=(k[g>>2]|0)+(f<<31>>31)-(k[h>>2]|0);g=k[g>>2]|0;h=k[h>>2]|0;if(g>>>0<h>>>0)f=1;else f=f&(g|0)==(h|0);i=i+1|0}while((i|0)!=(e|0));h=j}if(e>>>0<c>>>0){g=f;while(1){f=b+(e<<2)|0;k[a+(e<<2)>>2]=(k[f>>2]|0)-(g&1);e=e+1|0;if((e|0)==(c|0))break;else g=g&(k[f>>2]|0)==0}}f=k[h>>2]|0;if(!(k[a+(f<<2)>>2]|0))return;k[h>>2]=f+1;return}function ad(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0.0,g=0,h=0,i=0,j=0,l=0,m=0,n=0.0,o=0,q=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0,U=0,V=0,W=0,Y=0,Z=0,_=0,$=0,aa=0,ba=0,ca=0,da=0,ea=0,fa=0,ga=0,ha=0,ia=0,ja=0,ka=0,la=0,ma=0,na=0,oa=0,pa=0,qa=0,ra=0,sa=0,ta=0,ua=0,va=0,wa=0,xa=0,ya=0,za=0,Aa=0,Ba=0,Ca=0,Da=0,Ea=0,Fa=0,Ga=0,Ha=0,Ia=0,Ja=0,Ka=0;Ka=r;r=r+16688|0;Ja=Ka+16416|0;xa=Ka+15896|0;ya=Ka+15376|0;za=Ka+272|0;Ba=Ka+256|0;ha=Ka+15112|0;ia=Ka+14852|0;pa=Ka+14592|0;qa=Ka+14332|0;ra=Ka+14072|0;sa=Ka+13812|0;ta=Ka+13552|0;ua=Ka+13292|0;va=Ka+13032|0;wa=Ka+12772|0;ja=Ka+12512|0;ka=Ka+12252|0;la=Ka+11992|0;ma=Ka+11732|0;na=Ka+11472|0;Aa=Ka+240|0;oa=Ka+224|0;Ha=Ka+10432|0;Ia=Ka+9392|0;K=Ka+208|0;M=Ka+192|0;e=Ka+176|0;o=Ka+160|0;q=Ka+144|0;u=Ka+9128|0;v=Ka+8868|0;w=Ka+8608|0;x=Ka+8348|0;y=Ka+8088|0;z=Ka+7828|0;A=Ka+7568|0;B=Ka+7308|0;C=Ka+7048|0;D=Ka+6788|0;E=Ka+6528|0;F=Ka+6268|0;G=Ka+6008|0;H=Ka+5748|0;I=Ka+5488|0;L=Ka+128|0;J=Ka+112|0;Fa=Ka+96|0;t=Ka+80|0;j=Ka+64|0;s=Ka+48|0;Ea=Ka+32|0;N=Ka+5228|0;O=Ka+4968|0;P=Ka+4708|0;Q=Ka+4448|0;R=Ka+4188|0;S=Ka+3928|0;T=Ka+3668|0;U=Ka+3408|0;V=Ka+3148|0;W=Ka+2888|0;Y=Ka+2628|0;Z=Ka+2368|0;_=Ka+2108|0;$=Ka+1848|0;ba=Ka+1588|0;ca=Ka+1328|0;da=Ka+1068|0;ea=Ka+808|0;fa=Ka+548|0;ga=Ka+288|0;Ca=Ka+16|0;Da=Ka;aa=c+780|0;if(!(k[c+1036>>2]|0)){Xc(K,c,d);k[Ha>>2]=1;k[Ha+256>>2]=1;g=d+260|0;Sc(Ia,d,g);h=Ha+260|0;i=d+520|0;fe(h|0,i|0,260)|0;j=Ia+260|0;k[j>>2]=1;k[Ia+516>>2]=1;l=c+520|0;m=d+780|0;_c(e,l,m);Xc(q,Ha,Ia);f=+p[q>>3];Fa=k[q+8>>2]|0;Ea=(Fa&1|0)==0;Ga=o+8|0;f=+Kd(+X(+(Ea?f:f*2.0)),Ga);p[o>>3]=f;Fa=(((Ea^1)<<31>>31)+Fa>>1)+(k[Ga>>2]|0)|0;k[Ga>>2]=Fa;Fa=Fa+(k[e+8>>2]|0)|0;Ga=M+8|0;f=+Kd(+p[e>>3]*f,Ga);p[M>>3]=f;e=Fa+(k[Ga>>2]|0)|0;k[Ga>>2]=e;n=+p[K>>3];if(n<0.0|f<0.0?n>0.0|f>0.0:0){Sc(v,c,c);Sc(w,v,d);Ga=c+260|0;Sc(y,Ga,Ga);Sc(x,y,g);Tc(z,w,x);Sc(B,l,l);Sc(C,B,m);Sc(A,C,i);Uc(u,z,A);fe(Ha|0,u|0,260)|0;k[Ia>>2]=1;k[Ia+256>>2]=1;Sc(E,c,Ga);k[Ja>>2]=2;k[Ja+256>>2]=1;Sc(F,E,Ja);Sc(H,l,l);Sc(G,H,m);Uc(D,F,G);fe(h|0,D|0,260)|0;Sc(I,d,g);fe(j|0,I|0,260)|0;Xc(L,Ha,Ia);Zc(J,K,f,e);Ia=(k[L+8>>2]|0)-(k[J+8>>2]|0)|0;Ja=a+8|0;n=+Kd(+p[L>>3]/+p[J>>3],Ja);p[a>>3]=n;k[Ja>>2]=Ia+(k[Ja>>2]|0);r=Ka;return}Yc(a,K,M);r=Ka;return}k[Ha>>2]=1;k[Ha+256>>2]=1;l=d+260|0;Sc(Ia,d,l);m=Ha+260|0;g=d+520|0;fe(m|0,g|0,260)|0;o=Ia+260|0;k[o>>2]=1;k[Ia+516>>2]=1;h=c+520|0;i=d+780|0;_c(t,h,i);Xc(s,Ha,Ia);n=+p[s>>3];e=k[s+8>>2]|0;M=(e&1|0)==0;q=j+8|0;n=+Kd(+X(+(M?n:n*2.0)),q);p[j>>3]=n;e=(((M^1)<<31>>31)+e>>1)+(k[q>>2]|0)|0;k[q>>2]=e;e=e+(k[t+8>>2]|0)|0;q=Fa+8|0;n=+Kd(+p[t>>3]*n,q);p[Fa>>3]=n;k[q>>2]=e+(k[q>>2]|0);fe(Ha|0,c|0,260)|0;fe(Ia|0,d|0,260)|0;e=c+260|0;fe(m|0,e|0,260)|0;fe(o|0,l|0,260)|0;j=Ha+520|0;fe(j|0,aa|0,260)|0;k[Ia+520>>2]=1;k[Ia+776>>2]=1;Vc(Ea,b,Ha,Ia);f=+p[Ea>>3];if(f<0.0|n<0.0?f>0.0|n>0.0:0){Sc(N,aa,c);k[Ja>>2]=2;k[Ja+256>>2]=1;Sc(Ha,N,Ja);Sc(P,aa,e);k[Ja>>2]=2;k[Ja+256>>2]=1;Sc(O,P,Ja);fe(m|0,O|0,260)|0;Sc(R,c,c);Sc(S,R,d);Sc(U,e,e);Sc(T,U,l);Tc(V,S,T);Sc(W,aa,aa);Tc(Y,V,W);Sc(_,h,h);Sc($,_,g);Sc(Z,$,i);Uc(Q,Y,Z);fe(j|0,Q|0,260)|0;g=Ha+780|0;Sc(ca,c,e);k[Ja>>2]=2;k[Ja+256>>2]=1;Sc(da,ca,Ja);Sc(fa,h,h);Sc(ea,fa,i);Uc(ba,da,ea);fe(g|0,ba|0,260)|0;e=Ia+780|0;Sc(ga,d,l);fe(e|0,ga|0,260)|0;Xc(za,Ha,Ia);Xc(Ba,j,Ia+520|0);f=+p[za>>3];if(!(f<0.0)?!(+p[Ba>>3]<0.0):0)Ga=12;else{n=+p[Ba>>3];if(f>0.0|n>0.0){Sc(ia,Ha,Ha);Sc(pa,ia,Ia);Sc(ra,m,m);Sc(qa,ra,o);Tc(sa,pa,qa);Sc(ta,j,j);Uc(ua,sa,ta);Sc(wa,g,g);Sc(ja,wa,Ia);Sc(va,ja,o);Uc(ha,ua,va);fe(xa|0,ha|0,260)|0;k[ya>>2]=1;k[ya+256>>2]=1;Sc(la,Ha,m);Sc(ma,j,g);Uc(na,la,ma);k[Ja>>2]=2;k[Ja+256>>2]=1;Sc(ka,na,Ja);fe(xa+260|0,ka|0,260)|0;fe(ya+260|0,e|0,260)|0;Xc(Aa,xa,ya);Zc(oa,za,n,k[Ba+8>>2]|0);e=(k[Aa+8>>2]|0)-(k[oa+8>>2]|0)|0;Ja=Ca+8|0;f=+Kd(+p[Aa>>3]/+p[oa>>3],Ja);p[Ca>>3]=f;e=e+(k[Ja>>2]|0)|0;k[Ja>>2]=e}else Ga=12}if((Ga|0)==12){Yc(Ca,za,Ba);f=+p[Ca>>3];e=k[Ca+8>>2]|0}Zc(Da,Ea,+p[Fa>>3],k[q>>2]|0);Ia=e-(k[Da+8>>2]|0)|0;Ja=a+8|0;n=+Kd(f/+p[Da>>3],Ja);p[a>>3]=n;k[Ja>>2]=Ia+(k[Ja>>2]|0);r=Ka;return}Yc(a,Ea,Fa);r=Ka;return}function bd(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,l=0;f=a+4|0;g=k[a>>2]|0;c=g;h=(k[f>>2]|0)-c|0;i=(h|0)/24|0;j=i+1|0;if(j>>>0>178956970)xa(1340,1363,303,1438);l=a+8|0;c=((k[l>>2]|0)-c|0)/24|0;if(c>>>0<89478485){c=c<<1;c=c>>>0<j>>>0?j:c;if(!c){c=0;d=0}else e=5}else{c=178956970;e=5}if((e|0)==5){e=c*24|0;e=(e|0)==0?1:e;d=_d(e)|0;a:do if(!d){while(1){d=k[35]|0;k[35]=d+0;if(!d)break;Xa[d&0]();d=_d(e)|0;if(d)break a}a=ya(4)|0;k[a>>2]=128;La(a|0,8,1)}while(0)}e=d+(i*24|0)|0;k[e>>2]=k[b>>2];k[e+4>>2]=k[b+4>>2];k[e+8>>2]=k[b+8>>2];k[e+12>>2]=k[b+12>>2];k[e+16>>2]=k[b+16>>2];k[e+20>>2]=k[b+20>>2];b=d+((((h|0)/-24|0)+i|0)*24|0)|0;fe(b|0,g|0,h|0)|0;k[a>>2]=b;k[f>>2]=d+(j*24|0);k[l>>2]=d+(c*24|0);if(!g)return;$d(g);return}function cd(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0;j=k[a+16>>2]|0;h=a+28|0;l=k[a+44>>2]|0;m=j>>>0>l>>>0;o=m?a:h;t=k[b+16>>2]|0;i=b+28|0;r=k[b+44>>2]|0;s=t>>>0>r>>>0;p=s?b:i;c=o+8|0;d=k[o>>2]|0;e=k[c>>2]|0;q=(d|0)==(e|0);if(q)if((k[o+4>>2]|0)<(k[o+12>>2]|0))c=o;else g=4;else if((d|0)<(e|0))c=o;else g=4;d=p+8|0;e=k[p>>2]|0;f=k[d>>2]|0;n=(e|0)==(f|0);if(n)if((k[p+4>>2]|0)<(k[p+12>>2]|0))f=p;else g=8;else if((e|0)<(f|0))f=p;else g=8;if((g|0)==8)f=d;d=k[c>>2]|0;e=k[f>>2]|0;if((d|0)<(e|0)){b=hd(a,h,f)|0;return b|0}if((d|0)>(e|0)){b=(hd(b,i,c)|0)^1;return b|0}d=k[o+16>>2]|0;e=k[p+16>>2]|0;if((d|0)==(e|0)){do if((j|0)!=(l|0))if(m){c=a+12|0;f=1;break}else{c=a+32|0;f=-1;break}else{c=a+4|0;f=0}while(0);e=k[c>>2]|0;do if((t|0)!=(r|0))if(s){c=b+12|0;d=1;break}else{c=b+32|0;d=-1;break}else{c=b+4|0;d=0}while(0);c=k[c>>2]|0;if((e|0)<(c|0)){b=1;return b|0}else return (f|0)<(d|0)&(c|0)>=(e|0)|0}c=(j|0)==(l|0);if(d>>>0<e>>>0){do if(!c){if(!m){c=a+32|0;e=-1;break}if((k[a>>2]|0)==(k[a+8>>2]|0)){c=a+4|0;e=1;break}else{c=a+12|0;e=1;break}}else{c=a+4|0;e=0}while(0);d=k[c>>2]|0;do if((t|0)!=(r|0))if(s){c=b+12|0;break}else{c=b+32|0;break}else c=b+4|0;while(0);c=k[c>>2]|0;if((d|0)!=(c|0)){b=(d|0)<(c|0);return b|0}if(q)c=(k[o+4>>2]|0)==(k[o+12>>2]|0);else c=0;b=(e|0)<0&c;return b|0}else{do if(!c)if(m){c=a+12|0;break}else{c=a+32|0;break}else c=a+4|0;while(0);e=k[c>>2]|0;do if((t|0)!=(r|0)){if(!s){c=b+32|0;d=-1;break}if((k[b>>2]|0)==(k[b+8>>2]|0)){c=b+4|0;d=1;break}else{c=b+12|0;d=1;break}}else{c=b+4|0;d=0}while(0);c=k[c>>2]|0;if((e|0)!=(c|0)){b=(e|0)<(c|0);return b|0}if(n)c=(k[p+4>>2]|0)!=(k[p+12>>2]|0);else c=1;b=(d|0)>0|c;return b|0}return 0}function dd(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0;B=r;r=r+144|0;A=B+128|0;z=B+72|0;p=B;x=B+64|0;u=B+32|0;k[z>>2]=k[b>>2];k[z+4>>2]=k[b+4>>2];k[z+8>>2]=k[b+8>>2];k[z+12>>2]=k[b+12>>2];k[z+16>>2]=k[b+16>>2];k[z+20>>2]=k[b+20>>2];k[z+24>>2]=k[b+24>>2];i=z+28|0;k[i>>2]=k[d>>2];k[i+4>>2]=k[d+4>>2];k[i+8>>2]=k[d+8>>2];k[i+12>>2]=k[d+12>>2];k[i+16>>2]=k[d+16>>2];k[i+20>>2]=k[d+20>>2];k[i+24>>2]=k[d+24>>2];i=d;g=k[i>>2]|0;i=k[i+4>>2]|0;v=d+8|0;h=v;b=k[h>>2]|0;h=k[h+4>>2]|0;s=d+16|0;m=s;l=k[m>>2]|0;m=k[m+4>>2]|0;t=d+24|0;j=k[t>>2]|0;k[p>>2]=k[c>>2];k[p+4>>2]=k[c+4>>2];k[p+8>>2]=k[c+8>>2];k[p+12>>2]=k[c+12>>2];k[p+16>>2]=k[c+16>>2];k[p+20>>2]=k[c+20>>2];k[p+24>>2]=k[c+24>>2];q=d+8|0;if((g|0)==(b|0)?(k[d+4>>2]|0)==(k[d+12>>2]|0):0){n=g;o=i}else{n=b;o=h;b=g;h=i;j=j^32}ed(x,f,c,d);y=a+64|0;i=k[e>>2]|0;f=k[x+4>>2]|0;c=_d(80)|0;a:do if(!c){while(1){g=k[35]|0;k[35]=g+0;if(!g)break;Xa[g&0]();c=_d(80)|0;if(c)break a}B=ya(4)|0;k[B>>2]=128;La(B|0,8,1)}while(0);g=c+16|0;C=g;k[C>>2]=n;k[C+4>>2]=o;o=c+24|0;k[o>>2]=b;k[o+4>>2]=h;b=c+32|0;k[b>>2]=l;k[b+4>>2]=m;k[c+40>>2]=j;b=c+44|0;k[b>>2]=k[p>>2];k[b+4>>2]=k[p+4>>2];k[b+8>>2]=k[p+8>>2];k[b+12>>2]=k[p+12>>2];k[b+16>>2]=k[p+16>>2];k[b+20>>2]=k[p+20>>2];k[b+24>>2]=k[p+24>>2];k[c+72>>2]=0;k[c+76>>2]=f;g=fd(y,i,A,g)|0;b=k[g>>2]|0;if(b)if((b|0)==(c|0))c=b;else{$d(c);c=b}else{b=k[A>>2]|0;k[c>>2]=0;k[c+4>>2]=0;k[c+8>>2]=b;k[g>>2]=c;b=k[k[y>>2]>>2]|0;if(!b)b=c;else{k[y>>2]=b;b=k[g>>2]|0}Nb(k[a+68>>2]|0,b);C=a+72|0;k[C>>2]=(k[C>>2]|0)+1}k[e>>2]=c;if(!((k[d>>2]|0)==(k[q>>2]|0)?(k[d+4>>2]|0)==(k[d+12>>2]|0):0))w=16;do if((w|0)==16){k[u>>2]=k[d>>2];k[u+4>>2]=k[d+4>>2];k[u+8>>2]=k[d+8>>2];k[u+12>>2]=k[d+12>>2];k[u+16>>2]=k[d+16>>2];k[u+20>>2]=k[d+20>>2];k[u+24>>2]=k[d+24>>2];n=d;m=k[n>>2]|0;n=k[n+4>>2]|0;l=v;f=k[l>>2]|0;l=k[l+4>>2]|0;j=s;i=k[j>>2]|0;j=k[j+4>>2]|0;g=k[t>>2]^32;b=_d(80)|0;b:do if(!b){while(1){b=k[35]|0;k[35]=b+0;if(!b)break;Xa[b&0]();b=_d(80)|0;if(b){h=b;break b}}C=ya(4)|0;k[C>>2]=128;La(C|0,8,1)}else h=b;while(0);b=h+16|0;k[b>>2]=k[u>>2];k[b+4>>2]=k[u+4>>2];k[b+8>>2]=k[u+8>>2];k[b+12>>2]=k[u+12>>2];k[b+16>>2]=k[u+16>>2];k[b+20>>2]=k[u+20>>2];k[b+24>>2]=k[u+24>>2];C=h+44|0;k[C>>2]=f;k[C+4>>2]=l;C=h+52|0;k[C>>2]=m;k[C+4>>2]=n;C=h+60|0;k[C>>2]=i;k[C+4>>2]=j;k[h+68>>2]=g;k[h+72>>2]=0;k[h+76>>2]=0;g=fd(y,c,A,b)|0;b=k[g>>2]|0;if(b)if((b|0)==(h|0))g=b;else{$d(h);g=b}else{b=k[A>>2]|0;k[h>>2]=0;k[h+4>>2]=0;k[h+8>>2]=b;k[g>>2]=h;b=k[k[y>>2]>>2]|0;if(!b)b=h;else{k[y>>2]=b;b=k[g>>2]|0}Nb(k[a+68>>2]|0,b);g=a+72|0;k[g>>2]=(k[g>>2]|0)+1;g=h}k[e>>2]=g;b=a+20|0;n=v;m=k[n>>2]|0;n=k[n+4>>2]|0;q=a+24|0;h=k[q>>2]|0;o=a+28|0;i=k[o>>2]|0;if(h>>>0>=i>>>0){p=k[b>>2]|0;j=p;c=h-j|0;l=(c|0)/12|0;f=l+1|0;if(f>>>0>357913941)xa(1340,1363,303,1438);h=(i-j|0)/12|0;if(h>>>0<178956970){h=h<<1;h=h>>>0<f>>>0?f:h;if(!h){j=0;i=0}else w=32}else{h=357913941;w=32}if((w|0)==32){j=h*12|0;j=(j|0)==0?1:j;i=_d(j)|0;c:do if(!i){while(1){i=k[35]|0;k[35]=i+0;if(!i)break;Xa[i&0]();i=_d(j)|0;if(i)break c}C=ya(4)|0;k[C>>2]=128;La(C|0,8,1)}while(0);j=h}h=i+(l*12|0)|0;k[h>>2]=m;k[h+4>>2]=n;k[i+(l*12|0)+8>>2]=g;h=i+(f*12|0)|0;C=i+((((c|0)/-12|0)+l|0)*12|0)|0;fe(C|0,p|0,c|0)|0;k[b>>2]=C;k[q>>2]=h;k[o>>2]=i+(j*12|0);if(!p)f=h;else{$d(p);f=k[q>>2]|0}}else{f=h;k[f>>2]=m;k[f+4>>2]=n;k[h+8>>2]=g;f=(k[q>>2]|0)+12|0;k[q>>2]=f}o=k[b>>2]|0;C=f-o|0;c=(C|0)/12|0;if((C|0)>12){j=(c+-2|0)/2|0;b=o+(j*12|0)|0;l=f+-12|0;h=k[l>>2]|0;i=k[b>>2]|0;if((h|0)==(i|0)){if((k[f+-8>>2]|0)>=(k[o+(j*12|0)+4>>2]|0)){c=g;break}}else if((h|0)>=(i|0)){c=g;break}n=l;m=k[n>>2]|0;n=k[n+4>>2]|0;C=f+-4|0;f=k[C>>2]|0;u=b;v=k[u+4>>2]|0;w=l;k[w>>2]=k[u>>2];k[w+4>>2]=v;k[C>>2]=k[o+(j*12|0)+8>>2];d:do if((c+-1|0)>>>0>=3)while(1){g=j;j=(j+-1|0)/2|0;h=o+(j*12|0)|0;i=k[h>>2]|0;if((m|0)==(i|0)){if((n|0)>=(k[o+(j*12|0)+4>>2]|0))break d}else if((m|0)>=(i|0))break d;v=h;w=k[v+4>>2]|0;C=b;k[C>>2]=k[v>>2];k[C+4>>2]=w;k[o+(g*12|0)+8>>2]=k[o+(j*12|0)+8>>2];if(g>>>0<3){b=h;break}else b=h}while(0);c=b;k[c>>2]=m;k[c+4>>2]=n;k[b+8>>2]=f;c=k[e>>2]|0}else c=g}while(0);j=k[x>>2]|0;b=_d(80)|0;e:do if(!b){while(1){b=k[35]|0;k[35]=b+0;if(!b)break;Xa[b&0]();b=_d(80)|0;if(b){f=b;break e}}C=ya(4)|0;k[C>>2]=128;La(C|0,8,1)}else f=b;while(0);h=f+16|0;i=h;b=z;g=i+56|0;do{k[i>>2]=k[b>>2];i=i+4|0;b=b+4|0}while((i|0)<(g|0));k[f+72>>2]=0;k[f+76>>2]=j;g=fd(y,c,A,h)|0;b=k[g>>2]|0;if(!b){b=k[A>>2]|0;k[f>>2]=0;k[f+4>>2]=0;k[f+8>>2]=b;k[g>>2]=f;b=k[k[y>>2]>>2]|0;if(!b)b=f;else{k[y>>2]=b;b=k[g>>2]|0}Nb(k[a+68>>2]|0,b);C=a+72|0;k[C>>2]=(k[C>>2]|0)+1;C=f;r=B;return C|0}else{if((b|0)==(f|0)){C=b;r=B;return C|0}$d(f);C=b;r=B;return C|0}return 0}function ed(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0,s=0,t=0,u=0,v=0,w=0,x=0;x=r;r=r+80|0;q=x+48|0;s=x+24|0;t=x+12|0;u=x;v=k[c+16>>2]|0;w=k[d+16>>2]|0;o=k[c>>2]|0;l=k[c+8>>2]|0;i=(o|0)==(l|0);if(i)g=(k[c+4>>2]|0)!=(k[c+12>>2]|0);else g=1;m=k[d>>2]|0;n=k[d+8>>2]|0;j=(m|0)==(n|0);do if(j){f=k[d+4>>2]|0;e=(f|0)!=(k[d+12>>2]|0);if(!(e|g^1)){if((o|0)==(m|0)?(k[c+4>>2]|0)==(f|0):0){h=1;break}if((l|0)==(m|0)?(k[c+12>>2]|0)==(f|0):0)h=1;else p=14}else p=9}else{e=1;p=9}while(0);do if((p|0)==9)if(!(g|e^1)){if((m|0)==(o|0)?(k[d+4>>2]|0)==(k[c+4>>2]|0):0){h=1;break}if((n|0)==(o|0)?(k[d+12>>2]|0)==(k[c+4>>2]|0):0)h=1;else p=14}else p=14;while(0);if((p|0)==14){if(i)e=(k[c+4>>2]|0)!=(k[c+12>>2]|0);else e=1;if(j)f=(k[d+4>>2]|0)!=(k[d+12>>2]|0);else f=1;h=e^f^1}if(i)g=(k[c+4>>2]|0)!=(k[c+12>>2]|0);else g=1;do if(j){f=k[d+4>>2]|0;e=(f|0)!=(k[d+12>>2]|0);if(!(e|g^1)){if((o|0)==(m|0)?(k[c+4>>2]|0)==(f|0):0){e=0;break}if((l|0)==(m|0))e=(k[c+12>>2]|0)!=(f|0);else e=1}else p=27}else{e=1;p=27}while(0);do if((p|0)==27)if(!(g|e^1)){if((m|0)==(o|0)?(k[d+4>>2]|0)==(k[c+4>>2]|0):0){e=0;break}if((n|0)==(o|0))e=(k[d+12>>2]|0)!=(k[c+4>>2]|0);else e=1}else e=1;while(0);i=b+24|0;f=h&1;f=e?f|2:f;k[q>>2]=0;k[q+4>>2]=0;k[q+8>>2]=0;k[q+12>>2]=0;k[q+16>>2]=0;k[q+20>>2]=f;g=b+28|0;e=k[g>>2]|0;h=b+32|0;if(e>>>0<(k[h>>2]|0)>>>0){k[e>>2]=k[q>>2];k[e+4>>2]=k[q+4>>2];k[e+8>>2]=k[q+8>>2];k[e+12>>2]=k[q+12>>2];k[e+16>>2]=k[q+16>>2];k[e+20>>2]=k[q+20>>2];m=(k[g>>2]|0)+24|0;k[g>>2]=m}else{bd(i,q);m=k[g>>2]|0}l=m+-24|0;k[s>>2]=0;k[s+4>>2]=0;k[s+8>>2]=0;k[s+12>>2]=0;k[s+16>>2]=0;k[s+20>>2]=f;if(m>>>0<(k[h>>2]|0)>>>0){k[m>>2]=k[s>>2];k[m+4>>2]=k[s+4>>2];k[m+8>>2]=k[s+8>>2];k[m+12>>2]=k[s+12>>2];k[m+16>>2]=k[s+16>>2];k[m+20>>2]=k[s+20>>2];i=(k[g>>2]|0)+24|0;k[g>>2]=i}else{bd(i,s);i=k[g>>2]|0}h=i+-24|0;g=k[b>>2]|0;j=b+4|0;e=k[j>>2]|0;do if((g|0)==(e|0)){f=k[c+24>>2]&31;k[t>>2]=k[c+20>>2];k[t+4>>2]=0;k[t+8>>2]=f;f=b+8|0;if(g>>>0<(k[f>>2]|0)>>>0){k[g>>2]=k[t>>2];k[g+4>>2]=k[t+4>>2];k[g+8>>2]=k[t+8>>2];e=(k[j>>2]|0)+12|0;k[j>>2]=e;break}else{gd(b,t);e=k[j>>2]|0;break}}else f=b+8|0;while(0);t=k[d+24>>2]&31;k[u>>2]=k[d+20>>2];k[u+4>>2]=0;k[u+8>>2]=t;if(e>>>0<(k[f>>2]|0)>>>0){k[e>>2]=k[u>>2];k[e+4>>2]=k[u+4>>2];k[e+8>>2]=k[u+8>>2];k[j>>2]=(k[j>>2]|0)+12;b=k[b>>2]|0;d=b+(v*12|0)|0;k[l>>2]=d;b=b+(w*12|0)|0;k[h>>2]=b;b=m+-16|0;k[b>>2]=h;b=i+-16|0;k[b>>2]=l;b=l;d=h;k[a>>2]=b;b=a+4|0;k[b>>2]=d;r=x;return}else{gd(b,u);b=k[b>>2]|0;d=b+(v*12|0)|0;k[l>>2]=d;b=b+(w*12|0)|0;k[h>>2]=b;b=m+-16|0;k[b>>2]=h;b=i+-16|0;k[b>>2]=l;b=l;d=h;k[a>>2]=b;b=a+4|0;k[b>>2]=d;r=x;return}}function fd(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,g=0,h=0;h=a+4|0;e=b;if((h|0)!=(b|0)?(f=b+16|0,!(cd(d,f)|0)):0){if(!(cd(f,d)|0)){k[c>>2]=e;return c|0}a=b+4|0;e=k[a>>2]|0;g=(e|0)==0;if(g){f=b;while(1){e=k[f+8>>2]|0;if((k[e>>2]|0)==(f|0))break;else f=e}}else while(1){f=k[e>>2]|0;if(!f)break;else e=f}if((e|0)!=(h|0)?!(cd(d,e+16|0)|0):0){e=k[h>>2]|0;if(!e){k[c>>2]=h;c=h;return c|0}else a=e;while(1){e=a+16|0;if(cd(d,e)|0){e=k[a>>2]|0;if(!e){h=33;break}}else{if(!(cd(e,d)|0)){h=38;break}f=a+4|0;e=k[f>>2]|0;if(!e){h=37;break}}a=e}if((h|0)==33){k[c>>2]=a;c=a;return c|0}else if((h|0)==37){k[c>>2]=a;c=f;return c|0}else if((h|0)==38){k[c>>2]=a;return c|0}}if(g){k[c>>2]=b;c=a;return c|0}else{k[c>>2]=e;c=e;return c|0}}g=k[b>>2]|0;if((k[a>>2]|0)!=(b|0)){if(!g){f=b;while(1){e=k[f+8>>2]|0;if((k[e>>2]|0)==(f|0))f=e;else break}}else{e=g;while(1){f=k[e+4>>2]|0;if(!f)break;else e=f}}if(!(cd(e+16|0,d)|0)){e=k[h>>2]|0;if(!e){k[c>>2]=h;c=h;return c|0}else a=e;while(1){e=a+16|0;if(cd(d,e)|0){e=k[a>>2]|0;if(!e){h=14;break}}else{if(!(cd(e,d)|0)){h=19;break}f=a+4|0;e=k[f>>2]|0;if(!e){h=18;break}}a=e}if((h|0)==14){k[c>>2]=a;c=a;return c|0}else if((h|0)==18){k[c>>2]=a;c=f;return c|0}else if((h|0)==19){k[c>>2]=a;return c|0}}else{a=b;f=g}}else{a=b;f=g}if(!f){k[c>>2]=b;c=a;return c|0}else{d=e;k[c>>2]=d;c=d+4|0;return c|0}return 0}function gd(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,l=0;f=a+4|0;g=k[a>>2]|0;c=g;h=(k[f>>2]|0)-c|0;i=(h|0)/12|0;j=i+1|0;if(j>>>0>357913941)xa(1340,1363,303,1438);l=a+8|0;c=((k[l>>2]|0)-c|0)/12|0;if(c>>>0<178956970){c=c<<1;c=c>>>0<j>>>0?j:c;if(!c){c=0;d=0}else e=5}else{c=357913941;e=5}if((e|0)==5){e=c*12|0;e=(e|0)==0?1:e;d=_d(e)|0;a:do if(!d){while(1){d=k[35]|0;k[35]=d+0;if(!d)break;Xa[d&0]();d=_d(e)|0;if(d)break a}a=ya(4)|0;k[a>>2]=128;La(a|0,8,1)}while(0)}e=d+(i*12|0)|0;k[e>>2]=k[b>>2];k[e+4>>2]=k[b+4>>2];k[e+8>>2]=k[b+8>>2];b=d+((((h|0)/-12|0)+i|0)*12|0)|0;fe(b|0,g|0,h|0)|0;k[a>>2]=b;k[f>>2]=d+(j*12|0);k[l>>2]=d+(c*12|0);if(!g)return;$d(g);return}function hd(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0.0,l=0.0,m=0.0,n=0.0;i=k[a>>2]|0;f=k[a+8>>2]|0;if((i|0)==(f|0))d=(k[a+4>>2]|0)!=(k[a+12>>2]|0);else d=1;h=k[b>>2]|0;if((h|0)==(k[b+8>>2]|0))e=(k[b+4>>2]|0)!=(k[b+12>>2]|0);else e=1;if(d)if(e){e=k[c>>2]|0;d=k[c+4>>2]|0;if((k[a+16>>2]|0)==(k[b+16>>2]|0)){i=(Pc(i,k[a+4>>2]|0,f,k[a+12>>2]|0,e,d)|0)==1;return i|0}else{j=+jd(a,e,d);i=j<+jd(b,e,d);return i|0}}else{g=k[b+4>>2]|0;f=k[c>>2]|0;e=k[c+4>>2]|0;d=id(h,g,a,f,e,1)|0;if(!d){j=+(h|0)-+(f|0);l=+(g|0)-+(e|0);i=!((j*j+l*l)/(j*2.0)<+jd(a,f,e));return i|0}else{i=(d|0)==-1;return i|0}}if(e){f=k[a+4>>2]|0;g=k[c>>2]|0;e=k[c+4>>2]|0;d=id(i,f,b,g,e,0)|0;if(!d){l=+(i|0)-+(g|0);j=+(f|0)-+(e|0);i=(l*l+j*j)/(l*2.0)<+jd(b,g,e);return i|0}else{i=(d|0)==-1;return i|0}}do if((i|0)>(h|0)){e=k[c+4>>2]|0;d=k[a+4>>2]|0;if((e|0)>(d|0)){f=e;e=k[b+4>>2]|0;break}else{i=0;return i|0}}else{if((i|0)>=(h|0)){h=k[a+4>>2]|0;b=k[b+4>>2]|0;b=ge(b|0,((b|0)<0)<<31>>31|0,h|0,((h|0)<0)<<31>>31|0)|0;h=L;i=k[c+4>>2]|0;i=ee(i|0,((i|0)<0)<<31>>31|0,1)|0;c=L;i=(h|0)<(c|0)|(h|0)==(c|0)&b>>>0<i>>>0;return i|0}f=k[c+4>>2]|0;e=k[b+4>>2]|0;if((f|0)<(e|0)){d=k[a+4>>2]|0;break}else{i=1;return i|0}}while(0);l=+(k[c>>2]|0);m=+(i|0)-l;j=+(f|0);n=+(d|0)-j;l=+(h|0)-l;j=+(e|0)-j;i=(n*n+m*m)/(m*2.0)<(j*j+l*l)/(l*2.0);return i|0}function id(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0.0,h=0,i=0,j=0,l=0,m=0.0,n=0.0,o=0.0,q=0.0,r=0,s=0,u=0,v=0,w=0,x=0,y=0,z=0;h=k[c>>2]|0;i=k[c+4>>2]|0;j=k[c+8>>2]|0;l=k[c+12>>2]|0;if((Pc(h,i,j,l,d,e)|0)!=-1){c=((k[c+24>>2]|0)>>>4&2)+-1|0;return c|0}q=+(d|0)-+(a|0);m=+(e|0)-+(b|0);n=+(j|0)-+(h|0);o=+(l|0)-+(i|0);if((h|0)==(j|0))if((e|0)>=(b|0)|f)return ((e|0)>(b|0)&f)<<31>>31|0;else{c=1;return c|0}y=be(j|0,((j|0)<0)<<31>>31|0,h|0,((h|0)<0)<<31>>31|0)|0;x=L;u=be(l|0,((l|0)<0)<<31>>31|0,i|0,((i|0)<0)<<31>>31|0)|0;s=L;l=be(d|0,((d|0)<0)<<31>>31|0,a|0,((a|0)<0)<<31>>31|0)|0;j=L;i=be(e|0,((e|0)<0)<<31>>31|0,b|0,((b|0)<0)<<31>>31|0)|0;h=L;e=(x|0)<0;z=be(0,0,y|0,x|0)|0;x=e?L:x;a=(s|0)<0;v=be(0,0,u|0,s|0)|0;s=a?L:s;b=(j|0)<0;r=be(0,0,l|0,j|0)|0;j=b?L:j;d=(h|0)<0;w=be(0,0,i|0,h|0)|0;h=ne((e?z:y)|0,x|0,(d?w:i)|0,(d?L:h)|0)|0;i=L;j=ne((a?v:u)|0,s|0,(b?r:l)|0,j|0)|0;l=L;a=b^a;do if(d^e){if(!a){z=ge(j|0,l|0,h|0,i|0)|0;g=-(+(z>>>0)+4294967296.0*+(L>>>0));break}if(i>>>0>l>>>0|(i|0)==(l|0)&h>>>0>j>>>0){z=be(h|0,i|0,j|0,l|0)|0;g=-(+(z>>>0)+4294967296.0*+(L>>>0));break}else{z=be(j|0,l|0,h|0,i|0)|0;g=+(z>>>0)+4294967296.0*+(L>>>0);break}}else{if(a){z=ge(j|0,l|0,h|0,i|0)|0;g=+(z>>>0)+4294967296.0*+(L>>>0);break}if(i>>>0<l>>>0|(i|0)==(l|0)&h>>>0<j>>>0){z=be(j|0,l|0,h|0,i|0)|0;g=-(+(z>>>0)+4294967296.0*+(L>>>0));break}else{z=be(h|0,i|0,j|0,l|0)|0;g=+(z>>>0)+4294967296.0*+(L>>>0);break}}while(0);if(!(g!=0.0&!(g<0.0))){p[t>>3]=(m-q)*((q+m)*n);u=k[t>>2]|0;r=k[t+4>>2]|0;p[t>>3]=m*(q*(o*2.0));v=k[t>>2]|0;s=k[t+4>>2]|0;x=(r|0)>-1|(r|0)==-1&u>>>0>4294967295;w=be(0,-2147483648,u|0,r|0)|0;u=x?w:u;r=x?L:r;x=(s|0)>-1|(s|0)==-1&v>>>0>4294967295;w=be(0,-2147483648,v|0,s|0)|0;v=x?w:v;s=x?L:s;x=be(u|0,r|0,v|0,s|0)|0;w=L;z=be(v|0,s|0,u|0,r|0)|0;y=L;z=r>>>0>s>>>0|(r|0)==(s|0)&u>>>0>v>>>0?(w>>>0>0|(w|0)==0&x>>>0>4)<<31>>31:(y>>>0>0|(y|0)==0&z>>>0>4)&1;return ((z|0)!=0&((z|0)==1^f)?(f?-1:1):0)|0}if(!(k[c+24>>2]&32)){z=f<<31>>31;return z|0}else{z=f&1^1;return z|0}return 0}function jd(a,b,c){a=a|0;b=b|0;c=c|0;var d=0.0,e=0,f=0,g=0.0,h=0,i=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0.0;e=k[a>>2]|0;f=k[a+8>>2]|0;if((e|0)==(f|0)){g=(+(e|0)-+(b|0))*.5;return +g}t=+(f|0)-+(e|0);l=k[a+12>>2]|0;q=k[a+4>>2]|0;g=+(l|0)-+(q|0);t=t*t;d=+X(+(t+g*g));g=g<0.0?(d-g)/t:1.0/(d+g);n=((e|0)<0)<<31>>31;p=be(f|0,((f|0)<0)<<31>>31|0,e|0,n|0)|0;a=L;r=((q|0)<0)<<31>>31;l=be(l|0,((l|0)<0)<<31>>31|0,q|0,r|0)|0;f=L;n=be(b|0,((b|0)<0)<<31>>31|0,e|0,n|0)|0;m=L;r=be(c|0,((c|0)<0)<<31>>31|0,q|0,r|0)|0;q=L;i=(a|0)<0;e=be(0,0,p|0,a|0)|0;a=i?L:a;j=(f|0)<0;b=be(0,0,l|0,f|0)|0;f=j?L:f;c=(m|0)<0;o=be(0,0,n|0,m|0)|0;m=c?L:m;h=(q|0)<0;s=be(0,0,r|0,q|0)|0;a=ne((h?s:r)|0,(h?L:q)|0,(i?e:p)|0,a|0)|0;e=L;f=ne((c?o:n)|0,m|0,(j?b:l)|0,f|0)|0;b=L;c=j^c;do if(i^h){if(!c){s=ge(a|0,e|0,f|0,b|0)|0;d=-(+(s>>>0)+4294967296.0*+(L>>>0));break}if(e>>>0>b>>>0|(e|0)==(b|0)&a>>>0>f>>>0){s=be(a|0,e|0,f|0,b|0)|0;d=-(+(s>>>0)+4294967296.0*+(L>>>0));break}else{s=be(f|0,b|0,a|0,e|0)|0;d=+(s>>>0)+4294967296.0*+(L>>>0);break}}else{if(c){s=ge(a|0,e|0,f|0,b|0)|0;d=+(s>>>0)+4294967296.0*+(L>>>0);break}if(e>>>0<b>>>0|(e|0)==(b|0)&a>>>0<f>>>0){s=be(f|0,b|0,a|0,e|0)|0;d=-(+(s>>>0)+4294967296.0*+(L>>>0));break}else{s=be(a|0,e|0,f|0,b|0)|0;d=+(s>>>0)+4294967296.0*+(L>>>0);break}}while(0);t=g*d;return +t}function kd(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0.0,g=0,h=0,i=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,M=0,N=0;N=r;r=r+32|0;M=N;H=b;a:while(1){q=H;G=H+-28|0;s=H+-56|0;v=H+-20|0;D=H+-24|0;F=H+-16|0;K=a;b:while(1){p=K;a=q-p|0;switch((a|0)/28|0|0){case 2:{J=4;break a}case 3:{J=20;break a}case 4:{J=21;break a}case 5:{J=22;break a}case 1:case 0:{J=240;break a}default:{}}if((a|0)<868){J=24;break a}g=(a|0)/56|0;h=K+(g*28|0)|0;if((a|0)>27972){a=(a|0)/112|0;a=nd(K,K+(a*28|0)|0,h,K+((a+g|0)*28|0)|0,G)|0}else a=ld(K,h,G)|0;o=k[K>>2]|0;n=k[h>>2]|0;do if((o|0)==(n|0)){d=k[K+8>>2]|0;b=(o|0)==(d|0);if(b?(t=k[K+4>>2]|0,(t|0)==(k[K+12>>2]|0)):0){if((o|0)!=(k[K+(g*28|0)+8>>2]|0)){c=G;break}b=k[K+(g*28|0)+4>>2]|0;if((b|0)==(k[K+(g*28|0)+12>>2]|0))if((t|0)<(b|0)){c=G;break}else{J=92;break}else if((t|0)>(b|0)){J=92;break}else{c=G;break}}e=k[K+(g*28|0)+8>>2]|0;if((o|0)==(e|0)){if(!b){J=92;break}if((k[K+4>>2]|0)<(k[K+(g*28|0)+4>>2]|0)){c=G;break}else{J=92;break}}if(!b){b=k[K+4>>2]|0;c=k[K+(g*28|0)+4>>2]|0;if((b|0)==(c|0))if((Pc(d,k[K+12>>2]|0,o,b,e,k[K+(g*28|0)+12>>2]|0)|0)==1){c=G;break}else{J=92;break}else if((b|0)<(c|0)){c=G;break}else{J=92;break}}else c=G}else if((o|0)<(n|0))c=G;else J=92;while(0);c:do if((J|0)==92){J=0;d:do if((K|0)!=(s|0)){l=K+(g*28|0)+8|0;m=K+(g*28|0)+4|0;j=K+(g*28|0)+12|0;c=s;i=G;e:while(1){b=k[c>>2]|0;do if((b|0)==(n|0)){e=k[i+-20>>2]|0;b=(n|0)==(e|0);if(b?(z=k[i+-24>>2]|0,(z|0)==(k[i+-16>>2]|0)):0){if((n|0)!=(k[l>>2]|0))break e;b=k[m>>2]|0;if((b|0)==(k[j>>2]|0))if((z|0)<(b|0))break e;else break;else if((z|0)>(b|0))break;else break e}g=k[l>>2]|0;if((n|0)==(g|0)){if(!b)break;if((k[i+-24>>2]|0)<(k[m>>2]|0))break e;else break}if(b)break e;b=k[i+-24>>2]|0;d=k[m>>2]|0;if((b|0)==(d|0))if((Pc(e,k[i+-16>>2]|0,n,k[c+4>>2]|0,g,k[j>>2]|0)|0)==1)break e;else break;else if((b|0)<(d|0))break e;else break}else if((b|0)<(n|0))break e;while(0);b=c+-28|0;if((K|0)==(b|0))break d;else{i=c;c=b}}k[M>>2]=k[K>>2];k[M+4>>2]=k[K+4>>2];k[M+8>>2]=k[K+8>>2];k[M+12>>2]=k[K+12>>2];k[M+16>>2]=k[K+16>>2];k[M+20>>2]=k[K+20>>2];k[M+24>>2]=k[K+24>>2];k[K>>2]=k[c>>2];k[K+4>>2]=k[c+4>>2];k[K+8>>2]=k[c+8>>2];k[K+12>>2]=k[c+12>>2];k[K+16>>2]=k[c+16>>2];k[K+20>>2]=k[c+20>>2];k[K+24>>2]=k[c+24>>2];k[c>>2]=k[M>>2];k[c+4>>2]=k[M+4>>2];k[c+8>>2]=k[M+8>>2];k[c+12>>2]=k[M+12>>2];k[c+16>>2]=k[M+16>>2];k[c+20>>2]=k[M+20>>2];k[c+24>>2]=k[M+24>>2];a=a+1|0;break c}while(0);e=K+28|0;a=k[G>>2]|0;do if((o|0)==(a|0)){c=k[K+8>>2]|0;a=(o|0)==(c|0);if(a?(u=k[K+4>>2]|0,(u|0)==(k[K+12>>2]|0)):0){if((o|0)!=(k[v>>2]|0)){a=e;break}a=k[D>>2]|0;if((a|0)==(k[F>>2]|0))if((u|0)<(a|0)){a=e;break}else{J=109;break}else if((u|0)>(a|0)){J=109;break}else{a=e;break}}d=k[v>>2]|0;if((o|0)==(d|0)){if(!a){J=109;break}if((k[K+4>>2]|0)<(k[D>>2]|0)){a=e;break}else{J=109;break}}if(!a){a=k[K+4>>2]|0;b=k[D>>2]|0;if((a|0)==(b|0))if((Pc(c,k[K+12>>2]|0,o,a,d,k[F>>2]|0)|0)==1){a=e;break}else{J=109;break}else if((a|0)<(b|0)){a=e;break}else{J=109;break}}else a=e}else if((o|0)<(a|0))a=e;else J=109;while(0);if((J|0)==109){J=0;if((e|0)==(G|0)){J=240;break a}h=K+8|0;i=K+4|0;j=K+12|0;g=K;f:while(1){a=k[g+28>>2]|0;do if((o|0)==(a|0)){c=k[h>>2]|0;a=(o|0)==(c|0);if(a?(w=k[i>>2]|0,(w|0)==(k[j>>2]|0)):0){if((o|0)!=(k[g+36>>2]|0))break f;a=k[g+32>>2]|0;if((a|0)==(k[g+40>>2]|0))if((w|0)<(a|0))break f;else break;else if((w|0)>(a|0))break;else break f}d=k[g+36>>2]|0;if((o|0)==(d|0)){if(!a)break;if((k[i>>2]|0)<(k[g+32>>2]|0))break f;else break}if(a)break f;a=k[i>>2]|0;b=k[g+32>>2]|0;if((a|0)==(b|0))if((Pc(c,k[j>>2]|0,o,a,d,k[g+40>>2]|0)|0)==1)break f;else break;else if((a|0)<(b|0))break f;else break}else if((o|0)<(a|0))break f;while(0);a=e+28|0;if((a|0)==(G|0)){J=240;break a}else{g=e;e=a}}k[M>>2]=k[e>>2];k[M+4>>2]=k[e+4>>2];k[M+8>>2]=k[e+8>>2];k[M+12>>2]=k[e+12>>2];k[M+16>>2]=k[e+16>>2];k[M+20>>2]=k[e+20>>2];k[M+24>>2]=k[e+24>>2];k[e>>2]=k[G>>2];k[e+4>>2]=k[G+4>>2];k[e+8>>2]=k[G+8>>2];k[e+12>>2]=k[G+12>>2];k[e+16>>2]=k[G+16>>2];k[e+20>>2]=k[G+20>>2];k[e+24>>2]=k[G+24>>2];k[G>>2]=k[M>>2];k[G+4>>2]=k[M+4>>2];k[G+8>>2]=k[M+8>>2];k[G+12>>2]=k[M+12>>2];k[G+16>>2]=k[M+16>>2];k[G+20>>2]=k[M+20>>2];k[G+24>>2]=k[M+24>>2];a=g+56|0}if((a|0)==(G|0)){J=240;break a}j=K+4|0;l=K+8|0;m=K+12|0;g=G;while(1){i=k[K>>2]|0;g:while(1){b=k[a>>2]|0;do if((i|0)==(b|0)){d=k[l>>2]|0;b=(i|0)==(d|0);if(b?(x=k[j>>2]|0,(x|0)==(k[m>>2]|0)):0){if((i|0)!=(k[a+8>>2]|0)){h=g;break g}b=k[a+4>>2]|0;if((b|0)==(k[a+12>>2]|0))if((x|0)<(b|0)){h=g;break g}else break;else if((x|0)>(b|0))break;else{h=g;break g}}e=k[a+8>>2]|0;if((i|0)==(e|0)){if(!b)break;if((k[j>>2]|0)<(k[a+4>>2]|0)){h=g;break g}else break}if(b){h=g;break g}b=k[j>>2]|0;c=k[a+4>>2]|0;if((b|0)==(c|0))if((Pc(d,k[m>>2]|0,i,b,e,k[a+12>>2]|0)|0)==1){h=g;break g}else break;else if((b|0)<(c|0)){h=g;break g}else break}else if((i|0)<(b|0)){h=g;break g}while(0);a=a+28|0}while(1){g=h+-28|0;b=k[g>>2]|0;if((i|0)!=(b|0))if((i|0)<(b|0)){h=g;continue}else break;d=k[l>>2]|0;b=(i|0)==(d|0);if(b?(y=k[j>>2]|0,(y|0)==(k[m>>2]|0)):0){if((i|0)!=(k[h+-20>>2]|0)){h=g;continue}b=k[h+-24>>2]|0;if((b|0)==(k[h+-16>>2]|0))if((y|0)<(b|0)){h=g;continue}else break;else if((y|0)>(b|0))break;else{h=g;continue}}e=k[h+-20>>2]|0;if((i|0)==(e|0)){if(!b)break;if((k[j>>2]|0)<(k[h+-24>>2]|0)){h=g;continue}else break}if(b){h=g;continue}b=k[j>>2]|0;c=k[h+-24>>2]|0;if((b|0)==(c|0))if((Pc(d,k[m>>2]|0,i,b,e,k[h+-16>>2]|0)|0)==1){h=g;continue}else break;else if((b|0)<(c|0)){h=g;continue}else break}if(a>>>0>=g>>>0){K=a;continue b};k[M>>2]=k[a>>2];k[M+4>>2]=k[a+4>>2];k[M+8>>2]=k[a+8>>2];k[M+12>>2]=k[a+12>>2];k[M+16>>2]=k[a+16>>2];k[M+20>>2]=k[a+20>>2];k[M+24>>2]=k[a+24>>2];k[a>>2]=k[g>>2];k[a+4>>2]=k[g+4>>2];k[a+8>>2]=k[g+8>>2];k[a+12>>2]=k[g+12>>2];k[a+16>>2]=k[g+16>>2];k[a+20>>2]=k[g+20>>2];k[a+24>>2]=k[g+24>>2];k[g>>2]=k[M>>2];k[g+4>>2]=k[M+4>>2];k[g+8>>2]=k[M+8>>2];k[g+12>>2]=k[M+12>>2];k[g+16>>2]=k[M+16>>2];k[g+20>>2]=k[M+20>>2];k[g+24>>2]=k[M+24>>2];a=a+28|0}}while(0);b=K+28|0;h:do if(b>>>0<c>>>0)while(1){j=k[h>>2]|0;l=h+8|0;m=h+4|0;n=h+12|0;o=b;i:while(1){b=k[o>>2]|0;do if((b|0)==(j|0)){e=k[o+8>>2]|0;b=(j|0)==(e|0);if(b?(A=k[o+4>>2]|0,(A|0)==(k[o+12>>2]|0)):0){if((j|0)!=(k[l>>2]|0))break;b=k[m>>2]|0;if((b|0)==(k[n>>2]|0))if((A|0)<(b|0))break;else break i;else if((A|0)>(b|0))break i;else break}g=k[l>>2]|0;if((j|0)==(g|0)){if(!b)break i;if((k[o+4>>2]|0)<(k[m>>2]|0))break;else break i}if(!b){b=k[o+4>>2]|0;d=k[m>>2]|0;if((b|0)==(d|0))if((Pc(e,k[o+12>>2]|0,j,b,g,k[n>>2]|0)|0)==1)break;else break i;else if((b|0)<(d|0))break;else break i}}else if((b|0)>=(j|0))break i;while(0);o=o+28|0}while(1){i=c+-28|0;b=k[i>>2]|0;if((b|0)!=(j|0))if((b|0)<(j|0))break;else{c=i;continue}e=k[c+-20>>2]|0;b=(j|0)==(e|0);if(b?(B=k[c+-24>>2]|0,(B|0)==(k[c+-16>>2]|0)):0){if((j|0)!=(k[l>>2]|0))break;b=k[m>>2]|0;if((b|0)==(k[n>>2]|0))if((B|0)<(b|0))break;else{c=i;continue}else if((B|0)>(b|0)){c=i;continue}else break}g=k[l>>2]|0;if((j|0)==(g|0)){if(!b){c=i;continue}if((k[c+-24>>2]|0)<(k[m>>2]|0))break;else{c=i;continue}}if(b)break;b=k[c+-24>>2]|0;d=k[m>>2]|0;if((b|0)==(d|0))if((Pc(e,k[c+-16>>2]|0,j,b,g,k[n>>2]|0)|0)==1)break;else{c=i;continue}else if((b|0)<(d|0))break;else{c=i;continue}}if(o>>>0>i>>>0){i=o;break h};k[M>>2]=k[o>>2];k[M+4>>2]=k[o+4>>2];k[M+8>>2]=k[o+8>>2];k[M+12>>2]=k[o+12>>2];k[M+16>>2]=k[o+16>>2];k[M+20>>2]=k[o+20>>2];k[M+24>>2]=k[o+24>>2];k[o>>2]=k[i>>2];k[o+4>>2]=k[i+4>>2];k[o+8>>2]=k[i+8>>2];k[o+12>>2]=k[i+12>>2];k[o+16>>2]=k[i+16>>2];k[o+20>>2]=k[i+20>>2];k[o+24>>2]=k[i+24>>2];k[i>>2]=k[M>>2];k[i+4>>2]=k[M+4>>2];k[i+8>>2]=k[M+8>>2];k[i+12>>2]=k[M+12>>2];k[i+16>>2]=k[M+16>>2];k[i+20>>2]=k[M+20>>2];k[i+24>>2]=k[M+24>>2];b=o+28|0;c=i;h=(h|0)==(o|0)?i:h;a=a+1|0}else i=b;while(0);j:do if((i|0)!=(h|0)){g=k[h>>2]|0;b=k[i>>2]|0;do if((g|0)==(b|0)){d=k[h+8>>2]|0;b=(g|0)==(d|0);if(b?(C=k[h+4>>2]|0,(C|0)==(k[h+12>>2]|0)):0){if((g|0)!=(k[i+8>>2]|0))break;b=k[i+4>>2]|0;if((b|0)==(k[i+12>>2]|0))if((C|0)<(b|0))break;else break j;else if((C|0)>(b|0))break j;else break}e=k[i+8>>2]|0;if((g|0)==(e|0)){if(!b)break j;if((k[h+4>>2]|0)<(k[i+4>>2]|0))break;else break j}if(!b){b=k[h+4>>2]|0;c=k[i+4>>2]|0;if((b|0)==(c|0))if((Pc(d,k[h+12>>2]|0,g,b,e,k[i+12>>2]|0)|0)==1)break;else break j;else if((b|0)<(c|0))break;else break j}}else if((g|0)>=(b|0))break j;while(0);k[M>>2]=k[i>>2];k[M+4>>2]=k[i+4>>2];k[M+8>>2]=k[i+8>>2];k[M+12>>2]=k[i+12>>2];k[M+16>>2]=k[i+16>>2];k[M+20>>2]=k[i+20>>2];k[M+24>>2]=k[i+24>>2];k[i>>2]=k[h>>2];k[i+4>>2]=k[h+4>>2];k[i+8>>2]=k[h+8>>2];k[i+12>>2]=k[h+12>>2];k[i+16>>2]=k[h+16>>2];k[i+20>>2]=k[h+20>>2];k[i+24>>2]=k[h+24>>2];k[h>>2]=k[M>>2];k[h+4>>2]=k[M+4>>2];k[h+8>>2]=k[M+8>>2];k[h+12>>2]=k[M+12>>2];k[h+16>>2]=k[M+16>>2];k[h+20>>2]=k[M+20>>2];k[h+24>>2]=k[M+24>>2];a=a+1|0}while(0);if(!a){a=od(K,i)|0;b=i+28|0;if(od(b,H)|0){J=235;break}if(a){K=b;continue}}o=i;if((o-p|0)>=(q-o|0)){J=239;break}kd(K,i);K=i+28|0}if((J|0)==235){J=0;if(a){J=240;break}else{a=K;H=i;continue}}else if((J|0)==239){J=0;kd(i+28|0,H);a=K;H=i;continue}}if((J|0)==4){e=k[G>>2]|0;a=k[K>>2]|0;do if((e|0)==(a|0)){d=k[v>>2]|0;a=(e|0)==(d|0);if(a?(E=k[D>>2]|0,(E|0)==(k[F>>2]|0)):0){if((e|0)!=(k[K+8>>2]|0))break;a=k[K+4>>2]|0;if((a|0)==(k[K+12>>2]|0)){if((E|0)<(a|0))break;r=N;return}else{if((E|0)<=(a|0))break;r=N;return}}c=k[K+8>>2]|0;if((e|0)==(c|0)){if(!a){r=N;return}if((k[D>>2]|0)<(k[K+4>>2]|0))break;r=N;return}if(!a){a=k[D>>2]|0;b=k[K+4>>2]|0;if((a|0)==(b|0)){if((Pc(d,k[F>>2]|0,e,a,c,k[K+12>>2]|0)|0)==1)break;r=N;return}else{if((a|0)<(b|0))break;r=N;return}}}else if((e|0)>=(a|0)){r=N;return}while(0);k[M>>2]=k[K>>2];k[M+4>>2]=k[K+4>>2];k[M+8>>2]=k[K+8>>2];k[M+12>>2]=k[K+12>>2];k[M+16>>2]=k[K+16>>2];k[M+20>>2]=k[K+20>>2];k[M+24>>2]=k[K+24>>2];k[K>>2]=k[G>>2];k[K+4>>2]=k[G+4>>2];k[K+8>>2]=k[G+8>>2];k[K+12>>2]=k[G+12>>2];k[K+16>>2]=k[G+16>>2];k[K+20>>2]=k[G+20>>2];k[K+24>>2]=k[G+24>>2];k[G>>2]=k[M>>2];k[G+4>>2]=k[M+4>>2];k[G+8>>2]=k[M+8>>2];k[G+12>>2]=k[M+12>>2];k[G+16>>2]=k[M+16>>2];k[G+20>>2]=k[M+20>>2];k[G+24>>2]=k[M+24>>2];r=N;return}else if((J|0)==20){ld(K,K+28|0,G)|0;r=N;return}else if((J|0)==21){md(K,K+28|0,K+56|0,G)|0;r=N;return}else if((J|0)==22){nd(K,K+28|0,K+56|0,K+84|0,G)|0;r=N;return}else if((J|0)==24){b=K+56|0;ld(K,K+28|0,b)|0;a=K+84|0;if((a|0)!=(H|0)){x=a;while(1){w=k[x>>2]|0;a=k[b>>2]|0;do if((w|0)==(a|0)){d=k[x+8>>2]|0;a=(w|0)==(d|0);if(a?(I=k[x+4>>2]|0,(I|0)==(k[x+12>>2]|0)):0){if((w|0)!=(k[b+8>>2]|0)){d=w;J=41;break}a=k[b+4>>2]|0;if((a|0)==(k[b+12>>2]|0))if((I|0)<(a|0)){d=w;J=41;break}else break;else if((I|0)>(a|0))break;else{d=w;J=41;break}}e=k[b+8>>2]|0;if((w|0)==(e|0)){if(!a)break;if((k[x+4>>2]|0)<(k[b+4>>2]|0)){d=w;J=41;break}else break}if(!a){a=k[x+4>>2]|0;c=k[b+4>>2]|0;if((a|0)==(c|0))if((Pc(d,k[x+12>>2]|0,w,a,e,k[b+12>>2]|0)|0)==1){J=41;break}else break;else if((a|0)<(c|0)){J=41;break}else break}else{d=w;J=41}}else if((w|0)<(a|0)){d=k[x+8>>2]|0;J=41}while(0);if((J|0)==41){J=0;u=k[x+4>>2]|0;v=k[x+12>>2]|0;G=x+16|0;k[M>>2]=k[G>>2];k[M+4>>2]=k[G+4>>2];k[M+8>>2]=k[G+8>>2];k[x>>2]=k[b>>2];k[x+4>>2]=k[b+4>>2];k[x+8>>2]=k[b+8>>2];k[x+12>>2]=k[b+12>>2];k[x+16>>2]=k[b+16>>2];k[x+20>>2]=k[b+20>>2];k[x+24>>2]=k[b+24>>2];k:do if((b|0)==(K|0))a=K;else{t=(w|0)==(d|0);j=((w|0)<0)<<31>>31;n=be(d|0,((d|0)<0)<<31>>31|0,w|0,j|0)|0;o=L;l=((u|0)<0)<<31>>31;q=be(v|0,((v|0)<0)<<31>>31|0,u|0,l|0)|0;s=L;m=(o|0)<0;p=be(0,0,n|0,o|0)|0;n=m?p:n;o=m?L:o;p=(s|0)<0;G=be(0,0,q|0,s|0)|0;q=p?G:q;s=p?L:s;if(t&(u|0)==(v|0))while(1){a=b;b=b+-28|0;c=k[b>>2]|0;do if((w|0)==(c|0)){if((w|0)==(k[a+-20>>2]|0)){c=k[a+-24>>2]|0;if((c|0)==(k[a+-16>>2]|0))if((u|0)<(c|0))break;else break k;else if((u|0)>(c|0))break k;else break}}else if((w|0)>=(c|0))break k;while(0);k[a>>2]=k[b>>2];k[a+4>>2]=k[b+4>>2];k[a+8>>2]=k[b+8>>2];k[a+12>>2]=k[b+12>>2];k[a+16>>2]=k[b+16>>2];k[a+20>>2]=k[b+20>>2];k[a+24>>2]=k[b+24>>2];if((b|0)==(K|0)){a=K;break k}}while(1){a=b;b=b+-28|0;c=k[b>>2]|0;do if((w|0)==(c|0)){c=k[a+-20>>2]|0;if((w|0)==(c|0)){if(!t)break k;if((u|0)<(k[a+-24>>2]|0))break;else break k}if(!t){e=k[a+-24>>2]|0;if((u|0)!=(e|0))if((u|0)<(e|0))break;else break k;h=be(w|0,j|0,c|0,((c|0)<0)<<31>>31|0)|0;g=L;e=k[a+-16>>2]|0;e=be(u|0,l|0,e|0,((e|0)<0)<<31>>31|0)|0;c=L;i=(g|0)<0;F=be(0,0,h|0,g|0)|0;g=i?L:g;G=(c|0)<0;E=be(0,0,e|0,c|0)|0;c=ne((G?E:e)|0,(G?L:c)|0,n|0,o|0)|0;e=L;g=ne((i?F:h)|0,g|0,q|0,s|0)|0;h=L;i=p^i;do if(m^G){if(!i){G=ge(c|0,e|0,g|0,h|0)|0;f=-(+(G>>>0)+4294967296.0*+(L>>>0));break}if(e>>>0>h>>>0|(e|0)==(h|0)&c>>>0>g>>>0){G=be(c|0,e|0,g|0,h|0)|0;f=-(+(G>>>0)+4294967296.0*+(L>>>0));break}else{G=be(g|0,h|0,c|0,e|0)|0;f=+(G>>>0)+4294967296.0*+(L>>>0);break}}else{if(i){G=ge(c|0,e|0,g|0,h|0)|0;f=+(G>>>0)+4294967296.0*+(L>>>0);break}if(e>>>0<h>>>0|(e|0)==(h|0)&c>>>0<g>>>0){G=be(g|0,h|0,c|0,e|0)|0;f=-(+(G>>>0)+4294967296.0*+(L>>>0));break}else{G=be(c|0,e|0,g|0,h|0)|0;f=+(G>>>0)+4294967296.0*+(L>>>0);break}}while(0);if(!(f!=0.0&!(f<0.0)))break k}}else if((w|0)>=(c|0))break k;while(0);k[a>>2]=k[b>>2];k[a+4>>2]=k[b+4>>2];k[a+8>>2]=k[b+8>>2];k[a+12>>2]=k[b+12>>2];k[a+16>>2]=k[b+16>>2];k[a+20>>2]=k[b+20>>2];k[a+24>>2]=k[b+24>>2];if((b|0)==(K|0)){a=K;break}}}while(0);k[a>>2]=w;k[a+4>>2]=u;k[a+8>>2]=d;k[a+12>>2]=v;G=a+16|0;k[G>>2]=k[M>>2];k[G+4>>2]=k[M+4>>2];k[G+8>>2]=k[M+8>>2]}a=x+28|0;if((a|0)==(H|0))break;else{b=x;x=a}}}r=N;return}else if((J|0)==240){r=N;return}}function ld(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,l=0,m=0,n=0,o=0;o=r;r=r+32|0;n=o;j=k[b>>2]|0;d=k[a>>2]|0;do if((j|0)==(d|0)){g=k[b+8>>2]|0;d=(j|0)==(g|0);if(d?(e=k[b+4>>2]|0,(e|0)==(k[b+12>>2]|0)):0){if((j|0)!=(k[a+8>>2]|0)){h=1;break}d=k[a+4>>2]|0;if((d|0)==(k[a+12>>2]|0)){h=(e|0)<(d|0);break}else{h=(e|0)<=(d|0);break}}f=k[a+8>>2]|0;if((j|0)==(f|0)){if(!d){h=0;break}h=(k[b+4>>2]|0)<(k[a+4>>2]|0);break}if(!d){d=k[b+4>>2]|0;e=k[a+4>>2]|0;if((d|0)==(e|0)){h=(Pc(g,k[b+12>>2]|0,j,d,f,k[a+12>>2]|0)|0)==1;break}else{h=(d|0)<(e|0);break}}else h=1}else h=(j|0)<(d|0);while(0);d=k[c>>2]|0;do if((d|0)==(j|0)){g=k[c+8>>2]|0;d=(j|0)==(g|0);if(d?(i=k[c+4>>2]|0,(i|0)==(k[c+12>>2]|0)):0){if((j|0)!=(k[b+8>>2]|0)){d=1;break}d=k[b+4>>2]|0;if((d|0)==(k[b+12>>2]|0)){d=(i|0)<(d|0);break}else{d=(i|0)<=(d|0);break}}f=k[b+8>>2]|0;if((j|0)==(f|0)){if(!d){d=0;break}d=(k[c+4>>2]|0)<(k[b+4>>2]|0);break}if(!d){d=k[c+4>>2]|0;e=k[b+4>>2]|0;if((d|0)==(e|0)){d=(Pc(g,k[c+12>>2]|0,j,d,f,k[b+12>>2]|0)|0)==1;break}else{d=(d|0)<(e|0);break}}else d=1}else d=(d|0)<(j|0);while(0);if(!h){if(!d){b=0;r=o;return b|0};k[n>>2]=k[b>>2];k[n+4>>2]=k[b+4>>2];k[n+8>>2]=k[b+8>>2];k[n+12>>2]=k[b+12>>2];k[n+16>>2]=k[b+16>>2];k[n+20>>2]=k[b+20>>2];k[n+24>>2]=k[b+24>>2];k[b>>2]=k[c>>2];k[b+4>>2]=k[c+4>>2];k[b+8>>2]=k[c+8>>2];k[b+12>>2]=k[c+12>>2];k[b+16>>2]=k[c+16>>2];k[b+20>>2]=k[c+20>>2];k[b+24>>2]=k[c+24>>2];k[c>>2]=k[n>>2];k[c+4>>2]=k[n+4>>2];k[c+8>>2]=k[n+8>>2];k[c+12>>2]=k[n+12>>2];k[c+16>>2]=k[n+16>>2];k[c+20>>2]=k[n+20>>2];k[c+24>>2]=k[n+24>>2];h=k[b>>2]|0;d=k[a>>2]|0;do if((h|0)==(d|0)){g=k[b+8>>2]|0;d=(h|0)==(g|0);if(d?(m=k[b+4>>2]|0,(m|0)==(k[b+12>>2]|0)):0){if((h|0)!=(k[a+8>>2]|0))break;d=k[a+4>>2]|0;if((d|0)==(k[a+12>>2]|0)){if((m|0)<(d|0))break;else d=1;r=o;return d|0}else{if((m|0)>(d|0))d=1;else break;r=o;return d|0}}f=k[a+8>>2]|0;if((h|0)==(f|0)){if(!d){b=1;r=o;return b|0}if((k[b+4>>2]|0)<(k[a+4>>2]|0))break;else d=1;r=o;return d|0}if(!d){d=k[b+4>>2]|0;e=k[a+4>>2]|0;if((d|0)==(e|0)){if((Pc(g,k[b+12>>2]|0,h,d,f,k[a+12>>2]|0)|0)==1)break;else d=1;r=o;return d|0}else{if((d|0)<(e|0))break;else d=1;r=o;return d|0}}}else if((h|0)>=(d|0)){b=1;r=o;return b|0}while(0);k[n>>2]=k[a>>2];k[n+4>>2]=k[a+4>>2];k[n+8>>2]=k[a+8>>2];k[n+12>>2]=k[a+12>>2];k[n+16>>2]=k[a+16>>2];k[n+20>>2]=k[a+20>>2];k[n+24>>2]=k[a+24>>2];k[a>>2]=k[b>>2];k[a+4>>2]=k[b+4>>2];k[a+8>>2]=k[b+8>>2];k[a+12>>2]=k[b+12>>2];k[a+16>>2]=k[b+16>>2];k[a+20>>2]=k[b+20>>2];k[a+24>>2]=k[b+24>>2];k[b>>2]=k[n>>2];k[b+4>>2]=k[n+4>>2];k[b+8>>2]=k[n+8>>2];k[b+12>>2]=k[n+12>>2];k[b+16>>2]=k[n+16>>2];k[b+20>>2]=k[n+20>>2];k[b+24>>2]=k[n+24>>2];b=2;r=o;return b|0}if(d){k[n>>2]=k[a>>2];k[n+4>>2]=k[a+4>>2];k[n+8>>2]=k[a+8>>2];k[n+12>>2]=k[a+12>>2];k[n+16>>2]=k[a+16>>2];k[n+20>>2]=k[a+20>>2];k[n+24>>2]=k[a+24>>2];k[a>>2]=k[c>>2];k[a+4>>2]=k[c+4>>2];k[a+8>>2]=k[c+8>>2];k[a+12>>2]=k[c+12>>2];k[a+16>>2]=k[c+16>>2];k[a+20>>2]=k[c+20>>2];k[a+24>>2]=k[c+24>>2];k[c>>2]=k[n>>2];k[c+4>>2]=k[n+4>>2];k[c+8>>2]=k[n+8>>2];k[c+12>>2]=k[n+12>>2];k[c+16>>2]=k[n+16>>2];k[c+20>>2]=k[n+20>>2];k[c+24>>2]=k[n+24>>2];b=1;r=o;return b|0};k[n>>2]=k[a>>2];k[n+4>>2]=k[a+4>>2];k[n+8>>2]=k[a+8>>2];k[n+12>>2]=k[a+12>>2];k[n+16>>2]=k[a+16>>2];k[n+20>>2]=k[a+20>>2];k[n+24>>2]=k[a+24>>2];k[a>>2]=k[b>>2];k[a+4>>2]=k[b+4>>2];k[a+8>>2]=k[b+8>>2];k[a+12>>2]=k[b+12>>2];k[a+16>>2]=k[b+16>>2];k[a+20>>2]=k[b+20>>2];k[a+24>>2]=k[b+24>>2];k[b>>2]=k[n>>2];k[b+4>>2]=k[n+4>>2];k[b+8>>2]=k[n+8>>2];k[b+12>>2]=k[n+12>>2];k[b+16>>2]=k[n+16>>2];k[b+20>>2]=k[n+20>>2];k[b+24>>2]=k[n+24>>2];h=k[c>>2]|0;d=k[b>>2]|0;do if((h|0)==(d|0)){g=k[c+8>>2]|0;d=(h|0)==(g|0);if(d?(l=k[c+4>>2]|0,(l|0)==(k[c+12>>2]|0)):0){if((h|0)!=(k[b+8>>2]|0))break;d=k[b+4>>2]|0;if((d|0)==(k[b+12>>2]|0)){if((l|0)<(d|0))break;else d=1;r=o;return d|0}else{if((l|0)>(d|0))d=1;else break;r=o;return d|0}}f=k[b+8>>2]|0;if((h|0)==(f|0)){if(!d){b=1;r=o;return b|0}if((k[c+4>>2]|0)<(k[b+4>>2]|0))break;else d=1;r=o;return d|0}if(!d){d=k[c+4>>2]|0;e=k[b+4>>2]|0;if((d|0)==(e|0)){if((Pc(g,k[c+12>>2]|0,h,d,f,k[b+12>>2]|0)|0)==1)break;else d=1;r=o;return d|0}else{if((d|0)<(e|0))break;else d=1;r=o;return d|0}}}else if((h|0)>=(d|0)){b=1;r=o;return b|0}while(0);k[n>>2]=k[b>>2];k[n+4>>2]=k[b+4>>2];k[n+8>>2]=k[b+8>>2];k[n+12>>2]=k[b+12>>2];k[n+16>>2]=k[b+16>>2];k[n+20>>2]=k[b+20>>2];k[n+24>>2]=k[b+24>>2];k[b>>2]=k[c>>2];k[b+4>>2]=k[c+4>>2];k[b+8>>2]=k[c+8>>2];k[b+12>>2]=k[c+12>>2];k[b+16>>2]=k[c+16>>2];k[b+20>>2]=k[c+20>>2];k[b+24>>2]=k[c+24>>2];k[c>>2]=k[n>>2];k[c+4>>2]=k[n+4>>2];k[c+8>>2]=k[n+8>>2];k[c+12>>2]=k[n+12>>2];k[c+16>>2]=k[n+16>>2];k[c+20>>2]=k[n+20>>2];k[c+24>>2]=k[n+24>>2];b=2;r=o;return b|0}function md(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,l=0,m=0,n=0,o=0;o=r;r=r+32|0;n=o;e=ld(a,b,c)|0;j=k[d>>2]|0;f=k[c>>2]|0;do if((j|0)==(f|0)){i=k[d+8>>2]|0;f=(j|0)==(i|0);if(f?(g=k[d+4>>2]|0,(g|0)==(k[d+12>>2]|0)):0){if((j|0)!=(k[c+8>>2]|0))break;f=k[c+4>>2]|0;if((f|0)==(k[c+12>>2]|0)){if((g|0)<(f|0))break;r=o;return e|0}else{if((g|0)<=(f|0))break;r=o;return e|0}}h=k[c+8>>2]|0;if((j|0)==(h|0)){if(!f){b=e;r=o;return b|0}if((k[d+4>>2]|0)<(k[c+4>>2]|0))break;r=o;return e|0}if(!f){f=k[d+4>>2]|0;g=k[c+4>>2]|0;if((f|0)==(g|0)){if((Pc(i,k[d+12>>2]|0,j,f,h,k[c+12>>2]|0)|0)==1)break;r=o;return e|0}else{if((f|0)<(g|0))break;r=o;return e|0}}}else if((j|0)>=(f|0)){b=e;r=o;return b|0}while(0);k[n>>2]=k[c>>2];k[n+4>>2]=k[c+4>>2];k[n+8>>2]=k[c+8>>2];k[n+12>>2]=k[c+12>>2];k[n+16>>2]=k[c+16>>2];k[n+20>>2]=k[c+20>>2];k[n+24>>2]=k[c+24>>2];k[c>>2]=k[d>>2];k[c+4>>2]=k[d+4>>2];k[c+8>>2]=k[d+8>>2];k[c+12>>2]=k[d+12>>2];k[c+16>>2]=k[d+16>>2];k[c+20>>2]=k[d+20>>2];k[c+24>>2]=k[d+24>>2];k[d>>2]=k[n>>2];k[d+4>>2]=k[n+4>>2];k[d+8>>2]=k[n+8>>2];k[d+12>>2]=k[n+12>>2];k[d+16>>2]=k[n+16>>2];k[d+20>>2]=k[n+20>>2];k[d+24>>2]=k[n+24>>2];d=e+1|0;j=k[c>>2]|0;f=k[b>>2]|0;do if((j|0)==(f|0)){i=k[c+8>>2]|0;f=(j|0)==(i|0);if(f?(l=k[c+4>>2]|0,(l|0)==(k[c+12>>2]|0)):0){if((j|0)!=(k[b+8>>2]|0))break;f=k[b+4>>2]|0;if((f|0)==(k[b+12>>2]|0)){if((l|0)<(f|0))break;else e=d;r=o;return e|0}else{if((l|0)>(f|0))e=d;else break;r=o;return e|0}}h=k[b+8>>2]|0;if((j|0)==(h|0)){if(!f){b=d;r=o;return b|0}if((k[c+4>>2]|0)<(k[b+4>>2]|0))break;else e=d;r=o;return e|0}if(!f){f=k[c+4>>2]|0;g=k[b+4>>2]|0;if((f|0)==(g|0)){if((Pc(i,k[c+12>>2]|0,j,f,h,k[b+12>>2]|0)|0)==1)break;else e=d;r=o;return e|0}else{if((f|0)<(g|0))break;else e=d;r=o;return e|0}}}else if((j|0)>=(f|0)){b=d;r=o;return b|0}while(0);k[n>>2]=k[b>>2];k[n+4>>2]=k[b+4>>2];k[n+8>>2]=k[b+8>>2];k[n+12>>2]=k[b+12>>2];k[n+16>>2]=k[b+16>>2];k[n+20>>2]=k[b+20>>2];k[n+24>>2]=k[b+24>>2];k[b>>2]=k[c>>2];k[b+4>>2]=k[c+4>>2];k[b+8>>2]=k[c+8>>2];k[b+12>>2]=k[c+12>>2];k[b+16>>2]=k[c+16>>2];k[b+20>>2]=k[c+20>>2];k[b+24>>2]=k[c+24>>2];k[c>>2]=k[n>>2];k[c+4>>2]=k[n+4>>2];k[c+8>>2]=k[n+8>>2];k[c+12>>2]=k[n+12>>2];k[c+16>>2]=k[n+16>>2];k[c+20>>2]=k[n+20>>2];k[c+24>>2]=k[n+24>>2];d=e+2|0;j=k[b>>2]|0;f=k[a>>2]|0;do if((j|0)==(f|0)){i=k[b+8>>2]|0;f=(j|0)==(i|0);if(f?(m=k[b+4>>2]|0,(m|0)==(k[b+12>>2]|0)):0){if((j|0)!=(k[a+8>>2]|0))break;f=k[a+4>>2]|0;if((f|0)==(k[a+12>>2]|0)){if((m|0)<(f|0))break;else e=d;r=o;return e|0}else{if((m|0)>(f|0))e=d;else break;r=o;return e|0}}h=k[a+8>>2]|0;if((j|0)==(h|0)){if(!f){b=d;r=o;return b|0}if((k[b+4>>2]|0)<(k[a+4>>2]|0))break;else e=d;r=o;return e|0}if(!f){f=k[b+4>>2]|0;g=k[a+4>>2]|0;if((f|0)==(g|0)){if((Pc(i,k[b+12>>2]|0,j,f,h,k[a+12>>2]|0)|0)==1)break;else e=d;r=o;return e|0}else{if((f|0)<(g|0))break;else e=d;r=o;return e|0}}}else if((j|0)>=(f|0)){b=d;r=o;return b|0}while(0);k[n>>2]=k[a>>2];k[n+4>>2]=k[a+4>>2];k[n+8>>2]=k[a+8>>2];k[n+12>>2]=k[a+12>>2];k[n+16>>2]=k[a+16>>2];k[n+20>>2]=k[a+20>>2];k[n+24>>2]=k[a+24>>2];k[a>>2]=k[b>>2];k[a+4>>2]=k[b+4>>2];k[a+8>>2]=k[b+8>>2];k[a+12>>2]=k[b+12>>2];k[a+16>>2]=k[b+16>>2];k[a+20>>2]=k[b+20>>2];k[a+24>>2]=k[b+24>>2];k[b>>2]=k[n>>2];k[b+4>>2]=k[n+4>>2];k[b+8>>2]=k[n+8>>2];k[b+12>>2]=k[n+12>>2];k[b+16>>2]=k[n+16>>2];k[b+20>>2]=k[n+20>>2];k[b+24>>2]=k[n+24>>2];b=e+3|0;r=o;return b|0}function nd(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0;q=r;r=r+32|0;p=q;f=md(a,b,c,d)|0;l=k[e>>2]|0;g=k[d>>2]|0;do if((l|0)==(g|0)){j=k[e+8>>2]|0;g=(l|0)==(j|0);if(g?(h=k[e+4>>2]|0,(h|0)==(k[e+12>>2]|0)):0){if((l|0)!=(k[d+8>>2]|0))break;g=k[d+4>>2]|0;if((g|0)==(k[d+12>>2]|0)){if((h|0)<(g|0))break;r=q;return f|0}else{if((h|0)<=(g|0))break;r=q;return f|0}}i=k[d+8>>2]|0;if((l|0)==(i|0)){if(!g){b=f;r=q;return b|0}if((k[e+4>>2]|0)<(k[d+4>>2]|0))break;r=q;return f|0}if(!g){g=k[e+4>>2]|0;h=k[d+4>>2]|0;if((g|0)==(h|0)){if((Pc(j,k[e+12>>2]|0,l,g,i,k[d+12>>2]|0)|0)==1)break;r=q;return f|0}else{if((g|0)<(h|0))break;r=q;return f|0}}}else if((l|0)>=(g|0)){b=f;r=q;return b|0}while(0);k[p>>2]=k[d>>2];k[p+4>>2]=k[d+4>>2];k[p+8>>2]=k[d+8>>2];k[p+12>>2]=k[d+12>>2];k[p+16>>2]=k[d+16>>2];k[p+20>>2]=k[d+20>>2];k[p+24>>2]=k[d+24>>2];k[d>>2]=k[e>>2];k[d+4>>2]=k[e+4>>2];k[d+8>>2]=k[e+8>>2];k[d+12>>2]=k[e+12>>2];k[d+16>>2]=k[e+16>>2];k[d+20>>2]=k[e+20>>2];k[d+24>>2]=k[e+24>>2];k[e>>2]=k[p>>2];k[e+4>>2]=k[p+4>>2];k[e+8>>2]=k[p+8>>2];k[e+12>>2]=k[p+12>>2];k[e+16>>2]=k[p+16>>2];k[e+20>>2]=k[p+20>>2];k[e+24>>2]=k[p+24>>2];e=f+1|0;l=k[d>>2]|0;g=k[c>>2]|0;do if((l|0)==(g|0)){j=k[d+8>>2]|0;g=(l|0)==(j|0);if(g?(m=k[d+4>>2]|0,(m|0)==(k[d+12>>2]|0)):0){if((l|0)!=(k[c+8>>2]|0))break;g=k[c+4>>2]|0;if((g|0)==(k[c+12>>2]|0)){if((m|0)<(g|0))break;else f=e;r=q;return f|0}else{if((m|0)>(g|0))f=e;else break;r=q;return f|0}}i=k[c+8>>2]|0;if((l|0)==(i|0)){if(!g){b=e;r=q;return b|0}if((k[d+4>>2]|0)<(k[c+4>>2]|0))break;else f=e;r=q;return f|0}if(!g){g=k[d+4>>2]|0;h=k[c+4>>2]|0;if((g|0)==(h|0)){if((Pc(j,k[d+12>>2]|0,l,g,i,k[c+12>>2]|0)|0)==1)break;else f=e;r=q;return f|0}else{if((g|0)<(h|0))break;else f=e;r=q;return f|0}}}else if((l|0)>=(g|0)){b=e;r=q;return b|0}while(0);k[p>>2]=k[c>>2];k[p+4>>2]=k[c+4>>2];k[p+8>>2]=k[c+8>>2];k[p+12>>2]=k[c+12>>2];k[p+16>>2]=k[c+16>>2];k[p+20>>2]=k[c+20>>2];k[p+24>>2]=k[c+24>>2];k[c>>2]=k[d>>2];k[c+4>>2]=k[d+4>>2];k[c+8>>2]=k[d+8>>2];k[c+12>>2]=k[d+12>>2];k[c+16>>2]=k[d+16>>2];k[c+20>>2]=k[d+20>>2];k[c+24>>2]=k[d+24>>2];k[d>>2]=k[p>>2];k[d+4>>2]=k[p+4>>2];k[d+8>>2]=k[p+8>>2];k[d+12>>2]=k[p+12>>2];k[d+16>>2]=k[p+16>>2];k[d+20>>2]=k[p+20>>2];k[d+24>>2]=k[p+24>>2];e=f+2|0;l=k[c>>2]|0;g=k[b>>2]|0;do if((l|0)==(g|0)){j=k[c+8>>2]|0;g=(l|0)==(j|0);if(g?(n=k[c+4>>2]|0,(n|0)==(k[c+12>>2]|0)):0){if((l|0)!=(k[b+8>>2]|0))break;g=k[b+4>>2]|0;if((g|0)==(k[b+12>>2]|0)){if((n|0)<(g|0))break;else f=e;r=q;return f|0}else{if((n|0)>(g|0))f=e;else break;r=q;return f|0}}i=k[b+8>>2]|0;if((l|0)==(i|0)){if(!g){b=e;r=q;return b|0}if((k[c+4>>2]|0)<(k[b+4>>2]|0))break;else f=e;r=q;return f|0}if(!g){g=k[c+4>>2]|0;h=k[b+4>>2]|0;if((g|0)==(h|0)){if((Pc(j,k[c+12>>2]|0,l,g,i,k[b+12>>2]|0)|0)==1)break;else f=e;r=q;return f|0}else{if((g|0)<(h|0))break;else f=e;r=q;return f|0}}}else if((l|0)>=(g|0)){b=e;r=q;return b|0}while(0);k[p>>2]=k[b>>2];k[p+4>>2]=k[b+4>>2];k[p+8>>2]=k[b+8>>2];k[p+12>>2]=k[b+12>>2];k[p+16>>2]=k[b+16>>2];k[p+20>>2]=k[b+20>>2];k[p+24>>2]=k[b+24>>2];k[b>>2]=k[c>>2];k[b+4>>2]=k[c+4>>2];k[b+8>>2]=k[c+8>>2];k[b+12>>2]=k[c+12>>2];k[b+16>>2]=k[c+16>>2];k[b+20>>2]=k[c+20>>2];k[b+24>>2]=k[c+24>>2];k[c>>2]=k[p>>2];k[c+4>>2]=k[p+4>>2];k[c+8>>2]=k[p+8>>2];k[c+12>>2]=k[p+12>>2];k[c+16>>2]=k[p+16>>2];k[c+20>>2]=k[p+20>>2];k[c+24>>2]=k[p+24>>2];e=f+3|0;l=k[b>>2]|0;g=k[a>>2]|0;do if((l|0)==(g|0)){j=k[b+8>>2]|0;g=(l|0)==(j|0);if(g?(o=k[b+4>>2]|0,(o|0)==(k[b+12>>2]|0)):0){if((l|0)!=(k[a+8>>2]|0))break;g=k[a+4>>2]|0;if((g|0)==(k[a+12>>2]|0)){if((o|0)<(g|0))break;else f=e;r=q;return f|0}else{if((o|0)>(g|0))f=e;else break;r=q;return f|0}}i=k[a+8>>2]|0;if((l|0)==(i|0)){if(!g){b=e;r=q;return b|0}if((k[b+4>>2]|0)<(k[a+4>>2]|0))break;else f=e;r=q;return f|0}if(!g){g=k[b+4>>2]|0;h=k[a+4>>2]|0;if((g|0)==(h|0)){if((Pc(j,k[b+12>>2]|0,l,g,i,k[a+12>>2]|0)|0)==1)break;else f=e;r=q;return f|0}else{if((g|0)<(h|0))break;else f=e;r=q;return f|0}}}else if((l|0)>=(g|0)){b=e;r=q;return b|0}while(0);k[p>>2]=k[a>>2];k[p+4>>2]=k[a+4>>2];k[p+8>>2]=k[a+8>>2];k[p+12>>2]=k[a+12>>2];k[p+16>>2]=k[a+16>>2];k[p+20>>2]=k[a+20>>2];k[p+24>>2]=k[a+24>>2];k[a>>2]=k[b>>2];k[a+4>>2]=k[b+4>>2];k[a+8>>2]=k[b+8>>2];k[a+12>>2]=k[b+12>>2];k[a+16>>2]=k[b+16>>2];k[a+20>>2]=k[b+20>>2];k[a+24>>2]=k[b+24>>2];k[b>>2]=k[p>>2];k[b+4>>2]=k[p+4>>2];k[b+8>>2]=k[p+8>>2];k[b+12>>2]=k[p+12>>2];k[b+16>>2]=k[p+16>>2];k[b+20>>2]=k[p+20>>2];k[b+24>>2]=k[p+24>>2];b=f+4|0;r=q;return b|0}function od(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0.0,l=0,m=0,n=0,o=0,p=0,q=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0;F=r;r=r+48|0;i=F+12|0;D=F;switch((b-a|0)/28|0|0){case 2:{h=b+-28|0;g=k[h>>2]|0;c=k[a>>2]|0;do if((g|0)==(c|0)){f=k[b+-20>>2]|0;c=(g|0)==(f|0);if(c?(d=k[b+-24>>2]|0,(d|0)==(k[b+-16>>2]|0)):0){if((g|0)!=(k[a+8>>2]|0))break;c=k[a+4>>2]|0;if((c|0)==(k[a+12>>2]|0)){if((d|0)<(c|0))break;else c=1;r=F;return c|0}else{if((d|0)>(c|0))c=1;else break;r=F;return c|0}}e=k[a+8>>2]|0;if((g|0)==(e|0)){if(!c){a=1;r=F;return a|0}if((k[b+-24>>2]|0)<(k[a+4>>2]|0))break;else c=1;r=F;return c|0}if(!c){c=k[b+-24>>2]|0;d=k[a+4>>2]|0;if((c|0)==(d|0)){if((Pc(f,k[b+-16>>2]|0,g,c,e,k[a+12>>2]|0)|0)==1)break;else c=1;r=F;return c|0}else{if((c|0)<(d|0))break;else c=1;r=F;return c|0}}}else if((g|0)>=(c|0)){a=1;r=F;return a|0}while(0);k[i>>2]=k[a>>2];k[i+4>>2]=k[a+4>>2];k[i+8>>2]=k[a+8>>2];k[i+12>>2]=k[a+12>>2];k[i+16>>2]=k[a+16>>2];k[i+20>>2]=k[a+20>>2];k[i+24>>2]=k[a+24>>2];k[a>>2]=k[h>>2];k[a+4>>2]=k[h+4>>2];k[a+8>>2]=k[h+8>>2];k[a+12>>2]=k[h+12>>2];k[a+16>>2]=k[h+16>>2];k[a+20>>2]=k[h+20>>2];k[a+24>>2]=k[h+24>>2];k[h>>2]=k[i>>2];k[h+4>>2]=k[i+4>>2];k[h+8>>2]=k[i+8>>2];k[h+12>>2]=k[i+12>>2];k[h+16>>2]=k[i+16>>2];k[h+20>>2]=k[i+20>>2];k[h+24>>2]=k[i+24>>2];a=1;r=F;return a|0}case 3:{ld(a,a+28|0,b+-28|0)|0;a=1;r=F;return a|0}case 4:{md(a,a+28|0,a+56|0,b+-28|0)|0;a=1;r=F;return a|0}case 5:{nd(a,a+28|0,a+56|0,a+84|0,b+-28|0)|0;a=1;r=F;return a|0}case 1:case 0:{a=1;r=F;return a|0}default:{e=a+56|0;ld(a,a+28|0,e)|0;d=a+84|0;if((d|0)==(b|0)){a=1;r=F;return a|0}c=0;while(1){B=k[d>>2]|0;f=k[e>>2]|0;do if((B|0)==(f|0)){h=k[d+8>>2]|0;f=(B|0)==(h|0);if(f?(C=k[d+4>>2]|0,(C|0)==(k[d+12>>2]|0)):0){if((B|0)!=(k[e+8>>2]|0)){h=B;E=39;break}f=k[e+4>>2]|0;if((f|0)==(k[e+12>>2]|0))if((C|0)<(f|0)){h=B;E=39;break}else break;else if((C|0)>(f|0))break;else{h=B;E=39;break}}i=k[e+8>>2]|0;if((B|0)==(i|0)){if(!f)break;if((k[d+4>>2]|0)<(k[e+4>>2]|0)){h=B;E=39;break}else break}if(!f){f=k[d+4>>2]|0;g=k[e+4>>2]|0;if((f|0)==(g|0))if((Pc(h,k[d+12>>2]|0,B,f,i,k[e+12>>2]|0)|0)==1){E=39;break}else break;else if((f|0)<(g|0)){E=39;break}else break}else{h=B;E=39}}else if((B|0)<(f|0)){h=k[d+8>>2]|0;E=39}while(0);if((E|0)==39){E=0;z=k[d+4>>2]|0;A=k[d+12>>2]|0;y=d+16|0;k[D>>2]=k[y>>2];k[D+4>>2]=k[y+4>>2];k[D+8>>2]=k[y+8>>2];k[d>>2]=k[e>>2];k[d+4>>2]=k[e+4>>2];k[d+8>>2]=k[e+8>>2];k[d+12>>2]=k[e+12>>2];k[d+16>>2]=k[e+16>>2];k[d+20>>2]=k[e+20>>2];k[d+24>>2]=k[e+24>>2];a:do if((e|0)==(a|0))e=a;else{o=(B|0)==(h|0);y=o&(z|0)==(A|0);p=((B|0)<0)<<31>>31;t=be(h|0,((h|0)<0)<<31>>31|0,B|0,p|0)|0;u=L;q=((z|0)<0)<<31>>31;w=be(A|0,((A|0)<0)<<31>>31|0,z|0,q|0)|0;x=L;s=(u|0)<0;v=be(0,0,t|0,u|0)|0;t=s?v:t;u=s?L:u;v=(x|0)<0;n=be(0,0,w|0,x|0)|0;w=v?n:w;x=v?L:x;while(1){n=e;e=e+-28|0;f=k[e>>2]|0;do if((B|0)==(f|0)){g=k[n+-20>>2]|0;f=(B|0)==(g|0);if(y){if(!f)break;f=k[n+-24>>2]|0;if((f|0)==(k[n+-16>>2]|0))if((z|0)<(f|0))break;else{e=n;break a}else if((z|0)>(f|0)){e=n;break a}else break}if(f){if(!o){e=n;break a}if((z|0)<(k[n+-24>>2]|0))break;else{e=n;break a}}if(!o){f=k[n+-24>>2]|0;if((z|0)!=(f|0))if((z|0)<(f|0))break;else{e=n;break a}l=be(B|0,p|0,g|0,((g|0)<0)<<31>>31|0)|0;i=L;g=k[n+-16>>2]|0;g=be(z|0,q|0,g|0,((g|0)<0)<<31>>31|0)|0;f=L;m=(i|0)<0;H=be(0,0,l|0,i|0)|0;i=m?L:i;G=(f|0)<0;I=be(0,0,g|0,f|0)|0;f=ne((G?I:g)|0,(G?L:f)|0,t|0,u|0)|0;g=L;i=ne((m?H:l)|0,i|0,w|0,x|0)|0;l=L;m=v^m;do if(s^G){if(!m){I=ge(f|0,g|0,i|0,l|0)|0;j=-(+(I>>>0)+4294967296.0*+(L>>>0));break}if(g>>>0>l>>>0|(g|0)==(l|0)&f>>>0>i>>>0){I=be(f|0,g|0,i|0,l|0)|0;j=-(+(I>>>0)+4294967296.0*+(L>>>0));break}else{I=be(i|0,l|0,f|0,g|0)|0;j=+(I>>>0)+4294967296.0*+(L>>>0);break}}else{if(m){I=ge(f|0,g|0,i|0,l|0)|0;j=+(I>>>0)+4294967296.0*+(L>>>0);break}if(g>>>0<l>>>0|(g|0)==(l|0)&f>>>0<i>>>0){I=be(i|0,l|0,f|0,g|0)|0;j=-(+(I>>>0)+4294967296.0*+(L>>>0));break}else{I=be(f|0,g|0,i|0,l|0)|0;j=+(I>>>0)+4294967296.0*+(L>>>0);break}}while(0);if(!(j!=0.0&!(j<0.0))){e=n;break a}}}else if((B|0)>=(f|0)){e=n;break a}while(0);k[n>>2]=k[e>>2];k[n+4>>2]=k[e+4>>2];k[n+8>>2]=k[e+8>>2];k[n+12>>2]=k[e+12>>2];k[n+16>>2]=k[e+16>>2];k[n+20>>2]=k[e+20>>2];k[n+24>>2]=k[e+24>>2];if((e|0)==(a|0)){e=a;break}}}while(0);k[e>>2]=B;k[e+4>>2]=z;k[e+8>>2]=h;k[e+12>>2]=A;I=e+16|0;k[I>>2]=k[D>>2];k[I+4>>2]=k[D+4>>2];k[I+8>>2]=k[D+8>>2];c=c+1|0;if((c|0)==8)break}e=d+28|0;if((e|0)==(b|0)){c=1;E=70;break}else{I=d;d=e;e=I}}if((E|0)==70){r=F;return c|0}I=(d+28|0)==(b|0);r=F;return I|0}}return 0}function pd(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,l=0;f=a+4|0;g=k[a>>2]|0;c=g;h=(k[f>>2]|0)-c|0;i=(h|0)/28|0;j=i+1|0;if(j>>>0>153391689)xa(1340,1363,303,1438);l=a+8|0;c=((k[l>>2]|0)-c|0)/28|0;if(c>>>0<76695844){c=c<<1;c=c>>>0<j>>>0?j:c;if(!c){c=0;d=0}else e=5}else{c=153391689;e=5}if((e|0)==5){e=c*28|0;e=(e|0)==0?1:e;d=_d(e)|0;a:do if(!d){while(1){d=k[35]|0;k[35]=d+0;if(!d)break;Xa[d&0]();d=_d(e)|0;if(d)break a}a=ya(4)|0;k[a>>2]=128;La(a|0,8,1)}while(0)}e=d+(i*28|0)|0;k[e>>2]=k[b>>2];k[e+4>>2]=k[b+4>>2];k[e+8>>2]=k[b+8>>2];k[e+12>>2]=k[b+12>>2];k[e+16>>2]=k[b+16>>2];k[e+20>>2]=k[b+20>>2];k[e+24>>2]=k[b+24>>2];b=d+((((h|0)/-28|0)+i|0)*28|0)|0;fe(b|0,g|0,h|0)|0;k[a>>2]=b;k[f>>2]=d+(j*28|0);k[l>>2]=d+(c*28|0);if(!g)return;$d(g);return}function qd(a){a=a|0;return}function rd(a){a=a|0;$d(a);return}function sd(a){a=a|0;return 1459}function td(a){a=a|0;return}function ud(a){a=a|0;return}function vd(a){a=a|0;return}function wd(a){a=a|0;$d(a);return}function xd(a){a=a|0;$d(a);return}function yd(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0;g=r;r=r+64|0;f=g;if((a|0)!=(b|0))if((b|0)!=0?(e=Bd(b,56)|0,(e|0)!=0):0){b=f;d=b+56|0;do{k[b>>2]=0;b=b+4|0}while((b|0)<(d|0));k[f>>2]=e;k[f+8>>2]=a;k[f+12>>2]=-1;k[f+48>>2]=1;_a[k[(k[e>>2]|0)+28>>2]&3](e,f,k[c>>2]|0,1);if((k[f+24>>2]|0)==1){k[c>>2]=k[f+16>>2];b=1}else b=0}else b=0;else b=1;r=g;return b|0}function zd(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0;do if((a|0)==(k[b+8>>2]|0)){a=b+16|0;e=k[a>>2]|0;if(!e){k[a>>2]=c;k[b+24>>2]=d;k[b+36>>2]=1;break}if((e|0)!=(c|0)){d=b+36|0;k[d>>2]=(k[d>>2]|0)+1;k[b+24>>2]=2;i[b+54>>0]=1;break}a=b+24|0;if((k[a>>2]|0)==2)k[a>>2]=d}while(0);return}function Ad(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0;do if((a|0)==(k[b+8>>2]|0)){a=b+16|0;e=k[a>>2]|0;if(!e){k[a>>2]=c;k[b+24>>2]=d;k[b+36>>2]=1;break}if((e|0)!=(c|0)){d=b+36|0;k[d>>2]=(k[d>>2]|0)+1;k[b+24>>2]=2;i[b+54>>0]=1;break}a=b+24|0;if((k[a>>2]|0)==2)k[a>>2]=d}else{e=k[a+8>>2]|0;_a[k[(k[e>>2]|0)+28>>2]&3](e,b,c,d)}while(0);return}function Bd(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,l=0,m=0,n=0,o=0,p=0,q=0,s=0;s=r;r=r+64|0;q=s;p=k[a>>2]|0;o=a+(k[p+-8>>2]|0)|0;p=k[p+-4>>2]|0;k[q>>2]=b;k[q+4>>2]=a;k[q+8>>2]=40;l=q+12|0;a=q+16|0;c=q+20|0;d=q+24|0;e=q+28|0;f=q+32|0;g=q+40|0;h=(p|0)==(b|0);m=l;n=m+40|0;do{k[m>>2]=0;m=m+4|0}while((m|0)<(n|0));j[l+40>>1]=0;i[l+42>>0]=0;a:do if(h){k[q+48>>2]=1;Ya[k[(k[b>>2]|0)+20>>2]&3](b,q,o,o,1,0);a=(k[d>>2]|0)==1?o:0}else{Ua[k[(k[p>>2]|0)+24>>2]&3](p,q,o,1,0);switch(k[q+36>>2]|0){case 0:{a=(k[g>>2]|0)==1&(k[e>>2]|0)==1&(k[f>>2]|0)==1?k[c>>2]|0:0;break a}case 1:break;default:{a=0;break a}}if((k[d>>2]|0)!=1?!((k[g>>2]|0)==0&(k[e>>2]|0)==1&(k[f>>2]|0)==1):0){a=0;break}a=k[a>>2]|0}while(0);r=s;return a|0}function Cd(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0;i[a+53>>0]=1;do if((k[a+4>>2]|0)==(c|0)){i[a+52>>0]=1;c=a+16|0;e=k[c>>2]|0;if(!e){k[c>>2]=b;k[a+24>>2]=d;k[a+36>>2]=1;if(!((d|0)==1?(k[a+48>>2]|0)==1:0))break;i[a+54>>0]=1;break}if((e|0)!=(b|0)){d=a+36|0;k[d>>2]=(k[d>>2]|0)+1;i[a+54>>0]=1;break}e=a+24|0;c=k[e>>2]|0;if((c|0)==2){k[e>>2]=d;c=d}if((c|0)==1?(k[a+48>>2]|0)==1:0)i[a+54>>0]=1}while(0);return}function Dd(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;var f=0,g=0,h=0,j=0;a:do if((a|0)==(k[b+8>>2]|0)){if((k[b+4>>2]|0)==(c|0)?(f=b+28|0,(k[f>>2]|0)!=1):0)k[f>>2]=d}else{if((a|0)!=(k[b>>2]|0)){h=k[a+8>>2]|0;Ua[k[(k[h>>2]|0)+24>>2]&3](h,b,c,d,e);break}if((k[b+16>>2]|0)!=(c|0)?(g=b+20|0,(k[g>>2]|0)!=(c|0)):0){k[b+32>>2]=d;d=b+44|0;if((k[d>>2]|0)==4)break;f=b+52|0;i[f>>0]=0;j=b+53|0;i[j>>0]=0;a=k[a+8>>2]|0;Ya[k[(k[a>>2]|0)+20>>2]&3](a,b,c,c,1,e);if(i[j>>0]|0){if(!(i[f>>0]|0)){f=1;h=13}}else{f=0;h=13}do if((h|0)==13){k[g>>2]=c;j=b+40|0;k[j>>2]=(k[j>>2]|0)+1;if((k[b+36>>2]|0)==1?(k[b+24>>2]|0)==2:0){i[b+54>>0]=1;if(f)break}else h=16;if((h|0)==16?f:0)break;k[d>>2]=4;break a}while(0);k[d>>2]=3;break}if((d|0)==1)k[b+32>>2]=1}while(0);return}function Ed(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;var f=0,g=0;do if((a|0)==(k[b+8>>2]|0)){if((k[b+4>>2]|0)==(c|0)?(g=b+28|0,(k[g>>2]|0)!=1):0)k[g>>2]=d}else if((a|0)==(k[b>>2]|0)){if((k[b+16>>2]|0)!=(c|0)?(f=b+20|0,(k[f>>2]|0)!=(c|0)):0){k[b+32>>2]=d;k[f>>2]=c;e=b+40|0;k[e>>2]=(k[e>>2]|0)+1;if((k[b+36>>2]|0)==1?(k[b+24>>2]|0)==2:0)i[b+54>>0]=1;k[b+44>>2]=4;break}if((d|0)==1)k[b+32>>2]=1}while(0);return}function Fd(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;if((a|0)==(k[b+8>>2]|0))Cd(b,c,d,e);else{a=k[a+8>>2]|0;Ya[k[(k[a>>2]|0)+20>>2]&3](a,b,c,d,e,f)}return}function Gd(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;if((a|0)==(k[b+8>>2]|0))Cd(b,c,d,e);return}function Hd(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0;e=r;r=r+16|0;d=e;k[d>>2]=k[c>>2];a=Ta[k[(k[a>>2]|0)+16>>2]&7](a,b,d)|0;if(a)k[c>>2]=k[d>>2];r=e;return a&1|0}function Id(a){a=a|0;if(!a)a=0;else a=(Bd(a,88)|0)!=0;return a&1|0}function Jd(a){a=a|0;var b=0,c=0;b=0;while(1){if((l[1474+b>>0]|0)==(a|0)){c=2;break}b=b+1|0;if((b|0)==87){b=87;a=1562;c=5;break}}if((c|0)==2)if(!b)b=1562;else{a=1562;c=5}if((c|0)==5)while(1){do{c=a;a=a+1|0}while((i[c>>0]|0)!=0);b=b+-1|0;if(!b){b=a;break}else c=5}return b|0}function Kd(a,b){a=+a;b=b|0;var c=0,d=0,e=0;p[t>>3]=a;c=k[t>>2]|0;d=k[t+4>>2]|0;e=de(c|0,d|0,52)|0;e=e&2047;switch(e|0){case 0:{if(a!=0.0){a=+Kd(a*18446744073709552.0e3,b);c=(k[b>>2]|0)+-64|0}else c=0;k[b>>2]=c;break}case 2047:break;default:{k[b>>2]=e+-1022;k[t>>2]=c;k[t+4>>2]=d&-2146435073|1071644672;a=+p[t>>3]}}return +a}function Ld(a,b){a=a|0;b=b|0;do if(!a)a=1;else{if(b>>>0<128){i[a>>0]=b;a=1;break}if(b>>>0<2048){i[a>>0]=b>>>6|192;i[a+1>>0]=b&63|128;a=2;break}if(b>>>0<55296|(b&-8192|0)==57344){i[a>>0]=b>>>12|224;i[a+1>>0]=b>>>6&63|128;i[a+2>>0]=b&63|128;a=3;break}if((b+-65536|0)>>>0<1048576){i[a>>0]=b>>>18|240;i[a+1>>0]=b>>>12&63|128;i[a+2>>0]=b>>>6&63|128;i[a+3>>0]=b&63|128;a=4;break}if(!(k[56]|0))a=268;else{a=(Ga()|0)+60|0;a=k[a>>2]|0}k[a>>2]=84;a=-1}while(0);return a|0}function Md(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0;d=c+16|0;e=k[d>>2]|0;if(!e)if(!(Td(c)|0)){e=k[d>>2]|0;f=4}else d=0;else f=4;a:do if((f|0)==4){g=c+20|0;f=k[g>>2]|0;if((e-f|0)>>>0<b>>>0){d=Ta[k[c+36>>2]&7](c,a,b)|0;break}b:do if((i[c+75>>0]|0)>-1){d=b;while(1){if(!d){e=f;d=0;break b}e=d+-1|0;if((i[a+e>>0]|0)==10)break;else d=e}if((Ta[k[c+36>>2]&7](c,a,d)|0)>>>0<d>>>0)break a;b=b-d|0;a=a+d|0;e=k[g>>2]|0}else{e=f;d=0}while(0);fe(e|0,a|0,b|0)|0;k[g>>2]=(k[g>>2]|0)+b;d=d+b|0}while(0);return d|0}function Nd(a,b){a=a|0;b=b|0;var c=0,d=0;c=r;r=r+16|0;d=c;k[d>>2]=b;Od(272,a,d)|0;r=c;return}function Od(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0;q=r;r=r+224|0;m=q+120|0;p=q+80|0;o=q;n=q+136|0;d=p;e=d+40|0;do{k[d>>2]=0;d=d+4|0}while((d|0)<(e|0));k[m>>2]=k[c>>2];if((Vd(0,b,m,o,p)|0)<0)c=-1;else{c=k[a>>2]|0;l=c&32;if((i[a+74>>0]|0)<1)k[a>>2]=c&-33;j=a+48|0;if(!(k[j>>2]|0)){d=a+44|0;e=k[d>>2]|0;k[d>>2]=n;f=a+28|0;k[f>>2]=n;g=a+20|0;k[g>>2]=n;k[j>>2]=80;h=a+16|0;k[h>>2]=n+80;c=Vd(a,b,m,o,p)|0;if(e){Ta[k[a+36>>2]&7](a,0,0)|0;c=(k[g>>2]|0)==0?-1:c;k[d>>2]=e;k[j>>2]=0;k[h>>2]=0;k[f>>2]=0;k[g>>2]=0}}else c=Vd(a,b,m,o,p)|0;p=k[a>>2]|0;k[a>>2]=p|l;c=(p&32|0)==0?c:-1}r=q;return c|0}function Pd(a){a=a|0;var b=0,c=0;c=r;r=r+16|0;b=c;k[b>>2]=k[a+60>>2];a=va(6,b|0)|0;if(a>>>0>4294963200){if(!(k[56]|0))b=268;else{b=(Ga()|0)+60|0;b=k[b>>2]|0}k[b>>2]=0-a;a=-1}r=c;return a|0}function Qd(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0;f=r;r=r+32|0;g=f;d=f+20|0;k[g>>2]=k[a+60>>2];k[g+4>>2]=0;k[g+8>>2]=b;k[g+12>>2]=d;k[g+16>>2]=c;b=Ha(140,g|0)|0;if(b>>>0<=4294963200)if((b|0)<0)e=7;else a=k[d>>2]|0;else{if(!(k[56]|0))a=268;else{a=(Ga()|0)+60|0;a=k[a>>2]|0}k[a>>2]=0-b;e=7}if((e|0)==7){k[d>>2]=-1;a=-1}r=f;return a|0}function Rd(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,l=0,m=0,n=0,o=0,p=0;p=r;r=r+48|0;m=p+16|0;l=p;i=p+32|0;n=a+28|0;f=k[n>>2]|0;k[i>>2]=f;o=a+20|0;f=(k[o>>2]|0)-f|0;k[i+4>>2]=f;k[i+8>>2]=b;k[i+12>>2]=c;h=a+60|0;j=a+44|0;e=2;f=f+c|0;while(1){if(!(k[56]|0)){k[m>>2]=k[h>>2];k[m+4>>2]=i;k[m+8>>2]=e;b=Qa(146,m|0)|0;if(b>>>0>4294963200){if(!(k[56]|0))d=268;else{d=(Ga()|0)+60|0;d=k[d>>2]|0}k[d>>2]=0-b;b=-1}}else{Na(8,a|0);k[l>>2]=k[h>>2];k[l+4>>2]=i;k[l+8>>2]=e;b=Qa(146,l|0)|0;if(b>>>0>4294963200){if(!(k[56]|0))d=268;else{d=(Ga()|0)+60|0;d=k[d>>2]|0}k[d>>2]=0-b;b=-1}ua(0)}if((f|0)==(b|0)){b=13;break}if((b|0)<0){b=15;break}f=f-b|0;d=k[i+4>>2]|0;if(b>>>0<=d>>>0)if((e|0)==2){k[n>>2]=(k[n>>2]|0)+b;g=d;d=i;e=2}else{g=d;d=i}else{g=k[j>>2]|0;k[n>>2]=g;k[o>>2]=g;g=k[i+12>>2]|0;b=b-d|0;d=i+8|0;e=e+-1|0}k[d>>2]=(k[d>>2]|0)+b;k[d+4>>2]=g-b;i=d}if((b|0)==13){m=k[j>>2]|0;k[a+16>>2]=m+(k[a+48>>2]|0);a=m;k[n>>2]=a;k[o>>2]=a}else if((b|0)==15){k[a+16>>2]=0;k[n>>2]=0;k[o>>2]=0;k[a>>2]=k[a>>2]|32;if((e|0)==2)c=0;else c=c-(k[i+4>>2]|0)|0}r=p;return c|0}function Sd(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0;e=r;r=r+80|0;d=e;k[a+36>>2]=4;if((k[a>>2]&64|0)==0?(k[d>>2]=k[a+60>>2],k[d+4>>2]=21505,k[d+8>>2]=e+12,(Ia(54,d|0)|0)!=0):0)i[a+75>>0]=-1;d=Rd(a,b,c)|0;r=e;return d|0}function Td(a){a=a|0;var b=0,c=0;b=a+74|0;c=i[b>>0]|0;i[b>>0]=c+255|c;b=k[a>>2]|0;if(!(b&8)){k[a+8>>2]=0;k[a+4>>2]=0;b=k[a+44>>2]|0;k[a+28>>2]=b;k[a+20>>2]=b;k[a+16>>2]=b+(k[a+48>>2]|0);b=0}else{k[a>>2]=b|32;b=-1}return b|0}function Ud(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0;f=b&255;d=(c|0)!=0;a:do if(d&(a&3|0)!=0){e=b&255;while(1){if((i[a>>0]|0)==e<<24>>24)break a;a=a+1|0;c=c+-1|0;d=(c|0)!=0;if(!(d&(a&3|0)!=0)){g=5;break}}}else g=5;while(0);b:do if((g|0)==5)if(d){e=b&255;if((i[a>>0]|0)!=e<<24>>24){d=ha(f,16843009)|0;c:do if(c>>>0>3)while(1){f=k[a>>2]^d;if((f&-2139062144^-2139062144)&f+-16843009)break;a=a+4|0;c=c+-4|0;if(c>>>0<=3){g=11;break c}}else g=11;while(0);if((g|0)==11)if(!c){c=0;break}while(1){if((i[a>>0]|0)==e<<24>>24)break b;a=a+1|0;c=c+-1|0;if(!c){c=0;break}}}}else c=0;while(0);return ((c|0)!=0?a:0)|0}function Vd(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;var f=0,g=0,h=0,m=0.0,n=0,o=0,q=0,s=0,u=0,v=0,w=0,x=0.0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0,ba=0,ca=0,da=0,ea=0,fa=0,ga=0;ga=r;r=r+624|0;ba=ga+24|0;da=ga+16|0;ca=ga+588|0;Y=ga+576|0;aa=ga;V=ga+536|0;fa=ga+8|0;ea=ga+528|0;M=(a|0)!=0;N=V+40|0;U=N;V=V+39|0;W=fa+4|0;X=Y+12|0;Y=Y+11|0;Z=ca;_=X;$=_-Z|0;O=-2-Z|0;P=_+2|0;Q=ba+288|0;R=ca+9|0;S=R;T=ca+8|0;f=0;g=0;q=0;a:while(1){do if((f|0)>-1){if((g|0)<=(2147483647-f|0)){f=g+f|0;break}if(!(k[56]|0))f=268;else{f=(Ga()|0)+60|0;f=k[f>>2]|0}k[f>>2]=75;f=-1}while(0);g=i[b>>0]|0;if(!(g<<24>>24)){K=249;break}else h=b;b:while(1){switch(g<<24>>24){case 37:{g=h;K=11;break b}case 0:{g=h;break b}default:{}}J=h+1|0;g=i[J>>0]|0;h=J}c:do if((K|0)==11)while(1){K=0;if((i[g+1>>0]|0)!=37)break c;h=h+1|0;g=g+2|0;if((i[g>>0]|0)==37)K=11;else break}while(0);y=h-b|0;if(M?(k[a>>2]&32|0)==0:0)Md(b,y,a)|0;if((h|0)!=(b|0)){b=g;g=y;continue}o=g+1|0;h=i[o>>0]|0;n=(h<<24>>24)+-48|0;if(n>>>0<10){J=(i[g+2>>0]|0)==36;o=J?g+3|0:o;h=i[o>>0]|0;u=J?n:-1;q=J?1:q}else u=-1;g=h<<24>>24;d:do if((g&-32|0)==32){n=0;while(1){if(!(1<<g+-32&75913)){s=n;break d}n=1<<(h<<24>>24)+-32|n;o=o+1|0;h=i[o>>0]|0;g=h<<24>>24;if((g&-32|0)!=32){s=n;break}}}else s=0;while(0);do if(h<<24>>24==42){h=o+1|0;g=(i[h>>0]|0)+-48|0;if(g>>>0<10?(i[o+2>>0]|0)==36:0){k[e+(g<<2)>>2]=10;q=1;g=o+3|0;n=k[d+((i[h>>0]|0)+-48<<3)>>2]|0}else{if(q){f=-1;break a}if(!M){w=s;q=0;J=0;break}q=(k[c>>2]|0)+(4-1)&~(4-1);n=k[q>>2]|0;k[c>>2]=q+4;q=0;g=h}if((n|0)<0){w=s|8192;h=g;J=0-n|0}else{w=s;h=g;J=n}}else{g=(h<<24>>24)+-48|0;if(g>>>0<10){h=o;n=0;do{n=(n*10|0)+g|0;h=h+1|0;g=(i[h>>0]|0)+-48|0}while(g>>>0<10);if((n|0)<0){f=-1;break a}else{w=s;J=n}}else{w=s;h=o;J=0}}while(0);e:do if((i[h>>0]|0)==46){n=h+1|0;g=i[n>>0]|0;if(g<<24>>24!=42){o=(g<<24>>24)+-48|0;if(o>>>0<10){g=n;h=0}else{g=n;o=0;break}while(1){h=(h*10|0)+o|0;g=g+1|0;o=(i[g>>0]|0)+-48|0;if(o>>>0>=10){o=h;break e}}}n=h+2|0;g=(i[n>>0]|0)+-48|0;if(g>>>0<10?(i[h+3>>0]|0)==36:0){k[e+(g<<2)>>2]=10;g=h+4|0;o=k[d+((i[n>>0]|0)+-48<<3)>>2]|0;break}if(q){f=-1;break a}if(M){g=(k[c>>2]|0)+(4-1)&~(4-1);o=k[g>>2]|0;k[c>>2]=g+4;g=n}else{g=n;o=0}}else{g=h;o=-1}while(0);v=0;while(1){h=(i[g>>0]|0)+-65|0;if(h>>>0>57){f=-1;break a}I=g+1|0;h=i[4398+(v*58|0)+h>>0]|0;n=h&255;if((n+-1|0)>>>0<8){g=I;v=n}else break}if(!(h<<24>>24)){f=-1;break}s=(u|0)>-1;do if(h<<24>>24==19)if(s){f=-1;break a}else K=54;else{if(s){k[e+(u<<2)>>2]=n;G=d+(u<<3)|0;H=k[G+4>>2]|0;K=aa;k[K>>2]=k[G>>2];k[K+4>>2]=H;K=54;break}if(!M){f=0;break a}Xd(aa,n,c)}while(0);if((K|0)==54?(K=0,!M):0){b=I;g=y;continue}u=i[g>>0]|0;u=(v|0)!=0&(u&15|0)==3?u&-33:u;h=w&-65537;H=(w&8192|0)==0?w:h;f:do switch(u|0){case 110:switch(v|0){case 0:{k[k[aa>>2]>>2]=f;b=I;g=y;continue a}case 1:{k[k[aa>>2]>>2]=f;b=I;g=y;continue a}case 2:{b=k[aa>>2]|0;k[b>>2]=f;k[b+4>>2]=((f|0)<0)<<31>>31;b=I;g=y;continue a}case 3:{j[k[aa>>2]>>1]=f;b=I;g=y;continue a}case 4:{i[k[aa>>2]>>0]=f;b=I;g=y;continue a}case 6:{k[k[aa>>2]>>2]=f;b=I;g=y;continue a}case 7:{b=k[aa>>2]|0;k[b>>2]=f;k[b+4>>2]=((f|0)<0)<<31>>31;b=I;g=y;continue a}default:{b=I;g=y;continue a}}case 112:{s=H|8;o=o>>>0>8?o:8;u=120;K=66;break}case 88:case 120:{s=H;K=66;break}case 111:{h=aa;g=k[h>>2]|0;h=k[h+4>>2]|0;if((g|0)==0&(h|0)==0)b=N;else{b=N;do{b=b+-1|0;i[b>>0]=g&7|48;g=de(g|0,h|0,3)|0;h=L}while(!((g|0)==0&(h|0)==0))}if(!(H&8)){g=H;s=0;n=4878;K=79}else{s=U-b+1|0;g=H;o=(o|0)<(s|0)?s:o;s=0;n=4878;K=79}break}case 105:case 100:{g=aa;b=k[g>>2]|0;g=k[g+4>>2]|0;if((g|0)<0){b=be(0,0,b|0,g|0)|0;g=L;h=aa;k[h>>2]=b;k[h+4>>2]=g;h=1;n=4878;K=78;break f}if(!(H&2048)){n=H&1;h=n;n=(n|0)==0?4878:4880;K=78}else{h=1;n=4879;K=78}break}case 117:{g=aa;b=k[g>>2]|0;g=k[g+4>>2]|0;h=0;n=4878;K=78;break}case 99:{i[V>>0]=k[aa>>2];b=V;u=1;w=0;v=4878;g=N;break}case 109:{if(!(k[56]|0))b=268;else{b=(Ga()|0)+60|0;b=k[b>>2]|0}g=Jd(k[b>>2]|0)|0;K=86;break}case 115:{g=k[aa>>2]|0;g=(g|0)!=0?g:4888;K=86;break}case 67:{k[fa>>2]=k[aa>>2];k[W>>2]=0;k[aa>>2]=fa;h=fa;o=-1;K=91;break}case 83:if(!o){Zd(a,32,J,0,H);g=0;K=102;break f}else{h=k[aa>>2]|0;K=91;break f}case 65:case 71:case 70:case 69:case 97:case 103:case 102:case 101:{m=+p[aa>>3];k[da>>2]=0;p[t>>3]=m;if((k[t+4>>2]|0)>=0)if(!(H&2048)){G=H&1;F=G;G=(G|0)==0?4896:4901}else{F=1;G=4898}else{m=-m;F=1;G=4895}p[t>>3]=m;E=k[t+4>>2]&2146435072;do if(E>>>0<2146435072|(E|0)==2146435072&0<0){x=+Kd(m,da)*2.0;g=x!=0.0;if(g)k[da>>2]=(k[da>>2]|0)+-1;C=u|32;if((C|0)==97){v=u&32;y=(v|0)==0?G:G+9|0;w=F|2;b=12-o|0;do if(!(o>>>0>11|(b|0)==0)){m=8.0;do{b=b+-1|0;m=m*16.0}while((b|0)!=0);if((i[y>>0]|0)==45){m=-(m+(-x-m));break}else{m=x+m-m;break}}else m=x;while(0);g=k[da>>2]|0;b=(g|0)<0?0-g|0:g;b=Yd(b,((b|0)<0)<<31>>31,X)|0;if((b|0)==(X|0)){i[Y>>0]=48;b=Y}i[b+-1>>0]=(g>>31&2)+43;s=b+-2|0;i[s>>0]=u+15;n=(o|0)<1;h=(H&8|0)==0;g=ca;while(1){G=~~m;b=g+1|0;i[g>>0]=l[4862+G>>0]|v;m=(m-+(G|0))*16.0;do if((b-Z|0)==1){if(h&(n&m==0.0))break;i[b>>0]=46;b=g+2|0}while(0);if(!(m!=0.0))break;else g=b}h=s;o=(o|0)!=0&(O+b|0)<(o|0)?P+o-h|0:$-h+b|0;n=o+w|0;Zd(a,32,J,n,H);if(!(k[a>>2]&32))Md(y,w,a)|0;Zd(a,48,J,n,H^65536);g=b-Z|0;if(!(k[a>>2]&32))Md(ca,g,a)|0;b=_-h|0;Zd(a,48,o-(g+b)|0,0,0);if(!(k[a>>2]&32))Md(s,b,a)|0;Zd(a,32,J,n,H^8192);g=(n|0)<(J|0)?J:n;break}b=(o|0)<0?6:o;if(g){g=(k[da>>2]|0)+-28|0;k[da>>2]=g;m=x*268435456.0}else{m=x;g=k[da>>2]|0}E=(g|0)<0?ba:Q;D=E;h=E;do{B=~~m>>>0;k[h>>2]=B;h=h+4|0;m=(m-+(B>>>0))*1.0e9}while(m!=0.0);g=k[da>>2]|0;if((g|0)>0){n=E;o=h;while(1){s=(g|0)>29?29:g;g=o+-4|0;do if(g>>>0>=n>>>0){h=0;do{A=ee(k[g>>2]|0,0,s|0)|0;A=ge(A|0,L|0,h|0,0)|0;B=L;z=pe(A|0,B|0,1e9,0)|0;k[g>>2]=z;h=oe(A|0,B|0,1e9,0)|0;g=g+-4|0}while(g>>>0>=n>>>0);if(!h)break;n=n+-4|0;k[n>>2]=h}while(0);h=o;while(1){if(h>>>0<=n>>>0)break;g=h+-4|0;if(!(k[g>>2]|0))h=g;else break}g=(k[da>>2]|0)-s|0;k[da>>2]=g;if((g|0)>0)o=h;else break}}else n=E;if((g|0)<0){y=((b+25|0)/9|0)+1|0;z=(C|0)==102;do{w=0-g|0;w=(w|0)>9?9:w;do if(n>>>0<h>>>0){g=(1<<w)+-1|0;o=1e9>>>w;v=0;s=n;do{B=k[s>>2]|0;k[s>>2]=(B>>>w)+v;v=ha(B&g,o)|0;s=s+4|0}while(s>>>0<h>>>0);g=(k[n>>2]|0)==0?n+4|0:n;if(!v){n=g;g=h;break}k[h>>2]=v;n=g;g=h+4|0}else{n=(k[n>>2]|0)==0?n+4|0:n;g=h}while(0);h=z?E:n;h=(g-h>>2|0)>(y|0)?h+(y<<2)|0:g;g=(k[da>>2]|0)+w|0;k[da>>2]=g}while((g|0)<0);s=n;B=h}else{s=n;B=h}do if(s>>>0<B>>>0){g=(D-s>>2)*9|0;n=k[s>>2]|0;if(n>>>0<10)break;else h=10;do{h=h*10|0;g=g+1|0}while(n>>>0>=h>>>0)}else g=0;while(0);z=(C|0)==103;A=(b|0)!=0;h=b-((C|0)!=102?g:0)+((A&z)<<31>>31)|0;if((h|0)<(((B-D>>2)*9|0)+-9|0)){o=h+9216|0;y=(o|0)/9|0;h=E+(y+-1023<<2)|0;o=((o|0)%9|0)+1|0;if((o|0)<9){n=10;do{n=n*10|0;o=o+1|0}while((o|0)!=9)}else n=10;v=k[h>>2]|0;w=(v>>>0)%(n>>>0)|0;if((w|0)==0?(E+(y+-1022<<2)|0)==(B|0):0)n=s;else K=167;do if((K|0)==167){K=0;x=(((v>>>0)/(n>>>0)|0)&1|0)==0?9007199254740992.0:9007199254740994.0;o=(n|0)/2|0;do if(w>>>0<o>>>0)m=.5;else{if((w|0)==(o|0)?(E+(y+-1022<<2)|0)==(B|0):0){m=1.0;break}m=1.5}while(0);do if(F){if((i[G>>0]|0)!=45)break;x=-x;m=-m}while(0);o=v-w|0;k[h>>2]=o;if(!(x+m!=x)){n=s;break}C=o+n|0;k[h>>2]=C;if(C>>>0>999999999){g=s;while(1){n=h+-4|0;k[h>>2]=0;if(n>>>0<g>>>0){g=g+-4|0;k[g>>2]=0}C=(k[n>>2]|0)+1|0;k[n>>2]=C;if(C>>>0>999999999)h=n;else{s=g;h=n;break}}}g=(D-s>>2)*9|0;o=k[s>>2]|0;if(o>>>0<10){n=s;break}else n=10;do{n=n*10|0;g=g+1|0}while(o>>>0>=n>>>0);n=s}while(0);h=h+4|0;C=n;h=B>>>0>h>>>0?h:B}else{C=s;h=B}w=0-g|0;B=h;while(1){if(B>>>0<=C>>>0){y=0;break}h=B+-4|0;if(!(k[h>>2]|0))B=h;else{y=1;break}}do if(z){b=(A&1^1)+b|0;if((b|0)>(g|0)&(g|0)>-5){u=u+-1|0;b=b+-1-g|0}else{u=u+-2|0;b=b+-1|0}h=H&8;if(h)break;do if(y){h=k[B+-4>>2]|0;if(!h){n=9;break}if(!((h>>>0)%10|0)){o=10;n=0}else{n=0;break}do{o=o*10|0;n=n+1|0}while(((h>>>0)%(o>>>0)|0|0)==0)}else n=9;while(0);h=((B-D>>2)*9|0)+-9|0;if((u|32|0)==102){h=h-n|0;h=(h|0)<0?0:h;b=(b|0)<(h|0)?b:h;h=0;break}else{h=h+g-n|0;h=(h|0)<0?0:h;b=(b|0)<(h|0)?b:h;h=0;break}}else h=H&8;while(0);v=b|h;o=(v|0)!=0&1;s=(u|32|0)==102;if(s){g=(g|0)>0?g:0;u=0}else{n=(g|0)<0?w:g;n=Yd(n,((n|0)<0)<<31>>31,X)|0;if((_-n|0)<2)do{n=n+-1|0;i[n>>0]=48}while((_-n|0)<2);i[n+-1>>0]=(g>>31&2)+43;D=n+-2|0;i[D>>0]=u;g=_-D|0;u=D}w=F+1+b+o+g|0;Zd(a,32,J,w,H);if(!(k[a>>2]&32))Md(G,F,a)|0;Zd(a,48,J,w,H^65536);do if(s){n=C>>>0>E>>>0?E:C;h=n;do{g=Yd(k[h>>2]|0,0,R)|0;do if((h|0)==(n|0)){if((g|0)!=(R|0))break;i[T>>0]=48;g=T}else{if(g>>>0<=ca>>>0)break;do{g=g+-1|0;i[g>>0]=48}while(g>>>0>ca>>>0)}while(0);if(!(k[a>>2]&32))Md(g,S-g|0,a)|0;h=h+4|0}while(h>>>0<=E>>>0);do if(v){if(k[a>>2]&32)break;Md(4930,1,a)|0}while(0);if((b|0)>0&h>>>0<B>>>0)while(1){g=Yd(k[h>>2]|0,0,R)|0;if(g>>>0>ca>>>0)do{g=g+-1|0;i[g>>0]=48}while(g>>>0>ca>>>0);if(!(k[a>>2]&32))Md(g,(b|0)>9?9:b,a)|0;h=h+4|0;g=b+-9|0;if(!((b|0)>9&h>>>0<B>>>0)){b=g;break}else b=g}Zd(a,48,b+9|0,9,0)}else{s=y?B:C+4|0;if((b|0)>-1){o=(h|0)==0;n=C;do{g=Yd(k[n>>2]|0,0,R)|0;if((g|0)==(R|0)){i[T>>0]=48;g=T}do if((n|0)==(C|0)){h=g+1|0;if(!(k[a>>2]&32))Md(g,1,a)|0;if(o&(b|0)<1){g=h;break}if(k[a>>2]&32){g=h;break}Md(4930,1,a)|0;g=h}else{if(g>>>0<=ca>>>0)break;do{g=g+-1|0;i[g>>0]=48}while(g>>>0>ca>>>0)}while(0);h=S-g|0;if(!(k[a>>2]&32))Md(g,(b|0)>(h|0)?h:b,a)|0;b=b-h|0;n=n+4|0}while(n>>>0<s>>>0&(b|0)>-1)}Zd(a,48,b+18|0,18,0);if(k[a>>2]&32)break;Md(u,_-u|0,a)|0}while(0);Zd(a,32,J,w,H^8192);g=(w|0)<(J|0)?J:w}else{s=(u&32|0)!=0;o=m!=m|0.0!=0.0;g=o?0:F;n=g+3|0;Zd(a,32,J,n,h);b=k[a>>2]|0;if(!(b&32)){Md(G,g,a)|0;b=k[a>>2]|0}if(!(b&32))Md(o?(s?4922:4926):s?4914:4918,3,a)|0;Zd(a,32,J,n,H^8192);g=(n|0)<(J|0)?J:n}while(0);b=I;continue a}default:{h=H;u=o;w=0;v=4878;g=N}}while(0);g:do if((K|0)==66){h=aa;g=k[h>>2]|0;h=k[h+4>>2]|0;n=u&32;if(!((g|0)==0&(h|0)==0)){b=N;do{b=b+-1|0;i[b>>0]=l[4862+(g&15)>>0]|n;g=de(g|0,h|0,4)|0;h=L}while(!((g|0)==0&(h|0)==0));K=aa;if((s&8|0)==0|(k[K>>2]|0)==0&(k[K+4>>2]|0)==0){g=s;s=0;n=4878;K=79}else{g=s;s=2;n=4878+(u>>4)|0;K=79}}else{b=N;g=s;s=0;n=4878;K=79}}else if((K|0)==78){b=Yd(b,g,N)|0;g=H;s=h;K=79}else if((K|0)==86){K=0;H=Ud(g,0,o)|0;G=(H|0)==0;b=g;u=G?o:H-g|0;w=0;v=4878;g=G?g+o|0:H}else if((K|0)==91){K=0;g=0;b=0;s=h;while(1){n=k[s>>2]|0;if(!n)break;b=Ld(ea,n)|0;if((b|0)<0|b>>>0>(o-g|0)>>>0)break;g=b+g|0;if(o>>>0>g>>>0)s=s+4|0;else break}if((b|0)<0){f=-1;break a}Zd(a,32,J,g,H);if(!g){g=0;K=102}else{n=0;while(1){b=k[h>>2]|0;if(!b){K=102;break g}b=Ld(ea,b)|0;n=b+n|0;if((n|0)>(g|0)){K=102;break g}if(!(k[a>>2]&32))Md(ea,b,a)|0;if(n>>>0>=g>>>0){K=102;break}else h=h+4|0}}}while(0);if((K|0)==102){K=0;Zd(a,32,J,g,H^8192);b=I;g=(J|0)>(g|0)?J:g;continue}if((K|0)==79){K=0;h=(o|0)>-1?g&-65537:g;g=aa;g=(k[g>>2]|0)!=0|(k[g+4>>2]|0)!=0;if((o|0)!=0|g){u=(g&1^1)+(U-b)|0;u=(o|0)>(u|0)?o:u;w=s;v=n;g=N}else{b=N;u=0;w=s;v=n;g=N}}s=g-b|0;n=(u|0)<(s|0)?s:u;o=w+n|0;g=(J|0)<(o|0)?o:J;Zd(a,32,g,o,h);if(!(k[a>>2]&32))Md(v,w,a)|0;Zd(a,48,g,o,h^65536);Zd(a,48,n,s,0);if(!(k[a>>2]&32))Md(b,s,a)|0;Zd(a,32,g,o,h^8192);b=I}h:do if((K|0)==249)if(!a)if(!q)f=0;else{f=1;while(1){b=k[e+(f<<2)>>2]|0;if(!b){b=0;break}Xd(d+(f<<3)|0,b,c);f=f+1|0;if((f|0)>=10){f=1;break h}}while(1){f=f+1|0;if(b){f=-1;break h}if((f|0)>=10){f=1;break h}b=k[e+(f<<2)>>2]|0}}while(0);r=ga;return f|0}function Wd(a){a=a|0;return}function Xd(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0.0;a:do if(b>>>0<=20)do switch(b|0){case 9:{d=(k[c>>2]|0)+(4-1)&~(4-1);b=k[d>>2]|0;k[c>>2]=d+4;k[a>>2]=b;break a}case 10:{d=(k[c>>2]|0)+(4-1)&~(4-1);b=k[d>>2]|0;k[c>>2]=d+4;d=a;k[d>>2]=b;k[d+4>>2]=((b|0)<0)<<31>>31;break a}case 11:{d=(k[c>>2]|0)+(4-1)&~(4-1);b=k[d>>2]|0;k[c>>2]=d+4;d=a;k[d>>2]=b;k[d+4>>2]=0;break a}case 12:{d=(k[c>>2]|0)+(8-1)&~(8-1);b=d;e=k[b>>2]|0;b=k[b+4>>2]|0;k[c>>2]=d+8;d=a;k[d>>2]=e;k[d+4>>2]=b;break a}case 13:{e=(k[c>>2]|0)+(4-1)&~(4-1);d=k[e>>2]|0;k[c>>2]=e+4;d=(d&65535)<<16>>16;e=a;k[e>>2]=d;k[e+4>>2]=((d|0)<0)<<31>>31;break a}case 14:{e=(k[c>>2]|0)+(4-1)&~(4-1);d=k[e>>2]|0;k[c>>2]=e+4;e=a;k[e>>2]=d&65535;k[e+4>>2]=0;break a}case 15:{e=(k[c>>2]|0)+(4-1)&~(4-1);d=k[e>>2]|0;k[c>>2]=e+4;d=(d&255)<<24>>24;e=a;k[e>>2]=d;k[e+4>>2]=((d|0)<0)<<31>>31;break a}case 16:{e=(k[c>>2]|0)+(4-1)&~(4-1);d=k[e>>2]|0;k[c>>2]=e+4;e=a;k[e>>2]=d&255;k[e+4>>2]=0;break a}case 17:{e=(k[c>>2]|0)+(8-1)&~(8-1);f=+p[e>>3];k[c>>2]=e+8;p[a>>3]=f;break a}case 18:{e=(k[c>>2]|0)+(8-1)&~(8-1);f=+p[e>>3];k[c>>2]=e+8;p[a>>3]=f;break a}default:break a}while(0);while(0);return}function Yd(a,b,c){a=a|0;b=b|0;c=c|0;var d=0;if(b>>>0>0|(b|0)==0&a>>>0>4294967295)while(1){d=pe(a|0,b|0,10,0)|0;c=c+-1|0;i[c>>0]=d|48;d=a;a=oe(a|0,b|0,10,0)|0;if(!(b>>>0>9|(b|0)==9&d>>>0>4294967295))break;else b=L}if(a)while(1){c=c+-1|0;i[c>>0]=(a>>>0)%10|0|48;if(a>>>0<10)break;else a=(a>>>0)/10|0}return c|0}function Zd(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;var f=0,g=0;g=r;r=r+256|0;f=g;do if((c|0)>(d|0)&(e&73728|0)==0){e=c-d|0;ce(f|0,b|0,(e>>>0>256?256:e)|0)|0;d=k[a>>2]|0;c=(d&32|0)==0;if(e>>>0>255){b=e;do{if(c){Md(f,256,a)|0;d=k[a>>2]|0}b=b+-256|0;c=(d&32|0)==0}while(b>>>0>255);if(c)e=e&255;else break}else if(!c)break;Md(f,e,a)|0}while(0);r=g;return}function _d(a){a=a|0;var b=0,c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0;do if(a>>>0<245){o=a>>>0<11?16:a+11&-8;a=o>>>3;h=k[96]|0;b=h>>>a;if(b&3){b=(b&1^1)+a|0;d=b<<1;c=424+(d<<2)|0;d=424+(d+2<<2)|0;e=k[d>>2]|0;f=e+8|0;g=k[f>>2]|0;do if((c|0)!=(g|0)){if(g>>>0<(k[100]|0)>>>0)Ma();a=g+12|0;if((k[a>>2]|0)==(e|0)){k[a>>2]=c;k[d>>2]=g;break}else Ma()}else k[96]=h&~(1<<b);while(0);L=b<<3;k[e+4>>2]=L|3;L=e+(L|4)|0;k[L>>2]=k[L>>2]|1;L=f;return L|0}g=k[98]|0;if(o>>>0>g>>>0){if(b){d=2<<a;d=b<<a&(d|0-d);d=(d&0-d)+-1|0;i=d>>>12&16;d=d>>>i;e=d>>>5&8;d=d>>>e;f=d>>>2&4;d=d>>>f;c=d>>>1&2;d=d>>>c;b=d>>>1&1;b=(e|i|f|c|b)+(d>>>b)|0;d=b<<1;c=424+(d<<2)|0;d=424+(d+2<<2)|0;f=k[d>>2]|0;i=f+8|0;e=k[i>>2]|0;do if((c|0)!=(e|0)){if(e>>>0<(k[100]|0)>>>0)Ma();a=e+12|0;if((k[a>>2]|0)==(f|0)){k[a>>2]=c;k[d>>2]=e;j=k[98]|0;break}else Ma()}else{k[96]=h&~(1<<b);j=g}while(0);L=b<<3;g=L-o|0;k[f+4>>2]=o|3;h=f+o|0;k[f+(o|4)>>2]=g|1;k[f+L>>2]=g;if(j){e=k[101]|0;c=j>>>3;a=c<<1;d=424+(a<<2)|0;b=k[96]|0;c=1<<c;if(b&c){b=424+(a+2<<2)|0;a=k[b>>2]|0;if(a>>>0<(k[100]|0)>>>0)Ma();else{l=b;m=a}}else{k[96]=b|c;l=424+(a+2<<2)|0;m=d}k[l>>2]=e;k[m+12>>2]=e;k[e+8>>2]=m;k[e+12>>2]=d}k[98]=g;k[101]=h;L=i;return L|0}a=k[97]|0;if(a){h=(a&0-a)+-1|0;K=h>>>12&16;h=h>>>K;J=h>>>5&8;h=h>>>J;L=h>>>2&4;h=h>>>L;b=h>>>1&2;h=h>>>b;i=h>>>1&1;i=k[688+((J|K|L|b|i)+(h>>>i)<<2)>>2]|0;h=(k[i+4>>2]&-8)-o|0;b=i;while(1){a=k[b+16>>2]|0;if(!a){a=k[b+20>>2]|0;if(!a)break}b=(k[a+4>>2]&-8)-o|0;L=b>>>0<h>>>0;h=L?b:h;b=a;i=L?a:i}e=k[100]|0;if(i>>>0<e>>>0)Ma();g=i+o|0;if(i>>>0>=g>>>0)Ma();f=k[i+24>>2]|0;c=k[i+12>>2]|0;do if((c|0)==(i|0)){b=i+20|0;a=k[b>>2]|0;if(!a){b=i+16|0;a=k[b>>2]|0;if(!a){n=0;break}}while(1){c=a+20|0;d=k[c>>2]|0;if(d){a=d;b=c;continue}c=a+16|0;d=k[c>>2]|0;if(!d)break;else{a=d;b=c}}if(b>>>0<e>>>0)Ma();else{k[b>>2]=0;n=a;break}}else{d=k[i+8>>2]|0;if(d>>>0<e>>>0)Ma();a=d+12|0;if((k[a>>2]|0)!=(i|0))Ma();b=c+8|0;if((k[b>>2]|0)==(i|0)){k[a>>2]=c;k[b>>2]=d;n=c;break}else Ma()}while(0);do if(f){a=k[i+28>>2]|0;b=688+(a<<2)|0;if((i|0)==(k[b>>2]|0)){k[b>>2]=n;if(!n){k[97]=k[97]&~(1<<a);break}}else{if(f>>>0<(k[100]|0)>>>0)Ma();a=f+16|0;if((k[a>>2]|0)==(i|0))k[a>>2]=n;else k[f+20>>2]=n;if(!n)break}b=k[100]|0;if(n>>>0<b>>>0)Ma();k[n+24>>2]=f;a=k[i+16>>2]|0;do if(a)if(a>>>0<b>>>0)Ma();else{k[n+16>>2]=a;k[a+24>>2]=n;break}while(0);a=k[i+20>>2]|0;if(a)if(a>>>0<(k[100]|0)>>>0)Ma();else{k[n+20>>2]=a;k[a+24>>2]=n;break}}while(0);if(h>>>0<16){L=h+o|0;k[i+4>>2]=L|3;L=i+(L+4)|0;k[L>>2]=k[L>>2]|1}else{k[i+4>>2]=o|3;k[i+(o|4)>>2]=h|1;k[i+(h+o)>>2]=h;a=k[98]|0;if(a){e=k[101]|0;c=a>>>3;a=c<<1;d=424+(a<<2)|0;b=k[96]|0;c=1<<c;if(b&c){a=424+(a+2<<2)|0;b=k[a>>2]|0;if(b>>>0<(k[100]|0)>>>0)Ma();else{p=a;q=b}}else{k[96]=b|c;p=424+(a+2<<2)|0;q=d}k[p>>2]=e;k[q+12>>2]=e;k[e+8>>2]=q;k[e+12>>2]=d}k[98]=h;k[101]=g}L=i+8|0;return L|0}}}else if(a>>>0<=4294967231){a=a+11|0;o=a&-8;i=k[97]|0;if(i){b=0-o|0;a=a>>>8;if(a)if(o>>>0>16777215)h=31;else{q=(a+1048320|0)>>>16&8;x=a<<q;p=(x+520192|0)>>>16&4;x=x<<p;h=(x+245760|0)>>>16&2;h=14-(p|q|h)+(x<<h>>>15)|0;h=o>>>(h+7|0)&1|h<<1}else h=0;a=k[688+(h<<2)>>2]|0;a:do if(!a){c=0;a=0;x=86}else{e=b;c=0;f=o<<((h|0)==31?0:25-(h>>>1)|0);g=a;a=0;while(1){d=k[g+4>>2]&-8;b=d-o|0;if(b>>>0<e>>>0)if((d|0)==(o|0)){d=g;a=g;x=90;break a}else a=g;else b=e;x=k[g+20>>2]|0;g=k[g+16+(f>>>31<<2)>>2]|0;c=(x|0)==0|(x|0)==(g|0)?c:x;if(!g){x=86;break}else{e=b;f=f<<1}}}while(0);if((x|0)==86){if((c|0)==0&(a|0)==0){a=2<<h;a=i&(a|0-a);if(!a)break;a=(a&0-a)+-1|0;n=a>>>12&16;a=a>>>n;m=a>>>5&8;a=a>>>m;p=a>>>2&4;a=a>>>p;q=a>>>1&2;a=a>>>q;c=a>>>1&1;c=k[688+((m|n|p|q|c)+(a>>>c)<<2)>>2]|0;a=0}if(!c){h=b;i=a}else{d=c;x=90}}if((x|0)==90)while(1){x=0;q=(k[d+4>>2]&-8)-o|0;c=q>>>0<b>>>0;b=c?q:b;a=c?d:a;c=k[d+16>>2]|0;if(c){d=c;x=90;continue}d=k[d+20>>2]|0;if(!d){h=b;i=a;break}else x=90}if((i|0)!=0?h>>>0<((k[98]|0)-o|0)>>>0:0){e=k[100]|0;if(i>>>0<e>>>0)Ma();g=i+o|0;if(i>>>0>=g>>>0)Ma();f=k[i+24>>2]|0;c=k[i+12>>2]|0;do if((c|0)==(i|0)){b=i+20|0;a=k[b>>2]|0;if(!a){b=i+16|0;a=k[b>>2]|0;if(!a){s=0;break}}while(1){c=a+20|0;d=k[c>>2]|0;if(d){a=d;b=c;continue}c=a+16|0;d=k[c>>2]|0;if(!d)break;else{a=d;b=c}}if(b>>>0<e>>>0)Ma();else{k[b>>2]=0;s=a;break}}else{d=k[i+8>>2]|0;if(d>>>0<e>>>0)Ma();a=d+12|0;if((k[a>>2]|0)!=(i|0))Ma();b=c+8|0;if((k[b>>2]|0)==(i|0)){k[a>>2]=c;k[b>>2]=d;s=c;break}else Ma()}while(0);do if(f){a=k[i+28>>2]|0;b=688+(a<<2)|0;if((i|0)==(k[b>>2]|0)){k[b>>2]=s;if(!s){k[97]=k[97]&~(1<<a);break}}else{if(f>>>0<(k[100]|0)>>>0)Ma();a=f+16|0;if((k[a>>2]|0)==(i|0))k[a>>2]=s;else k[f+20>>2]=s;if(!s)break}b=k[100]|0;if(s>>>0<b>>>0)Ma();k[s+24>>2]=f;a=k[i+16>>2]|0;do if(a)if(a>>>0<b>>>0)Ma();else{k[s+16>>2]=a;k[a+24>>2]=s;break}while(0);a=k[i+20>>2]|0;if(a)if(a>>>0<(k[100]|0)>>>0)Ma();else{k[s+20>>2]=a;k[a+24>>2]=s;break}}while(0);b:do if(h>>>0>=16){k[i+4>>2]=o|3;k[i+(o|4)>>2]=h|1;k[i+(h+o)>>2]=h;a=h>>>3;if(h>>>0<256){b=a<<1;d=424+(b<<2)|0;c=k[96]|0;a=1<<a;if(c&a){a=424+(b+2<<2)|0;b=k[a>>2]|0;if(b>>>0<(k[100]|0)>>>0)Ma();else{t=a;u=b}}else{k[96]=c|a;t=424+(b+2<<2)|0;u=d}k[t>>2]=g;k[u+12>>2]=g;k[i+(o+8)>>2]=u;k[i+(o+12)>>2]=d;break}a=h>>>8;if(a)if(h>>>0>16777215)d=31;else{K=(a+1048320|0)>>>16&8;L=a<<K;J=(L+520192|0)>>>16&4;L=L<<J;d=(L+245760|0)>>>16&2;d=14-(J|K|d)+(L<<d>>>15)|0;d=h>>>(d+7|0)&1|d<<1}else d=0;a=688+(d<<2)|0;k[i+(o+28)>>2]=d;k[i+(o+20)>>2]=0;k[i+(o+16)>>2]=0;b=k[97]|0;c=1<<d;if(!(b&c)){k[97]=b|c;k[a>>2]=g;k[i+(o+24)>>2]=a;k[i+(o+12)>>2]=g;k[i+(o+8)>>2]=g;break}a=k[a>>2]|0;c:do if((k[a+4>>2]&-8|0)!=(h|0)){d=h<<((d|0)==31?0:25-(d>>>1)|0);while(1){c=a+16+(d>>>31<<2)|0;b=k[c>>2]|0;if(!b)break;if((k[b+4>>2]&-8|0)==(h|0)){w=b;break c}else{d=d<<1;a=b}}if(c>>>0<(k[100]|0)>>>0)Ma();else{k[c>>2]=g;k[i+(o+24)>>2]=a;k[i+(o+12)>>2]=g;k[i+(o+8)>>2]=g;break b}}else w=a;while(0);a=w+8|0;b=k[a>>2]|0;L=k[100]|0;if(b>>>0>=L>>>0&w>>>0>=L>>>0){k[b+12>>2]=g;k[a>>2]=g;k[i+(o+8)>>2]=b;k[i+(o+12)>>2]=w;k[i+(o+24)>>2]=0;break}else Ma()}else{L=h+o|0;k[i+4>>2]=L|3;L=i+(L+4)|0;k[L>>2]=k[L>>2]|1}while(0);L=i+8|0;return L|0}}}else o=-1;while(0);c=k[98]|0;if(c>>>0>=o>>>0){a=c-o|0;b=k[101]|0;if(a>>>0>15){k[101]=b+o;k[98]=a;k[b+(o+4)>>2]=a|1;k[b+c>>2]=a;k[b+4>>2]=o|3}else{k[98]=0;k[101]=0;k[b+4>>2]=c|3;L=b+(c+4)|0;k[L>>2]=k[L>>2]|1}L=b+8|0;return L|0}a=k[99]|0;if(a>>>0>o>>>0){K=a-o|0;k[99]=K;L=k[102]|0;k[102]=L+o;k[L+(o+4)>>2]=K|1;k[L+4>>2]=o|3;L=L+8|0;return L|0}do if(!(k[214]|0)){a=Fa(30)|0;if(!(a+-1&a)){k[216]=a;k[215]=a;k[217]=-1;k[218]=-1;k[219]=0;k[207]=0;w=(Oa(0)|0)&-16^1431655768;k[214]=w;break}else Ma()}while(0);f=o+48|0;e=k[216]|0;g=o+47|0;d=e+g|0;e=0-e|0;h=d&e;if(h>>>0<=o>>>0){L=0;return L|0}a=k[206]|0;if((a|0)!=0?(u=k[204]|0,w=u+h|0,w>>>0<=u>>>0|w>>>0>a>>>0):0){L=0;return L|0}d:do if(!(k[207]&4)){c=k[102]|0;e:do if(c){a=832;while(1){b=k[a>>2]|0;if(b>>>0<=c>>>0?(r=a+4|0,(b+(k[r>>2]|0)|0)>>>0>c>>>0):0)break;a=k[a+8>>2]|0;if(!a){x=174;break e}}b=d-(k[99]|0)&e;if(b>>>0<2147483647){c=Ba(b|0)|0;w=(c|0)==((k[a>>2]|0)+(k[r>>2]|0)|0);a=w?b:0;if(w){if((c|0)!=(-1|0)){r=c;q=a;x=194;break d}}else x=184}else a=0}else x=174;while(0);do if((x|0)==174){d=Ba(0)|0;if((d|0)!=(-1|0)){a=d;b=k[215]|0;c=b+-1|0;if(!(c&a))b=h;else b=h-a+(c+a&0-b)|0;a=k[204]|0;c=a+b|0;if(b>>>0>o>>>0&b>>>0<2147483647){w=k[206]|0;if((w|0)!=0?c>>>0<=a>>>0|c>>>0>w>>>0:0){a=0;break}c=Ba(b|0)|0;x=(c|0)==(d|0);a=x?b:0;if(x){r=d;q=a;x=194;break d}else x=184}else a=0}else a=0}while(0);f:do if((x|0)==184){d=0-b|0;do if(f>>>0>b>>>0&(b>>>0<2147483647&(c|0)!=(-1|0))?(v=k[216]|0,v=g-b+v&0-v,v>>>0<2147483647):0)if((Ba(v|0)|0)==(-1|0)){Ba(d|0)|0;break f}else{b=v+b|0;break}while(0);if((c|0)!=(-1|0)){r=c;q=b;x=194;break d}}while(0);k[207]=k[207]|4;x=191}else{a=0;x=191}while(0);if((((x|0)==191?h>>>0<2147483647:0)?(y=Ba(h|0)|0,z=Ba(0)|0,y>>>0<z>>>0&((y|0)!=(-1|0)&(z|0)!=(-1|0))):0)?(A=z-y|0,B=A>>>0>(o+40|0)>>>0,B):0){r=y;q=B?A:a;x=194}if((x|0)==194){a=(k[204]|0)+q|0;k[204]=a;if(a>>>0>(k[205]|0)>>>0)k[205]=a;g=k[102]|0;g:do if(g){e=832;while(1){a=k[e>>2]|0;b=e+4|0;c=k[b>>2]|0;if((r|0)==(a+c|0)){x=204;break}d=k[e+8>>2]|0;if(!d)break;else e=d}if(((x|0)==204?(k[e+12>>2]&8|0)==0:0)?g>>>0<r>>>0&g>>>0>=a>>>0:0){k[b>>2]=c+q;L=(k[99]|0)+q|0;K=g+8|0;K=(K&7|0)==0?0:0-K&7;J=L-K|0;k[102]=g+K;k[99]=J;k[g+(K+4)>>2]=J|1;k[g+(L+4)>>2]=40;k[103]=k[218];break}a=k[100]|0;if(r>>>0<a>>>0){k[100]=r;i=r}else i=a;b=r+q|0;a=832;while(1){if((k[a>>2]|0)==(b|0)){x=212;break}a=k[a+8>>2]|0;if(!a){b=832;break}}if((x|0)==212)if(!(k[a+12>>2]&8)){k[a>>2]=r;n=a+4|0;k[n>>2]=(k[n>>2]|0)+q;n=r+8|0;n=(n&7|0)==0?0:0-n&7;j=r+(q+8)|0;j=(j&7|0)==0?0:0-j&7;a=r+(j+q)|0;m=n+o|0;p=r+m|0;l=a-(r+n)-o|0;k[r+(n+4)>>2]=o|3;h:do if((a|0)!=(g|0)){if((a|0)==(k[101]|0)){L=(k[98]|0)+l|0;k[98]=L;k[101]=p;k[r+(m+4)>>2]=L|1;k[r+(L+m)>>2]=L;break}g=q+4|0;b=k[r+(g+j)>>2]|0;if((b&3|0)==1){h=b&-8;e=b>>>3;i:do if(b>>>0>=256){f=k[r+((j|24)+q)>>2]|0;d=k[r+(q+12+j)>>2]|0;do if((d|0)==(a|0)){c=j|16;d=r+(g+c)|0;b=k[d>>2]|0;if(!b){c=r+(c+q)|0;b=k[c>>2]|0;if(!b){I=0;break}}else c=d;while(1){d=b+20|0;e=k[d>>2]|0;if(e){b=e;c=d;continue}d=b+16|0;e=k[d>>2]|0;if(!e)break;else{b=e;c=d}}if(c>>>0<i>>>0)Ma();else{k[c>>2]=0;I=b;break}}else{e=k[r+((j|8)+q)>>2]|0;if(e>>>0<i>>>0)Ma();b=e+12|0;if((k[b>>2]|0)!=(a|0))Ma();c=d+8|0;if((k[c>>2]|0)==(a|0)){k[b>>2]=d;k[c>>2]=e;I=d;break}else Ma()}while(0);if(!f)break;b=k[r+(q+28+j)>>2]|0;c=688+(b<<2)|0;do if((a|0)!=(k[c>>2]|0)){if(f>>>0<(k[100]|0)>>>0)Ma();b=f+16|0;if((k[b>>2]|0)==(a|0))k[b>>2]=I;else k[f+20>>2]=I;if(!I)break i}else{k[c>>2]=I;if(I)break;k[97]=k[97]&~(1<<b);break i}while(0);c=k[100]|0;if(I>>>0<c>>>0)Ma();k[I+24>>2]=f;a=j|16;b=k[r+(a+q)>>2]|0;do if(b)if(b>>>0<c>>>0)Ma();else{k[I+16>>2]=b;k[b+24>>2]=I;break}while(0);a=k[r+(g+a)>>2]|0;if(!a)break;if(a>>>0<(k[100]|0)>>>0)Ma();else{k[I+20>>2]=a;k[a+24>>2]=I;break}}else{c=k[r+((j|8)+q)>>2]|0;d=k[r+(q+12+j)>>2]|0;b=424+(e<<1<<2)|0;do if((c|0)!=(b|0)){if(c>>>0<i>>>0)Ma();if((k[c+12>>2]|0)==(a|0))break;Ma()}while(0);if((d|0)==(c|0)){k[96]=k[96]&~(1<<e);break}do if((d|0)==(b|0))E=d+8|0;else{if(d>>>0<i>>>0)Ma();b=d+8|0;if((k[b>>2]|0)==(a|0)){E=b;break}Ma()}while(0);k[c+12>>2]=d;k[E>>2]=c}while(0);a=r+((h|j)+q)|0;e=h+l|0}else e=l;a=a+4|0;k[a>>2]=k[a>>2]&-2;k[r+(m+4)>>2]=e|1;k[r+(e+m)>>2]=e;a=e>>>3;if(e>>>0<256){b=a<<1;d=424+(b<<2)|0;c=k[96]|0;a=1<<a;do if(!(c&a)){k[96]=c|a;J=424+(b+2<<2)|0;K=d}else{a=424+(b+2<<2)|0;b=k[a>>2]|0;if(b>>>0>=(k[100]|0)>>>0){J=a;K=b;break}Ma()}while(0);k[J>>2]=p;k[K+12>>2]=p;k[r+(m+8)>>2]=K;k[r+(m+12)>>2]=d;break}a=e>>>8;do if(!a)d=0;else{if(e>>>0>16777215){d=31;break}J=(a+1048320|0)>>>16&8;K=a<<J;I=(K+520192|0)>>>16&4;K=K<<I;d=(K+245760|0)>>>16&2;d=14-(I|J|d)+(K<<d>>>15)|0;d=e>>>(d+7|0)&1|d<<1}while(0);a=688+(d<<2)|0;k[r+(m+28)>>2]=d;k[r+(m+20)>>2]=0;k[r+(m+16)>>2]=0;b=k[97]|0;c=1<<d;if(!(b&c)){k[97]=b|c;k[a>>2]=p;k[r+(m+24)>>2]=a;k[r+(m+12)>>2]=p;k[r+(m+8)>>2]=p;break}a=k[a>>2]|0;j:do if((k[a+4>>2]&-8|0)!=(e|0)){d=e<<((d|0)==31?0:25-(d>>>1)|0);while(1){c=a+16+(d>>>31<<2)|0;b=k[c>>2]|0;if(!b)break;if((k[b+4>>2]&-8|0)==(e|0)){L=b;break j}else{d=d<<1;a=b}}if(c>>>0<(k[100]|0)>>>0)Ma();else{k[c>>2]=p;k[r+(m+24)>>2]=a;k[r+(m+12)>>2]=p;k[r+(m+8)>>2]=p;break h}}else L=a;while(0);a=L+8|0;b=k[a>>2]|0;K=k[100]|0;if(b>>>0>=K>>>0&L>>>0>=K>>>0){k[b+12>>2]=p;k[a>>2]=p;k[r+(m+8)>>2]=b;k[r+(m+12)>>2]=L;k[r+(m+24)>>2]=0;break}else Ma()}else{L=(k[99]|0)+l|0;k[99]=L;k[102]=p;k[r+(m+4)>>2]=L|1}while(0);L=r+(n|8)|0;return L|0}else b=832;while(1){a=k[b>>2]|0;if(a>>>0<=g>>>0?(C=k[b+4>>2]|0,D=a+C|0,D>>>0>g>>>0):0)break;b=k[b+8>>2]|0}b=a+(C+-39)|0;b=a+(C+-47+((b&7|0)==0?0:0-b&7))|0;e=g+16|0;b=b>>>0<e>>>0?g:b;a=b+8|0;c=r+8|0;c=(c&7|0)==0?0:0-c&7;L=q+-40-c|0;k[102]=r+c;k[99]=L;k[r+(c+4)>>2]=L|1;k[r+(q+-36)>>2]=40;k[103]=k[218];c=b+4|0;k[c>>2]=27;k[a>>2]=k[208];k[a+4>>2]=k[209];k[a+8>>2]=k[210];k[a+12>>2]=k[211];k[208]=r;k[209]=q;k[211]=0;k[210]=a;a=b+28|0;k[a>>2]=7;if((b+32|0)>>>0<D>>>0)do{L=a;a=a+4|0;k[a>>2]=7}while((L+8|0)>>>0<D>>>0);if((b|0)!=(g|0)){f=b-g|0;k[c>>2]=k[c>>2]&-2;k[g+4>>2]=f|1;k[b>>2]=f;a=f>>>3;if(f>>>0<256){b=a<<1;d=424+(b<<2)|0;c=k[96]|0;a=1<<a;if(c&a){a=424+(b+2<<2)|0;b=k[a>>2]|0;if(b>>>0<(k[100]|0)>>>0)Ma();else{F=a;G=b}}else{k[96]=c|a;F=424+(b+2<<2)|0;G=d}k[F>>2]=g;k[G+12>>2]=g;k[g+8>>2]=G;k[g+12>>2]=d;break}a=f>>>8;if(a)if(f>>>0>16777215)d=31;else{K=(a+1048320|0)>>>16&8;L=a<<K;J=(L+520192|0)>>>16&4;L=L<<J;d=(L+245760|0)>>>16&2;d=14-(J|K|d)+(L<<d>>>15)|0;d=f>>>(d+7|0)&1|d<<1}else d=0;c=688+(d<<2)|0;k[g+28>>2]=d;k[g+20>>2]=0;k[e>>2]=0;a=k[97]|0;b=1<<d;if(!(a&b)){k[97]=a|b;k[c>>2]=g;k[g+24>>2]=c;k[g+12>>2]=g;k[g+8>>2]=g;break}a=k[c>>2]|0;k:do if((k[a+4>>2]&-8|0)!=(f|0)){d=f<<((d|0)==31?0:25-(d>>>1)|0);while(1){c=a+16+(d>>>31<<2)|0;b=k[c>>2]|0;if(!b)break;if((k[b+4>>2]&-8|0)==(f|0)){H=b;break k}else{d=d<<1;a=b}}if(c>>>0<(k[100]|0)>>>0)Ma();else{k[c>>2]=g;k[g+24>>2]=a;k[g+12>>2]=g;k[g+8>>2]=g;break g}}else H=a;while(0);a=H+8|0;b=k[a>>2]|0;L=k[100]|0;if(b>>>0>=L>>>0&H>>>0>=L>>>0){k[b+12>>2]=g;k[a>>2]=g;k[g+8>>2]=b;k[g+12>>2]=H;k[g+24>>2]=0;break}else Ma()}}else{L=k[100]|0;if((L|0)==0|r>>>0<L>>>0)k[100]=r;k[208]=r;k[209]=q;k[211]=0;k[105]=k[214];k[104]=-1;a=0;do{L=a<<1;K=424+(L<<2)|0;k[424+(L+3<<2)>>2]=K;k[424+(L+2<<2)>>2]=K;a=a+1|0}while((a|0)!=32);L=r+8|0;L=(L&7|0)==0?0:0-L&7;K=q+-40-L|0;k[102]=r+L;k[99]=K;k[r+(L+4)>>2]=K|1;k[r+(q+-36)>>2]=40;k[103]=k[218]}while(0);a=k[99]|0;if(a>>>0>o>>>0){K=a-o|0;k[99]=K;L=k[102]|0;k[102]=L+o;k[L+(o+4)>>2]=K|1;k[L+4>>2]=o|3;L=L+8|0;return L|0}}if(!(k[56]|0))a=268;else{a=(Ga()|0)+60|0;a=k[a>>2]|0}k[a>>2]=12;L=0;return L|0}function $d(a){a=a|0;var b=0,c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0;if(!a)return;b=a+-8|0;h=k[100]|0;if(b>>>0<h>>>0)Ma();c=k[a+-4>>2]|0;d=c&3;if((d|0)==1)Ma();o=c&-8;q=a+(o+-8)|0;do if(!(c&1)){b=k[b>>2]|0;if(!d)return;i=-8-b|0;l=a+i|0;m=b+o|0;if(l>>>0<h>>>0)Ma();if((l|0)==(k[101]|0)){b=a+(o+-4)|0;c=k[b>>2]|0;if((c&3|0)!=3){u=l;f=m;break}k[98]=m;k[b>>2]=c&-2;k[a+(i+4)>>2]=m|1;k[q>>2]=m;return}e=b>>>3;if(b>>>0<256){d=k[a+(i+8)>>2]|0;c=k[a+(i+12)>>2]|0;b=424+(e<<1<<2)|0;if((d|0)!=(b|0)){if(d>>>0<h>>>0)Ma();if((k[d+12>>2]|0)!=(l|0))Ma()}if((c|0)==(d|0)){k[96]=k[96]&~(1<<e);u=l;f=m;break}if((c|0)!=(b|0)){if(c>>>0<h>>>0)Ma();b=c+8|0;if((k[b>>2]|0)==(l|0))g=b;else Ma()}else g=c+8|0;k[d+12>>2]=c;k[g>>2]=d;u=l;f=m;break}g=k[a+(i+24)>>2]|0;d=k[a+(i+12)>>2]|0;do if((d|0)==(l|0)){c=a+(i+20)|0;b=k[c>>2]|0;if(!b){c=a+(i+16)|0;b=k[c>>2]|0;if(!b){j=0;break}}while(1){d=b+20|0;e=k[d>>2]|0;if(e){b=e;c=d;continue}d=b+16|0;e=k[d>>2]|0;if(!e)break;else{b=e;c=d}}if(c>>>0<h>>>0)Ma();else{k[c>>2]=0;j=b;break}}else{e=k[a+(i+8)>>2]|0;if(e>>>0<h>>>0)Ma();b=e+12|0;if((k[b>>2]|0)!=(l|0))Ma();c=d+8|0;if((k[c>>2]|0)==(l|0)){k[b>>2]=d;k[c>>2]=e;j=d;break}else Ma()}while(0);if(g){b=k[a+(i+28)>>2]|0;c=688+(b<<2)|0;if((l|0)==(k[c>>2]|0)){k[c>>2]=j;if(!j){k[97]=k[97]&~(1<<b);u=l;f=m;break}}else{if(g>>>0<(k[100]|0)>>>0)Ma();b=g+16|0;if((k[b>>2]|0)==(l|0))k[b>>2]=j;else k[g+20>>2]=j;if(!j){u=l;f=m;break}}c=k[100]|0;if(j>>>0<c>>>0)Ma();k[j+24>>2]=g;b=k[a+(i+16)>>2]|0;do if(b)if(b>>>0<c>>>0)Ma();else{k[j+16>>2]=b;k[b+24>>2]=j;break}while(0);b=k[a+(i+20)>>2]|0;if(b)if(b>>>0<(k[100]|0)>>>0)Ma();else{k[j+20>>2]=b;k[b+24>>2]=j;u=l;f=m;break}else{u=l;f=m}}else{u=l;f=m}}else{u=b;f=o}while(0);if(u>>>0>=q>>>0)Ma();b=a+(o+-4)|0;c=k[b>>2]|0;if(!(c&1))Ma();if(!(c&2)){if((q|0)==(k[102]|0)){t=(k[99]|0)+f|0;k[99]=t;k[102]=u;k[u+4>>2]=t|1;if((u|0)!=(k[101]|0))return;k[101]=0;k[98]=0;return}if((q|0)==(k[101]|0)){t=(k[98]|0)+f|0;k[98]=t;k[101]=u;k[u+4>>2]=t|1;k[u+t>>2]=t;return}f=(c&-8)+f|0;e=c>>>3;do if(c>>>0>=256){g=k[a+(o+16)>>2]|0;b=k[a+(o|4)>>2]|0;do if((b|0)==(q|0)){c=a+(o+12)|0;b=k[c>>2]|0;if(!b){c=a+(o+8)|0;b=k[c>>2]|0;if(!b){p=0;break}}while(1){d=b+20|0;e=k[d>>2]|0;if(e){b=e;c=d;continue}d=b+16|0;e=k[d>>2]|0;if(!e)break;else{b=e;c=d}}if(c>>>0<(k[100]|0)>>>0)Ma();else{k[c>>2]=0;p=b;break}}else{c=k[a+o>>2]|0;if(c>>>0<(k[100]|0)>>>0)Ma();d=c+12|0;if((k[d>>2]|0)!=(q|0))Ma();e=b+8|0;if((k[e>>2]|0)==(q|0)){k[d>>2]=b;k[e>>2]=c;p=b;break}else Ma()}while(0);if(g){b=k[a+(o+20)>>2]|0;c=688+(b<<2)|0;if((q|0)==(k[c>>2]|0)){k[c>>2]=p;if(!p){k[97]=k[97]&~(1<<b);break}}else{if(g>>>0<(k[100]|0)>>>0)Ma();b=g+16|0;if((k[b>>2]|0)==(q|0))k[b>>2]=p;else k[g+20>>2]=p;if(!p)break}c=k[100]|0;if(p>>>0<c>>>0)Ma();k[p+24>>2]=g;b=k[a+(o+8)>>2]|0;do if(b)if(b>>>0<c>>>0)Ma();else{k[p+16>>2]=b;k[b+24>>2]=p;break}while(0);b=k[a+(o+12)>>2]|0;if(b)if(b>>>0<(k[100]|0)>>>0)Ma();else{k[p+20>>2]=b;k[b+24>>2]=p;break}}}else{d=k[a+o>>2]|0;c=k[a+(o|4)>>2]|0;b=424+(e<<1<<2)|0;if((d|0)!=(b|0)){if(d>>>0<(k[100]|0)>>>0)Ma();if((k[d+12>>2]|0)!=(q|0))Ma()}if((c|0)==(d|0)){k[96]=k[96]&~(1<<e);break}if((c|0)!=(b|0)){if(c>>>0<(k[100]|0)>>>0)Ma();b=c+8|0;if((k[b>>2]|0)==(q|0))n=b;else Ma()}else n=c+8|0;k[d+12>>2]=c;k[n>>2]=d}while(0);k[u+4>>2]=f|1;k[u+f>>2]=f;if((u|0)==(k[101]|0)){k[98]=f;return}}else{k[b>>2]=c&-2;k[u+4>>2]=f|1;k[u+f>>2]=f}b=f>>>3;if(f>>>0<256){c=b<<1;e=424+(c<<2)|0;d=k[96]|0;b=1<<b;if(d&b){b=424+(c+2<<2)|0;c=k[b>>2]|0;if(c>>>0<(k[100]|0)>>>0)Ma();else{r=b;s=c}}else{k[96]=d|b;r=424+(c+2<<2)|0;s=e}k[r>>2]=u;k[s+12>>2]=u;k[u+8>>2]=s;k[u+12>>2]=e;return}b=f>>>8;if(b)if(f>>>0>16777215)e=31;else{r=(b+1048320|0)>>>16&8;s=b<<r;q=(s+520192|0)>>>16&4;s=s<<q;e=(s+245760|0)>>>16&2;e=14-(q|r|e)+(s<<e>>>15)|0;e=f>>>(e+7|0)&1|e<<1}else e=0;b=688+(e<<2)|0;k[u+28>>2]=e;k[u+20>>2]=0;k[u+16>>2]=0;c=k[97]|0;d=1<<e;a:do if(c&d){b=k[b>>2]|0;b:do if((k[b+4>>2]&-8|0)!=(f|0)){e=f<<((e|0)==31?0:25-(e>>>1)|0);while(1){d=b+16+(e>>>31<<2)|0;c=k[d>>2]|0;if(!c)break;if((k[c+4>>2]&-8|0)==(f|0)){t=c;break b}else{e=e<<1;b=c}}if(d>>>0<(k[100]|0)>>>0)Ma();else{k[d>>2]=u;k[u+24>>2]=b;k[u+12>>2]=u;k[u+8>>2]=u;break a}}else t=b;while(0);b=t+8|0;c=k[b>>2]|0;s=k[100]|0;if(c>>>0>=s>>>0&t>>>0>=s>>>0){k[c+12>>2]=u;k[b>>2]=u;k[u+8>>2]=c;k[u+12>>2]=t;k[u+24>>2]=0;break}else Ma()}else{k[97]=c|d;k[b>>2]=u;k[u+24>>2]=b;k[u+12>>2]=u;k[u+8>>2]=u}while(0);u=(k[104]|0)+-1|0;k[104]=u;if(!u)b=840;else return;while(1){b=k[b>>2]|0;if(!b)break;else b=b+8|0}k[104]=-1;return}function ae(){}function be(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;d=b-d-(c>>>0>a>>>0|0)>>>0;return (L=d,a-c>>>0|0)|0}function ce(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0;d=a+c|0;if((c|0)>=20){b=b&255;f=a&3;g=b|b<<8|b<<16|b<<24;e=d&~3;if(f){f=a+4-f|0;while((a|0)<(f|0)){i[a>>0]=b;a=a+1|0}}while((a|0)<(e|0)){k[a>>2]=g;a=a+4|0}}while((a|0)<(d|0)){i[a>>0]=b;a=a+1|0}return a-c|0}function de(a,b,c){a=a|0;b=b|0;c=c|0;if((c|0)<32){L=b>>>c;return a>>>c|(b&(1<<c)-1)<<32-c}L=0;return b>>>c-32|0}function ee(a,b,c){a=a|0;b=b|0;c=c|0;if((c|0)<32){L=b<<c|(a&(1<<c)-1<<32-c)>>>32-c;return a<<c}L=a<<c-32;return 0}function fe(a,b,c){a=a|0;b=b|0;c=c|0;var d=0;if((c|0)>=4096)return Ca(a|0,b|0,c|0)|0;d=a|0;if((a&3)==(b&3)){while(a&3){if(!c)return d|0;i[a>>0]=i[b>>0]|0;a=a+1|0;b=b+1|0;c=c-1|0}while((c|0)>=4){k[a>>2]=k[b>>2];a=a+4|0;b=b+4|0;c=c-4|0}}while((c|0)>0){i[a>>0]=i[b>>0]|0;a=a+1|0;b=b+1|0;c=c-1|0}return d|0}function ge(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;c=a+c>>>0;return (L=b+d+(c>>>0<a>>>0|0)>>>0,c|0)|0}function he(a,b,c){a=a|0;b=b|0;c=c|0;var d=0;if((b|0)<(a|0)&(a|0)<(b+c|0)){d=a;b=b+c|0;a=a+c|0;while((c|0)>0){a=a-1|0;b=b-1|0;c=c-1|0;i[a>>0]=i[b>>0]|0}a=d}else fe(a,b,c)|0;return a|0}function ie(a,b,c){a=a|0;b=b|0;c=c|0;if((c|0)<32){L=b>>c;return a>>>c|(b&(1<<c)-1)<<32-c}L=(b|0)<0?-1:0;return b>>c-32|0}function je(a){a=a|0;var b=0;b=i[v+(a&255)>>0]|0;if((b|0)<8)return b|0;b=i[v+(a>>8&255)>>0]|0;if((b|0)<8)return b+8|0;b=i[v+(a>>16&255)>>0]|0;if((b|0)<8)return b+16|0;return (i[v+(a>>>24)>>0]|0)+24|0}function ke(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0;f=a&65535;e=b&65535;c=ha(e,f)|0;d=a>>>16;a=(c>>>16)+(ha(e,d)|0)|0;e=b>>>16;b=ha(e,f)|0;return (L=(a>>>16)+(ha(e,d)|0)+(((a&65535)+b|0)>>>16)|0,a+b<<16|c&65535|0)|0}function le(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0;j=b>>31|((b|0)<0?-1:0)<<1;i=((b|0)<0?-1:0)>>31|((b|0)<0?-1:0)<<1;f=d>>31|((d|0)<0?-1:0)<<1;e=((d|0)<0?-1:0)>>31|((d|0)<0?-1:0)<<1;h=be(j^a,i^b,j,i)|0;g=L;a=f^j;b=e^i;return be((qe(h,g,be(f^c,e^d,f,e)|0,L,0)|0)^a,L^b,a,b)|0}function me(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0;e=r;r=r+16|0;h=e|0;g=b>>31|((b|0)<0?-1:0)<<1;f=((b|0)<0?-1:0)>>31|((b|0)<0?-1:0)<<1;j=d>>31|((d|0)<0?-1:0)<<1;i=((d|0)<0?-1:0)>>31|((d|0)<0?-1:0)<<1;a=be(g^a,f^b,g,f)|0;b=L;qe(a,b,be(j^c,i^d,j,i)|0,L,h)|0;d=be(k[h>>2]^g,k[h+4>>2]^f,g,f)|0;c=L;r=e;return (L=c,d)|0}function ne(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0;e=a;f=c;c=ke(e,f)|0;a=L;return (L=(ha(b,f)|0)+(ha(d,e)|0)+a|a&0,c|0|0)|0}function oe(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;return qe(a,b,c,d,0)|0}function pe(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0;f=r;r=r+16|0;e=f|0;qe(a,b,c,d,e)|0;r=f;return (L=k[e+4>>2]|0,k[e>>2]|0)|0}function qe(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0,j=0,l=0,m=0,n=0,o=0,p=0;l=a;i=b;j=i;g=c;n=d;h=n;if(!j){f=(e|0)!=0;if(!h){if(f){k[e>>2]=(l>>>0)%(g>>>0);k[e+4>>2]=0}n=0;e=(l>>>0)/(g>>>0)>>>0;return (L=n,e)|0}else{if(!f){n=0;e=0;return (L=n,e)|0}k[e>>2]=a|0;k[e+4>>2]=b&0;n=0;e=0;return (L=n,e)|0}}f=(h|0)==0;do if(g){if(!f){f=(ja(h|0)|0)-(ja(j|0)|0)|0;if(f>>>0<=31){m=f+1|0;h=31-f|0;b=f-31>>31;g=m;a=l>>>(m>>>0)&b|j<<h;b=j>>>(m>>>0)&b;f=0;h=l<<h;break}if(!e){n=0;e=0;return (L=n,e)|0}k[e>>2]=a|0;k[e+4>>2]=i|b&0;n=0;e=0;return (L=n,e)|0}f=g-1|0;if(f&g){h=(ja(g|0)|0)+33-(ja(j|0)|0)|0;p=64-h|0;m=32-h|0;i=m>>31;o=h-32|0;b=o>>31;g=h;a=m-1>>31&j>>>(o>>>0)|(j<<m|l>>>(h>>>0))&b;b=b&j>>>(h>>>0);f=l<<p&i;h=(j<<p|l>>>(o>>>0))&i|l<<m&h-33>>31;break}if(e){k[e>>2]=f&l;k[e+4>>2]=0}if((g|0)==1){o=i|b&0;p=a|0|0;return (L=o,p)|0}else{p=je(g|0)|0;o=j>>>(p>>>0)|0;p=j<<32-p|l>>>(p>>>0)|0;return (L=o,p)|0}}else{if(f){if(e){k[e>>2]=(j>>>0)%(g>>>0);k[e+4>>2]=0}o=0;p=(j>>>0)/(g>>>0)>>>0;return (L=o,p)|0}if(!l){if(e){k[e>>2]=0;k[e+4>>2]=(j>>>0)%(h>>>0)}o=0;p=(j>>>0)/(h>>>0)>>>0;return (L=o,p)|0}f=h-1|0;if(!(f&h)){if(e){k[e>>2]=a|0;k[e+4>>2]=f&j|b&0}o=0;p=j>>>((je(h|0)|0)>>>0);return (L=o,p)|0}f=(ja(h|0)|0)-(ja(j|0)|0)|0;if(f>>>0<=30){b=f+1|0;h=31-f|0;g=b;a=j<<h|l>>>(b>>>0);b=j>>>(b>>>0);f=0;h=l<<h;break}if(!e){o=0;p=0;return (L=o,p)|0}k[e>>2]=a|0;k[e+4>>2]=i|b&0;o=0;p=0;return (L=o,p)|0}while(0);if(!g){j=h;i=0;h=0}else{m=c|0|0;l=n|d&0;j=ge(m|0,l|0,-1,-1)|0;c=L;i=h;h=0;do{d=i;i=f>>>31|i<<1;f=h|f<<1;d=a<<1|d>>>31|0;n=a>>>31|b<<1|0;be(j,c,d,n)|0;p=L;o=p>>31|((p|0)<0?-1:0)<<1;h=o&1;a=be(d,n,o&m,(((p|0)<0?-1:0)>>31|((p|0)<0?-1:0)<<1)&l)|0;b=L;g=g-1|0}while((g|0)!=0);j=i;i=0}g=0;if(e){k[e>>2]=a;k[e+4>>2]=b}o=(f|0)>>>31|(j|g)<<1|(g<<1|f>>>31)&0|i;p=(f<<1|0>>>31)&-2|h;return (L=o,p)|0}function re(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;return Ta[a&7](b|0,c|0,d|0)|0}function se(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;Ua[a&3](b|0,c|0,d|0,e|0,f|0)}function te(a,b){a=a|0;b=b|0;Va[a&15](b|0)}function ue(a,b){a=a|0;b=b|0;return Wa[a&3](b|0)|0}function ve(a){a=a|0;Xa[a&0]()}function we(a,b,c,d,e,f,g){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=g|0;Ya[a&3](b|0,c|0,d|0,e|0,f|0,g|0)}function xe(a,b,c){a=a|0;b=b|0;c=c|0;return Za[a&7](b|0,c|0)|0}function ye(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;_a[a&3](b|0,c|0,d|0,e|0)}function ze(a,b,c){a=a|0;b=b|0;c=c|0;ka(0);return 0}function Ae(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;ka(1)}function Be(a){a=a|0;ka(2)}function Ce(a){a=a|0;ka(3);return 0}function De(){ka(4)}function Ee(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;ka(5)}function Fe(a,b){a=a|0;b=b|0;ka(6);return 0}function Ge(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;ka(7)}\r\nfunction Qb(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0,U=0,V=0,W=0,X=0;T=b;a:while(1){u=T;v=T+-20|0;w=T+-40|0;Q=T+-16|0;P=T+-12|0;R=T+-4|0;S=T+-8|0;X=a;b:while(1){s=X;a=u-s|0;switch((a|0)/20|0|0){case 2:{t=4;break a}case 3:{t=23;break a}case 4:{t=24;break a}case 5:{t=25;break a}case 1:case 0:{t=262;break a}default:{}}if((a|0)<140){t=27;break a}h=(a|0)/40|0;j=X+(h*20|0)|0;if((a|0)>19980){a=(a|0)/80|0;a=bc(X,X+(a*20|0)|0,j,X+((a+h|0)*20|0)|0,v)|0}else a=$b(X,j,v)|0;q=k[X>>2]|0;b=k[j>>2]|0;c:do if((q|0)<(b|0))e=v;else{e=(q|0)==(b|0);if(e?(k[X+4>>2]|0)<(k[X+(h*20|0)+4>>2]|0):0){e=v;break}do if((b|0)>=(q|0)){if(e?(x=k[X+(h*20|0)+4>>2]|0,y=k[X+4>>2]|0,(x|0)<(y|0)):0){e=x;f=y;t=82}else{g=k[X+8>>2]|0;f=k[X+(h*20|0)+8>>2]|0;if((g|0)<(f|0)){e=v;break c}if((g|0)==(f|0)?(k[X+12>>2]|0)<(k[X+(h*20|0)+12>>2]|0):0){e=v;break c}if(e){e=k[X+(h*20|0)+4>>2]|0;f=k[X+4>>2]|0;t=82}else{e=g;t=85}}if((t|0)==82){t=0;if((e|0)<(f|0))break;if((f|0)>=(e|0)){f=k[X+(h*20|0)+8>>2]|0;e=k[X+8>>2]|0;t=85}}if((t|0)==85){if((f|0)<(e|0))break;if((f|0)==(e|0)?(k[X+(h*20|0)+12>>2]|0)<(k[X+12>>2]|0):0)break}if((k[X+16>>2]|0)<(k[X+(h*20|0)+16>>2]|0)){e=v;break c}}while(0);d:do if((X|0)!=(w|0)){o=X+(h*20|0)+4|0;n=X+(h*20|0)+8|0;p=X+(h*20|0)+16|0;l=X+(h*20|0)+12|0;e=w;m=v;e:while(1){i=k[e>>2]|0;if((i|0)<(b|0)){b=i;break}f=(i|0)==(b|0);if(f?(k[m+-16>>2]|0)<(k[o>>2]|0):0)break;do if((b|0)>=(i|0)){if(f?(H=k[o>>2]|0,I=k[m+-16>>2]|0,(H|0)<(I|0)):0){f=H;g=I;t=184}else{h=k[m+-12>>2]|0;g=k[n>>2]|0;if((h|0)<(g|0)){b=i;break e}if((h|0)==(g|0)?(k[m+-8>>2]|0)<(k[l>>2]|0):0){b=i;break e}if(f){f=k[o>>2]|0;g=k[m+-16>>2]|0;t=184}else{f=h;t=187}}if((t|0)==184){t=0;if((f|0)<(g|0))break;if((g|0)>=(f|0)){g=k[n>>2]|0;f=k[m+-12>>2]|0;t=187}}if((t|0)==187){if((g|0)<(f|0))break;if((g|0)==(f|0)?(k[l>>2]|0)<(k[m+-8>>2]|0):0)break}if((k[m+-4>>2]|0)<(k[p>>2]|0)){b=i;break e}}while(0);f=e+-20|0;if((X|0)==(f|0))break d;else{m=e;e=f}}t=X+4|0;o=k[t>>2]|0;k[X>>2]=b;p=m+-16|0;k[t>>2]=k[p>>2];k[e>>2]=q;k[p>>2]=o;q=X+8|0;p=k[q>>2]|0;o=X+12|0;t=k[o>>2]|0;r=m+-12|0;k[q>>2]=k[r>>2];q=m+-8|0;k[o>>2]=k[q>>2];k[r>>2]=p;k[q>>2]=t;q=X+16|0;t=m+-4|0;r=k[q>>2]|0;k[q>>2]=k[t>>2];k[t>>2]=r;a=a+1|0;break c}while(0);a=X+20|0;o=k[v>>2]|0;f:do if((q|0)>=(o|0)){b=(q|0)==(o|0);if(b?(k[X+4>>2]|0)<(k[Q>>2]|0):0)break;do if((o|0)>=(q|0)){if(b?(z=k[Q>>2]|0,A=k[X+4>>2]|0,(z|0)<(A|0)):0){b=z;e=A;t=102}else{f=k[X+8>>2]|0;e=k[P>>2]|0;if((f|0)<(e|0))break f;if((f|0)==(e|0)?(k[X+12>>2]|0)<(k[S>>2]|0):0)break f;if(b){b=k[Q>>2]|0;e=k[X+4>>2]|0;t=102}else{b=f;t=105}}if((t|0)==102){t=0;if((b|0)<(e|0))break;if((e|0)>=(b|0)){e=k[P>>2]|0;b=k[X+8>>2]|0;t=105}}if((t|0)==105){if((e|0)<(b|0))break;if((e|0)==(b|0)?(k[S>>2]|0)<(k[X+12>>2]|0):0)break}if((k[X+16>>2]|0)<(k[R>>2]|0))break f}while(0);if((a|0)==(v|0)){t=262;break a}j=X+4|0;i=X+8|0;l=X+16|0;m=X+12|0;n=X;h=a;g:while(1){g=n+20|0;a=k[g>>2]|0;if((q|0)<(a|0))break;f=(q|0)==(a|0);if(f?(k[j>>2]|0)<(k[n+24>>2]|0):0){a=q;break}h:do if((a|0)>=(q|0)){if(f?(B=k[n+24>>2]|0,C=k[j>>2]|0,(B|0)<(C|0)):0){b=B;e=C;t=122}else t=117;do if((t|0)==117){e=k[i>>2]|0;b=k[n+28>>2]|0;if((e|0)<(b|0))break g;if((e|0)==(b|0)?(k[m>>2]|0)<(k[n+32>>2]|0):0)break g;if(!f){t=125;break}b=k[n+24>>2]|0;e=k[j>>2]|0;t=122}while(0);do if((t|0)==122){t=0;if((b|0)<(e|0))break h;if((e|0)<(b|0))break;b=k[n+28>>2]|0;e=k[i>>2]|0;t=125}while(0);do if((t|0)==125){if((b|0)<(e|0))break h;if((b|0)!=(e|0))break;if((k[n+32>>2]|0)<(k[m>>2]|0))break h}while(0);if((k[l>>2]|0)<(k[n+36>>2]|0))break g}while(0);a=h+20|0;if((a|0)==(v|0)){t=262;break a}else{n=h;h=a}}s=n+24|0;r=k[s>>2]|0;k[g>>2]=o;k[s>>2]=k[Q>>2];k[v>>2]=a;k[Q>>2]=r;r=n+28|0;a=k[r>>2]|0;s=n+32|0;t=k[s>>2]|0;k[r>>2]=k[P>>2];k[s>>2]=k[S>>2];k[P>>2]=a;k[S>>2]=t;t=n+36|0;a=k[t>>2]|0;k[t>>2]=k[R>>2];k[R>>2]=a;a=n+40|0}while(0);if((a|0)==(v|0)){t=262;break a}o=X+4|0;p=X+12|0;n=X+8|0;q=X+16|0;h=v;while(1){m=k[X>>2]|0;b=k[a>>2]|0;i:do if((m|0)<(b|0)){l=a;j=a}else while(1){g=(m|0)==(b|0);if(g?(k[o>>2]|0)<(k[a+4>>2]|0):0){l=a;b=m;j=a;break i}j:do if((b|0)>=(m|0)){if(g?(D=k[a+4>>2]|0,E=k[o>>2]|0,(D|0)<(E|0)):0){e=D;f=E;t=145}else t=140;do if((t|0)==140){f=k[n>>2]|0;e=k[a+8>>2]|0;if((f|0)<(e|0)){l=a;j=a;break i}if((f|0)==(e|0)?(k[p>>2]|0)<(k[a+12>>2]|0):0){l=a;j=a;break i}if(!g){t=148;break}e=k[a+4>>2]|0;f=k[o>>2]|0;t=145}while(0);do if((t|0)==145){t=0;if((e|0)<(f|0))break j;if((f|0)<(e|0))break;e=k[a+8>>2]|0;f=k[n>>2]|0;t=148}while(0);do if((t|0)==148){if((e|0)<(f|0))break j;if((e|0)!=(f|0))break;if((k[a+12>>2]|0)<(k[p>>2]|0))break j}while(0);if((k[q>>2]|0)<(k[a+16>>2]|0)){l=a;j=a;break i}}while(0);a=a+20|0;b=k[a>>2]|0;if((m|0)<(b|0)){l=a;j=a;break}}while(0);k:while(1){i=h+-20|0;g=k[i>>2]|0;if((m|0)<(g|0)){h=i;continue}f=(m|0)==(g|0);if(f?(k[o>>2]|0)<(k[h+-16>>2]|0):0){h=i;continue}if((g|0)<(m|0))break;if(f?(F=k[h+-16>>2]|0,G=k[o>>2]|0,(F|0)<(G|0)):0){a=F;e=G;t=164}else t=159;do if((t|0)==159){e=k[n>>2]|0;a=k[h+-12>>2]|0;if((e|0)<(a|0)){h=i;continue k}if((e|0)==(a|0)?(k[p>>2]|0)<(k[h+-8>>2]|0):0){h=i;continue k}if(!f){t=167;break}a=k[h+-16>>2]|0;e=k[o>>2]|0;t=164}while(0);do if((t|0)==164){t=0;if((a|0)<(e|0))break k;if((e|0)<(a|0))break;a=k[h+-12>>2]|0;e=k[n>>2]|0;t=167}while(0);do if((t|0)==167){if((a|0)<(e|0))break k;if((a|0)!=(e|0))break;if((k[h+-8>>2]|0)<(k[p>>2]|0))break k}while(0);if((k[q>>2]|0)<(k[h+-4>>2]|0))h=i;else break}if(j>>>0>=i>>>0){X=j;continue b}m=j+4|0;r=k[m>>2]|0;k[l>>2]=g;t=h+-16|0;k[m>>2]=k[t>>2];k[i>>2]=b;k[t>>2]=r;t=j+8|0;r=k[t>>2]|0;m=j+12|0;a=k[m>>2]|0;s=h+-12|0;k[t>>2]=k[s>>2];t=h+-8|0;k[m>>2]=k[t>>2];k[s>>2]=r;k[t>>2]=a;t=j+16|0;a=h+-4|0;h=k[t>>2]|0;k[t>>2]=k[a>>2];k[a>>2]=h;a=j+20|0;h=i}}while(0);b=X+20|0;l:do if(b>>>0<e>>>0)while(1){m=j+12|0;p=k[j>>2]|0;n=j+4|0;l=j+8|0;o=j+16|0;r=b;m:while(1){q=k[r>>2]|0;do if((q|0)>=(p|0)){b=(q|0)==(p|0);if(b?(k[r+4>>2]|0)<(k[n>>2]|0):0)break;if((p|0)<(q|0))break m;if(b?(J=k[n>>2]|0,K=k[r+4>>2]|0,(J|0)<(K|0)):0){b=J;f=K;t=207}else{g=k[r+8>>2]|0;f=k[l>>2]|0;if((g|0)<(f|0))break;if((g|0)==(f|0)?(k[r+12>>2]|0)<(k[m>>2]|0):0)break;if(b){b=k[n>>2]|0;f=k[r+4>>2]|0;t=207}else{b=g;t=210}}if((t|0)==207){t=0;if((b|0)<(f|0))break m;if((f|0)>=(b|0)){f=k[l>>2]|0;b=k[r+8>>2]|0;t=210}}if((t|0)==210){if((f|0)<(b|0))break m;if((f|0)==(b|0)?(k[m>>2]|0)<(k[r+12>>2]|0):0)break m}if((k[r+16>>2]|0)>=(k[o>>2]|0))break m}while(0);r=r+20|0}f=e+-20|0;b=k[f>>2]|0;n:do if((b|0)<(p|0)){h=f;g=f}else while(1){g=(b|0)==(p|0);if(g?(k[e+-16>>2]|0)<(k[n>>2]|0):0){h=f;g=f;b=p;break n}do if((p|0)>=(b|0)){if(g?(L=k[n>>2]|0,M=k[e+-16>>2]|0,(L|0)<(M|0)):0){g=L;h=M;t=225}else{i=k[e+-12>>2]|0;h=k[l>>2]|0;if((i|0)<(h|0)){h=f;g=f;break n}if((i|0)==(h|0)?(k[e+-8>>2]|0)<(k[m>>2]|0):0){h=f;g=f;break n}if(g){g=k[n>>2]|0;h=k[e+-16>>2]|0;t=225}else{g=i;t=228}}if((t|0)==225){t=0;if((g|0)<(h|0))break;if((h|0)>=(g|0)){h=k[l>>2]|0;g=k[e+-12>>2]|0;t=228}}if((t|0)==228){if((h|0)<(g|0))break;if((h|0)==(g|0)?(k[m>>2]|0)<(k[e+-8>>2]|0):0)break}if((k[e+-4>>2]|0)<(k[o>>2]|0)){h=f;g=f;break n}}while(0);e=f+-20|0;b=k[e>>2]|0;if((b|0)<(p|0)){h=e;g=e;e=f;break}else{t=f;f=e;e=t}}while(0);if(r>>>0>h>>>0){b=r;break l}o=r+4|0;p=k[o>>2]|0;k[r>>2]=b;t=e+-16|0;k[o>>2]=k[t>>2];k[g>>2]=q;k[t>>2]=p;t=r+8|0;p=k[t>>2]|0;o=r+12|0;b=k[o>>2]|0;q=e+-12|0;k[t>>2]=k[q>>2];t=e+-8|0;k[o>>2]=k[t>>2];k[q>>2]=p;k[t>>2]=b;t=r+16|0;b=e+-4|0;e=k[t>>2]|0;k[t>>2]=k[b>>2];k[b>>2]=e;b=r+20|0;e=h;j=(j|0)==(r|0)?h:j;a=a+1|0}while(0);o:do if((b|0)!=(j|0)){h=k[j>>2]|0;i=k[b>>2]|0;do if((h|0)>=(i|0)){e=(h|0)==(i|0);if(e?(k[j+4>>2]|0)<(k[b+4>>2]|0):0)break;if((i|0)<(h|0))break o;if(e?(N=k[b+4>>2]|0,O=k[j+4>>2]|0,(N|0)<(O|0)):0){e=N;f=O;t=247}else{g=k[j+8>>2]|0;f=k[b+8>>2]|0;if((g|0)<(f|0))break;if((g|0)==(f|0)?(k[j+12>>2]|0)<(k[b+12>>2]|0):0)break;if(e){e=k[b+4>>2]|0;f=k[j+4>>2]|0;t=247}else{e=g;t=250}}if((t|0)==247){t=0;if((e|0)<(f|0))break o;if((f|0)>=(e|0)){f=k[b+8>>2]|0;e=k[j+8>>2]|0;t=250}}if((t|0)==250){if((f|0)<(e|0))break o;if((f|0)==(e|0)?(k[b+12>>2]|0)<(k[j+12>>2]|0):0)break o}if((k[j+16>>2]|0)>=(k[b+16>>2]|0))break o}while(0);o=b+4|0;p=k[o>>2]|0;k[b>>2]=h;q=j+4|0;k[o>>2]=k[q>>2];k[j>>2]=i;k[q>>2]=p;q=b+8|0;p=k[q>>2]|0;o=b+12|0;t=k[o>>2]|0;r=j+8|0;k[q>>2]=k[r>>2];q=j+12|0;k[o>>2]=k[q>>2];k[r>>2]=p;k[q>>2]=t;q=b+16|0;t=j+16|0;r=k[q>>2]|0;k[q>>2]=k[t>>2];k[t>>2]=r;a=a+1|0}while(0);if(!a){e=cc(X,b)|0;a=b+20|0;if(cc(a,T)|0){t=257;break}if(e){X=a;continue}}t=b;if((t-s|0)>=(u-t|0)){t=261;break}Qb(X,b);X=b+20|0}if((t|0)==257)if(e){t=262;break}else{a=X;T=b;continue}else if((t|0)==261){Qb(b+20|0,T);a=X;T=b;continue}}if((t|0)==4){f=T+-20|0;b=k[f>>2]|0;e=k[X>>2]|0;do if((b|0)>=(e|0)){a=(b|0)==(e|0);if(a?(k[Q>>2]|0)<(k[X+4>>2]|0):0)break;if((e|0)<(b|0))return;if(a?(d=k[X+4>>2]|0,c=k[Q>>2]|0,(d|0)<(c|0)):0)t=15;else{d=k[P>>2]|0;c=k[X+8>>2]|0;if((d|0)<(c|0))break;if((d|0)==(c|0)?(k[S>>2]|0)<(k[X+12>>2]|0):0)break;if(a){d=k[X+4>>2]|0;c=k[Q>>2]|0;t=15}else t=18}if((t|0)==15){if((d|0)<(c|0))return;if((c|0)>=(d|0)){c=k[X+8>>2]|0;d=k[P>>2]|0;t=18}}if((t|0)==18){if((c|0)<(d|0))return;if((c|0)==(d|0)?(k[X+12>>2]|0)<(k[S>>2]|0):0)return}if((k[R>>2]|0)>=(k[X+16>>2]|0))return}while(0);V=X+4|0;T=k[V>>2]|0;k[X>>2]=b;k[V>>2]=k[Q>>2];k[f>>2]=e;k[Q>>2]=T;T=X+8|0;V=k[T>>2]|0;U=X+12|0;W=k[U>>2]|0;k[T>>2]=k[P>>2];k[U>>2]=k[S>>2];k[P>>2]=V;k[S>>2]=W;W=X+16|0;X=k[W>>2]|0;k[W>>2]=k[R>>2];k[R>>2]=X;return}else if((t|0)==23){$b(X,X+20|0,v)|0;return}else if((t|0)==24){ac(X,X+20|0,X+40|0,v)|0;return}else if((t|0)==25){bc(X,X+20|0,X+40|0,X+60|0,v)|0;return}else if((t|0)==27){d=X+40|0;$b(X,X+20|0,d)|0;c=X+60|0;if((c|0)==(T|0))return;else p=c;while(1){o=k[p>>2]|0;e=k[d>>2]|0;do if((o|0)>=(e|0)){b=(o|0)==(e|0);if(b?(k[p+4>>2]|0)<(k[d+4>>2]|0):0){t=46;break}if((e|0)>=(o|0)){if(b?(V=k[d+4>>2]|0,W=k[p+4>>2]|0,(V|0)<(W|0)):0){c=V;a=W;t=39}else{c=k[p+8>>2]|0;a=k[d+8>>2]|0;if((c|0)<(a|0)){t=46;break}if((c|0)==(a|0)?(k[p+12>>2]|0)<(k[d+12>>2]|0):0){t=46;break}if(b){c=k[d+4>>2]|0;a=k[p+4>>2]|0;t=39}else t=42}if((t|0)==39){t=0;if((c|0)<(a|0))break;if((a|0)>=(c|0)){a=k[d+8>>2]|0;c=k[p+8>>2]|0;t=42}}if((t|0)==42){t=0;if((a|0)<(c|0))break;if((a|0)==(c|0)?(k[d+12>>2]|0)<(k[p+12>>2]|0):0)break}if((k[p+16>>2]|0)<(k[d+16>>2]|0))t=46}}else t=46;while(0);if((t|0)==46){t=0;R=p+4|0;j=k[R>>2]|0;a=p+8|0;l=k[a>>2]|0;c=p+12|0;m=k[c>>2]|0;S=p+16|0;n=k[S>>2]|0;k[p>>2]=e;b=d+4|0;k[R>>2]=k[b>>2];e=d+8|0;k[a>>2]=k[e>>2];a=d+12|0;k[c>>2]=k[a>>2];c=d+16|0;k[S>>2]=k[c>>2];p:do if((d|0)!=(X|0)){i=d;h=e;g=b;while(1){d=i+-20|0;f=k[d>>2]|0;do if((o|0)>=(f|0)){e=(o|0)==(f|0);if(e?(j|0)<(k[i+-16>>2]|0):0)break;if((f|0)<(o|0)){d=i;b=g;e=h;break p}if(e?(U=k[i+-16>>2]|0,(U|0)<(j|0)):0){b=U;t=58}else{b=k[i+-12>>2]|0;if((l|0)<(b|0))break;if((l|0)==(b|0)?(m|0)<(k[i+-8>>2]|0):0)break;if(e){b=k[i+-16>>2]|0;t=58}else t=61}if((t|0)==58){t=0;if((b|0)<(j|0)){d=i;b=g;e=h;break p}if((j|0)>=(b|0)){b=k[i+-12>>2]|0;t=61}}if((t|0)==61){t=0;if((b|0)<(l|0)){d=i;b=g;e=h;break p}if((b|0)==(l|0)?(k[i+-8>>2]|0)<(m|0):0){d=i;b=g;e=h;break p}}if((n|0)>=(k[i+-4>>2]|0)){d=i;b=g;e=h;break p}}while(0);k[i>>2]=f;b=i+-16|0;k[i+4>>2]=k[b>>2];e=i+-12|0;k[i+8>>2]=k[e>>2];a=i+-8|0;k[i+12>>2]=k[a>>2];c=i+-4|0;k[i+16>>2]=k[c>>2];if((d|0)==(X|0))break;else{i=d;h=e;g=b}}}while(0);k[d>>2]=o;k[b>>2]=j;k[e>>2]=l;k[a>>2]=m;k[c>>2]=n}c=p+20|0;if((c|0)==(T|0))break;else{d=p;p=c}}return}else if((t|0)==262)return}function Rb(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,l=0,m=0,n=0,o=0;m=a+4|0;e=k[m>>2]|0;n=k[a>>2]|0;j=n;l=e-j>>3;i=l+1|0;if(i>>>0>536870911)xa(1340,1363,303,1438);o=a+8|0;c=(k[o>>2]|0)-j|0;if(c>>3>>>0<268435455){c=c>>2;c=c>>>0<i>>>0?i:c;if(!c){f=0;d=0}else g=5}else{c=536870911;g=5}if((g|0)==5){f=c<<3;f=(f|0)==0?1:f;d=_d(f)|0;a:do if(!d){while(1){d=k[35]|0;k[35]=d+0;if(!d)break;Xa[d&0]();d=_d(f)|0;if(d)break a}a=ya(4)|0;k[a>>2]=128;La(a|0,8,1)}while(0);f=c}c=d+(l<<3)|0;h=d+(f<<3)|0;k[c>>2]=k[b>>2];k[d+(l<<3)+4>>2]=k[b+4>>2];g=d+(i<<3)|0;if((e|0)!=(n|0)){f=e+-8|0;while(1){b=e;e=e+-8|0;k[c+-8>>2]=k[e>>2];k[c+-4>>2]=k[b+-4>>2];if((e|0)==(n|0))break;else c=c+-8|0}c=d+(l+~((f-j|0)>>>3)<<3)|0}k[a>>2]=c;k[m>>2]=g;k[o>>2]=h;if(!n)return;$d(n);return}function Sb(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0;A=k[a>>2]|0;D=k[a+8>>2]|0;E=k[a+4>>2]|0;F=k[a+12>>2]|0;i=(A|0)>(D|0);e=i?D:A;i=i?A:D;g=(E|0)>(F|0);c=g?F:E;g=g?E:F;z=k[b>>2]|0;B=k[b+8>>2]|0;y=k[b+4>>2]|0;C=k[b+12>>2]|0;j=(z|0)>(B|0);f=j?B:z;j=j?z:B;h=(y|0)>(C|0);d=h?C:y;h=h?y:C;l=(i|0)>(f|0)&(e|0)<(j|0);if(l?(c|0)<(h|0)&(g|0)>(d|0):0){h=(A|0)==(z|0);if(h&(E|0)==(y|0)){if((!((D|0)==(B|0)&(F|0)==(C|0))?(p=((E|0)<0)<<31>>31,a=be(C|0,((C|0)<0)<<31>>31|0,E|0,p|0)|0,C=L,p=be(F|0,((F|0)<0)<<31>>31|0,E|0,p|0)|0,o=L,E=((A|0)<0)<<31>>31,r=be(B|0,((B|0)<0)<<31>>31|0,A|0,E|0)|0,B=L,D=be(D|0,((D|0)<0)<<31>>31|0,A|0,E|0)|0,E=L,m=(B|0)<0,F=be(0,0,r|0,B|0)|0,B=m?L:B,n=(o|0)<0,q=be(0,0,p|0,o|0)|0,o=ne((m?F:r)|0,B|0,(n?q:p)|0,(n?L:o)|0)|0,p=L,q=(E|0)<0,B=be(0,0,D|0,E|0)|0,E=q?L:E,r=(C|0)<0,F=be(0,0,a|0,C|0)|0,F=ne((q?B:D)|0,E|0,(r?F:a)|0,(r?L:C)|0)|0,(o|0)==(F|0)&(p|0)==(L|0)):0)?(F=ha(q?-1:1,r?-1:1)|0,(o|0)==0&(p|0)==0|(ha(m?-1:1,n?-1:1)|0)==(F|0)):0){F=1;return F|0}F=0;return F|0}g=(A|0)==(B|0);f=(D|0)==(z|0);c=f&(F|0)==(y|0);if(g&(E|0)==(C|0)){if((!c?(v=((E|0)<0)<<31>>31,B=be(y|0,((y|0)<0)<<31>>31|0,E|0,v|0)|0,C=L,v=be(F|0,((F|0)<0)<<31>>31|0,E|0,v|0)|0,u=L,E=((A|0)<0)<<31>>31,x=be(z|0,((z|0)<0)<<31>>31|0,A|0,E|0)|0,t=L,D=be(D|0,((D|0)<0)<<31>>31|0,A|0,E|0)|0,E=L,s=(t|0)<0,F=be(0,0,x|0,t|0)|0,A=s?L:t,t=(u|0)<0,w=be(0,0,v|0,u|0)|0,u=ne((s?F:x)|0,A|0,(t?w:v)|0,(t?L:u)|0)|0,v=L,w=(E|0)<0,A=be(0,0,D|0,E|0)|0,E=w?L:E,x=(C|0)<0,F=be(0,0,B|0,C|0)|0,F=ne((w?A:D)|0,E|0,(x?F:B)|0,(x?L:C)|0)|0,(u|0)==(F|0)&(v|0)==(L|0)):0)?(F=ha(w?-1:1,x?-1:1)|0,(u|0)==0&(v|0)==0|(ha(s?-1:1,t?-1:1)|0)==(F|0)):0){F=1;return F|0}F=0;return F|0}if(c){f=((F|0)<0)<<31>>31;a=be(C|0,((C|0)<0)<<31>>31|0,F|0,f|0)|0;C=L;f=be(E|0,((E|0)<0)<<31>>31|0,F|0,f|0)|0;e=L;E=((D|0)<0)<<31>>31;h=be(B|0,((B|0)<0)<<31>>31|0,D|0,E|0)|0;B=L;D=be(A|0,((A|0)<0)<<31>>31|0,D|0,E|0)|0;E=L;c=(B|0)<0;F=be(0,0,h|0,B|0)|0;B=c?L:B;d=(e|0)<0;g=be(0,0,f|0,e|0)|0;e=ne((c?F:h)|0,B|0,(d?g:f)|0,(d?L:e)|0)|0;f=L;g=(E|0)<0;B=be(0,0,D|0,E|0)|0;E=g?L:E;h=(C|0)<0;F=be(0,0,a|0,C|0)|0;F=ne((g?B:D)|0,E|0,(h?F:a)|0,(h?L:C)|0)|0;if((e|0)==(F|0)&(f|0)==(L|0)?(F=ha(g?-1:1,h?-1:1)|0,(e|0)==0&(f|0)==0|(ha(c?-1:1,d?-1:1)|0)==(F|0)):0){F=1;return F|0}F=0;return F|0}e=(D|0)==(B|0);if(e&(F|0)==(C|0)){f=((F|0)<0)<<31>>31;B=be(y|0,((y|0)<0)<<31>>31|0,F|0,f|0)|0;C=L;f=be(E|0,((E|0)<0)<<31>>31|0,F|0,f|0)|0;e=L;E=((D|0)<0)<<31>>31;h=be(z|0,((z|0)<0)<<31>>31|0,D|0,E|0)|0;d=L;D=be(A|0,((A|0)<0)<<31>>31|0,D|0,E|0)|0;E=L;c=(d|0)<0;F=be(0,0,h|0,d|0)|0;A=c?L:d;d=(e|0)<0;g=be(0,0,f|0,e|0)|0;e=ne((c?F:h)|0,A|0,(d?g:f)|0,(d?L:e)|0)|0;f=L;g=(E|0)<0;A=be(0,0,D|0,E|0)|0;E=g?L:E;h=(C|0)<0;F=be(0,0,B|0,C|0)|0;F=ne((g?A:D)|0,E|0,(h?F:B)|0,(h?L:C)|0)|0;if((e|0)==(F|0)&(f|0)==(L|0)?(F=ha(g?-1:1,h?-1:1)|0,(e|0)==0&(f|0)==0|(ha(c?-1:1,d?-1:1)|0)==(F|0)):0){F=1;return F|0}F=0;return F|0}d=_b(A,E,b)|0;do if(!d){if((z|0)>=(B|0)?!((z|0)==(B|0)&(y|0)<(C|0)):0){if(!((A|0)<(z|0)|h&(E|0)<(y|0)))break;if((B|0)<(A|0)|g&(C|0)<(E|0))c=1;else break;return c|0}if((A|0)<(B|0)|g&(E|0)<(C|0)?(z|0)<(A|0)|h&(y|0)<(E|0):0){F=1;return F|0}}while(0);c=_b(D,F,b)|0;do if(!c){if((z|0)>=(B|0)?!((z|0)==(B|0)&(y|0)<(C|0)):0){if(!((D|0)<(z|0)|f&(F|0)<(y|0)))break;if((B|0)<(D|0)|e&(C|0)<(F|0))c=1;else break;return c|0}if((D|0)<(B|0)|e&(F|0)<(C|0)?(z|0)<(D|0)|f&(y|0)<(F|0):0){F=1;return F|0}}while(0);if((d|0)!=0&(d|0)==(c|0)){F=0;return F|0}d=_b(z,y,a)|0;do if(!d){if((A|0)>=(D|0)?!((A|0)==(D|0)&(E|0)<(F|0)):0){if(!((z|0)<(A|0)|h&(y|0)<(E|0)))break;if((D|0)<(z|0)|f&(F|0)<(y|0))c=1;else break;return c|0}if((z|0)<(D|0)|f&(y|0)<(F|0)?(A|0)<(z|0)|h&(E|0)<(y|0):0){F=1;return F|0}}while(0);c=_b(B,C,a)|0;do if(!c){if((A|0)>=(D|0)?!((A|0)==(D|0)&(E|0)<(F|0)):0){if(!((B|0)<(A|0)|g&(C|0)<(E|0)))break;if((D|0)<(B|0)|e&(F|0)<(C|0))c=1;else break;return c|0}if((B|0)<(D|0)|e&(C|0)<(F|0)?(A|0)<(B|0)|g&(E|0)<(C|0):0){F=1;return F|0}}while(0);F=(d|0)!=(c|0);return F|0}if((A|0)==(D|0)&(z|0)==(B|0)&(A|0)==(z|0))if((g|0)>(d|0)&(c|0)<(h|0))return (g|0)!=(h|0)|(c|0)!=(d|0)|0;else{F=0;return F|0}if(!((E|0)==(F|0)&(y|0)==(C|0)&(E|0)==(y|0)&l)){F=0;return F|0}F=(i|0)!=(j|0)|(e|0)!=(f|0);return F|0}function Tb(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0;t=r;r=r+32|0;q=t+16|0;s=t;p=k[a>>2]|0;m=k[b+8>>2]|0;n=(p|0)==(m|0);if(n?(k[a+4>>2]|0)==(k[b+12>>2]|0):0){s=1;r=t;return s|0}o=k[b>>2]|0;l=(p|0)==(o|0);if(l){a=k[a+4>>2]|0;c=k[b+4>>2]|0;if((a|0)==(c|0)){s=1;r=t;return s|0}else j=a}else{c=k[b+4>>2]|0;j=k[a+4>>2]|0}a=k[b+12>>2]|0;h=(o|0)>(m|0);i=(c|0)>(a|0);if(!(((i?a:c)|0)<=(j|0)&((((h?m:o)|0)>(p|0)|((h?o:m)|0)<(p|0)|((i?c:a)|0)<(j|0))^1))){s=0;r=t;return s|0}if((o|0)==(m|0)|(c|0)==(a|0)){s=1;r=t;return s|0}g=((j|0)<0)<<31>>31;v=be(a|0,((a|0)<0)<<31>>31|0,j|0,g|0)|0;u=L;g=be(c|0,((c|0)<0)<<31>>31|0,j|0,g|0)|0;f=L;y=((p|0)<0)<<31>>31;i=be(m|0,((m|0)<0)<<31>>31|0,p|0,y|0)|0;z=L;y=be(o|0,((o|0)<0)<<31>>31|0,p|0,y|0)|0;x=L;d=(z|0)<0;w=be(0,0,i|0,z|0)|0;z=d?L:z;e=(f|0)<0;h=be(0,0,g|0,f|0)|0;f=ne((d?w:i)|0,z|0,(e?h:g)|0,(e?L:f)|0)|0;g=L;h=(x|0)<0;z=be(0,0,y|0,x|0)|0;x=h?L:x;i=(u|0)<0;w=be(0,0,v|0,u|0)|0;u=ne((h?z:y)|0,x|0,(i?w:v)|0,(i?L:u)|0)|0;do if((f|0)==(u|0)&(g|0)==(L|0)?(z=ha(h?-1:1,i?-1:1)|0,(f|0)==0&(g|0)==0|(ha(d?-1:1,e?-1:1)|0)==(z|0)):0)if((o|0)<(m|0)){if(!((p|0)<(m|0)|n&(j|0)<(a|0)))break;if((o|0)<(p|0)|l&(c|0)<(j|0))c=1;else break;r=t;return c|0}else{if(!((p|0)<(o|0)|l&(j|0)<(c|0)))break;if((m|0)<(p|0)|n&(a|0)<(j|0))c=1;else break;r=t;return c|0}while(0);c=j+1|0;a=p+1|0;k[q>>2]=p;k[q+4>>2]=j;k[q+8>>2]=a;k[q+12>>2]=c;if(Sb(q,b)|0?(_b(a,c,b)|0)!=0:0){z=1;r=t;return z|0}k[s>>2]=p;k[s+4>>2]=c;k[s+8>>2]=a;k[s+12>>2]=j;if((Sb(s,b)|0?(_b(p,c,b)|0)!=0:0)?(_b(a,j,b)|0)!=0:0){z=1;r=t;return z|0}z=0;r=t;return z|0}function Ub(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0,j=0,l=0,m=0;m=r;r=r+16|0;j=m;d=b+4|0;e=k[d>>2]|0;do if(e){g=k[c>>2]|0;h=k[c+4>>2]|0;a:while(1){d=k[e+16>>2]|0;do if((g|0)>=(d|0)){f=(g|0)==(d|0);if(f?(h|0)<(k[e+20>>2]|0):0){l=6;break}if((d|0)>=(g|0)){if(!f){l=14;break a}if((k[e+20>>2]|0)>=(h|0)){l=14;break a}}f=e+4|0;d=k[f>>2]|0;if(!d){l=13;break a}}else l=6;while(0);if((l|0)==6){l=0;d=k[e>>2]|0;if(!d){l=7;break}}e=d}if((l|0)==7){k[j>>2]=e;f=e;g=e;break}else if((l|0)==13){k[j>>2]=e;g=e;break}else if((l|0)==14){k[j>>2]=e;f=j;g=e;break}}else{k[j>>2]=d;f=d;g=d}while(0);d=k[f>>2]|0;if(d){c=0;b=d;k[a>>2]=b;b=a+4|0;i[b>>0]=c;r=m;return}d=_d(24)|0;b:do if(!d){while(1){d=k[35]|0;k[35]=d+0;if(!d)break;Xa[d&0]();d=_d(24)|0;if(d){e=d;break b}}m=ya(4)|0;k[m>>2]=128;La(m|0,8,1)}else e=d;while(0);k[e+16>>2]=k[c>>2];k[e+20>>2]=k[c+4>>2];k[e>>2]=0;k[e+4>>2]=0;k[e+8>>2]=g;k[f>>2]=e;d=k[k[b>>2]>>2]|0;if(!d)d=e;else{k[b>>2]=d;d=k[f>>2]|0}Nb(k[b+4>>2]|0,d);c=b+8|0;k[c>>2]=(k[c>>2]|0)+1;c=1;b=e;k[a>>2]=b;b=a+4|0;i[b>>0]=c;r=m;return}function Vb(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0;t=b;a:while(1){m=t;n=t+-8|0;o=t+-16|0;s=t+-4|0;y=a;b:while(1){l=y;a=m-l|0;b=a>>3;switch(b|0){case 2:{x=4;break a}case 3:{x=9;break a}case 4:{x=10;break a}case 5:{x=11;break a}case 1:case 0:{x=88;break a}default:{}}if((a|0)<56){x=13;break a}c=(b|0)/2|0;g=y+(c<<3)|0;if((a|0)>7992){a=(b|0)/4|0;a=Yb(y,y+(a<<3)|0,g,y+(a+c<<3)|0,n)|0}else a=Wb(y,g,n)|0;h=k[y>>2]|0;f=k[g>>2]|0;c:do if((h|0)<(f|0))c=n;else{if((h|0)==(f|0)?(k[y+4>>2]|0)<(k[y+(c<<3)+4>>2]|0):0){c=n;break}d:do if((y|0)!=(o|0)){e=y+(c<<3)+4|0;c=o;d=n;while(1){b=k[c>>2]|0;if((b|0)<(f|0)){x=58;break}if((b|0)==(f|0)?(p=d+-4|0,(k[p>>2]|0)<(k[e>>2]|0)):0){d=p;b=f;break}b=c+-8|0;if((y|0)==(b|0))break d;else{d=c;c=b}}if((x|0)==58){x=0;d=d+-4|0}i=y+4|0;j=k[i>>2]|0;k[y>>2]=b;k[i>>2]=k[d>>2];k[c>>2]=h;k[d>>2]=j;a=a+1|0;break c}while(0);a=y+8|0;f=k[n>>2]|0;do if((h|0)>=(f|0)){if((h|0)==(f|0)?(k[y+4>>2]|0)<(k[s>>2]|0):0)break;if((a|0)==(n|0)){x=88;break a}c=y+4|0;e=y;while(1){d=e+8|0;b=k[d>>2]|0;if((h|0)<(b|0)){x=40;break}if((h|0)==(b|0)?(q=e+12|0,r=k[q>>2]|0,(k[c>>2]|0)<(r|0)):0){c=q;a=h;b=r;break}b=a+8|0;if((b|0)==(n|0)){x=88;break a}else{e=a;a=b}}if((x|0)==40){x=0;l=e+12|0;c=l;a=b;b=k[l>>2]|0}k[d>>2]=f;k[c>>2]=k[s>>2];k[n>>2]=a;k[s>>2]=b;a=e+16|0}while(0);if((a|0)==(n|0)){x=88;break a}h=y+4|0;c=n;while(1){g=k[y>>2]|0;b=k[a>>2]|0;e:do if((g|0)<(b|0)){f=a;e=a}else while(1){if((g|0)==(b|0)?(k[h>>2]|0)<(k[a+4>>2]|0):0){f=a;b=g;e=a;break e}a=a+8|0;b=k[a>>2]|0;if((g|0)<(b|0)){f=a;e=a;break}}while(0);while(1){d=c+-8|0;a=k[d>>2]|0;if((g|0)<(a|0)){c=d;continue}if((g|0)!=(a|0))break;if((k[h>>2]|0)<(k[c+-4>>2]|0))c=d;else{a=g;break}}if(e>>>0>=d>>>0){y=e;continue b}j=e+4|0;l=k[j>>2]|0;k[f>>2]=a;a=c+-4|0;k[j>>2]=k[a>>2];k[d>>2]=b;k[a>>2]=l;a=e+8|0;c=d}}while(0);b=y+8|0;f:do if(b>>>0<c>>>0)while(1){i=k[g>>2]|0;f=g+4|0;j=b;while(1){b=k[j>>2]|0;if((b|0)>=(i|0)){if((b|0)!=(i|0))break;if((k[j+4>>2]|0)>=(k[f>>2]|0)){b=i;break}}j=j+8|0}d=c+-8|0;e=k[d>>2]|0;g:do if((e|0)<(i|0)){h=d;f=d}else while(1){if((e|0)==(i|0)?(k[c+-4>>2]|0)<(k[f>>2]|0):0){h=d;f=d;e=i;break g}c=d+-8|0;e=k[c>>2]|0;if((e|0)<(i|0)){h=c;f=c;c=d;break}else{h=d;d=c;c=h}}while(0);if(j>>>0>h>>>0){h=j;break f}d=j+4|0;i=k[d>>2]|0;k[j>>2]=e;c=c+-4|0;k[d>>2]=k[c>>2];k[f>>2]=b;k[c>>2]=i;b=j+8|0;c=h;g=(g|0)==(j|0)?h:g;a=a+1|0}else h=b;while(0);do if((h|0)!=(g|0)){e=k[g>>2]|0;f=k[h>>2]|0;if((e|0)>=(f|0)){if((e|0)!=(f|0))break;b=g+4|0;d=h+4|0;c=k[d>>2]|0;if((k[b>>2]|0)>=(c|0))break}else{c=h+4|0;b=g+4|0;d=c;c=k[c>>2]|0}k[h>>2]=e;k[d>>2]=k[b>>2];k[g>>2]=f;k[b>>2]=c;a=a+1|0}while(0);if(!a){a=Zb(y,h)|0;b=h+8|0;if(Zb(b,t)|0){x=83;break}if(a){y=b;continue}}j=h;if((j-l|0)>=(m-j|0)){x=87;break}Vb(y,h);y=h+8|0}if((x|0)==83){x=0;if(a){x=88;break}else{a=y;t=h;continue}}else if((x|0)==87){x=0;Vb(h+8|0,t);a=y;t=h;continue}}if((x|0)==4){c=t+-8|0;d=k[c>>2]|0;e=k[y>>2]|0;if((d|0)>=(e|0)){if((d|0)!=(e|0))return;a=y+4|0;b=k[a>>2]|0;if((k[s>>2]|0)>=(b|0))return}else{b=y+4|0;a=b;b=k[b>>2]|0}k[y>>2]=d;k[a>>2]=k[s>>2];k[c>>2]=e;k[s>>2]=b;return}else if((x|0)==9){Wb(y,y+8|0,n)|0;return}else if((x|0)==10){Xb(y,y+8|0,y+16|0,n)|0;return}else if((x|0)==11){Yb(y,y+8|0,y+16|0,y+24|0,n)|0;return}else if((x|0)==13){b=y+16|0;Wb(y,y+8|0,b)|0;a=y+24|0;if((a|0)==(t|0))return;while(1){h=k[a>>2]|0;e=k[b>>2]|0;if((h|0)>=(e|0)){if((h|0)==(e|0)?(u=a+4|0,v=k[u>>2]|0,w=b+4|0,(v|0)<(k[w>>2]|0)):0){d=u;c=w;i=v;x=18}}else{i=a+4|0;d=i;c=b+4|0;i=k[i>>2]|0;x=18}if((x|0)==18){x=0;k[a>>2]=e;k[d>>2]=k[c>>2];h:do if((b|0)!=(y|0)){f=b;while(1){b=f+-8|0;g=k[b>>2]|0;if((h|0)>=(g|0)){if((h|0)!=(g|0)){b=f;break h}e=f+-4|0;d=k[e>>2]|0;if((i|0)<(d|0))c=e;else{b=f;break h}}else{d=f+-4|0;c=d;d=k[d>>2]|0}k[f>>2]=g;k[f+4>>2]=d;if((b|0)==(y|0))break;else f=b}}while(0);k[b>>2]=h;k[c>>2]=i}b=a+8|0;if((b|0)==(t|0))break;else{s=a;a=b;b=s}}return}else if((x|0)==88)return}function Wb(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0,i=0;f=k[b>>2]|0;i=k[a>>2]|0;if((f|0)>=(i|0))if((f|0)==(i|0))d=(k[b+4>>2]|0)<(k[a+4>>2]|0);else d=0;else d=1;g=k[c>>2]|0;if((g|0)>=(f|0))if((g|0)==(f|0))e=(k[c+4>>2]|0)<(k[b+4>>2]|0);else e=0;else e=1;if(!d){if(!e){b=0;return b|0}h=b+4|0;i=k[h>>2]|0;k[b>>2]=g;g=c+4|0;k[h>>2]=k[g>>2];k[c>>2]=f;k[g>>2]=i;f=k[b>>2]|0;g=k[a>>2]|0;if((f|0)>=(g|0)){if((f|0)!=(g|0)){b=1;return b|0}d=a+4|0;e=k[d>>2]|0;if((k[h>>2]|0)>=(e|0)){b=1;return b|0}}else{e=a+4|0;d=e;e=k[e>>2]|0}k[a>>2]=f;k[d>>2]=k[h>>2];k[b>>2]=g;k[h>>2]=e;b=2;return b|0}d=a+4|0;h=k[d>>2]|0;if(e){k[a>>2]=g;b=c+4|0;k[d>>2]=k[b>>2];k[c>>2]=i;k[b>>2]=h;b=1;return b|0}k[a>>2]=f;f=b+4|0;k[d>>2]=k[f>>2];k[b>>2]=i;k[f>>2]=h;e=k[c>>2]|0;if((e|0)>=(i|0)){if((e|0)!=(i|0)){b=1;return b|0}d=c+4|0;if((k[d>>2]|0)>=(h|0)){b=1;return b|0}}else d=c+4|0;k[b>>2]=e;k[f>>2]=k[d>>2];k[c>>2]=i;k[d>>2]=h;b=2;return b|0}function Xb(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,l=0;l=Wb(a,b,c)|0;h=k[d>>2]|0;i=k[c>>2]|0;if((h|0)>=(i|0)){if((h|0)!=(i|0)){b=l;return b|0}f=d+4|0;g=c+4|0;e=k[g>>2]|0;if((k[f>>2]|0)<(e|0))j=g;else{b=l;return b|0}}else{e=c+4|0;f=d+4|0;j=e;e=k[e>>2]|0}k[c>>2]=h;k[j>>2]=k[f>>2];k[d>>2]=i;k[f>>2]=e;f=l+1|0;h=k[c>>2]|0;i=k[b>>2]|0;if((h|0)>=(i|0)){if((h|0)!=(i|0)){b=f;return b|0}g=b+4|0;e=k[g>>2]|0;if((k[j>>2]|0)<(e|0))d=g;else{b=f;return b|0}}else{e=b+4|0;d=e;e=k[e>>2]|0}k[b>>2]=h;k[d>>2]=k[j>>2];k[c>>2]=i;k[j>>2]=e;g=l+2|0;h=k[b>>2]|0;i=k[a>>2]|0;if((h|0)>=(i|0)){if((h|0)!=(i|0)){b=g;return b|0}f=a+4|0;e=k[f>>2]|0;if((k[d>>2]|0)>=(e|0)){b=g;return b|0}}else{e=a+4|0;f=e;e=k[e>>2]|0}k[a>>2]=h;k[f>>2]=k[d>>2];k[b>>2]=i;k[d>>2]=e;b=l+3|0;return b|0}function Yb(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0,j=0,l=0,m=0,n=0;n=Xb(a,b,c,d)|0;i=k[e>>2]|0;j=k[d>>2]|0;if((i|0)>=(j|0)){if((i|0)!=(j|0)){b=n;return b|0}g=e+4|0;h=d+4|0;f=k[h>>2]|0;if((k[g>>2]|0)<(f|0))m=h;else{b=n;return b|0}}else{f=d+4|0;g=e+4|0;m=f;f=k[f>>2]|0}k[d>>2]=i;k[m>>2]=k[g>>2];k[e>>2]=j;k[g>>2]=f;g=n+1|0;i=k[d>>2]|0;j=k[c>>2]|0;if((i|0)>=(j|0)){if((i|0)!=(j|0)){b=g;return b|0}h=c+4|0;f=k[h>>2]|0;if((k[m>>2]|0)<(f|0))l=h;else{b=g;return b|0}}else{f=c+4|0;l=f;f=k[f>>2]|0}k[c>>2]=i;k[l>>2]=k[m>>2];k[d>>2]=j;k[m>>2]=f;g=n+2|0;i=k[c>>2]|0;j=k[b>>2]|0;if((i|0)>=(j|0)){if((i|0)!=(j|0)){b=g;return b|0}h=b+4|0;f=k[h>>2]|0;if((k[l>>2]|0)<(f|0))e=h;else{b=g;return b|0}}else{f=b+4|0;e=f;f=k[f>>2]|0}k[b>>2]=i;k[e>>2]=k[l>>2];k[c>>2]=j;k[l>>2]=f;h=n+3|0;i=k[b>>2]|0;j=k[a>>2]|0;if((i|0)>=(j|0)){if((i|0)!=(j|0)){b=h;return b|0}g=a+4|0;f=k[g>>2]|0;if((k[e>>2]|0)>=(f|0)){b=h;return b|0}}else{f=a+4|0;g=f;f=k[f>>2]|0}k[a>>2]=i;k[g>>2]=k[e>>2];k[b>>2]=j;k[e>>2]=f;b=n+4|0;return b|0}function Zb(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0;switch(b-a>>3|0){case 2:{f=b+-8|0;g=k[f>>2]|0;h=k[a>>2]|0;if((g|0)>=(h|0)){if((g|0)!=(h|0)){a=1;return a|0}e=b+-4|0;c=a+4|0;d=k[c>>2]|0;if((k[e>>2]|0)>=(d|0)){a=1;return a|0}}else{d=a+4|0;c=d;e=b+-4|0;d=k[d>>2]|0}k[a>>2]=g;k[c>>2]=k[e>>2];k[f>>2]=h;k[e>>2]=d;a=1;return a|0}case 3:{Wb(a,a+8|0,b+-8|0)|0;a=1;return a|0}case 4:{Xb(a,a+8|0,a+16|0,b+-8|0)|0;a=1;return a|0}case 5:{Yb(a,a+8|0,a+16|0,a+24|0,b+-8|0)|0;a=1;return a|0}case 1:case 0:{a=1;return a|0}default:{e=a+16|0;Wb(a,a+8|0,e)|0;d=a+24|0;if((d|0)==(b|0)){a=1;return a|0}else c=0;while(1){l=k[d>>2]|0;h=k[e>>2]|0;if((l|0)>=(h|0)){if((l|0)==(h|0)?(n=d+4|0,o=k[n>>2]|0,p=e+4|0,(o|0)<(k[p>>2]|0)):0){f=p;g=n;m=o;q=15}}else{m=d+4|0;f=e+4|0;g=m;m=k[m>>2]|0;q=15}if((q|0)==15){q=0;k[d>>2]=h;k[g>>2]=k[f>>2];a:do if((e|0)!=(a|0)){j=e;while(1){e=j+-8|0;i=k[e>>2]|0;if((l|0)>=(i|0)){if((l|0)!=(i|0)){e=j;break a}h=j+-4|0;g=k[h>>2]|0;if((m|0)<(g|0))f=h;else{e=j;break a}}else{g=j+-4|0;f=g;g=k[g>>2]|0}k[j>>2]=i;k[j+4>>2]=g;if((e|0)==(a|0))break;else j=e}}while(0);k[e>>2]=l;k[f>>2]=m;c=c+1|0;if((c|0)==8)break}e=d+8|0;if((e|0)==(b|0)){c=1;q=24;break}else{m=d;d=e;e=m}}if((q|0)==24)return c|0;a=(d+8|0)==(b|0);return a|0}}return 0}function _b(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0;y=k[c>>2]|0;z=(y|0)==(a|0);if(z?(k[c+4>>2]|0)==(b|0):0){b=0;return b|0}A=k[c+8>>2]|0;B=(A|0)==(a|0);C=k[c+12>>2]|0;if(B&(C|0)==(b|0)){b=0;return b|0}i=((b|0)<0)<<31>>31;n=be(C|0,((C|0)<0)<<31>>31|0,b|0,i|0)|0;p=L;x=k[c+4>>2]|0;c=be(x|0,((x|0)<0)<<31>>31|0,b|0,i|0)|0;i=L;v=((a|0)<0)<<31>>31;q=be(A|0,((A|0)<0)<<31>>31|0,a|0,v|0)|0;s=L;v=be(y|0,((y|0)<0)<<31>>31|0,a|0,v|0)|0;w=L;u=(s|0)<0;r=be(0,0,q|0,s|0)|0;t=L;d=(i|0)<0;e=be(0,0,c|0,i|0)|0;j=L;f=ne((u?r:q)|0,(u?t:s)|0,(d?e:c)|0,(d?j:i)|0)|0;g=L;l=(w|0)<0;h=be(0,0,v|0,w|0)|0;v=l?h:v;w=l?L:w;h=(p|0)<0;m=be(0,0,n|0,p|0)|0;o=L;D=ne(v|0,w|0,(h?m:n)|0,(h?o:p)|0)|0;if((f|0)==(D|0)&(g|0)==(L|0)?(D=ha(l?-1:1,h?-1:1)|0,(f|0)==0&(g|0)==0|(ha(u?-1:1,d?-1:1)|0)==(D|0)):0){D=0;return D|0}h=l?e:c;g=l?j:i;do if(l|z^1){f=u?m:n;e=u?o:p;d=u?r:q;c=u?t:s;if(!(u|B^1)){c=(y|0)!=(a|0);break}u=(c|0)<0;s=be(0,0,d|0,c|0)|0;t=u?L:c;D=(g|0)<0;c=be(0,0,h|0,g|0)|0;g=ne((u?s:d)|0,t|0,(D?c:h)|0,(D?L:g)|0)|0;h=L;c=(e|0)<0;d=be(0,0,f|0,e|0)|0;e=ne((c?d:f)|0,(c?L:e)|0,v|0,w|0)|0;f=L;d=ha(u?-1:1,D?-1:1)|0;c=ha(c?-1:1,(w|0)<0?-1:1)|0;if((d|0)>=(c|0))if((c|0)>=(d|0))if((d|0)==-1){c=f>>>0<h>>>0|(f|0)==(h|0)&e>>>0<g>>>0;break}else{c=h>>>0<f>>>0|(h|0)==(f|0)&g>>>0<e>>>0;break}else c=0;else c=1}else c=0;while(0);d=c?-1:1;if((A|0)<(y|0))c=1;else c=(A|0)==(y|0)&(C|0)<(x|0);d=c?0-d|0:d;if((y|0)>=(A|0)?!((y|0)==(A|0)&(x|0)<(C|0)):0)if((y|0)>(a|0)|z&(x|0)>(b|0))if((A|0)<(a|0))c=1;else c=B&(C|0)<(b|0);else c=0;else if((A|0)>(a|0)|B&(C|0)>(b|0))if((y|0)<(a|0))c=1;else c=z&(x|0)<(b|0);else c=0;D=c?d:0-d|0;return D|0}function $b(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0;n=k[b>>2]|0;o=k[a>>2]|0;do if((n|0)>=(o|0)){h=(n|0)==(o|0);if(h?(k[b+4>>2]|0)<(k[a+4>>2]|0):0){i=1;break}if((o|0)<(n|0))i=0;else{if(h?(f=k[a+4>>2]|0,g=k[b+4>>2]|0,(f|0)<(g|0)):0)r=12;else{g=k[b+8>>2]|0;f=k[a+8>>2]|0;if((g|0)<(f|0)){i=1;break}if((g|0)==(f|0)?(k[b+12>>2]|0)<(k[a+12>>2]|0):0){i=1;break}if(h){f=k[a+4>>2]|0;g=k[b+4>>2]|0;r=12}else r=15}if((r|0)==12){if((f|0)<(g|0)){i=0;break}if((g|0)>=(f|0)){f=k[a+8>>2]|0;g=k[b+8>>2]|0;r=15}}if((r|0)==15){if((f|0)<(g|0)){i=0;break}if((f|0)==(g|0)?(k[a+12>>2]|0)<(k[b+12>>2]|0):0){i=0;break}}i=(k[b+16>>2]|0)<(k[a+16>>2]|0)}}else i=1;while(0);l=k[c>>2]|0;do if((l|0)>=(n|0)){h=(l|0)==(n|0);if(h?(k[c+4>>2]|0)<(k[b+4>>2]|0):0){f=1;break}if((n|0)<(l|0))f=0;else{if(h?(j=k[b+4>>2]|0,m=k[c+4>>2]|0,(j|0)<(m|0)):0){g=j;f=m;r=30}else{g=k[c+8>>2]|0;f=k[b+8>>2]|0;if((g|0)<(f|0)){f=1;break}if((g|0)==(f|0)?(k[c+12>>2]|0)<(k[b+12>>2]|0):0){f=1;break}if(h){g=k[b+4>>2]|0;f=k[c+4>>2]|0;r=30}else r=33}if((r|0)==30){if((g|0)<(f|0)){f=0;break}if((f|0)>=(g|0)){f=k[b+8>>2]|0;g=k[c+8>>2]|0;r=33}}if((r|0)==33){if((f|0)<(g|0)){f=0;break}if((f|0)==(g|0)?(k[b+12>>2]|0)<(k[c+12>>2]|0):0){f=0;break}}f=(k[c+16>>2]|0)<(k[b+16>>2]|0)}}else f=1;while(0);if(!i){if(!f){b=0;return b|0}m=b+4|0;r=k[m>>2]|0;k[b>>2]=l;i=c+4|0;k[m>>2]=k[i>>2];k[c>>2]=n;k[i>>2]=r;i=b+8|0;r=k[i>>2]|0;j=b+12|0;g=k[j>>2]|0;h=c+8|0;k[i>>2]=k[h>>2];l=c+12|0;k[j>>2]=k[l>>2];k[h>>2]=r;k[l>>2]=g;l=b+16|0;g=c+16|0;h=k[l>>2]|0;k[l>>2]=k[g>>2];k[g>>2]=h;g=k[b>>2]|0;h=k[a>>2]|0;do if((g|0)>=(h|0)){f=(g|0)==(h|0);if(f?(k[m>>2]|0)<(k[a+4>>2]|0):0)break;if((h|0)<(g|0)){b=1;return b|0}if(f?(e=k[a+4>>2]|0,d=k[m>>2]|0,(e|0)<(d|0)):0)r=50;else{e=k[i>>2]|0;d=k[a+8>>2]|0;if((e|0)<(d|0))break;if((e|0)==(d|0)?(k[j>>2]|0)<(k[a+12>>2]|0):0)break;if(f){e=k[a+4>>2]|0;d=k[m>>2]|0;r=50}else r=53}if((r|0)==50){if((e|0)<(d|0)){b=1;return b|0}if((d|0)>=(e|0)){d=k[a+8>>2]|0;e=k[i>>2]|0;r=53}}if((r|0)==53){if((d|0)<(e|0)){b=1;return b|0}if((d|0)==(e|0)?(k[a+12>>2]|0)<(k[j>>2]|0):0){b=1;return b|0}}if((k[l>>2]|0)>=(k[a+16>>2]|0)){b=1;return b|0}}while(0);r=a+4|0;q=k[r>>2]|0;k[a>>2]=g;k[r>>2]=k[m>>2];k[b>>2]=h;k[m>>2]=q;q=a+8|0;b=k[q>>2]|0;r=a+12|0;c=k[r>>2]|0;k[q>>2]=k[i>>2];k[r>>2]=k[j>>2];k[i>>2]=b;k[j>>2]=c;c=a+16|0;b=k[c>>2]|0;k[c>>2]=k[l>>2];k[l>>2]=b;b=2;return b|0}d=a+4|0;e=k[d>>2]|0;if(f){k[a>>2]=l;b=c+4|0;k[d>>2]=k[b>>2];k[c>>2]=o;k[b>>2]=e;b=a+8|0;p=k[b>>2]|0;o=a+12|0;r=k[o>>2]|0;q=c+8|0;k[b>>2]=k[q>>2];b=c+12|0;k[o>>2]=k[b>>2];k[q>>2]=p;k[b>>2]=r;a=a+16|0;b=c+16|0;c=k[a>>2]|0;k[a>>2]=k[b>>2];k[b>>2]=c;b=1;return b|0}k[a>>2]=n;n=b+4|0;k[d>>2]=k[n>>2];k[b>>2]=o;k[n>>2]=e;m=a+8|0;g=k[m>>2]|0;h=a+12|0;i=k[h>>2]|0;l=b+8|0;k[m>>2]=k[l>>2];m=b+12|0;k[h>>2]=k[m>>2];k[l>>2]=g;k[m>>2]=i;i=a+16|0;g=b+16|0;h=k[i>>2]|0;k[i>>2]=k[g>>2];k[g>>2]=h;i=k[c>>2]|0;j=k[b>>2]|0;do if((i|0)>=(j|0)){f=(i|0)==(j|0);if(f?(k[c+4>>2]|0)<(k[n>>2]|0):0)break;if((j|0)<(i|0)){b=1;return b|0}if(f?(p=k[n>>2]|0,q=k[c+4>>2]|0,(p|0)<(q|0)):0){e=p;d=q;r=71}else{e=k[c+8>>2]|0;d=k[l>>2]|0;if((e|0)<(d|0))break;if((e|0)==(d|0)?(k[c+12>>2]|0)<(k[m>>2]|0):0)break;if(f){e=k[n>>2]|0;d=k[c+4>>2]|0;r=71}else r=74}if((r|0)==71){if((e|0)<(d|0)){b=1;return b|0}if((d|0)>=(e|0)){d=k[l>>2]|0;e=k[c+8>>2]|0;r=74}}if((r|0)==74){if((d|0)<(e|0)){b=1;return b|0}if((d|0)==(e|0)?(k[m>>2]|0)<(k[c+12>>2]|0):0){b=1;return b|0}}if((k[c+16>>2]|0)>=(h|0)){b=1;return b|0}}while(0);a=k[n>>2]|0;k[b>>2]=i;q=c+4|0;k[n>>2]=k[q>>2];k[c>>2]=j;k[q>>2]=a;q=k[l>>2]|0;a=k[m>>2]|0;r=c+8|0;k[l>>2]=k[r>>2];b=c+12|0;k[m>>2]=k[b>>2];k[r>>2]=q;k[b>>2]=a;b=c+16|0;c=k[g>>2]|0;k[g>>2]=k[b>>2];k[b>>2]=c;b=2;return b|0}function ac(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0;t=$b(a,b,c)|0;i=k[d>>2]|0;j=k[c>>2]|0;do if((i|0)>=(j|0)){h=(i|0)==(j|0);if(h?(k[d+4>>2]|0)<(k[c+4>>2]|0):0)break;if((j|0)<(i|0)){b=t;return b|0}if(h?(f=k[c+4>>2]|0,g=k[d+4>>2]|0,(f|0)<(g|0)):0)r=12;else{g=k[d+8>>2]|0;f=k[c+8>>2]|0;if((g|0)<(f|0))break;if((g|0)==(f|0)?(k[d+12>>2]|0)<(k[c+12>>2]|0):0)break;if(h){f=k[c+4>>2]|0;g=k[d+4>>2]|0;r=12}else r=15}if((r|0)==12){if((f|0)<(g|0)){b=t;return b|0}if((g|0)>=(f|0)){f=k[c+8>>2]|0;g=k[d+8>>2]|0;r=15}}if((r|0)==15){if((f|0)<(g|0)){b=t;return b|0}if((f|0)==(g|0)?(k[c+12>>2]|0)<(k[d+12>>2]|0):0){b=t;return b|0}}if((k[d+16>>2]|0)>=(k[c+16>>2]|0)){b=t;return b|0}}while(0);l=c+4|0;r=k[l>>2]|0;k[c>>2]=i;o=d+4|0;k[l>>2]=k[o>>2];k[d>>2]=j;k[o>>2]=r;o=c+8|0;r=k[o>>2]|0;p=c+12|0;i=k[p>>2]|0;j=d+8|0;k[o>>2]=k[j>>2];q=d+12|0;k[p>>2]=k[q>>2];k[j>>2]=r;k[q>>2]=i;q=c+16|0;i=d+16|0;j=k[q>>2]|0;k[q>>2]=k[i>>2];k[i>>2]=j;i=t+1|0;j=k[c>>2]|0;d=k[b>>2]|0;do if((j|0)>=(d|0)){h=(j|0)==(d|0);if(h?(k[l>>2]|0)<(k[b+4>>2]|0):0)break;if((d|0)<(j|0)){b=i;return b|0}if(h?(m=k[b+4>>2]|0,n=k[l>>2]|0,(m|0)<(n|0)):0){g=m;f=n;r=30}else{g=k[o>>2]|0;f=k[b+8>>2]|0;if((g|0)<(f|0))break;if((g|0)==(f|0)?(k[p>>2]|0)<(k[b+12>>2]|0):0)break;if(h){g=k[b+4>>2]|0;f=k[l>>2]|0;r=30}else r=33}if((r|0)==30){if((g|0)<(f|0)){b=i;return b|0}if((f|0)>=(g|0)){f=k[b+8>>2]|0;g=k[o>>2]|0;r=33}}if((r|0)==33){if((f|0)<(g|0)){b=i;return b|0}if((f|0)==(g|0)?(k[b+12>>2]|0)<(k[p>>2]|0):0){b=i;return b|0}}if((k[q>>2]|0)>=(k[b+16>>2]|0)){b=i;return b|0}}while(0);n=b+4|0;h=k[n>>2]|0;k[b>>2]=j;k[n>>2]=k[l>>2];k[c>>2]=d;k[l>>2]=h;l=b+8|0;h=k[l>>2]|0;m=b+12|0;d=k[m>>2]|0;k[l>>2]=k[o>>2];k[m>>2]=k[p>>2];k[o>>2]=h;k[p>>2]=d;d=b+16|0;h=k[d>>2]|0;k[d>>2]=k[q>>2];k[q>>2]=h;h=t+2|0;i=k[b>>2]|0;j=k[a>>2]|0;do if((i|0)>=(j|0)){g=(i|0)==(j|0);if(g?(k[n>>2]|0)<(k[a+4>>2]|0):0)break;if((j|0)<(i|0)){b=h;return b|0}if(g?(s=k[a+4>>2]|0,e=k[n>>2]|0,(s|0)<(e|0)):0){f=s;r=48}else{f=k[l>>2]|0;e=k[a+8>>2]|0;if((f|0)<(e|0))break;if((f|0)==(e|0)?(k[m>>2]|0)<(k[a+12>>2]|0):0)break;if(g){f=k[a+4>>2]|0;e=k[n>>2]|0;r=48}else r=51}if((r|0)==48){if((f|0)<(e|0)){b=h;return b|0}if((e|0)>=(f|0)){e=k[a+8>>2]|0;f=k[l>>2]|0;r=51}}if((r|0)==51){if((e|0)<(f|0)){b=h;return b|0}if((e|0)==(f|0)?(k[a+12>>2]|0)<(k[m>>2]|0):0){b=h;return b|0}}if((k[d>>2]|0)>=(k[a+16>>2]|0)){b=h;return b|0}}while(0);s=a+4|0;c=k[s>>2]|0;k[a>>2]=i;k[s>>2]=k[n>>2];k[b>>2]=j;k[n>>2]=c;c=a+8|0;s=k[c>>2]|0;r=a+12|0;b=k[r>>2]|0;k[c>>2]=k[l>>2];k[r>>2]=k[m>>2];k[l>>2]=s;k[m>>2]=b;a=a+16|0;b=k[a>>2]|0;k[a>>2]=k[d>>2];k[d>>2]=b;b=t+3|0;return b|0}function bc(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0;x=ac(a,b,c,d)|0;m=k[e>>2]|0;n=k[d>>2]|0;do if((m|0)>=(n|0)){l=(m|0)==(n|0);if(l?(k[e+4>>2]|0)<(k[d+4>>2]|0):0)break;if((n|0)<(m|0)){b=x;return b|0}if(l?(i=k[d+4>>2]|0,j=k[e+4>>2]|0,(i|0)<(j|0)):0)w=12;else{j=k[e+8>>2]|0;i=k[d+8>>2]|0;if((j|0)<(i|0))break;if((j|0)==(i|0)?(k[e+12>>2]|0)<(k[d+12>>2]|0):0)break;if(l){i=k[d+4>>2]|0;j=k[e+4>>2]|0;w=12}else w=15}if((w|0)==12){if((i|0)<(j|0)){b=x;return b|0}if((j|0)>=(i|0)){i=k[d+8>>2]|0;j=k[e+8>>2]|0;w=15}}if((w|0)==15){if((i|0)<(j|0)){b=x;return b|0}if((i|0)==(j|0)?(k[d+12>>2]|0)<(k[e+12>>2]|0):0){b=x;return b|0}}if((k[e+16>>2]|0)>=(k[d+16>>2]|0)){b=x;return b|0}}while(0);o=d+4|0;w=k[o>>2]|0;k[d>>2]=m;p=e+4|0;k[o>>2]=k[p>>2];k[e>>2]=n;k[p>>2]=w;p=d+8|0;w=k[p>>2]|0;s=d+12|0;m=k[s>>2]|0;n=e+8|0;k[p>>2]=k[n>>2];u=e+12|0;k[s>>2]=k[u>>2];k[n>>2]=w;k[u>>2]=m;u=d+16|0;m=e+16|0;n=k[u>>2]|0;k[u>>2]=k[m>>2];k[m>>2]=n;m=x+1|0;n=k[d>>2]|0;e=k[c>>2]|0;do if((n|0)>=(e|0)){l=(n|0)==(e|0);if(l?(k[o>>2]|0)<(k[c+4>>2]|0):0)break;if((e|0)<(n|0)){b=m;return b|0}if(l?(q=k[c+4>>2]|0,r=k[o>>2]|0,(q|0)<(r|0)):0){j=q;i=r;w=30}else{j=k[p>>2]|0;i=k[c+8>>2]|0;if((j|0)<(i|0))break;if((j|0)==(i|0)?(k[s>>2]|0)<(k[c+12>>2]|0):0)break;if(l){j=k[c+4>>2]|0;i=k[o>>2]|0;w=30}else w=33}if((w|0)==30){if((j|0)<(i|0)){b=m;return b|0}if((i|0)>=(j|0)){i=k[c+8>>2]|0;j=k[p>>2]|0;w=33}}if((w|0)==33){if((i|0)<(j|0)){b=m;return b|0}if((i|0)==(j|0)?(k[c+12>>2]|0)<(k[s>>2]|0):0){b=m;return b|0}}if((k[u>>2]|0)>=(k[c+16>>2]|0)){b=m;return b|0}}while(0);t=c+4|0;q=k[t>>2]|0;k[c>>2]=n;k[t>>2]=k[o>>2];k[d>>2]=e;k[o>>2]=q;q=c+8|0;m=k[q>>2]|0;r=c+12|0;l=k[r>>2]|0;k[q>>2]=k[p>>2];k[r>>2]=k[s>>2];k[p>>2]=m;k[s>>2]=l;p=c+16|0;l=k[p>>2]|0;k[p>>2]=k[u>>2];k[u>>2]=l;l=x+2|0;m=k[c>>2]|0;n=k[b>>2]|0;do if((m|0)>=(n|0)){j=(m|0)==(n|0);if(j?(k[t>>2]|0)<(k[b+4>>2]|0):0)break;if((n|0)<(m|0)){b=l;return b|0}if(j?(v=k[b+4>>2]|0,h=k[t>>2]|0,(v|0)<(h|0)):0){i=v;w=48}else{i=k[q>>2]|0;h=k[b+8>>2]|0;if((i|0)<(h|0))break;if((i|0)==(h|0)?(k[r>>2]|0)<(k[b+12>>2]|0):0)break;if(j){i=k[b+4>>2]|0;h=k[t>>2]|0;w=48}else w=51}if((w|0)==48){if((i|0)<(h|0)){b=l;return b|0}if((h|0)>=(i|0)){h=k[b+8>>2]|0;i=k[q>>2]|0;w=51}}if((w|0)==51){if((h|0)<(i|0)){b=l;return b|0}if((h|0)==(i|0)?(k[b+12>>2]|0)<(k[r>>2]|0):0){b=l;return b|0}}if((k[p>>2]|0)>=(k[b+16>>2]|0)){b=l;return b|0}}while(0);o=b+4|0;i=k[o>>2]|0;k[b>>2]=m;k[o>>2]=k[t>>2];k[c>>2]=n;k[t>>2]=i;n=b+8|0;i=k[n>>2]|0;e=b+12|0;m=k[e>>2]|0;k[n>>2]=k[q>>2];k[e>>2]=k[r>>2];k[q>>2]=i;k[r>>2]=m;m=b+16|0;i=k[m>>2]|0;k[m>>2]=k[p>>2];k[p>>2]=i;i=x+3|0;j=k[b>>2]|0;l=k[a>>2]|0;do if((j|0)>=(l|0)){h=(j|0)==(l|0);if(h?(k[o>>2]|0)<(k[a+4>>2]|0):0)break;if((l|0)<(j|0)){b=i;return b|0}if(h?(g=k[a+4>>2]|0,f=k[o>>2]|0,(g|0)<(f|0)):0)w=66;else{g=k[n>>2]|0;f=k[a+8>>2]|0;if((g|0)<(f|0))break;if((g|0)==(f|0)?(k[e>>2]|0)<(k[a+12>>2]|0):0)break;if(h){g=k[a+4>>2]|0;f=k[o>>2]|0;w=66}else w=69}if((w|0)==66){if((g|0)<(f|0)){b=i;return b|0}if((f|0)>=(g|0)){f=k[a+8>>2]|0;g=k[n>>2]|0;w=69}}if((w|0)==69){if((f|0)<(g|0)){b=i;return b|0}if((f|0)==(g|0)?(k[a+12>>2]|0)<(k[e>>2]|0):0){b=i;return b|0}}if((k[m>>2]|0)>=(k[a+16>>2]|0)){b=i;return b|0}}while(0);c=a+4|0;v=k[c>>2]|0;k[a>>2]=j;k[c>>2]=k[o>>2];k[b>>2]=l;k[o>>2]=v;v=a+8|0;c=k[v>>2]|0;w=a+12|0;b=k[w>>2]|0;k[v>>2]=k[n>>2];k[w>>2]=k[e>>2];k[n>>2]=c;k[e>>2]=b;a=a+16|0;b=k[a>>2]|0;k[a>>2]=k[m>>2];k[m>>2]=b;b=x+4|0;return b|0}function cc(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0;switch((b-a|0)/20|0|0){case 2:{f=b+-20|0;g=k[f>>2]|0;h=k[a>>2]|0;do if((g|0)>=(h|0)){e=(g|0)==(h|0);if(e?(k[b+-16>>2]|0)<(k[a+4>>2]|0):0)break;if((h|0)<(g|0)){b=1;return b|0}if(e?(d=k[a+4>>2]|0,c=k[b+-16>>2]|0,(d|0)<(c|0)):0)w=13;else{d=k[b+-12>>2]|0;c=k[a+8>>2]|0;if((d|0)<(c|0))break;if((d|0)==(c|0)?(k[b+-8>>2]|0)<(k[a+12>>2]|0):0)break;if(e){d=k[a+4>>2]|0;c=k[b+-16>>2]|0;w=13}else w=16}if((w|0)==13){if((d|0)<(c|0)){b=1;return b|0}if((c|0)>=(d|0)){c=k[a+8>>2]|0;d=k[b+-12>>2]|0;w=16}}if((w|0)==16){if((c|0)<(d|0)){b=1;return b|0}if((c|0)==(d|0)?(k[a+12>>2]|0)<(k[b+-8>>2]|0):0){b=1;return b|0}}if((k[b+-4>>2]|0)>=(k[a+16>>2]|0)){b=1;return b|0}}while(0);s=a+4|0;t=k[s>>2]|0;k[a>>2]=g;w=b+-16|0;k[s>>2]=k[w>>2];k[f>>2]=h;k[w>>2]=t;w=a+8|0;t=k[w>>2]|0;s=a+12|0;v=k[s>>2]|0;u=b+-12|0;k[w>>2]=k[u>>2];w=b+-8|0;k[s>>2]=k[w>>2];k[u>>2]=t;k[w>>2]=v;w=a+16|0;b=b+-4|0;a=k[w>>2]|0;k[w>>2]=k[b>>2];k[b>>2]=a;b=1;return b|0}case 3:{$b(a,a+20|0,b+-20|0)|0;b=1;return b|0}case 4:{ac(a,a+20|0,a+40|0,b+-20|0)|0;b=1;return b|0}case 5:{bc(a,a+20|0,a+40|0,a+60|0,b+-20|0)|0;b=1;return b|0}case 1:case 0:{b=1;return b|0}default:{e=a+40|0;$b(a,a+20|0,e)|0;d=a+60|0;if((d|0)==(b|0)){b=1;return b|0}else c=0;while(1){s=k[d>>2]|0;i=k[e>>2]|0;do if((s|0)>=(i|0)){h=(s|0)==(i|0);if(h?(k[d+4>>2]|0)<(k[e+4>>2]|0):0){w=43;break}if((i|0)>=(s|0)){if(h?(u=k[e+4>>2]|0,v=k[d+4>>2]|0,(u|0)<(v|0)):0){f=u;g=v;w=36}else{f=k[d+8>>2]|0;g=k[e+8>>2]|0;if((f|0)<(g|0)){w=43;break}if((f|0)==(g|0)?(k[d+12>>2]|0)<(k[e+12>>2]|0):0){w=43;break}if(h){f=k[e+4>>2]|0;g=k[d+4>>2]|0;w=36}else w=39}if((w|0)==36){w=0;if((f|0)<(g|0))break;if((g|0)>=(f|0)){g=k[e+8>>2]|0;f=k[d+8>>2]|0;w=39}}if((w|0)==39){w=0;if((g|0)<(f|0))break;if((g|0)==(f|0)?(k[e+12>>2]|0)<(k[d+12>>2]|0):0)break}if((k[d+16>>2]|0)<(k[e+16>>2]|0))w=43}}else w=43;while(0);if((w|0)==43){w=0;m=d+4|0;o=k[m>>2]|0;g=d+8|0;p=k[g>>2]|0;f=d+12|0;q=k[f>>2]|0;n=d+16|0;r=k[n>>2]|0;k[d>>2]=i;h=e+4|0;k[m>>2]=k[h>>2];i=e+8|0;k[g>>2]=k[i>>2];g=e+12|0;k[f>>2]=k[g>>2];f=e+16|0;k[n>>2]=k[f>>2];a:do if((e|0)!=(a|0)){n=e;m=i;l=h;while(1){e=n+-20|0;j=k[e>>2]|0;do if((s|0)>=(j|0)){i=(s|0)==(j|0);if(i?(o|0)<(k[n+-16>>2]|0):0)break;if((j|0)<(s|0)){e=n;h=l;i=m;break a}if(i?(t=k[n+-16>>2]|0,(t|0)<(o|0)):0){h=t;w=55}else{h=k[n+-12>>2]|0;if((p|0)<(h|0))break;if((p|0)==(h|0)?(q|0)<(k[n+-8>>2]|0):0)break;if(i){h=k[n+-16>>2]|0;w=55}else w=58}if((w|0)==55){w=0;if((h|0)<(o|0)){e=n;h=l;i=m;break a}if((o|0)>=(h|0)){h=k[n+-12>>2]|0;w=58}}if((w|0)==58){w=0;if((h|0)<(p|0)){e=n;h=l;i=m;break a}if((h|0)==(p|0)?(k[n+-8>>2]|0)<(q|0):0){e=n;h=l;i=m;break a}}if((r|0)>=(k[n+-4>>2]|0)){e=n;h=l;i=m;break a}}while(0);k[n>>2]=j;h=n+-16|0;k[n+4>>2]=k[h>>2];i=n+-12|0;k[n+8>>2]=k[i>>2];g=n+-8|0;k[n+12>>2]=k[g>>2];f=n+-4|0;k[n+16>>2]=k[f>>2];if((e|0)==(a|0))break;else{n=e;m=i;l=h}}}while(0);k[e>>2]=s;k[h>>2]=o;k[i>>2]=p;k[g>>2]=q;k[f>>2]=r;c=c+1|0;if((c|0)==8)break}e=d+20|0;if((e|0)==(b|0)){c=1;w=66;break}else{s=d;d=e;e=s}}if((w|0)==66)return c|0;b=(d+20|0)==(b|0);return b|0}}return 0}function dc(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,l=0,m=0;f=a+4|0;g=k[a>>2]|0;c=g;h=(k[f>>2]|0)-c|0;i=h>>3;j=i+1|0;if(j>>>0>536870911)xa(1340,1363,303,1438);l=a+8|0;c=(k[l>>2]|0)-c|0;if(c>>3>>>0<268435455){c=c>>2;c=c>>>0<j>>>0?j:c;if(!c){c=0;d=0}else e=5}else{c=536870911;e=5}if((e|0)==5){e=c<<3;e=(e|0)==0?1:e;d=_d(e)|0;a:do if(!d){while(1){d=k[35]|0;k[35]=d+0;if(!d)break;Xa[d&0]();d=_d(e)|0;if(d)break a}a=ya(4)|0;k[a>>2]=128;La(a|0,8,1)}while(0)}m=b;e=k[m+4>>2]|0;b=d+(i<<3)|0;k[b>>2]=k[m>>2];k[b+4>>2]=e;fe(d|0,g|0,h|0)|0;k[a>>2]=d;k[f>>2]=d+(j<<3);k[l>>2]=d+(c<<3);if(!g)return;$d(g);return}function ec(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0;s=b;a:while(1){m=s;n=s+-8|0;o=s+-16|0;r=s+-4|0;w=a;b:while(1){l=w;a=m-l|0;b=a>>3;switch(b|0){case 2:{v=4;break a}case 3:{v=9;break a}case 4:{v=10;break a}case 5:{v=11;break a}case 1:case 0:{v=88;break a}default:{}}if((a|0)<56){v=13;break a}c=(b|0)/2|0;h=w+(c<<3)|0;if((a|0)>7992){a=(b|0)/4|0;a=ic(w,w+(a<<3)|0,h,w+(a+c<<3)|0,n)|0}else a=gc(w,h,n)|0;g=k[w>>2]|0;f=k[h>>2]|0;c:do if((g|0)<(f|0))c=n;else{if((f|0)>=(g|0)?(k[w+4>>2]|0)<(k[w+(c<<3)+4>>2]|0):0){c=n;break}d:do if((w|0)!=(o|0)){e=w+(c<<3)+4|0;c=o;b=n;while(1){d=k[c>>2]|0;if((d|0)<(f|0)){v=58;break}if((f|0)>=(d|0)?(p=b+-4|0,(k[p>>2]|0)<(k[e>>2]|0)):0){b=p;break}b=c+-8|0;if((w|0)==(b|0))break d;else{j=c;c=b;b=j}}if((v|0)==58){v=0;b=b+-4|0}k[w>>2]=d;k[c>>2]=g;i=w+4|0;j=k[i>>2]|0;k[i>>2]=k[b>>2];k[b>>2]=j;a=a+1|0;break c}while(0);a=w+8|0;f=k[n>>2]|0;do if((g|0)>=(f|0)){if((f|0)>=(g|0)?(k[w+4>>2]|0)<(k[r>>2]|0):0)break;if((a|0)==(n|0)){v=88;break a}d=w+4|0;e=w;while(1){b=e+8|0;c=k[b>>2]|0;if((g|0)<(c|0)){v=40;break}if((c|0)>=(g|0)?(q=e+12|0,(k[d>>2]|0)<(k[q>>2]|0)):0){a=q;break}b=a+8|0;if((b|0)==(n|0)){v=88;break a}else{e=a;a=b}}if((v|0)==40){v=0;a=e+12|0}k[b>>2]=f;k[n>>2]=c;l=k[a>>2]|0;k[a>>2]=k[r>>2];k[r>>2]=l;a=e+16|0}while(0);if((a|0)==(n|0)){v=88;break a}h=w+4|0;c=n;while(1){g=k[w>>2]|0;b=k[a>>2]|0;e:do if((g|0)<(b|0)){f=a;e=a}else while(1){if((b|0)>=(g|0)?(k[h>>2]|0)<(k[a+4>>2]|0):0){f=a;e=a;break e}a=a+8|0;b=k[a>>2]|0;if((g|0)<(b|0)){f=a;e=a;break}}while(0);while(1){d=c+-8|0;a=k[d>>2]|0;if((g|0)<(a|0)){c=d;continue}if((a|0)<(g|0))break;if((k[h>>2]|0)<(k[c+-4>>2]|0))c=d;else break}if(e>>>0>=d>>>0){w=e;continue b}k[f>>2]=a;k[d>>2]=b;l=e+4|0;a=c+-4|0;c=k[l>>2]|0;k[l>>2]=k[a>>2];k[a>>2]=c;a=e+8|0;c=d}}while(0);b=w+8|0;f:do if(b>>>0<c>>>0){f=h;while(1){g=k[f>>2]|0;h=f+4|0;j=b;while(1){i=k[j>>2]|0;if((i|0)>=(g|0)){if((g|0)<(i|0))break;if((k[j+4>>2]|0)>=(k[h>>2]|0))break}j=j+8|0}d=c+-8|0;b=k[d>>2]|0;g:do if((b|0)<(g|0))g=d;else{e=c;while(1){e=e+-8|0;if((g|0)>=(b|0)?(k[c+-4>>2]|0)<(k[h>>2]|0):0){g=e;d=e;break g}c=d+-8|0;b=k[c>>2]|0;if((b|0)<(g|0)){g=c;d=c;c=e;break}else{x=d;d=c;c=e;e=x}}}while(0);if(j>>>0>g>>>0){g=j;break f}k[j>>2]=b;k[d>>2]=i;x=j+4|0;b=c+-4|0;c=k[x>>2]|0;k[x>>2]=k[b>>2];k[b>>2]=c;b=j+8|0;c=g;f=(f|0)==(j|0)?g:f;a=a+1|0}}else{g=b;f=h}while(0);do if((g|0)!=(f|0)){d=k[f>>2]|0;e=k[g>>2]|0;if((d|0)>=(e|0)){if((e|0)<(d|0))break;b=f+4|0;c=g+4|0;if((k[b>>2]|0)>=(k[c>>2]|0))break}else{c=g+4|0;b=f+4|0}k[g>>2]=d;k[f>>2]=e;x=k[c>>2]|0;k[c>>2]=k[b>>2];k[b>>2]=x;a=a+1|0}while(0);if(!a){a=jc(w,g)|0;b=g+8|0;if(jc(b,s)|0){v=83;break}if(a){w=b;continue}}x=g;if((x-l|0)>=(m-x|0)){v=87;break}ec(w,g);w=g+8|0}if((v|0)==83){v=0;if(a){v=88;break}else{a=w;s=g;continue}}else if((v|0)==87){v=0;ec(g+8|0,s);a=w;s=g;continue}}if((v|0)==4){b=s+-8|0;c=k[b>>2]|0;d=k[w>>2]|0;if((c|0)>=(d|0)){if((d|0)<(c|0))return;a=w+4|0;if((k[r>>2]|0)>=(k[a>>2]|0))return}else a=w+4|0;k[w>>2]=c;k[b>>2]=d;x=k[a>>2]|0;k[a>>2]=k[r>>2];k[r>>2]=x;return}else if((v|0)==9){gc(w,w+8|0,n)|0;return}else if((v|0)==10){hc(w,w+8|0,w+16|0,n)|0;return}else if((v|0)==11){ic(w,w+8|0,w+16|0,w+24|0,n)|0;return}else if((v|0)==13){b=w+16|0;gc(w,w+8|0,b)|0;a=w+24|0;if((a|0)==(s|0))return;while(1){c=k[a>>2]|0;e=k[b>>2]|0;if((c|0)>=(e|0)){if((e|0)>=(c|0)?(t=a+4|0,u=b+4|0,(k[t>>2]|0)<(k[u>>2]|0)):0){c=u;d=t;v=18}}else{c=b+4|0;d=a+4|0;v=18}if((v|0)==18){v=0;i=a;h=k[i>>2]|0;i=k[i+4>>2]|0;k[a>>2]=e;k[d>>2]=k[c>>2];h:do if((b|0)!=(w|0)){f=b;while(1){b=f+-8|0;g=k[b>>2]|0;if((h|0)>=(g|0)){if((g|0)<(h|0)){b=f;break h}e=f+-4|0;d=k[e>>2]|0;if((i|0)<(d|0))c=e;else{b=f;break h}}else{d=f+-4|0;c=d;d=k[d>>2]|0}k[f>>2]=g;k[f+4>>2]=d;if((b|0)==(w|0))break;else f=b}}while(0);k[b>>2]=h;k[c>>2]=i}b=a+8|0;if((b|0)==(s|0))break;else{x=a;a=b;b=x}}return}else if((v|0)==88)return}function fc(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,l=0;f=a+4|0;g=k[a>>2]|0;c=g;h=(k[f>>2]|0)-c|0;i=(h|0)/12|0;j=i+1|0;if(j>>>0>357913941)xa(1340,1363,303,1438);l=a+8|0;c=((k[l>>2]|0)-c|0)/12|0;if(c>>>0<178956970){c=c<<1;c=c>>>0<j>>>0?j:c;if(!c){c=0;d=0}else e=5}else{c=357913941;e=5}if((e|0)==5){e=c*12|0;e=(e|0)==0?1:e;d=_d(e)|0;a:do if(!d){while(1){d=k[35]|0;k[35]=d+0;if(!d)break;Xa[d&0]();d=_d(e)|0;if(d)break a}a=ya(4)|0;k[a>>2]=128;La(a|0,8,1)}while(0)}e=d+(i*12|0)|0;k[e>>2]=k[b>>2];k[e+4>>2]=k[b+4>>2];k[e+8>>2]=k[b+8>>2];b=d+((((h|0)/-12|0)+i|0)*12|0)|0;fe(b|0,g|0,h|0)|0;k[a>>2]=b;k[f>>2]=d+(j*12|0);k[l>>2]=d+(c*12|0);if(!g)return;$d(g);return}function gc(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0;d=k[b>>2]|0;e=k[a>>2]|0;if((d|0)>=(e|0))if((e|0)<(d|0))f=0;else f=(k[b+4>>2]|0)<(k[a+4>>2]|0);else f=1;h=k[c>>2]|0;if((h|0)>=(d|0))if((d|0)<(h|0))g=0;else g=(k[c+4>>2]|0)<(k[b+4>>2]|0);else g=1;if(!f){if(!g){b=0;return b|0}k[b>>2]=h;k[c>>2]=d;g=b+4|0;e=c+4|0;f=k[g>>2]|0;k[g>>2]=k[e>>2];k[e>>2]=f;e=k[b>>2]|0;f=k[a>>2]|0;if((e|0)>=(f|0)){if((f|0)<(e|0)){b=1;return b|0}d=a+4|0;if((k[g>>2]|0)>=(k[d>>2]|0)){b=1;return b|0}}else d=a+4|0;k[a>>2]=e;k[b>>2]=f;b=k[d>>2]|0;k[d>>2]=k[g>>2];k[g>>2]=b;b=2;return b|0}if(g){k[a>>2]=h;k[c>>2]=e;a=a+4|0;b=c+4|0;c=k[a>>2]|0;k[a>>2]=k[b>>2];k[b>>2]=c;b=1;return b|0}k[a>>2]=d;k[b>>2]=e;g=a+4|0;f=b+4|0;e=k[g>>2]|0;k[g>>2]=k[f>>2];k[f>>2]=e;g=k[c>>2]|0;h=k[b>>2]|0;if((g|0)>=(h|0)){if((h|0)<(g|0)){b=1;return b|0}d=c+4|0;if((k[d>>2]|0)>=(e|0)){b=1;return b|0}}else d=c+4|0;k[b>>2]=g;k[c>>2]=h;b=k[f>>2]|0;k[f>>2]=k[d>>2];k[d>>2]=b;b=2;return b|0}function hc(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0;j=gc(a,b,c)|0;g=k[d>>2]|0;h=k[c>>2]|0;if((g|0)>=(h|0)){if((h|0)<(g|0)){b=j;return b|0}e=d+4|0;f=c+4|0;if((k[e>>2]|0)<(k[f>>2]|0))i=f;else{b=j;return b|0}}else{e=d+4|0;i=c+4|0}k[c>>2]=g;k[d>>2]=h;g=k[i>>2]|0;k[i>>2]=k[e>>2];k[e>>2]=g;e=j+1|0;g=k[c>>2]|0;h=k[b>>2]|0;if((g|0)>=(h|0)){if((h|0)<(g|0)){b=e;return b|0}f=b+4|0;if((k[i>>2]|0)<(k[f>>2]|0))d=f;else{b=e;return b|0}}else d=b+4|0;k[b>>2]=g;k[c>>2]=h;f=k[d>>2]|0;k[d>>2]=k[i>>2];k[i>>2]=f;f=j+2|0;g=k[b>>2]|0;h=k[a>>2]|0;if((g|0)>=(h|0)){if((h|0)<(g|0)){b=f;return b|0}e=a+4|0;if((k[d>>2]|0)>=(k[e>>2]|0)){b=f;return b|0}}else e=a+4|0;k[a>>2]=g;k[b>>2]=h;b=k[e>>2]|0;k[e>>2]=k[d>>2];k[d>>2]=b;b=j+3|0;return b|0}function ic(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0,j=0,l=0,m=0;m=hc(a,b,c,d)|0;h=k[e>>2]|0;i=k[d>>2]|0;if((h|0)>=(i|0)){if((i|0)<(h|0)){b=m;return b|0}f=e+4|0;g=d+4|0;if((k[f>>2]|0)<(k[g>>2]|0))l=g;else{b=m;return b|0}}else{f=e+4|0;l=d+4|0}k[d>>2]=h;k[e>>2]=i;h=k[l>>2]|0;k[l>>2]=k[f>>2];k[f>>2]=h;f=m+1|0;h=k[d>>2]|0;i=k[c>>2]|0;if((h|0)>=(i|0)){if((i|0)<(h|0)){b=f;return b|0}g=c+4|0;if((k[l>>2]|0)<(k[g>>2]|0))j=g;else{b=f;return b|0}}else j=c+4|0;k[c>>2]=h;k[d>>2]=i;f=k[j>>2]|0;k[j>>2]=k[l>>2];k[l>>2]=f;f=m+2|0;h=k[c>>2]|0;i=k[b>>2]|0;if((h|0)>=(i|0)){if((i|0)<(h|0)){b=f;return b|0}g=b+4|0;if((k[j>>2]|0)<(k[g>>2]|0))e=g;else{b=f;return b|0}}else e=b+4|0;k[b>>2]=h;k[c>>2]=i;g=k[e>>2]|0;k[e>>2]=k[j>>2];k[j>>2]=g;g=m+3|0;h=k[b>>2]|0;i=k[a>>2]|0;if((h|0)>=(i|0)){if((i|0)<(h|0)){b=g;return b|0}f=a+4|0;if((k[e>>2]|0)>=(k[f>>2]|0)){b=g;return b|0}}else f=a+4|0;k[a>>2]=h;k[b>>2]=i;b=k[f>>2]|0;k[f>>2]=k[e>>2];k[e>>2]=b;b=m+4|0;return b|0}function jc(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,l=0,m=0,n=0,o=0,p=0;switch(b-a>>3|0){case 2:{e=b+-8|0;f=k[e>>2]|0;g=k[a>>2]|0;if((f|0)>=(g|0)){if((g|0)<(f|0)){a=1;return a|0}c=b+-4|0;d=a+4|0;if((k[c>>2]|0)>=(k[d>>2]|0)){a=1;return a|0}}else{d=a+4|0;c=b+-4|0}k[a>>2]=f;k[e>>2]=g;a=k[d>>2]|0;k[d>>2]=k[c>>2];k[c>>2]=a;a=1;return a|0}case 3:{gc(a,a+8|0,b+-8|0)|0;a=1;return a|0}case 4:{hc(a,a+8|0,a+16|0,b+-8|0)|0;a=1;return a|0}case 5:{ic(a,a+8|0,a+16|0,a+24|0,b+-8|0)|0;a=1;return a|0}case 1:case 0:{a=1;return a|0}default:{e=a+16|0;gc(a,a+8|0,e)|0;d=a+24|0;if((d|0)==(b|0)){a=1;return a|0}else c=0;while(1){f=k[d>>2]|0;h=k[e>>2]|0;if((f|0)>=(h|0)){if((h|0)>=(f|0)?(n=d+4|0,o=e+4|0,(k[n>>2]|0)<(k[o>>2]|0)):0){f=o;g=n;p=15}}else{f=e+4|0;g=d+4|0;p=15}if((p|0)==15){p=0;m=d;l=k[m>>2]|0;m=k[m+4>>2]|0;k[d>>2]=h;k[g>>2]=k[f>>2];a:do if((e|0)!=(a|0)){j=e;while(1){e=j+-8|0;i=k[e>>2]|0;if((l|0)>=(i|0)){if((i|0)<(l|0)){e=j;break a}h=j+-4|0;g=k[h>>2]|0;if((m|0)<(g|0))f=h;else{e=j;break a}}else{g=j+-4|0;f=g;g=k[g>>2]|0}k[j>>2]=i;k[j+4>>2]=g;if((e|0)==(a|0))break;else j=e}}while(0);k[e>>2]=l;k[f>>2]=m;c=c+1|0;if((c|0)==8)break}e=d+8|0;if((e|0)==(b|0)){c=1;p=24;break}else{m=d;d=e;e=m}}if((p|0)==24)return c|0;a=(d+8|0)==(b|0);return a|0}}return 0}function kc(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0;m=a+4|0;e=k[m>>2]|0;l=k[a>>2]|0;c=l;i=e-c>>5;j=i+1|0;if(j>>>0>134217727)xa(1340,1363,303,1438);n=a+8|0;d=(k[n>>2]|0)-c|0;if(d>>5>>>0<67108863){d=d>>4;d=d>>>0<j>>>0?j:d;if(!d){g=0;f=0}else h=5}else{d=134217727;h=5}if((h|0)==5){g=d<<5;g=(g|0)==0?1:g;f=_d(g)|0;a:do if(!f){while(1){f=k[35]|0;k[35]=f+0;if(!f)break;Xa[f&0]();f=_d(g)|0;if(f)break a}n=ya(4)|0;k[n>>2]=128;La(n|0,8,1)}while(0);g=d}h=f+(i<<5)|0;d=h;g=f+(g<<5)|0;k[h>>2]=k[b>>2];q=b+4|0;p=k[q+4>>2]|0;o=f+(i<<5)+4|0;k[o>>2]=k[q>>2];k[o+4>>2]=p;k[f+(i<<5)+12>>2]=k[b+12>>2];k[f+(i<<5)+16>>2]=k[b+16>>2];k[f+(i<<5)+20>>2]=k[b+20>>2];k[f+(i<<5)+24>>2]=k[b+24>>2];k[f+(i<<5)+28>>2]=k[b+28>>2];f=f+(j<<5)|0;if((e|0)==(l|0))e=a;else{c=h;do{q=e;e=e+-32|0;k[c+-32>>2]=k[e>>2];b=q+-28|0;o=k[b+4>>2]|0;p=c+-28|0;k[p>>2]=k[b>>2];k[p+4>>2]=o;k[c+-20>>2]=k[q+-20>>2];k[c+-16>>2]=k[q+-16>>2];k[c+-12>>2]=k[q+-12>>2];k[c+-8>>2]=k[q+-8>>2];k[c+-4>>2]=k[q+-4>>2];c=d+-32|0;d=c}while((e|0)!=(l|0));e=a;c=k[a>>2]|0}k[e>>2]=d;k[m>>2]=f;k[n>>2]=g;if(!c)return;$d(c);return}function lc(a,b,c,d,e,f,g,h,l,m){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=+f;g=+g;h=h|0;l=l|0;m=m|0;var n=0,o=0,q=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0;_=r;r=r+256|0;R=_+72|0;S=_+56|0;y=_+32|0;t=_+232|0;E=_+220|0;u=_+245|0;v=_+216|0;w=_+244|0;x=_+212|0;O=_+200|0;P=_+184|0;J=_+168|0;M=_+152|0;N=_+124|0;L=_+120|0;K=_+24|0;Q=_+92|0;H=_+80|0;I=_;Z=_+188|0;Y=_+172|0;a=_+156|0;X=_+140|0;V=_+128|0;p[y>>3]=f;p[y+8>>3]=g;p[y+16>>3]=0.0;Nd(911,y);kb(Z,c,d,e);mc(Y,Z,f*3.141592653589793/180.0);W=Y+4|0;if((k[Y>>2]|0)!=(k[W>>2]|0)){k[X>>2]=0;U=X+4|0;k[U>>2]=0;k[X+8>>2]=0;k[V>>2]=0;T=V+4|0;k[T>>2]=0;k[V+8>>2]=0;p[I>>3]=g;p[I+8>>3]=0.0;k[I+16>>2]=X;k[I+20>>2]=V;e=(k[87]|0)>-1;a:do if(!2){a=954;G=6}else{b=954;a=954;while(1){if(!(i[b>>0]|0))break a;b=b+1|0;a=b;if(!(a&3)){a=b;G=6;break}}}while(0);if((G|0)==6){while(1){b=k[a>>2]|0;if(!((b&-2139062144^-2139062144)&b+-16843009))a=a+4|0;else break}if((b&255)<<24>>24)do a=a+1|0;while((i[a>>0]|0)!=0)}d=a-954|0;a=k[72]|0;b=(a|0)==0;b:do if(e){do if(b){a=i[346]|0;i[346]=a+255|a;a=k[68]|0;if(!(a&8)){k[70]=0;k[69]=0;b=k[79]|0;k[75]=b;k[73]=b;a=b+(k[80]|0)|0;k[72]=a;break}else{k[68]=a|32;a=0;G=28;break b}}else b=k[73]|0;while(0);if((a-b|0)>>>0<d>>>0){a=Ta[k[308>>2]&7](272,954,d)|0;G=28;break}else{fe(b|0,954,d|0)|0;k[73]=(k[73]|0)+d;G=30;break}}else{do if(b){a=i[346]|0;i[346]=a+255|a;a=k[68]|0;if(!(a&8)){k[70]=0;k[69]=0;b=k[79]|0;k[75]=b;k[73]=b;a=b+(k[80]|0)|0;k[72]=a;break}else{k[68]=a|32;a=0;G=28;break b}}else b=k[73]|0;while(0);if((a-b|0)>>>0<d>>>0){a=Ta[k[308>>2]&7](272,954,d)|0;G=28;break}else{fe(b|0,954,d|0)|0;k[73]=(k[73]|0)+d;G=30;break}}while(0);if((G|0)==28)if(!((a|0)!=(d|0)?((a>>>0)/(d>>>0)|0|0)<1:0))G=30;do if((G|0)==30){b=i[347]|0;if(b<<24>>24!=10){d=k[73]|0;a=k[72]|0;if(d>>>0<a>>>0){k[73]=d+1;i[d>>0]=10;break}}else a=k[72]|0;i[y>>0]=10;do if(!a){b=j[173]|0;a=(b&65535)<<24>>24;i[346]=a+255|a;a=k[68]|0;if(!(a&8)){k[70]=0;k[69]=0;d=k[79]|0;k[75]=d;k[73]=d;a=d+(k[80]|0)|0;k[72]=a;b=(b&65535)>>>8&255;G=39;break}else{k[68]=a|32;break}}else{d=k[73]|0;G=39}while(0);do if((G|0)==39)if(d>>>0>=a>>>0|b<<24>>24==10){Ta[k[308>>2]&7](272,y,1)|0;break}else{k[73]=d+1;i[d>>0]=10;break}while(0)}while(0);k[E>>2]=0;F=E+4|0;k[F>>2]=0;k[E+8>>2]=0;q=k[W>>2]|0;a=k[Y>>2]|0;b=(q-a|0)/44|0;e=b<<1;s=E+8|0;if((q|0)!=(a|0)){d=b<<6;d=(d|0)==0?1:d;b=_d(d)|0;c:do if(!b){while(1){b=k[35]|0;k[35]=b+0;if(!b)break;Xa[b&0]();b=_d(d)|0;if(b)break c}_=ya(4)|0;k[_>>2]=128;La(_|0,8,1)}while(0);d=b;n=b+(e<<5)|0;k[E>>2]=d;k[F>>2]=d;k[s>>2]=n;d=b;while(1){e=a+16|0;c=a+28|0;i[u>>0]=0;k[v>>2]=a;o=a;if(d>>>0<n>>>0){k[y>>2]=k[e>>2];k[y+4>>2]=k[e+4>>2];k[y+8>>2]=k[e+8>>2];k[t>>2]=k[c>>2];k[t+4>>2]=k[c+4>>2];k[t+8>>2]=k[c+8>>2];k[d>>2]=k[y>>2];k[d+4>>2]=k[y+4>>2];k[d+8>>2]=k[y+8>>2];D=d+12|0;k[D>>2]=k[t>>2];k[D+4>>2]=k[t+4>>2];k[D+8>>2]=k[t+8>>2];k[d+24>>2]=o;i[d+28>>0]=0;i[d+29>>0]=0;d=b+32|0;k[F>>2]=d;b=n}else{nc(E,e,c,u,v);d=k[F>>2]|0;b=k[s>>2]|0}i[w>>0]=1;k[x>>2]=a;if(d>>>0<b>>>0){k[y>>2]=k[c>>2];k[y+4>>2]=k[c+4>>2];k[y+8>>2]=k[c+8>>2];k[t>>2]=k[e>>2];k[t+4>>2]=k[e+4>>2];k[t+8>>2]=k[e+8>>2];k[d>>2]=k[y>>2];k[d+4>>2]=k[y+4>>2];k[d+8>>2]=k[y+8>>2];D=d+12|0;k[D>>2]=k[t>>2];k[D+4>>2]=k[t+4>>2];k[D+8>>2]=k[t+8>>2];k[d+24>>2]=o;i[d+28>>0]=1;i[d+29>>0]=0;k[F>>2]=(k[F>>2]|0)+32}else nc(E,c,e,w,x);a=a+44|0;if((a|0)==(q|0))break;b=k[F>>2]|0;d=b;n=k[s>>2]|0}c=k[E>>2]|0;b=k[F>>2]|0;oc(c,b);a=(c|0)==(b|0);if(!a){d=c;do{e=k[d+24>>2]|0;if(!(i[d+28>>0]|0))k[e+4>>2]=d;else k[e+8>>2]=d;d=d+32|0}while((d|0)!=(b|0))}}else{oc(0,0);b=0;c=0;a=1}k[S>>2]=b-c>>5;Nd(956,S);d:do if(a){d=b;a=b}else{a=c;while(1){if(!(k[a+8>>2]|0)){d=b;break d}a=a+32|0;if((a|0)==(b|0)){d=b;a=b;break}}}while(0);D=(a|0)==(d|0)?c:a;b=D+24|0;a=k[b>>2]|0;i[a+2>>0]=1;i[(k[a+4>>2]|0)+29>>0]=1;i[(k[a+8>>2]|0)+29>>0]=1;if(i[D+28>>0]|0){D=a+28|0;a=a+16|0;k[S>>2]=k[a>>2];k[S+4>>2]=k[a+4>>2];k[S+8>>2]=k[a+8>>2];k[a>>2]=k[D>>2];k[a+4>>2]=k[D+4>>2];k[a+8>>2]=k[D+8>>2];k[D>>2]=k[S>>2];k[D+4>>2]=k[S+4>>2];k[D+8>>2]=k[S+8>>2];a=k[b>>2]|0}pc(O,I,a,((k[W>>2]|0)-(k[Y>>2]|0)|0)==44);k[P>>2]=O;e=(k[87]|0)>-1;e:do if(!0){a=976;G=71}else{b=976;a=976;while(1){if(!(i[b>>0]|0))break e;b=b+1|0;a=b;if(!(a&3)){a=b;G=71;break}}}while(0);if((G|0)==71){while(1){b=k[a>>2]|0;if(!((b&-2139062144^-2139062144)&b+-16843009))a=a+4|0;else break}if((b&255)<<24>>24)do a=a+1|0;while((i[a>>0]|0)!=0)}d=a-976|0;a=k[72]|0;b=(a|0)==0;f:do if(e){do if(b){a=i[346]|0;i[346]=a+255|a;a=k[68]|0;if(!(a&8)){k[70]=0;k[69]=0;b=k[79]|0;k[75]=b;k[73]=b;a=b+(k[80]|0)|0;k[72]=a;break}else{k[68]=a|32;a=0;G=93;break f}}else b=k[73]|0;while(0);if((a-b|0)>>>0<d>>>0){a=Ta[k[308>>2]&7](272,976,d)|0;G=93;break}else{fe(b|0,976,d|0)|0;k[73]=(k[73]|0)+d;G=95;break}}else{do if(b){a=i[346]|0;i[346]=a+255|a;a=k[68]|0;if(!(a&8)){k[70]=0;k[69]=0;b=k[79]|0;k[75]=b;k[73]=b;a=b+(k[80]|0)|0;k[72]=a;break}else{k[68]=a|32;a=0;G=93;break f}}else b=k[73]|0;while(0);if((a-b|0)>>>0<d>>>0){a=Ta[k[308>>2]&7](272,976,d)|0;G=93;break}else{fe(b|0,976,d|0)|0;k[73]=(k[73]|0)+d;G=95;break}}while(0);if((G|0)==93)if(!((a|0)!=(d|0)?((a>>>0)/(d>>>0)|0|0)<1:0))G=95;do if((G|0)==95){d=i[347]|0;if(d<<24>>24!=10){a=k[73]|0;b=k[72]|0;if(a>>>0<b>>>0){k[73]=a+1;i[a>>0]=10;break}}else b=k[72]|0;i[S>>0]=10;do if(!b){d=j[173]|0;a=(d&65535)<<24>>24;i[346]=a+255|a;a=k[68]|0;if(!(a&8)){k[70]=0;k[69]=0;e=k[79]|0;k[75]=e;k[73]=e;b=e+(k[80]|0)|0;k[72]=b;a=(d&65535)>>>8&255;G=104;break}else{k[68]=a|32;break}}else{e=k[73]|0;a=d;G=104}while(0);do if((G|0)==104)if(e>>>0>=b>>>0|a<<24>>24==10){Ta[k[308>>2]&7](272,S,1)|0;break}else{k[73]=e+1;i[e>>0]=10;break}while(0)}while(0);b=((k[W>>2]|0)-(k[Y>>2]|0)|0)/44|0;if(b>>>0>1){w=O+4|0;x=O+8|0;y=Q+4|0;z=Q+8|0;A=Q+12|0;B=Q+16|0;C=Q+20|0;D=Q+24|0;a=k[E>>2]|0;v=k[F>>2]|0;u=1;do{k[R>>2]=u;k[R+4>>2]=b;Nd(978,R);t=a;q=k[O>>2]|0;s=k[w>>2]|0;d=v-t>>5;if(!d)b=a;else{e=t;b=a;do{o=(d|0)/2|0;c=e;n=k[c+(o<<5)>>2]|0;if((n|0)>=(q|0))if((n|0)==(q|0)?(k[c+(o<<5)+4>>2]|0)<(s|0):0)G=115;else d=o;else G=115;if((G|0)==115){G=0;e=c+(o+1<<5)|0;b=e;d=d+-1-o|0}}while((d|0)!=0)}k[J>>2]=t;k[M>>2]=0;k[N>>2]=2147483647;k[L>>2]=2147483647;p[K>>3]=17976931348623157.0e292;k[Q>>2]=P;k[y>>2]=O;k[z>>2]=M;k[A>>2]=K;k[B>>2]=N;k[C>>2]=L;k[D>>2]=J;g:do if((b|0)!=(v|0)){d=b;do{if(!(qc(Q,d)|0))break g;d=d+32|0}while((d|0)!=(v|0))}while(0);if((b|0)!=(a|0))do b=b+-32|0;while(!((b|0)==(a|0)|(qc(Q,b)|0)^1));if(!(k[x>>2]|0)){if(k[(k[J>>2]|0)+8>>2]|0){c=(k[87]|0)>-1;h:do if(!3){b=999;G=127}else{d=999;b=999;while(1){if(!(i[d>>0]|0))break h;d=d+1|0;b=d;if(!(b&3)){b=d;G=127;break}}}while(0);if((G|0)==127){while(1){d=k[b>>2]|0;if(!((d&-2139062144^-2139062144)&d+-16843009))b=b+4|0;else break}if((d&255)<<24>>24)do b=b+1|0;while((i[b>>0]|0)!=0)}e=b-999|0;b=k[72]|0;d=(b|0)==0;i:do if(c){do if(d){b=i[346]|0;i[346]=b+255|b;b=k[68]|0;if(!(b&8)){k[70]=0;k[69]=0;d=k[79]|0;k[75]=d;k[73]=d;b=d+(k[80]|0)|0;k[72]=b;break}else{k[68]=b|32;b=0;G=149;break i}}else d=k[73]|0;while(0);if((b-d|0)>>>0<e>>>0){b=Ta[k[308>>2]&7](272,999,e)|0;G=149;break}else{fe(d|0,999,e|0)|0;k[73]=(k[73]|0)+e;G=151;break}}else{do if(d){b=i[346]|0;i[346]=b+255|b;b=k[68]|0;if(!(b&8)){k[70]=0;k[69]=0;d=k[79]|0;k[75]=d;k[73]=d;b=d+(k[80]|0)|0;k[72]=b;break}else{k[68]=b|32;b=0;G=149;break i}}else d=k[73]|0;while(0);if((b-d|0)>>>0<e>>>0){b=Ta[k[308>>2]&7](272,999,e)|0;G=149;break}else{fe(d|0,999,e|0)|0;k[73]=(k[73]|0)+e;G=151;break}}while(0);do if((G|0)==149){G=0;if((b|0)==(e|0)){G=151;break}if(((b>>>0)/(e>>>0)|0|0)>=1)G=151}while(0);j:do if((G|0)==151){G=0;e=i[347]|0;do if(e<<24>>24==10)d=k[72]|0;else{b=k[73]|0;d=k[72]|0;if(b>>>0>=d>>>0)break;k[73]=b+1;i[b>>0]=10;break j}while(0);i[S>>0]=10;do if(!d){e=j[173]|0;b=(e&65535)<<24>>24;i[346]=b+255|b;b=k[68]|0;if(!(b&8)){k[70]=0;k[69]=0;c=k[79]|0;k[75]=c;k[73]=c;d=c+(k[80]|0)|0;k[72]=d;b=(e&65535)>>>8&255;G=160;break}else{k[68]=b|32;break}}else{c=k[73]|0;b=e;G=160}while(0);do if((G|0)==160){G=0;if(c>>>0>=d>>>0|b<<24>>24==10){Ta[k[308>>2]&7](272,S,1)|0;break}else{k[73]=c+1;i[c>>0]=10;break}}while(0)}while(0);if(k[x>>2]|0)G=165}}else G=165;k:do if((G|0)==165?(G=0,(k[(k[J>>2]|0)+8>>2]|0)==0):0){c=(k[87]|0)>-1;l:do if(!0){b=1004;G=169}else{b=1004;d=1004;while(1){if(!(i[b>>0]|0)){b=d;break l}b=b+1|0;d=b;if(!(d&3)){G=169;break}}}while(0);if((G|0)==169){G=0;while(1){d=k[b>>2]|0;if(!((d&-2139062144^-2139062144)&d+-16843009))b=b+4|0;else break}if((d&255)<<24>>24)do b=b+1|0;while((i[b>>0]|0)!=0)}e=b-1004|0;b=k[72]|0;d=(b|0)==0;m:do if(c){do if(d){b=i[346]|0;i[346]=b+255|b;b=k[68]|0;if(!(b&8)){k[70]=0;k[69]=0;d=k[79]|0;k[75]=d;k[73]=d;b=d+(k[80]|0)|0;k[72]=b;break}else{k[68]=b|32;b=0;G=191;break m}}else d=k[73]|0;while(0);if((b-d|0)>>>0<e>>>0){b=Ta[k[308>>2]&7](272,1004,e)|0;G=191;break}else{fe(d|0,1004,e|0)|0;k[73]=(k[73]|0)+e;break}}else{do if(d){b=i[346]|0;i[346]=b+255|b;b=k[68]|0;if(!(b&8)){k[70]=0;k[69]=0;d=k[79]|0;k[75]=d;k[73]=d;b=d+(k[80]|0)|0;k[72]=b;break}else{k[68]=b|32;b=0;G=191;break m}}else d=k[73]|0;while(0);if((b-d|0)>>>0<e>>>0){b=Ta[k[308>>2]&7](272,1004,e)|0;G=191;break}else{fe(d|0,1004,e|0)|0;k[73]=(k[73]|0)+e;break}}while(0);do if((G|0)==191){G=0;if((b|0)==(e|0))break;if(((b>>>0)/(e>>>0)|0|0)<1)break k}while(0);e=i[347]|0;do if(e<<24>>24==10)d=k[72]|0;else{b=k[73]|0;d=k[72]|0;if(b>>>0>=d>>>0)break;k[73]=b+1;i[b>>0]=10;break k}while(0);i[S>>0]=10;do if(!d){e=j[173]|0;b=(e&65535)<<24>>24;i[346]=b+255|b;b=k[68]|0;if(!(b&8)){k[70]=0;k[69]=0;c=k[79]|0;k[75]=c;k[73]=c;d=c+(k[80]|0)|0;k[72]=d;b=(e&65535)>>>8&255;G=202;break}else{k[68]=b|32;break}}else{c=k[73]|0;b=e;G=202}while(0);do if((G|0)==202){G=0;if(c>>>0>=d>>>0|b<<24>>24==10){Ta[k[308>>2]&7](272,S,1)|0;break}else{k[73]=c+1;i[c>>0]=10;break}}while(0)}while(0);E=k[J>>2]|0;b=E+24|0;d=k[b>>2]|0;i[d+2>>0]=1;i[(k[d+4>>2]|0)+29>>0]=1;i[(k[d+8>>2]|0)+29>>0]=1;if(i[E+28>>0]|0){E=d+28|0;d=d+16|0;k[S>>2]=k[d>>2];k[S+4>>2]=k[d+4>>2];k[S+8>>2]=k[d+8>>2];k[d>>2]=k[E>>2];k[d+4>>2]=k[E+4>>2];k[d+8>>2]=k[E+8>>2];k[E>>2]=k[S>>2];k[E+4>>2]=k[S+4>>2];k[E+8>>2]=k[S+8>>2];d=k[b>>2]|0}b=((k[W>>2]|0)-(k[Y>>2]|0)|0)/44|0;u=u+1|0;pc(H,I,d,(b|0)==(u|0));k[O>>2]=k[H>>2];k[O+4>>2]=k[H+4>>2];k[O+8>>2]=k[H+8>>2]}while(u>>>0<b>>>0)}else a=k[E>>2]|0;b=a;if(a){d=k[F>>2]|0;if((d|0)!=(a|0))k[F>>2]=d+(~((d+-32-b|0)>>>5)<<5);$d(a)}e=(k[87]|0)>-1;n:do if(!0){a=1012;G=216}else{b=1012;a=1012;while(1){if(!(i[b>>0]|0))break n;b=b+1|0;a=b;if(!(a&3)){a=b;G=216;break}}}while(0);if((G|0)==216){while(1){b=k[a>>2]|0;if(!((b&-2139062144^-2139062144)&b+-16843009))a=a+4|0;else break}if((b&255)<<24>>24)do a=a+1|0;while((i[a>>0]|0)!=0)}d=a-1012|0;a=k[72]|0;b=(a|0)==0;o:do if(e){do if(b){a=i[346]|0;i[346]=a+255|a;a=k[68]|0;if(!(a&8)){k[70]=0;k[69]=0;b=k[79]|0;k[75]=b;k[73]=b;a=b+(k[80]|0)|0;k[72]=a;break}else{k[68]=a|32;a=0;G=238;break o}}else b=k[73]|0;while(0);if((a-b|0)>>>0<d>>>0){a=Ta[k[308>>2]&7](272,1012,d)|0;G=238;break}else{fe(b|0,1012,d|0)|0;k[73]=(k[73]|0)+d;G=240;break}}else{do if(b){a=i[346]|0;i[346]=a+255|a;a=k[68]|0;if(!(a&8)){k[70]=0;k[69]=0;b=k[79]|0;k[75]=b;k[73]=b;a=b+(k[80]|0)|0;k[72]=a;break}else{k[68]=a|32;a=0;G=238;break o}}else b=k[73]|0;while(0);if((a-b|0)>>>0<d>>>0){a=Ta[k[308>>2]&7](272,1012,d)|0;G=238;break}else{fe(b|0,1012,d|0)|0;k[73]=(k[73]|0)+d;G=240;break}}while(0);if((G|0)==238)if(!((a|0)!=(d|0)?((a>>>0)/(d>>>0)|0|0)<1:0))G=240;do if((G|0)==240){d=i[347]|0;if(d<<24>>24!=10){a=k[73]|0;b=k[72]|0;if(a>>>0<b>>>0){k[73]=a+1;i[a>>0]=10;break}}else b=k[72]|0;i[S>>0]=10;do if(!b){d=j[173]|0;a=(d&65535)<<24>>24;i[346]=a+255|a;a=k[68]|0;if(!(a&8)){k[70]=0;k[69]=0;e=k[79]|0;k[75]=e;k[73]=e;b=e+(k[80]|0)|0;k[72]=b;a=(d&65535)>>>8&255;G=249;break}else{k[68]=a|32;break}}else{e=k[73]|0;a=d;G=249}while(0);do if((G|0)==249)if(e>>>0>=b>>>0|a<<24>>24==10){Ta[k[308>>2]&7](272,S,1)|0;break}else{k[73]=e+1;i[e>>0]=10;break}while(0)}while(0);jb(h,l,m,V);a=k[V>>2]|0;if(a){b=k[T>>2]|0;if((b|0)!=(a|0)){do{d=b+-12|0;k[T>>2]=d;e=k[d>>2]|0;c=e;if(!e)b=d;else{b=b+-8|0;d=k[b>>2]|0;if((d|0)!=(e|0))k[b>>2]=d+(~(((d+-12-c|0)>>>0)/12|0)*12|0);$d(e);b=k[T>>2]|0}}while((b|0)!=(a|0));a=k[V>>2]|0}$d(a)}a=k[X>>2]|0;if(a){b=k[U>>2]|0;if((b|0)!=(a|0))k[U>>2]=b+(~(((b+-44-a|0)>>>0)/44|0)*44|0);$d(a)}}else{k[a>>2]=0;k[a+4>>2]=0;k[a+8>>2]=0;jb(h,l,m,a)}a=k[Y>>2]|0;if(a){b=k[W>>2]|0;if((b|0)!=(a|0))k[W>>2]=b+(~(((b+-44-a|0)>>>0)/44|0)*44|0);$d(a)}o=k[Z>>2]|0;if(!o){r=_;return}n=Z+4|0;a=k[n>>2]|0;if((a|0)!=(o|0)){do{b=a;a=a+-12|0;e=k[a>>2]|0;c=e;if(e){b=b+-8|0;d=k[b>>2]|0;if((d|0)!=(e|0))k[b>>2]=d+(~((d+-8-c|0)>>>3)<<3);$d(e)}}while((a|0)!=(o|0));k[n>>2]=o}$d(o);r=_;return}\r\n\r\n// EMSCRIPTEN_END_FUNCS\r\nvar Ta=[ze,yd,Sd,Qd,Rd,ze,ze,ze];var Ua=[Ae,Ed,Dd,Ae];var Va=[Be,qd,rd,td,wd,ud,vd,xd,Wd,Be,Be,Be,Be,Be,Be,Be];var Wa=[Ce,sd,Pd,Ce];var Xa=[De];var Ya=[Ee,Gd,Fd,Ee];var Za=[Fe,nb,pb,zc,Dc,Fe,Fe,Fe];var _a=[Ge,zd,Ad,Ge];return{___cxa_can_catch:Hd,_free:$d,___cxa_is_pointer_type:Id,_i64Add:ge,_memmove:he,_vCarve:lc,_i64Subtract:be,_memset:ce,_malloc:_d,_separateTabs:lb,_memcpy:fe,_bitshift64Lshr:de,_bitshift64Shl:ee,runPostSets:ae,_emscripten_replace_memory:Sa,stackAlloc:$a,stackSave:ab,stackRestore:bb,establishStackSpace:cb,setThrew:db,setTempRet0:gb,getTempRet0:hb,dynCall_iiii:re,dynCall_viiiii:se,dynCall_vi:te,dynCall_ii:ue,dynCall_v:ve,dynCall_viiiiii:we,dynCall_iii:xe,dynCall_viiii:ye}})\r\n\r\n\r\n// EMSCRIPTEN_END_ASM\r\n(Module.asmGlobalArg,Module.asmLibraryArg,buffer);var ___cxa_can_catch=Module[\"___cxa_can_catch\"]=asm[\"___cxa_can_catch\"];var _free=Module[\"_free\"]=asm[\"_free\"];var runPostSets=Module[\"runPostSets\"]=asm[\"runPostSets\"];var ___cxa_is_pointer_type=Module[\"___cxa_is_pointer_type\"]=asm[\"___cxa_is_pointer_type\"];var _i64Add=Module[\"_i64Add\"]=asm[\"_i64Add\"];var _memmove=Module[\"_memmove\"]=asm[\"_memmove\"];var _vCarve=Module[\"_vCarve\"]=asm[\"_vCarve\"];var _i64Subtract=Module[\"_i64Subtract\"]=asm[\"_i64Subtract\"];var _memset=Module[\"_memset\"]=asm[\"_memset\"];var _malloc=Module[\"_malloc\"]=asm[\"_malloc\"];var _separateTabs=Module[\"_separateTabs\"]=asm[\"_separateTabs\"];var _memcpy=Module[\"_memcpy\"]=asm[\"_memcpy\"];var _emscripten_replace_memory=Module[\"_emscripten_replace_memory\"]=asm[\"_emscripten_replace_memory\"];var _bitshift64Lshr=Module[\"_bitshift64Lshr\"]=asm[\"_bitshift64Lshr\"];var _bitshift64Shl=Module[\"_bitshift64Shl\"]=asm[\"_bitshift64Shl\"];var dynCall_iiii=Module[\"dynCall_iiii\"]=asm[\"dynCall_iiii\"];var dynCall_viiiii=Module[\"dynCall_viiiii\"]=asm[\"dynCall_viiiii\"];var dynCall_vi=Module[\"dynCall_vi\"]=asm[\"dynCall_vi\"];var dynCall_ii=Module[\"dynCall_ii\"]=asm[\"dynCall_ii\"];var dynCall_v=Module[\"dynCall_v\"]=asm[\"dynCall_v\"];var dynCall_viiiiii=Module[\"dynCall_viiiiii\"]=asm[\"dynCall_viiiiii\"];var dynCall_iii=Module[\"dynCall_iii\"]=asm[\"dynCall_iii\"];var dynCall_viiii=Module[\"dynCall_viiii\"]=asm[\"dynCall_viiii\"];Runtime.stackAlloc=asm[\"stackAlloc\"];Runtime.stackSave=asm[\"stackSave\"];Runtime.stackRestore=asm[\"stackRestore\"];Runtime.establishStackSpace=asm[\"establishStackSpace\"];Runtime.setTempRet0=asm[\"setTempRet0\"];Runtime.getTempRet0=asm[\"getTempRet0\"];function ExitStatus(status){this.name=\"ExitStatus\";this.message=\"Program terminated with exit(\"+status+\")\";this.status=status}ExitStatus.prototype=new Error;ExitStatus.prototype.constructor=ExitStatus;var initialStackTop;var preloadStartTime=null;var calledMain=false;dependenciesFulfilled=function runCaller(){if(!Module[\"calledRun\"])run();if(!Module[\"calledRun\"])dependenciesFulfilled=runCaller};Module[\"callMain\"]=Module.callMain=function callMain(args){assert(runDependencies==0,\"cannot call main when async dependencies remain! (listen on __ATMAIN__)\");assert(__ATPRERUN__.length==0,\"cannot call main when preRun functions remain to be called\");args=args||[];ensureInitRuntime();var argc=args.length+1;function pad(){for(var i=0;i<4-1;i++){argv.push(0)}}var argv=[allocate(intArrayFromString(Module[\"thisProgram\"]),\"i8\",ALLOC_NORMAL)];pad();for(var i=0;i<argc-1;i=i+1){argv.push(allocate(intArrayFromString(args[i]),\"i8\",ALLOC_NORMAL));pad()}argv.push(0);argv=allocate(argv,\"i32\",ALLOC_NORMAL);try{var ret=Module[\"_main\"](argc,argv,0);exit(ret,true)}catch(e){if(e instanceof ExitStatus){return}else if(e==\"SimulateInfiniteLoop\"){Module[\"noExitRuntime\"]=true;return}else{if(e&&typeof e===\"object\"&&e.stack)Module.printErr(\"exception thrown: \"+[e,e.stack]);throw e}}finally{calledMain=true}};function run(args){args=args||Module[\"arguments\"];if(preloadStartTime===null)preloadStartTime=Date.now();if(runDependencies>0){return}preRun();if(runDependencies>0)return;if(Module[\"calledRun\"])return;function doRun(){if(Module[\"calledRun\"])return;Module[\"calledRun\"]=true;if(ABORT)return;ensureInitRuntime();preMain();if(Module[\"onRuntimeInitialized\"])Module[\"onRuntimeInitialized\"]();if(Module[\"_main\"]&&shouldRunNow)Module[\"callMain\"](args);postRun()}if(Module[\"setStatus\"]){Module[\"setStatus\"](\"Running...\");setTimeout((function(){setTimeout((function(){Module[\"setStatus\"](\"\")}),1);doRun()}),1)}else{doRun()}}Module[\"run\"]=Module.run=run;function exit(status,implicit){if(implicit&&Module[\"noExitRuntime\"]){return}if(Module[\"noExitRuntime\"]){}else{ABORT=true;EXITSTATUS=status;STACKTOP=initialStackTop;exitRuntime();if(Module[\"onExit\"])Module[\"onExit\"](status)}if(ENVIRONMENT_IS_NODE){process[\"stdout\"][\"once\"](\"drain\",(function(){process[\"exit\"](status)}));console.log(\" \");setTimeout((function(){process[\"exit\"](status)}),500)}else if(ENVIRONMENT_IS_SHELL&&typeof quit===\"function\"){quit(status)}throw new ExitStatus(status)}Module[\"exit\"]=Module.exit=exit;var abortDecorators=[];function abort(what){if(what!==undefined){Module.print(what);Module.printErr(what);what=JSON.stringify(what)}else{what=\"\"}ABORT=true;EXITSTATUS=1;var extra=\"\\nIf this abort() is unexpected, build with -s ASSERTIONS=1 which can give more information.\";var output=\"abort(\"+what+\") at \"+stackTrace()+extra;if(abortDecorators){abortDecorators.forEach((function(decorator){output=decorator(output,what)}))}throw output}Module[\"abort\"]=Module.abort=abort;if(Module[\"preInit\"]){if(typeof Module[\"preInit\"]==\"function\")Module[\"preInit\"]=[Module[\"preInit\"]];while(Module[\"preInit\"].length>0){Module[\"preInit\"].pop()()}}var shouldRunNow=true;if(Module[\"noInitialRun\"]){shouldRunNow=false}Module[\"noExitRuntime\"]=true;run()\r\n\r\n\r\n\r\n\r\n"

/***/ })
/******/ ]);
//# sourceMappingURL=f97a474f1354d1897040.worker.js.map