{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///lw.svg-parser.min.js","webpack:///webpack/bootstrap 87848381726b7842be86","webpack:///../~/lw.svg-path/dist/lw.svg-path.js","webpack:///./parser.js","webpack:///./tag.js","webpack:///./tagparser.js","webpack:///../~/clipper-lib/clipper.js","webpack:///../~/lw.svg-curves/dist/lw.svg-curves.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","t","n","i","e","o","TypeError","Object","defineProperty","value","length","enumerable","configurable","writable","key","prototype","x","parseFloat","y","isNaN","console","error","Error","r","points","forEach","push","arguments","X","parseInt","Y","addPoint","getPoint","isEqual","isClosed","map","Path","Point","default","_classCallCheck","instance","Constructor","Parser","undefined","_createClass","defineProperties","target","props","descriptor","protoProps","staticProps","_tag","_tagparser","settings","element","editor","document","defs","tags","traceSettings","assign","linear","step","resolution","segmentLength","supportedTags","parseTags","includes","skipTags","excludes","onTag","onTagContext","input","loadFromString","File","loadFromFile","XMLDocument","loadFromXMLDocument","Element","loadFromElement","Promise","reject","_this","resolve","nodeName","textContent","getElementsByTagName","_this2","documentElement","then","catch","_this3","_parseEditor","parser","DOMParser","XMLDoc","parseFromString","name","version","fingerprint","match","_this4","reader","FileReader","onload","event","result","onerror","readAsText","_this5","load","parse","_parseElement","applyMatrix","tag","callback","context","_this6","_onTag","parent","_this7","Tag","indexOf","_skipTag","tagParser","TagParser","childTag","childNodes","childNode","addChild","children","message","warn","attr","_interopRequireDefault","obj","__esModule","_lw","_clipperLib","_clipperLib2","DEG_TO_RAD","Math","PI","toLowerCase","layer","attrs","paths","matrix","path","point","shapes","setMatrix","keys","setAttr","defaultValue","getAttr","getLayerName","clearPath","close","relative","il","addMatrix","angle","cos","sin","tan","transform","shape","outer","holes","hole","fillRule","PolyFillType","pftNonZero","pftEvenOdd","cPolyTree","PolyTree","cClipper","Clipper","clipperScale","clipperPaths","getClipperPoints","AddPaths","PolyType","ptSubject","Execute","ClipType","ctUnion","PolyTreeToPaths","polygones","SimplifyPolygons","Clear","StrictlySimple","toPath","fromClipperPoints","exPolygons","JS","PolyTreeToExPolygons","exPolygon","_lw2","currentCommand","lastCommand","pathData","handler","_parseTagAttrs","attributes","viewBox","getNamedItem","_normalizeTagAttrPoints","style","some","_normalizeTagAttr","replace","split","nodeValue","colorsAttrs","attrName","_parseViewBoxAttr","_parseTransformAttr","trim","_skipTagAttr","_normalizeTagAttrUnit","_normalizeTagAttrRange","_normalizeTagAttrPreserveAspectRatio","ratio","stringValue","floatValue","fontSize","_parseNumbers","min","max","filter","params","defer","align","meet","slice","rawParams","substr","width","height","scaleX","scaleY","translateX","translateY","preserveAspectRatio","newWidth","newHeight","translate","scale","transformAttr","transformations","pop","type","raw","func","tagTransform","apply","newPath","closePath","addPoints","title","description","useTag","setLayerName","_path","shift","concat","_polyline","w","h","rx","ry","dx","dy","cx","cy","num","splice","join","dAttr","commands","parseError","toUpperCase","_clearPath","rl","firstPoint","_newPath","_addPoints","_closePath","every","_paths","p1","x1","y1","x2","y2","p2","p3","p4","tracer","CubicBezier","coords","trace","QuadricBezier","large","sweep","Arc","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_RESULT__","BigInteger","a","b","ClipperLib","biginteger_used","fromInt","fromNumber","fromString","nbi","am1","j","v","floor","am2","xl","xh","l","am3","int2char","BI_RM","charAt","intAt","s","BI_RC","charCodeAt","bnpCopyTo","bnpFromInt","DV","nbv","bnpFromString","k","fromRadix","mi","sh","DB","clamp","ZERO","subTo","bnpClamp","DM","bnToString","negate","toString","toRadix","d","km","bnNegate","bnAbs","bnCompareTo","nbits","bnBitLength","bnpDLShiftTo","bnpDRShiftTo","bnpLShiftTo","bs","cbs","bm","ds","bnpRShiftTo","bnpSubTo","bnpMultiplyTo","abs","am","bnpSquareTo","bnpDivRemTo","q","pm","pt","copyTo","ts","ms","nsh","lShiftTo","ys","y0","yt","F1","F2","d1","FV","d2","dlShiftTo","compareTo","ONE","qd","drShiftTo","rShiftTo","bnMod","divRemTo","Classic","cConvert","mod","cRevert","cReduce","cMulTo","multiplyTo","reduce","cSqrTo","squareTo","bnpInvDigit","Montgomery","mp","invDigit","mpl","mph","um","mt2","montConvert","montRevert","montReduce","u0","montSqrTo","montMulTo","bnpIsEven","bnpExp","z","r2","g","convert","sqrTo","mulTo","revert","bnModPowInt","isEven","exp","bnClone","bnIntValue","bnByteValue","bnShortValue","bnpChunkSize","LN2","log","bnSigNum","bnpToRadix","signum","cs","chunkSize","pow","intValue","bnpFromRadix","dMultiply","dAddOffset","bnpFromNumber","testBit","bitwiseTo","shiftLeft","op_or","isProbablePrime","bitLength","Array","nextBytes","bnToByteArray","bnEquals","bnMin","bnMax","bnpBitwiseTo","op","f","op_and","bnAnd","bnOr","op_xor","bnXor","op_andnot","bnAndNot","bnNot","bnShiftLeft","bnShiftRight","lbit","bnGetLowestSetBit","cbit","bnBitCount","bnTestBit","bnpChangeBit","bnSetBit","changeBit","bnClearBit","bnFlipBit","bnpAddTo","bnAdd","addTo","bnSubtract","bnMultiply","bnSquare","bnDivide","bnRemainder","bnDivideAndRemainder","bnpDMultiply","bnpDAddOffset","NullExp","nNop","nMulTo","nSqrTo","bnPow","bnpMultiplyLowerTo","bnpMultiplyUpperTo","Barrett","q3","mu","divide","barrettConvert","barrettRevert","barrettReduce","multiplyUpperTo","multiplyLowerTo","barrettSqrTo","barrettMulTo","bnModPow","k1","g2","is1","bnGCD","clone","getLowestSetBit","bnpModInt","bnModInverse","ac","u","subtract","add","bnIsProbablePrime","lowprimes","lplim","modInt","millerRabin","bnpMillerRabin","n1","shiftRight","random","modPow","modPowInt","use_int32","use_xyz","use_lines","isNode","window","self","navigator_appName","nav","navigator","userAgent","appName","browser","chrome","chromium","safari","firefox","firefox17","firefox15","firefox3","opera","msie10","msie9","msie8","msie7","msie","dbits","canary","j_lm","BI_FP","rr","vv","byteValue","shortValue","toByteArray","equals","and","or","xor","andNot","not","bitCount","setBit","clearBit","flipBit","multiply","remainder","divideAndRemainder","modInverse","gcd","square","Int128","IsNegative","op_Equality","val1","val2","op_Inequality","op_GreaterThan","op_LessThan","op_Addition","lhs","rhs","op_Subtraction","Int128Mul","op_Division","ToDouble","Inherit","ce","ce2","$baseCtor","getOwnPropertyNames","getOwnPropertyDescriptor","Paths","DoublePoint","DoublePoint0","DoublePoint1","dp","DoublePoint2","PolyNode","m_Parent","m_polygon","m_Index","m_jointype","m_endtype","m_Childs","IsOpen","IsHoleNode","node","ChildCount","Contour","AddChild","Child","cnt","GetNext","GetNextSiblingUp","Childs","Parent","IsHole","m_AllPolys","ilen","GetFirst","Total","Math_Abs_Int64","Math_Abs_Int32","Math_Abs_Double","Math_Max_Int32_Int32","Cast_Int32","Cast_Int64","ceil","Number","toInteger","PI2","IntPoint","alen","Z","Round","IntPoint0","IntPoint1","IntPoint1dp","IntPoint2","IntPoint3","IntRect","left","top","right","bottom","ir","IntRect0","IntRect1","IntRect4","ctIntersection","ctDifference","ctXor","ptClip","pftPositive","pftNegative","JoinType","jtSquare","jtRound","jtMiter","EndType","etOpenSquare","etOpenRound","etOpenButt","etClosedLine","etClosedPolygon","EdgeSide","esLeft","esRight","Direction","dRightToLeft","dLeftToRight","TEdge","Bot","Curr","Top","Delta","Dx","PolyTyp","Side","WindDelta","WindCnt","WindCnt2","OutIdx","Next","Prev","NextInLML","NextInAEL","PrevInAEL","NextInSEL","PrevInSEL","IntersectNode","Edge1","Edge2","Pt","MyIntersectNodeSort","Compare","node1","node2","LocalMinima","LeftBound","RightBound","Scanbeam","OutRec","Idx","FirstLeft","Pts","BottomPt","OutPt","Join","OutPt1","OutPt2","OffPt","ClipperBase","m_MinimaList","m_CurrentLM","m_edges","m_UseFullRange","m_HasOpenPaths","PreserveCollinear","horizontal","Skip","Unassigned","tolerance","loRange","hiRange","near_zero","val","IsHorizontal","PointIsVertex","pp","pp2","PointOnLineSegment","linePt1","linePt2","UseFullRange","PointOnPolygon","SlopesEqual","e1","e2","pt1","pt2","pt3","pt4","SlopesEqual3","SlopesEqual4","SlopesEqual5","DisposeLocalMinimaList","jlen","tmpLm","RangeTest","useFullRange","Value","InitEdge","eNext","ePrev","InitEdge2","polyType","SetDx","FindNextLocMin","E","E2","ProcessBound","LeftBoundIsForward","EStart","Horz","Result","locMin","InsertLocalMinima","ReverseHorizontal","AddPath","pg","Closed","highI","edges","IsFlat","$1","eStart","eLoopStop","Pt2IsBetweenPt1AndPt3","RemoveEdge","leftBoundIsForward","EMin","ppg","closed","newLm","PopLocalMinima","tmp","Reset","lm","InitOptions","m_PolyOuts","m_ClipType","m_Scanbeam","m_ActiveEdges","m_SortedEdges","m_IntersectList","m_IntersectNodeComparer","m_ExecuteLocked","m_ClipFillType","m_SubjFillType","m_Joins","m_GhostJoins","m_UsingPolyTree","ReverseSolution","ZFillFunction","ioReverseSolution","ioStrictlySimple","ioPreserveCollinear","DisposeAllPolyPts","DisposeScanbeamList","sb2","InsertScanbeam","newSb","ispolytree","clipType","solution","subjFillType","clipFillType","succeeded","ExecuteInternal","BuildResult","polytree","BuildResult2","FixHoleLinkage","outRec","orfl","botY","PopScanbeam","InsertLocalMinimaIntoAEL","ProcessHorizontals","topY","ProcessIntersections","ProcessEdgesAtTopOfScanbeam","Area","ReversePolyPtLinks","JoinCommonEdges","FixupOutPolygon","DoSimplePolygons","DisposeOutRec","index","AddJoin","Op1","Op2","AddGhostJoin","Op","SetZ","lb","rb","InsertEdgeIntoAEL","SetWindingCount","IsContributing","AddOutPt","AddLocalMinPoly","AddEdgeToSEL","HorzSegmentsOverlap","IntersectEdges","edge","startEdge","E2InsertsBeforeE1","TopX","IsEvenOddFillType","IsEvenOddAltFillType","pft","pft2","Inside","CopyAELToSEL","SwapPositionsInAEL","edge1","edge2","next","prev","SwapPositionsInSEL","AddLocalMaxPoly","AppendPolygon","prevE","outPt","CreateOutRec","ToFront","newOp","SetHoleState","SwapPoints","seg1a","seg1b","seg2a","seg2b","isHole","GetDx","FirstIsBottomPt","btmPt1","btmPt2","dx1p","dx1n","dx2p","dx2n","GetBottomPt","dups","GetLowermostRec","outRec1","outRec2","bPt1","bPt2","Param1RightOfParam2","GetOutRec","idx","outrec","holeStateRec","side","p1_lft","p1_rt","p2_lft","p2_rt","OKIdx","ObsoleteIdx","pp1","SwapSides","SwapPolyIndexes","outIdx","e1Contributing","e2Contributing","oldE1WindCnt","e1FillType","e2FillType","e1FillType2","e2FillType2","e1Wc","e2Wc","e1Wc2","e2Wc2","DeleteFromAEL","AelPrev","AelNext","DeleteFromSEL","SelPrev","SelNext","UpdateEdgeIntoAEL","isTopOfScanbeam","horzEdge","ProcessHorizontal","GetHorzDirection","HorzEdge","$var","Left","Right","Dir","dir","horzLeft","horzRight","eLastHorz","eMaxPair","GetMaximaPair","IsLastHorz","GetNextInAEL","op1","eNextHorz","op2","IsMinima","IsMaxima","IsIntermediate","BuildIntersectList","FixupIntersectionOrder","ProcessIntersectList","$$e2","isModified","IntersectPoint","newNode","EdgesAdjacent","inode","IntersectNodeSort","sort","iNode","R1","round","R2","R3","R4","currentY","ip","b1","b2","IsMaximaEdge","DoMaxima","ReversePaths","polys","len","reverse","Orientation","poly","PointCount","pts","polyg","pn","lastOK","DupOutPt","InsertAfter","GetOverlap","a1","a2","$val","JoinHorz","op1b","op2b","DiscardLeft","Dir1","Dir2","JoinPoints","isHorizontal","reverse1","reverse2","DiscardLeftSide","Reverse1","Reverse2","GetBounds","GetBounds2","ops","opStart","PointInPolygon","ipNext","startOp","ptx","pty","poly0x","poly0y","poly1x","poly1y","Poly2ContainsPoly1","outPt1","outPt2","res","FixupFirstLefts1","OldOutRec","NewOutRec","firstLeft","ParseFirstLeft","FixupFirstLefts2","$i2","$t2","$l2","UpdateOutPtIdxs","oRec","op3","op4","outrec2","SimplifyPolygon","fillType","DistanceSqrd","DistanceFromLineSqrd","ln1","ln2","A","B","C","SlopesNearCollinear","distSqrd","PointsAreClose","ExcludeOp","CleanPolygon","distance","outPts","CleanPolygons","Minkowski","pattern","IsSum","IsClosed","delta","polyCnt","pathCnt","quads","quad","MinkowskiSum","path_or_paths","pathIsClosed","TranslatePath","outPath","MinkowskiDiff","poly1","poly2","AddPolyNodeToPaths","NodeType","ntAny","polynode","nt","ntOpen","ntClosed","$i3","$t3","$l3","OpenPathsFromPolyTree","ClosedPathsFromPolyTree","ClipperOffset","miterLimit","arcTolerance","def_arc_tolerance","m_destPolys","m_srcPoly","m_destPoly","m_normals","m_delta","m_sinA","m_sin","m_cos","m_miterLim","m_StepsPerRad","m_lowest","m_polyNodes","MiterLimit","ArcTolerance","two_pi","joinType","endType","FixOrientations","GetUnitNormal","sqrt","DoOffset","steps","acos","OffsetPoint","DoSquare","DoRound","X2","clpr","outerNode","jointype","cosA","DoMiter","atan2","err","alert","AreaOfPolygon","AreaOfPolygons","area","BoundsOfPath","BoundsOfPaths","bounds","Clean","polygon","isPolygons","Clone","k_length","results","plen","Lighten","P","rem","addlast","bxax","byay","ax","ay","toleranceSq","PerimeterOfPath","perimeter","p1x","p1y","p2x","p2y","PerimeterOfPaths","ScaleDownPath","ScaleDownPaths","ScaleUpPath","ScaleUpPaths","ExPolygons","ExPolygon","AddOuterPolyNodeToExPolygons","expolygons","ep","childs","childs2","ExPolygonsToPaths","ReferenceError","create","constructor","setPrototypeOf","__proto__","Function","getPrototypeOf","get","arcLength","arcLengthMap","getPointAtT","_approximateLength","_addPoint","_postTrace","getPath","radians","__addPoint","center","startAngle","sweepAngle","init","_B1","_B2","_B3","_B4","_C1","unshift"],"mappings":"CAAA,SAAAA,EAAAC,GACA,gBAAAC,UAAA,gBAAAC,QACAA,OAAAD,QAAAD,IACA,kBAAAG,gBAAAC,IACAD,OAAA,eAAAH,GACA,gBAAAC,SACAA,QAAA,UAAAD,IAEAD,EAAA,UAAAC,KACCK,KAAA,WACD,MCAgB,UAAUC,GCN1B,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAP,OAGA,IAAAC,GAAAO,EAAAD,IACAP,WACAS,GAAAF,EACAG,QAAA,EAUA,OANAL,GAAAE,GAAAI,KAAAV,EAAAD,QAAAC,IAAAD,QAAAM,GAGAL,EAAAS,QAAA,EAGAT,EAAAD,QAvBA,GAAAQ,KAqCA,OATAF,GAAAM,EAAAP,EAGAC,EAAAO,EAAAL,EAGAF,EAAAQ,EAAA,GAGAR,EAAA,KDgBM,SAASL,EAAQD,EAASM,GAE/BL,EAAOD,QAAUM,EAAoB,IAKhC,SAASL,EAAQD,EAASM,IE7DhC,SAAAS,EAAAC,GAAef,EAAAD,QAAAgB,KAA6LZ,KAAA,WAAiB,gBAAAW,GAAmB,QAAAC,GAAAC,GAAc,GAAAC,EAAAD,GAAA,MAAAC,GAAAD,GAAAjB,OAA4B,IAAAmB,GAAAD,EAAAD,IAAYjB,WAAUS,GAAAQ,EAAAP,QAAA,EAAiB,OAAAK,GAAAE,GAAAN,KAAAQ,EAAAnB,QAAAmB,IAAAnB,QAAAgB,GAAAG,EAAAT,QAAA,EAAAS,EAAAnB,QAAgE,GAAAkB,KAAS,OAAAF,GAAAJ,EAAAG,EAAAC,EAAAH,EAAAK,EAAAF,EAAAF,EAAA,GAAAE,EAAA,KAA+B,SAAAD,EAAAC,EAAAE,GAAkBH,EAAAf,QAAAkB,EAAA,IAAe,SAAAH,EAAAC,GAAe,YAAa,SAAAE,GAAAH,EAAAC,GAAgB,KAAAD,YAAAC,IAAA,SAAAI,WAAA,qCAA8EC,OAAAC,eAAAN,EAAA,cAAsCO,OAAA,GAAW,IAAAN,GAAA,WAAiB,QAAAF,KAAAC,GAAgB,OAAAE,GAAA,EAAYA,EAAAF,EAAAQ,OAAWN,IAAA,CAAK,GAAAD,GAAAD,EAAAE,EAAWD,GAAAQ,WAAAR,EAAAQ,aAAA,EAAAR,EAAAS,cAAA,WAAAT,OAAAU,UAAA,GAAAN,OAAAC,eAAAP,EAAAE,EAAAW,IAAAX,IAA+G,gBAAAD,EAAAE,EAAAD,GAAuB,MAAAC,IAAAH,EAAAC,EAAAa,UAAAX,GAAAD,GAAAF,EAAAC,EAAAC,GAAAD,MAAwCG,EAAA,WAAgB,QAAAJ,GAAAC,EAAAC,GAAgB,GAAAC,EAAAd,KAAAW,GAAAX,KAAA0B,EAAAC,WAAAf,GAAAZ,KAAA4B,EAAAD,WAAAd,GAAAgB,MAAA7B,KAAA0B,IAAAG,MAAA7B,KAAA4B,GAAA,KAAAE,SAAAC,MAAA,aAAAnB,EAAAC,EAAA,QAAAmB,OAAA,gDAAwL,MAAAnB,GAAAF,IAAaa,IAAA,UAAAL,MAAA,SAAAR,GAAgC,MAAAX,MAAA0B,IAAAf,EAAAe,GAAA1B,KAAA4B,IAAAjB,EAAAiB,MAAmCjB,KAAKsB,EAAA,WAAgB,QAAAtB,KAAaG,EAAAd,KAAAW,GAAAX,KAAAkC,UAAAlC,KAAAoB,OAAA,EAAuC,MAAAP,GAAAF,IAAaa,IAAA,YAAAL,MAAA,WAAiC,MAAAnB,MAAAkC,UAAsBV,IAAA,mBAAAL,MAAA,WAAwC,GAAAR,KAAS,OAAAX,MAAAkC,OAAAC,QAAA,SAAAvB,GAAuC,MAAAD,GAAAyB,KAAAxB,EAAAc,EAAAd,EAAAgB,KAAuBjB,KAAOa,IAAA,mBAAAL,MAAA,WAAwC,GAAAR,GAAA0B,UAAAjB,OAAA,YAAAiB,UAAA,GAAAA,UAAA,KAAAzB,IAAoE,OAAAZ,MAAAkC,OAAAC,QAAA,SAAArB,GAAuC,MAAAF,GAAAwB,MAAeE,EAAAC,SAAAzB,EAAAY,EAAAf,GAAA6B,EAAAD,SAAAzB,EAAAc,EAAAjB,OAAsCC,KAAOY,IAAA,oBAAAL,MAAA,SAAAR,GAA0C,GAAAC,GAAAZ,KAAAc,EAAAuB,UAAAjB,OAAA,YAAAiB,UAAA,GAAAA,UAAA,IAAsE,OAAArC,MAAAkC,UAAAvB,EAAAwB,QAAA,SAAAxB,GAA4C,MAAAC,GAAA6B,SAAAd,WAAAhB,EAAA2B,EAAAxB,GAAAa,WAAAhB,EAAA6B,EAAA1B,MAAuDd,QAAUwB,IAAA,WAAAL,MAAA,SAAAR,GAAiC,MAAAX,MAAAkC,OAAAvB,EAAA,EAAAX,KAAAoB,OAAAT,MAAA,QAAiDa,IAAA,WAAAL,MAAA,SAAAR,EAAAC,GAAmCZ,KAAAkC,OAAAE,KAAA,GAAArB,GAAAJ,EAAAC,IAAAZ,KAAAoB,OAAApB,KAAAkC,OAAAd,UAA+DI,IAAA,YAAAL,MAAA,SAAAR,GAAkC,OAAAC,GAAA,EAAAE,EAAAH,EAAAS,OAAuBR,EAAAE,EAAIF,GAAA,EAAAZ,KAAAyC,SAAA9B,EAAAC,GAAAD,EAAAC,EAAA,OAAmCY,IAAA,WAAAL,MAAA,WAAgC,GAAAR,GAAAX,KAAA0C,SAAA,EAAuB,OAAA/B,MAAAgC,QAAA3C,KAAA0C,UAAA,OAA0ClB,IAAA,QAAAL,MAAA,WAA6B,IAAAnB,KAAA4C,YAAA5C,KAAAoB,OAAA,GAAoC,GAAAT,GAAAX,KAAA0C,SAAA,EAAuB,OAAA1C,MAAAyC,SAAA9B,EAAAe,EAAAf,EAAAiB,IAAA,EAAiC,YAAYJ,IAAA,YAAAL,MAAA,SAAAR,GAAkCX,KAAAkC,OAAAlC,KAAAkC,OAAAW,IAAA,SAAAjC,GAAwC,UAAAG,GAAAJ,EAAA,GAAAC,EAAAc,EAAAf,EAAA,GAAAC,EAAAgB,EAAAjB,EAAA,GAAAA,EAAA,GAAAC,EAAAc,EAAAf,EAAA,GAAAC,EAAAgB,EAAAjB,EAAA,UAA+DA,IAAQC,GAAAkC,KAAAb,EAAArB,EAAAmC,MAAAhC,EAAAH,EAAAoC,QAAAf,QFoEv8E,SAASpC,EAAQD,EAASM,GAE/B,YAcA,SAAS+C,GAAgBC,EAAUC,GAAe,KAAMD,YAAoBC,IAAgB,KAAM,IAAInC,WAAU,qCAZhHC,OAAOC,eAAetB,EAAS,cAC3BuB,OAAO,IAEXvB,EAAQwD,OAASC,MAEjB,IAAIC,GAAe,WAAc,QAASC,GAAiBC,EAAQC,GAAS,IAAK,GAAI5C,GAAI,EAAGA,EAAI4C,EAAMrC,OAAQP,IAAK,CAAE,GAAI6C,GAAaD,EAAM5C,EAAI6C,GAAWrC,WAAaqC,EAAWrC,aAAc,EAAOqC,EAAWpC,cAAe,EAAU,SAAWoC,KAAYA,EAAWnC,UAAW,GAAMN,OAAOC,eAAesC,EAAQE,EAAWlC,IAAKkC,IAAiB,MAAO,UAAUP,EAAaQ,EAAYC,GAAiJ,MAA9HD,IAAYJ,EAAiBJ,EAAY1B,UAAWkC,GAAiBC,GAAaL,EAAiBJ,EAAaS,GAAqBT,MG5EjiBU,EAAA3D,EAAA,GACA4D,EAAA5D,EAAA,GAGMkD,EHkFQ,WGhFV,QAAAA,GAAYW,GAAUd,EAAAjD,KAAAoD,GAElBW,EAAWA,MAGX/D,KAAKgE,QAAW,KAChBhE,KAAKiE,OAAW,KAChBjE,KAAKkE,SAAW,KAChBlE,KAAKmE,KAAW,KAChBnE,KAAKoE,KAAW,KAGhBpE,KAAKqE,cAAgBpD,OAAOqD,QACxBC,QAAe,EACfC,KAAe,IACfC,WAAe,IACfC,cAAe,GAChBX,EAASM,mBAGZrE,KAAK2E,eACD,MAAO,IAAK,OAAQ,MACpB,OAAQ,WAAY,UACpB,OAAQ,SAAU,UAAW,OAC7B,QAAS,OAAQ,QAAS,QAI9B3E,KAAK4E,UAAYb,EAASc,UAAY7E,KAAK2E,cAC3C3E,KAAK8E,SAAYf,EAASgB,WAAa,QAAS,YAGhDhB,EAASiB,OAAShF,KAAKgF,MAAMjB,EAASiB,MAAOjB,EAASkB,cHmYzD,MA/SA3B,GAAaF,IACT5B,IAAK,OACLL,MAAO,SGlFP+D,GAED,MAAqB,gBAAVA,GACAlF,KAAKmF,eAAeD,GAI3BA,YAAiBE,MACVpF,KAAKqF,aAAaH,GAIzBA,YAAiBI,aACVtF,KAAKuF,oBAAoBL,GAIhCA,YAAiBM,SACVxF,KAAKyF,gBAAgBP,GAIzBQ,QAAQC,OAAO,GAAI3D,OAAM,iCHwF/BR,IAAK,kBACLL,MAAO,SGrFI+D,GAAO,GAAAU,GAAA5F,IACnB,OAAO,IAAI0F,SAAQ,SAACG,EAASF,GAElBT,YAAiBM,UACpBG,EAAO,GAAI3D,OAAM,0CAIE,gBAAnBkD,EAAMY,UACNH,EAAO,GAAI3D,OAAMkD,EAAMa,cAGJ,SAAnBb,EAAMY,UAAuBZ,EAAMc,qBAAqB,gBACxDL,EAAO,GAAI3D,OAAMkD,EAAMc,qBAAqB,eAAe,GAAGD,cAIlEH,EAAK5B,QAAUkB,EAGfW,EAAQX,QHgGX1D,IAAK,sBACLL,MAAO,SG5FQ+D,GAAO,GAAAe,GAAAjG,IACvB,OAAO,IAAI0F,SAAQ,SAACG,EAASF,GAElBT,YAAiBI,cACpBK,EAAO,GAAI3D,OAAM,8CAIrBiE,EAAKR,gBAAgBP,EAAMgB,iBAAiBC,KAAKN,GAASO,MAAMT,QHqGnEnE,IAAK,iBACLL,MAAO,SGjGG+D,GAAO,GAAAmB,GAAArG,IAClB,OAAO,IAAI0F,SAAQ,SAACG,EAASF,GAEJ,gBAAVT,IACPS,EAAO,GAAI3D,OAAM,kCAIrBqE,EAAKC,aAAapB,EAGlB,IAAIqB,GAAS,GAAIC,WACbC,EAASF,EAAOG,gBAAgBxB,EAAO,WAG3CmB,GAAKd,oBAAoBkB,GAAQN,KAAKN,GAASO,MAAMT,QH0GxDnE,IAAK,eACLL,MAAO,SGtGC+D,GAETlF,KAAKiE,QACD0C,KAAa,UACbC,QAAa,KACbC,YAAa,KAIjB,IAAIA,SAKJ,QAFAA,EAAc3B,EAAM4B,MAAM,uCAGtB9G,KAAKiE,OAAO0C,KAAc,WAC1B3G,KAAKiE,OAAO4C,YAAcA,EAAY,GAE/B7G,KAAKiE,SAIhB4C,EAAc3B,EAAM4B,MAAM,wDAEtBD,GACA7G,KAAKiE,OAAO0C,KAAc,cAC1B3G,KAAKiE,OAAO2C,QAAcC,EAAY,GACtC7G,KAAKiE,OAAO4C,YAAcA,EAAY,GAE/B7G,KAAKiE,QAITjE,KAAKiE,WH4GXzC,IAAK,eACLL,MAAO,SGzGC+D,GAAO,GAAA6B,GAAA/G,IAChB,OAAO,IAAI0F,SAAQ,SAACG,EAASF,GAElBT,YAAiBE,OACpBO,EAAO,GAAI3D,OAAM,sCAIrB,IAAIgF,GAAS,GAAIC,WAGjBD,GAAOE,OAAS,SAAAC,GACZJ,EAAK5B,eAAegC,EAAM3D,OAAO4D,QAAQjB,KAAKN,GAASO,MAAMT,IAGjEqB,EAAOK,QAAU,SAAAF,GACbxB,EAAO,GAAI3D,OAAM,wBAA0BkD,EAAMyB,QAIrDK,EAAOM,WAAWpC,QHkHrB1D,IAAK,QACLL,MAAO,SG9GN+D,GAAO,GAAAqC,GAAAvH,IAOT,OALAA,MAAKkE,SAAW,KAChBlE,KAAKmE,QACLnE,KAAKoE,KAAW,KAGZc,EACO,GAAIQ,SAAQ,SAACG,EAASF,GACzB4B,EAAKC,KAAKtC,GAAOiB,KAAK,WAClBN,EAAQ0B,EAAKE,WACdrB,MAAMT,KAKV,GAAID,SAAQ,SAACG,EAASF,GAEnB4B,EAAKvD,SACP2B,EAAO,GAAI3D,OAAM,uDAIrBuF,EAAKnD,KAAOmD,EAAKG,cAAcH,EAAKvD,SAE9BuD,EAAKnD,MACPuB,EAAO,GAAI3D,OAAM,6BAIrBuF,EAAKnD,KAAKuD,cAGV9B,EAAQ0B,EAAKnD,WHuHhB5C,IAAK,SACLL,MAAO,SGnHLyG,OH0HFpG,IAAK,QACLL,MAAO,SGtHN0G,EAAUC,GAAS,GAAAC,GAAA/H,IACrBA,MAAKgI,OAAS,SAAAJ,GAAA,MAAOC,GAAStH,KAAKuH,KAAiBF,OHgInDpG,IAAK,gBACLL,MAAO,SG7HE6C,EAASiE,GAAQ,GAAAC,GAAAlI,KAEvB4H,EAAM,GAAA/D,GAAAsE,IAAQnE,EAASiE,EAG3B,IAAIjI,KAAK8E,SAASsD,QAAQR,EAAIjB,SAAU,EACpC,MAAO,KAIX,IAAI3G,KAAK4E,UAAUwD,QAAQR,EAAIjB,SAAU,EACrC,MAAO3G,MAAKqI,SAAST,EAAK,cAI9B,IAAIU,GAAY,GAAAxE,GAAAyE,UAAcX,EAAK5H,KAEnC,KAAMsI,EAAUb,QACZ,OAAO,CAIXzH,MAAKgI,OAAOJ,EAGZ,IAAIY,SAUJ,OARAxE,GAAQyE,WAAWtG,QAAQ,SAAAuG,IAEnBF,EAAWN,EAAKR,cAAcgB,EAAWd,KACzCA,EAAIe,SAASH,MAKhB,MAAO,KAAKJ,QAAQR,EAAIjB,SAAU,GAAQiB,EAAIgB,SAASxH,OAKrDwG,EAJI5H,KAAKqI,SAAST,EAAK,YHyI7BpG,IAAK,WACLL,MAAO,SGlIHyG,EAAKiB,GAEV,MADA/G,SAAQgH,KAAK,aAAcD,EAAU,IAAKjB,IACnC,KHwINpG,IAAK,eACLL,MAAO,SGrICyG,EAAKmB,EAAMF,GAEpB,MADA/G,SAAQgH,KAAK,uBAAwBD,EAAU,IAAKE,EAAMnB,IACnD,MHyIHxE,IAMXxD,GGzIQwD,SH0IRxD,EAAQoD,QGzIMI,GH6IT,SAASvD,EAAQD,EAASM,GAE/B,YAeA,SAAS8I,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQjG,QAASiG,GAEvF,QAAShG,GAAgBC,EAAUC,GAAe,KAAMD,YAAoBC,IAAgB,KAAM,IAAInC,WAAU,qCAfhHC,OAAOC,eAAetB,EAAS,cAC3BuB,OAAO,IAEXvB,EAAQuI,IAAM9E,MAEd,IAAIC,GAAe,WAAc,QAASC,GAAiBC,EAAQC,GAAS,IAAK,GAAI5C,GAAI,EAAGA,EAAI4C,EAAMrC,OAAQP,IAAK,CAAE,GAAI6C,GAAaD,EAAM5C,EAAI6C,GAAWrC,WAAaqC,EAAWrC,aAAc,EAAOqC,EAAWpC,cAAe,EAAU,SAAWoC,KAAYA,EAAWnC,UAAW,GAAMN,OAAOC,eAAesC,EAAQE,EAAWlC,IAAKkC,IAAiB,MAAO,UAAUP,EAAaQ,EAAYC,GAAiJ,MAA9HD,IAAYJ,EAAiBJ,EAAY1B,UAAWkC,GAAiBC,GAAaL,EAAiBJ,EAAaS,GAAqBT,MI9bjiBgG,EAAAjJ,EAAA,GACAkJ,EAAAlJ,EAAA,GJmcKmJ,EAAeL,EAAuBI,GIjcrCE,EAAaC,KAAKC,GAAK,IAGvBrB,EJwcK,WItcP,QAAAA,GAAYnE,EAASiE,GAAQ,GAAArC,GAAA5F,IAAAiD,GAAAjD,KAAAmI,GAEzBnI,KAAKgE,QAAWA,EAChBhE,KAAK2G,KAAW3C,EAAQ8B,SAAS2D,cACjCzJ,KAAKiI,OAAWA,GAAU,KAC1BjI,KAAK0J,MAAW,KAChB1J,KAAK2J,SACL3J,KAAK4I,YACL5I,KAAK4J,SACL5J,KAAK6J,OAAW,KAChB7J,KAAK8J,KAAW,GAAAX,GAAArG,KAChB9C,KAAK+J,MAAW,GAAAZ,GAAApG,MAAU,EAAG,GAC7B/C,KAAKgK,UAGLhK,KAAK4J,MAAMxH,KAAKpC,KAAK8J,MAGrB9J,KAAKiK,UAAUjK,KAAKiI,QAAUjI,KAAKiI,OAAO4B,SAGtC7J,KAAKiI,QAAgC,MAArBjI,KAAKiI,OAAOtB,MAAqC,QAArB3G,KAAKiI,OAAOtB,OAAiB,WAEzEf,EAAK8D,MAAQ9D,EAAKqC,OAAOyB,KAGzB,IAAI3E,IAAY,YAAa,QAAS,SAEpB,OAAda,EAAKe,MAA8B,QAAdf,EAAKe,MAC1B5B,EAAS3C,KAAK,WAGlBnB,OAAOiJ,KAAKtE,EAAKqC,OAAO0B,OAAOxH,QAAQ,SAAAX,GAC/BuD,EAASqD,QAAQ5G,MAAS,GAC1BoE,EAAKuE,QAAQ3I,EAAKoE,EAAKqC,OAAO0B,MAAMnI,SJqqBnD,MAjNA8B,GAAa6E,IACT3G,IAAK,UACLL,MAAO,SIhdJwF,EAAMxF,GACVnB,KAAK2J,MAAMhD,GAAQxF,KJmdlBK,IAAK,UACLL,MAAO,SIjdJwF,EAAMyD,GACV,MAA4B/G,UAArBrD,KAAK2J,MAAMhD,GAAsB3G,KAAK2J,MAAMhD,GAC3BtD,SAAjB+G,EAA6BA,EAAe,QJmdlD5I,IAAK,eACLL,MAAO,WIhdR,GAAkB,MAAdnB,KAAK2G,KACL,MAAO3G,MAAKqK,QAAQ,iBAAkBrK,KAAKqK,QAAQ,KAAM,UJqd5D7I,IAAK,eACLL,MAAO,SIldCwF,GACS,MAAd3G,KAAK2G,OACL3G,KAAK0J,MAAQ/C,GAAQ3G,KAAKsK,mBJsd7B9I,IAAK,WACLL,MAAO,SIndHqH,GACLxI,KAAK4I,SAASxG,KAAKoG,MJsdlBhH,IAAK,YACLL,MAAO,WIndRnB,KAAK8J,KAAQ,GAAAX,GAAArG,KACb9C,KAAK+J,MAAQ,GAAAZ,GAAApG,MAAU,EAAG,MJudzBvB,IAAK,UACLL,MAAO,WIpdJnB,KAAK8J,KAAK1I,OAAS,IACnBpB,KAAKuK,YACLvK,KAAK4J,MAAMxH,KAAKpC,KAAK8J,UJydxBtI,IAAK,YACLL,MAAO,WIpdR,GAAIqJ,GAAQxK,KAAK8J,KAAKU,QAGlBT,EAAS/J,KAAK8J,KAAKpH,UAAS,EAIhC,OAHA1C,MAAK+J,MAAQ,GAAAZ,GAAApG,MAAUgH,EAAMrI,EAAGqI,EAAMnI,GAG/B4I,KJydNhJ,IAAK,WACLL,MAAO,SIvdHO,EAAGE,EAAG6I,GAEPA,IACA/I,GAAK1B,KAAK+J,MAAMrI,EAChBE,GAAK5B,KAAK+J,MAAMnI,GAIpB5B,KAAK8J,KAAKrH,SAASf,EAAGE,GAGtB5B,KAAK+J,MAAQ,GAAAZ,GAAApG,MAAUrB,EAAGE,MJ0dzBJ,IAAK,YACLL,MAAO,SIxdFe,EAAQuI,GAEd,IAAK,GAAI5J,GAAI,EAAG6J,EAAKxI,EAAOd,OAAQP,EAAI6J,EAAI7J,GAAK,EAC7Cb,KAAKyC,SAASP,EAAOrB,GAAIqB,EAAOrB,EAAI,GAAI4J,MJ4d3CjJ,IAAK,YACLL,MAAO,SIzdF0I,GACN7J,KAAK6J,OAASA,IAAW,EAAG,EAAG,EAAG,EAAG,EAAG,MJ4dvCrI,IAAK,YACLL,MAAO,SI1dF0I,GACN7J,KAAK6J,QACD7J,KAAK6J,OAAO,GAAKA,EAAO,GAAK7J,KAAK6J,OAAO,GAAKA,EAAO,GACrD7J,KAAK6J,OAAO,GAAKA,EAAO,GAAK7J,KAAK6J,OAAO,GAAKA,EAAO,GACrD7J,KAAK6J,OAAO,GAAKA,EAAO,GAAK7J,KAAK6J,OAAO,GAAKA,EAAO,GACrD7J,KAAK6J,OAAO,GAAKA,EAAO,GAAK7J,KAAK6J,OAAO,GAAKA,EAAO,GACrD7J,KAAK6J,OAAO,GAAKA,EAAO,GAAK7J,KAAK6J,OAAO,GAAKA,EAAO,GAAK7J,KAAK6J,OAAO,GACtE7J,KAAK6J,OAAO,GAAKA,EAAO,GAAK7J,KAAK6J,OAAO,GAAKA,EAAO,GAAK7J,KAAK6J,OAAO,OJudzErI,IAAK,YACLL,MAAO,SIpdFO,EAAGE,GACTA,EAAUyB,SAANzB,EAAkB,EAAIA,EAC1B5B,KAAK2K,WAAW,EAAG,EAAG,EAAG,EAAGjJ,EAAGE,OJud9BJ,IAAK,SACLL,MAAO,SIrdLyJ,EAAOlJ,EAAGE,GACbgJ,GAAgBtB,EAEQ,GAApBjH,UAAUjB,QACVpB,KAAK2K,WAAW,EAAG,EAAG,EAAG,EAAGjJ,EAAGE,IAGnC5B,KAAK2K,WAAWpB,KAAKsB,IAAID,GAAQrB,KAAKuB,IAAIF,IAASrB,KAAKuB,IAAIF,GAAQrB,KAAKsB,IAAID,GAAQ,EAAG,IAEhE,GAApBvI,UAAUjB,QACVpB,KAAK2K,WAAW,EAAG,EAAG,EAAG,GAAIjJ,GAAIE,OJydpCJ,IAAK,QACLL,MAAO,SItdNO,EAAGE,GACLA,EAAUyB,SAANzB,EAAkBF,EAAIE,EAC1B5B,KAAK2K,WAAWjJ,EAAG,EAAG,EAAGE,EAAG,EAAG,OJyd9BJ,IAAK,QACLL,MAAO,SIvdNyJ,GACF5K,KAAK2K,WAAW,EAAG,EAAGpB,KAAKwB,IAAIH,EAAQtB,GAAa,EAAG,EAAG,OJ0dzD9H,IAAK,QACLL,MAAO,SIxdNyJ,GACF5K,KAAK2K,WAAW,EAAGpB,KAAKwB,IAAIH,EAAQtB,GAAa,EAAG,EAAG,EAAG,OJ2dzD9H,IAAK,cACLL,MAAO,SIzdA0I,GAAQ,GAAA5D,GAAAjG,IAChB6J,IAAU7J,KAAK2K,UAAUd,GAEzB7J,KAAK4J,MAAMzH,QAAQ,SAAA2H,GACfA,EAAKkB,UAAU/E,EAAK4D,UAGxB7J,KAAKgK,OAAO7H,QAAQ,SAAA8I,GAChBA,EAAMC,MAAMF,UAAU/E,EAAK4D,QAC3BoB,EAAME,MAAMhJ,QAAQ,SAAAiJ,GAChBA,EAAKJ,UAAU/E,EAAK4D,YAI5B7J,KAAKiK,UAAU,MAEfjK,KAAK4I,SAASzG,QAAQ,SAAAyF,GAClBA,EAAID,YAAYkC,QJ+dnBrI,IAAK,WACLL,MAAO,WI3dR,MAAOnB,MAAK4J,SJ+dXpI,IAAK,YACLL,MAAO,WI3dR,GAAqC,SAAjCnB,KAAKqK,QAAQ,OAAQ,UAAwBrK,KAAK4J,MAAM,GAAGxI,OAC3D,MAAOpB,MAAKgK,MAIhB,IAAIqB,GAAWrL,KAAKqK,QAAQ,YAAa,UACrCgB,GAAwB,YAAbA,EAAyBhC,EAAArG,QAAQsI,aAAaC,WAAalC,EAAArG,QAAQsI,aAAaE,UAG/F,IAAIC,GAAe,GAAIpC,GAAArG,QAAQ0I,SAC3BC,EAAe,GAAItC,GAAArG,QAAQ4I,QAC3BC,EAAe,IACfC,IAEJ9L,MAAK4J,MAAMzH,QAAQ,SAAA2H,GACfgC,EAAa1J,KAAK0H,EAAKiC,iBAAiBF,MAG5CF,EAASK,SAASF,EAAczC,EAAArG,QAAQiJ,SAASC,WAAW,GAC5DP,EAASQ,QAAQ9C,EAAArG,QAAQoJ,SAASC,QAASZ,EAAWJ,EAAUA,EAEhE,IAAIzB,GAAYP,EAAArG,QAAQ4I,QAAQU,gBAAgBb,GAC5Cc,EAAYlD,EAAArG,QAAQ4I,QAAQY,iBAAiB5C,EAAOyB,EAGpDrL,MAAK4J,MAAMxI,OAAS,IACpBuK,EAASc,QACTd,EAASe,gBAAiB,EAC1BjB,EAAY,GAAIpC,GAAArG,QAAQ0I,SACxBC,EAASK,SAASO,EAAWlD,EAAArG,QAAQiJ,SAASC,WAAW,GACzDP,EAASQ,QAAQ9C,EAAArG,QAAQoJ,SAASC,QAASZ,EAAWJ,EAAUA,GAIpE,IAAIsB,GAAa,SAAA7C,GAAA,OAAQ,GAAAX,GAAArG,MAAW8J,kBAAkB9C,EAAM,EAAI+B,IAC5DgB,EAAaxD,EAAArG,QAAQ8J,GAAGC,qBAAqBtB,EASjD,OARAzL,MAAKgK,OAAY6C,EAAWhK,IAAI,SAAAmK,GAC5B,OACI9B,MAAOyB,EAAOK,EAAU9B,OACxBC,MAAO6B,EAAU7B,MAAMtI,IAAI8J,MAK5B3M,KAAKgK,WJmeR7B,IAMXvI,GIpeQuI,MJqeRvI,EAAQoD,QIpeMmF,GJweT,SAAStI,EAAQD,EAASM,GAE/B,YAaA,SAAS+C,GAAgBC,EAAUC,GAAe,KAAMD,YAAoBC,IAAgB,KAAM,IAAInC,WAAU,qCAXhHC,OAAOC,eAAetB,EAAS,cAC3BuB,OAAO,IAEXvB,EAAQ2I,UAAYlF,MAEpB,IAAIC,GAAe,WAAc,QAASC,GAAiBC,EAAQC,GAAS,IAAK,GAAI5C,GAAI,EAAGA,EAAI4C,EAAMrC,OAAQP,IAAK,CAAE,GAAI6C,GAAaD,EAAM5C,EAAI6C,GAAWrC,WAAaqC,EAAWrC,aAAc,EAAOqC,EAAWpC,cAAe,EAAU,SAAWoC,KAAYA,EAAWnC,UAAW,GAAMN,OAAOC,eAAesC,EAAQE,EAAWlC,IAAKkC,IAAiB,MAAO,UAAUP,EAAaQ,EAAYC,GAAiJ,MAA9HD,IAAYJ,EAAiBJ,EAAY1B,UAAWkC,GAAiBC,GAAaL,EAAiBJ,EAAaS,GAAqBT,MKnuBjiBgG,EAAAjJ,EAAA,GACA+M,EAAA/M,EAAA,GAGMqI,ELwuBW,WKtuBb,QAAAA,GAAYX,EAAKrB,GAAQtD,EAAAjD,KAAAuI,GAErBvI,KAAK4H,IAAiBA,EACtB5H,KAAKuG,OAAiBA,EACtBvG,KAAKkN,eAAiB,KACtBlN,KAAKmN,YAAiB,KACtBnN,KAAKoN,SAAiB,KACtBpN,KAAKqE,cAAiBkC,EAAOlC,cLuyDhC,MA1jCAf,GAAaiF,IACT/G,IAAK,QACLL,MAAO,WK1uBR,GAAIkM,GAAUrN,KAAK,IAAMA,KAAK4H,IAAIjB,KAGlC,OAAM0G,IAA8B,kBAAZA,IAKxBrN,KAAKsN,iBAGED,EAAQ9M,KAAKP,OAPTA,KAAKuG,OAAO8B,SAASrI,KAAK4H,IAAK,0BLyvBzCpG,IAAK,iBACLL,MAAO,WK/uBK,GAAAyE,GAAA5F,KAET2J,EAAQ3J,KAAK4H,IAAI5D,QAAQuJ,UAE7B,KAAM5D,EACF,MAAO,KAIX,IAAI6D,GAAU7D,EAAM8D,aAAa,UAE7BD,IACAxN,KAAK4H,IAAIuC,QAAQ,UAAWnK,KAAK0N,wBAAwBF,GAI7D,IAAIzE,UAAM5H,SAAOwM,QAEjB1M,QAAOiJ,KAAKP,GAAOiE,KAAK,SAAApM,GAOpB,MALAuH,GAAOY,EAAMnI,GAGbL,EAAQyE,EAAKiI,kBAAkB9E,GAE3B5H,KAAU,QAKQ,UAAlB4H,EAAKjD,SACL6H,EAAQxM,EAIRyE,EAAKgC,IAAIuC,QAAQpB,EAAKjD,SAAU3E,MAMxCwM,GAASA,EAAMG,QAAQ,KAAM,IAAIC,MAAM,KAAKH,KAAK,SAAA7E,GAQ7C,MANAA,GAAOA,EAAKgF,MAAM,KAClBhF,GAASjD,SAAUiD,EAAK,GAAIiF,UAAWjF,EAAK,IAG5C5H,EAAQyE,EAAKiI,kBAAkB9E,GAE3B5H,KAAU,OAKdyE,GAAKgC,IAAIuC,QAAQpB,EAAKjD,SAAU3E,IAIpC,IAAI8M,IAAe,OAAQ,SAAU,QAErCA,GAAY9L,QAAQ,SAAA+L,GACmB,YAA/BtI,EAAKgC,IAAIyC,QAAQ6D,IACjBtI,EAAKgC,IAAIuC,QAAQ+D,EAAUtI,EAAKgC,IAAIK,OAAOoC,QAAQ6D,EAAU,WAKrElO,KAAKmO,oBAGLnO,KAAKoO,yBLwvBJ5M,IAAK,oBACLL,MAAO,SKrvBM4H,GAEd,GAAI5H,GAAQ4H,EAAKiF,UACZF,QAAQ,gBAAiB,KACzBA,QAAQ,QAAS,KACjBO,MAEL,KAAMlN,EAAMC,OACR,MAAOpB,MAAKuG,OAAO+H,aAAatO,KAAK4H,IAAKmB,EAAM,QAIpD,QAAQA,EAAKjD,UAET,IAAK,IACL,IAAK,IACL,IAAK,QACL,IAAK,SACD3E,EAAQnB,KAAKuO,sBAAsBxF,EACvC,MAEA,KAAK,KACL,IAAK,KACL,IAAK,KACL,IAAK,KACL,IAAK,IACL,IAAK,KACL,IAAK,KACL,IAAK,KACL,IAAK,KACL,IAAK,YACL,IAAK,eACD5H,EAAQnB,KAAKuO,sBAAsBxF,GAAM,EAC7C,MAGA,KAAK,SAED5H,EAAQnB,KAAK0N,wBAAwB3E,EACzC,MAEA,KAAK,UACD5H,GAAQ,CACZ,MAGA,KAAK,UACL,IAAK,eACL,IAAK,iBACDA,EAAQnB,KAAKwO,uBAAuBzF,EAAM,EAAG,EACjD,MAEA,KAAK,sBACD5H,EAAQnB,KAAKyO,qCAAqC1F,GAK1D,MAAO5H,ML0vBNK,IAAK,wBACLL,MAAO,SKvvBU4H,EAAM2F,GACxB,GAAIC,GAAc5F,EAAKiF,UAAUvE,cAC7BmF,EAAcjN,WAAWgN,EAE7B,IAAI9M,MAAM+M,GACN,MAAO5O,MAAKuG,OAAO+H,aAAatO,KAAK4H,IAAKmB,EAAM,6BAGpD,IAAI4F,EAAYvG,QAAQ,SAAU,EAC9B,MAAoB,cAAbwG,CAGX,IAAID,EAAYvG,QAAQ,SAAU,EAC9B,MAAoB,cAAbwG,CAGX,IAAID,EAAYvG,QAAQ,SAAU,EAC9B,MAAoB,IAAbwG,CAGX,IAAID,EAAYvG,QAAQ,SAAU,EAC9B,MAAoB,MAAbwG,CAGX,IAAID,EAAYvG,QAAQ,SAAU,EAC9B,MAAoB,IAAbwG,CAGX,IAAID,EAAYvG,QAAQ,QAAS,EAAI,CACjC,GAAIoF,GAAUxN,KAAK4H,IAAIyC,QAAQ,UAAWrK,KAAK4H,IAAIK,QAAUjI,KAAK4H,IAAIK,OAAOoC,QAAQ,WAErF,QAAQtB,EAAKjD,UACT,IAAK,IACL,IAAK,QACD8I,GAAcpB,EAAQ,GAAK,GAC/B,MACA,KAAK,IACL,IAAK,SACDoB,GAAcpB,EAAQ,GAAK,KAKvC,GAAImB,EAAYvG,QAAQ,SAAU,EAAI,CAClC,GAAIyG,GAAW7O,KAAK4H,IAAIyC,QAAQ,YAAa,GAE7C,QAAQtB,EAAKjD,UACT,IAAK,IACL,IAAK,IACL,IAAK,QACL,IAAK,SACD8I,GAAcC,GAK1B,MAAOD,ML6vBNpN,IAAK,0BACLL,MAAO,SK1vBY4H,GACpB,GAAI7G,GAASlC,KAAK8O,cAAc/F,EAAKiF,UAErC,OAAI9L,MAAW,EACJlC,KAAKuG,OAAO+H,aAAatO,KAAK4H,IAAKmB,EAAM,mCAG9C7G,EAAOd,OAITc,EAAOd,OAAS,EACTpB,KAAKuG,OAAO+H,aAAatO,KAAK4H,IAAKmB,EAAM,qCAG7C7G,EAPIlC,KAAKuG,OAAO+H,aAAatO,KAAK4H,IAAKmB,EAAM,wBLuwBnDvH,IAAK,yBACLL,MAAO,SK7vBW4H,EAAMgG,EAAKC,GAC9B,GAAIL,GAAc5F,EAAKiF,UAAUK,OAC7BO,EAAcjN,WAAWgN,EAE7B,OAAI9M,OAAM+M,GACC5O,KAAKuG,OAAO+H,aAAatO,KAAK4H,IAAKmB,EAAM,mCAGhD6F,EAAaG,GAAOH,EAAaI,EAC1BhP,KAAKuG,OAAO+H,aAAatO,KAAK4H,IAAKmB,EAAM,iBAAmBgG,EAAM,KAAOC,EAAM,KAGnFJ,KLmwBNpN,IAAK,gBACLL,MAAO,SKhwBEe,GAaV,MAXsB,gBAAXA,KACPA,EAASA,EAAO6L,MAAM,wDACrBkB,OAAO,SAAAlF,GACJ,MAAOA,KAAU,GAAI,KAAK3B,QAAQ2B,EAAMsE,WAAY,KAK5DnM,EAASA,EAAOW,IAAIlB,aAGhBO,EAAO0L,KAAK/L,QAITK,KLqwBNV,IAAK,uCACLL,MAAO,SKlwByB4H,GACjC,GAAImG,IACAC,OAAO,EACPC,MAAO,OACPC,MAAO,EACPC,OAAO,GAGPC,EAAYxG,EAAKiF,SAarB,OAXmC,KAA/BuB,EAAUnH,QAAQ,WAClBmH,EAAeA,EAAUC,OAAO,GAChCN,EAAOC,OAAQ,GAGnBI,EAAeA,EAAUxB,MAAM,KAC/BmB,EAAOE,MAAQG,EAAU,GACzBL,EAAOG,KAAQE,EAAU,IAAM,OAC/BL,EAAOG,KAAwB,SAAhBH,EAAOG,KACtBH,EAAOI,OAAUJ,EAAOG,KAEjBH,KLwwBN1N,IAAK,oBACLL,MAAO,WKnwBR,GAAIqM,GAAUxN,KAAK4H,IAAIyC,QAAQ,UAAW,KAG1C,IAAgB,OAAZmD,EACA,MAAO,KAIX,IAAIiC,GAASzP,KAAK4H,IAAIyC,QAAQ,QAASmD,EAAQ,IAC3CkC,EAAS1P,KAAK4H,IAAIyC,QAAQ,SAAUmD,EAAQ,GAEhDxN,MAAK4H,IAAIuC,QAAQ,QAAUsF,GAC3BzP,KAAK4H,IAAIuC,QAAQ,SAAUuF,EAI3B,IAAIC,GAAaF,EAASjC,EAAQ,GAC9BoC,EAAaF,EAASlC,EAAQ,GAC9BqC,EAAarC,EAAQ,GACrBsC,EAAatC,EAAQ,GAErBuC,EAAsB/P,KAAK4H,IAAIyC,QAAQ,sBAAuB,gBAElE,IAAI0F,EAAqB,CACrB,GAAIC,UAAUC,QAEVF,GAAoBV,KAChBM,EAASC,GACTD,EAAWC,EACXI,EAAWxC,EAAQ,GAAKmC,GAEnBA,EAASC,IACdA,EAAYD,EACZM,EAAYzC,EAAQ,GAAKoC,GAGxBG,EAAoBT,QACrBK,EAASC,GACTD,EAAWC,EACXI,EAAWxC,EAAQ,GAAKmC,GAEnBA,EAASC,IACdA,EAAYD,EACZM,EAAYzC,EAAQ,GAAKoC,IAIhBvM,SAAb2M,EACkC,aAA9BD,EAAoBX,MACpBpP,KAAK4H,IAAIsI,WAAWT,EAAQO,GAAY,EAAG,GAER,aAA9BD,EAAoBX,OACzBpP,KAAK4H,IAAIsI,UAAUT,EAAQO,EAAU,GAGtB3M,SAAd4M,IAC6B,aAA9BF,EAAoBX,MACpBpP,KAAK4H,IAAIsI,UAAU,GAAIR,EAASO,GAAa,GAEV,aAA9BF,EAAoBX,OACzBpP,KAAK4H,IAAIsI,UAAU,EAAGR,EAASO,IAK3CjQ,KAAK4H,IAAIuI,MAAMR,EAAQC,GACvB5P,KAAK4H,IAAIsI,WAAWL,GAAaC,MLswBhCtO,IAAK,sBACLL,MAAO,WKnwBU,GAAA8E,GAAAjG,KAEdoQ,EAAgBpQ,KAAK4H,IAAIyC,QAAQ,YAAa,KAGlD,IAAsB,OAAlB+F,IAA4BA,EAAchP,OAC1C,MAAO,KAIX,IAAIiP,GAAkBD,EAAcrC,MAAM,IAG1CsC,GAAgBC,KAGhB,IAAItF,UAAWuF,SAAMrB,QAErBmB,GAAgBzC,KAAK,SAAA4C,GAKjB,GAHAxF,EAAYwF,EAAIzC,MAAM,KAGG,IAArB/C,EAAU5J,OACV,MAAO6E,GAAKM,OAAO+H,aAAarI,EAAK2B,IAAKwI,EAAe,YAG7DG,GAAOvF,EAAU,GAAGqD,MAGpB,IAAIoC,GAAOF,CACE,YAATE,IACAA,EAAO,YAIX,IAAIC,GAAezK,EAAK2B,IAAI6I,EAE5B,OAA4B,kBAAjBC,GACAzK,EAAKM,OAAO+H,aAAarI,EAAK2B,IAAKwI,EAAe,+BAAiCG,IAG9FrB,EAASlE,EAAU,GAAGqD,OACtBa,EAASjJ,EAAK6I,cAAcI,GAGtBA,EAAO9N,QAKD,aAARqP,IACAvB,GAAUA,QAIdwB,GAAaC,MAAM1K,EAAK2B,IAAKsH,IATlBjJ,EAAKM,OAAO+H,aAAarI,EAAK2B,IAAKwI,EAAe,6BAA+BG,SLoxB/F/O,IAAK,WACLL,MAAO,WKvwBRnB,KAAK4H,IAAIgJ,aL2wBRpP,IAAK,aACLL,MAAO,WKxwBRnB,KAAK4H,IAAI2C,eL4wBR/I,IAAK,aACLL,MAAO,WKzwBR,MAAOnB,MAAK4H,IAAIiJ,eL6wBfrP,IAAK,aACLL,MAAO,SK3wBDe,EAAQuI,GACf,MAAMvI,GAAOd,OAITc,EAAOd,OAAS,EACTpB,KAAKuG,OAAO8B,SAASrI,KAAK4H,IAAK,sCAIzBvE,SAAboH,IACAA,EAAWzK,KAAKkN,eAAezC,UAGnCzK,KAAK4H,IAAIkJ,UAAU5O,EAAQuI,IACpB,GAbIzK,KAAKuG,OAAO8B,SAASrI,KAAK4H,IAAK,wBL8xBzCpG,IAAK,OACLL,MAAO,WK3wBR,GAAInB,KAAKuG,OAAOrC,SAEZ,OAAO,CAIX,IAAIuL,GAASzP,KAAK4H,IAAIyC,QAAQ,SAC1BqF,EAAS1P,KAAK4H,IAAIyC,QAAQ,SAG9B,KAAMoF,GAASA,EAAQ,IAAOC,GAAUA,EAAS,EAC7C,KAAM,IAAI1N,OAAM,0BAA4ByN,EAAQ,MAAQC,EAIhE1P,MAAKuG,OAAOrC,UACRuL,MAAQA,EACRC,OAAQA,EAIZ,IAAIlC,GAAUxN,KAAK4H,IAAIyC,QAAQ,WAAY,EAAG,EAAGoF,EAAOC,GAexD,OAbA1P,MAAKuG,OAAOrC,SAASsJ,SACjB9L,EAAQ8L,EAAQ,GAChB5L,EAAQ4L,EAAQ,GAChBiC,MAAQjC,EAAQ,GAChBkC,OAAQlC,EAAQ,IAIY,aAA5BxN,KAAKuG,OAAOtC,OAAO0C,OACnB3G,KAAKuG,OAAOtC,OAAO2C,QAAU5G,KAAK4H,IAAIyC,QAAQ,sBAI3C,KLgxBN7I,IAAK,SACLL,MAAO,WKvwBR,MALInB,MAAKuG,OAAOrC,WAAclE,KAAKuG,OAAOrC,SAAS6M,QAC/C/Q,KAAKuG,OAAOrC,SAAS6M,MAAQ/Q,KAAK4H,IAAI5D,QAAQ+B,cAI3C,KLixBNvE,IAAK,QACLL,MAAO,WKxwBR,MALInB,MAAKuG,OAAOrC,WAAclE,KAAKuG,OAAOrC,SAAS8M,cAC/ChR,KAAKuG,OAAOrC,SAAS8M,YAAchR,KAAK4H,IAAI5D,QAAQ+B,cAIjD,KLkxBNvE,IAAK,SACLL,MAAO,WK7wBR,OAAO,KLmxBNK,IAAK,QACLL,MAAO,WK9wBR,OAAO,KLoxBNK,IAAK,QACLL,MAAO,WKlxBJ,GAAAkF,GAAArG,IAOJ,OALAA,MAAK4H,IAAI5D,QAAQyE,WAAWtG,QAAQ,SAAAuG,GAChCA,EAAUrI,KAAOgG,EAAKE,OAAOpC,KAAKuE,EAAUrI,IAAMqI,MAI/C,KLuxBNlH,IAAK,OACLL,MAAO,WKnxBR,GAAIqC,GAAUxD,KAAK4H,IAAIyC,QAAQ,cAAcyD,QAAQ,KAAM,IAGvD9J,EAAUhE,KAAKuG,OAAOpC,KAAKX,EAE/B,KAAMQ,EACF,MAAOhE,MAAKuG,OAAO8B,SAASrI,KAAK4H,IAAK,wBAA0BpE,EAAS,IAI7E,IAAIyN,GAASjR,KAAKuG,OAAOmB,cAAc1D,EAAShE,KAAK4H,IAAIK,OAEzD,OAAMgJ,IAKNA,EAAOhH,UAAUjK,KAAK4H,IAAIiC,QAG1B7J,KAAK4H,IAAIK,OAAOU,SAASsI,IAGlB,GAVIjR,KAAKuG,OAAO8B,SAASrI,KAAK4H,IAAK,oBAAsBpE,EAAS,QLkyBxEhC,IAAK,KACLL,MAAO,WKjxBR,MAHAnB,MAAK4H,IAAIsJ,gBAGF,KLyxBN1P,IAAK,QACLL,MAAO,WKrxBR,MAAOnB,MAAKmR,OACR,IAAKnR,KAAK4H,IAAIyC,QAAQ,MAAOrK,KAAK4H,IAAIyC,QAAQ,MAC9C,IAAKrK,KAAK4H,IAAIyC,QAAQ,MAAOrK,KAAK4H,IAAIyC,QAAQ,WLwxBjD7I,IAAK,YACLL,MAAO,WKrxBW,GAAbqJ,GAAanI,UAAAjB,OAAA,GAAAiC,SAAAhB,UAAA,IAAAA,UAAA,GACfH,EAASlC,KAAK4H,IAAIyC,QAAQ,UAC1BP,GAAU,IAAK5H,EAAOkP,QAASlP,EAAOkP,QAAS,IAMnD,OAJAtH,GAAOA,EAAKuH,OAAOnP,GACnBsI,GAASV,EAAK1H,KAAK,KAGZpC,KAAKmR,MAAMrH,ML0xBjBtI,IAAK,WACLL,MAAO,WKtxBR,MAAOnB,MAAKsR,WAAU,ML2xBrB9P,IAAK,QACLL,MAAO,WKvxBR,GAAIoQ,GAAKvR,KAAK4H,IAAIyC,QAAQ,SACtBmH,EAAKxR,KAAK4H,IAAIyC,QAAQ,UACtB3I,EAAK1B,KAAK4H,IAAIyC,QAAQ,IAAK,GAC3BzI,EAAK5B,KAAK4H,IAAIyC,QAAQ,IAAK,GAC3BoH,EAAKzR,KAAK4H,IAAIyC,QAAQ,KAAM,MAC5BqH,EAAK1R,KAAK4H,IAAIyC,QAAQ,KAAM,KAGhC,KAAKoH,IAAOC,EAER,MAAO1R,MAAKmR,OAAO,IAAKzP,EAAGE,EAAG,IAAK2P,EAAG,IAAKC,EAAG,KAAMD,EAAG,KAS3D,IAJW,OAAPE,IAAaA,EAAKC,GACX,OAAPA,IAAaA,EAAKD,GAGX,OAAPA,GAAsB,OAAPA,GAAeA,EAAK,GAAKC,EAAK,EAE7C,MAAO1R,MAAKuG,OAAO8B,SAASrI,KAAK4H,IAAK,yCAKtC6J,GAAKF,EAAI,IAAGE,EAAKF,EAAI,GACrBG,EAAKF,EAAI,IAAGE,EAAKF,EAAI,EAEzB,IAAIG,GAAU,EAALF,EACLG,EAAU,EAALF,CAGT,OAAO1R,MAAKmR,OACR,IAAKzP,EAAI+P,EAAI7P,EACb,IAAK2P,EAAII,EACT,IAAKF,EAAI,EAAGA,EAAIC,EAAID,EAAIC,EACxB,IAAKF,EAAII,EACT,IAAK,EAAGF,GAAKD,EAAIC,GAAKD,EAAIC,EAC1B,KAAMH,EAAII,EACV,KAAMF,EAAI,GAAIA,GAAKC,GAAKD,GAAKC,EAC7B,KAAMF,EAAII,EACV,IAAK,EAAG,EAAG,GAAIF,EAAID,GAAKC,EACxB,SLkxBHlQ,IAAK,UACLL,MAAO,WK9wBR,GAAIc,GAAIjC,KAAK4H,IAAIyC,QAAQ,IAAK,EAE9B,IAAIpI,GAAK,EAEL,OAAO,CAGX,IAAI4P,GAAK7R,KAAK4H,IAAIyC,QAAQ,KAAM,GAC5ByH,EAAK9R,KAAK4H,IAAIyC,QAAQ,KAAM,EAGhC,OAAOrK,MAAKmR,OACR,IAAKU,EAAG5P,EAAG6P,EACX,IAAK7P,EAAGA,EAAG,EAAG,EAAG,EAAG4P,EAAIC,EAAG7P,EAC3B,IAAKA,EAAGA,EAAG,EAAG,EAAG,EAAG4P,EAAG5P,EAAG6P,EAC1B,IAAK7P,EAAGA,EAAG,EAAG,EAAG,EAAG4P,EAAIC,EAAG7P,EAC3B,IAAKA,EAAGA,EAAG,EAAG,EAAG,EAAG4P,EAAG5P,EAAG6P,EAC1B,SL4wBHtQ,IAAK,WACLL,MAAO,WKxwBR,GAAIsQ,GAAKzR,KAAK4H,IAAIyC,QAAQ,KAAM,GAC5BqH,EAAK1R,KAAK4H,IAAIyC,QAAQ,KAAM,EAEhC,IAAIoH,GAAM,GAAKC,GAAM,EAEjB,OAAO,CAGX,IAAIG,GAAK7R,KAAK4H,IAAIyC,QAAQ,KAAM,GAC5ByH,EAAK9R,KAAK4H,IAAIyC,QAAQ,KAAM,EAGhC,OAAOrK,MAAKmR,OACR,IAAKU,EAAGJ,EAAIK,EACZ,IAAKL,EAAIC,EAAI,EAAG,EAAG,EAAGG,EAAIC,EAAGJ,EAC7B,IAAKD,EAAIC,EAAI,EAAG,EAAG,EAAGG,EAAGJ,EAAIK,EAC7B,IAAKL,EAAIC,EAAI,EAAG,EAAG,EAAGG,EAAIC,EAAGJ,EAC7B,IAAKD,EAAIC,EAAI,EAAG,EAAG,EAAGG,EAAGJ,EAAIK,EAC7B,SLswBHtQ,IAAK,SACLL,MAAO,SKnwBLoP,EAAMwB,EAAK7P,GACd,GAAIA,EAAOd,OAAS2Q,EAAK,CAGrB,IAFA,GAAI1E,UAASjG,GAAS,EAEhBA,GAAUlF,EAAOd,QACnBiM,EAAUrN,KAAK,QAAUuQ,GACzBnJ,EAAUiG,EAAQ9M,KAAKP,KAAMkC,EAAO8P,OAAO,EAAGD,GAGlD,OAAO3K,GAGX,MAAO,SLuwBN5F,IAAK,QACLL,MAAO,SKrwBN2I,GAAM,GAAA/C,GAAA/G,IAEJ8J,IAAwB,gBAATA,KACfA,EAAOA,EAAKmI,KAAK,KAIrB,IAAIC,GAAQpI,GAAQ9J,KAAK4H,IAAIyC,QAAQ,IAAK,KAE1C,KAAM6H,EAEF,OAAO,CAIX,IAAIC,GAAWD,EAAMpL,MAAM,sDAE3B,KAAMqL,EACF,MAAOnS,MAAKuG,OAAO8B,SAASrI,KAAK4H,IAAK,0BAI1C5H,MAAKkN,gBACDsD,IAAU,KACVD,KAAU,KACVrB,OAAU,KACVzE,SAAU,MAEdzK,KAAKmN,YAAcnN,KAAKkN,eACxBlN,KAAKoN,WAEL,IAAIC,GAAa,KACb+E,GAAa,CA0CjB,OAxCAD,GAASvE,KAAK,SAAA4C,GAaV,MAXAA,GAAMA,EAAInC,OAGVtH,EAAKmG,eAAesD,IAAWA,EAC/BzJ,EAAKmG,eAAeqD,KAAWC,EAAI,GAAG6B,cACtCtL,EAAKmG,eAAegC,OAAWsB,EAAIhB,OAAO,GAAGnB,OAC7CtH,EAAKmG,eAAezC,SAAW1D,EAAKmG,eAAeqD,OAASC,EAAI,GAGhEnD,EAAUtG,EAAK,QAAUA,EAAKmG,eAAeqD,MAEvClD,GAA8B,kBAAZA,IAMxBtG,EAAKmG,eAAegC,OAASnI,EAAK+H,cAAc/H,EAAKmG,eAAegC,QAEhEnI,EAAKmG,eAAegC,UAAW,GAC/BnI,EAAKR,OAAO8B,SAAStB,EAAKa,IAAK,uCAAyCb,EAAKmG,eAAesD,IAAM,KAC3F4B,GAAa,GAIlB/E,EAAQ9M,KAARwG,EAAmBA,EAAKmG,eAAegC,SAK7CnI,EAAKoG,mBAELlM,QAAOiJ,KAAKnD,EAAKmG,gBAAgB/K,QAAQ,SAAAX,GACrCuF,EAAKoG,YAAY3L,GAAOuF,EAAKmG,eAAe1L,MAPrC4Q,GAAa,IAdpBrL,EAAKR,OAAO8B,SAAStB,EAAKa,IAAK,6BAA+B4I,EAAI,GAAK,KAChE4B,GAAa,MAyBxBA,IACApS,KAAKsS,cACE,ML8wBV9Q,IAAK,SACLL,MAAO,SKxwBLe,GAEH,GAAIR,GAAK1B,KAAK4H,IAAImC,MAAMrI,EACpBE,EAAK5B,KAAK4H,IAAImC,MAAMnI,EACpB2Q,EAAKvS,KAAKkN,eAAezC,SAGzB+H,EAAatQ,EAAO8P,OAAO,EAAG,EAGlChS,MAAKyS,WAGDF,GAAMvS,KAAK4H,IAAIgC,MAAMxI,OAAS,IAC9BoR,EAAW,IAAM9Q,EACjB8Q,EAAW,IAAM5Q,EAIrB,IAAIwF,GAASpH,KAAK0S,WAAWF,GAAY,EASzC,OALIpL,IAAUlF,EAAOd,SACjBgG,EAASpH,KAAK0S,WAAWxQ,IAItBkF,KL2wBN5F,IAAK,SACLL,MAAO,WKvwBR,MADAnB,MAAK2S,cACE,KL4wBNnR,IAAK,SACLL,MAAO,SK1wBLe,GACH,MAAOlC,MAAK0S,WAAWxQ,ML6wBtBV,IAAK,SACLL,MAAO,SK3wBLe,GAAQ,GAAAqF,GAAAvH,IACX,OAAOkC,GAAO0Q,MAAM,SAAAlR,GAChB,MAAO6F,GAAKmL,YAAYhR,EAAG6F,EAAK2F,eAAezC,SAAW,EAAIlD,EAAKK,IAAImC,MAAMnI,SLixBhFJ,IAAK,SACLL,MAAO,SK9wBLe,GAAQ,GAAA6F,GAAA/H,IACX,OAAOkC,GAAO0Q,MAAM,SAAAhR,GAChB,MAAOmG,GAAK2K,YAAY3K,EAAKmF,eAAezC,SAAW,EAAI1C,EAAKH,IAAImC,MAAMrI,EAAGE,SLoxBhFJ,IAAK,SACLL,MAAO,SKjxBLe,GAEH,GAAIkF,GAASpH,KAAK6S,OAAO,IAAK,EAAG3Q,EAEjC,IAAe,OAAXkF,EACA,MAAOA,EAIX,IAAI0L,GAAK9S,KAAK4H,IAAImC,MACdwI,EAAKvS,KAAKkN,eAAezC,SAEzBsI,EAAK7Q,EAAO,IAAMqQ,EAAKO,EAAGpR,EAAI,GAC9BsR,EAAK9Q,EAAO,IAAMqQ,EAAKO,EAAGlR,EAAI,GAC9BqR,EAAK/Q,EAAO,IAAMqQ,EAAKO,EAAGpR,EAAI,GAC9BwR,EAAKhR,EAAO,IAAMqQ,EAAKO,EAAGlR,EAAI,GAC9BF,EAAKQ,EAAO,IAAMqQ,EAAKO,EAAGpR,EAAI,GAC9BE,EAAKM,EAAO,IAAMqQ,EAAKO,EAAGlR,EAAI,EAElC5B,MAAKoN,SAAS6F,GAAKA,EACnBjT,KAAKoN,SAAS8F,GAAKA,CAEnB,IAAIC,GAAK,GAAAlG,GAAAlK,MAAUgQ,EAAIC,GACnBI,EAAK,GAAAnG,GAAAlK,MAAUkQ,EAAIC,GACnBG,EAAK,GAAApG,GAAAlK,MAAUrB,EAAGE,GAQlB0R,EAAS,GAAAnK,GAAAoK,YAAgBvT,KAAKqE,eAC9BmP,EAASF,EAAOG,OAAQX,KAAIK,KAAIC,KAAIC,MAKxC,OAAOrT,MAAK0S,WAAWc,GAAQ,MLoxB9BhS,IAAK,SACLL,MAAO,SKlxBLe,GAEH,GAAIkF,GAASpH,KAAK6S,OAAO,IAAK,EAAG3Q,EAEjC,IAAe,OAAXkF,EACA,MAAOA,EAIX,IAAI0L,GAAK9S,KAAK4H,IAAImC,MACdwI,EAAKvS,KAAKkN,eAAezC,SAEzBsI,EAAKD,EAAGpR,EACRsR,EAAKF,EAAGlR,CAEkB,OAA1B5B,KAAKmN,YAAYoD,MAA0C,MAA1BvQ,KAAKmN,YAAYoD,OAClDwC,GAAM/S,KAAKoN,SAAS6F,GAAKF,EACzBC,GAAMhT,KAAKoN,SAAS8F,GAAKF,EAG7B,IAAIC,GAAK/Q,EAAO,IAAMqQ,EAAKO,EAAGpR,EAAI,GAC9BwR,EAAKhR,EAAO,IAAMqQ,EAAKO,EAAGlR,EAAI,GAC9BF,EAAKQ,EAAO,IAAMqQ,EAAKO,EAAGpR,EAAI,GAC9BE,EAAKM,EAAO,IAAMqQ,EAAKO,EAAGlR,EAAI,EAElC5B,MAAKoN,SAAS6F,GAAKA,EACnBjT,KAAKoN,SAAS8F,GAAKA,CAEnB,IAAIC,GAAK,GAAAlG,GAAAlK,MAAUgQ,EAAIC,GACnBI,EAAK,GAAAnG,GAAAlK,MAAUkQ,EAAIC,GACnBG,EAAK,GAAApG,GAAAlK,MAAUrB,EAAGE,GAQlB0R,EAAS,GAAAnK,GAAAoK,YAAgBvT,KAAKqE,eAC9BmP,EAASF,EAAOG,OAAQX,KAAIK,KAAIC,KAAIC,MAKxC,OAAOrT,MAAK0S,WAAWc,GAAQ,MLqxB9BhS,IAAK,SACLL,MAAO,SKnxBLe,GAEH,GAAIkF,GAASpH,KAAK6S,OAAO,IAAK,EAAG3Q,EAEjC,IAAe,OAAXkF,EACA,MAAOA,EAIX,IAAI0L,GAAK9S,KAAK4H,IAAImC,MACdwI,EAAKvS,KAAKkN,eAAezC,SAEzBsI,EAAK7Q,EAAO,IAAMqQ,EAAKO,EAAGpR,EAAI,GAC9BsR,EAAK9Q,EAAO,IAAMqQ,EAAKO,EAAGlR,EAAI,GAC9BF,EAAKQ,EAAO,IAAMqQ,EAAKO,EAAGpR,EAAI,GAC9BE,EAAKM,EAAO,IAAMqQ,EAAKO,EAAGlR,EAAI,EAElC5B,MAAKoN,SAAS2F,GAAKA,EACnB/S,KAAKoN,SAAS4F,GAAKA,CAEnB,IAAIG,GAAK,GAAAlG,GAAAlK,MAAUgQ,EAAIC,GACnBI,EAAK,GAAAnG,GAAAlK,MAAUrB,EAAGE,GAOlB0R,EAAS,GAAAnK,GAAAuK,cAAkB1T,KAAKqE,eAChCmP,EAASF,EAAOG,OAAQX,KAAIK,KAAIC,MAGpC,OAAOpT,MAAK0S,WAAWc,GAAQ,MLsxB9BhS,IAAK,SACLL,MAAO,SKpxBLe,GAEH,GAAIkF,GAASpH,KAAK6S,OAAO,IAAK,EAAG3Q,EAEjC,IAAe,OAAXkF,EACA,MAAOA,EAIX,IAAI0L,GAAK9S,KAAK4H,IAAImC,MACdwI,EAAKvS,KAAKkN,eAAezC,SAEzBsI,EAAKD,EAAGpR,EACRsR,EAAKF,EAAGlR,CAEkB,OAA1B5B,KAAKmN,YAAYoD,MAA0C,MAA1BvQ,KAAKmN,YAAYoD,OAClDwC,GAAM/S,KAAKoN,SAAS2F,GAAKA,EACzBC,GAAMhT,KAAKoN,SAAS4F,GAAKA,EAG7B,IAAItR,GAAIQ,EAAO,IAAMqQ,EAAKO,EAAGpR,EAAI,GAC7BE,EAAIM,EAAO,IAAMqQ,EAAKO,EAAGlR,EAAI,EAEjC5B,MAAKoN,SAAS2F,GAAKA,EACnB/S,KAAKoN,SAAS4F,GAAKA,CAEnB,IAAIG,GAAK,GAAAlG,GAAAlK,MAAUgQ,EAAIC,GACnBI,EAAK,GAAAnG,GAAAlK,MAAUrB,EAAGE,GAOlB0R,EAAS,GAAAnK,GAAAuK,cAAkB1T,KAAKqE,eAChCmP,EAASF,EAAOG,OAAQX,KAAIK,KAAIC,MAGpC,OAAOpT,MAAK0S,WAAWc,GAAQ,MLuxB9BhS,IAAK,SACLL,MAAO,SKrxBLe,GAEH,GAAIkF,GAASpH,KAAK6S,OAAO,IAAK,EAAG3Q,EAEjC,IAAe,OAAXkF,EACA,MAAOA,EAIX,IAAImL,GAAQvS,KAAKkN,eAAezC,SAC5BqI,EAAQ9S,KAAK4H,IAAImC,MACjB0H,EAAQvP,EAAO,GACfwP,EAAQxP,EAAO,GACf0I,EAAQ1I,EAAO,GACfyR,IAAUzR,EAAO,GACjB0R,IAAU1R,EAAO,GACjBR,EAAQQ,EAAO,IAAMqQ,EAAKO,EAAGpR,EAAI,GACjCE,EAAQM,EAAO,IAAMqQ,EAAKO,EAAGlR,EAAI,GACjCuR,EAAQ,GAAAlG,GAAAlK,MAAUrB,EAAGE,GAIrB0R,EAAS,GAAAnK,GAAA0K,IAAQ7T,KAAKqE,eACtBmP,EAASF,EAAOG,OAAQX,KAAIrB,KAAIC,KAAI9G,QAAO+I,QAAOC,QAAOT,MAG7D,OAAOnT,MAAK0S,WAAWc,GAAQ,OLyxB3BjL,IAMX3I,GK1xBQ2I,YL2xBR3I,EAAQoD,QK1xBMuF,GL8xBT,SAAS1I,EAAQD,EAASM,GM/zDhC,GAAA4T,GAAAC,GAiEA,WAEA,YA2EA,SAAAC,GAAAC,EAAAC,EAAAzT,GAKA0T,GAAAC,gBAAA,EACA,MAAAH,IACA,gBAAAA,IAAA,sBAAAjU,KAAAqU,QAAAJ,GACA,gBAAAA,GAAAjU,KAAAsU,WAAAL,EAAAC,EAAAzT,GACA,MAAAyT,GAAA,gBAAAD,GAAAjU,KAAAuU,WAAAN,EAAA,KACAjU,KAAAuU,WAAAN,EAAAC,IAGA,QAAAM,KAEA,UAAAR,GAAA,KAAA3Q,eASA,QAAAoR,GAAA5T,EAAAa,EAAA6P,EAAAmD,EAAAjU,EAAAG,GAEA,OAAAA,GAAA,GACA,CACA,GAAA+T,GAAAjT,EAAA1B,KAAAa,KAAA0Q,EAAAmD,GAAAjU,CACAA,GAAA8I,KAAAqL,MAAAD,EAAA,UACApD,EAAAmD,KAAA,SAAAC,EAEA,MAAAlU,GAKA,QAAAoU,GAAAhU,EAAAa,EAAA6P,EAAAmD,EAAAjU,EAAAG,GAIA,IAFA,GAAAkU,GAAA,MAAApT,EACAqT,EAAArT,GAAA,KACAd,GAAA,GACA,CACA,GAAAoU,GAAA,MAAAhV,KAAAa,GACA2Q,EAAAxR,KAAAa,MAAA,GACAL,EAAAuU,EAAAC,EAAAxD,EAAAsD,CACAE,GAAAF,EAAAE,IAAA,MAAAxU,IAAA,IAAA+Q,EAAAmD,IAAA,WAAAjU,GACAA,GAAAuU,IAAA,KAAAxU,IAAA,IAAAuU,EAAAvD,GAAA/Q,IAAA,IACA8Q,EAAAmD,KAAA,WAAAM,EAEA,MAAAvU,GAIA,QAAAwU,GAAApU,EAAAa,EAAA6P,EAAAmD,EAAAjU,EAAAG,GAIA,IAFA,GAAAkU,GAAA,MAAApT,EACAqT,EAAArT,GAAA,KACAd,GAAA,GACA,CACA,GAAAoU,GAAA,MAAAhV,KAAAa,GACA2Q,EAAAxR,KAAAa,MAAA,GACAL,EAAAuU,EAAAC,EAAAxD,EAAAsD,CACAE,GAAAF,EAAAE,IAAA,MAAAxU,IAAA,IAAA+Q,EAAAmD,GAAAjU,EACAA,GAAAuU,GAAA,KAAAxU,GAAA,IAAAuU,EAAAvD,EACAD,EAAAmD,KAAA,UAAAM,EAEA,MAAAvU,GAmCA,QAAAyU,GAAAtU,GAEA,MAAAuU,IAAAC,OAAAxU,GAGA,QAAAyU,GAAAC,EAAAzU,GAEA,GAAAJ,GAAA8U,GAAAD,EAAAE,WAAA3U,GACA,cAAAJ,GAAA,EAAAA,EAGA,QAAAgV,GAAAxT,GAEA,OAAApB,GAAAb,KAAAW,EAAA,EAA4BE,GAAA,IAAQA,EAAAoB,EAAApB,GAAAb,KAAAa,EACpCoB,GAAAtB,EAAAX,KAAAW,EACAsB,EAAAqT,EAAAtV,KAAAsV,EAGA,QAAAI,GAAAhU,GAEA1B,KAAAW,EAAA,EACAX,KAAAsV,EAAA5T,EAAA,OACAA,EAAA,EAAA1B,KAAA,GAAA0B,EACAA,GAAA,EAAA1B,KAAA,GAAA0B,EAAA1B,KAAA2V,GACA3V,KAAAW,EAAA,EAGA,QAAAiV,GAAA/U,GAEA,GAAAoB,GAAAuS,GAEA,OADAvS,GAAAoS,QAAAxT,GACAoB,EAGA,QAAA4T,GAAAP,EAAApB,GAEA,GAAA4B,EACA,QAAA5B,EAAA4B,EAAA,MACA,OAAA5B,EAAA4B,EAAA,MACA,SAAA5B,EAAA4B,EAAA,MACA,OAAA5B,EAAA4B,EAAA,MACA,QAAA5B,EAAA4B,EAAA,MACA,OAAA5B,EAIA,WADAlU,MAAA+V,UAAAT,EAAApB,EAHA4B,GAAA,EAMA9V,KAAAW,EAAA,EACAX,KAAAsV,EAAA,CAIA,KAHA,GAAAzU,GAAAyU,EAAAlU,OACA4U,GAAA,EACAC,EAAA,IACApV,GAAA,GACA,CACA,GAAAa,GAAA,GAAAoU,EAAA,IAAAR,EAAAzU,GAAAwU,EAAAC,EAAAzU,EACAa,GAAA,EAEA,KAAA4T,EAAAF,OAAAvU,KAAAmV,GAAA,IAGAA,GAAA,EACA,GAAAC,EACAjW,UAAAW,KAAAe,EACAuU,EAAAH,EAAA9V,KAAAkW,IAEAlW,UAAAW,EAAA,KAAAe,GAAA,GAAA1B,KAAAkW,GAAAD,GAAA,IAAAA,EACAjW,UAAAW,KAAAe,GAAA1B,KAAAkW,GAAAD,GAGAjW,UAAAW,EAAA,IAAAe,GAAAuU,EACAA,GAAAH,EACAG,GAAAjW,KAAAkW,KAAAD,GAAAjW,KAAAkW,KAEA,GAAAJ,GAAA,QAAAR,EAAA,MAEAtV,KAAAsV,GAAA,EACAW,EAAA,IAAAjW,UAAAW,EAAA,QAAAX,KAAAkW,GAAAD,GAAA,GAAAA,IAEAjW,KAAAmW,QACAH,GAAAhC,EAAAoC,KAAAC,MAAArW,WAGA,QAAAsW,KAGA,IADA,GAAA7V,GAAAT,KAAAsV,EAAAtV,KAAAuW,GACAvW,KAAAW,EAAA,GAAAX,UAAAW,EAAA,IAAAF,KAAAT,KAAAW,EAGA,QAAA6V,GAAAtC,GAEA,GAAAlU,KAAAsV,EAAA,YAAAtV,KAAAyW,SAAAC,SAAAxC,EACA,IAAA4B,EACA,QAAA5B,EAAA4B,EAAA,MACA,OAAA5B,EAAA4B,EAAA,MACA,OAAA5B,EAAA4B,EAAA,MACA,QAAA5B,EAAA4B,EAAA,MACA,OAAA5B,EACA,MAAAlU,MAAA2W,QAAAzC,EADA4B,GAAA,EAEA,GACAc,GADAC,GAAA,GAAAf,GAAA,EACAtV,GAAA,EACAyB,EAAA,GACApB,EAAAb,KAAAW,EACAD,EAAAV,KAAAkW,GAAArV,EAAAb,KAAAkW,GAAAJ,CACA,IAAAjV,KAAA,EAOA,IALAH,EAAAV,KAAAkW,KAAAU,EAAA5W,KAAAa,IAAAH,GAAA,IAEAF,GAAA,EACAyB,EAAAiT,EAAA0B,IAEA/V,GAAA,GAEAH,EAAAoV,GAEAc,GAAA5W,KAAAa,IAAA,GAAAH,GAAA,IAAAoV,EAAApV,EACAkW,GAAA5W,OAAAa,KAAAH,GAAAV,KAAAkW,GAAAJ,KAIAc,EAAA5W,KAAAa,KAAAH,GAAAoV,GAAAe,EACAnW,GAAA,IAEAA,GAAAV,KAAAkW,KACArV,IAGA+V,EAAA,IAAApW,GAAA,GACAA,IAAAyB,GAAAiT,EAAA0B,GAGA,OAAApW,GAAAyB,EAAA,IAGA,QAAA6U,KAEA,GAAA7U,GAAAuS,GAEA,OADAR,GAAAoC,KAAAC,MAAArW,KAAAiC,GACAA,EAGA,QAAA8U,KAEA,MAAA/W,MAAAsV,EAAA,EAAAtV,KAAAyW,SAAAzW,KAGA,QAAAgX,GAAA/C,GAEA,GAAAhS,GAAAjC,KAAAsV,EAAArB,EAAAqB,CACA,OAAArT,EAAA,MAAAA,EACA,IAAApB,GAAAb,KAAAW,CAEA,IADAsB,EAAApB,EAAAoT,EAAAtT,EACA,GAAAsB,EAAA,MAAAjC,MAAAsV,EAAA,GAAArT,GACA,QAAApB,GAAA,GACA,OAAAoB,EAAAjC,KAAAa,GAAAoT,EAAApT,IAAA,MAAAoB,EACA,UAGA,QAAAgV,GAAAvV,GAEA,GACAf,GADAsB,EAAA,CA2BA,OAzBA,KAAAtB,EAAAe,IAAA,MAEAA,EAAAf,EACAsB,GAAA,IAEA,IAAAtB,EAAAe,GAAA,KAEAA,EAAAf,EACAsB,GAAA,GAEA,IAAAtB,EAAAe,GAAA,KAEAA,EAAAf,EACAsB,GAAA,GAEA,IAAAtB,EAAAe,GAAA,KAEAA,EAAAf,EACAsB,GAAA,GAEA,IAAAtB,EAAAe,GAAA,KAEAA,EAAAf,EACAsB,GAAA,GAEAA,EAGA,QAAAiV,KAEA,MAAAlX,MAAAW,GAAA,IACAX,KAAAkW,IAAAlW,KAAAW,EAAA,GAAAsW,EAAAjX,UAAAW,EAAA,GAAAX,KAAAsV,EAAAtV,KAAAuW,IAGA,QAAAY,GAAAvW,EAAAqB,GAEA,GAAApB,EACA,KAAAA,EAAAb,KAAAW,EAAA,EAAwBE,GAAA,IAAQA,EAAAoB,EAAApB,EAAAD,GAAAZ,KAAAa,EAChC,KAAAA,EAAAD,EAAA,EAAmBC,GAAA,IAAQA,EAAAoB,EAAApB,GAAA,CAC3BoB,GAAAtB,EAAAX,KAAAW,EAAAC,EACAqB,EAAAqT,EAAAtV,KAAAsV,EAGA,QAAA8B,GAAAxW,EAAAqB,GAEA,OAAApB,GAAAD,EAAmBC,EAAAb,KAAAW,IAAYE,EAAAoB,EAAApB,EAAAD,GAAAZ,KAAAa,EAC/BoB,GAAAtB,EAAA4I,KAAAyF,IAAAhP,KAAAW,EAAAC,EAAA,GACAqB,EAAAqT,EAAAtV,KAAAsV,EAGA,QAAA+B,GAAAzW,EAAAqB,GAEA,GAKApB,GALAyW,EAAA1W,EAAAZ,KAAAkW,GACAqB,EAAAvX,KAAAkW,GAAAoB,EACAE,GAAA,GAAAD,GAAA,EACAE,EAAAlO,KAAAqL,MAAAhU,EAAAZ,KAAAkW,IACAzV,EAAAT,KAAAsV,GAAAgC,EAAAtX,KAAAuW,EAEA,KAAA1V,EAAAb,KAAAW,EAAA,EAAwBE,GAAA,IAAQA,EAEhCoB,EAAApB,EAAA4W,EAAA,GAAAzX,KAAAa,IAAA0W,EAAA9W,EACAA,GAAAT,KAAAa,GAAA2W,IAAAF,CAEA,KAAAzW,EAAA4W,EAAA,EAAoB5W,GAAA,IAAQA,EAAAoB,EAAApB,GAAA,CAC5BoB,GAAAwV,GAAAhX,EACAwB,EAAAtB,EAAAX,KAAAW,EAAA8W,EAAA,EACAxV,EAAAqT,EAAAtV,KAAAsV,EACArT,EAAAkU,QAGA,QAAAuB,GAAA9W,EAAAqB,GAEAA,EAAAqT,EAAAtV,KAAAsV,CACA,IAAAmC,GAAAlO,KAAAqL,MAAAhU,EAAAZ,KAAAkW,GACA,IAAAuB,GAAAzX,KAAAW,EAGA,YADAsB,EAAAtB,EAAA,EAGA,IAAA2W,GAAA1W,EAAAZ,KAAAkW,GACAqB,EAAAvX,KAAAkW,GAAAoB,EACAE,GAAA,GAAAF,GAAA,CACArV,GAAA,GAAAjC,KAAAyX,IAAAH,CACA,QAAAzW,GAAA4W,EAAA,EAAwB5W,EAAAb,KAAAW,IAAYE,EAEpCoB,EAAApB,EAAA4W,EAAA,KAAAzX,KAAAa,GAAA2W,IAAAD,EACAtV,EAAApB,EAAA4W,GAAAzX,KAAAa,IAAAyW,CAEAA,GAAA,IAAArV,EAAAjC,KAAAW,EAAA8W,EAAA,KAAAzX,KAAAsV,EAAAkC,IAAAD,GACAtV,EAAAtB,EAAAX,KAAAW,EAAA8W,EACAxV,EAAAkU,QAGA,QAAAwB,GAAA1D,EAAAhS,GAKA,IAHA,GAAApB,GAAA,EACAJ,EAAA,EACAD,EAAA+I,KAAAwF,IAAAkF,EAAAtT,EAAAX,KAAAW,GACAE,EAAAL,GAEAC,GAAAT,KAAAa,GAAAoT,EAAApT,GACAoB,EAAApB,KAAAJ,EAAAT,KAAAuW,GACA9V,IAAAT,KAAAkW,EAEA,IAAAjC,EAAAtT,EAAAX,KAAAW,EACA,CAEA,IADAF,GAAAwT,EAAAqB,EACAzU,EAAAb,KAAAW,GAEAF,GAAAT,KAAAa,GACAoB,EAAApB,KAAAJ,EAAAT,KAAAuW,GACA9V,IAAAT,KAAAkW,EAEAzV,IAAAT,KAAAsV,MAGA,CAEA,IADA7U,GAAAT,KAAAsV,EACAzU,EAAAoT,EAAAtT,GAEAF,GAAAwT,EAAApT,GACAoB,EAAApB,KAAAJ,EAAAT,KAAAuW,GACA9V,IAAAT,KAAAkW,EAEAzV,IAAAwT,EAAAqB,EAEArT,EAAAqT,EAAA7U,EAAA,OACAA,GAAA,EAAAwB,EAAApB,KAAAb,KAAA2V,GAAAlV,EACAA,EAAA,IAAAwB,EAAApB,KAAAJ,GACAwB,EAAAtB,EAAAE,EACAoB,EAAAkU,QAIA,QAAAyB,GAAA3D,EAAAhS,GAEA,GAAAP,GAAA1B,KAAA6X,MACAjW,EAAAqS,EAAA4D,MACAhX,EAAAa,EAAAf,CAEA,KADAsB,EAAAtB,EAAAE,EAAAe,EAAAjB,IACAE,GAAA,GAAAoB,EAAApB,GAAA,CACA,KAAAA,EAAA,EAAeA,EAAAe,EAAAjB,IAASE,EAAAoB,EAAApB,EAAAa,EAAAf,GAAAe,EAAAoW,GAAA,EAAAlW,EAAAf,GAAAoB,EAAApB,EAAA,EAAAa,EAAAf,EACxBsB,GAAAqT,EAAA,EACArT,EAAAkU,QACAnW,KAAAsV,GAAArB,EAAAqB,GAAAtB,EAAAoC,KAAAC,MAAApU,KAGA,QAAA8V,GAAA9V,GAIA,IAFA,GAAAP,GAAA1B,KAAA6X,MACAhX,EAAAoB,EAAAtB,EAAA,EAAAe,EAAAf,IACAE,GAAA,GAAAoB,EAAApB,GAAA,CACA,KAAAA,EAAA,EAAeA,EAAAa,EAAAf,EAAA,IAAaE,EAC5B,CACA,GAAAJ,GAAAiB,EAAAoW,GAAAjX,EAAAa,EAAAb,GAAAoB,EAAA,EAAApB,EAAA,MACAoB,EAAApB,EAAAa,EAAAf,IAAAe,EAAAoW,GAAAjX,EAAA,IAAAa,EAAAb,GAAAoB,EAAA,EAAApB,EAAA,EAAAJ,EAAAiB,EAAAf,EAAAE,EAAA,KAAAa,EAAAiU,KAEA1T,EAAApB,EAAAa,EAAAf,IAAAe,EAAAiU,GACA1T,EAAApB,EAAAa,EAAAf,EAAA,MAGAsB,EAAAtB,EAAA,IAAAsB,IAAAtB,EAAA,IAAAe,EAAAoW,GAAAjX,EAAAa,EAAAb,GAAAoB,EAAA,EAAApB,EAAA,MACAoB,EAAAqT,EAAA,EACArT,EAAAkU,QAIA,QAAA6B,GAAAxX,EAAAyX,EAAAhW,GAEA,GAAAiW,GAAA1X,EAAAqX,KACA,MAAAK,EAAAvX,GAAA,IACA,GAAAwX,GAAAnY,KAAA6X,KACA,IAAAM,EAAAxX,EAAAuX,EAAAvX,EAIA,MAFA,OAAAsX,KAAA5D,QAAA,QACA,MAAApS,GAAAjC,KAAAoY,OAAAnW,GAGA,OAAAA,MAAAuS,IACA,IAAA5S,GAAA4S,IACA6D,EAAArY,KAAAsV,EACAgD,EAAA9X,EAAA8U,EACAiD,EAAAvY,KAAAkW,GAAAe,EAAAiB,IAAAvX,EAAA,GACA4X,GAAA,GAEAL,EAAAM,SAAAD,EAAA3W,GACAuW,EAAAK,SAAAD,EAAAtW,KAIAiW,EAAAE,OAAAxW,GACAuW,EAAAC,OAAAnW,GAEA,IAAAwW,GAAA7W,EAAAjB,EACA+X,EAAA9W,EAAA6W,EAAA,EACA,OAAAC,EAAA,CACA,GAAAC,GAAAD,GAAA,GAAA1Y,KAAA4Y,KAAAH,EAAA,EAAA7W,EAAA6W,EAAA,IAAAzY,KAAA6Y,GAAA,GACAC,EAAA9Y,KAAA+Y,GAAAJ,EACAK,GAAA,GAAAhZ,KAAA4Y,IAAAD,EACA7X,EAAA,GAAAd,KAAA6Y,GACAhY,EAAAoB,EAAAtB,EACA+T,EAAA7T,EAAA4X,EACA9X,EAAA,MAAAsX,EAAAzD,IAAAyD,CASA,KARArW,EAAAqX,UAAAvE,EAAA/T,GACAsB,EAAAiX,UAAAvY,IAAA,IAEAsB,IAAAtB,KAAA,EACAsB,EAAAoU,MAAA1V,EAAAsB,IAEA+R,EAAAmF,IAAAF,UAAAR,EAAA9X,GACAA,EAAA0V,MAAAzU,KACAA,EAAAjB,EAAA8X,GAAA7W,IAAAjB,KAAA,CACA,QAAA+T,GAAA,GACA,CAEA,GAAA0E,GAAAnX,IAAApB,IAAA6X,EAAA1Y,KAAAuW,GAAAhN,KAAAqL,MAAA3S,EAAApB,GAAAiY,GAAA7W,EAAApB,EAAA,GAAAC,GAAAkY,EACA,KAAA/W,EAAApB,IAAAe,EAAAkW,GAAA,EAAAsB,EAAAnX,EAAAyS,EAAA,EAAA+D,IAAAW,EAIA,IAFAxX,EAAAqX,UAAAvE,EAAA/T,GACAsB,EAAAoU,MAAA1V,EAAAsB,GACAA,EAAApB,KAAAuY,GAAAnX,EAAAoU,MAAA1V,EAAAsB,GAGA,MAAAgW,IAEAhW,EAAAoX,UAAAZ,EAAAR,GACAI,GAAAC,GAAAtE,EAAAoC,KAAAC,MAAA4B,MAEAhW,EAAAtB,EAAA8X,EACAxW,EAAAkU,QACAoC,EAAA,GAAAtW,EAAAqX,SAAAf,EAAAtW,GACAoW,EAAA,GAAArE,EAAAoC,KAAAC,MAAApU,OAGA,QAAAsX,GAAAtF,GAEA,GAAAhS,GAAAuS,GAGA,OAFAxU,MAAA6X,MAAA2B,SAAAvF,EAAA,KAAAhS,GACAjC,KAAAsV,EAAA,GAAArT,EAAAiX,UAAAlF,EAAAoC,MAAA,GAAAnC,EAAAoC,MAAApU,KACAA,EAGA,QAAAwX,GAAAjZ,GAEAR,KAAAQ,IAGA,QAAAkZ,GAAAhY,GAEA,MAAAA,GAAA4T,EAAA,GAAA5T,EAAAwX,UAAAlZ,KAAAQ,IAAA,EAAAkB,EAAAiY,IAAA3Z,KAAAQ,GACAkB,EAGA,QAAAkY,GAAAlY,GAEA,MAAAA,GAGA,QAAAmY,GAAAnY,GAEAA,EAAA8X,SAAAxZ,KAAAQ,EAAA,KAAAkB,GAGA,QAAAoY,GAAApY,EAAAE,EAAAK,GAEAP,EAAAqY,WAAAnY,EAAAK,GACAjC,KAAAga,OAAA/X,GAGA,QAAAgY,GAAAvY,EAAAO,GAEAP,EAAAwY,SAAAjY,GACAjC,KAAAga,OAAA/X,GAiBA,QAAAkY,KAEA,GAAAna,KAAAW,EAAA,UACA,IAAAe,GAAA1B,KAAA,EACA,UAAA0B,GAAA,QACA,IAAAE,GAAA,EAAAF,CAQA,OAPAE,MAAA,MAAAF,GAAAE,GAAA,GACAA,KAAA,OAAAF,GAAAE,GAAA,IACAA,KAAA,UAAAF,GAAAE,EAAA,cAGAA,KAAA,EAAAF,EAAAE,EAAA5B,KAAA2V,IAAA3V,KAAA2V,GAEA/T,EAAA,EAAA5B,KAAA2V,GAAA/T,KAGA,QAAAwY,GAAA5Z,GAEAR,KAAAQ,IACAR,KAAAqa,GAAA7Z,EAAA8Z,WACAta,KAAAua,IAAA,MAAAva,KAAAqa,GACAra,KAAAwa,IAAAxa,KAAAqa,IAAA,GACAra,KAAAya,IAAA,GAAAja,EAAA0V,GAAA,MACAlW,KAAA0a,IAAA,EAAAla,EAAAG,EAGA,QAAAga,GAAAjZ,GAEA,GAAAO,GAAAuS,GAIA,OAHA9S,GAAAmW,MAAAoB,UAAAjZ,KAAAQ,EAAAG,EAAAsB,GACAA,EAAAuX,SAAAxZ,KAAAQ,EAAA,KAAAyB,GACAP,EAAA4T,EAAA,GAAArT,EAAAiX,UAAAlF,EAAAoC,MAAA,GAAApW,KAAAQ,EAAA6V,MAAApU,KACAA,EAGA,QAAA2Y,GAAAlZ,GAEA,GAAAO,GAAAuS,GAGA,OAFA9S,GAAA0W,OAAAnW,GACAjC,KAAAga,OAAA/X,GACAA,EAGA,QAAA4Y,GAAAnZ,GAEA,KAAAA,EAAAf,GAAAX,KAAA0a,KACAhZ,IAAAf,KAAA,CACA,QAAAE,GAAA,EAAmBA,EAAAb,KAAAQ,EAAAG,IAAcE,EACjC,CAEA,GAAA6T,GAAA,MAAAhT,EAAAb,GACAia,EAAApG,EAAA1U,KAAAua,MAAA7F,EAAA1U,KAAAwa,KAAA9Y,EAAAb,IAAA,IAAAb,KAAAua,IAAAva,KAAAya,KAAA,IAAA/Y,EAAA6U,EAKA,KAHA7B,EAAA7T,EAAAb,KAAAQ,EAAAG,EACAe,EAAAgT,IAAA1U,KAAAQ,EAAAsX,GAAA,EAAAgD,EAAApZ,EAAAb,EAAA,EAAAb,KAAAQ,EAAAG,GAEAe,EAAAgT,IAAAhT,EAAAiU,IAEAjU,EAAAgT,IAAAhT,EAAAiU,GACAjU,IAAAgT,KAGAhT,EAAAyU,QACAzU,EAAA2X,UAAArZ,KAAAQ,EAAAG,EAAAe,GACAA,EAAAwX,UAAAlZ,KAAAQ,IAAA,GAAAkB,EAAA2U,MAAArW,KAAAQ,EAAAkB,GAGA,QAAAqZ,GAAArZ,EAAAO,GAEAP,EAAAwY,SAAAjY,GACAjC,KAAAga,OAAA/X,GAGA,QAAA+Y,GAAAtZ,EAAAE,EAAAK,GAEAP,EAAAqY,WAAAnY,EAAAK,GACAjC,KAAAga,OAAA/X,GAQA,QAAAgZ,KAEA,WAAAjb,KAAAW,EAAA,IAAAX,KAAA,GAAAA,KAAAsV,GAGA,QAAA4F,GAAApa,EAAAqa,GAEA,GAAAra,EAAA,YAAAA,EAAA,QAAAkT,GAAAmF,GACA,IAAAlX,GAAAuS,IACA4G,EAAA5G,IACA6G,EAAAF,EAAAG,QAAAtb,MACAa,EAAAoW,EAAAnW,GAAA,CAEA,KADAua,EAAAjD,OAAAnW,KACApB,GAAA,GAGA,GADAsa,EAAAI,MAAAtZ,EAAAmZ,IACAta,EAAA,GAAAD,GAAA,EAAAsa,EAAAK,MAAAJ,EAAAC,EAAApZ,OAEA,CACA,GAAAtB,GAAAsB,CACAA,GAAAmZ,EACAA,EAAAza,EAGA,MAAAwa,GAAAM,OAAAxZ,GAGA,QAAAyZ,GAAA5a,EAAAN,GAEA,GAAA2a,EAGA,OAFAA,GAAAra,EAAA,KAAAN,EAAAmb,SAAA,GAAAlC,GAAAjZ,GACA,GAAA4Z,GAAA5Z,GACAR,KAAA4b,IAAA9a,EAAAqa,GAoCA,QAAAU,KAEA,GAAA5Z,GAAAuS,GAEA,OADAxU,MAAAoY,OAAAnW,GACAA,EAGA,QAAA6Z,KAEA,GAAA9b,KAAAsV,EAAA,EACA,CACA,MAAAtV,KAAAW,EAAA,MAAAX,MAAA,GAAAA,KAAA2V,EACA,OAAA3V,KAAAW,EAAA,aAEA,OAAAX,KAAAW,EAAA,MAAAX,MAAA,EACA,OAAAA,KAAAW,EAAA,SAEA,OAAAX,KAAA,UAAAA,KAAAkW,IAAA,IAAAlW,KAAAkW,GAAAlW,KAAA,GAGA,QAAA+b,KAEA,UAAA/b,KAAAW,EAAAX,KAAAsV,EAAAtV,KAAA,WAGA,QAAAgc,KAEA,UAAAhc,KAAAW,EAAAX,KAAAsV,EAAAtV,KAAA,WAGA,QAAAic,GAAAha,GAEA,MAAAsH,MAAAqL,MAAArL,KAAA2S,IAAAlc,KAAAkW,GAAA3M,KAAA4S,IAAAla,IAGA,QAAAma,KAEA,MAAApc,MAAAsV,EAAA,KACAtV,KAAAW,GAAA,MAAAX,KAAAW,GAAAX,KAAA,QACA,EAGA,QAAAqc,IAAAnI,GAGA,GADA,MAAAA,MAAA,IACA,GAAAlU,KAAAsc,UAAApI,EAAA,GAAAA,EAAA,YACA,IAAAqI,GAAAvc,KAAAwc,UAAAtI,GACAD,EAAA1K,KAAAkT,IAAAvI,EAAAqI,GACA3F,EAAAhB,EAAA3B,GACArS,EAAA4S,IACA2G,EAAA3G,IACAvS,EAAA,EAEA,KADAjC,KAAAwZ,SAAA5C,EAAAhV,EAAAuZ,GACAvZ,EAAA0a,SAAA,GAEAra,GAAAgS,EAAAkH,EAAAuB,YAAAhG,SAAAxC,GAAA1E,OAAA,GAAAvN,EACAL,EAAA4X,SAAA5C,EAAAhV,EAAAuZ,EAEA,OAAAA,GAAAuB,WAAAhG,SAAAxC,GAAAjS,EAGA,QAAA0a,IAAArH,EAAApB,GAEAlU,KAAAqU,QAAA,GACA,MAAAH,MAAA,GAMA,QALAqI,GAAAvc,KAAAwc,UAAAtI,GACA0C,EAAArN,KAAAkT,IAAAvI,EAAAqI,GACAvG,GAAA,EACAtB,EAAA,EACAnD,EAAA,EACA1Q,EAAA,EAAmBA,EAAAyU,EAAAlU,SAAcP,EACjC,CACA,GAAAa,GAAA2T,EAAAC,EAAAzU,EACAa,GAAA,EAEA,KAAA4T,EAAAF,OAAAvU,IAAA,GAAAb,KAAAsc,WAAAtG,GAAA,IAGAzE,EAAA2C,EAAA3C,EAAA7P,IACAgT,GAAA6H,IAEAvc,KAAA4c,UAAAhG,GACA5W,KAAA6c,WAAAtL,EAAA,GACAmD,EAAA,EACAnD,EAAA,IAGAmD,EAAA,IAEA1U,KAAA4c,UAAArT,KAAAkT,IAAAvI,EAAAQ,IACA1U,KAAA6c,WAAAtL,EAAA,IAEAyE,GAAAhC,EAAAoC,KAAAC,MAAArW,WAGA,QAAA8c,IAAA7I,EAAAC,EAAAzT,GAEA,mBAAAyT,GAGA,GAAAD,EAAA,EAAAjU,KAAAqU,QAAA,OAOA,KAJArU,KAAAsU,WAAAL,EAAAxT,GACAT,KAAA+c,QAAA9I,EAAA,IACAjU,KAAAgd,UAAAhJ,EAAAmF,IAAA8D,UAAAhJ,EAAA,GAAAiJ,GAAAld,MACAA,KAAA2b,UAAA3b,KAAA6c,WAAA,MACA7c,KAAAmd,gBAAAjJ,IAEAlU,KAAA6c,WAAA;AACA7c,KAAAod,YAAAnJ,GAAAjU,KAAAqW,MAAArC,EAAAmF,IAAA8D,UAAAhJ,EAAA,GAAAjU,UAKA,CAEA,GAAA0B,GAAA,GAAA2b,OACA1c,EAAA,EAAAsT,CACAvS,GAAAN,QAAA6S,GAAA,KACAC,EAAAoJ,UAAA5b,GACAf,EAAA,EAAAe,EAAA,QAAAf,GAAA,EACAe,EAAA,KACA1B,KAAAuU,WAAA7S,EAAA,MAIA,QAAA6b,MAEA,GAAA1c,GAAAb,KAAAW,EACAsB,EAAA,GAAAob,MACApb,GAAA,GAAAjC,KAAAsV,CACA,IACAsB,GADAlW,EAAAV,KAAAkW,GAAArV,EAAAb,KAAAkW,GAAA,EACAJ,EAAA,CACA,IAAAjV,KAAA,EAIA,IAFAH,EAAAV,KAAAkW,KAAAU,EAAA5W,KAAAa,IAAAH,KAAAV,KAAAsV,EAAAtV,KAAAuW,KAAA7V,IACAuB,EAAA6T,KAAAc,EAAA5W,KAAAsV,GAAAtV,KAAAkW,GAAAxV,GACAG,GAAA,GAEAH,EAAA,GAEAkW,GAAA5W,KAAAa,IAAA,GAAAH,GAAA,MAAAA,EACAkW,GAAA5W,OAAAa,KAAAH,GAAAV,KAAAkW,GAAA,KAIAU,EAAA5W,KAAAa,KAAAH,GAAA,OACAA,GAAA,IAEAA,GAAAV,KAAAkW,KACArV,IAGA,QAAA+V,SAAA,KACA,GAAAd,IAAA,IAAA9V,KAAAsV,KAAA,IAAAsB,MAAAd,GACAA,EAAA,GAAAc,GAAA5W,KAAAsV,KAAArT,EAAA6T,KAAAc,EAGA,OAAA3U,GAGA,QAAAub,IAAAvJ,GAEA,UAAAjU,KAAAkZ,UAAAjF,GAGA,QAAAwJ,IAAAxJ,GAEA,MAAAjU,MAAAkZ,UAAAjF,GAAA,EAAAjU,KAAAiU,EAGA,QAAAyJ,IAAAzJ,GAEA,MAAAjU,MAAAkZ,UAAAjF,GAAA,EAAAjU,KAAAiU,EAGA,QAAA0J,IAAA1J,EAAA2J,EAAA3b,GAEA,GAAApB,GAAAgd,EAAArd,EAAA+I,KAAAwF,IAAAkF,EAAAtT,EAAAX,KAAAW,EACA,KAAAE,EAAA,EAAeA,EAAAL,IAAOK,EAAAoB,EAAApB,GAAA+c,EAAA5d,KAAAa,GAAAoT,EAAApT,GACtB,IAAAoT,EAAAtT,EAAAX,KAAAW,EACA,CAEA,IADAkd,EAAA5J,EAAAqB,EAAAtV,KAAAuW,GACA1V,EAAAL,EAAiBK,EAAAb,KAAAW,IAAYE,EAAAoB,EAAApB,GAAA+c,EAAA5d,KAAAa,GAAAgd,EAC7B5b,GAAAtB,EAAAX,KAAAW,MAGA,CAEA,IADAkd,EAAA7d,KAAAsV,EAAAtV,KAAAuW,GACA1V,EAAAL,EAAiBK,EAAAoT,EAAAtT,IAASE,EAAAoB,EAAApB,GAAA+c,EAAAC,EAAA5J,EAAApT,GAC1BoB,GAAAtB,EAAAsT,EAAAtT,EAEAsB,EAAAqT,EAAAsI,EAAA5d,KAAAsV,EAAArB,EAAAqB,GACArT,EAAAkU,QAGA,QAAA2H,IAAApc,EAAAE,GAEA,MAAAF,GAAAE,EAGA,QAAAmc,IAAA9J,GAEA,GAAAhS,GAAAuS,GAEA,OADAxU,MAAAgd,UAAA/I,EAAA6J,GAAA7b,GACAA,EAGA,QAAAib,IAAAxb,EAAAE,GAEA,MAAAF,GAAAE,EAGA,QAAAoc,IAAA/J,GAEA,GAAAhS,GAAAuS,GAEA,OADAxU,MAAAgd,UAAA/I,EAAAiJ,GAAAjb,GACAA,EAGA,QAAAgc,IAAAvc,EAAAE,GAEA,MAAAF,GAAAE,EAGA,QAAAsc,IAAAjK,GAEA,GAAAhS,GAAAuS,GAEA,OADAxU,MAAAgd,UAAA/I,EAAAgK,GAAAhc,GACAA,EAGA,QAAAkc,IAAAzc,EAAAE,GAEA,MAAAF,IAAAE,EAGA,QAAAwc,IAAAnK,GAEA,GAAAhS,GAAAuS,GAEA,OADAxU,MAAAgd,UAAA/I,EAAAkK,GAAAlc,GACAA,EAGA,QAAAoc,MAGA,OADApc,GAAAuS,IACA3T,EAAA,EAAmBA,EAAAb,KAAAW,IAAYE,EAAAoB,EAAApB,GAAAb,KAAAuW,IAAAvW,KAAAa,EAG/B,OAFAoB,GAAAtB,EAAAX,KAAAW,EACAsB,EAAAqT,GAAAtV,KAAAsV,EACArT,EAGA,QAAAqc,IAAA1d,GAEA,GAAAqB,GAAAuS,GAGA,OAFA5T,GAAA,EAAAZ,KAAAsZ,UAAA1Y,EAAAqB,GACAjC,KAAAwY,SAAA5X,EAAAqB,GACAA,EAGA,QAAAsc,IAAA3d,GAEA,GAAAqB,GAAAuS,GAGA,OAFA5T,GAAA,EAAAZ,KAAAwY,UAAA5X,EAAAqB,GACAjC,KAAAsZ,SAAA1Y,EAAAqB,GACAA,EAGA,QAAAuc,IAAA9c,GAEA,MAAAA,EAAA,QACA,IAAAO,GAAA,CAsBA,OArBA,WAAAP,KAEAA,IAAA,GACAO,GAAA,IAEA,QAAAP,KAEAA,IAAA,EACAO,GAAA,GAEA,OAAAP,KAEAA,IAAA,EACAO,GAAA,GAEA,MAAAP,KAEAA,IAAA,EACAO,GAAA,GAEA,MAAAP,MAAAO,EACAA,EAGA,QAAAwc,MAEA,OAAA5d,GAAA,EAAmBA,EAAAb,KAAAW,IAAYE,EAC/B,MAAAb,KAAAa,GAAA,MAAAA,GAAAb,KAAAkW,GAAAsI,GAAAxe,KAAAa,GACA,OAAAb,MAAAsV,EAAA,EAAAtV,KAAAW,EAAAX,KAAAkW,IACA,EAGA,QAAAwI,IAAAhd,GAGA,IADA,GAAAO,GAAA,EACA,GAAAP,GAEAA,KAAA,IACAO,CAEA,OAAAA,GAGA,QAAA0c,MAIA,OAFA1c,GAAA,EACAP,EAAA1B,KAAAsV,EAAAtV,KAAAuW,GACA1V,EAAA,EAAmBA,EAAAb,KAAAW,IAAYE,EAAAoB,GAAAyc,GAAA1e,KAAAa,GAAAa,EAC/B,OAAAO,GAGA,QAAA2c,IAAAhe,GAEA,GAAA8T,GAAAnL,KAAAqL,MAAAhU,EAAAZ,KAAAkW,GACA,OAAAxB,IAAA1U,KAAAW,EAAA,GAAAX,KAAAsV,EACA,IAAAtV,KAAA0U,GAAA,GAAA9T,EAAAZ,KAAAkW,IAGA,QAAA2I,IAAAje,EAAAgd,GAEA,GAAA3b,GAAA+R,EAAAmF,IAAA8D,UAAArc,EAEA,OADAZ,MAAAgd,UAAA/a,EAAA2b,EAAA3b,GACAA,EAGA,QAAA6c,IAAAle,GAEA,MAAAZ,MAAA+e,UAAAne,EAAAsc,IAGA,QAAA8B,IAAApe,GAEA,MAAAZ,MAAA+e,UAAAne,EAAAud,IAGA,QAAAc,IAAAre,GAEA,MAAAZ,MAAA+e,UAAAne,EAAAqd,IAGA,QAAAiB,IAAAjL,EAAAhS,GAKA,IAHA,GAAApB,GAAA,EACAJ,EAAA,EACAD,EAAA+I,KAAAwF,IAAAkF,EAAAtT,EAAAX,KAAAW,GACAE,EAAAL,GAEAC,GAAAT,KAAAa,GAAAoT,EAAApT,GACAoB,EAAApB,KAAAJ,EAAAT,KAAAuW,GACA9V,IAAAT,KAAAkW,EAEA,IAAAjC,EAAAtT,EAAAX,KAAAW,EACA,CAEA,IADAF,GAAAwT,EAAAqB,EACAzU,EAAAb,KAAAW,GAEAF,GAAAT,KAAAa,GACAoB,EAAApB,KAAAJ,EAAAT,KAAAuW,GACA9V,IAAAT,KAAAkW,EAEAzV,IAAAT,KAAAsV,MAGA,CAEA,IADA7U,GAAAT,KAAAsV,EACAzU,EAAAoT,EAAAtT,GAEAF,GAAAwT,EAAApT,GACAoB,EAAApB,KAAAJ,EAAAT,KAAAuW,GACA9V,IAAAT,KAAAkW,EAEAzV,IAAAwT,EAAAqB,EAEArT,EAAAqT,EAAA7U,EAAA,OACAA,EAAA,EAAAwB,EAAApB,KAAAJ,EACAA,GAAA,IAAAwB,EAAApB,KAAAb,KAAA2V,GAAAlV,GACAwB,EAAAtB,EAAAE,EACAoB,EAAAkU,QAGA,QAAAgJ,IAAAlL,GAEA,GAAAhS,GAAAuS,GAEA,OADAxU,MAAAof,MAAAnL,EAAAhS,GACAA,EAGA,QAAAod,IAAApL,GAEA,GAAAhS,GAAAuS,GAEA,OADAxU,MAAAqW,MAAApC,EAAAhS,GACAA,EAGA,QAAAqd,IAAArL,GAEA,GAAAhS,GAAAuS,GAEA,OADAxU,MAAA+Z,WAAA9F,EAAAhS,GACAA,EAGA,QAAAsd,MAEA,GAAAtd,GAAAuS,GAEA,OADAxU,MAAAka,SAAAjY,GACAA,EAGA,QAAAud,IAAAvL,GAEA,GAAAhS,GAAAuS,GAEA,OADAxU,MAAAwZ,SAAAvF,EAAAhS,EAAA,MACAA,EAGA,QAAAwd,IAAAxL,GAEA,GAAAhS,GAAAuS,GAEA,OADAxU,MAAAwZ,SAAAvF,EAAA,KAAAhS,GACAA,EAGA,QAAAyd,IAAAzL,GAEA,GAAAgE,GAAAzD,IACAvS,EAAAuS,GAEA,OADAxU,MAAAwZ,SAAAvF,EAAAgE,EAAAhW,GACA,GAAAob,OAAApF,EAAAhW,GAGA,QAAA0d,IAAA/e,GAEAZ,UAAAW,GAAAX,KAAA8X,GAAA,EAAAlX,EAAA,EAAAZ,KAAA,IAAAA,KAAAW,KACAX,KAAAW,EACAX,KAAAmW,QAGA,QAAAyJ,IAAAhf,EAAA2Q,GAEA,MAAA3Q,EAAA,CACA,KAAAZ,KAAAW,GAAA4Q,GAAAvR,UAAAW,KAAA,CAEA,KADAX,KAAAuR,IAAA3Q,EACAZ,KAAAuR,IAAAvR,KAAA2V,IAEA3V,KAAAuR,IAAAvR,KAAA2V,KACApE,GAAAvR,KAAAW,IAAAX,UAAAW,KAAA,KACAX,KAAAuR,IAIA,QAAAsO,OAGA,QAAAC,IAAApe,GAEA,MAAAA,GAGA,QAAAqe,IAAAre,EAAAE,EAAAK,GAEAP,EAAAqY,WAAAnY,EAAAK,GAGA,QAAA+d,IAAAte,EAAAO,GAEAP,EAAAwY,SAAAjY,GAOA,QAAAge,IAAAnf,GAEA,MAAAd,MAAA4b,IAAA9a,EAAA,GAAA+e,KAIA,QAAAK,IAAAjM,EAAArT,EAAAqB,GAEA,GAAApB,GAAA0I,KAAAwF,IAAA/O,KAAAW,EAAAsT,EAAAtT,EAAAC,EAGA,KAFAqB,EAAAqT,EAAA,EACArT,EAAAtB,EAAAE,EACAA,EAAA,GAAAoB,IAAApB,GAAA,CACA,IAAA6T,EACA,KAAAA,EAAAzS,EAAAtB,EAAAX,KAAAW,EAA0BE,EAAA6T,IAAO7T,EAAAoB,EAAApB,EAAAb,KAAAW,GAAAX,KAAA8X,GAAA,EAAA7D,EAAApT,GAAAoB,EAAApB,EAAA,EAAAb,KAAAW,EACjC,KAAA+T,EAAAnL,KAAAwF,IAAAkF,EAAAtT,EAAAC,GAA8BC,EAAA6T,IAAO7T,EAAAb,KAAA8X,GAAA,EAAA7D,EAAApT,GAAAoB,EAAApB,EAAA,EAAAD,EAAAC,EACrCoB,GAAAkU,QAIA,QAAAgK,IAAAlM,EAAArT,EAAAqB,KAEArB,CACA,IAAAC,GAAAoB,EAAAtB,EAAAX,KAAAW,EAAAsT,EAAAtT,EAAAC,CAEA,KADAqB,EAAAqT,EAAA,IACAzU,GAAA,GAAAoB,EAAApB,GAAA,CACA,KAAAA,EAAA0I,KAAAyF,IAAApO,EAAAZ,KAAAW,EAAA,GAAqCE,EAAAoT,EAAAtT,IAASE,EAC9CoB,EAAAjC,KAAAW,EAAAE,EAAAD,GAAAZ,KAAA8X,GAAAlX,EAAAC,EAAAoT,EAAApT,GAAAoB,EAAA,IAAAjC,KAAAW,EAAAE,EAAAD,EACAqB,GAAAkU,QACAlU,EAAAoX,UAAA,EAAApX,GAGA,QAAAme,IAAA5f,GAGAR,KAAAob,GAAA5G,IACAxU,KAAAqgB,GAAA7L,IACAR,EAAAmF,IAAAF,UAAA,EAAAzY,EAAAG,EAAAX,KAAAob,IACApb,KAAAsgB,GAAAtgB,KAAAob,GAAAmF,OAAA/f,GACAR,KAAAQ,IAGA,QAAAggB,IAAA9e,GAEA,GAAAA,EAAA4T,EAAA,GAAA5T,EAAAf,EAAA,EAAAX,KAAAQ,EAAAG,EAAA,MAAAe,GAAAiY,IAAA3Z,KAAAQ,EACA,IAAAkB,EAAAwX,UAAAlZ,KAAAQ,GAAA,QAAAkB,EAGA,IAAAO,GAAAuS,GAGA,OAFA9S,GAAA0W,OAAAnW,GACAjC,KAAAga,OAAA/X,GACAA,EAIA,QAAAwe,IAAA/e,GAEA,MAAAA,GAGA,QAAAgf,IAAAhf,GAUA,IARAA,EAAA2X,UAAArZ,KAAAQ,EAAAG,EAAA,EAAAX,KAAAob,IACA1Z,EAAAf,EAAAX,KAAAQ,EAAAG,EAAA,IAEAe,EAAAf,EAAAX,KAAAQ,EAAAG,EAAA,EACAe,EAAAyU,SAEAnW,KAAAsgB,GAAAK,gBAAA3gB,KAAAob,GAAApb,KAAAQ,EAAAG,EAAA,EAAAX,KAAAqgB,IACArgB,KAAAQ,EAAAogB,gBAAA5gB,KAAAqgB,GAAArgB,KAAAQ,EAAAG,EAAA,EAAAX,KAAAob,IACA1Z,EAAAwX,UAAAlZ,KAAAob,IAAA,GAAA1Z,EAAAmb,WAAA,EAAA7c,KAAAQ,EAAAG,EAAA,EAEA,KADAe,EAAA2U,MAAArW,KAAAob,GAAA1Z,GACAA,EAAAwX,UAAAlZ,KAAAQ,IAAA,GAAAkB,EAAA2U,MAAArW,KAAAQ,EAAAkB,GAGA,QAAAmf,IAAAnf,EAAAO,GAEAP,EAAAwY,SAAAjY,GACAjC,KAAAga,OAAA/X,GAGA,QAAA6e,IAAApf,EAAAE,EAAAK,GAEAP,EAAAqY,WAAAnY,EAAAK,GACAjC,KAAAga,OAAA/X,GAQA,QAAA8e,IAAAjgB,EAAAN,GAEA,GACAsV,GACAqF,EAFAta,EAAAC,EAAAsc,YACAnb,EAAA2T,EAAA,EAEA,IAAA/U,GAAA,QAAAoB,EACA6T,GAAAjV,EAAA,KACAA,EAAA,KACAA,EAAA,MACAA,EAAA,MACA,EAEAsa,EADAta,EAAA,EACA,GAAA4Y,GAAAjZ,GACAA,EAAAmb,SACA,GAAAyE,IAAA5f,GAEA,GAAA4Z,GAAA5Z,EAEA,IAAA6a,GAAA,GAAAgC,OACAzc,EAAA,EACAogB,EAAAlL,EAAA,EACAe,GAAA,GAAAf,GAAA,CAEA,IADAuF,EAAA,GAAAF,EAAAG,QAAAtb,MACA8V,EAAA,EACA,CACA,GAAAmL,GAAAzM,GAEA,KADA2G,EAAAI,MAAAF,EAAA,GAAA4F,GACArgB,GAAAiW,GAEAwE,EAAAza,GAAA4T,IACA2G,EAAAK,MAAAyF,EAAA5F,EAAAza,EAAA,GAAAya,EAAAza,IACAA,GAAA,EAGA,GACA2Q,GAEA5Q,EAHA+T,EAAA5T,EAAAH,EAAA,EACAugB,GAAA,EACA9F,EAAA5G,GAGA,KADA3T,EAAAoW,EAAAnW,EAAA4T,IAAA,EACAA,GAAA,GACA,CAQA,IAPA7T,GAAAmgB,EAAAzP,EAAAzQ,EAAA4T,IAAA7T,EAAAmgB,EAAAnK,GAGAtF,GAAAzQ,EAAA4T,IAAA,GAAA7T,EAAA,OAAAmgB,EAAAngB,EACA6T,EAAA,IAAAnD,GAAAzQ,EAAA4T,EAAA,IAAA1U,KAAAkW,GAAArV,EAAAmgB,IAEApgB,EAAAkV,EACA,MAAAvE,IAEAA,IAAA,IACA3Q,CAOA,KALAC,GAAAD,GAAA,IAEAC,GAAAb,KAAAkW,KACAxB,GAEAwM,EAEA7F,EAAA9J,GAAA6G,OAAAnW,GACAif,GAAA,MAGA,CACA,KAAAtgB,EAAA,GAEAua,EAAAI,MAAAtZ,EAAAmZ,GACAD,EAAAI,MAAAH,EAAAnZ,GACArB,GAAA,CAEAA,GAAA,EAAAua,EAAAI,MAAAtZ,EAAAmZ,IAGAza,EAAAsB,EACAA,EAAAmZ,EACAA,EAAAza,GAEAwa,EAAAK,MAAAJ,EAAAC,EAAA9J,GAAAtP,GAEA,KAAAyS,GAAA,OAAA5T,EAAA4T,GAAA,GAAA7T,IAEAsa,EAAAI,MAAAtZ,EAAAmZ,GACAza,EAAAsB,EACAA,EAAAmZ,EACAA,EAAAza,IACAE,EAAA,IAEAA,EAAAb,KAAAkW,GAAA,IACAxB,GAIA,MAAAyG,GAAAM,OAAAxZ,GAGA,QAAAkf,IAAAlN,GAEA,GAAAvS,GAAA1B,KAAAsV,EAAA,EAAAtV,KAAAyW,SAAAzW,KAAAohB,QACAxf,EAAAqS,EAAAqB,EAAA,EAAArB,EAAAwC,SAAAxC,EAAAmN,OACA,IAAA1f,EAAAwX,UAAAtX,GAAA,EACA,CACA,GAAAjB,GAAAe,CACAA,GAAAE,EACAA,EAAAjB,EAEA,GAAAE,GAAAa,EAAA2f,kBACAhG,EAAAzZ,EAAAyf,iBACA,IAAAhG,EAAA,QAAA3Z,EAOA,KANAb,EAAAwa,MAAAxa,GACAwa,EAAA,IAEA3Z,EAAA4X,SAAA+B,EAAA3Z,GACAE,EAAA0X,SAAA+B,EAAAzZ,IAEAF,EAAA4a,SAAA,IAEAzb,EAAAa,EAAA2f,mBAAA,GAAA3f,EAAA4X,SAAAzY,EAAAa,IACAb,EAAAe,EAAAyf,mBAAA,GAAAzf,EAAA0X,SAAAzY,EAAAe,GACAF,EAAAwX,UAAAtX,IAAA,GAEAF,EAAA2U,MAAAzU,EAAAF,GACAA,EAAA4X,SAAA,EAAA5X,KAIAE,EAAAyU,MAAA3U,EAAAE,GACAA,EAAA0X,SAAA,EAAA1X,GAIA,OADAyZ,GAAA,GAAAzZ,EAAA4W,SAAA6C,EAAAzZ,GACAA,EAGA,QAAA0f,IAAA1gB,GAEA,GAAAA,GAAA,UACA,IAAAgW,GAAA5W,KAAA2V,GAAA/U,EACAqB,EAAAjC,KAAAsV,EAAA,EAAA1U,EAAA,GACA,IAAAZ,KAAAW,EAAA,EACA,MAAAiW,EAAA3U,EAAAjC,KAAA,GAAAY,MAEA,QAAAC,GAAAb,KAAAW,EAAA,EAAgCE,GAAA,IAAQA,EAAAoB,GAAA2U,EAAA3U,EAAAjC,KAAAa,IAAAD,CACxC,OAAAqB,GAGA,QAAAsf,IAAA/gB,GAEA,GAAAghB,GAAAhhB,EAAAmb,QACA,IAAA3b,KAAA2b,UAAA6F,GAAA,GAAAhhB,EAAA8b,SAAA,MAAAtI,GAAAoC,IAOA,KANA,GAAAqL,GAAAjhB,EAAA4gB,QACAzM,EAAA3U,KAAAohB,QACAnN,EAAA2B,EAAA,GACA1B,EAAA0B,EAAA,GACAnV,EAAAmV,EAAA,GACAgB,EAAAhB,EAAA,GACA,GAAA6L,EAAAnF,UACA,CACA,KAAAmF,EAAA9F,UAEA8F,EAAAnI,SAAA,EAAAmI,GACAD,GAEAvN,EAAA0H,UAAAzH,EAAAyH,WAEA1H,EAAAmL,MAAApf,KAAAiU,GACAC,EAAAmC,MAAA7V,EAAA0T,IAEAD,EAAAqF,SAAA,EAAArF,IAEAC,EAAAyH,UAAAzH,EAAAmC,MAAA7V,EAAA0T,GACAA,EAAAoF,SAAA,EAAApF,EAEA,MAAAS,EAAAgH,UAEAhH,EAAA2E,SAAA,EAAA3E,GACA6M,GAEA/gB,EAAAkb,UAAA/E,EAAA+E,WAEAlb,EAAA2e,MAAApf,KAAAS,GACAmW,EAAAP,MAAA7V,EAAAoW,IAEAnW,EAAA6Y,SAAA,EAAA7Y,IAEAmW,EAAA+E,UAAA/E,EAAAP,MAAA7V,EAAAoW,GACAA,EAAA0C,SAAA,EAAA1C,EAEA6K,GAAAvI,UAAAvE,IAAA,GAEA8M,EAAApL,MAAA1B,EAAA8M,GACAD,GAAAvN,EAAAoC,MAAA5V,EAAAwT,GACAC,EAAAmC,MAAAO,EAAA1C,KAIAS,EAAA0B,MAAAoL,EAAA9M,GACA6M,GAAA/gB,EAAA4V,MAAApC,EAAAxT,GACAmW,EAAAP,MAAAnC,EAAA0C,IAGA,UAAAjC,EAAAuE,UAAAlF,EAAAmF,KAAAnF,EAAAoC,KACAQ,EAAAsC,UAAA1Y,IAAA,EAAAoW,EAAA8K,SAAAlhB,GACAoW,EAAA0F,SAAA,GAAA1F,EAAAwI,MAAA5e,EAAAoW,GAEAA,EAAA0F,SAAA,EAAA1F,EAAA+K,IAAAnhB,GACAoW,GAFAA,EAOA,QAAAgL,IAAAjhB,GAEA,GAAAE,GAAAa,EAAA1B,KAAA6X,KACA,OAAAnW,EAAAf,GAAAe,EAAA,IAAAmgB,MAAAzgB,OAAA,GACA,CACA,IAAAP,EAAA,EAAiBA,EAAAghB,GAAAzgB,SAAsBP,EACvC,GAAAa,EAAA,IAAAmgB,GAAAhhB,GAAA,QACA,UAEA,GAAAa,EAAAia,SAAA,QAEA,KADA9a,EAAA,EACAA,EAAAghB,GAAAzgB,QACA,CAGA,IAFA,GAAAZ,GAAAqhB,GAAAhhB,GACA6T,EAAA7T,EAAA,EACA6T,EAAAmN,GAAAzgB,QAAAZ,EAAAshB,IAAAthB,GAAAqhB,GAAAnN,IAEA,KADAlU,EAAAkB,EAAAqgB,OAAAvhB,GACAK,EAAA6T,GACA,GAAAlU,EAAAqhB,GAAAhhB,MAAA,WAEA,MAAAa,GAAAsgB,YAAArhB,GAGA,QAAAshB,IAAAthB,GAEA,GAAAuhB,GAAAliB,KAAA0hB,SAAA1N,EAAAmF,KACArD,EAAAoM,EAAAb,iBACA,IAAAvL,GAAA,UACA,IAAA7T,GAAAigB,EAAAC,WAAArM,EACAnV,KAAA,KACAA,EAAAkhB,GAAAzgB,SAAAT,EAAAkhB,GAAAzgB,OAEA,QADA6S,GAAAO,IACA3T,EAAA,EAAmBA,EAAAF,IAAOE,EAC1B,CAEAoT,EAAAI,QAAAwN,GAAAtY,KAAAqL,MAAArL,KAAA6Y,SAAAP,GAAAzgB,SACA,IAAAQ,GAAAqS,EAAAoO,OAAApgB,EAAAjC,KACA,OAAA4B,EAAAsX,UAAAlF,EAAAmF,MAAA,GAAAvX,EAAAsX,UAAAgJ,GACA,CAEA,IADA,GAAAxN,GAAA,EACAA,IAAAoB,GAAA,GAAAlU,EAAAsX,UAAAgJ,IAGA,GADAtgB,IAAA0gB,UAAA,EAAAtiB,MACA,GAAA4B,EAAAsX,UAAAlF,EAAAmF,KAAA,QAEA,OAAAvX,EAAAsX,UAAAgJ,GAAA,UAGA,SA7kDA,GAAAK,KAAA,EAEAC,IAAA,EAEAC,IAAA,EAEAtO,MACAuO,IAAA,CACA,oBAAA7iB,MAAAD,SAEAC,EAAAD,QAAAuU,GACAuO,IAAA,IAKA5O,EAAA,GAAAC,EAAA,kBAAAD,KAAAvT,KAAAX,EAAAM,EAAAN,EAAAC,GAAAiU,IAAAzQ,SAAA0Q,IAAAlU,EAAAD,QAAAmU,IAEA,6BAAA4O,OAAAxO,cACAyO,KAAA,WAAAzO,GAEA,IAAA0O,GACA,IAAAH,GAMA,CACA,GAAAI,IAAA,QACAD,IAAA,eAPA,CACA,GAAAC,IAAAC,UAAAC,UAAAtM,WAAAjN,aACAoZ,IAAAE,UAAAE,QAQA,GAAAC,MACAJ,IAAA1a,QAAA,eAAA0a,GAAA1a,QAAA,gBAAA8a,GAAAC,OAAA,EACAD,GAAAC,OAAA,EACAL,GAAA1a,QAAA,gBAAA8a,GAAAE,SAAA,EACAF,GAAAE,SAAA,EACAN,GAAA1a,QAAA,eAAA0a,GAAA1a,QAAA,eAAA0a,GAAA1a,QAAA,gBAAA8a,GAAAG,OAAA,EACAH,GAAAG,OAAA,EACAP,GAAA1a,QAAA,eAAA8a,GAAAI,QAAA,EACAJ,GAAAI,QAAA,EACAR,GAAA1a,QAAA,kBAAA8a,GAAAK,UAAA,EACAL,GAAAK,UAAA,EACAT,GAAA1a,QAAA,kBAAA8a,GAAAM,UAAA,EACAN,GAAAM,UAAA,EACAV,GAAA1a,QAAA,iBAAA8a,GAAAO,SAAA,EACAP,GAAAO,SAAA,EACAX,GAAA1a,QAAA,aAAA8a,GAAAQ,MAAA,EACAR,GAAAQ,MAAA,EACAZ,GAAA1a,QAAA,eAAA8a,GAAAS,OAAA,EACAT,GAAAS,OAAA,EACAb,GAAA1a,QAAA,cAAA8a,GAAAU,MAAA,EACAV,GAAAU,MAAA,EACAd,GAAA1a,QAAA,cAAA8a,GAAAW,MAAA,EACAX,GAAAW,MAAA,EACAf,GAAA1a,QAAA,cAAA8a,GAAAY,MAAA,EACAZ,GAAAY,MAAA,EACAhB,GAAA1a,QAAA,aAAA8a,GAAAa,KAAA,EACAb,GAAAa,KAAA,EACA5P,GAAAC,gBAAA,IAOA,IAAA4P,IAEAC,GAAA,eACAC,GAAA,oBAAAD,GAuEAC,KAAA,+BAAArB,IAEA7O,EAAAvS,UAAAqW,GAAAjD,EACAmP,GAAA,IAEAE,IAAA,YAAArB,IAEA7O,EAAAvS,UAAAqW,GAAArD,EACAuP,GAAA,KAIAhQ,EAAAvS,UAAAqW,GAAA7C,EACA+O,GAAA,IAEAhQ,EAAAvS,UAAAyU,GAAA8N,GACAhQ,EAAAvS,UAAA8U,IAAA,GAAAyN,IAAA,EACAhQ,EAAAvS,UAAAkU,GAAA,GAAAqO,EACA,IAAAG,IAAA,EACAnQ,GAAAvS,UAAAsX,GAAAxP,KAAAkT,IAAA,EAAA0H,IACAnQ,EAAAvS,UAAAmX,GAAAuL,GAAAH,GACAhQ,EAAAvS,UAAAoX,GAAA,EAAAmL,GAAAG,EAEA,IAEAC,IAAAC,GAFAlP,GAAA,uCACAI,GAAA,GAAA8H,MAGA,KADA+G,GAAA,IAAA5O,WAAA,GACA6O,GAAA,EAAcA,IAAA,IAASA,GAAA9O,GAAA6O,MAAAC,EAEvB,KADAD,GAAA,IAAA5O,WAAA,GACA6O,GAAA,GAAeA,GAAA,KAASA,GAAA9O,GAAA6O,MAAAC,EAExB,KADAD,GAAA,IAAA5O,WAAA,GACA6O,GAAA,GAAeA,GAAA,KAASA,GAAA9O,GAAA6O,MAAAC,EAsbxB5K,GAAAhY,UAAA6Z,QAAA5B,EACAD,EAAAhY,UAAAga,OAAA7B,EACAH,EAAAhY,UAAAuY,OAAAH,EACAJ,EAAAhY,UAAA+Z,MAAA1B,EACAL,EAAAhY,UAAA8Z,MAAAtB,EAyFAG,EAAA3Y,UAAA6Z,QAAAX,EACAP,EAAA3Y,UAAAga,OAAAb,EACAR,EAAA3Y,UAAAuY,OAAAa,EACAT,EAAA3Y,UAAA+Z,MAAAR,EACAZ,EAAA3Y,UAAA8Z,MAAAR,EAqCA/G,EAAAvS,UAAA2W,OAAA3C,EACAzB,EAAAvS,UAAA4S,QAAAqB,EACA1B,EAAAvS,UAAA8S,WAAAsB,EACA7B,EAAAvS,UAAA0U,MAAAG,EACAtC,EAAAvS,UAAAwX,UAAA9B,EACAnD,EAAAvS,UAAA4X,UAAAjC,EACApD,EAAAvS,UAAA+W,SAAAnB,EACArD,EAAAvS,UAAA6X,SAAA5B,EACA1D,EAAAvS,UAAA4U,MAAAsB,EACA3D,EAAAvS,UAAAsY,WAAAnC,EACA5D,EAAAvS,UAAAyY,SAAAnC,EACA/D,EAAAvS,UAAA+X,SAAAxB,EACAhE,EAAAvS,UAAA6Y,SAAAH,EACAnG,EAAAvS,UAAAka,OAAAV,EACAjH,EAAAvS,UAAAma,IAAAV,EAEAlH,EAAAvS,UAAAiV,SAAAF,EACAxC,EAAAvS,UAAAgV,OAAAK,EACA9C,EAAAvS,UAAAoW,IAAAd,EACA/C,EAAAvS,UAAAyX,UAAAlC,EACAhD,EAAAvS,UAAA2b,UAAAlG,EACAlD,EAAAvS,UAAAkY,IAAAJ,EACAvF,EAAAvS,UAAA6gB,UAAA5G,EAEA1H,EAAAoC,KAAAR,EAAA,GACA5B,EAAAmF,IAAAvD,EAAA,GAyeAiK,GAAApe,UAAA6Z,QAAAwE,GACAD,GAAApe,UAAAga,OAAAqE,GACAD,GAAApe,UAAA+Z,MAAAuE,GACAF,GAAApe,UAAA8Z,MAAAyE,GAuFAI,GAAA3e,UAAA6Z,QAAAkF,GACAJ,GAAA3e,UAAAga,OAAAgF,GACAL,GAAA3e,UAAAuY,OAAA0G,GACAN,GAAA3e,UAAA+Z,MAAAsF,GACAV,GAAA3e,UAAA8Z,MAAAsF,EAkNA,IAAAgB,KAAA,ooBACAC,IAAA,OAAAD,MAAAzgB,OAAA,EAqDA4S,GAAAvS,UAAA+a,UAAAP,EACAjI,EAAAvS,UAAAkV,QAAA0F,GACArI,EAAAvS,UAAAsU,UAAA4G,GACA3I,EAAAvS,UAAA6S,WAAAwI,GACA9I,EAAAvS,UAAAub,UAAAW,GACA3J,EAAAvS,UAAAsd,UAAAF,GACA7K,EAAAvS,UAAA2d,MAAAF,GACAlL,EAAAvS,UAAAmb,UAAA+C,GACA3L,EAAAvS,UAAAob,WAAA+C,GACA5L,EAAAvS,UAAAmf,gBAAAV,GACAlM,EAAAvS,UAAAkf,gBAAAR,GACAnM,EAAAvS,UAAAsgB,OAAAT,GACAtN,EAAAvS,UAAAugB,YAAAC,GAEAjO,EAAAvS,UAAA2f,MAAAvF,EACA7H,EAAAvS,UAAAib,SAAAZ,EACA9H,EAAAvS,UAAA6iB,UAAAvI,EACA/H,EAAAvS,UAAA8iB,WAAAvI,EACAhI,EAAAvS,UAAA6a,OAAAF,EACApI,EAAAvS,UAAA+iB,YAAAjH,GACAvJ,EAAAvS,UAAAgjB,OAAAjH,GACAxJ,EAAAvS,UAAAsN,IAAA0O,GACAzJ,EAAAvS,UAAAuN,IAAA0O,GACA1J,EAAAvS,UAAAijB,IAAA3G,GACA/J,EAAAvS,UAAAkjB,GAAA3G,GACAhK,EAAAvS,UAAAmjB,IAAA1G,GACAlK,EAAAvS,UAAAojB,OAAAzG,GACApK,EAAAvS,UAAAqjB,IAAAzG,GACArK,EAAAvS,UAAAwb,UAAAqB,GACAtK,EAAAvS,UAAA0gB,WAAA5D,GACAvK,EAAAvS,UAAA4f,gBAAA5C,GACAzK,EAAAvS,UAAAsjB,SAAApG,GACA3K,EAAAvS,UAAAsb,QAAA6B,GACA5K,EAAAvS,UAAAujB,OAAAlG,GACA9K,EAAAvS,UAAAwjB,SAAAjG,GACAhL,EAAAvS,UAAAyjB,QAAAjG,GACAjL,EAAAvS,UAAAkgB,IAAAxC,GACAnL,EAAAvS,UAAAigB,SAAArC,GACArL,EAAAvS,UAAA0jB,SAAA7F,GACAtL,EAAAvS,UAAA8e,OAAAf,GACAxL,EAAAvS,UAAA2jB,UAAA3F,GACAzL,EAAAvS,UAAA4jB,mBAAA3F,GACA1L,EAAAvS,UAAA4gB,OAAAtB,GACA/M,EAAAvS,UAAA6jB,WAAA/D,GACAvN,EAAAvS,UAAAgb,IAAAwD,GACAjM,EAAAvS,UAAA8jB,IAAApE,GACAnN,EAAAvS,UAAA0b,gBAAAyE,GAEA5N,EAAAvS,UAAA+jB,OAAAjG,EACA,IAAAkG,IAAAzR,CAUAyR,IAAAhkB,UAAAikB,WAAA,WAEA,MAAA1lB,MAAAkZ,UAAAuM,GAAArP,QAAA,GAGAqP,GAAAE,YAAA,SAAAC,EAAAC,GAEA,UAAAD,EAAA1M,UAAA2M,IAGAJ,GAAAK,cAAA,SAAAF,EAAAC,GAEA,UAAAD,EAAA1M,UAAA2M,IAGAJ,GAAAM,eAAA,SAAAH,EAAAC,GAEA,MAAAD,GAAA1M,UAAA2M,GAAA,GAGAJ,GAAAO,YAAA,SAAAJ,EAAAC,GAEA,MAAAD,GAAA1M,UAAA2M,GAAA,GAGAJ,GAAAQ,YAAA,SAAAC,EAAAC,GAEA,UAAAV,IAAAS,GAAAvE,IAAA,GAAA8D,IAAAU,KAEAV,GAAAW,eAAA,SAAAF,EAAAC,GAEA,UAAAV,IAAAS,GAAAxE,SAAA,GAAA+D,IAAAU,KAEAV,GAAAY,UAAA,SAAAH,EAAAC,GAEA,UAAAV,IAAAS,GAAAf,SAAA,GAAAM,IAAAU,KAEAV,GAAAa,YAAA,SAAAJ,EAAAC,GAEA,MAAAD,GAAA3F,OAAA4F,IAEAV,GAAAhkB,UAAA8kB,SAAA,WAEA,MAAA5kB,YAAA3B,KAAA0W,YAaA,IAAA8P,IAAA,SAAAC,EAAAC,GAEA,GAAAhmB,EACA,uBAAAO,QAAA,oBACA,CACA,IAAAP,IAAAgmB,GAAAjlB,UACA,mBAAAglB,GAAAhlB,UAAAf,IAAA+lB,EAAAhlB,UAAAf,IAAAO,OAAAQ,UAAAf,KAAA+lB,EAAAhlB,UAAAf,GAAAgmB,EAAAjlB,UAAAf,GACA,KAAAA,IAAAgmB,GACA,mBAAAD,GAAA/lB,KAAA+lB,EAAA/lB,GAAAgmB,EAAAhmB,GACA+lB,GAAAE,UAAAD,MAGA,CAEA,OADAjjB,GAAAxC,OAAA2lB,oBAAAF,EAAAjlB,WACAZ,EAAA,EAAkBA,EAAA4C,EAAArC,OAAkBP,IACpC,mBAAAI,QAAA4lB,yBAAAJ,EAAAhlB,UAAAgC,EAAA5C,KAAAI,OAAAC,eAAAulB,EAAAhlB,UAAAgC,EAAA5C,GAAAI,OAAA4lB,yBAAAH,EAAAjlB,UAAAgC,EAAA5C,IACA,KAAAH,IAAAgmB,GACA,mBAAAD,GAAA/lB,KAAA+lB,EAAA/lB,GAAAgmB,EAAAhmB,GACA+lB,GAAAE,UAAAD,GAGAvS,IAAArR,KAAA,WAEA,UAEAqR,GAAA2S,MAAA,WAEA,UAIA3S,GAAA4S,YAAA,WAEA,GAAA9S,GAAA5R,SACArC,MAAAsC,EAAA,EACAtC,KAAAwC,EAAA,EAGA,GAAAyR,EAAA7S,QAEApB,KAAAsC,EAAA2R,EAAA,GAAA3R,EACAtC,KAAAwC,EAAAyR,EAAA,GAAAzR,GAEA,GAAAyR,EAAA7S,SAEApB,KAAAsC,EAAA2R,EAAA,GACAjU,KAAAwC,EAAAyR,EAAA,KAGAE,GAAA6S,aAAA,WAEAhnB,KAAAsC,EAAA,EACAtC,KAAAwC,EAAA,GAGA2R,GAAA8S,aAAA,SAAAC,GAEAlnB,KAAAsC,EAAA4kB,EAAA5kB,EACAtC,KAAAwC,EAAA0kB,EAAA1kB,GAGA2R,GAAAgT,aAAA,SAAAzlB,EAAAE,GAEA5B,KAAAsC,EAAAZ,EACA1B,KAAAwC,EAAAZ,GAIAuS,GAAAiT,SAAA,WAEApnB,KAAAqnB,SAAA,KACArnB,KAAAsnB,UAAA,GAAAnT,IAAArR,KACA9C,KAAAunB,QAAA,EACAvnB,KAAAwnB,WAAA,EACAxnB,KAAAynB,UAAA,EACAznB,KAAA0nB,YACA1nB,KAAA2nB,QAAA,GAEAxT,GAAAiT,SAAA3lB,UAAAmmB,WAAA,WAIA,IAFA,GAAAxgB,IAAA,EACAygB,EAAA7nB,KAAAqnB,SACA,OAAAQ,GAEAzgB,KACAygB,IAAAR,QAEA,OAAAjgB,IAEA+M,GAAAiT,SAAA3lB,UAAAqmB,WAAA,WAEA,MAAA9nB,MAAA0nB,SAAAtmB,QAEA+S,GAAAiT,SAAA3lB,UAAAsmB,QAAA,WAEA,MAAA/nB,MAAAsnB,WAEAnT,GAAAiT,SAAA3lB,UAAAumB,SAAA,SAAAC,GAEA,GAAAC,GAAAloB,KAAA0nB,SAAAtmB,MACApB,MAAA0nB,SAAAtlB,KAAA6lB,GACAA,EAAAZ,SAAArnB,KACAioB,EAAAV,QAAAW,GAEA/T,GAAAiT,SAAA3lB,UAAA0mB,QAAA,WAEA,MAAAnoB,MAAA0nB,SAAAtmB,OAAA,EACApB,KAAA0nB,SAAA,GAEA1nB,KAAAooB,oBAEAjU,GAAAiT,SAAA3lB,UAAA2mB,iBAAA,WAEA,cAAApoB,KAAAqnB,SACA,KACArnB,KAAAunB,SAAAvnB,KAAAqnB,SAAAK,SAAAtmB,OAAA,EACApB,KAAAqnB,SAAAe,mBAEApoB,KAAAqnB,SAAAK,SAAA1nB,KAAAunB,QAAA,IAEApT,GAAAiT,SAAA3lB,UAAA4mB,OAAA,WAEA,MAAAroB,MAAA0nB,UAEAvT,GAAAiT,SAAA3lB,UAAA6mB,OAAA,WAEA,MAAAtoB,MAAAqnB,UAEAlT,GAAAiT,SAAA3lB,UAAA8mB,OAAA,WAEA,MAAAvoB,MAAA4nB,cAGAzT,GAAAzI,SAAA,WAEA1L,KAAAwoB,cACArU,GAAAiT,SAAA7mB,KAAAP,OAEAmU,GAAAzI,SAAAjK,UAAAgL,MAAA,WAEA,OAAA5L,GAAA,EAAA4nB,EAAAzoB,KAAAwoB,WAAApnB,OAAkDP,EAAA4nB,EAAU5nB,IAC5Db,KAAAwoB,WAAA3nB,GAAA,IACAb,MAAAwoB,WAAApnB,OAAA,EACApB,KAAA0nB,SAAAtmB,OAAA,GAEA+S,GAAAzI,SAAAjK,UAAAinB,SAAA,WAEA,MAAA1oB,MAAA0nB,SAAAtmB,OAAA,EACApB,KAAA0nB,SAAA,GAEA,MAEAvT,GAAAzI,SAAAjK,UAAAknB,MAAA,WAEA,GAAAvhB,GAAApH,KAAAwoB,WAAApnB,MAGA,OADAgG,GAAA,GAAApH,KAAA0nB,SAAA,IAAA1nB,KAAAwoB,WAAA,IAAAphB,IACAA,GAEAof,GAAArS,GAAAzI,SAAAyI,GAAAiT,UAGAjT,GAAAyU,eAAAzU,GAAA0U,eAAA1U,GAAA2U,gBAAA,SAAA7U,GAEA,MAAA1K,MAAAsO,IAAA5D,IAEAE,GAAA4U,qBAAA,SAAA9U,EAAAC,GAEA,MAAA3K,MAAAyF,IAAAiF,EAAAC,IAOAgP,GAAAa,MAAAb,GAAAQ,OAAAR,GAAAG,OAAAlP,GAAA6U,WAAA,SAAA/U,GAEA,SAAAA,GAEAE,GAAA6U,WAAA,SAAA/U,GAEA,QAAAA,GAgBAiP,GAAAC,OAAAhP,GAAA8U,WAAA,SAAAhV,GAEA,MAAAA,IAAA,YAAAA,EAAA,WACAA,EAAA,EAAA1K,KAAA2f,KAAAjV,GAAA1K,KAAAqL,MAAAX,KACAA,GAEAiP,GAAAI,SAAA,kBAAA6F,QAAA,UAAAhV,GAAA8U,WAAA,SAAAhV,GAEA,MAAAkV,QAAAC,UAAAnV,IAEAiP,GAAAY,OAAAZ,GAAAW,MAAA1P,GAAA8U,WAAA,SAAAhV,GAEA,MAAA1R,UAAA0R,EAAA,KAEAiP,GAAAa,KAAA5P,GAAA8U,WAAA,SAAAhV,GAEA,MAAAA,IAAA,YAAAA,EAAA,WACAA,EAAA,EAAA1K,KAAA2f,KAAAjV,GAAA1K,KAAAqL,MAAAX,GACA,EAAAA,GAGAE,GAAA8U,WAAA,SAAAhV,GAEA,MAAAA,GAAA,EAAA1K,KAAA2f,KAAAjV,GAAA1K,KAAAqL,MAAAX,IAEAE,GAAA1H,MAAA,SAAAwH,GAEAA,EAAA7S,OAAA,GAGA+S,GAAA3K,GAAA,kBACA2K,GAAAkV,IAAA,kBACAlV,GAAAmV,SAAA,WAEA,GAAArV,GAAA5R,UACAknB,EAAAtV,EAAA7S,MAGA,IAFApB,KAAAsC,EAAA,EACAtC,KAAAwC,EAAA,EACAggB,GAGA,GADAxiB,KAAAwpB,EAAA,EACA,GAAAD,EAEAvpB,KAAAsC,EAAA2R,EAAA,GACAjU,KAAAwC,EAAAyR,EAAA,GACAjU,KAAAwpB,EAAAvV,EAAA,OAEA,OAAAsV,EAEAvpB,KAAAsC,EAAA2R,EAAA,GACAjU,KAAAwC,EAAAyR,EAAA,GACAjU,KAAAwpB,EAAA,MAEA,OAAAD,EAEA,GAAAtV,EAAA,YAAAE,IAAA4S,YACA,CACA,GAAAG,GAAAjT,EAAA,EACAjU,MAAAsC,EAAA6R,GAAAvI,QAAA6d,MAAAvC,EAAA5kB,GACAtC,KAAAwC,EAAA2R,GAAAvI,QAAA6d,MAAAvC,EAAA1kB,GACAxC,KAAAwpB,EAAA,MAGA,CACA,GAAArR,GAAAlE,EAAA,EACA,oBAAAkE,GAAA,IAAAA,EAAAqR,EAAA,GACAxpB,KAAAsC,EAAA6V,EAAA7V,EACAtC,KAAAwC,EAAA2V,EAAA3V,EACAxC,KAAAwpB,EAAArR,EAAAqR,MAKAxpB,MAAAsC,EAAA,EACAtC,KAAAwC,EAAA,EACAxC,KAAAwpB,EAAA,MAKA,OAAAD,EAEAvpB,KAAAsC,EAAA2R,EAAA,GACAjU,KAAAwC,EAAAyR,EAAA,OAEA,OAAAsV,EAEA,GAAAtV,EAAA,YAAAE,IAAA4S,YACA,CACA,GAAAG,GAAAjT,EAAA,EACAjU,MAAAsC,EAAA6R,GAAAvI,QAAA6d,MAAAvC,EAAA5kB,GACAtC,KAAAwC,EAAA2R,GAAAvI,QAAA6d,MAAAvC,EAAA1kB,OAGA,CACA,GAAA2V,GAAAlE,EAAA,EACAjU,MAAAsC,EAAA6V,EAAA7V,EACAtC,KAAAwC,EAAA2V,EAAA3V,MAKAxC,MAAAsC,EAAA,EACAtC,KAAAwC,EAAA,GAIA2R,GAAAmV,SAAA3D,YAAA,SAAA1R,EAAAC,GAGA,MAAAD,GAAA3R,GAAA4R,EAAA5R,GAAA2R,EAAAzR,GAAA0R,EAAA1R,GAEA2R,GAAAmV,SAAAxD,cAAA,SAAA7R,EAAAC,GAGA,MAAAD,GAAA3R,GAAA4R,EAAA5R,GAAA2R,EAAAzR,GAAA0R,EAAA1R,GAgBAggB,IAEArO,GAAAuV,UAAA,WAEA1pB,KAAAsC,EAAA,EACAtC,KAAAwC,EAAA,EACAxC,KAAAwpB,EAAA,GAEArV,GAAAwV,UAAA,SAAAxR,GAEAnY,KAAAsC,EAAA6V,EAAA7V,EACAtC,KAAAwC,EAAA2V,EAAA3V,EACAxC,KAAAwpB,EAAArR,EAAAqR,GAEArV,GAAAyV,YAAA,SAAA1C,GAEAlnB,KAAAsC,EAAA6R,GAAAvI,QAAA6d,MAAAvC,EAAA5kB,GACAtC,KAAAwC,EAAA2R,GAAAvI,QAAA6d,MAAAvC,EAAA1kB,GACAxC,KAAAwpB,EAAA,GAEArV,GAAA0V,UAAA,SAAAnoB,EAAAE,GAEA5B,KAAAsC,EAAAZ,EACA1B,KAAAwC,EAAAZ,EACA5B,KAAAwpB,EAAA,GAEArV,GAAA2V,UAAA,SAAApoB,EAAAE,EAAAuZ,GAEAnb,KAAAsC,EAAAZ,EACA1B,KAAAwC,EAAAZ,EACA5B,KAAAwpB,EAAArO,KAKAhH,GAAAuV,UAAA,WAEA1pB,KAAAsC,EAAA,EACAtC,KAAAwC,EAAA,GAEA2R,GAAAwV,UAAA,SAAAxR,GAEAnY,KAAAsC,EAAA6V,EAAA7V,EACAtC,KAAAwC,EAAA2V,EAAA3V,GAEA2R,GAAAyV,YAAA,SAAA1C,GAEAlnB,KAAAsC,EAAA6R,GAAAvI,QAAA6d,MAAAvC,EAAA5kB,GACAtC,KAAAwC,EAAA2R,GAAAvI,QAAA6d,MAAAvC,EAAA1kB,IAEA2R,GAAA0V,UAAA,SAAAnoB,EAAAE,GAEA5B,KAAAsC,EAAAZ,EACA1B,KAAAwC,EAAAZ,IAGAuS,GAAA4V,QAAA,WAEA,GAAA9V,GAAA5R,UACAknB,EAAAtV,EAAA7S,MACA,IAAAmoB,GAEAvpB,KAAAgqB,KAAA/V,EAAA,GACAjU,KAAAiqB,IAAAhW,EAAA,GACAjU,KAAAkqB,MAAAjW,EAAA,GACAjU,KAAAmqB,OAAAlW,EAAA,IAEA,GAAAsV,GAEAvpB,KAAAgqB,KAAAI,GAAAJ,KACAhqB,KAAAiqB,IAAAG,GAAAH,IACAjqB,KAAAkqB,MAAAE,GAAAF,MACAlqB,KAAAmqB,OAAAC,GAAAD,SAIAnqB,KAAAgqB,KAAA,EACAhqB,KAAAiqB,IAAA,EACAjqB,KAAAkqB,MAAA,EACAlqB,KAAAmqB,OAAA,IAGAhW,GAAAkW,SAAA,WAEArqB,KAAAgqB,KAAA,EACAhqB,KAAAiqB,IAAA,EACAjqB,KAAAkqB,MAAA,EACAlqB,KAAAmqB,OAAA,GAEAhW,GAAAmW,SAAA,SAAAF,GAEApqB,KAAAgqB,KAAAI,EAAAJ,KACAhqB,KAAAiqB,IAAAG,EAAAH,IACAjqB,KAAAkqB,MAAAE,EAAAF,MACAlqB,KAAAmqB,OAAAC,EAAAD,QAEAhW,GAAAoW,SAAA,SAAAvV,EAAArU,EAAAsB,EAAAiS,GAEAlU,KAAAgqB,KAAAhV,EACAhV,KAAAiqB,IAAAtpB,EACAX,KAAAkqB,MAAAjoB,EACAjC,KAAAmqB,OAAAjW,GAEAC,GAAA/H,UACAoe,eAAA,EACAne,QAAA,EACAoe,aAAA,EACAC,MAAA,GAEAvW,GAAAlI,UACAC,UAAA,EACAye,OAAA,GAEAxW,GAAA7I,cACAE,WAAA,EACAD,WAAA,EACAqf,YAAA,EACAC,YAAA,GAEA1W,GAAA2W,UACAC,SAAA,EACAC,QAAA,EACAC,QAAA,GAEA9W,GAAA+W,SACAC,aAAA,EACAC,YAAA,EACAC,WAAA,EACAC,aAAA,EACAC,gBAAA,GAEApX,GAAAqX,UACAC,OAAA,EACAC,QAAA,GAEAvX,GAAAwX,WACAC,aAAA,EACAC,aAAA,GAEA1X,GAAA2X,MAAA,WAEA9rB,KAAA+rB,IAAA,GAAA5X,IAAAmV,SACAtpB,KAAAgsB,KAAA,GAAA7X,IAAAmV,SACAtpB,KAAAisB,IAAA,GAAA9X,IAAAmV,SACAtpB,KAAAksB,MAAA,GAAA/X,IAAAmV,SACAtpB,KAAAmsB,GAAA,EACAnsB,KAAAosB,QAAAjY,GAAAlI,SAAAC,UACAlM,KAAAqsB,KAAAlY,GAAAqX,SAAAC,OACAzrB,KAAAssB,UAAA,EACAtsB,KAAAusB,QAAA,EACAvsB,KAAAwsB,SAAA,EACAxsB,KAAAysB,OAAA,EACAzsB,KAAA0sB,KAAA,KACA1sB,KAAA2sB,KAAA,KACA3sB,KAAA4sB,UAAA,KACA5sB,KAAA6sB,UAAA,KACA7sB,KAAA8sB,UAAA,KACA9sB,KAAA+sB,UAAA,KACA/sB,KAAAgtB,UAAA,MAEA7Y,GAAA8Y,cAAA,WAEAjtB,KAAAktB,MAAA,KACAltB,KAAAmtB,MAAA,KACAntB,KAAAotB,GAAA,GAAAjZ,IAAAmV,UAEAnV,GAAAkZ,oBAAA,aACAlZ,GAAAkZ,oBAAAC,QAAA,SAAAC,EAAAC,GAEA,GAAA3sB,GAAA2sB,EAAAJ,GAAA5qB,EAAA+qB,EAAAH,GAAA5qB,CACA,OAAA3B,GAAA,IACAA,EAAA,KACA,GAGAsT,GAAAsZ,YAAA,WAEAztB,KAAAwC,EAAA,EACAxC,KAAA0tB,UAAA,KACA1tB,KAAA2tB,WAAA,KACA3tB,KAAA0sB,KAAA,MAEAvY,GAAAyZ,SAAA,WAEA5tB,KAAAwC,EAAA,EACAxC,KAAA0sB,KAAA,MAEAvY,GAAA0Z,OAAA,WAEA7tB,KAAA8tB,IAAA,EACA9tB,KAAAuoB,QAAA,EACAvoB,KAAA2nB,QAAA,EACA3nB,KAAA+tB,UAAA,KACA/tB,KAAAguB,IAAA,KACAhuB,KAAAiuB,SAAA,KACAjuB,KAAAonB,SAAA,MAEAjT,GAAA+Z,MAAA,WAEAluB,KAAA8tB,IAAA,EACA9tB,KAAAotB,GAAA,GAAAjZ,IAAAmV,SACAtpB,KAAA0sB,KAAA,KACA1sB,KAAA2sB,KAAA,MAEAxY,GAAAga,KAAA,WAEAnuB,KAAAouB,OAAA,KACApuB,KAAAquB,OAAA,KACAruB,KAAAsuB,MAAA,GAAAna,IAAAmV,UAEAnV,GAAAoa,YAAA,WAEAvuB,KAAAwuB,aAAA,KACAxuB,KAAAyuB,YAAA,KACAzuB,KAAA0uB,QAAA,GAAArR,OACArd,KAAA2uB,gBAAA,EACA3uB,KAAA4uB,gBAAA,EACA5uB,KAAA6uB,mBAAA,EACA7uB,KAAAwuB,aAAA,KACAxuB,KAAAyuB,YAAA,KACAzuB,KAAA2uB,gBAAA,EACA3uB,KAAA4uB,gBAAA,GASAza,GAAAoa,YAAAO,YAAA,iBACA3a,GAAAoa,YAAAQ,MAAA,EACA5a,GAAAoa,YAAAS,YAAA,EACA7a,GAAAoa,YAAAU,UAAA,MACA1M,IAEApO,GAAAoa,YAAAW,QAAA,MACA/a,GAAAoa,YAAAY,QAAA,QAIAhb,GAAAoa,YAAAW,QAAA,SACA/a,GAAAoa,YAAAY,QAAA,iBAGAhb,GAAAoa,YAAAa,UAAA,SAAAC,GAEA,MAAAA,IAAAlb,GAAAoa,YAAAU,WAAAI,EAAAlb,GAAAoa,YAAAU,WAEA9a,GAAAoa,YAAAe,aAAA,SAAAxuB,GAEA,WAAAA,EAAAorB,MAAA1pB,GAEA2R,GAAAoa,YAAA9sB,UAAA8tB,cAAA,SAAApX,EAAAqX,GAEA,GAAAC,GAAAD,CACA,IACA,GAAArb,GAAAmV,SAAA3D,YAAA8J,EAAArC,GAAAjV,GACA,QACAsX,KAAA/C,WAEA+C,GAAAD,EACA,WAEArb,GAAAoa,YAAA9sB,UAAAiuB,mBAAA,SAAAvX,EAAAwX,EAAAC,EAAAC,GAEA,MAAAA,GACA1X,EAAA7V,GAAAqtB,EAAArtB,GAAA6V,EAAA3V,GAAAmtB,EAAAntB,GACA2V,EAAA7V,GAAAstB,EAAAttB,GAAA6V,EAAA3V,GAAAotB,EAAAptB,GACA2V,EAAA7V,EAAAqtB,EAAArtB,GAAA6V,EAAA7V,EAAAstB,EAAAttB,GACA6V,EAAA3V,EAAAmtB,EAAAntB,GAAA2V,EAAA3V,EAAAotB,EAAAptB,GACAijB,GAAAE,YAAAF,GAAAY,UAAAlO,EAAA7V,EAAAqtB,EAAArtB,EAAAstB,EAAAptB,EAAAmtB,EAAAntB,GACAijB,GAAAY,UAAAuJ,EAAAttB,EAAAqtB,EAAArtB,EAAA6V,EAAA3V,EAAAmtB,EAAAntB,IAEA2V,EAAA7V,GAAAqtB,EAAArtB,GAAA6V,EAAA3V,GAAAmtB,EAAAntB,GAAA2V,EAAA7V,GAAAstB,EAAAttB,GAAA6V,EAAA3V,GAAAotB,EAAAptB,GAAA2V,EAAA7V,EAAAqtB,EAAArtB,GAAA6V,EAAA7V,EAAAstB,EAAAttB,GAAA6V,EAAA3V,EAAAmtB,EAAAntB,GAAA2V,EAAA3V,EAAAotB,EAAAptB,IAAA2V,EAAA7V,EAAAqtB,EAAArtB,IAAAstB,EAAAptB,EAAAmtB,EAAAntB,KAAAotB,EAAAttB,EAAAqtB,EAAArtB,IAAA6V,EAAA3V,EAAAmtB,EAAAntB,IAEA2R,GAAAoa,YAAA9sB,UAAAquB,eAAA,SAAA3X,EAAAqX,EAAAK,GAGA,IADA,GAAAJ,GAAAD,IAEA,CACA,GAAAxvB,KAAA0vB,mBAAAvX,EAAAsX,EAAArC,GAAAqC,EAAA/C,KAAAU,GAAAyC,GACA,QAEA,IADAJ,IAAA/C,KACA+C,GAAAD,EACA,MAEA,UAEArb,GAAAoa,YAAA9sB,UAAAsuB,YAAA5b,GAAAoa,YAAAwB,YAAA,WAEA,GAEAC,GAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAR,EAFA5b,EAAA5R,UACAknB,EAAAtV,EAAA7S,MAEA,WAAAmoB,GAEAyG,EAAA/b,EAAA,GACAgc,EAAAhc,EAAA,GACA4b,EAAA5b,EAAA,GACA4b,EACApK,GAAAE,YAAAF,GAAAY,UAAA2J,EAAA9D,MAAA1pB,EAAAytB,EAAA/D,MAAA5pB,GAAAmjB,GAAAY,UAAA2J,EAAA9D,MAAA5pB,EAAA2tB,EAAA/D,MAAA1pB,IAEA2R,GAAA8U,WAAA+G,EAAA9D,MAAA,EAAA+D,EAAA/D,MAAA,IAAA/X,GAAA8U,WAAA+G,EAAA9D,MAAA,EAAA+D,EAAA/D,MAAA,IAEA,GAAA3C,GAEA2G,EAAAjc,EAAA,GACAkc,EAAAlc,EAAA,GACAmc,EAAAnc,EAAA,GACA4b,EAAA5b,EAAA,GACA4b,EACApK,GAAAE,YAAAF,GAAAY,UAAA6J,EAAA1tB,EAAA2tB,EAAA3tB,EAAA2tB,EAAA7tB,EAAA8tB,EAAA9tB,GAAAmjB,GAAAY,UAAA6J,EAAA5tB,EAAA6tB,EAAA7tB,EAAA6tB,EAAA3tB,EAAA4tB,EAAA5tB,IAEA2R,GAAA8U,YAAAiH,EAAA1tB,EAAA2tB,EAAA3tB,IAAA2tB,EAAA7tB,EAAA8tB,EAAA9tB,IAAA6R,GAAA8U,YAAAiH,EAAA5tB,EAAA6tB,EAAA7tB,IAAA6tB,EAAA3tB,EAAA4tB,EAAA5tB,MAAA,IAIA0tB,EAAAjc,EAAA,GACAkc,EAAAlc,EAAA,GACAmc,EAAAnc,EAAA,GACAoc,EAAApc,EAAA,GACA4b,EAAA5b,EAAA,GACA4b,EACApK,GAAAE,YAAAF,GAAAY,UAAA6J,EAAA1tB,EAAA2tB,EAAA3tB,EAAA4tB,EAAA9tB,EAAA+tB,EAAA/tB,GAAAmjB,GAAAY,UAAA6J,EAAA5tB,EAAA6tB,EAAA7tB,EAAA8tB,EAAA5tB,EAAA6tB,EAAA7tB,IAEA2R,GAAA8U,YAAAiH,EAAA1tB,EAAA2tB,EAAA3tB,IAAA4tB,EAAA9tB,EAAA+tB,EAAA/tB,IAAA6R,GAAA8U,YAAAiH,EAAA5tB,EAAA6tB,EAAA7tB,IAAA8tB,EAAA5tB,EAAA6tB,EAAA7tB,MAAA,IAGA2R,GAAAoa,YAAA+B,aAAA,SAAAN,EAAAC,EAAAJ,GAEA,MAAAA,GACApK,GAAAE,YAAAF,GAAAY,UAAA2J,EAAA9D,MAAA1pB,EAAAytB,EAAA/D,MAAA5pB,GAAAmjB,GAAAY,UAAA2J,EAAA9D,MAAA5pB,EAAA2tB,EAAA/D,MAAA1pB,IAEA2R,GAAA8U,WAAA+G,EAAA9D,MAAA,EAAA+D,EAAA/D,MAAA,IAAA/X,GAAA8U,WAAA+G,EAAA9D,MAAA,EAAA+D,EAAA/D,MAAA,IAEA/X,GAAAoa,YAAAgC,aAAA,SAAAL,EAAAC,EAAAC,EAAAP,GAEA,MAAAA,GACApK,GAAAE,YAAAF,GAAAY,UAAA6J,EAAA1tB,EAAA2tB,EAAA3tB,EAAA2tB,EAAA7tB,EAAA8tB,EAAA9tB,GAAAmjB,GAAAY,UAAA6J,EAAA5tB,EAAA6tB,EAAA7tB,EAAA6tB,EAAA3tB,EAAA4tB,EAAA5tB,IAEA2R,GAAA8U,YAAAiH,EAAA1tB,EAAA2tB,EAAA3tB,IAAA2tB,EAAA7tB,EAAA8tB,EAAA9tB,IAAA6R,GAAA8U,YAAAiH,EAAA5tB,EAAA6tB,EAAA7tB,IAAA6tB,EAAA3tB,EAAA4tB,EAAA5tB,MAAA,GAEA2R,GAAAoa,YAAAiC,aAAA,SAAAN,EAAAC,EAAAC,EAAAC,EAAAR,GAEA,MAAAA,GACApK,GAAAE,YAAAF,GAAAY,UAAA6J,EAAA1tB,EAAA2tB,EAAA3tB,EAAA4tB,EAAA9tB,EAAA+tB,EAAA/tB,GAAAmjB,GAAAY,UAAA6J,EAAA5tB,EAAA6tB,EAAA7tB,EAAA8tB,EAAA5tB,EAAA6tB,EAAA7tB,IAEA2R,GAAA8U,YAAAiH,EAAA1tB,EAAA2tB,EAAA3tB,IAAA4tB,EAAA9tB,EAAA+tB,EAAA/tB,IAAA6R,GAAA8U,YAAAiH,EAAA5tB,EAAA6tB,EAAA7tB,IAAA8tB,EAAA5tB,EAAA6tB,EAAA7tB,MAAA,GAEA2R,GAAAoa,YAAA9sB,UAAAgL,MAAA,WAEAzM,KAAAywB,wBACA,QAAA5vB,GAAA,EAAA4nB,EAAAzoB,KAAA0uB,QAAAttB,OAA+CP,EAAA4nB,IAAU5nB,EACzD,CACA,OAAA6T,GAAA,EAAAgc,EAAA1wB,KAAA0uB,QAAA7tB,GAAAO,OAAoDsT,EAAAgc,IAAUhc,EAC9D1U,KAAA0uB,QAAA7tB,GAAA6T,GAAA,IACAP,IAAA1H,MAAAzM,KAAA0uB,QAAA7tB,IAEAsT,GAAA1H,MAAAzM,KAAA0uB,SACA1uB,KAAA2uB,gBAAA,EACA3uB,KAAA4uB,gBAAA,GAEAza,GAAAoa,YAAA9sB,UAAAgvB,uBAAA,WAEA,YAAAzwB,KAAAwuB,cACA,CACA,GAAAmC,GAAA3wB,KAAAwuB,aAAA9B,IACA1sB,MAAAwuB,aAAA,KACAxuB,KAAAwuB,aAAAmC,EAEA3wB,KAAAyuB,YAAA,MAEAta,GAAAoa,YAAA9sB,UAAAmvB,UAAA,SAAAxD,EAAAyD,GAEAA,EAAAC,OAEA1D,EAAA9qB,EAAA6R,GAAAoa,YAAAY,SAAA/B,EAAA5qB,EAAA2R,GAAAoa,YAAAY,UAAA/B,EAAA9qB,EAAA6R,GAAAoa,YAAAY,UAAA/B,EAAA5qB,EAAA2R,GAAAoa,YAAAY,UACAhb,GAAAnS,MAAA,qDAEAorB,EAAA9qB,EAAA6R,GAAAoa,YAAAW,SAAA9B,EAAA5qB,EAAA2R,GAAAoa,YAAAW,UAAA9B,EAAA9qB,EAAA6R,GAAAoa,YAAAW,UAAA9B,EAAA5qB,EAAA2R,GAAAoa,YAAAW,WAEA2B,EAAAC,OAAA,EACA9wB,KAAA4wB,UAAAxD,EAAAyD,KAGA1c,GAAAoa,YAAA9sB,UAAAsvB,SAAA,SAAAjwB,EAAAkwB,EAAAC,EAAA9Y,GAEArX,EAAA4rB,KAAAsE,EACAlwB,EAAA6rB,KAAAsE,EAEAnwB,EAAAkrB,KAAA1pB,EAAA6V,EAAA7V,EACAxB,EAAAkrB,KAAAxpB,EAAA2V,EAAA3V,EACA1B,EAAA2rB,QAAA,GAEAtY,GAAAoa,YAAA9sB,UAAAyvB,UAAA,SAAApwB,EAAAqwB,GAEArwB,EAAAkrB,KAAAxpB,GAAA1B,EAAA4rB,KAAAV,KAAAxpB,GAGA1B,EAAAirB,IAAAzpB,EAAAxB,EAAAkrB,KAAA1pB,EACAxB,EAAAirB,IAAAvpB,EAAA1B,EAAAkrB,KAAAxpB,EAEA1B,EAAAmrB,IAAA3pB,EAAAxB,EAAA4rB,KAAAV,KAAA1pB,EACAxB,EAAAmrB,IAAAzpB,EAAA1B,EAAA4rB,KAAAV,KAAAxpB,IAKA1B,EAAAmrB,IAAA3pB,EAAAxB,EAAAkrB,KAAA1pB,EACAxB,EAAAmrB,IAAAzpB,EAAA1B,EAAAkrB,KAAAxpB,EAEA1B,EAAAirB,IAAAzpB,EAAAxB,EAAA4rB,KAAAV,KAAA1pB,EACAxB,EAAAirB,IAAAvpB,EAAA1B,EAAA4rB,KAAAV,KAAAxpB,GAEAxC,KAAAoxB,MAAAtwB,GACAA,EAAAsrB,QAAA+E,GAEAhd,GAAAoa,YAAA9sB,UAAA4vB,eAAA,SAAAC,GAGA,IADA,GAAAC,KAEA,CACA,KAAApd,GAAAmV,SAAAxD,cAAAwL,EAAAvF,IAAAuF,EAAA3E,KAAAZ,MAAA5X,GAAAmV,SAAA3D,YAAA2L,EAAAtF,KAAAsF,EAAArF,MACAqF,IAAA5E,IACA,IAAA4E,EAAAnF,IAAAhY,GAAAoa,YAAAO,YAAAwC,EAAA3E,KAAAR,IAAAhY,GAAAoa,YAAAO,WACA,KACA,MAAAwC,EAAA3E,KAAAR,IAAAhY,GAAAoa,YAAAO,YACAwC,IAAA3E,IAEA,KADA4E,EAAAD,EACAA,EAAAnF,IAAAhY,GAAAoa,YAAAO,YACAwC,IAAA5E,IACA,IAAA4E,EAAArF,IAAAzpB,GAAA8uB,EAAA3E,KAAAZ,IAAAvpB,EAAA,CAGA+uB,EAAA5E,KAAAZ,IAAAzpB,EAAAgvB,EAAAvF,IAAAzpB,IACAgvB,EAAAC,EACA,QAEA,MAAAD,IAEAnd,GAAAoa,YAAA9sB,UAAA+vB,aAAA,SAAAF,EAAAG,GAEA,GAAAC,GAEAC,EADAC,EAAAN,CAGA,IAAAM,EAAAnF,QAAAtY,GAAAoa,YAAAQ,KACA,CAIA,GADAuC,EAAAM,EACAH,EACA,CACA,KAAAH,EAAArF,IAAAzpB,GAAA8uB,EAAA5E,KAAAX,IAAAvpB,GAAA8uB,IAAA5E,IACA,MAAA4E,GAAAM,GAAAN,EAAAnF,IAAAhY,GAAAoa,YAAAO,YAAAwC,IAAA3E,SAGA,CACA,KAAA2E,EAAArF,IAAAzpB,GAAA8uB,EAAA3E,KAAAZ,IAAAvpB,GAAA8uB,IAAA3E,IACA,MAAA2E,GAAAM,GAAAN,EAAAnF,IAAAhY,GAAAoa,YAAAO,YAAAwC,IAAA5E,KAEA,GAAA4E,GAAAM,EAEAA,EAAAH,EAAAH,EAAA5E,KACA4E,EAAA3E,SAGA,CAGA2E,EADAG,EACAG,EAAAlF,KAEAkF,EAAAjF,IACA,IAAAkF,GAAA,GAAA1d,IAAAsZ,WACAoE,GAAAnF,KAAA,KACAmF,EAAArvB,EAAA8uB,EAAAvF,IAAAvpB,EACAqvB,EAAAnE,UAAA,KACAmE,EAAAlE,WAAA2D,EACAA,EAAAhF,UAAA,EACAsF,EAAA5xB,KAAAwxB,aAAAF,EAAAG,GACAzxB,KAAA8xB,kBAAAD,GAEA,MAAAD,GAuBA,GApBAN,EAAAnF,IAAAhY,GAAAoa,YAAAO,aAKA4C,EAAAD,EAAAH,EAAA3E,KACA2E,EAAA5E,KACAgF,EAAAjF,QAAAtY,GAAAoa,YAAAQ,OAEA2C,EAAAvF,IAAAhY,GAAAoa,YAAAO,WAEA4C,EAAA3F,IAAAzpB,GAAAgvB,EAAAvF,IAAAzpB,GAAAovB,EAAAzF,IAAA3pB,GAAAgvB,EAAAvF,IAAAzpB,GACAtC,KAAA+xB,kBAAAT,GAEAI,EAAA3F,IAAAzpB,GAAAgvB,EAAAvF,IAAAzpB,GACAtC,KAAA+xB,kBAAAT,KAIAI,EAAAJ,EACAG,EACA,CACA,KAAAG,EAAA3F,IAAAzpB,GAAAovB,EAAAlF,KAAAX,IAAAvpB,GAAAovB,EAAAlF,KAAAD,QAAAtY,GAAAoa,YAAAQ,MACA6C,IAAAlF,IACA,IAAAkF,EAAAzF,IAAAhY,GAAAoa,YAAAO,YAAA8C,EAAAlF,KAAAD,QAAAtY,GAAAoa,YAAAQ,KACA,CAKA,IADA4C,EAAAC,EACAD,EAAAhF,KAAAR,IAAAhY,GAAAoa,YAAAO,YACA6C,IAAAhF,IACAgF,GAAAhF,KAAAV,IAAA3pB,GAAAsvB,EAAAlF,KAAAT,IAAA3pB,EAEAmvB,IACAG,EAAAD,EAAAhF,MAEAgF,EAAAhF,KAAAV,IAAA3pB,EAAAsvB,EAAAlF,KAAAT,IAAA3pB,IACAsvB,EAAAD,EAAAhF,MAEA,KAAA2E,GAAAM,GAEAN,EAAA1E,UAAA0E,EAAA5E,KACA4E,EAAAnF,IAAAhY,GAAAoa,YAAAO,YAAAwC,GAAAI,GAAAJ,EAAAvF,IAAAzpB,GAAAgvB,EAAA3E,KAAAV,IAAA3pB,GACAtC,KAAA+xB,kBAAAT,GACAA,IAAA5E,IAEA4E,GAAAnF,IAAAhY,GAAAoa,YAAAO,YAAAwC,GAAAI,GAAAJ,EAAAvF,IAAAzpB,GAAAgvB,EAAA3E,KAAAV,IAAA3pB,GACAtC,KAAA+xB,kBAAAT,GACAM,IAAAlF,SAIA,CACA,KAAAkF,EAAA3F,IAAAzpB,GAAAovB,EAAAjF,KAAAZ,IAAAvpB,GAAAovB,EAAAjF,KAAAF,QAAAtY,GAAAoa,YAAAQ,MACA6C,IAAAjF,IACA,IAAAiF,EAAAzF,IAAAhY,GAAAoa,YAAAO,YAAA8C,EAAAjF,KAAAF,QAAAtY,GAAAoa,YAAAQ,KACA,CAEA,IADA4C,EAAAC,EACAD,EAAAjF,KAAAP,IAAAhY,GAAAoa,YAAAO,YACA6C,IAAAjF,IACAiF,GAAAjF,KAAAT,IAAA3pB,GAAAsvB,EAAAjF,KAAAV,IAAA3pB,EAEAmvB,IACAG,EAAAD,EAAAjF,MAEAiF,EAAAjF,KAAAT,IAAA3pB,EAAAsvB,EAAAjF,KAAAV,IAAA3pB,IACAsvB,EAAAD,EAAAjF,MAEA,KAAA4E,GAAAM,GAEAN,EAAA1E,UAAA0E,EAAA3E,KACA2E,EAAAnF,IAAAhY,GAAAoa,YAAAO,YAAAwC,GAAAI,GAAAJ,EAAAvF,IAAAzpB,GAAAgvB,EAAA5E,KAAAT,IAAA3pB,GACAtC,KAAA+xB,kBAAAT,GACAA,IAAA3E,IAEA2E,GAAAnF,IAAAhY,GAAAoa,YAAAO,YAAAwC,GAAAI,GAAAJ,EAAAvF,IAAAzpB,GAAAgvB,EAAA5E,KAAAT,IAAA3pB,GACAtC,KAAA+xB,kBAAAT,GACAM,IAAAjF,KAIA,MAAAiF,IAGAzd,GAAAoa,YAAA9sB,UAAAuwB,QAAA,SAAAC,EAAAd,EAAAe,GAEAzP,GAEAyP,GAAAf,GAAAhd,GAAAlI,SAAA0e,QACAxW,GAAAnS,MAAA,wCAIAkwB,GACA/d,GAAAnS,MAAA,0CAEA,IAAAmwB,GAAAF,EAAA7wB,OAAA,CACA,IAAA8wB,EACA,KAAAC,EAAA,GAAAhe,GAAAmV,SAAA3D,YAAAsM,EAAAE,GAAAF,EAAA,OACAE,CACA,MAAAA,EAAA,GAAAhe,GAAAmV,SAAA3D,YAAAsM,EAAAE,GAAAF,EAAAE,EAAA,OACAA,CACA,IAAAD,GAAAC,EAAA,IAAAD,GAAAC,EAAA,EACA,QAGA,QADAC,GAAA,GAAA/U,OACAxc,EAAA,EAAmBA,GAAAsxB,EAAYtxB,IAC/BuxB,EAAAhwB,KAAA,GAAA+R,IAAA2X,MACA,IAAAuG,IAAA,CAIAD,GAAA,GAAApG,KAAA1pB,EAAA2vB,EAAA,GAAA3vB,EACA8vB,EAAA,GAAApG,KAAAxpB,EAAAyvB,EAAA,GAAAzvB,CAEA,IAAA8vB,IAAcxB,MAAA9wB,KAAA2uB,eACd3uB,MAAA4wB,UAAAqB,EAAA,GAAAK,GACAtyB,KAAA2uB,eAAA2D,EAAAxB,MAEAwB,EAAAxB,MAAA9wB,KAAA2uB,eACA3uB,KAAA4wB,UAAAqB,EAAAE,GAAAG,GACAtyB,KAAA2uB,eAAA2D,EAAAxB,MAEA9wB,KAAA+wB,SAAAqB,EAAA,GAAAA,EAAA,GAAAA,EAAAD,GAAAF,EAAA,IACAjyB,KAAA+wB,SAAAqB,EAAAD,GAAAC,EAAA,GAAAA,EAAAD,EAAA,GAAAF,EAAAE,GACA,QAAAtxB,GAAAsxB,EAAA,EAA2BtxB,GAAA,IAAQA,EAEnCyxB,EAAAxB,MAAA9wB,KAAA2uB,eACA3uB,KAAA4wB,UAAAqB,EAAApxB,GAAAyxB,GACAtyB,KAAA2uB,eAAA2D,EAAAxB,MAEA9wB,KAAA+wB,SAAAqB,EAAAvxB,GAAAuxB,EAAAvxB,EAAA,GAAAuxB,EAAAvxB,EAAA,GAAAoxB,EAAApxB,GAOA,KAJA,GAAA0xB,GAAAH,EAAA,GAEAd,EAAAiB,EACAC,EAAAD,IAKA,GAAAjB,EAAAtF,MAAAsF,EAAA5E,KAAAV,OAAAkG,GAAAZ,EAAA5E,MAAA6F,EAAA,CAUA,GAAAjB,EAAA3E,MAAA2E,EAAA5E,KACA,KACA,KAAAwF,IAAA/d,GAAAoa,YAAAwB,YAAAuB,EAAA3E,KAAAX,KAAAsF,EAAAtF,KAAAsF,EAAA5E,KAAAV,KAAAhsB,KAAA2uB,iBAAA3uB,KAAA6uB,mBAAA7uB,KAAAyyB,sBAAAnB,EAAA3E,KAAAX,KAAAsF,EAAAtF,KAAAsF,EAAA5E,KAAAV,OAcA,GADAsF,IAAA5E,KACA4E,GAAAkB,IAAAN,GAAAZ,EAAA5E,MAAA6F,EAAA,UARAjB,IAAAiB,IACAA,EAAAjB,EAAA5E,MACA4E,EAAAtxB,KAAA0yB,WAAApB,GACAA,IAAA3E,KACA6F,EAAAlB,MAtBA,CAEA,GAAAA,KAAA5E,KACA,KACA4E,IAAAiB,IACAA,EAAAjB,EAAA5E,MACA4E,EAAAtxB,KAAA0yB,WAAApB,GACAkB,EAAAlB,EAqBA,IAAAY,GAAAZ,KAAA5E,MAAAwF,GAAAZ,EAAA3E,MAAA2E,EAAA5E,KACA,QACAwF,KAEAlyB,KAAA4uB,gBAAA,EACA2D,EAAA5F,KAAAF,OAAAtY,GAAAoa,YAAAQ,MAGAuC,EAAAiB,CACA,GACAvyB,MAAAkxB,UAAAI,EAAAH,GACAG,IAAA5E,KACA2F,GAAAf,EAAAtF,KAAAxpB,GAAA+vB,EAAAvG,KAAAxpB,IACA6vB,GAAA,SAEAf,GAAAiB,EAIA,IAAAF,EACA,CACA,GAAAH,EACA,QACAZ,GAAA3E,KAAAF,OAAAtY,GAAAoa,YAAAQ,KACAuC,EAAA3E,KAAAZ,IAAAzpB,EAAAgvB,EAAA3E,KAAAV,IAAA3pB,GACAtC,KAAA+xB,kBAAAT,EAAA3E,KACA,IAAAkF,GAAA,GAAA1d,IAAAsZ,WAOA,KANAoE,EAAAnF,KAAA,KACAmF,EAAArvB,EAAA8uB,EAAAvF,IAAAvpB,EACAqvB,EAAAnE,UAAA,KACAmE,EAAAlE,WAAA2D,EACAO,EAAAlE,WAAAtB,KAAAlY,GAAAqX,SAAAE,QACAmG,EAAAlE,WAAArB,UAAA,EACAgF,EAAA5E,KAAAD,QAAAtY,GAAAoa,YAAAQ,MAEAuC,EAAA1E,UAAA0E,EAAA5E,KACA4E,EAAAvF,IAAAzpB,GAAAgvB,EAAA3E,KAAAV,IAAA3pB,GACAtC,KAAA+xB,kBAAAT,GACAA,IAAA5E,IAIA,OAFA1sB,MAAA8xB,kBAAAD,GACA7xB,KAAA0uB,QAAAtsB,KAAAgwB,IACA,EAEApyB,KAAA0uB,QAAAtsB,KAAAgwB,EACA,IAAAO,GACAC,EAAA,IAOA,KAHAze,GAAAmV,SAAA3D,YAAA2L,EAAA3E,KAAAZ,IAAAuF,EAAA3E,KAAAV,OACAqF,IAAA5E,MAIA4E,EAAAtxB,KAAAqxB,eAAAC,GACAA,GAAAsB,GAFA,CAIA,MAAAA,IACAA,EAAAtB,EAGA,IAAAO,GAAA,GAAA1d,IAAAsZ,WACAoE,GAAAnF,KAAA,KACAmF,EAAArvB,EAAA8uB,EAAAvF,IAAAvpB,EACA8uB,EAAAnF,GAAAmF,EAAA3E,KAAAR,IAEA0F,EAAAnE,UAAA4D,EAAA3E,KACAkF,EAAAlE,WAAA2D,EACAqB,GAAA,IAKAd,EAAAnE,UAAA4D,EACAO,EAAAlE,WAAA2D,EAAA3E,KACAgG,GAAA,GAGAd,EAAAnE,UAAArB,KAAAlY,GAAAqX,SAAAC,OACAoG,EAAAlE,WAAAtB,KAAAlY,GAAAqX,SAAAE,QACAwG,EAEAL,EAAAnE,UAAAhB,MAAAmF,EAAAlE,WACAkE,EAAAnE,UAAApB,WAAA,EAEAuF,EAAAnE,UAAApB,UAAA,EAJAuF,EAAAnE,UAAApB,UAAA,EAKAuF,EAAAlE,WAAArB,WAAAuF,EAAAnE,UAAApB,UACAgF,EAAAtxB,KAAAwxB,aAAAK,EAAAnE,UAAAiF,GACArB,EAAA7E,QAAAtY,GAAAoa,YAAAQ,OACAuC,EAAAtxB,KAAAwxB,aAAAF,EAAAqB,GACA,IAAApB,GAAAvxB,KAAAwxB,aAAAK,EAAAlE,YAAAgF,EACApB,GAAA9E,QAAAtY,GAAAoa,YAAAQ,OAAAwC,EAAAvxB,KAAAwxB,aAAAD,GAAAoB,IACAd,EAAAnE,UAAAjB,QAAAtY,GAAAoa,YAAAQ,KACA8C,EAAAnE,UAAA,KACAmE,EAAAlE,WAAAlB,QAAAtY,GAAAoa,YAAAQ,OACA8C,EAAAlE,WAAA,MACA3tB,KAAA8xB,kBAAAD,GACAc,IACArB,EAAAC,GAEA,UAEApd,GAAAoa,YAAA9sB,UAAAuK,SAAA,SAAA6mB,EAAA1B,EAAA2B,GAKA,OADA1rB,IAAA,EACAvG,EAAA,EAAA4nB,EAAAoK,EAAAzxB,OAAsCP,EAAA4nB,IAAU5nB,EAChDb,KAAAgyB,QAAAa,EAAAhyB,GAAAswB,EAAA2B,KACA1rB,GAAA,EACA,OAAAA,IAGA+M,GAAAoa,YAAA9sB,UAAAgxB,sBAAA,SAAAvC,EAAAC,EAAAC,GAEA,QAAAjc,GAAAmV,SAAA3D,YAAAuK,EAAAE,IAAAjc,GAAAmV,SAAA3D,YAAAuK,EAAAC,IAAAhc,GAAAmV,SAAA3D,YAAAyK,EAAAD,MAKAD,EAAA5tB,GAAA8tB,EAAA9tB,EACA6tB,EAAA7tB,EAAA4tB,EAAA5tB,GAAA6tB,EAAA7tB,EAAA8tB,EAAA9tB,EAEA6tB,EAAA3tB,EAAA0tB,EAAA1tB,GAAA2tB,EAAA3tB,EAAA4tB,EAAA5tB,IAEA2R,GAAAoa,YAAA9sB,UAAAixB,WAAA,SAAA5xB,GAGAA,EAAA6rB,KAAAD,KAAA5rB,EAAA4rB,KACA5rB,EAAA4rB,KAAAC,KAAA7rB,EAAA6rB,IACA,IAAAvlB,GAAAtG,EAAA4rB,IAEA,OADA5rB,GAAA6rB,KAAA,KACAvlB,GAEA+M,GAAAoa,YAAA9sB,UAAA2vB,MAAA,SAAAtwB,GAEAA,EAAAorB,MAAA5pB,EAAAxB,EAAAmrB,IAAA3pB,EAAAxB,EAAAirB,IAAAzpB,EACAxB,EAAAorB,MAAA1pB,EAAA1B,EAAAmrB,IAAAzpB,EAAA1B,EAAAirB,IAAAvpB,EACA,IAAA1B,EAAAorB,MAAA1pB,EAAA1B,EAAAqrB,GAAAhY,GAAAoa,YAAAO,WACAhuB,EAAAqrB,GAAArrB,EAAAorB,MAAA,EAAAprB,EAAAorB,MAAA,GAEA/X,GAAAoa,YAAA9sB,UAAAqwB,kBAAA,SAAAiB,GAEA,UAAA/yB,KAAAwuB,aAEAxuB,KAAAwuB,aAAAuE,MAEA,IAAAA,EAAAvwB,GAAAxC,KAAAwuB,aAAAhsB,EAEAuwB,EAAArG,KAAA1sB,KAAAwuB,aACAxuB,KAAAwuB,aAAAuE,MAGA,CAEA,IADA,GAAApC,GAAA3wB,KAAAwuB,aACA,OAAAmC,EAAAjE,MAAAqG,EAAAvwB,EAAAmuB,EAAAjE,KAAAlqB,GACAmuB,IAAAjE,IACAqG,GAAArG,KAAAiE,EAAAjE,KACAiE,EAAAjE,KAAAqG,IAGA5e,GAAAoa,YAAA9sB,UAAAuxB,eAAA,WAEA,OAAAhzB,KAAAyuB,cAEAzuB,KAAAyuB,YAAAzuB,KAAAyuB,YAAA/B,OAEAvY,GAAAoa,YAAA9sB,UAAAswB,kBAAA,SAAAjxB,GAKA,GAAAmyB,GAAAnyB,EAAAmrB,IAAA3pB,CACAxB,GAAAmrB,IAAA3pB,EAAAxB,EAAAirB,IAAAzpB,EACAxB,EAAAirB,IAAAzpB,EAAA2wB,EACAzQ,KAEAyQ,EAAAnyB,EAAAmrB,IAAAzC,EACA1oB,EAAAmrB,IAAAzC,EAAA1oB,EAAAirB,IAAAvC,EACA1oB,EAAAirB,IAAAvC,EAAAyJ,IAGA9e,GAAAoa,YAAA9sB,UAAAyxB,MAAA,WAGA,GADAlzB,KAAAyuB,YAAAzuB,KAAAwuB,aACA,MAAAxuB,KAAAyuB,YAKA,IADA,GAAA0E,GAAAnzB,KAAAwuB,aACA,MAAA2E,GACA,CACA,GAAAryB,GAAAqyB,EAAAzF,SACA,OAAA5sB,IAGAA,EAAAkrB,KAAA1pB,EAAAxB,EAAAirB,IAAAzpB,EACAxB,EAAAkrB,KAAAxpB,EAAA1B,EAAAirB,IAAAvpB,EACA1B,EAAAurB,KAAAlY,GAAAqX,SAAAC,OACA3qB,EAAA2rB,OAAAtY,GAAAoa,YAAAS,YAEAluB,EAAAqyB,EAAAxF,WACA,MAAA7sB,IAGAA,EAAAkrB,KAAA1pB,EAAAxB,EAAAirB,IAAAzpB,EACAxB,EAAAkrB,KAAAxpB,EAAA1B,EAAAirB,IAAAvpB,EACA1B,EAAAurB,KAAAlY,GAAAqX,SAAAE,QACA5qB,EAAA2rB,OAAAtY,GAAAoa,YAAAS,YAEAmE,IAAAzG,OAGAvY,GAAAvI,QAAA,SAAAwnB,GAEA,wBAAAA,EAAA,GACApzB,KAAAqzB,WAAA,KACArzB,KAAAszB,WAAAnf,GAAA/H,SAAAoe,eACAxqB,KAAAuzB,WAAA,KACAvzB,KAAAwzB,cAAA,KACAxzB,KAAAyzB,cAAA,KACAzzB,KAAA0zB,gBAAA,KACA1zB,KAAA2zB,wBAAA,KACA3zB,KAAA4zB,iBAAA,EACA5zB,KAAA6zB,eAAA1f,GAAA7I,aAAAE,WACAxL,KAAA8zB,eAAA3f,GAAA7I,aAAAE,WACAxL,KAAA+zB,QAAA,KACA/zB,KAAAg0B,aAAA,KACAh0B,KAAAi0B,iBAAA,EACAj0B,KAAAk0B,iBAAA,EACAl0B,KAAA0M,gBAAA,EACAyH,GAAAoa,YAAAhuB,KAAAP,MACAA,KAAAuzB,WAAA,KACAvzB,KAAAwzB,cAAA,KACAxzB,KAAAyzB,cAAA,KACAzzB,KAAA0zB,gBAAA,GAAArW,OACArd,KAAA2zB,wBAAAxf,GAAAkZ,oBAAAC,QACAttB,KAAA4zB,iBAAA,EACA5zB,KAAAi0B,iBAAA,EACAj0B,KAAAqzB,WAAA,GAAAhW,OACArd,KAAA+zB,QAAA,GAAA1W,OACArd,KAAAg0B,aAAA,GAAA3W,OACArd,KAAAk0B,gBAAA,OAAAd,GACApzB,KAAA0M,eAAA,OAAA0mB,GACApzB,KAAA6uB,kBAAA,OAAAuE,GACA5Q,KAEAxiB,KAAAm0B,cAAA,OAGAhgB,GAAAvI,QAAAwoB,kBAAA,EACAjgB,GAAAvI,QAAAyoB,iBAAA,EACAlgB,GAAAvI,QAAA0oB,oBAAA,EAEAngB,GAAAvI,QAAAnK,UAAAgL,MAAA,WAEA,IAAAzM,KAAA0uB,QAAAttB,SAGApB,KAAAu0B,oBACApgB,GAAAoa,YAAA9sB,UAAAgL,MAAAlM,KAAAP,QAGAmU,GAAAvI,QAAAnK,UAAA+yB,oBAAA,WAEA,YAAAx0B,KAAAuzB,YACA,CACA,GAAAkB,GAAAz0B,KAAAuzB,WAAA7G,IACA1sB,MAAAuzB,WAAA,KACAvzB,KAAAuzB,WAAAkB,IAGAtgB,GAAAvI,QAAAnK,UAAAyxB,MAAA,WAEA/e,GAAAoa,YAAA9sB,UAAAyxB,MAAA3yB,KAAAP,MACAA,KAAAuzB,WAAA,KACAvzB,KAAAwzB,cAAA,KACAxzB,KAAAyzB,cAAA,IAGA,KADA,GAAAN,GAAAnzB,KAAAwuB,aACA,OAAA2E,GAEAnzB,KAAA00B,eAAAvB,EAAA3wB,GACA2wB,IAAAzG,MAGAvY,GAAAvI,QAAAnK,UAAAizB,eAAA,SAAAlyB,GAEA,UAAAxC,KAAAuzB,WAEAvzB,KAAAuzB,WAAA,GAAApf,IAAAyZ,SACA5tB,KAAAuzB,WAAA7G,KAAA,KACA1sB,KAAAuzB,WAAA/wB,QAEA,IAAAA,EAAAxC,KAAAuzB,WAAA/wB,EACA,CACA,GAAAmyB,GAAA,GAAAxgB,IAAAyZ,QACA+G,GAAAnyB,IACAmyB,EAAAjI,KAAA1sB,KAAAuzB,WACAvzB,KAAAuzB,WAAAoB,MAGA,CAEA,IADA,GAAAF,GAAAz0B,KAAAuzB,WACA,OAAAkB,EAAA/H,MAAAlqB,GAAAiyB,EAAA/H,KAAAlqB,GACAiyB,IAAA/H,IACA,IAAAlqB,GAAAiyB,EAAAjyB,EACA,MAEA,IAAAmyB,GAAA,GAAAxgB,IAAAyZ,QACA+G,GAAAnyB,IACAmyB,EAAAjI,KAAA+H,EAAA/H,KACA+H,EAAA/H,KAAAiI,IAIAxgB,GAAAvI,QAAAnK,UAAA0K,QAAA,WAEA,GAAA8H,GAAA5R,UACAknB,EAAAtV,EAAA7S,OACAwzB,EAAA3gB,EAAA,YAAAE,IAAAzI,QACA,OAAA6d,IAAAqL,EACA,CACA,GAAAC,GAAA5gB,EAAA,GACA6gB,EAAA7gB,EAAA,GACA8gB,EAAA9gB,EAAA,GACA+gB,EAAA/gB,EAAA,EACA,IAAAjU,KAAA4zB,gBACA,QACA5zB,MAAA4uB,gBACAza,GAAAnS,MAAA,0DACAhC,KAAA4zB,iBAAA,EACAzf,GAAA1H,MAAAqoB,GACA90B,KAAA8zB,eAAAiB,EACA/0B,KAAA6zB,eAAAmB,EACAh1B,KAAAszB,WAAAuB,EACA70B,KAAAi0B,iBAAA,CACA,KAEA,GAAAgB,GAAAj1B,KAAAk1B,iBAEAD,IAAAj1B,KAAAm1B,YAAAL,GAEA,QAEA90B,KAAAu0B,oBACAv0B,KAAA4zB,iBAAA,EAEA,MAAAqB,GAEA,MAAA1L,GAAAqL,EACA,CACA,GAAAC,GAAA5gB,EAAA,GACAmhB,EAAAnhB,EAAA,GACA8gB,EAAA9gB,EAAA,GACA+gB,EAAA/gB,EAAA,EACA,IAAAjU,KAAA4zB,gBACA,QACA5zB,MAAA4zB,iBAAA,EACA5zB,KAAA8zB,eAAAiB,EACA/0B,KAAA6zB,eAAAmB,EACAh1B,KAAAszB,WAAAuB,EACA70B,KAAAi0B,iBAAA,CACA,KAEA,GAAAgB,GAAAj1B,KAAAk1B,iBAEAD,IAAAj1B,KAAAq1B,aAAAD,GAEA,QAEAp1B,KAAAu0B,oBACAv0B,KAAA4zB,iBAAA,EAEA,MAAAqB,GAEA,MAAA1L,IAAAqL,EACA,CACA,GAAAC,GAAA5gB,EAAA,GACA6gB,EAAA7gB,EAAA,EACA,OAAAjU,MAAAmM,QAAA0oB,EAAAC,EAAA3gB,GAAA7I,aAAAE,WAAA2I,GAAA7I,aAAAE,YAEA,MAAA+d,GAAAqL,EACA,CACA,GAAAC,GAAA5gB,EAAA,GACAmhB,EAAAnhB,EAAA,EACA,OAAAjU,MAAAmM,QAAA0oB,EAAAO,EAAAjhB,GAAA7I,aAAAE,WAAA2I,GAAA7I,aAAAE,cAGA2I,GAAAvI,QAAAnK,UAAA6zB,eAAA,SAAAC,GAIA,UAAAA,EAAAxH,YAAAwH,EAAAhN,QAAAgN,EAAAxH,UAAAxF,QAAA,OAAAgN,EAAAxH,UAAAC,KAAA,CAGA,IADA,GAAAwH,GAAAD,EAAAxH,UACA,OAAAyH,MAAAjN,QAAAgN,EAAAhN,QAAA,OAAAiN,EAAAxH,MACAwH,IAAAzH;AACAwH,EAAAxH,UAAAyH,IAEArhB,GAAAvI,QAAAnK,UAAAyzB,gBAAA,WAEA,IAGA,GADAl1B,KAAAkzB,QACA,OAAAlzB,KAAAyuB,YACA,QACA,IAAAgH,GAAAz1B,KAAA01B,aACA,IAIA,GAHA11B,KAAA21B,yBAAAF,GACAthB,GAAA1H,MAAAzM,KAAAg0B,cACAh0B,KAAA41B,oBAAA,GACA,OAAA51B,KAAAuzB,WACA,KACA,IAAAsC,GAAA71B,KAAA01B,aACA,KAAA11B,KAAA81B,qBAAAD,GAAA,QAEA71B,MAAA+1B,4BAAAF,GACAJ,EAAAI,QAEA,OAAA71B,KAAAuzB,YAAA,OAAAvzB,KAAAyuB,YAEA,QAAA5tB,GAAA,EAAA4nB,EAAAzoB,KAAAqzB,WAAAjyB,OAAoDP,EAAA4nB,EAAU5nB,IAC9D,CACA,GAAA00B,GAAAv1B,KAAAqzB,WAAAxyB,EACA,QAAA00B,EAAAvH,KAAAuH,EAAA5N,SAEA4N,EAAAhN,OAAAvoB,KAAAk0B,kBAAAl0B,KAAAg2B,KAAAT,GAAA,GACAv1B,KAAAi2B,mBAAAV,EAAAvH,KAEAhuB,KAAAk2B,iBACA,QAAAr1B,GAAA,EAAA4nB,EAAAzoB,KAAAqzB,WAAAjyB,OAAoDP,EAAA4nB,EAAU5nB,IAC9D,CACA,GAAA00B,GAAAv1B,KAAAqzB,WAAAxyB,EACA,QAAA00B,EAAAvH,KAAAuH,EAAA5N,QACA3nB,KAAAm2B,gBAAAZ,GAIA,MAFAv1B,MAAA0M,gBACA1M,KAAAo2B,oBACA,EAEA,QAEAjiB,GAAA1H,MAAAzM,KAAA+zB,SACA5f,GAAA1H,MAAAzM,KAAAg0B,gBAGA7f,GAAAvI,QAAAnK,UAAAi0B,YAAA,WAEA,GAAAlzB,GAAAxC,KAAAuzB,WAAA/wB,CAEA,OADAxC,MAAAuzB,WAAAvzB,KAAAuzB,WAAA7G,KACAlqB,GAGA2R,GAAAvI,QAAAnK,UAAA8yB,kBAAA,WAEA,OAAA1zB,GAAA,EAAA4nB,EAAAzoB,KAAAqzB,WAAAjyB,OAAkDP,EAAA4nB,IAAU5nB,EAC5Db,KAAAq2B,cAAAx1B,EACAsT,IAAA1H,MAAAzM,KAAAqzB,aAEAlf,GAAAvI,QAAAnK,UAAA40B,cAAA,SAAAC,GAEA,GAAAf,GAAAv1B,KAAAqzB,WAAAiD,EACAf,GAAAvH,IAAA,KACAuH,EAAA,KACAv1B,KAAAqzB,WAAAiD,GAAA,MAGAniB,GAAAvI,QAAAnK,UAAA80B,QAAA,SAAAC,EAAAC,EAAAnI,GAEA,GAAA5Z,GAAA,GAAAP,IAAAga,IACAzZ,GAAA0Z,OAAAoI,EACA9hB,EAAA2Z,OAAAoI,EAEA/hB,EAAA4Z,MAAAhsB,EAAAgsB,EAAAhsB,EACAoS,EAAA4Z,MAAA9rB,EAAA8rB,EAAA9rB,EACAxC,KAAA+zB,QAAA3xB,KAAAsS,IAEAP,GAAAvI,QAAAnK,UAAAi1B,aAAA,SAAAC,EAAArI,GAEA,GAAA5Z,GAAA,GAAAP,IAAAga,IACAzZ,GAAA0Z,OAAAuI,EAEAjiB,EAAA4Z,MAAAhsB,EAAAgsB,EAAAhsB,EACAoS,EAAA4Z,MAAA9rB,EAAA8rB,EAAA9rB,EACAxC,KAAAg0B,aAAA5xB,KAAAsS,IAEA8N,KAEArO,GAAAvI,QAAAnK,UAAAm1B,KAAA,SAAAze,EAAA6X,EAAAC,GAEA,UAAAjwB,KAAAm0B,cACA,CACA,MAAAhc,EAAAqR,GAAA,OAAAxpB,KAAAm0B,cAAA,MACAhgB,IAAAmV,SAAA3D,YAAAxN,EAAA6X,EAAAjE,KAAA5T,EAAAqR,EAAAwG,EAAAjE,IAAAvC,EACArV,GAAAmV,SAAA3D,YAAAxN,EAAA6X,EAAA/D,KAAA9T,EAAAqR,EAAAwG,EAAA/D,IAAAzC,EACArV,GAAAmV,SAAA3D,YAAAxN,EAAA8X,EAAAlE,KAAA5T,EAAAqR,EAAAyG,EAAAlE,IAAAvC,EACArV,GAAAmV,SAAA3D,YAAAxN,EAAA8X,EAAAhE,KAAA9T,EAAAqR,EAAAyG,EAAAhE,IAAAzC,EACA2K,cAAAnE,EAAAjE,IAAAiE,EAAA/D,IAAAgE,EAAAlE,IAAAkE,EAAAhE,IAAA9T,MAOAhE,GAAAvI,QAAAnK,UAAAk0B,yBAAA,SAAAF,GAEA,YAAAz1B,KAAAyuB,aAAAzuB,KAAAyuB,YAAAjsB,GAAAizB,GACA,CACA,GAAAoB,GAAA72B,KAAAyuB,YAAAf,UACAoJ,EAAA92B,KAAAyuB,YAAAd,UACA3tB,MAAAgzB,gBACA,IAAAwD,GAAA,IAkCA,IAjCA,OAAAK,GAEA72B,KAAA+2B,kBAAAD,EAAA,MACA92B,KAAAg3B,gBAAAF,GACA92B,KAAAi3B,eAAAH,KACAN,EAAAx2B,KAAAk3B,SAAAJ,IAAA/K,OAEA,MAAA+K,GAEA92B,KAAA+2B,kBAAAF,EAAA,MACA72B,KAAAg3B,gBAAAH,GACA72B,KAAAi3B,eAAAJ,KACAL,EAAAx2B,KAAAk3B,SAAAL,IAAA9K,MACA/rB,KAAA00B,eAAAmC,EAAA5K,IAAAzpB,KAIAxC,KAAA+2B,kBAAAF,EAAA,MACA72B,KAAA+2B,kBAAAD,EAAAD,GACA72B,KAAAg3B,gBAAAH,GACAC,EAAAvK,QAAAsK,EAAAtK,QACAuK,EAAAtK,SAAAqK,EAAArK,SACAxsB,KAAAi3B,eAAAJ,KACAL,EAAAx2B,KAAAm3B,gBAAAN,EAAAC,EAAAD,EAAA9K,MACA/rB,KAAA00B,eAAAmC,EAAA5K,IAAAzpB,IAEA,MAAAs0B,IAEA3iB,GAAAoa,YAAAe,aAAAwH,GACA92B,KAAAo3B,aAAAN,GAEA92B,KAAA00B,eAAAoC,EAAA7K,IAAAzpB,IAEA,MAAAq0B,GAAA,MAAAC,EAAA,CAEA,UAAAN,GAAAriB,GAAAoa,YAAAe,aAAAwH,IAAA92B,KAAAg0B,aAAA5yB,OAAA,OAAA01B,EAAAxK,UAEA,OAAAzrB,GAAA,EAAA4nB,EAAAzoB,KAAAg0B,aAAA5yB,OAAwDP,EAAA4nB,EAAU5nB,IAClE,CAGA,GAAA6T,GAAA1U,KAAAg0B,aAAAnzB,EAEAb,MAAAq3B,oBAAA3iB,EAAA0Z,OAAAhB,GAAA9qB,EAAAoS,EAAA4Z,MAAAhsB,EAAAw0B,EAAA/K,IAAAzpB,EAAAw0B,EAAA7K,IAAA3pB,IACAtC,KAAAu2B,QAAA7hB,EAAA0Z,OAAAoI,EAAA9hB,EAAA4Z,OAGA,GAAAuI,EAAApK,QAAA,UAAAoK,EAAA/J,WACA+J,EAAA/J,UAAAd,KAAA1pB,GAAAu0B,EAAA9K,IAAAzpB,GACAu0B,EAAA/J,UAAAL,QAAA,GACAtY,GAAAoa,YAAAwB,YAAA8G,EAAA/J,UAAA+J,EAAA72B,KAAA2uB,iBACA,IAAAkI,EAAAvK,WAAA,IAAAuK,EAAA/J,UAAAR,UACA,CACA,GAAAmK,GAAAz2B,KAAAk3B,SAAAL,EAAA/J,UAAA+J,EAAA9K,IACA/rB,MAAAu2B,QAAAC,EAAAC,EAAAI,EAAA5K,KAEA,GAAA4K,EAAAhK,WAAAiK,EACA,CACA,GAAAA,EAAArK,QAAA,GAAAqK,EAAAhK,UAAAL,QAAA,GACAtY,GAAAoa,YAAAwB,YAAA+G,EAAAhK,UAAAgK,EAAA92B,KAAA2uB,iBACA,IAAAmI,EAAAxK,WAAA,IAAAwK,EAAAhK,UAAAR,UACA,CACA,GAAAmK,GAAAz2B,KAAAk3B,SAAAJ,EAAAhK,UAAAgK,EAAA/K,IACA/rB,MAAAu2B,QAAAC,EAAAC,EAAAK,EAAA7K,KAEA,GAAAnrB,GAAA+1B,EAAAhK,SACA,WAAA/rB,EACA,KAAAA,GAAAg2B,GAIA92B,KAAAs3B,eAAAR,EAAAh2B,EAAA+1B,EAAA7K,MAAA,GAEAlrB,IAAA+rB,cAKA1Y,GAAAvI,QAAAnK,UAAAs1B,kBAAA,SAAAQ,EAAAC,GAEA,UAAAx3B,KAAAwzB,cAEA+D,EAAAzK,UAAA,KACAyK,EAAA1K,UAAA,KACA7sB,KAAAwzB,cAAA+D,MAEA,WAAAC,GAAAx3B,KAAAy3B,kBAAAz3B,KAAAwzB,cAAA+D,GAEAA,EAAAzK,UAAA,KACAyK,EAAA1K,UAAA7sB,KAAAwzB,cACAxzB,KAAAwzB,cAAA1G,UAAAyK,EACAv3B,KAAAwzB,cAAA+D,MAGA,CAGA,IAFA,OAAAC,IACAA,EAAAx3B,KAAAwzB,eACA,OAAAgE,EAAA3K,YAAA7sB,KAAAy3B,kBAAAD,EAAA3K,UAAA0K,IACAC,IAAA3K,SACA0K,GAAA1K,UAAA2K,EAAA3K,UACA,OAAA2K,EAAA3K,YACA2K,EAAA3K,UAAAC,UAAAyK,GACAA,EAAAzK,UAAA0K,EACAA,EAAA3K,UAAA0K,IAGApjB,GAAAvI,QAAAnK,UAAAg2B,kBAAA,SAAAzH,EAAAC,GAEA,MAAAA,GAAAjE,KAAA1pB,GAAA0tB,EAAAhE,KAAA1pB,EAEA2tB,EAAAhE,IAAAzpB,EAAAwtB,EAAA/D,IAAAzpB,EACAytB,EAAAhE,IAAA3pB,EAAA6R,GAAAvI,QAAA8rB,KAAA1H,EAAAC,EAAAhE,IAAAzpB,GAEAwtB,EAAA/D,IAAA3pB,EAAA6R,GAAAvI,QAAA8rB,KAAAzH,EAAAD,EAAA/D,IAAAzpB,GAGAytB,EAAAjE,KAAA1pB,EAAA0tB,EAAAhE,KAAA1pB,GAEA6R,GAAAvI,QAAAnK,UAAAk2B,kBAAA,SAAAJ,GAEA,MAAAA,GAAAnL,SAAAjY,GAAAlI,SAAAC,UACAlM,KAAA8zB,gBAAA3f,GAAA7I,aAAAE,WAEAxL,KAAA6zB,gBAAA1f,GAAA7I,aAAAE,YAEA2I,GAAAvI,QAAAnK,UAAAm2B,qBAAA,SAAAL,GAEA,MAAAA,GAAAnL,SAAAjY,GAAAlI,SAAAC,UACAlM,KAAA6zB,gBAAA1f,GAAA7I,aAAAE,WAEAxL,KAAA8zB,gBAAA3f,GAAA7I,aAAAE,YAEA2I,GAAAvI,QAAAnK,UAAAw1B,eAAA,SAAAM,GAEA,GAAAM,GAAAC,CAWA,QAVAP,EAAAnL,SAAAjY,GAAAlI,SAAAC,WAEA2rB,EAAA73B,KAAA8zB,eACAgE,EAAA93B,KAAA6zB,iBAIAgE,EAAA73B,KAAA6zB,eACAiE,EAAA93B,KAAA8zB,gBAEA+D,GAEA,IAAA1jB,IAAA7I,aAAAE,WACA,OAAA+rB,EAAAjL,WAAA,GAAAiL,EAAAhL,QACA,QACA,MACA,KAAApY,IAAA7I,aAAAC,WACA,MAAAhC,KAAAsO,IAAA0f,EAAAhL,SACA,QACA,MACA,KAAApY,IAAA7I,aAAAsf,YACA,MAAA2M,EAAAhL,QACA,QACA,MACA,SACA,GAAAgL,EAAAhL,UAAA,EACA,SAGA,OAAAvsB,KAAAszB,YAEA,IAAAnf,IAAA/H,SAAAoe,eACA,OAAAsN,GAEA,IAAA3jB,IAAA7I,aAAAE,WACA,IAAA2I,IAAA7I,aAAAC,WACA,WAAAgsB,EAAA/K,QACA,KAAArY,IAAA7I,aAAAsf,YACA,MAAA2M,GAAA/K,SAAA,CACA,SACA,MAAA+K,GAAA/K,SAAA,EAEA,IAAArY,IAAA/H,SAAAC,QACA,OAAAyrB,GAEA,IAAA3jB,IAAA7I,aAAAE,WACA,IAAA2I,IAAA7I,aAAAC,WACA,WAAAgsB,EAAA/K,QACA,KAAArY,IAAA7I,aAAAsf,YACA,MAAA2M,GAAA/K,UAAA,CACA,SACA,MAAA+K,GAAA/K,UAAA,EAEA,IAAArY,IAAA/H,SAAAqe,aACA,GAAA8M,EAAAnL,SAAAjY,GAAAlI,SAAAC,UACA,OAAA4rB,GAEA,IAAA3jB,IAAA7I,aAAAE,WACA,IAAA2I,IAAA7I,aAAAC,WACA,WAAAgsB,EAAA/K,QACA,KAAArY,IAAA7I,aAAAsf,YACA,MAAA2M,GAAA/K,UAAA,CACA,SACA,MAAA+K,GAAA/K,UAAA,MAGA,QAAAsL,GAEA,IAAA3jB,IAAA7I,aAAAE,WACA,IAAA2I,IAAA7I,aAAAC,WACA,WAAAgsB,EAAA/K,QACA,KAAArY,IAAA7I,aAAAsf,YACA,MAAA2M,GAAA/K,SAAA,CACA,SACA,MAAA+K,GAAA/K,SAAA,EAEA,IAAArY,IAAA/H,SAAAse,MACA,OAAA6M,EAAAjL,UAYA,QAXA,QAAAwL,GAEA,IAAA3jB,IAAA7I,aAAAE,WACA,IAAA2I,IAAA7I,aAAAC,WACA,WAAAgsB,EAAA/K,QACA,KAAArY,IAAA7I,aAAAsf,YACA,MAAA2M,GAAA/K,UAAA,CACA,SACA,MAAA+K,GAAA/K,UAAA,GAKA,UAEArY,GAAAvI,QAAAnK,UAAAu1B,gBAAA,SAAAO,GAIA,IAFA,GAAAz2B,GAAAy2B,EAAAzK,UAEA,OAAAhsB,MAAAsrB,SAAAmL,EAAAnL,SAAA,IAAAtrB,EAAAwrB,YACAxrB,IAAAgsB,SACA,WAAAhsB,EAEAy2B,EAAAhL,QAAA,IAAAgL,EAAAjL,UAAA,EAAAiL,EAAAjL,UACAiL,EAAA/K,SAAA,EACA1rB,EAAAd,KAAAwzB,kBAGA,QAAA+D,EAAAjL,WAAAtsB,KAAAszB,YAAAnf,GAAA/H,SAAAC,QAEAkrB,EAAAhL,QAAA,EACAgL,EAAA/K,SAAA1rB,EAAA0rB,SACA1rB,IAAA+rB,cAGA,IAAA7sB,KAAA23B,kBAAAJ,GACA,CAEA,OAAAA,EAAAjL,UACA,CAIA,IAFA,GAAAyL,IAAA,EACA9H,EAAAnvB,EAAAgsB,UACA,OAAAmD,GAEAA,EAAA7D,SAAAtrB,EAAAsrB,SAAA,IAAA6D,EAAA3D,YACAyL,MACA9H,IAAAnD,SAEAyK,GAAAhL,QAAAwL,EAAA,QAIAR,GAAAhL,QAAAgL,EAAAjL,SAEAiL,GAAA/K,SAAA1rB,EAAA0rB,SACA1rB,IAAA+rB,cAMA/rB,GAAAyrB,QAAAzrB,EAAAwrB,UAAA,EAIA/iB,KAAAsO,IAAA/W,EAAAyrB,SAAA,EAIAzrB,EAAAwrB,UAAAiL,EAAAjL,UAAA,EACAiL,EAAAhL,QAAAzrB,EAAAyrB,QAEAgL,EAAAhL,QAAAzrB,EAAAyrB,QAAAgL,EAAAjL,UAGAiL,EAAAhL,QAAA,IAAAgL,EAAAjL,UAAA,EAAAiL,EAAAjL,UAMA,IAAAiL,EAAAjL,UACAiL,EAAAhL,QAAAzrB,EAAAyrB,QAAA,EAAAzrB,EAAAyrB,QAAA,EAAAzrB,EAAAyrB,QAAA,EACAzrB,EAAAwrB,UAAAiL,EAAAjL,UAAA,EACAiL,EAAAhL,QAAAzrB,EAAAyrB,QAEAgL,EAAAhL,QAAAzrB,EAAAyrB,QAAAgL,EAAAjL,UAEAiL,EAAA/K,SAAA1rB,EAAA0rB,SACA1rB,IAAA+rB,SAIA,IAAA7sB,KAAA43B,qBAAAL,GAGA,KAAAz2B,GAAAy2B,GAEA,IAAAz2B,EAAAwrB,YACAiL,EAAA/K,SAAA,IAAA+K,EAAA/K,SAAA,KACA1rB,IAAA+rB,cAMA,MAAA/rB,GAAAy2B,GAEAA,EAAA/K,UAAA1rB,EAAAwrB,UACAxrB,IAAA+rB,WAIA1Y,GAAAvI,QAAAnK,UAAA21B,aAAA,SAAAG,GAIA,OAAAv3B,KAAAyzB,eAEAzzB,KAAAyzB,cAAA8D,EACAA,EAAAvK,UAAA,KACAuK,EAAAxK,UAAA,OAIAwK,EAAAxK,UAAA/sB,KAAAyzB,cACA8D,EAAAvK,UAAA,KACAhtB,KAAAyzB,cAAAzG,UAAAuK,EACAv3B,KAAAyzB,cAAA8D,IAGApjB,GAAAvI,QAAAnK,UAAAu2B,aAAA,WAEA,GAAAl3B,GAAAd,KAAAwzB,aAEA,KADAxzB,KAAAyzB,cAAA3yB,EACA,OAAAA,GAEAA,EAAAksB,UAAAlsB,EAAAgsB,UACAhsB,EAAAisB,UAAAjsB,EAAA+rB,UACA/rB,IAAA+rB,WAGA1Y,GAAAvI,QAAAnK,UAAAw2B,mBAAA,SAAAC,EAAAC,GAGA,GAAAD,EAAArL,WAAAqL,EAAApL,WAAAqL,EAAAtL,WAAAsL,EAAArL,UAAA,CAEA,GAAAoL,EAAArL,WAAAsL,EACA,CACA,GAAAC,GAAAD,EAAAtL,SACA,QAAAuL,IACAA,EAAAtL,UAAAoL,EACA,IAAAG,GAAAH,EAAApL,SACA,QAAAuL,IACAA,EAAAxL,UAAAsL,GACAA,EAAArL,UAAAuL,EACAF,EAAAtL,UAAAqL,EACAA,EAAApL,UAAAqL,EACAD,EAAArL,UAAAuL,MAEA,IAAAD,EAAAtL,WAAAqL,EACA,CACA,GAAAE,GAAAF,EAAArL,SACA,QAAAuL,IACAA,EAAAtL,UAAAqL,EACA,IAAAE,GAAAF,EAAArL,SACA,QAAAuL,IACAA,EAAAxL,UAAAqL,GACAA,EAAApL,UAAAuL,EACAH,EAAArL,UAAAsL,EACAA,EAAArL,UAAAoL,EACAC,EAAAtL,UAAAuL,MAGA,CACA,GAAAA,GAAAF,EAAArL,UACAwL,EAAAH,EAAApL,SACAoL,GAAArL,UAAAsL,EAAAtL,UACA,OAAAqL,EAAArL,YACAqL,EAAArL,UAAAC,UAAAoL,GACAA,EAAApL,UAAAqL,EAAArL,UACA,OAAAoL,EAAApL,YACAoL,EAAApL,UAAAD,UAAAqL,GACAC,EAAAtL,UAAAuL,EACA,OAAAD,EAAAtL,YACAsL,EAAAtL,UAAAC,UAAAqL,GACAA,EAAArL,UAAAuL,EACA,OAAAF,EAAArL,YACAqL,EAAArL,UAAAD,UAAAsL,GAEA,OAAAD,EAAApL,UACA9sB,KAAAwzB,cAAA0E,EACA,OAAAC,EAAArL,YACA9sB,KAAAwzB,cAAA2E,KAEAhkB,GAAAvI,QAAAnK,UAAA62B,mBAAA,SAAAJ,EAAAC,GAEA,YAAAD,EAAAnL,WAAA,OAAAmL,EAAAlL,WAEA,OAAAmL,EAAApL,WAAA,OAAAoL,EAAAnL,WAAA,CAEA,GAAAkL,EAAAnL,WAAAoL,EACA,CACA,GAAAC,GAAAD,EAAApL,SACA,QAAAqL,IACAA,EAAApL,UAAAkL,EACA,IAAAG,GAAAH,EAAAlL,SACA,QAAAqL,IACAA,EAAAtL,UAAAoL,GACAA,EAAAnL,UAAAqL,EACAF,EAAApL,UAAAmL,EACAA,EAAAlL,UAAAmL,EACAD,EAAAnL,UAAAqL,MAEA,IAAAD,EAAApL,WAAAmL,EACA,CACA,GAAAE,GAAAF,EAAAnL,SACA,QAAAqL,IACAA,EAAApL,UAAAmL,EACA,IAAAE,GAAAF,EAAAnL,SACA,QAAAqL,IACAA,EAAAtL,UAAAmL,GACAA,EAAAlL,UAAAqL,EACAH,EAAAnL,UAAAoL,EACAA,EAAAnL,UAAAkL,EACAC,EAAApL,UAAAqL,MAGA,CACA,GAAAA,GAAAF,EAAAnL,UACAsL,EAAAH,EAAAlL,SACAkL,GAAAnL,UAAAoL,EAAApL,UACA,OAAAmL,EAAAnL,YACAmL,EAAAnL,UAAAC,UAAAkL,GACAA,EAAAlL,UAAAmL,EAAAnL,UACA,OAAAkL,EAAAlL,YACAkL,EAAAlL,UAAAD,UAAAmL,GACAC,EAAApL,UAAAqL,EACA,OAAAD,EAAApL,YACAoL,EAAApL,UAAAC,UAAAmL,GACAA,EAAAnL,UAAAqL,EACA,OAAAF,EAAAnL,YACAmL,EAAAnL,UAAAD,UAAAoL,GAEA,OAAAD,EAAAlL,UACAhtB,KAAAyzB,cAAAyE,EACA,OAAAC,EAAAnL,YACAhtB,KAAAyzB,cAAA0E,KAEAhkB,GAAAvI,QAAAnK,UAAA82B,gBAAA,SAAAvI,EAAAC,EAAA9X,GAEAnY,KAAAk3B,SAAAlH,EAAA7X,GACA,GAAA8X,EAAA3D,WAAAtsB,KAAAk3B,SAAAjH,EAAA9X,GACA6X,EAAAvD,QAAAwD,EAAAxD,QAEAuD,EAAAvD,QAAA,EACAwD,EAAAxD,QAAA,GAEAuD,EAAAvD,OAAAwD,EAAAxD,OACAzsB,KAAAw4B,cAAAxI,EAAAC,GAEAjwB,KAAAw4B,cAAAvI,EAAAD,IAEA7b,GAAAvI,QAAAnK,UAAA01B,gBAAA,SAAAnH,EAAAC,EAAA9X,GAEA,GAAA/Q,GACAtG,EAAA23B,CAyBA,IAxBAtkB,GAAAoa,YAAAe,aAAAW,IAAAD,EAAA7D,GAAA8D,EAAA9D,IAEA/kB,EAAApH,KAAAk3B,SAAAlH,EAAA7X,GACA8X,EAAAxD,OAAAuD,EAAAvD,OACAuD,EAAA3D,KAAAlY,GAAAqX,SAAAC,OACAwE,EAAA5D,KAAAlY,GAAAqX,SAAAE,QACA5qB,EAAAkvB,EAEAyI,EADA33B,EAAAgsB,WAAAmD,EACAA,EAAAnD,UAEAhsB,EAAAgsB,YAIA1lB,EAAApH,KAAAk3B,SAAAjH,EAAA9X,GACA6X,EAAAvD,OAAAwD,EAAAxD,OACAuD,EAAA3D,KAAAlY,GAAAqX,SAAAE,QACAuE,EAAA5D,KAAAlY,GAAAqX,SAAAC,OACA3qB,EAAAmvB,EAEAwI,EADA33B,EAAAgsB,WAAAkD,EACAA,EAAAlD,UAEAhsB,EAAAgsB,WAEA,OAAA2L,KAAAhM,QAAA,GAAAtY,GAAAvI,QAAA8rB,KAAAe,EAAAtgB,EAAA3V,IAAA2R,GAAAvI,QAAA8rB,KAAA52B,EAAAqX,EAAA3V,IAAA2R,GAAAoa,YAAAwB,YAAAjvB,EAAA23B,EAAAz4B,KAAA2uB,iBAAA,IAAA7tB,EAAAwrB,WAAA,IAAAmM,EAAAnM,UACA,CACA,GAAAoM,GAAA14B,KAAAk3B,SAAAuB,EAAAtgB,EACAnY,MAAAu2B,QAAAnvB,EAAAsxB,EAAA53B,EAAAmrB,KAEA,MAAA7kB,IAEA+M,GAAAvI,QAAAnK,UAAAk3B,aAAA,WAEA,GAAAvxB,GAAA,GAAA+M,IAAA0Z,MAUA,OATAzmB,GAAA0mB,KAAA,EACA1mB,EAAAmhB,QAAA,EACAnhB,EAAAugB,QAAA,EACAvgB,EAAA2mB,UAAA,KACA3mB,EAAA4mB,IAAA,KACA5mB,EAAA6mB,SAAA,KACA7mB,EAAAggB,SAAA,KACApnB,KAAAqzB,WAAAjxB,KAAAgF,GACAA,EAAA0mB,IAAA9tB,KAAAqzB,WAAAjyB,OAAA,EACAgG,GAEA+M,GAAAvI,QAAAnK,UAAAy1B,SAAA,SAAAp2B,EAAAqX,GAEA,GAAAygB,GAAA93B,EAAAurB,MAAAlY,GAAAqX,SAAAC,MACA,IAAA3qB,EAAA2rB,OAAA,EACA,CACA,GAAA8I,GAAAv1B,KAAA24B,cACApD,GAAA5N,OAAA,IAAA7mB,EAAAwrB,SACA,IAAAuM,GAAA,GAAA1kB,IAAA+Z,KAYA,OAXAqH,GAAAvH,IAAA6K,EACAA,EAAA/K,IAAAyH,EAAAzH,IAEA+K,EAAAzL,GAAA9qB,EAAA6V,EAAA7V,EACAu2B,EAAAzL,GAAA5qB,EAAA2V,EAAA3V,EACAq2B,EAAAnM,KAAAmM,EACAA,EAAAlM,KAAAkM,EACAtD,EAAA5N,QACA3nB,KAAA84B,aAAAh4B,EAAAy0B,GACAz0B,EAAA2rB,OAAA8I,EAAAzH,IAEA+K,EAIA,GAAAtD,GAAAv1B,KAAAqzB,WAAAvyB,EAAA2rB,QAEA7O,EAAA2X,EAAAvH,GACA,IAAA4K,GAAAzkB,GAAAmV,SAAA3D,YAAAxN,EAAAyF,EAAAwP,IACA,MAAAxP,EACA,KAAAgb,GAAAzkB,GAAAmV,SAAA3D,YAAAxN,EAAAyF,EAAA+O,KAAAS,IACA,MAAAxP,GAAA+O,IACA,IAAAkM,GAAA,GAAA1kB,IAAA+Z,KAWA,OAVA2K,GAAA/K,IAAAyH,EAAAzH,IAEA+K,EAAAzL,GAAA9qB,EAAA6V,EAAA7V,EACAu2B,EAAAzL,GAAA5qB,EAAA2V,EAAA3V,EACAq2B,EAAAnM,KAAA9O,EACAib,EAAAlM,KAAA/O,EAAA+O,KACAkM,EAAAlM,KAAAD,KAAAmM,EACAjb,EAAA+O,KAAAkM,EACAD,IACArD,EAAAvH,IAAA6K,GACAA,GAGA1kB,GAAAvI,QAAAnK,UAAAs3B,WAAA,SAAA7I,EAAAC,GAEA,GAAA8C,GAAA,GAAA9e,IAAAmV,SAAA4G,EAAAY,MAEAZ,GAAAY,MAAAxuB,EAAA6tB,EAAAW,MAAAxuB,EACA4tB,EAAAY,MAAAtuB,EAAA2tB,EAAAW,MAAAtuB,EAEA2tB,EAAAW,MAAAxuB,EAAA2wB,EAAA3wB,EACA6tB,EAAAW,MAAAtuB,EAAAywB,EAAAzwB,GAEA2R,GAAAvI,QAAAnK,UAAA41B,oBAAA,SAAA2B,EAAAC,EAAAC,EAAAC,GAEA,GAAAlG,EAaA,OAZA+F,GAAAC,IAEAhG,EAAA+F,EACAA,EAAAC,EACAA,EAAAhG,GAEAiG,EAAAC,IAEAlG,EAAAiG,EACAA,EAAAC,EACAA,EAAAlG,GAEA+F,EAAAG,GAAAD,EAAAD,GAGA9kB,GAAAvI,QAAAnK,UAAAq3B,aAAA,SAAAh4B,EAAAy0B,GAIA,IAFA,GAAA6D,IAAA,EACAnJ,EAAAnvB,EAAAgsB,UACA,OAAAmD,GAEAA,EAAAxD,QAAA,MAAAwD,EAAA3D,YAEA8M,KACA,OAAA7D,EAAAxH,YACAwH,EAAAxH,UAAA/tB,KAAAqzB,WAAApD,EAAAxD,UAEAwD,IAAAnD,SAEAsM,KACA7D,EAAAhN,QAAA,IAEApU,GAAAvI,QAAAnK,UAAA43B,MAAA,SAAAnJ,EAAAC,GAEA,MAAAD,GAAA1tB,GAAA2tB,EAAA3tB,EACA2R,GAAAoa,YAAAO,YAEAqB,EAAA7tB,EAAA4tB,EAAA5tB,IAAA6tB,EAAA3tB,EAAA0tB,EAAA1tB,IAEA2R,GAAAvI,QAAAnK,UAAA63B,gBAAA,SAAAC,EAAAC,GAGA,IADA,GAAA94B,GAAA64B,EAAA5M,KACAxY,GAAAmV,SAAA3D,YAAAjlB,EAAA0sB,GAAAmM,EAAAnM,KAAA1sB,GAAA64B,GACA74B,IAAAisB,IACA,IAAA8M,GAAAlwB,KAAAsO,IAAA7X,KAAAq5B,MAAAE,EAAAnM,GAAA1sB,EAAA0sB,IAEA,KADA1sB,EAAA64B,EAAA7M,KACAvY,GAAAmV,SAAA3D,YAAAjlB,EAAA0sB,GAAAmM,EAAAnM,KAAA1sB,GAAA64B,GACA74B,IAAAgsB,IACA,IAAAgN,GAAAnwB,KAAAsO,IAAA7X,KAAAq5B,MAAAE,EAAAnM,GAAA1sB,EAAA0sB,IAEA,KADA1sB,EAAA84B,EAAA7M,KACAxY,GAAAmV,SAAA3D,YAAAjlB,EAAA0sB,GAAAoM,EAAApM,KAAA1sB,GAAA84B,GACA94B,IAAAisB,IACA,IAAAgN,GAAApwB,KAAAsO,IAAA7X,KAAAq5B,MAAAG,EAAApM,GAAA1sB,EAAA0sB,IAEA,KADA1sB,EAAA84B,EAAA9M,KACAvY,GAAAmV,SAAA3D,YAAAjlB,EAAA0sB,GAAAoM,EAAApM,KAAA1sB,GAAA84B,GACA94B,IAAAgsB,IACA,IAAAkN,GAAArwB,KAAAsO,IAAA7X,KAAAq5B,MAAAG,EAAApM,GAAA1sB,EAAA0sB,IACA,OAAAqM,IAAAE,GAAAF,GAAAG,GAAAF,GAAAC,GAAAD,GAAAE,GAEAzlB,GAAAvI,QAAAnK,UAAAo4B,YAAA,SAAArK,GAIA,IAFA,GAAAsK,GAAA,KACAp5B,EAAA8uB,EAAA9C,KACAhsB,GAAA8uB,GAEA9uB,EAAA0sB,GAAA5qB,EAAAgtB,EAAApC,GAAA5qB,GAEAgtB,EAAA9uB,EACAo5B,EAAA,MAEAp5B,EAAA0sB,GAAA5qB,GAAAgtB,EAAApC,GAAA5qB,GAAA9B,EAAA0sB,GAAA9qB,GAAAktB,EAAApC,GAAA9qB,IAEA5B,EAAA0sB,GAAA9qB,EAAAktB,EAAApC,GAAA9qB,GAEAw3B,EAAA,KACAtK,EAAA9uB,GAIAA,EAAAgsB,MAAA8C,GAAA9uB,EAAAisB,MAAA6C,IACAsK,EAAAp5B,IAGAA,IAAAgsB,IAEA,WAAAoN,EAGA,KAAAA,GAAAp5B,GAKA,IAHAV,KAAAs5B,gBAAA54B,EAAAo5B,KACAtK,EAAAsK,GACAA,IAAApN,KACAvY,GAAAmV,SAAAxD,cAAAgU,EAAA1M,GAAAoC,EAAApC,KACA0M,IAAApN,IAGA,OAAA8C,IAEArb,GAAAvI,QAAAnK,UAAAs4B,gBAAA,SAAAC,EAAAC,GAGA,OAAAD,EAAA/L,WACA+L,EAAA/L,SAAAjuB,KAAA65B,YAAAG,EAAAhM,MACA,OAAAiM,EAAAhM,WACAgM,EAAAhM,SAAAjuB,KAAA65B,YAAAI,EAAAjM,KACA,IAAAkM,GAAAF,EAAA/L,SACAkM,EAAAF,EAAAhM,QACA,OAAAiM,GAAA9M,GAAA5qB,EAAA23B,EAAA/M,GAAA5qB,EACAw3B,EACAE,EAAA9M,GAAA5qB,EAAA23B,EAAA/M,GAAA5qB,EACAy3B,EACAC,EAAA9M,GAAA9qB,EAAA63B,EAAA/M,GAAA9qB,EACA03B,EACAE,EAAA9M,GAAA9qB,EAAA63B,EAAA/M,GAAA9qB,EACA23B,EACAC,EAAAxN,MAAAwN,EACAD,EACAE,EAAAzN,MAAAyN,EACAH,EACAh6B,KAAAs5B,gBAAAY,EAAAC,GACAH,EAEAC,GAEA9lB,GAAAvI,QAAAnK,UAAA24B,oBAAA,SAAAJ,EAAAC,GAEA,EAEA,IADAD,IAAAjM,UACAiM,GAAAC,EACA,eAEA,OAAAD,EACA,WAEA7lB,GAAAvI,QAAAnK,UAAA44B,UAAA,SAAAC,GAGA,IADA,GAAAC,GAAAv6B,KAAAqzB,WAAAiH,GACAC,GAAAv6B,KAAAqzB,WAAAkH,EAAAzM,MACAyM,EAAAv6B,KAAAqzB,WAAAkH,EAAAzM,IACA,OAAAyM,IAEApmB,GAAAvI,QAAAnK,UAAA+2B,cAAA,SAAAxI,EAAAC,GAGA,GAEAuK,GAFAR,EAAAh6B,KAAAqzB,WAAArD,EAAAvD,QACAwN,EAAAj6B,KAAAqzB,WAAApD,EAAAxD,OAGA+N,GADAx6B,KAAAo6B,oBAAAJ,EAAAC,GACAA,EACAj6B,KAAAo6B,oBAAAH,EAAAD,GACAA,EAEAh6B,KAAA+5B,gBAAAC,EAAAC,EACA,IAIAQ,GAJAC,EAAAV,EAAAhM,IACA2M,EAAAD,EAAA/N,KACAiO,EAAAX,EAAAjM,IACA6M,EAAAD,EAAAjO,IAGAqD,GAAA3D,MAAAlY,GAAAqX,SAAAC,QAEAwE,EAAA5D,MAAAlY,GAAAqX,SAAAC,QAGAzrB,KAAAi2B,mBAAA2E,GACAA,EAAAlO,KAAAgO,EACAA,EAAA/N,KAAAiO,EACAD,EAAAjO,KAAAmO,EACAA,EAAAlO,KAAAgO,EACAX,EAAAhM,IAAA6M,IAKAA,EAAAnO,KAAAgO,EACAA,EAAA/N,KAAAkO,EACAD,EAAAjO,KAAAgO,EACAA,EAAAjO,KAAAkO,EACAZ,EAAAhM,IAAA4M,GAEAH,EAAAtmB,GAAAqX,SAAAC,SAIAwE,EAAA5D,MAAAlY,GAAAqX,SAAAE,SAGA1rB,KAAAi2B,mBAAA2E,GACAD,EAAAjO,KAAAmO,EACAA,EAAAlO,KAAAgO,EACAC,EAAAlO,KAAAgO,EACAA,EAAA/N,KAAAiO,IAKAD,EAAAjO,KAAAkO,EACAA,EAAAjO,KAAAgO,EACAD,EAAA/N,KAAAkO,EACAA,EAAAnO,KAAAgO,GAEAD,EAAAtmB,GAAAqX,SAAAE,SAEAsO,EAAA/L,SAAA,KACAuM,GAAAP,IAEAA,EAAAlM,WAAAiM,IACAA,EAAAjM,UAAAkM,EAAAlM,WACAiM,EAAAzR,OAAA0R,EAAA1R,QAEA0R,EAAAjM,IAAA,KACAiM,EAAAhM,SAAA,KACAgM,EAAAlM,UAAAiM,CACA,IAAAc,GAAA9K,EAAAvD,OACAsO,EAAA9K,EAAAxD,MACAuD,GAAAvD,QAAA,EAEAwD,EAAAxD,QAAA,CAEA,KADA,GAAA3rB,GAAAd,KAAAwzB,cACA,OAAA1yB,GACA,CACA,GAAAA,EAAA2rB,QAAAsO,EACA,CACAj6B,EAAA2rB,OAAAqO,EACAh6B,EAAAurB,KAAAoO,CACA,OAEA35B,IAAA+rB,UAEAoN,EAAAnM,IAAAkM,EAAAlM,KAEA3Z,GAAAvI,QAAAnK,UAAAw0B,mBAAA,SAAAzG,GAEA,UAAAA,EAAA,CAEA,GAAAwL,GACAvL,CACAuL,GAAAxL,CACA,GACAC,GAAAuL,EAAAtO,KACAsO,EAAAtO,KAAAsO,EAAArO,KACAqO,EAAArO,KAAA8C,EACAuL,EAAAvL,QAEAuL,GAAAxL,KAEArb,GAAAvI,QAAAqvB,UAAA,SAAA/C,EAAAC,GAEA,GAAAsC,GAAAvC,EAAA7L,IACA6L,GAAA7L,KAAA8L,EAAA9L,KACA8L,EAAA9L,KAAAoO,GAEAtmB,GAAAvI,QAAAsvB,gBAAA,SAAAhD,EAAAC,GAEA,GAAAgD,GAAAjD,EAAAzL,MACAyL,GAAAzL,OAAA0L,EAAA1L,OACA0L,EAAA1L,OAAA0O,GAEAhnB,GAAAvI,QAAAnK,UAAA61B,eAAA,SAAAtH,EAAAC,EAAA9X,GAIA,GAAAijB,GAAApL,EAAAvD,QAAA,EACA4O,EAAApL,EAAAxD,QAAA,CAKA,IAHAjK,IACAxiB,KAAA42B,KAAAze,EAAA6X,EAAAC,GAEAxN,KAGA,IAAAuN,EAAA1D,WAAA,IAAA2D,EAAA3D,WACA,CAGA,MAAA0D,EAAA1D,WAAA,GAAA2D,EAAA3D,UAAA,MAyCA,aAvCA0D,EAAA5D,SAAA6D,EAAA7D,SACA4D,EAAA1D,WAAA2D,EAAA3D,WAAAtsB,KAAAszB,YAAAnf,GAAA/H,SAAAC,QAEA,IAAA2jB,EAAA1D,UAEA+O,IAEAr7B,KAAAk3B,SAAAlH,EAAA7X,GACAijB,IACApL,EAAAvD,QAAA,IAKA2O,IAEAp7B,KAAAk3B,SAAAjH,EAAA9X,GACAkjB,IACApL,EAAAxD,QAAA,IAIAuD,EAAA5D,SAAA6D,EAAA7D,UAEA,IAAA4D,EAAA1D,WAAA,GAAA/iB,KAAAsO,IAAAoY,EAAA1D,UACAvsB,KAAAszB,YAAAnf,GAAA/H,SAAAC,SAAA,IAAA4jB,EAAAzD,SAMA,IAAAyD,EAAA3D,WAAA,GAAA/iB,KAAAsO,IAAAmY,EAAAzD,UACAvsB,KAAAszB,YAAAnf,GAAA/H,SAAAC,SAAA,IAAA2jB,EAAAxD,WAEAxsB,KAAAk3B,SAAAjH,EAAA9X,GACAkjB,IACApL,EAAAxD,QAAA,KATAzsB,KAAAk3B,SAAAlH,EAAA7X,GACAijB,IACApL,EAAAvD,QAAA,MAeA,GAAAuD,EAAA5D,SAAA6D,EAAA7D,QAEA,GAAApsB,KAAA23B,kBAAA3H,GACA,CACA,GAAAsL,GAAAtL,EAAAzD,OACAyD,GAAAzD,QAAA0D,EAAA1D,QACA0D,EAAA1D,QAAA+O,MAIAtL,GAAAzD,QAAA0D,EAAA3D,YAAA,EACA0D,EAAAzD,SAAAyD,EAAAzD,QAEAyD,EAAAzD,SAAA0D,EAAA3D,UACA2D,EAAA1D,QAAAyD,EAAA1D,YAAA,EACA2D,EAAA1D,SAAA0D,EAAA1D,QAEA0D,EAAA1D,SAAAyD,EAAA1D,cAKAtsB,MAAA23B,kBAAA1H,GAGAD,EAAAxD,SAAA,IAAAwD,EAAAxD,SAAA,IAFAwD,EAAAxD,UAAAyD,EAAA3D,UAGAtsB,KAAA23B,kBAAA3H,GAGAC,EAAAzD,SAAA,IAAAyD,EAAAzD,SAAA,IAFAyD,EAAAzD,UAAAwD,EAAA1D,SAIA,IAAAiP,GAAAC,EAAAC,EAAAC,CACA1L,GAAA5D,SAAAjY,GAAAlI,SAAAC,WAEAqvB,EAAAv7B,KAAA8zB,eACA2H,EAAAz7B,KAAA6zB,iBAIA0H,EAAAv7B,KAAA6zB,eACA4H,EAAAz7B,KAAA8zB,gBAEA7D,EAAA7D,SAAAjY,GAAAlI,SAAAC,WAEAsvB,EAAAx7B,KAAA8zB,eACA4H,EAAA17B,KAAA6zB,iBAIA2H,EAAAx7B,KAAA6zB,eACA6H,EAAA17B,KAAA8zB,eAEA,IAAA6H,GAAAC,CACA,QAAAL,GAEA,IAAApnB,IAAA7I,aAAAsf,YACA+Q,EAAA3L,EAAAzD,OACA,MACA,KAAApY,IAAA7I,aAAAuf,YACA8Q,GAAA3L,EAAAzD,OACA,MACA,SACAoP,EAAApyB,KAAAsO,IAAAmY,EAAAzD,SAGA,OAAAiP,GAEA,IAAArnB,IAAA7I,aAAAsf,YACAgR,EAAA3L,EAAA1D,OACA,MACA,KAAApY,IAAA7I,aAAAuf,YACA+Q,GAAA3L,EAAA1D,OACA,MACA,SACAqP,EAAAryB,KAAAsO,IAAAoY,EAAA1D,SAGA,GAAA6O,GAAAC,EAEA,GAAAM,GAAA,GAAAA,GAAA,GAAAC,GAAA,GAAAA,GACA5L,EAAA5D,SAAA6D,EAAA7D,SAAApsB,KAAAszB,YAAAnf,GAAA/H,SAAAse,MAEA1qB,KAAAu4B,gBAAAvI,EAAAC,EAAA9X,IAIAnY,KAAAk3B,SAAAlH,EAAA7X,GACAnY,KAAAk3B,SAAAjH,EAAA9X,GACAhE,GAAAvI,QAAAqvB,UAAAjL,EAAAC,GACA9b,GAAAvI,QAAAsvB,gBAAAlL,EAAAC,QAGA,IAAAmL,EAEA,IAAAQ,GAAA,GAAAA,IAEA57B,KAAAk3B,SAAAlH,EAAA7X,GACAhE,GAAAvI,QAAAqvB,UAAAjL,EAAAC,GACA9b,GAAAvI,QAAAsvB,gBAAAlL,EAAAC,QAGA,IAAAoL,EAEA,IAAAM,GAAA,GAAAA,IAEA37B,KAAAk3B,SAAAjH,EAAA9X,GACAhE,GAAAvI,QAAAqvB,UAAAjL,EAAAC,GACA9b,GAAAvI,QAAAsvB,gBAAAlL,EAAAC,QAGA,SAAA0L,GAAA,GAAAA,GAAA,GAAAC,GAAA,GAAAA,GACA,CAEA,GAAAC,GAAAC,CACA,QAAAL,GAEA,IAAAtnB,IAAA7I,aAAAsf,YACAiR,EAAA7L,EAAAxD,QACA,MACA,KAAArY,IAAA7I,aAAAuf,YACAgR,GAAA7L,EAAAxD,QACA,MACA,SACAqP,EAAAtyB,KAAAsO,IAAAmY,EAAAxD,UAGA,OAAAkP,GAEA,IAAAvnB,IAAA7I,aAAAsf,YACAkR,EAAA7L,EAAAzD,QACA,MACA,KAAArY,IAAA7I,aAAAuf,YACAiR,GAAA7L,EAAAzD,QACA,MACA,SACAsP,EAAAvyB,KAAAsO,IAAAoY,EAAAzD,UAGA,GAAAwD,EAAA5D,SAAA6D,EAAA7D,QAEApsB,KAAAm3B,gBAAAnH,EAAAC,EAAA9X,OAEA,OAAAwjB,GAAA,GAAAC,EACA,OAAA57B,KAAAszB,YAEA,IAAAnf,IAAA/H,SAAAoe,eACAqR,EAAA,GAAAC,EAAA,GACA97B,KAAAm3B,gBAAAnH,EAAAC,EAAA9X,EACA,MACA,KAAAhE,IAAA/H,SAAAC,QACAwvB,GAAA,GAAAC,GAAA,GACA97B,KAAAm3B,gBAAAnH,EAAAC,EAAA9X,EACA,MACA,KAAAhE,IAAA/H,SAAAqe,cACAuF,EAAA5D,SAAAjY,GAAAlI,SAAA0e,QAAAkR,EAAA,GAAAC,EAAA,GACA9L,EAAA5D,SAAAjY,GAAAlI,SAAAC,WAAA2vB,GAAA,GAAAC,GAAA,IACA97B,KAAAm3B,gBAAAnH,EAAAC,EAAA9X,EACA,MACA,KAAAhE,IAAA/H,SAAAse,MACA1qB,KAAAm3B,gBAAAnH,EAAAC,EAAA9X,OAIAhE,IAAAvI,QAAAqvB,UAAAjL,EAAAC,KAGA9b,GAAAvI,QAAAnK,UAAAs6B,cAAA,SAAAj7B,GAEA,GAAAk7B,GAAAl7B,EAAAgsB,UACAmP,EAAAn7B,EAAA+rB,SACA,QAAAmP,GAAA,OAAAC,GAAAn7B,GAAAd,KAAAwzB,gBAGA,OAAAwI,EACAA,EAAAnP,UAAAoP,EAEAj8B,KAAAwzB,cAAAyI,EACA,OAAAA,IACAA,EAAAnP,UAAAkP,GACAl7B,EAAA+rB,UAAA,KACA/rB,EAAAgsB,UAAA,OAEA3Y,GAAAvI,QAAAnK,UAAAy6B,cAAA,SAAAp7B,GAEA,GAAAq7B,GAAAr7B,EAAAksB,UACAoP,EAAAt7B,EAAAisB,SACA,QAAAoP,GAAA,OAAAC,GAAAt7B,GAAAd,KAAAyzB,gBAGA,OAAA0I,EACAA,EAAApP,UAAAqP,EAEAp8B,KAAAyzB,cAAA2I,EACA,OAAAA,IACAA,EAAApP,UAAAmP,GACAr7B,EAAAisB,UAAA,KACAjsB,EAAAksB,UAAA,OAEA7Y,GAAAvI,QAAAnK,UAAA46B,kBAAA,SAAAv7B,GAEA,OAAAA,EAAA8rB,WACAzY,GAAAnS,MAAA,kCACA,IAAAg6B,GAAAl7B,EAAAgsB,UACAmP,EAAAn7B,EAAA+rB,SAoBA,OAnBA/rB,GAAA8rB,UAAAH,OAAA3rB,EAAA2rB,OACA,OAAAuP,EACAA,EAAAnP,UAAA/rB,EAAA8rB,UAEA5sB,KAAAwzB,cAAA1yB,EAAA8rB,UACA,OAAAqP,IACAA,EAAAnP,UAAAhsB,EAAA8rB,WACA9rB,EAAA8rB,UAAAP,KAAAvrB,EAAAurB,KACAvrB,EAAA8rB,UAAAN,UAAAxrB,EAAAwrB,UACAxrB,EAAA8rB,UAAAL,QAAAzrB,EAAAyrB,QACAzrB,EAAA8rB,UAAAJ,SAAA1rB,EAAA0rB,SACA1rB,IAAA8rB,UAEA9rB,EAAAkrB,KAAA1pB,EAAAxB,EAAAirB,IAAAzpB,EACAxB,EAAAkrB,KAAAxpB,EAAA1B,EAAAirB,IAAAvpB,EACA1B,EAAAgsB,UAAAkP,EACAl7B,EAAA+rB,UAAAoP,EACA9nB,GAAAoa,YAAAe,aAAAxuB,IACAd,KAAA00B,eAAA5zB,EAAAmrB,IAAAzpB,GACA1B,GAEAqT,GAAAvI,QAAAnK,UAAAm0B,mBAAA,SAAA0G,GAGA,IADA,GAAAC,GAAAv8B,KAAAyzB,cACA,OAAA8I,GAEAv8B,KAAAk8B,cAAAK,GACAv8B,KAAAw8B,kBAAAD,EAAAD,GACAC,EAAAv8B,KAAAyzB,eAGAtf,GAAAvI,QAAAnK,UAAAg7B,iBAAA,SAAAC,EAAAC,GAEAD,EAAA3Q,IAAAzpB,EAAAo6B,EAAAzQ,IAAA3pB,GAEAq6B,EAAAC,KAAAF,EAAA3Q,IAAAzpB,EACAq6B,EAAAE,MAAAH,EAAAzQ,IAAA3pB,EACAq6B,EAAAG,IAAA3oB,GAAAwX,UAAAE,eAIA8Q,EAAAC,KAAAF,EAAAzQ,IAAA3pB,EACAq6B,EAAAE,MAAAH,EAAA3Q,IAAAzpB,EACAq6B,EAAAG,IAAA3oB,GAAAwX,UAAAC,eAGAzX,GAAAvI,QAAAnK,UAAA+6B,kBAAA,SAAAD,EAAAD,GAEA,GAAAK,IAAgBG,IAAA,KAAAF,KAAA,KAAAC,MAAA,KAChB78B,MAAAy8B,iBAAAF,EAAAI,EAOA,KANA,GAAAI,GAAAJ,EAAAG,IACAE,EAAAL,EAAAC,KACAK,EAAAN,EAAAE,MAEAK,EAAAX,EACAY,EAAA,KACA,OAAAD,EAAAtQ,WAAAzY,GAAAoa,YAAAe,aAAA4N,EAAAtQ,YACAsQ,IAAAtQ,SAGA,KAFA,OAAAsQ,EAAAtQ,YACAuQ,EAAAn9B,KAAAo9B,cAAAF,MAEA,CAGA,IAFA,GAAAG,GAAAd,GAAAW,EACAp8B,EAAAd,KAAAs9B,aAAAf,EAAAQ,GACA,OAAAj8B,KAIAA,EAAAkrB,KAAA1pB,GAAAi6B,EAAAtQ,IAAA3pB,GAAA,OAAAi6B,EAAA3P,WAAA9rB,EAAAqrB,GAAAoQ,EAAA3P,UAAAT,KAHA,CAKA,GAAA6E,GAAAhxB,KAAAs9B,aAAAx8B,EAAAi8B,EAEA,IAAAA,GAAA5oB,GAAAwX,UAAAE,cAAA/qB,EAAAkrB,KAAA1pB,GAAA26B,GAAAF,GAAA5oB,GAAAwX,UAAAC,cAAA9qB,EAAAkrB,KAAA1pB,GAAA06B,EACA,CAGA,GAAAl8B,GAAAq8B,GAAAE,EACA,CACA,GAAAd,EAAA9P,QAAA,EACA,CAGA,IAFA,GAAA8Q,GAAAv9B,KAAAk3B,SAAAqF,IAAAtQ,KACAuR,EAAAx9B,KAAAyzB,cACA,OAAA+J,GACA,CACA,GAAAA,EAAA/Q,QAAA,GACAzsB,KAAAq3B,oBAAAkF,EAAAxQ,IAAAzpB,EACAi6B,EAAAtQ,IAAA3pB,EAAAk7B,EAAAzR,IAAAzpB,EAAAk7B,EAAAvR,IAAA3pB,GACA,CACA,GAAAm7B,GAAAz9B,KAAAk3B,SAAAsG,IAAAzR,IACA/rB,MAAAu2B,QAAAkH,EAAAF,EAAAC,EAAAvR,KAEAuR,IAAAzQ,UAEA/sB,KAAA02B,aAAA6G,EAAAhB,EAAAxQ,KACA/rB,KAAAu4B,gBAAAgE,EAAAY,EAAAZ,EAAAtQ,KAIA,MAFAjsB,MAAA+7B,cAAAQ,OACAv8B,MAAA+7B,cAAAoB,GAGA,GAAAJ,GAAA5oB,GAAAwX,UAAAE,aACA,CACA,GAAAuB,GAAA,GAAAjZ,IAAAmV,SAAAxoB,EAAAkrB,KAAA1pB,EAAAi6B,EAAAvQ,KAAAxpB,EACAxC,MAAAs3B,eAAAiF,EAAAz7B,EAAAssB,OAGA,CACA,GAAAA,GAAA,GAAAjZ,IAAAmV,SAAAxoB,EAAAkrB,KAAA1pB,EAAAi6B,EAAAvQ,KAAAxpB,EACAxC,MAAAs3B,eAAAx2B,EAAAy7B,EAAAnP,GAEAptB,KAAAi4B,mBAAAsE,EAAAz7B,OAEA,IAAAi8B,GAAA5oB,GAAAwX,UAAAE,cAAA/qB,EAAAkrB,KAAA1pB,GAAA26B,GAAAF,GAAA5oB,GAAAwX,UAAAC,cAAA9qB,EAAAkrB,KAAA1pB,GAAA06B,EACA,KACAl8B,GAAAkwB,EAGA,UAAAuL,EAAA3P,YAAAzY,GAAAoa,YAAAe,aAAAiN,EAAA3P,WAaA,KAXA2P,GAAAv8B,KAAAq8B,kBAAAE,GACAA,EAAA9P,QAAA,GACAzsB,KAAAk3B,SAAAqF,IAAAxQ,IAEA,IAAA4Q,IAAsBG,IAAAC,EAAAH,KAAAI,EAAAH,MAAAI,EACtBj9B,MAAAy8B,iBAAAF,EAAAI,GACAI,EAAAJ,EAAAG,IACAE,EAAAL,EAAAC,KACAK,EAAAN,EAAAE,MAMA,UAAAN,EAAA3P,UAEA,GAAA2P,EAAA9P,QAAA,EACA,CACA,GAAA8Q,GAAAv9B,KAAAk3B,SAAAqF,IAAAtQ,IAGA,IAFAqQ,GAAAt8B,KAAA02B,aAAA6G,EAAAhB,EAAAxQ,KACAwQ,EAAAv8B,KAAAq8B,kBAAAE,GACA,IAAAA,EAAAjQ,UACA,MAEA,IAAA2E,GAAAsL,EAAAzP,UACAkE,EAAAuL,EAAA1P,SACA,WAAAoE,KAAAjF,KAAA1pB,GAAAi6B,EAAAxQ,IAAAzpB,GACA2uB,EAAAjF,KAAAxpB,GAAA+5B,EAAAxQ,IAAAvpB,GAAA,IAAAyuB,EAAA3E,WACA2E,EAAAxE,QAAA,GAAAwE,EAAAjF,KAAAxpB,EAAAyuB,EAAAhF,IAAAzpB,GACA2R,GAAAoa,YAAAwB,YAAAwM,EAAAtL,EAAAjxB,KAAA2uB,gBACA,CACA,GAAA8O,GAAAz9B,KAAAk3B,SAAAjG,EAAAsL,EAAAxQ,IACA/rB,MAAAu2B,QAAAgH,EAAAE,EAAAlB,EAAAtQ,SAEA,WAAA+E,KAAAhF,KAAA1pB,GAAAi6B,EAAAxQ,IAAAzpB,GACA0uB,EAAAhF,KAAAxpB,GAAA+5B,EAAAxQ,IAAAvpB,GAAA,IAAAwuB,EAAA1E,WACA0E,EAAAvE,QAAA,GAAAuE,EAAAhF,KAAAxpB,EAAAwuB,EAAA/E,IAAAzpB,GACA2R,GAAAoa,YAAAwB,YAAAwM,EAAAvL,EAAAhxB,KAAA2uB,gBACA,CACA,GAAA8O,GAAAz9B,KAAAk3B,SAAAlG,EAAAuL,EAAAxQ,IACA/rB,MAAAu2B,QAAAgH,EAAAE,EAAAlB,EAAAtQ,UAGAsQ,GAAAv8B,KAAAq8B,kBAAAE,OAIAA,GAAA9P,QAAA,GACAzsB,KAAAk3B,SAAAqF,IAAAtQ,KACAjsB,KAAA+7B,cAAAQ,IAGApoB,GAAAvI,QAAAnK,UAAA67B,aAAA,SAAAx8B,EAAA6qB,GAEA,MAAAA,IAAAxX,GAAAwX,UAAAE,aAAA/qB,EAAA+rB,UAAA/rB,EAAAgsB,WAEA3Y,GAAAvI,QAAAnK,UAAAi8B,SAAA,SAAA58B,GAEA,cAAAA,KAAA6rB,KAAAC,WAAA9rB,KAAA4rB,KAAAE,WAAA9rB,GAEAqT,GAAAvI,QAAAnK,UAAAk8B,SAAA,SAAA78B,EAAA0B,GAEA,cAAA1B,KAAAmrB,IAAAzpB,MAAA,OAAA1B,EAAA8rB,WAEAzY,GAAAvI,QAAAnK,UAAAm8B,eAAA,SAAA98B,EAAA0B,GAEA,MAAA1B,GAAAmrB,IAAAzpB,MAAA,OAAA1B,EAAA8rB,WAEAzY,GAAAvI,QAAAnK,UAAA27B,cAAA,SAAAt8B,GAEA,GAAAsG,GAAA,IAKA,OAJA+M,IAAAmV,SAAA3D,YAAA7kB,EAAA4rB,KAAAT,IAAAnrB,EAAAmrB,MAAA,OAAAnrB,EAAA4rB,KAAAE,UACAxlB,EAAAtG,EAAA4rB,KACAvY,GAAAmV,SAAA3D,YAAA7kB,EAAA6rB,KAAAV,IAAAnrB,EAAAmrB,MAAA,OAAAnrB,EAAA6rB,KAAAC,YACAxlB,EAAAtG,EAAA6rB,MACA,OAAAvlB,KAAAqlB,SAAA,IAAArlB,EAAAylB,WAAAzlB,EAAA0lB,WAAA3Y,GAAAoa,YAAAe,aAAAloB,IAEAA,EADA,MAIA+M,GAAAvI,QAAAnK,UAAAq0B,qBAAA,SAAAD,GAEA,SAAA71B,KAAAwzB,cACA,QACA,KAGA,GADAxzB,KAAA69B,mBAAAhI,GACA,GAAA71B,KAAA0zB,gBAAAtyB,OACA,QACA,OAAApB,KAAA0zB,gBAAAtyB,SAAApB,KAAA89B,yBAGA,QAFA99B,MAAA+9B,uBAIA,MAAAC,GAEAh+B,KAAAyzB,cAAA,KACAzzB,KAAA0zB,gBAAAtyB,OAAA,EACA+S,GAAAnS,MAAA,8BAGA,MADAhC,MAAAyzB,cAAA,MACA,GAEAtf,GAAAvI,QAAAnK,UAAAo8B,mBAAA,SAAAhI,GAEA,UAAA71B,KAAAwzB,cAAA,CAGA,GAAA1yB,GAAAd,KAAAwzB,aAGA,KADAxzB,KAAAyzB,cAAA3yB,EACA,OAAAA,GAEAA,EAAAksB,UAAAlsB,EAAAgsB,UACAhsB,EAAAisB,UAAAjsB,EAAA+rB,UACA/rB,EAAAkrB,KAAA1pB,EAAA6R,GAAAvI,QAAA8rB,KAAA52B,EAAA+0B,GACA/0B,IAAA+rB,SAIA,KADA,GAAAoR,IAAA,EACAA,GAAA,OAAAj+B,KAAAyzB,eACA,CAGA,IAFAwK,GAAA,EACAn9B,EAAAd,KAAAyzB,cACA,OAAA3yB,EAAAisB,WACA,CACA,GAAAiE,GAAAlwB,EAAAisB,UACA5U,EAAA,GAAAhE,IAAAmV,QAEA,IAAAxoB,EAAAkrB,KAAA1pB,EAAA0uB,EAAAhF,KAAA1pB,EACA,CACAtC,KAAAk+B,eAAAp9B,EAAAkwB,EAAA7Y,EACA,IAAAgmB,GAAA,GAAAhqB,IAAA8Y,aACAkR,GAAAjR,MAAApsB,EACAq9B,EAAAhR,MAAA6D,EAEAmN,EAAA/Q,GAAA9qB,EAAA6V,EAAA7V,EACA67B,EAAA/Q,GAAA5qB,EAAA2V,EAAA3V,EACAxC,KAAA0zB,gBAAAtxB,KAAA+7B,GACAn+B,KAAAs4B,mBAAAx3B,EAAAkwB,GACAiN,GAAA,MAGAn9B,GAAAkwB,EAEA,UAAAlwB,EAAAksB,UAGA,KAFAlsB,GAAAksB,UAAAD,UAAA,KAIA/sB,KAAAyzB,cAAA,OAEAtf,GAAAvI,QAAAnK,UAAA28B,cAAA,SAAAC,GAEA,MAAAA,GAAAnR,MAAAH,WAAAsR,EAAAlR,OAAAkR,EAAAnR,MAAAF,WAAAqR,EAAAlR,OAEAhZ,GAAAvI,QAAA0yB,kBAAA,SAAA/Q,EAAAC,GAIA,MAAAA,GAAAJ,GAAA5qB,EAAA+qB,EAAAH,GAAA5qB,GAEA2R,GAAAvI,QAAAnK,UAAAq8B,uBAAA,WAKA99B,KAAA0zB,gBAAA6K,KAAAv+B,KAAA2zB,yBACA3zB,KAAAg4B,cAEA,QADA9P,GAAAloB,KAAA0zB,gBAAAtyB,OACAP,EAAA,EAAmBA,EAAAqnB,EAASrnB,IAC5B,CACA,IAAAb,KAAAo+B,cAAAp+B,KAAA0zB,gBAAA7yB,IACA,CAEA,IADA,GAAA6T,GAAA7T,EAAA,EACA6T,EAAAwT,IAAAloB,KAAAo+B,cAAAp+B,KAAA0zB,gBAAAhf,KACAA,GACA,IAAAA,GAAAwT,EACA,QACA,IAAA+K,GAAAjzB,KAAA0zB,gBAAA7yB,EACAb,MAAA0zB,gBAAA7yB,GAAAb,KAAA0zB,gBAAAhf,GACA1U,KAAA0zB,gBAAAhf,GAAAue,EAEAjzB,KAAAs4B,mBAAAt4B,KAAA0zB,gBAAA7yB,GAAAqsB,MAAAltB,KAAA0zB,gBAAA7yB,GAAAssB,OAEA,UAEAhZ,GAAAvI,QAAAnK,UAAAs8B,qBAAA,WAEA,OAAAl9B,GAAA,EAAA4nB,EAAAzoB,KAAA0zB,gBAAAtyB,OAAuDP,EAAA4nB,EAAU5nB,IACjE,CACA,GAAA29B,GAAAx+B,KAAA0zB,gBAAA7yB,EACAb,MAAAs3B,eAAAkH,EAAAtR,MAAAsR,EAAArR,MAAAqR,EAAApR,IACAptB,KAAAi4B,mBAAAuG,EAAAtR,MAAAsR,EAAArR,OAEAntB,KAAA0zB,gBAAAtyB,OAAA,EAOA,IAAAq9B,IAAA,SAAAxqB,GAEA,MAAAA,GAAA,EAAA1K,KAAA2f,KAAAjV,EAAA,IAAA1K,KAAAm1B,MAAAzqB,IAEA0qB,GAAA,SAAA1qB,GAEA,MAAAA,GAAA,EAAA1K,KAAA2f,KAAAjV,EAAA,IAAA1K,KAAAqL,MAAAX,EAAA,KAEA2qB,GAAA,SAAA3qB,GAEA,MAAAA,GAAA,GAAA1K,KAAAm1B,MAAAn1B,KAAAsO,IAAA5D,IAAA1K,KAAAm1B,MAAAzqB,IAEA4qB,GAAA,SAAA5qB,GAEA,MAAAA,GAAA,GAEAA,GAAA,GACAA,GAAA,WAAA1K,KAAA2f,KAAAjV,GAAA,EAAAA,IAIAA,GAAA,GACAA,EAAA,WAAA1K,KAAAqL,MAAAX,GAAA,EAAAA,GAGAiP,IAAAa,KAAA5P,GAAAvI,QAAA6d,MAAAgV,GACAvb,GAAAE,SAAAjP,GAAAvI,QAAA6d,MAAAmV,GACA1b,GAAAG,OAAAlP,GAAAvI,QAAA6d,MAAAoV,GACA1qB,GAAAvI,QAAA6d,MAAAkV,GACAxqB,GAAAvI,QAAA8rB,KAAA,SAAAH,EAAAuH,GAIA,MAAAA,IAAAvH,EAAAtL,IAAAzpB,EACA+0B,EAAAtL,IAAA3pB,EACAi1B,EAAAxL,IAAAzpB,EAAA6R,GAAAvI,QAAA6d,MAAA8N,EAAApL,IAAA2S,EAAAvH,EAAAxL,IAAAvpB,KAEA2R,GAAAvI,QAAAnK,UAAAy8B,eAAA,SAAAhG,EAAAC,EAAA4G,GAEAA,EAAAz8B,EAAA,EACAy8B,EAAAv8B,EAAA,CACA,IAAAw8B,GAAAC,CAGA,IAAA/G,EAAA/L,IAAAgM,EAAAhM,GAIA,MAFA4S,GAAAv8B,EAAA01B,EAAAlM,KAAAxpB,OACAu8B,EAAAz8B,EAAA6R,GAAAvI,QAAA8rB,KAAAQ,EAAA6G,EAAAv8B,GAGA,QAAA01B,EAAAhM,MAAA5pB,EAEAy8B,EAAAz8B,EAAA41B,EAAAnM,IAAAzpB,EACA6R,GAAAoa,YAAAe,aAAA6I,GAEA4G,EAAAv8B,EAAA21B,EAAApM,IAAAvpB,GAIAy8B,EAAA9G,EAAApM,IAAAvpB,EAAA21B,EAAApM,IAAAzpB,EAAA61B,EAAAhM,GACA4S,EAAAv8B,EAAA2R,GAAAvI,QAAA6d,MAAAsV,EAAAz8B,EAAA61B,EAAAhM,GAAA8S,QAGA,QAAA9G,EAAAjM,MAAA5pB,EAEAy8B,EAAAz8B,EAAA61B,EAAApM,IAAAzpB,EACA6R,GAAAoa,YAAAe,aAAA4I,GAEA6G,EAAAv8B,EAAA01B,EAAAnM,IAAAvpB,GAIAw8B,EAAA9G,EAAAnM,IAAAvpB,EAAA01B,EAAAnM,IAAAzpB,EAAA41B,EAAA/L,GACA4S,EAAAv8B,EAAA2R,GAAAvI,QAAA6d,MAAAsV,EAAAz8B,EAAA41B,EAAA/L,GAAA6S,QAIA,CACAA,EAAA9G,EAAAnM,IAAAzpB,EAAA41B,EAAAnM,IAAAvpB,EAAA01B,EAAA/L,GACA8S,EAAA9G,EAAApM,IAAAzpB,EAAA61B,EAAApM,IAAAvpB,EAAA21B,EAAAhM,EACA,IAAAlU,IAAAgnB,EAAAD,IAAA9G,EAAA/L,GAAAgM,EAAAhM,GACA4S,GAAAv8B,EAAA2R,GAAAvI,QAAA6d,MAAAxR,GACA1O,KAAAsO,IAAAqgB,EAAA/L,IAAA5iB,KAAAsO,IAAAsgB,EAAAhM,IACA4S,EAAAz8B,EAAA6R,GAAAvI,QAAA6d,MAAAyO,EAAA/L,GAAAlU,EAAA+mB,GAEAD,EAAAz8B,EAAA6R,GAAAvI,QAAA6d,MAAA0O,EAAAhM,GAAAlU,EAAAgnB,GAEA,GAAAF,EAAAv8B,EAAA01B,EAAAjM,IAAAzpB,GAAAu8B,EAAAv8B,EAAA21B,EAAAlM,IAAAzpB,EACA,CACA,GAAA01B,EAAAjM,IAAAzpB,EAAA21B,EAAAlM,IAAAzpB,EAIA,MAFAu8B,GAAAv8B,EAAA01B,EAAAjM,IAAAzpB,EACAu8B,EAAAz8B,EAAA6R,GAAAvI,QAAA8rB,KAAAS,EAAAD,EAAAjM,IAAAzpB,GACAu8B,EAAAz8B,EAAA41B,EAAAjM,IAAA3pB,CAGAy8B,GAAAv8B,EAAA21B,EAAAlM,IAAAzpB,EACA+G,KAAAsO,IAAAqgB,EAAA/L,IAAA5iB,KAAAsO,IAAAsgB,EAAAhM,IACA4S,EAAAz8B,EAAA6R,GAAAvI,QAAA8rB,KAAAQ,EAAA6G,EAAAv8B,GAEAu8B,EAAAz8B,EAAA6R,GAAAvI,QAAA8rB,KAAAS,EAAA4G,EAAAv8B,GAGAu8B,EAAAv8B,EAAA01B,EAAAlM,KAAAxpB,IAEAu8B,EAAAv8B,EAAA01B,EAAAlM,KAAAxpB,EAEA+G,KAAAsO,IAAAqgB,EAAA/L,IAAA5iB,KAAAsO,IAAAsgB,EAAAhM,IACA4S,EAAAz8B,EAAA6R,GAAAvI,QAAA8rB,KAAAS,EAAA4G,EAAAv8B,GAEAu8B,EAAAz8B,EAAA6R,GAAAvI,QAAA8rB,KAAAQ,EAAA6G,EAAAv8B,KAIA2R,GAAAvI,QAAAnK,UAAAs0B,4BAAA,SAAAF,GAGA,IADA,GAAA/0B,GAAAd,KAAAwzB,cACA,OAAA1yB,GACA,CAGA,GAAAo+B,GAAAl/B,KAAA29B,SAAA78B,EAAA+0B,EACA,IAAAqJ,EACA,CACA,GAAA/B,GAAAn9B,KAAAo9B,cAAAt8B,EACAo+B,GAAA,OAAA/B,IAAAhpB,GAAAoa,YAAAe,aAAA6N,GAEA,GAAA+B,EACA,CACA,GAAAjO,GAAAnwB,EAAAgsB,SACA9sB,MAAAm/B,SAAAr+B,GAEAA,EADA,OAAAmwB,EACAjxB,KAAAwzB,cAEAvC,EAAApE,cAGA,CAcA,GAZA7sB,KAAA49B,eAAA98B,EAAA+0B,IAAA1hB,GAAAoa,YAAAe,aAAAxuB,EAAA8rB,YAEA9rB,EAAAd,KAAAq8B,kBAAAv7B,GACAA,EAAA2rB,QAAA,GACAzsB,KAAAk3B,SAAAp2B,IAAAirB,KACA/rB,KAAAo3B,aAAAt2B,KAIAA,EAAAkrB,KAAA1pB,EAAA6R,GAAAvI,QAAA8rB,KAAA52B,EAAA+0B,GACA/0B,EAAAkrB,KAAAxpB,EAAAqzB,GAEA71B,KAAA0M,eACA,CACA,GAAAukB,GAAAnwB,EAAAgsB,SACA,IAAAhsB,EAAA2rB,QAAA,OAAA3rB,EAAAwrB,WAAA,OAAA2E,GACAA,EAAAxE,QAAA,GAAAwE,EAAAjF,KAAA1pB,GAAAxB,EAAAkrB,KAAA1pB,GACA,IAAA2uB,EAAA3E,UACA,CACA,GAAAyS,GAAA,GAAA5qB,IAAAmV,SAAAxoB,EAAAkrB,KAEAxJ,KAEAxiB,KAAA42B,KAAAmI,EAAA9N,EAAAnwB,EAGA,IAAA8c,GAAA5d,KAAAk3B,SAAAjG,EAAA8N,GACAtB,EAAAz9B,KAAAk3B,SAAAp2B,EAAAi+B,EACA/+B,MAAAu2B,QAAA3Y,EAAA6f,EAAAsB,IAIAj+B,IAAA+rB,WAOA,IAHA7sB,KAAA41B,oBAAA,GAEA90B,EAAAd,KAAAwzB,cACA,OAAA1yB,GACA,CACA,GAAAd,KAAA49B,eAAA98B,EAAA+0B,GACA,CACA,GAAAjY,GAAA,IACA9c,GAAA2rB,QAAA,IACA7O,EAAA5d,KAAAk3B,SAAAp2B,IAAAmrB,MACAnrB,EAAAd,KAAAq8B,kBAAAv7B,EAEA,IAAAmwB,GAAAnwB,EAAAgsB,UACAkE,EAAAlwB,EAAA+rB,SACA,WAAAoE,KAAAjF,KAAA1pB,GAAAxB,EAAAirB,IAAAzpB,GACA2uB,EAAAjF,KAAAxpB,GAAA1B,EAAAirB,IAAAvpB,GAAA,OAAAob,GACAqT,EAAAxE,QAAA,GAAAwE,EAAAjF,KAAAxpB,EAAAyuB,EAAAhF,IAAAzpB,GACA2R,GAAAoa,YAAAwB,YAAAjvB,EAAAmwB,EAAAjxB,KAAA2uB,iBACA,IAAA7tB,EAAAwrB,WAAA,IAAA2E,EAAA3E,UACA,CACA,GAAAmR,GAAAz9B,KAAAk3B,SAAAjG,EAAAnwB,EAAAirB,IACA/rB,MAAAu2B,QAAA3Y,EAAA6f,EAAA38B,EAAAmrB,SAEA,WAAA+E,KAAAhF,KAAA1pB,GAAAxB,EAAAirB,IAAAzpB,GACA0uB,EAAAhF,KAAAxpB,GAAA1B,EAAAirB,IAAAvpB,GAAA,OAAAob,GACAoT,EAAAvE,QAAA,GAAAuE,EAAAhF,KAAAxpB,EAAAwuB,EAAA/E,IAAAzpB,GACA2R,GAAAoa,YAAAwB,YAAAjvB,EAAAkwB,EAAAhxB,KAAA2uB,iBACA,IAAA7tB,EAAAwrB,WAAA,IAAA0E,EAAA1E,UACA,CACA,GAAAmR,GAAAz9B,KAAAk3B,SAAAlG,EAAAlwB,EAAAirB,IACA/rB,MAAAu2B,QAAA3Y,EAAA6f,EAAA38B,EAAAmrB,MAGAnrB,IAAA+rB,YAGA1Y,GAAAvI,QAAAnK,UAAA09B,SAAA,SAAAr+B,GAEA,GAAAq8B,GAAAn9B,KAAAo9B,cAAAt8B,EACA,WAAAq8B,EAKA,MAHAr8B,GAAA2rB,QAAA,GACAzsB,KAAAk3B,SAAAp2B,IAAAmrB,SACAjsB,MAAA+7B,cAAAj7B,EAKA,KAFA,GAAAkwB,GAAAlwB,EAAA+rB,UACApK,GAAA,EACA,OAAAuO,MAAAmM,GAEAn9B,KAAAs3B,eAAAx2B,EAAAkwB,EAAAlwB,EAAAmrB,KACAjsB,KAAAi4B,mBAAAn3B,EAAAkwB,GACAA,EAAAlwB,EAAA+rB,SAEA/rB,GAAA2rB,SAAA,GAAA0Q,EAAA1Q,SAAA,GAEAzsB,KAAA+7B,cAAAj7B,GACAd,KAAA+7B,cAAAoB,IAEAr8B,EAAA2rB,QAAA,GAAA0Q,EAAA1Q,QAAA,GAEA3rB,EAAA2rB,QAAA,GAAAzsB,KAAAu4B,gBAAAz3B,EAAAq8B,EAAAr8B,EAAAmrB,KACAjsB,KAAA+7B,cAAAj7B,GACAd,KAAA+7B,cAAAoB,IAEA1a,GAAA,IAAA3hB,EAAAwrB,WAEAxrB,EAAA2rB,QAAA,IAEAzsB,KAAAk3B,SAAAp2B,IAAAmrB,KACAnrB,EAAA2rB,QAAA,GAEAzsB,KAAA+7B,cAAAj7B,GACAq8B,EAAA1Q,QAAA,IAEAzsB,KAAAk3B,SAAAiG,EAAAr8B,EAAAmrB,KACAkR,EAAA1Q,QAAA,GAEAzsB,KAAA+7B,cAAAoB,IAGAhpB,GAAAnS,MAAA,mBAEAmS,GAAAvI,QAAAwzB,aAAA,SAAAC,GAEA,OAAAx+B,GAAA,EAAAy+B,EAAAD,EAAAj+B,OAAuCP,EAAAy+B,EAASz+B,IAChDw+B,EAAAx+B,GAAA0+B,WAEAprB,GAAAvI,QAAA4zB,YAAA,SAAAC,GAEA,MAAAtrB,IAAAvI,QAAAoqB,KAAAyJ,IAAA,GAEAtrB,GAAAvI,QAAAnK,UAAAi+B,WAAA,SAAAC,GAEA,UAAAA,EACA,QACA,IAAAv4B,GAAA,EACA1G,EAAAi/B,CACA,GACAv4B,KACA1G,IAAAgsB,WAEAhsB,GAAAi/B,EACA,OAAAv4B,IAEA+M,GAAAvI,QAAAnK,UAAA0zB,YAAA,SAAAyK,GAEAzrB,GAAA1H,MAAAmzB,EACA,QAAA/+B,GAAA,EAAA4nB,EAAAzoB,KAAAqzB,WAAAjyB,OAAkDP,EAAA4nB,EAAU5nB,IAC5D,CACA,GAAA00B,GAAAv1B,KAAAqzB,WAAAxyB,EACA,WAAA00B,EAAAvH,IAAA,CAEA,GAAAttB,GAAA60B,EAAAvH,IAAArB,KACAzE,EAAAloB,KAAA0/B,WAAAh/B,EACA,MAAAwnB,EAAA,IAGA,OADA+J,GAAA,GAAA5U,OAAA6K,GACAxT,EAAA,EAAqBA,EAAAwT,EAASxT,IAE9Bud,EAAAvd,GAAAhU,EAAA0sB,GACA1sB,IAAAisB,IAEAiT,GAAAx9B,KAAA6vB,OAGA9d,GAAAvI,QAAAnK,UAAA4zB,aAAA,SAAAD,GAEAA,EAAA3oB,OAGA,QAAA5L,GAAA,EAAA4nB,EAAAzoB,KAAAqzB,WAAAjyB,OAAkDP,EAAA4nB,EAAU5nB,IAC5D,CACA,GAAA00B,GAAAv1B,KAAAqzB,WAAAxyB,GACAqnB,EAAAloB,KAAA0/B,WAAAnK,EAAAvH,IACA,MAAAuH,EAAA5N,QAAAO,EAAA,IAAAqN,EAAA5N,QAAAO,EAAA,IAEAloB,KAAAs1B,eAAAC,EACA,IAAAsK,GAAA,GAAA1rB,IAAAiT,QACAgO,GAAA5M,WAAApmB,KAAAy9B,GACAtK,EAAAnO,SAAAyY,EACAA,EAAAvY,UAAAlmB,OAAA8mB,CAEA,QADAtK,GAAA2X,EAAAvH,IAAArB,KACAjY,EAAA,EAAqBA,EAAAwT,EAASxT,IAE9BmrB,EAAAvY,UAAA5S,GAAAkJ,EAAAwP,GACAxP,IAAA+O,MAKA,OAAA9rB,GAAA,EAAA4nB,EAAAzoB,KAAAqzB,WAAAjyB,OAAkDP,EAAA4nB,EAAU5nB,IAC5D,CACA,GAAA00B,GAAAv1B,KAAAqzB,WAAAxyB,EACA,QAAA00B,EAAAnO,WAEAmO,EAAA5N,QAEA4N,EAAAnO,SAAAO,QAAA,EACAyN,EAAApN,SAAAuN,EAAAnO,WAEA,OAAAmO,EAAAxH,WAAA,MAAAwH,EAAAxH,UAAA3G,SACAmO,EAAAxH,UAAA3G,SAAAY,SAAAuN,EAAAnO,UAEAgO,EAAApN,SAAAuN,EAAAnO,aAGAjT,GAAAvI,QAAAnK,UAAA00B,gBAAA,SAAAZ,GAIA,GAAAuK,GAAA,IACAvK,GAAAtH,SAAA,IAEA,KADA,GAAAuB,GAAA+F,EAAAvH,MAEA,CACA,GAAAwB,EAAA7C,MAAA6C,KAAA7C,MAAA6C,EAAA9C,KAGA,YADA6I,EAAAvH,IAAA,KAIA,IAAA7Z,GAAAmV,SAAA3D,YAAA6J,EAAApC,GAAAoC,EAAA9C,KAAAU,KAAAjZ,GAAAmV,SAAA3D,YAAA6J,EAAApC,GAAAoC,EAAA7C,KAAAS,KACAjZ,GAAAoa,YAAAwB,YAAAP,EAAA7C,KAAAS,GAAAoC,EAAApC,GAAAoC,EAAA9C,KAAAU,GAAAptB,KAAA2uB,mBACA3uB,KAAA6uB,oBAAA7uB,KAAAyyB,sBAAAjD,EAAA7C,KAAAS,GAAAoC,EAAApC,GAAAoC,EAAA9C,KAAAU,KAEA0S,EAAA,KACAtQ,EAAA7C,KAAAD,KAAA8C,EAAA9C,KACA8C,EAAA9C,KAAAC,KAAA6C,EAAA7C,KACA6C,IAAA7C,SAEA,IAAA6C,GAAAsQ,EACA,KAGA,QAAAA,IACAA,EAAAtQ,GACAA,IAAA9C,MAGA6I,EAAAvH,IAAAwB,GAEArb,GAAAvI,QAAAnK,UAAAs+B,SAAA,SAAArH,EAAAsH,GAEA,GAAA54B,GAAA,GAAA+M,IAAA+Z,KAmBA,OAjBA9mB,GAAAgmB,GAAA9qB,EAAAo2B,EAAAtL,GAAA9qB,EACA8E,EAAAgmB,GAAA5qB,EAAAk2B,EAAAtL,GAAA5qB,EACA4E,EAAA0mB,IAAA4K,EAAA5K,IACAkS,GAEA54B,EAAAslB,KAAAgM,EAAAhM,KACAtlB,EAAAulB,KAAA+L,EACAA,EAAAhM,KAAAC,KAAAvlB,EACAsxB,EAAAhM,KAAAtlB,IAIAA,EAAAulB,KAAA+L,EAAA/L,KACAvlB,EAAAslB,KAAAgM,EACAA,EAAA/L,KAAAD,KAAAtlB,EACAsxB,EAAA/L,KAAAvlB,GAEAA,GAEA+M,GAAAvI,QAAAnK,UAAAw+B,WAAA,SAAAC,EAAAC,EAAAnB,EAAAC,EAAAmB,GA4BA,MA1BAF,GAAAC,EAEAnB,EAAAC,GAEAmB,EAAAxD,KAAArzB,KAAAyF,IAAAkxB,EAAAlB,GACAoB,EAAAvD,MAAAtzB,KAAAwF,IAAAoxB,EAAAlB,KAIAmB,EAAAxD,KAAArzB,KAAAyF,IAAAkxB,EAAAjB,GACAmB,EAAAvD,MAAAtzB,KAAAwF,IAAAoxB,EAAAnB,IAKAA,EAAAC,GAEAmB,EAAAxD,KAAArzB,KAAAyF,IAAAmxB,EAAAnB,GACAoB,EAAAvD,MAAAtzB,KAAAwF,IAAAmxB,EAAAjB,KAIAmB,EAAAxD,KAAArzB,KAAAyF,IAAAmxB,EAAAlB,GACAmB,EAAAvD,MAAAtzB,KAAAwF,IAAAmxB,EAAAlB,IAGAoB,EAAAxD,KAAAwD,EAAAvD,OAEA1oB,GAAAvI,QAAAnK,UAAA4+B,SAAA,SAAA9C,EAAA+C,EAAA7C,EAAA8C,EAAAnT,EAAAoT,GAEA,GAAAC,GAAAlD,EAAAnQ,GAAA9qB,EAAAg+B,EAAAlT,GAAA9qB,EAAA6R,GAAAwX,UAAAC,aAAAzX,GAAAwX,UAAAE,aACA6U,EAAAjD,EAAArQ,GAAA9qB,EAAAi+B,EAAAnT,GAAA9qB,EAAA6R,GAAAwX,UAAAC,aAAAzX,GAAAwX,UAAAE,YACA,IAAA4U,GAAAC,EACA,QAMA,IAAAD,GAAAtsB,GAAAwX,UAAAE,aACA,CACA,KAAA0R,EAAA7Q,KAAAU,GAAA9qB,GAAA8qB,EAAA9qB,GACAi7B,EAAA7Q,KAAAU,GAAA9qB,GAAAi7B,EAAAnQ,GAAA9qB,GAAAi7B,EAAA7Q,KAAAU,GAAA5qB,GAAA4qB,EAAA5qB,GACA+6B,IAAA7Q,IACA8T,IAAAjD,EAAAnQ,GAAA9qB,GAAA8qB,EAAA9qB,IACAi7B,IAAA7Q,MACA4T,EAAAtgC,KAAA+/B,SAAAxC,GAAAiD,GACArsB,GAAAmV,SAAAxD,cAAAwa,EAAAlT,QAEAmQ,EAAA+C,EAEA/C,EAAAnQ,GAAA9qB,EAAA8qB,EAAA9qB,EACAi7B,EAAAnQ,GAAA5qB,EAAA4qB,EAAA5qB,EACA89B,EAAAtgC,KAAA+/B,SAAAxC,GAAAiD,QAIA,CACA,KAAAjD,EAAA7Q,KAAAU,GAAA9qB,GAAA8qB,EAAA9qB,GACAi7B,EAAA7Q,KAAAU,GAAA9qB,GAAAi7B,EAAAnQ,GAAA9qB,GAAAi7B,EAAA7Q,KAAAU,GAAA5qB,GAAA4qB,EAAA5qB,GACA+6B,IAAA7Q,IACA8T,IAAAjD,EAAAnQ,GAAA9qB,GAAA8qB,EAAA9qB,IACAi7B,IAAA7Q,MACA4T,EAAAtgC,KAAA+/B,SAAAxC,EAAAiD,GACArsB,GAAAmV,SAAAxD,cAAAwa,EAAAlT,QAEAmQ,EAAA+C,EAEA/C,EAAAnQ,GAAA9qB,EAAA8qB,EAAA9qB,EACAi7B,EAAAnQ,GAAA5qB,EAAA4qB,EAAA5qB,EACA89B,EAAAtgC,KAAA+/B,SAAAxC,EAAAiD,IAGA,GAAAE,GAAAvsB,GAAAwX,UAAAE,aACA,CACA,KAAA4R,EAAA/Q,KAAAU,GAAA9qB,GAAA8qB,EAAA9qB,GACAm7B,EAAA/Q,KAAAU,GAAA9qB,GAAAm7B,EAAArQ,GAAA9qB,GAAAm7B,EAAA/Q,KAAAU,GAAA5qB,GAAA4qB,EAAA5qB,GACAi7B,IAAA/Q,IACA8T,IAAA/C,EAAArQ,GAAA9qB,GAAA8qB,EAAA9qB,IACAm7B,IAAA/Q,MACA6T,EAAAvgC,KAAA+/B,SAAAtC,GAAA+C,GACArsB,GAAAmV,SAAAxD,cAAAya,EAAAnT,QAEAqQ,EAAA8C,EAEA9C,EAAArQ,GAAA9qB,EAAA8qB,EAAA9qB,EACAm7B,EAAArQ,GAAA5qB,EAAA4qB,EAAA5qB,EACA+9B,EAAAvgC,KAAA+/B,SAAAtC,GAAA+C,QAIA,CACA,KAAA/C,EAAA/Q,KAAAU,GAAA9qB,GAAA8qB,EAAA9qB,GACAm7B,EAAA/Q,KAAAU,GAAA9qB,GAAAm7B,EAAArQ,GAAA9qB,GAAAm7B,EAAA/Q,KAAAU,GAAA5qB,GAAA4qB,EAAA5qB,GACAi7B,IAAA/Q,IACA8T,IAAA/C,EAAArQ,GAAA9qB,GAAA8qB,EAAA9qB,IACAm7B,IAAA/Q,MACA6T,EAAAvgC,KAAA+/B,SAAAtC,EAAA+C,GACArsB,GAAAmV,SAAAxD,cAAAya,EAAAnT,QAEAqQ,EAAA8C,EAEA9C,EAAArQ,GAAA9qB,EAAA8qB,EAAA9qB,EACAm7B,EAAArQ,GAAA5qB,EAAA4qB,EAAA5qB,EACA+9B,EAAAvgC,KAAA+/B,SAAAtC,EAAA+C,IAiBA,MAdAC,IAAAtsB,GAAAwX,UAAAE,cAAA2U,GAEAjD,EAAA5Q,KAAA8Q,EACAA,EAAA/Q,KAAA6Q,EACA+C,EAAA5T,KAAA6T,EACAA,EAAA5T,KAAA2T,IAIA/C,EAAA7Q,KAAA+Q,EACAA,EAAA9Q,KAAA4Q,EACA+C,EAAA3T,KAAA4T,EACAA,EAAA7T,KAAA4T,IAEA,GAEAnsB,GAAAvI,QAAAnK,UAAAk/B,WAAA,SAAAjsB,EAAAslB,EAAAC,GAEA,GAAAsD,GAAA7oB,EAAA0Z,OACAkS,EAAA,GAAAnsB,IAAA+Z,MACAuP,EAAA/oB,EAAA2Z,OACAkS,EAAA,GAAApsB,IAAA+Z,MAQA0S,EAAAlsB,EAAA0Z,OAAAhB,GAAA5qB,GAAAkS,EAAA4Z,MAAA9rB,CACA,IAAAo+B,GAAAzsB,GAAAmV,SAAA3D,YAAAjR,EAAA4Z,MAAA5Z,EAAA0Z,OAAAhB,KAAAjZ,GAAAmV,SAAA3D,YAAAjR,EAAA4Z,MAAA5Z,EAAA2Z,OAAAjB,IACA,CAEA,GAAA4M,GAAAC,EAAA,QAGA,KADAqG,EAAA5rB,EAAA0Z,OAAA1B,KACA4T,GAAA/C,GAAAppB,GAAAmV,SAAA3D,YAAA2a,EAAAlT,GAAA1Y,EAAA4Z,QACAgS,IAAA5T,IACA,IAAAmU,GAAAP,EAAAlT,GAAA5qB,EAAAkS,EAAA4Z,MAAA9rB,CAEA,KADA+9B,EAAA7rB,EAAA2Z,OAAA3B,KACA6T,GAAA9C,GAAAtpB,GAAAmV,SAAA3D,YAAA4a,EAAAnT,GAAA1Y,EAAA4Z,QACAiS,IAAA7T,IACA,IAAAoU,GAAAP,EAAAnT,GAAA5qB,EAAAkS,EAAA4Z,MAAA9rB,CACA,OAAAq+B,IAAAC,IAEAD,GAEAP,EAAAtgC,KAAA+/B,SAAAxC,GAAA,GACAgD,EAAAvgC,KAAA+/B,SAAAtC,GAAA,GACAF,EAAA5Q,KAAA8Q,EACAA,EAAA/Q,KAAA6Q,EACA+C,EAAA5T,KAAA6T,EACAA,EAAA5T,KAAA2T,EACA5rB,EAAA0Z,OAAAmP,EACA7oB,EAAA2Z,OAAAiS,GACA,IAIAA,EAAAtgC,KAAA+/B,SAAAxC,GAAA,GACAgD,EAAAvgC,KAAA+/B,SAAAtC,GAAA,GACAF,EAAA7Q,KAAA+Q,EACAA,EAAA9Q,KAAA4Q,EACA+C,EAAA3T,KAAA4T,EACAA,EAAA7T,KAAA4T,EACA5rB,EAAA0Z,OAAAmP,EACA7oB,EAAA2Z,OAAAiS,GACA,IAGA,GAAAM,EACA,CAKA,IADAN,EAAA/C,EACAA,EAAA5Q,KAAAS,GAAA5qB,GAAA+6B,EAAAnQ,GAAA5qB,GAAA+6B,EAAA5Q,MAAA2T,GAAA/C,EAAA5Q,MAAA8Q,GACAF,IAAA5Q,IACA,MAAA2T,EAAA5T,KAAAU,GAAA5qB,GAAA89B,EAAAlT,GAAA5qB,GAAA89B,EAAA5T,MAAA6Q,GAAA+C,EAAA5T,MAAA+Q,GACA6C,IAAA5T,IACA,IAAA4T,EAAA5T,MAAA6Q,GAAA+C,EAAA5T,MAAA+Q,EACA,QAGA,KADA8C,EAAA9C,EACAA,EAAA9Q,KAAAS,GAAA5qB,GAAAi7B,EAAArQ,GAAA5qB,GAAAi7B,EAAA9Q,MAAA4T,GAAA9C,EAAA9Q,MAAA2T,GACA7C,IAAA9Q,IACA,MAAA4T,EAAA7T,KAAAU,GAAA5qB,GAAA+9B,EAAAnT,GAAA5qB,GAAA+9B,EAAA7T,MAAA+Q,GAAA8C,EAAA7T,MAAA6Q,GACAgD,IAAA7T,IACA,IAAA6T,EAAA7T,MAAA+Q,GAAA8C,EAAA7T,MAAA6Q,EACA,QAIA,IAAA6C,IAAkBxD,KAAA,KAAAC,MAAA,KAClB,KAAA78B,KAAAigC,WAAA1C,EAAAnQ,GAAA9qB,EAAAg+B,EAAAlT,GAAA9qB,EAAAm7B,EAAArQ,GAAA9qB,EAAAi+B,EAAAnT,GAAA9qB,EAAA89B,GACA,QACA,IAOAW,GAPAnE,EAAAwD,EAAAxD,KACAC,EAAAuD,EAAAvD,MAKAzP,EAAA,GAAAjZ,IAAAmV,QAgCA,OA9BAiU,GAAAnQ,GAAA9qB,GAAAs6B,GAAAW,EAAAnQ,GAAA9qB,GAAAu6B,GAGAzP,EAAA9qB,EAAAi7B,EAAAnQ,GAAA9qB,EACA8qB,EAAA5qB,EAAA+6B,EAAAnQ,GAAA5qB,EACAu+B,EAAAxD,EAAAnQ,GAAA9qB,EAAAg+B,EAAAlT,GAAA9qB,GAEAm7B,EAAArQ,GAAA9qB,GAAAs6B,GAAAa,EAAArQ,GAAA9qB,GAAAu6B,GAGAzP,EAAA9qB,EAAAm7B,EAAArQ,GAAA9qB,EACA8qB,EAAA5qB,EAAAi7B,EAAArQ,GAAA5qB,EACAu+B,EAAAtD,EAAArQ,GAAA9qB,EAAAi+B,EAAAnT,GAAA9qB,GAEAg+B,EAAAlT,GAAA9qB,GAAAs6B,GAAA0D,EAAAlT,GAAA9qB,GAAAu6B,GAGAzP,EAAA9qB,EAAAg+B,EAAAlT,GAAA9qB,EACA8qB,EAAA5qB,EAAA89B,EAAAlT,GAAA5qB,EACAu+B,EAAAT,EAAAlT,GAAA9qB,EAAAi7B,EAAAnQ,GAAA9qB,IAKA8qB,EAAA9qB,EAAAi+B,EAAAnT,GAAA9qB,EACA8qB,EAAA5qB,EAAA+9B,EAAAnT,GAAA5qB,EACAu+B,EAAAR,EAAAnT,GAAA9qB,EAAAm7B,EAAArQ,GAAA9qB,GAEAoS,EAAA0Z,OAAAmP,EACA7oB,EAAA2Z,OAAAoP,EACAz9B,KAAAqgC,SAAA9C,EAAA+C,EAAA7C,EAAA8C,EAAAnT,EAAA2T,GASA,IADAT,EAAA/C,EAAA7Q,KACAvY,GAAAmV,SAAA3D,YAAA2a,EAAAlT,GAAAmQ,EAAAnQ,KAAAkT,GAAA/C,GACA+C,IAAA5T,IACA,IAAAsU,GAAAV,EAAAlT,GAAA5qB,EAAA+6B,EAAAnQ,GAAA5qB,IAAA2R,GAAAoa,YAAAwB,YAAAwN,EAAAnQ,GAAAkT,EAAAlT,GAAA1Y,EAAA4Z,MAAAtuB,KAAA2uB,eACA,IAAAqS,EACA,CAEA,IADAV,EAAA/C,EAAA5Q,KACAxY,GAAAmV,SAAA3D,YAAA2a,EAAAlT,GAAAmQ,EAAAnQ,KAAAkT,GAAA/C,GACA+C,IAAA3T,IACA,IAAA2T,EAAAlT,GAAA5qB,EAAA+6B,EAAAnQ,GAAA5qB,IAAA2R,GAAAoa,YAAAwB,YAAAwN,EAAAnQ,GAAAkT,EAAAlT,GAAA1Y,EAAA4Z,MAAAtuB,KAAA2uB,gBACA,SAGA,IADA4R,EAAA9C,EAAA/Q,KACAvY,GAAAmV,SAAA3D,YAAA4a,EAAAnT,GAAAqQ,EAAArQ,KAAAmT,GAAA9C,GACA8C,IAAA7T,IACA,IAAAuU,GAAAV,EAAAnT,GAAA5qB,EAAAi7B,EAAArQ,GAAA5qB,IAAA2R,GAAAoa,YAAAwB,YAAA0N,EAAArQ,GAAAmT,EAAAnT,GAAA1Y,EAAA4Z,MAAAtuB,KAAA2uB,eACA,IAAAsS,EACA,CAEA,IADAV,EAAA9C,EAAA9Q,KACAxY,GAAAmV,SAAA3D,YAAA4a,EAAAnT,GAAAqQ,EAAArQ,KAAAmT,GAAA9C,GACA8C,IAAA5T,IACA,IAAA4T,EAAAnT,GAAA5qB,EAAAi7B,EAAArQ,GAAA5qB,IAAA2R,GAAAoa,YAAAwB,YAAA0N,EAAArQ,GAAAmT,EAAAnT,GAAA1Y,EAAA4Z,MAAAtuB,KAAA2uB,gBACA,SAEA,MAAA2R,IAAA/C,GAAAgD,GAAA9C,GAAA6C,GAAAC,IACAvG,GAAAC,GAAA+G,GAAAC,KAEAD,GAEAV,EAAAtgC,KAAA+/B,SAAAxC,GAAA,GACAgD,EAAAvgC,KAAA+/B,SAAAtC,GAAA,GACAF,EAAA5Q,KAAA8Q,EACAA,EAAA/Q,KAAA6Q,EACA+C,EAAA5T,KAAA6T,EACAA,EAAA5T,KAAA2T,EACA5rB,EAAA0Z,OAAAmP;AACA7oB,EAAA2Z,OAAAiS,GACA,IAIAA,EAAAtgC,KAAA+/B,SAAAxC,GAAA,GACAgD,EAAAvgC,KAAA+/B,SAAAtC,GAAA,GACAF,EAAA7Q,KAAA+Q,EACAA,EAAA9Q,KAAA4Q,EACA+C,EAAA3T,KAAA4T,EACAA,EAAA7T,KAAA4T,EACA5rB,EAAA0Z,OAAAmP,EACA7oB,EAAA2Z,OAAAiS,GACA,KAIAnsB,GAAAvI,QAAAs1B,UAAA,SAAAt3B,GAIA,IAFA,GAAA/I,GAAA,EACAqnB,EAAAte,EAAAxI,OACAP,EAAAqnB,GAAA,GAAAte,EAAA/I,GAAAO,QAAAP,GACA,IAAAA,GAAAqnB,EAAA,UAAA/T,IAAA4V,QAAA,QACA,IAAA3iB,GAAA,GAAA+M,IAAA4V,OAKA,KAJA3iB,EAAA4iB,KAAApgB,EAAA/I,GAAA,GAAAyB,EACA8E,EAAA8iB,MAAA9iB,EAAA4iB,KACA5iB,EAAA6iB,IAAArgB,EAAA/I,GAAA,GAAA2B,EACA4E,EAAA+iB,OAAA/iB,EAAA6iB,IACUppB,EAAAqnB,EAASrnB,IACnB,OAAA6T,GAAA,EAAAgc,EAAA9mB,EAAA/I,GAAAO,OAA6CsT,EAAAgc,EAAUhc,IAEvD9K,EAAA/I,GAAA6T,GAAApS,EAAA8E,EAAA4iB,KAAA5iB,EAAA4iB,KAAApgB,EAAA/I,GAAA6T,GAAApS,EACAsH,EAAA/I,GAAA6T,GAAApS,EAAA8E,EAAA8iB,QAAA9iB,EAAA8iB,MAAAtgB,EAAA/I,GAAA6T,GAAApS,GACAsH,EAAA/I,GAAA6T,GAAAlS,EAAA4E,EAAA6iB,IAAA7iB,EAAA6iB,IAAArgB,EAAA/I,GAAA6T,GAAAlS,EACAoH,EAAA/I,GAAA6T,GAAAlS,EAAA4E,EAAA+iB,SAAA/iB,EAAA+iB,OAAAvgB,EAAA/I,GAAA6T,GAAAlS,EAEA,OAAA4E,IAEA+M,GAAAvI,QAAAnK,UAAA0/B,WAAA,SAAAC,GAEA,GAAAC,GAAAD,EACAh6B,EAAA,GAAA+M,IAAA4V,OAMA,KALA3iB,EAAA4iB,KAAAoX,EAAAhU,GAAA9qB,EACA8E,EAAA8iB,MAAAkX,EAAAhU,GAAA9qB,EACA8E,EAAA6iB,IAAAmX,EAAAhU,GAAA5qB,EACA4E,EAAA+iB,OAAAiX,EAAAhU,GAAA5qB,EACA4+B,IAAA1U,KACA0U,GAAAC,GAEAD,EAAAhU,GAAA9qB,EAAA8E,EAAA4iB,OACA5iB,EAAA4iB,KAAAoX,EAAAhU,GAAA9qB,GACA8+B,EAAAhU,GAAA9qB,EAAA8E,EAAA8iB,QACA9iB,EAAA8iB,MAAAkX,EAAAhU,GAAA9qB,GACA8+B,EAAAhU,GAAA5qB,EAAA4E,EAAA6iB,MACA7iB,EAAA6iB,IAAAmX,EAAAhU,GAAA5qB,GACA4+B,EAAAhU,GAAA5qB,EAAA4E,EAAA+iB,SACA/iB,EAAA+iB,OAAAiX,EAAAhU,GAAA5qB,GACA4+B,IAAA1U,IAEA,OAAAtlB,IAGA+M,GAAAvI,QAAA01B,eAAA,SAAAnpB,EAAArO,GAKA,GAAA1C,GAAA,EACA8gB,EAAApe,EAAA1I,MACA,IAAA8mB,EAAA,EACA,QAEA,QADA6W,GAAAj1B,EAAA,GACAjJ,EAAA,EAAmBA,GAAAqnB,IAAUrnB,EAC7B,CACA,GAAA0gC,GAAA1gC,GAAAqnB,EAAApe,EAAA,GAAAA,EAAAjJ,EACA,IAAA0gC,EAAA/+B,GAAA2V,EAAA3V,IAEA++B,EAAAj/B,GAAA6V,EAAA7V,GAAAy8B,EAAAv8B,GAAA2V,EAAA3V,GAAA++B,EAAAj/B,EAAA6V,EAAA7V,GAAAy8B,EAAAz8B,EAAA6V,EAAA7V,GACA,QAEA,IAAAy8B,EAAAv8B,EAAA2V,EAAA3V,GAAA++B,EAAA/+B,EAAA2V,EAAA3V,EAEA,GAAAu8B,EAAAz8B,GAAA6V,EAAA7V,EAEA,GAAAi/B,EAAAj/B,EAAA6V,EAAA7V,EACA8E,EAAA,EAAAA,MAEA,CACA,GAAAwP,IAAAmoB,EAAAz8B,EAAA6V,EAAA7V,IAAAi/B,EAAA/+B,EAAA2V,EAAA3V,IAAA++B,EAAAj/B,EAAA6V,EAAA7V,IAAAy8B,EAAAv8B,EAAA2V,EAAA3V,EACA,OAAAoU,EACA,QACAA,GAAA,GAAA2qB,EAAA/+B,EAAAu8B,EAAAv8B,IACA4E,EAAA,EAAAA,OAKA,IAAAm6B,EAAAj/B,EAAA6V,EAAA7V,EACA,CACA,GAAAsU,IAAAmoB,EAAAz8B,EAAA6V,EAAA7V,IAAAi/B,EAAA/+B,EAAA2V,EAAA3V,IAAA++B,EAAAj/B,EAAA6V,EAAA7V,IAAAy8B,EAAAv8B,EAAA2V,EAAA3V,EACA,OAAAoU,EACA,QACAA,GAAA,GAAA2qB,EAAA/+B,EAAAu8B,EAAAv8B,IACA4E,EAAA,EAAAA,GAIA23B,EAAAwC,EAEA,MAAAn6B,IAGA+M,GAAAvI,QAAAnK,UAAA6/B,eAAA,SAAAnpB,EAAAyF,GAKA,GAAAxW,GAAA,EACAo6B,EAAA5jB,EACA6jB,EAAAtpB,EAAA7V,EAAAo/B,EAAAvpB,EAAA3V,EACAm/B,EAAA/jB,EAAAwP,GAAA9qB,EAAAs/B,EAAAhkB,EAAAwP,GAAA5qB,CACA,GACA,CACAob,IAAA8O,IACA,IAAAmV,GAAAjkB,EAAAwP,GAAA9qB,EAAAw/B,EAAAlkB,EAAAwP,GAAA5qB,CACA,IAAAs/B,GAAAJ,IAEAG,GAAAJ,GAAAG,GAAAF,GAAAG,EAAAJ,GAAAE,EAAAF,GACA,QAEA,IAAAG,EAAAF,GAAAI,EAAAJ,EAEA,GAAAC,GAAAF,EAEA,GAAAI,EAAAJ,EACAr6B,EAAA,EAAAA,MAEA,CACA,GAAAwP,IAAA+qB,EAAAF,IAAAK,EAAAJ,IAAAG,EAAAJ,IAAAG,EAAAF,EACA,OAAA9qB,EACA,QACAA,GAAA,GAAAkrB,EAAAF,IACAx6B,EAAA,EAAAA,OAKA,IAAAy6B,EAAAJ,EACA,CACA,GAAA7qB,IAAA+qB,EAAAF,IAAAK,EAAAJ,IAAAG,EAAAJ,IAAAG,EAAAF,EACA,OAAA9qB,EACA,QACAA,GAAA,GAAAkrB,EAAAF,IACAx6B,EAAA,EAAAA,GAIAu6B,EAAAE,EACAD,EAAAE,QACKN,GAAA5jB,EAEL,OAAAxW,IAGA+M,GAAAvI,QAAAnK,UAAAsgC,mBAAA,SAAAC,EAAAC,GAEA,GAAArkB,GAAAokB,CACA,GACA,CAEA,GAAAE,GAAAliC,KAAAshC,eAAA1jB,EAAAwP,GAAA6U,EACA,IAAAC,GAAA,EACA,MAAAA,GAAA,CACAtkB,KAAA8O,WAEA9O,GAAAokB,EACA,WAEA7tB,GAAAvI,QAAAnK,UAAA0gC,iBAAA,SAAAC,EAAAC,GAEA,OAAAxhC,GAAA,EAAA4nB,EAAAzoB,KAAAqzB,WAAAjyB,OAAkDP,EAAA4nB,EAAU5nB,IAC5D,CACA,GAAA00B,GAAAv1B,KAAAqzB,WAAAxyB,EACA,UAAA00B,EAAAvH,KAAA,MAAAuH,EAAAxH,UAAA,CAEA,GAAAuU,GAAAtiC,KAAAuiC,eAAAhN,EAAAxH,UACAuU,IAAAF,GAEApiC,KAAA+hC,mBAAAxM,EAAAvH,IAAAqU,EAAArU,OACAuH,EAAAxH,UAAAsU,MAIAluB,GAAAvI,QAAAnK,UAAA+gC,iBAAA,SAAAJ,EAAAC,GAEA,OAAAI,GAAA,EAAAC,EAAA1iC,KAAAqzB,WAAAsP,EAAAD,EAAAthC,OAAAm0B,EAAAmN,EAAAD,GAAiFA,EAAAE,EAAWF,IAAAlN,EAAAmN,EAAAD,GAC5FlN,EAAAxH,WAAAqU,IACA7M,EAAAxH,UAAAsU,IAEAluB,GAAAvI,QAAA22B,eAAA,SAAAxU,GAEA,WAAAA,GAAA,MAAAA,EAAAC,KACAD,aACA,OAAAA,IAEA5Z,GAAAvI,QAAAnK,UAAAy0B,gBAAA,WAEA,OAAAr1B,GAAA,EAAA4nB,EAAAzoB,KAAA+zB,QAAA3yB,OAA+CP,EAAA4nB,EAAU5nB,IACzD,CACA,GAAAoR,GAAAjS,KAAA+zB,QAAAlzB,GACAm5B,EAAAh6B,KAAAq6B,UAAApoB,EAAAmc,OAAAN,KACAmM,EAAAj6B,KAAAq6B,UAAApoB,EAAAoc,OAAAP,IACA,UAAAkM,EAAAhM,KAAA,MAAAiM,EAAAjM,IAAA,CAIA,GAAAwM,EAUA,IARAA,EADAR,GAAAC,EACAD,EACAh6B,KAAAo6B,oBAAAJ,EAAAC,GACAA,EACAj6B,KAAAo6B,oBAAAH,EAAAD,GACAA,EAEAh6B,KAAA+5B,gBAAAC,EAAAC,GAEAj6B,KAAA2gC,WAAA1uB,EAAA+nB,EAAAC,GAEA,GAAAD,GAAAC,EACA,CAWA,GARAD,EAAAhM,IAAA/b,EAAAmc,OACA4L,EAAA/L,SAAA,KACAgM,EAAAj6B,KAAA24B,eACAsB,EAAAjM,IAAA/b,EAAAoc,OAEAruB,KAAA4iC,gBAAA3I,GAGAj6B,KAAAi0B,gBACA,OAAAvf,GAAA,EAAAgc,EAAA1wB,KAAAqzB,WAAAjyB,OAAwDsT,EAAAgc,EAAA,EAAchc,IACtE,CACA,GAAAmuB,GAAA7iC,KAAAqzB,WAAA3e,EACA,OAAAmuB,EAAA7U,KAAA7Z,GAAAvI,QAAA22B,eAAAM,EAAA9U,YAAAiM,GAAA6I,EAAAta,QAAAyR,EAAAzR,QAEAvoB,KAAA+hC,mBAAAc,EAAA7U,IAAA/b,EAAAoc,UACAwU,EAAA9U,UAAAkM,GAEAj6B,KAAA+hC,mBAAA9H,EAAAjM,IAAAgM,EAAAhM,MAGAiM,EAAA1R,QAAAyR,EAAAzR,OACA0R,EAAAlM,UAAAiM,EAEAh6B,KAAAi0B,iBACAj0B,KAAAwiC,iBAAAvI,EAAAD,IACAC,EAAA1R,OAAAvoB,KAAAk0B,kBAAAl0B,KAAAg2B,KAAAiE,GAAA,GACAj6B,KAAAi2B,mBAAAgE,EAAAjM,MAEAhuB,KAAA+hC,mBAAA/H,EAAAhM,IAAAiM,EAAAjM,MAGAiM,EAAA1R,OAAAyR,EAAAzR,OACAyR,EAAAzR,QAAA0R,EAAA1R,OACA0R,EAAAlM,UAAAiM,EAAAjM,UACAiM,EAAAjM,UAAAkM,EAEAj6B,KAAAi0B,iBACAj0B,KAAAwiC,iBAAAxI,EAAAC,IACAD,EAAAzR,OAAAvoB,KAAAk0B,kBAAAl0B,KAAAg2B,KAAAgE,GAAA,GACAh6B,KAAAi2B,mBAAA+D,EAAAhM,OAKAiM,EAAA1R,OAAAyR,EAAAzR,OACA0R,EAAAlM,UAAAiM,EAAAjM,UAEA/tB,KAAAi0B,iBACAj0B,KAAAmiC,iBAAAnI,EAAAC,QAMAA,GAAAjM,IAAA,KACAiM,EAAAhM,SAAA,KACAgM,EAAAnM,IAAAkM,EAAAlM,IACAkM,EAAAzR,OAAAiS,EAAAjS,OACAiS,GAAAP,IACAD,EAAAjM,UAAAkM,EAAAlM,WACAkM,EAAAlM,UAAAiM,EAEAh6B,KAAAi0B,iBACAj0B,KAAAwiC,iBAAAvI,EAAAD,MAIA7lB,GAAAvI,QAAAnK,UAAAmhC,gBAAA,SAAArI,GAEA,GAAA3c,GAAA2c,EAAAvM,GACA,GACApQ,GAAAkQ,IAAAyM,EAAAzM,IACAlQ,IAAA+O,WAEA/O,GAAA2c,EAAAvM,MAEA7Z,GAAAvI,QAAAnK,UAAA20B,iBAAA,WAGA,IADA,GAAAv1B,GAAA,EACAA,EAAAb,KAAAqzB,WAAAjyB,QACA,CACA,GAAAm5B,GAAAv6B,KAAAqzB,WAAAxyB,KACA+c,EAAA2c,EAAAvM,GACA,UAAApQ,IAAA2c,EAAA5S,OAEA,EACA,CAEA,IADA,GAAA8V,GAAA7f,EAAA8O,KACA+Q,GAAAlD,EAAAvM,KACA,CACA,GAAA7Z,GAAAmV,SAAA3D,YAAA/H,EAAAwP,GAAAqQ,EAAArQ,KAAAqQ,EAAA/Q,MAAA9O,GAAA6f,EAAA9Q,MAAA/O,EACA,CAEA,GAAAklB,GAAAllB,EAAA+O,KACAoW,EAAAtF,EAAA9Q,IACA/O,GAAA+O,KAAAoW,EACAA,EAAArW,KAAA9O,EACA6f,EAAA9Q,KAAAmW,EACAA,EAAApW,KAAA+Q,EACAlD,EAAAvM,IAAApQ,CACA,IAAAolB,GAAAhjC,KAAA24B,cACAqK,GAAAhV,IAAAyP,EACAz9B,KAAA4iC,gBAAAI,GACAhjC,KAAA+hC,mBAAAiB,EAAAhV,IAAAuM,EAAAvM,MAGAgV,EAAAza,QAAAgS,EAAAhS,OACAya,EAAAjV,UAAAwM,EACAv6B,KAAAi0B,iBAAAj0B,KAAAwiC,iBAAAQ,EAAAzI,IAGAv6B,KAAA+hC,mBAAAxH,EAAAvM,IAAAgV,EAAAhV,MAGAgV,EAAAza,OAAAgS,EAAAhS,OACAgS,EAAAhS,QAAAya,EAAAza,OACAya,EAAAjV,UAAAwM,EAAAxM,UACAwM,EAAAxM,UAAAiV,EACAhjC,KAAAi0B,iBAAAj0B,KAAAwiC,iBAAAjI,EAAAyI,KAKAA,EAAAza,OAAAgS,EAAAhS,OACAya,EAAAjV,UAAAwM,EAAAxM,UACA/tB,KAAAi0B,iBAAAj0B,KAAAmiC,iBAAA5H,EAAAyI,IAEAvF,EAAA7f,EAGA6f,IAAA/Q,KAEA9O,IAAA8O,WAEA9O,GAAA2c,EAAAvM,OAGA7Z,GAAAvI,QAAAoqB,KAAA,SAAAyJ,GAEA,GAAAvX,GAAAuX,EAAAr+B,MACA,IAAA8mB,EAAA,EACA,QAEA,QADAjU,GAAA,EACApT,EAAA,EAAA6T,EAAAwT,EAAA,EAAgCrnB,EAAAqnB,IAASrnB,EAEzCoT,IAAAwrB,EAAA/qB,GAAApS,EAAAm9B,EAAA5+B,GAAAyB,IAAAm9B,EAAA/qB,GAAAlS,EAAAi9B,EAAA5+B,GAAA2B,GACAkS,EAAA7T,CAEA,WAAAoT,GAEAE,GAAAvI,QAAAnK,UAAAu0B,KAAA,SAAAT,GAEA,GAAA3X,GAAA2X,EAAAvH,GACA,UAAApQ,EACA,QACA,IAAA3J,GAAA,CACA,GACAA,KAAA2J,EAAA+O,KAAAS,GAAA9qB,EAAAsb,EAAAwP,GAAA9qB,IAAAsb,EAAA+O,KAAAS,GAAA5qB,EAAAob,EAAAwP,GAAA5qB,GACAob,IAAA8O,WAEA9O,GAAA2X,EAAAvH,IACA,UAAA/Z,GAEAE,GAAAvI,QAAAq3B,gBAAA,SAAAxD,EAAAyD,GAEA,GAAA97B,GAAA,GAAAiW,OACA5c,EAAA,GAAA0T,IAAAvI,QAAA,EAIA,OAHAnL,GAAAiM,gBAAA,EACAjM,EAAAuxB,QAAAyN,EAAAtrB,GAAAlI,SAAAC,WAAA,GACAzL,EAAA0L,QAAAgI,GAAA/H,SAAAC,QAAAjF,EAAA87B,KACA97B,GAEA+M,GAAAvI,QAAAY,iBAAA,SAAA6yB,EAAA6D,GAEA,wBAAAA,EAAA/uB,GAAA7I,aAAAE,WACA,IAAApE,GAAA,GAAAiW,OACA5c,EAAA,GAAA0T,IAAAvI,QAAA,EAIA,OAHAnL,GAAAiM,gBAAA,EACAjM,EAAAuL,SAAAqzB,EAAAlrB,GAAAlI,SAAAC,WAAA,GACAzL,EAAA0L,QAAAgI,GAAA/H,SAAAC,QAAAjF,EAAA87B,KACA97B,GAEA+M,GAAAvI,QAAAu3B,aAAA,SAAAjT,EAAAC,GAEA,GAAAxe,GAAAue,EAAA5tB,EAAA6tB,EAAA7tB,EACAsP,EAAAse,EAAA1tB,EAAA2tB,EAAA3tB,CACA,OAAAmP,KAAAC,KAEAuC,GAAAvI,QAAAw3B,qBAAA,SAAAjrB,EAAAkrB,EAAAC,GAQA,GAAAC,GAAAF,EAAA7gC,EAAA8gC,EAAA9gC,EACAghC,EAAAF,EAAAhhC,EAAA+gC,EAAA/gC,EACAmhC,EAAAF,EAAAF,EAAA/gC,EAAAkhC,EAAAH,EAAA7gC,CAEA,OADAihC,GAAAF,EAAAprB,EAAA7V,EAAAkhC,EAAArrB,EAAA3V,EAAAihC,EACAA,KAAAF,IAAAC,MAGArvB,GAAAvI,QAAA83B,oBAAA,SAAAxT,EAAAC,EAAAC,EAAAuT,GAKA,MAAAp6B,MAAAsO,IAAAqY,EAAA5tB,EAAA6tB,EAAA7tB,GAAAiH,KAAAsO,IAAAqY,EAAA1tB,EAAA2tB,EAAA3tB,GAEA0tB,EAAA5tB,EAAA6tB,EAAA7tB,GAAA4tB,EAAA5tB,EAAA8tB,EAAA9tB,EACA6R,GAAAvI,QAAAw3B,qBAAAlT,EAAAC,EAAAC,GAAAuT,EACAxT,EAAA7tB,EAAA4tB,EAAA5tB,GAAA6tB,EAAA7tB,EAAA8tB,EAAA9tB,EACA6R,GAAAvI,QAAAw3B,qBAAAjT,EAAAD,EAAAE,GAAAuT,EAEAxvB,GAAAvI,QAAAw3B,qBAAAhT,EAAAF,EAAAC,GAAAwT,EAIAzT,EAAA1tB,EAAA2tB,EAAA3tB,GAAA0tB,EAAA1tB,EAAA4tB,EAAA5tB,EACA2R,GAAAvI,QAAAw3B,qBAAAlT,EAAAC,EAAAC,GAAAuT,EACAxT,EAAA3tB,EAAA0tB,EAAA1tB,GAAA2tB,EAAA3tB,EAAA4tB,EAAA5tB,EACA2R,GAAAvI,QAAAw3B,qBAAAjT,EAAAD,EAAAE,GAAAuT,EAEAxvB,GAAAvI,QAAAw3B,qBAAAhT,EAAAF,EAAAC,GAAAwT,GAIAxvB,GAAAvI,QAAAg4B,eAAA,SAAA1T,EAAAC,EAAAwT,GAEA,GAAAhyB,GAAAue,EAAA5tB,EAAA6tB,EAAA7tB,EACAsP,EAAAse,EAAA1tB,EAAA2tB,EAAA3tB,CACA,OAAAmP,KAAAC,KAAA+xB,GAGAxvB,GAAAvI,QAAAi4B,UAAA,SAAAjmB,GAEA,GAAAxW,GAAAwW,EAAA+O,IAIA,OAHAvlB,GAAAslB,KAAA9O,EAAA8O,KACA9O,EAAA8O,KAAAC,KAAAvlB,EACAA,EAAA0mB,IAAA,EACA1mB,GAEA+M,GAAAvI,QAAAk4B,aAAA,SAAAh6B,EAAAi6B,GAEA,wBAAAA,EAAA,MAIA,IAAA7b,GAAApe,EAAA1I,MACA,OAAA8mB,EACA,UAAA7K,MAEA,QADA2mB,GAAA,GAAA3mB,OAAA6K,GACArnB,EAAA,EAAmBA,EAAAqnB,IAASrnB,EAC5BmjC,EAAAnjC,GAAA,GAAAsT,IAAA+Z,KACA,QAAArtB,GAAA,EAAmBA,EAAAqnB,IAASrnB,EAE5BmjC,EAAAnjC,GAAAusB,GAAAtjB,EAAAjJ,GACAmjC,EAAAnjC,GAAA6rB,KAAAsX,GAAAnjC,EAAA,GAAAqnB,GACA8b,EAAAnjC,GAAA6rB,KAAAC,KAAAqX,EAAAnjC,GACAmjC,EAAAnjC,GAAAitB,IAAA,CAIA,KAFA,GAAA6V,GAAAI,IACAnmB,EAAAomB,EAAA,GACA,GAAApmB,EAAAkQ,KAAAlQ,EAAA8O,MAAA9O,EAAA+O,MAEAxY,GAAAvI,QAAAg4B,eAAAhmB,EAAAwP,GAAAxP,EAAA+O,KAAAS,GAAAuW,IAEA/lB,EAAAzJ,GAAAvI,QAAAi4B,UAAAjmB,GACAsK,KAEA/T,GAAAvI,QAAAg4B,eAAAhmB,EAAA+O,KAAAS,GAAAxP,EAAA8O,KAAAU,GAAAuW,IAEAxvB,GAAAvI,QAAAi4B,UAAAjmB,EAAA8O,MACA9O,EAAAzJ,GAAAvI,QAAAi4B,UAAAjmB,GACAsK,GAAA,GAEA/T,GAAAvI,QAAA83B,oBAAA9lB,EAAA+O,KAAAS,GAAAxP,EAAAwP,GAAAxP,EAAA8O,KAAAU,GAAAuW,IAEA/lB,EAAAzJ,GAAAvI,QAAAi4B,UAAAjmB,GACAsK,MAIAtK,EAAAkQ,IAAA,EACAlQ,IAAA8O,KAGAxE,GAAA,IACAA,EAAA,EAEA,QADA9gB,GAAA,GAAAiW,OAAA6K,GACArnB,EAAA,EAAmBA,EAAAqnB,IAASrnB,EAE5BuG,EAAAvG,GAAA,GAAAsT,IAAAmV,SAAA1L,EAAAwP,IACAxP,IAAA8O,IAGA,OADAsX,GAAA,KACA58B,GAEA+M,GAAAvI,QAAAq4B,cAAA,SAAA5E,EAAA0E,GAGA,OADA38B,GAAA,GAAAiW,OAAAgiB,EAAAj+B,QACAP,EAAA,EAAA4nB,EAAA4W,EAAAj+B,OAAwCP,EAAA4nB,EAAU5nB,IAClDuG,EAAAvG,GAAAsT,GAAAvI,QAAAk4B,aAAAzE,EAAAx+B,GAAAkjC,EACA,OAAA38B,IAEA+M,GAAAvI,QAAAs4B,UAAA,SAAAC,EAAAr6B,EAAAs6B,EAAAC,GAEA,GAAAC,GAAAD,EAAA,IACAE,EAAAJ,EAAA/iC,OACAojC,EAAA16B,EAAA1I,OACAgG,EAAA,GAAAiW,MACA,IAAA+mB,EACA,OAAAvjC,GAAA,EAAqBA,EAAA2jC,EAAa3jC,IAClC,CAEA,OADAH,GAAA,GAAA2c,OAAAknB,GACA7vB,EAAA,EAAAgc,EAAAyT,EAAA/iC,OAAA29B,EAAAoF,EAAAzvB,GAA+DA,EAAAgc,EAAUhc,IAAAqqB,EAAAoF,EAAAzvB,GACzEhU,EAAAgU,GAAA,GAAAP,IAAAmV,SAAAxf,EAAAjJ,GAAAyB,EAAAy8B,EAAAz8B,EAAAwH,EAAAjJ,GAAA2B,EAAAu8B,EAAAv8B,EACA4E,GAAAhF,KAAA1B,OAGA,QAAAG,GAAA,EAAqBA,EAAA2jC,EAAa3jC,IAClC,CAEA,OADAH,GAAA,GAAA2c,OAAAknB,GACA7vB,EAAA,EAAAgc,EAAAyT,EAAA/iC,OAAA29B,EAAAoF,EAAAzvB,GAA+DA,EAAAgc,EAAUhc,IAAAqqB,EAAAoF,EAAAzvB,GACzEhU,EAAAgU,GAAA,GAAAP,IAAAmV,SAAAxf,EAAAjJ,GAAAyB,EAAAy8B,EAAAz8B,EAAAwH,EAAAjJ,GAAA2B,EAAAu8B,EAAAv8B,EACA4E,GAAAhF,KAAA1B,GAGA,OADA+jC,GAAA,GAAApnB,OACAxc,EAAA,EAAmBA,EAAA2jC,EAAA,EAAAF,EAAyBzjC,IAC5C,OAAA6T,GAAA,EAAqBA,EAAA6vB,EAAa7vB,IAClC,CACA,GAAAgwB,GAAA,GAAArnB,MACAqnB,GAAAtiC,KAAAgF,EAAAvG,EAAA2jC,GAAA9vB,EAAA6vB,IACAG,EAAAtiC,KAAAgF,GAAAvG,EAAA,GAAA2jC,GAAA9vB,EAAA6vB,IACAG,EAAAtiC,KAAAgF,GAAAvG,EAAA,GAAA2jC,IAAA9vB,EAAA,GAAA6vB,IACAG,EAAAtiC,KAAAgF,EAAAvG,EAAA2jC,IAAA9vB,EAAA,GAAA6vB,IACApwB,GAAAvI,QAAA4zB,YAAAkF,IACAA,EAAAnF,UACAkF,EAAAriC,KAAAsiC,GAEA,MAAAD,IAGAtwB,GAAAvI,QAAA+4B,aAAA,SAAAR,EAAAS,EAAAC,GAEA,GAAAD,EAAA,YAAAvnB,OAUA,CAIA,OAHAzT,GAAAg7B,EACA9P,EAAA,GAAA3gB,IAAA2S,MACArmB,EAAA,GAAA0T,IAAAvI,QACA/K,EAAA,EAAkBA,EAAA+I,EAAAxI,SAAkBP,EACpC,CACA,GAAAoyB,GAAA9e,GAAAvI,QAAAs4B,UAAAC,EAAAv6B,EAAA/I,IAAA,EAAAgkC,EAEA,IADApkC,EAAAuL,SAAAinB,EAAA9e,GAAAlI,SAAAC,WAAA,GACA24B,EACA,CACA,GAAA/6B,GAAAqK,GAAAvI,QAAAk5B,cAAAl7B,EAAA/I,GAAAsjC,EAAA,GACA1jC,GAAAuxB,QAAAloB,EAAAqK,GAAAlI,SAAA0e,QAAA,IAKA,MAFAlqB,GAAA0L,QAAAgI,GAAA/H,SAAAC,QAAAyoB,EACA3gB,GAAA7I,aAAAC,WAAA4I,GAAA7I,aAAAC,YACAupB,EAxBA,GAAAhrB,GAAA86B,EACAh7B,EAAAuK,GAAAvI,QAAAs4B,UAAAC,EAAAr6B,GAAA,EAAA+6B,GACApkC,EAAA,GAAA0T,IAAAvI,OAGA,OAFAnL,GAAAuL,SAAApC,EAAAuK,GAAAlI,SAAAC,WAAA,GACAzL,EAAA0L,QAAAgI,GAAA/H,SAAAC,QAAAzC,EAAAuK,GAAA7I,aAAAC,WAAA4I,GAAA7I,aAAAC,YACA3B,GAwBAuK,GAAAvI,QAAAk5B,cAAA,SAAAh7B,EAAAw6B,GAGA,OADAS,GAAA,GAAA5wB,IAAArR,KACAjC,EAAA,EAAiBA,EAAAiJ,EAAA1I,OAAiBP,IAClCkkC,EAAA3iC,KAAA,GAAA+R,IAAAmV,SAAAxf,EAAAjJ,GAAAyB,EAAAgiC,EAAAhiC,EAAAwH,EAAAjJ,GAAA2B,EAAA8hC,EAAA9hC,GACA,OAAAuiC,IAIA5wB,GAAAvI,QAAAo5B,cAAA,SAAAC,EAAAC,GAEA,GAAAt7B,GAAAuK,GAAAvI,QAAAs4B,UAAAe,EAAAC,GAAA,MACAzkC,EAAA,GAAA0T,IAAAvI,OAGA,OAFAnL,GAAAuL,SAAApC,EAAAuK,GAAAlI,SAAAC,WAAA,GACAzL,EAAA0L,QAAAgI,GAAA/H,SAAAC,QAAAzC,EAAAuK,GAAA7I,aAAAC,WAAA4I,GAAA7I,aAAAC,YACA3B,GAGAuK,GAAAvI,QAAAU,gBAAA,SAAA8oB,GAEA,GAAAhuB,GAAA,GAAAiW,MAGA,OADAlJ,IAAAvI,QAAAu5B,mBAAA/P,EAAAjhB,GAAAvI,QAAAw5B,SAAAC,MAAAj+B,GACAA,GAEA+M,GAAAvI,QAAAu5B,mBAAA,SAAAG,EAAAC,EAAA37B,GAEA,GAAA9C,IAAA,CACA,QAAAy+B,GAEA,IAAApxB,IAAAvI,QAAAw5B,SAAAI,OACA,MACA,KAAArxB,IAAAvI,QAAAw5B,SAAAK,SACA3+B,GAAAw+B,EAAA3d,OAKA2d,EAAAhe,UAAAlmB,OAAA,GAAA0F,GACA8C,EAAAxH,KAAAkjC,EAAAhe,UACA,QAAAoe,GAAA,EAAAC,EAAAL,EAAAjd,SAAAud,EAAAD,EAAAvkC,OAAAy+B,EAAA8F,EAAAD,GAA+EA,EAAAE,EAAWF,IAAA7F,EAAA8F,EAAAD,GAC1FvxB,GAAAvI,QAAAu5B,mBAAAtF,EAAA0F,EAAA37B,IAEAuK,GAAAvI,QAAAi6B,sBAAA,SAAAzQ,GAIA,OAFAhuB,GAAA,GAAA+M,IAAA2S,MAEAjmB,EAAA,EAAA4nB,EAAA2M,EAAAtN,aAAiDjnB,EAAA4nB,EAAU5nB,IAC3Du0B,EAAA/M,SAAAxnB,GAAA8mB,QACAvgB,EAAAhF,KAAAgzB,EAAA/M,SAAAxnB,GAAAymB,UACA,OAAAlgB,IAEA+M,GAAAvI,QAAAk6B,wBAAA,SAAA1Q,GAEA,GAAAhuB,GAAA,GAAA+M,IAAA2S,KAGA,OADA3S,IAAAvI,QAAAu5B,mBAAA/P,EAAAjhB,GAAAvI,QAAAw5B,SAAAK,SAAAr+B,GACAA,GAEAof,GAAArS,GAAAvI,QAAAuI,GAAAoa,aACApa,GAAAvI,QAAAw5B,UACAC,MAAA,EACAG,OAAA,EACAC,SAAA,GAEAtxB,GAAA4xB,cAAA,SAAAC,EAAAC,GAEA,wBAAAD,EAAA,GACA,wBAAAC,EAAA9xB,GAAA4xB,cAAAG,mBACAlmC,KAAAmmC,YAAA,GAAAhyB,IAAA2S,MACA9mB,KAAAomC,UAAA,GAAAjyB,IAAArR,KACA9C,KAAAqmC,WAAA,GAAAlyB,IAAArR,KACA9C,KAAAsmC,UAAA,GAAAjpB,OACArd,KAAAumC,QAAA,EACAvmC,KAAAwmC,OAAA,EACAxmC,KAAAymC,MAAA,EACAzmC,KAAA0mC,MAAA,EACA1mC,KAAA2mC,WAAA,EACA3mC,KAAA4mC,cAAA,EACA5mC,KAAA6mC,SAAA,GAAA1yB,IAAAmV,SACAtpB,KAAA8mC,YAAA,GAAA3yB,IAAAiT,SACApnB,KAAA+mC,WAAAf,EACAhmC,KAAAgnC,aAAAf,EACAjmC,KAAA6mC,SAAAvkC,GAAA,GAEA6R,GAAA4xB,cAAAkB,OAAA,iBACA9yB,GAAA4xB,cAAAG,kBAAA,IACA/xB,GAAA4xB,cAAAtkC,UAAAgL,MAAA,WAEA0H,GAAA1H,MAAAzM,KAAA8mC,YAAAze,UACAroB,KAAA6mC,SAAAvkC,GAAA,GAEA6R,GAAA4xB,cAAAtc,MAAAtV,GAAAvI,QAAA6d,MACAtV,GAAA4xB,cAAAtkC,UAAAuwB,QAAA,SAAAloB,EAAAo9B,EAAAC,GAEA,GAAAhV,GAAAroB,EAAA1I,OAAA,CACA,MAAA+wB,EAAA,IAEA,GAAAgM,GAAA,GAAAhqB,IAAAiT,QAIA,IAHA+W,EAAA3W,WAAA0f,EACA/I,EAAA1W,UAAA0f,EAEAA,GAAAhzB,GAAA+W,QAAAI,cAAA6b,GAAAhzB,GAAA+W,QAAAK,gBACA,KAAA4G,EAAA,GAAAhe,GAAAmV,SAAA3D,YAAA7b,EAAA,GAAAA,EAAAqoB,KACAA,GAEAgM,GAAA7W,UAAAllB,KAAA0H,EAAA,GAGA,QAFA4K,GAAA,EACAoB,EAAA,EACAjV,EAAA,EAAmBA,GAAAsxB,EAAYtxB,IAC/BsT,GAAAmV,SAAAxD,cAAAqY,EAAA7W,UAAA5S,GAAA5K,EAAAjJ,MAEA6T,IACAypB,EAAA7W,UAAAllB,KAAA0H,EAAAjJ,KACAiJ,EAAAjJ,GAAA2B,EAAA27B,EAAA7W,UAAAxR,GAAAtT,GAAAsH,EAAAjJ,GAAA2B,GAAA27B,EAAA7W,UAAAxR,GAAAtT,GAAAsH,EAAAjJ,GAAAyB,EAAA67B,EAAA7W,UAAAxR,GAAAxT,KACAwT,EAAApB,GAEA,MAAAyyB,GAAAhzB,GAAA+W,QAAAK,iBAAA7W,EAAA,KAEA1U,KAAA8mC,YAAA9e,SAAAmW,GAEAgJ,GAAAhzB,GAAA+W,QAAAK,iBAEA,GAAAvrB,KAAA6mC,SAAAvkC,EAAA,EACAtC,KAAA6mC,SAAA,GAAA1yB,IAAAmV,SAAAtpB,KAAA8mC,YAAAhf,aAAA,EAAAhS,OAEA,CACA,GAAAipB,GAAA/+B,KAAA8mC,YAAAze,SAAAroB,KAAA6mC,SAAAvkC,GAAAglB,UAAAtnB,KAAA6mC,SAAArkC,IACA27B,EAAA7W,UAAAxR,GAAAtT,EAAAu8B,EAAAv8B,GAAA27B,EAAA7W,UAAAxR,GAAAtT,GAAAu8B,EAAAv8B,GAAA27B,EAAA7W,UAAAxR,GAAAxT,EAAAy8B,EAAAz8B,KACAtC,KAAA6mC,SAAA,GAAA1yB,IAAAmV,SAAAtpB,KAAA8mC,YAAAhf,aAAA,EAAAhS,OAGA3B,GAAA4xB,cAAAtkC,UAAAuK,SAAA,SAAApC,EAAAs9B,EAAAC,GAEA,OAAAtmC,GAAA,EAAA4nB,EAAA7e,EAAAxI,OAAwCP,EAAA4nB,EAAU5nB,IAClDb,KAAAgyB,QAAApoB,EAAA/I,GAAAqmC,EAAAC,IAEAhzB,GAAA4xB,cAAAtkC,UAAA2lC,gBAAA,WAIA,GAAApnC,KAAA6mC,SAAAvkC,GAAA,IAAA6R,GAAAvI,QAAA4zB,YAAAx/B,KAAA8mC,YAAAze,SAAAroB,KAAA6mC,SAAAvkC,GAAAglB,WAEA,OAAAzmB,GAAA,EAAqBA,EAAAb,KAAA8mC,YAAAhf,aAAmCjnB,IACxD,CACA,GAAAgnB,GAAA7nB,KAAA8mC,YAAAze,SAAAxnB,IACAgnB,EAAAJ,WAAAtT,GAAA+W,QAAAK,iBAAA1D,EAAAJ,WAAAtT,GAAA+W,QAAAI,cAAAnX,GAAAvI,QAAA4zB,YAAA3X,EAAAP,aACAO,EAAAP,UAAAiY,cAKA,QAAA1+B,GAAA,EAAqBA,EAAAb,KAAA8mC,YAAAhf,aAAmCjnB,IACxD,CACA,GAAAgnB,GAAA7nB,KAAA8mC,YAAAze,SAAAxnB,EACAgnB,GAAAJ,WAAAtT,GAAA+W,QAAAI,cAAAnX,GAAAvI,QAAA4zB,YAAA3X,EAAAP,YACAO,EAAAP,UAAAiY,YAIAprB,GAAA4xB,cAAAsB,cAAA,SAAAnX,EAAAC,GAEA,GAAAxe,GAAAwe,EAAA7tB,EAAA4tB,EAAA5tB,EACAsP,EAAAue,EAAA3tB,EAAA0tB,EAAA1tB,CACA,OAAAmP,GAAA,GAAAC,EACA,UAAAuC,IAAA4S,YAAA,IACA,IAAAlJ,GAAA,EAAAtU,KAAA+9B,KAAA31B,IAAAC,IAGA,OAFAD,IAAAkM,EACAjM,GAAAiM,EACA,GAAA1J,IAAA4S,YAAAnV,GAAAD,IAEAwC,GAAA4xB,cAAAtkC,UAAA8lC,SAAA,SAAAjD,GAKA,GAHAtkC,KAAAmmC,YAAA,GAAA9oB,OACArd,KAAAumC,QAAAjC,EAEAnwB,GAAAoa,YAAAa,UAAAkV,GAGA,OAAAzjC,GAAA,EAAqBA,EAAAb,KAAA8mC,YAAAhf,aAAmCjnB,IACxD,CACA,GAAAgnB,GAAA7nB,KAAA8mC,YAAAze,SAAAxnB,EACAgnB,GAAAJ,WAAAtT,GAAA+W,QAAAK,iBACAvrB,KAAAmmC,YAAA/jC,KAAAylB,EAAAP,eAPA,CAYAtnB,KAAA+mC,WAAA,EACA/mC,KAAA2mC,WAAA,GAAA3mC,KAAA+mC,WAAA/mC,KAAA+mC,YAEA/mC,KAAA2mC,WAAA,EACA,IAAA/kC,EAEAA,GADA5B,KAAAgnC,cAAA,EACA7yB,GAAA4xB,cAAAG,kBACAlmC,KAAAgnC,aAAAz9B,KAAAsO,IAAAysB,GAAAnwB,GAAA4xB,cAAAG,kBACA38B,KAAAsO,IAAAysB,GAAAnwB,GAAA4xB,cAAAG,kBAEAlmC,KAAAgnC,YAEA,IAAAQ,GAAA,iBAAAj+B,KAAAk+B,KAAA,EAAA7lC,EAAA2H,KAAAsO,IAAAysB,GACAtkC,MAAAymC,MAAAl9B,KAAAuB,IAAAqJ,GAAA4xB,cAAAkB,OAAAO,GACAxnC,KAAA0mC,MAAAn9B,KAAAsB,IAAAsJ,GAAA4xB,cAAAkB,OAAAO,GACAxnC,KAAA4mC,cAAAY,EAAArzB,GAAA4xB,cAAAkB,OACA3C,EAAA,IACAtkC,KAAAymC,OAAAzmC,KAAAymC,MAEA,QAAA5lC,GAAA,EAAmBA,EAAAb,KAAA8mC,YAAAhf,aAAmCjnB,IACtD,CACA,GAAAgnB,GAAA7nB,KAAA8mC,YAAAze,SAAAxnB,EACAb,MAAAomC,UAAAve,EAAAP,SACA,IAAAgY,GAAAt/B,KAAAomC,UAAAhlC,MACA,SAAAk+B,GAAAgF,GAAA,IAAAhF,EAAA,GAAAzX,EAAAJ,WAAAtT,GAAA+W,QAAAK,kBAGA,GADAvrB,KAAAqmC,WAAA,GAAAhpB,OACA,GAAAiiB,EAAA,CAiCAt/B,KAAAsmC,UAAAllC,OAAA,CAEA,QAAAsT,GAAA,EAAqBA,EAAA4qB,EAAA,EAAa5qB,IAClC1U,KAAAsmC,UAAAlkC,KAAA+R,GAAA4xB,cAAAsB,cAAArnC,KAAAomC,UAAA1xB,GAAA1U,KAAAomC,UAAA1xB,EAAA,IAKA,IAJAmT,EAAAJ,WAAAtT,GAAA+W,QAAAI,cAAAzD,EAAAJ,WAAAtT,GAAA+W,QAAAK,gBACAvrB,KAAAsmC,UAAAlkC,KAAA+R,GAAA4xB,cAAAsB,cAAArnC,KAAAomC,UAAA9G,EAAA,GAAAt/B,KAAAomC,UAAA,KAEApmC,KAAAsmC,UAAAlkC,KAAA,GAAA+R,IAAA4S,YAAA/mB,KAAAsmC,UAAAhH,EAAA,KACAzX,EAAAJ,WAAAtT,GAAA+W,QAAAK,gBACA,CAEA,OADAzV,GAAAwpB,EAAA,EACA5qB,EAAA,EAAuBA,EAAA4qB,EAAS5qB,IAChCoB,EAAA9V,KAAA0nC,YAAAhzB,EAAAoB,EAAA+R,EAAAL,WACAxnB,MAAAmmC,YAAA/jC,KAAApC,KAAAqmC,gBAEA,IAAAxe,EAAAJ,WAAAtT,GAAA+W,QAAAI,aACA,CAEA,OADAxV,GAAAwpB,EAAA,EACA5qB,EAAA,EAAuBA,EAAA4qB,EAAS5qB,IAChCoB,EAAA9V,KAAA0nC,YAAAhzB,EAAAoB,EAAA+R,EAAAL,WACAxnB,MAAAmmC,YAAA/jC,KAAApC,KAAAqmC,YACArmC,KAAAqmC,WAAA,GAAAhpB,MAGA,QADAzc,GAAAZ,KAAAsmC,UAAAhH,EAAA,GACA5qB,EAAA4qB,EAAA,EAA6B5qB,EAAA,EAAOA,IACpC1U,KAAAsmC,UAAA5xB,GAAA,GAAAP,IAAA4S,aAAA/mB,KAAAsmC,UAAA5xB,EAAA,GAAApS,GAAAtC,KAAAsmC,UAAA5xB,EAAA,GAAAlS,EACAxC,MAAAsmC,UAAA,MAAAnyB,IAAA4S,aAAAnmB,EAAA0B,GAAA1B,EAAA4B,GACAsT,EAAA,CACA,QAAApB,GAAA4qB,EAAA,EAA6B5qB,GAAA,EAAQA,IACrCoB,EAAA9V,KAAA0nC,YAAAhzB,EAAAoB,EAAA+R,EAAAL,WACAxnB,MAAAmmC,YAAA/jC,KAAApC,KAAAqmC,gBAGA,CAEA,OADAvwB,GAAA,EACApB,EAAA,EAAuBA,EAAA4qB,EAAA,IAAa5qB,EACpCoB,EAAA9V,KAAA0nC,YAAAhzB,EAAAoB,EAAA+R,EAAAL,WACA,IAAA0I,EACA,IAAArI,EAAAJ,WAAAtT,GAAA+W,QAAAG,WACA,CACA,GAAA3W,GAAA4qB,EAAA,CACApP,GAAA,GAAA/b,IAAAmV,SAAAnV,GAAA4xB,cAAAtc,MAAAzpB,KAAAomC,UAAA1xB,GAAApS,EAAAtC,KAAAsmC,UAAA5xB,GAAApS,EAAAgiC,GAAAnwB,GAAA4xB,cAAAtc,MAAAzpB,KAAAomC,UAAA1xB,GAAAlS,EAAAxC,KAAAsmC,UAAA5xB,GAAAlS,EAAA8hC,IACAtkC,KAAAqmC,WAAAjkC,KAAA8tB,GACAA,EAAA,GAAA/b,IAAAmV,SAAAnV,GAAA4xB,cAAAtc,MAAAzpB,KAAAomC,UAAA1xB,GAAApS,EAAAtC,KAAAsmC,UAAA5xB,GAAApS,EAAAgiC,GAAAnwB,GAAA4xB,cAAAtc,MAAAzpB,KAAAomC,UAAA1xB,GAAAlS,EAAAxC,KAAAsmC,UAAA5xB,GAAAlS,EAAA8hC,IACAtkC,KAAAqmC,WAAAjkC,KAAA8tB,OAGA,CACA,GAAAxb,GAAA4qB,EAAA,CACAxpB,GAAAwpB,EAAA,EACAt/B,KAAAwmC,OAAA,EACAxmC,KAAAsmC,UAAA5xB,GAAA,GAAAP,IAAA4S,aAAA/mB,KAAAsmC,UAAA5xB,GAAApS,GAAAtC,KAAAsmC,UAAA5xB,GAAAlS,GACAqlB,EAAAJ,WAAAtT,GAAA+W,QAAAC,aACAnrB,KAAA2nC,SAAAjzB,EAAAoB,GAEA9V,KAAA4nC,QAAAlzB,EAAAoB,GAGA,OAAApB,GAAA4qB,EAAA,EAA6B5qB,EAAA,EAAOA,IACpC1U,KAAAsmC,UAAA5xB,GAAA,GAAAP,IAAA4S,aAAA/mB,KAAAsmC,UAAA5xB,EAAA,GAAApS,GAAAtC,KAAAsmC,UAAA5xB,EAAA,GAAAlS,EACAxC,MAAAsmC,UAAA,MAAAnyB,IAAA4S,aAAA/mB,KAAAsmC,UAAA,GAAAhkC,GAAAtC,KAAAsmC,UAAA,GAAA9jC,GACAsT,EAAAwpB,EAAA,CACA,QAAA5qB,GAAAoB,EAAA,EAA2BpB,EAAA,IAAOA,EAClCoB,EAAA9V,KAAA0nC,YAAAhzB,EAAAoB,EAAA+R,EAAAL,WACAK,GAAAJ,WAAAtT,GAAA+W,QAAAG,YAEA6E,EAAA,GAAA/b,IAAAmV,SAAAnV,GAAA4xB,cAAAtc,MAAAzpB,KAAAomC,UAAA,GAAA9jC,EAAAtC,KAAAsmC,UAAA,GAAAhkC,EAAAgiC,GAAAnwB,GAAA4xB,cAAAtc,MAAAzpB,KAAAomC,UAAA,GAAA5jC,EAAAxC,KAAAsmC,UAAA,GAAA9jC,EAAA8hC,IACAtkC,KAAAqmC,WAAAjkC,KAAA8tB,GACAA,EAAA,GAAA/b,IAAAmV,SAAAnV,GAAA4xB,cAAAtc,MAAAzpB,KAAAomC,UAAA,GAAA9jC,EAAAtC,KAAAsmC,UAAA,GAAAhkC,EAAAgiC,GAAAnwB,GAAA4xB,cAAAtc,MAAAzpB,KAAAomC,UAAA,GAAA5jC,EAAAxC,KAAAsmC,UAAA,GAAA9jC,EAAA8hC,IACAtkC,KAAAqmC,WAAAjkC,KAAA8tB,KAIApa,EAAA,EACA9V,KAAAwmC,OAAA,EACA3e,EAAAJ,WAAAtT,GAAA+W,QAAAC,aACAnrB,KAAA2nC,SAAA,KAEA3nC,KAAA4nC,QAAA,MAEA5nC,KAAAmmC,YAAA/jC,KAAApC,KAAAqmC,iBAjHA,CAEA,GAAAxe,EAAAL,YAAArT,GAAA2W,SAAAE,QAIA,OAFA1oB,GAAA,EACAE,EAAA,EACAkS,EAAA,EAAyBA,GAAA8yB,EAAY9yB,IACrC,CACA1U,KAAAqmC,WAAAjkC,KAAA,GAAA+R,IAAAmV,SAAAnV,GAAA4xB,cAAAtc,MAAAzpB,KAAAomC,UAAA,GAAA9jC,IAAAgiC,GAAAnwB,GAAA4xB,cAAAtc,MAAAzpB,KAAAomC,UAAA,GAAA5jC,IAAA8hC,IACA,IAAAuD,GAAAvlC,CACAA,KAAAtC,KAAA0mC,MAAA1mC,KAAAymC,MAAAjkC,EACAA,EAAAqlC,EAAA7nC,KAAAymC,MAAAjkC,EAAAxC,KAAA0mC,UAOA,QAFApkC,IAAA,EACAE,GAAA,EACAkS,EAAA,EAAyBA,EAAA,IAAOA,EAEhC1U,KAAAqmC,WAAAjkC,KAAA,GAAA+R,IAAAmV,SAAAnV,GAAA4xB,cAAAtc,MAAAzpB,KAAAomC,UAAA,GAAA9jC,IAAAgiC,GAAAnwB,GAAA4xB,cAAAtc,MAAAzpB,KAAAomC,UAAA,GAAA5jC,IAAA8hC,KACAhiC,EAAA,EACAA,EAAA,EACAE,EAAA,EACAA,EAAA,EAEAF,GAAA,CAGAtC,MAAAmmC,YAAA/jC,KAAApC,KAAAqmC,gBAwFAlyB,GAAA4xB,cAAAtkC,UAAA0K,QAAA,WAEA,GAAA8H,GAAA5R,UACAuyB,EAAA3gB,EAAA,YAAAE,IAAAzI,QACA,IAAAkpB,EA+BA,CACA,GAAAE,GAAA7gB,EAAA,GACAqwB,EAAArwB,EAAA,EACA6gB,GAAAroB,QACAzM,KAAAonC,kBACApnC,KAAAunC,SAAAjD,EAEA,IAAAwD,GAAA,GAAA3zB,IAAAvI,QAAA,EAEA,IADAk8B,EAAA97B,SAAAhM,KAAAmmC,YAAAhyB,GAAAlI,SAAAC,WAAA,GACAo4B,EAAA,EAEAwD,EAAA37B,QAAAgI,GAAA/H,SAAAC,QAAAyoB,EAAA3gB,GAAA7I,aAAAsf,YAAAzW,GAAA7I,aAAAsf,iBAGA,CACA,GAAA3oB,GAAAkS,GAAAvI,QAAAs1B,UAAAlhC,KAAAmmC,aACAj7B,EAAA,GAAAiJ,IAAArR,IASA,IARAoI,EAAA9I,KAAA,GAAA+R,IAAAmV,SAAArnB,EAAA+nB,KAAA,GAAA/nB,EAAAkoB,OAAA,KACAjf,EAAA9I,KAAA,GAAA+R,IAAAmV,SAAArnB,EAAAioB,MAAA,GAAAjoB,EAAAkoB,OAAA,KACAjf,EAAA9I,KAAA,GAAA+R,IAAAmV,SAAArnB,EAAAioB,MAAA,GAAAjoB,EAAAgoB,IAAA,KACA/e,EAAA9I,KAAA,GAAA+R,IAAAmV,SAAArnB,EAAA+nB,KAAA,GAAA/nB,EAAAgoB,IAAA,KACA6d,EAAA9V,QAAA9mB,EAAAiJ,GAAAlI,SAAAC,WAAA,GACA47B,EAAA5T,iBAAA,EACA4T,EAAA37B,QAAAgI,GAAA/H,SAAAC,QAAAyoB,EAAA3gB,GAAA7I,aAAAuf,YAAA1W,GAAA7I,aAAAuf,aAEA,GAAAiK,EAAAhN,cAAAgN,EAAAzM,SAAA,GAAAP,aAAA,EACA,CACA,GAAAigB,GAAAjT,EAAAzM,SAAA,EAEAyM,GAAAzM,SAAA,GAAA0f,EAAA1f,SAAA,GACAyM,EAAAzM,SAAA,GAAAhB,SAAAyN,CACA,QAAAj0B,GAAA,EAAyBA,EAAAknC,EAAAjgB,aAA4BjnB,IACrDi0B,EAAA9M,SAAA+f,EAAA1f,SAAAxnB,QAGAi0B,GAAAroB,aAjEA,CACA,GAAAqoB,GAAA7gB,EAAA,GACAqwB,EAAArwB,EAAA,EACAE,IAAA1H,MAAAqoB,GACA90B,KAAAonC,kBACApnC,KAAAunC,SAAAjD,EAEA,IAAAwD,GAAA,GAAA3zB,IAAAvI,QAAA,EAEA,IADAk8B,EAAA97B,SAAAhM,KAAAmmC,YAAAhyB,GAAAlI,SAAAC,WAAA,GACAo4B,EAAA,EAEAwD,EAAA37B,QAAAgI,GAAA/H,SAAAC,QAAAyoB,EAAA3gB,GAAA7I,aAAAsf,YAAAzW,GAAA7I,aAAAsf,iBAGA,CACA,GAAA3oB,GAAAkS,GAAAvI,QAAAs1B,UAAAlhC,KAAAmmC,aACAj7B,EAAA,GAAAiJ,IAAArR,IACAoI,GAAA9I,KAAA,GAAA+R,IAAAmV,SAAArnB,EAAA+nB,KAAA,GAAA/nB,EAAAkoB,OAAA,KACAjf,EAAA9I,KAAA,GAAA+R,IAAAmV,SAAArnB,EAAAioB,MAAA,GAAAjoB,EAAAkoB,OAAA,KACAjf,EAAA9I,KAAA,GAAA+R,IAAAmV,SAAArnB,EAAAioB,MAAA,GAAAjoB,EAAAgoB,IAAA,KACA/e,EAAA9I,KAAA,GAAA+R,IAAAmV,SAAArnB,EAAA+nB,KAAA,GAAA/nB,EAAAgoB,IAAA,KACA6d,EAAA9V,QAAA9mB,EAAAiJ,GAAAlI,SAAAC,WAAA,GACA47B,EAAA5T,iBAAA,EACA4T,EAAA37B,QAAAgI,GAAA/H,SAAAC,QAAAyoB,EAAA3gB,GAAA7I,aAAAuf,YAAA1W,GAAA7I,aAAAuf,aACAiK,EAAA1zB,OAAA,GACA0zB,EAAA9iB,OAAA,QA4CAmC,GAAA4xB,cAAAtkC,UAAAimC,YAAA,SAAAhzB,EAAAoB,EAAAkyB,GAKA,GAFAhoC,KAAAwmC,OAAAxmC,KAAAsmC,UAAAxwB,GAAAxT,EAAAtC,KAAAsmC,UAAA5xB,GAAAlS,EAAAxC,KAAAsmC,UAAA5xB,GAAApS,EAAAtC,KAAAsmC,UAAAxwB,GAAAtT,EAEA+G,KAAAsO,IAAA7X,KAAAwmC,OAAAxmC,KAAAumC,SAAA,EACA,CAEA,GAAA0B,GAAAjoC,KAAAsmC,UAAAxwB,GAAAxT,EAAAtC,KAAAsmC,UAAA5xB,GAAApS,EAAAtC,KAAAsmC,UAAA5xB,GAAAlS,EAAAxC,KAAAsmC,UAAAxwB,GAAAtT,CACA,IAAAylC,EAAA,EAIA,MAFAjoC,MAAAqmC,WAAAjkC,KAAA,GAAA+R,IAAAmV,SAAAnV,GAAA4xB,cAAAtc,MAAAzpB,KAAAomC,UAAA1xB,GAAApS,EAAAtC,KAAAsmC,UAAAxwB,GAAAxT,EAAAtC,KAAAumC,SACApyB,GAAA4xB,cAAAtc,MAAAzpB,KAAAomC,UAAA1xB,GAAAlS,EAAAxC,KAAAsmC,UAAAxwB,GAAAtT,EAAAxC,KAAAumC,WACAzwB,MAIA9V,MAAAwmC,OAAA,EACAxmC,KAAAwmC,OAAA,EACAxmC,KAAAwmC,QAAA,IACAxmC,KAAAwmC,QAAA,EACA,IAAAxmC,KAAAwmC,OAAAxmC,KAAAumC,QAAA,EAEAvmC,KAAAqmC,WAAAjkC,KAAA,GAAA+R,IAAAmV,SAAAnV,GAAA4xB,cAAAtc,MAAAzpB,KAAAomC,UAAA1xB,GAAApS,EAAAtC,KAAAsmC,UAAAxwB,GAAAxT,EAAAtC,KAAAumC,SACApyB,GAAA4xB,cAAAtc,MAAAzpB,KAAAomC,UAAA1xB,GAAAlS,EAAAxC,KAAAsmC,UAAAxwB,GAAAtT,EAAAxC,KAAAumC,WACAvmC,KAAAqmC,WAAAjkC,KAAA,GAAA+R,IAAAmV,SAAAtpB,KAAAomC,UAAA1xB,KACA1U,KAAAqmC,WAAAjkC,KAAA,GAAA+R,IAAAmV,SAAAnV,GAAA4xB,cAAAtc,MAAAzpB,KAAAomC,UAAA1xB,GAAApS,EAAAtC,KAAAsmC,UAAA5xB,GAAApS,EAAAtC,KAAAumC,SACApyB,GAAA4xB,cAAAtc,MAAAzpB,KAAAomC,UAAA1xB,GAAAlS,EAAAxC,KAAAsmC,UAAA5xB,GAAAlS,EAAAxC,KAAAumC,eAGA,QAAAyB,GAEA,IAAA7zB,IAAA2W,SAAAG,QAEA,GAAAhpB,GAAA,GAAAjC,KAAAsmC,UAAA5xB,GAAApS,EAAAtC,KAAAsmC,UAAAxwB,GAAAxT,EAAAtC,KAAAsmC,UAAA5xB,GAAAlS,EAAAxC,KAAAsmC,UAAAxwB,GAAAtT,EACAP,IAAAjC,KAAA2mC,WACA3mC,KAAAkoC,QAAAxzB,EAAAoB,EAAA7T,GAEAjC,KAAA2nC,SAAAjzB,EAAAoB,EACA,MAEA,KAAA3B,IAAA2W,SAAAC,SACA/qB,KAAA2nC,SAAAjzB,EAAAoB,EACA,MACA,KAAA3B,IAAA2W,SAAAE,QACAhrB,KAAA4nC,QAAAlzB,EAAAoB,GAIA,MADAA,GAAApB,GAGAP,GAAA4xB,cAAAtkC,UAAAkmC,SAAA,SAAAjzB,EAAAoB,GAEA,GAAAnE,GAAApI,KAAAwB,IAAAxB,KAAA4+B,MAAAnoC,KAAAwmC,OACAxmC,KAAAsmC,UAAAxwB,GAAAxT,EAAAtC,KAAAsmC,UAAA5xB,GAAApS,EAAAtC,KAAAsmC,UAAAxwB,GAAAtT,EAAAxC,KAAAsmC,UAAA5xB,GAAAlS,GAAA,EACAxC,MAAAqmC,WAAAjkC,KAAA,GAAA+R,IAAAmV,SACAnV,GAAA4xB,cAAAtc,MAAAzpB,KAAAomC,UAAA1xB,GAAApS,EAAAtC,KAAAumC,SAAAvmC,KAAAsmC,UAAAxwB,GAAAxT,EAAAtC,KAAAsmC,UAAAxwB,GAAAtT,EAAAmP,IACAwC,GAAA4xB,cAAAtc,MAAAzpB,KAAAomC,UAAA1xB,GAAAlS,EAAAxC,KAAAumC,SAAAvmC,KAAAsmC,UAAAxwB,GAAAtT,EAAAxC,KAAAsmC,UAAAxwB,GAAAxT,EAAAqP,MACA3R,KAAAqmC,WAAAjkC,KAAA,GAAA+R,IAAAmV,SACAnV,GAAA4xB,cAAAtc,MAAAzpB,KAAAomC,UAAA1xB,GAAApS,EAAAtC,KAAAumC,SAAAvmC,KAAAsmC,UAAA5xB,GAAApS,EAAAtC,KAAAsmC,UAAA5xB,GAAAlS,EAAAmP,IACAwC,GAAA4xB,cAAAtc,MAAAzpB,KAAAomC,UAAA1xB,GAAAlS,EAAAxC,KAAAumC,SAAAvmC,KAAAsmC,UAAA5xB,GAAAlS,EAAAxC,KAAAsmC,UAAA5xB,GAAApS,EAAAqP,OAEAwC,GAAA4xB,cAAAtkC,UAAAymC,QAAA,SAAAxzB,EAAAoB,EAAA7T,GAEA,GAAAgW,GAAAjY,KAAAumC,QAAAtkC,CACAjC,MAAAqmC,WAAAjkC,KAAA,GAAA+R,IAAAmV,SACAnV,GAAA4xB,cAAAtc,MAAAzpB,KAAAomC,UAAA1xB,GAAApS,GAAAtC,KAAAsmC,UAAAxwB,GAAAxT,EAAAtC,KAAAsmC,UAAA5xB,GAAApS,GAAA2V,GACA9D,GAAA4xB,cAAAtc,MAAAzpB,KAAAomC,UAAA1xB,GAAAlS,GAAAxC,KAAAsmC,UAAAxwB,GAAAtT,EAAAxC,KAAAsmC,UAAA5xB,GAAAlS,GAAAyV,MAEA9D,GAAA4xB,cAAAtkC,UAAAmmC,QAAA,SAAAlzB,EAAAoB,GAUA,OADA+xB,GAPA5zB,EAAA1K,KAAA4+B,MAAAnoC,KAAAwmC,OACAxmC,KAAAsmC,UAAAxwB,GAAAxT,EAAAtC,KAAAsmC,UAAA5xB,GAAApS,EAAAtC,KAAAsmC,UAAAxwB,GAAAtT,EAAAxC,KAAAsmC,UAAA5xB,GAAAlS,GAEAglC,EAAAj+B,KAAAyF,IAAAmF,GAAA6U,WAAA7U,GAAA4xB,cAAAtc,MAAAzpB,KAAA4mC,cAAAr9B,KAAAsO,IAAA5D,KAAA,GAEA3R,EAAAtC,KAAAsmC,UAAAxwB,GAAAxT,EACAE,EAAAxC,KAAAsmC,UAAAxwB,GAAAtT,EAEA3B,EAAA,EAAmBA,EAAA2mC,IAAW3mC,EAE9Bb,KAAAqmC,WAAAjkC,KAAA,GAAA+R,IAAAmV,SACAnV,GAAA4xB,cAAAtc,MAAAzpB,KAAAomC,UAAA1xB,GAAApS,IAAAtC,KAAAumC,SACApyB,GAAA4xB,cAAAtc,MAAAzpB,KAAAomC,UAAA1xB,GAAAlS,IAAAxC,KAAAumC,WACAsB,EAAAvlC,EACAA,IAAAtC,KAAA0mC,MAAA1mC,KAAAymC,MAAAjkC,EACAA,EAAAqlC,EAAA7nC,KAAAymC,MAAAjkC,EAAAxC,KAAA0mC,KAEA1mC,MAAAqmC,WAAAjkC,KAAA,GAAA+R,IAAAmV,SACAnV,GAAA4xB,cAAAtc,MAAAzpB,KAAAomC,UAAA1xB,GAAApS,EAAAtC,KAAAsmC,UAAA5xB,GAAApS,EAAAtC,KAAAumC,SACApyB,GAAA4xB,cAAAtc,MAAAzpB,KAAAomC,UAAA1xB,GAAAlS,EAAAxC,KAAAsmC,UAAA5xB,GAAAlS,EAAAxC,KAAAumC,YAEApyB,GAAAnS,MAAA,SAAA6G,GAEA,IAEA,SAAA7G,OAAA6G,GAEA,MAAAu/B,GAEAC,MAAAD,EAAAv/B,WAKAsL,GAAArH,MACAqH,GAAArH,GAAAw7B,cAAA,SAAA7I,EAAAtvB,GAGA,MADAA,OAAA,GACAgE,GAAAvI,QAAAoqB,KAAAyJ,IAAAtvB,MAEAgE,GAAArH,GAAAy7B,eAAA,SAAA9I,EAAAtvB,GAEAA,MAAA,EAEA,QADAq4B,GAAA,EACA3nC,EAAA,EAAmBA,EAAA4+B,EAAAr+B,OAAiBP,IAEpC2nC,GAAAr0B,GAAAvI,QAAAoqB,KAAAyJ,EAAA5+B,GAEA,OAAA2nC,IAAAr4B,MAEAgE,GAAArH,GAAA27B,aAAA,SAAA3+B,EAAAqG,GAEA,MAAAgE,IAAArH,GAAA47B,eAAA5+B,GAAAqG,IAEAgE,GAAArH,GAAA47B,cAAA,SAAA9+B,EAAAuG,GAEAA,MAAA,EACA,IAAAw4B,GAAAx0B,GAAAvI,QAAAs1B,UAAAt3B,EAKA,OAJA++B,GAAA3e,MAAA7Z,EACAw4B,EAAAxe,QAAAha,EACAw4B,EAAAze,OAAA/Z,EACAw4B,EAAA1e,KAAA9Z,EACAw4B,GAIAx0B,GAAArH,GAAA87B,MAAA,SAAAC,EAAAvE,GAEA,KAAAuE,YAAAxrB,QAAA,QACA,IAAAyrB,GAAAD,EAAA,YAAAxrB,OACAwrB,EAAA10B,GAAArH,GAAAi8B,MAAAF,EACA,oBAAAvE,IAAA,OAAAA,EAGA,MADAnwB,IAAAnS,MAAA,qCACA6mC,CAEA,QAAAA,EAAAznC,QAAA,GAAAynC,EAAAznC,QAAA,IAAAynC,EAAA,GAAAznC,QAAAkjC,EAAA,QAAAuE,EACAC,KAAAD,MAIA,QAFAvJ,GAAAG,EAAAr4B,EAAAwP,EAAAlW,EAAAgU,EAAA7T,EADAmoC,EAAAH,EAAAznC,OAEA6nC,KACAnzB,EAAA,EAAmBA,EAAAkzB,EAAclzB,IAIjC,GAFA2pB,EAAAoJ,EAAA/yB,GACAwpB,EAAAG,EAAAr+B,OACA,IAAAk+B,EACA,GAAAA,EAAA,EAEAl4B,EAAAq4B,EACAwJ,EAAA7mC,KAAAgF,OAHA,CAWA,IALAA,EAAAq4B,EACA7oB,EAAA0tB,IAEA5jC,EAAA++B,EAAA,GACA/qB,EAAA,EACA7T,EAAA,EAAiBA,EAAAy+B,EAASz+B,KAE1B4+B,EAAA5+B,GAAAyB,EAAA5B,EAAA4B,IAAAm9B,EAAA5+B,GAAAyB,EAAA5B,EAAA4B,IACAm9B,EAAA5+B,GAAA2B,EAAA9B,EAAA8B,IAAAi9B,EAAA5+B,GAAA2B,EAAA9B,EAAA8B,IAAAoU,IAEAxP,EAAAsN,GAAA+qB,EAAA5+B,GACAH,EAAA++B,EAAA5+B,GACA6T,IAEAhU,GAAA++B,EAAA/qB,EAAA,IACA+qB,EAAA,GAAAn9B,EAAA5B,EAAA4B,IAAAm9B,EAAA,GAAAn9B,EAAA5B,EAAA4B,IACAm9B,EAAA,GAAAj9B,EAAA9B,EAAA8B,IAAAi9B,EAAA,GAAAj9B,EAAA9B,EAAA8B,IAAAoU,GACAlC,IACAA,EAAA4qB,GACAl4B,EAAA4K,OAAA0C,EAAA4qB,EAAA5qB,GACAtN,EAAAhG,QAAA6nC,EAAA7mC,KAAAgF,GAOA,OALA0hC,GAAAG,EAAA7nC,OAAA6nC,IAAA,GACAH,GAAA,IAAAG,EAAA7nC,OACA0nC,GAAA,IAAAG,EAAA7nC,SAAA6nC,QADAA,KAIAA,GAKA90B,GAAArH,GAAAi8B,MAAA,SAAAF,GAEA,KAAAA,YAAAxrB,QAAA,QACA,QAAAwrB,EAAAznC,OAAA,QACA,OAAAynC,EAAAznC,QAAA,IAAAynC,EAAA,GAAAznC,OAAA,UACA,IAAA0nC,GAAAD,EAAA,YAAAxrB,MACAyrB,KAAAD,MACA,IACAK,GAAAroC,EAAA6T,EAAAtN,EADAk4B,EAAAuJ,EAAAznC,OAEA6nC,EAAA,GAAA5rB,OAAAiiB,EACA,KAAAz+B,EAAA,EAAeA,EAAAy+B,EAASz+B,IACxB,CAGA,IAFAqoC,EAAAL,EAAAhoC,GAAAO,OACAgG,EAAA,GAAAiW,OAAA6rB,GACAx0B,EAAA,EAAiBA,EAAAw0B,EAAUx0B,IAE3BtN,EAAAsN,IACApS,EAAAumC,EAAAhoC,GAAA6T,GAAApS,EACAE,EAAAqmC,EAAAhoC,GAAA6T,GAAAlS,EAGAymC,GAAApoC,GAAAuG,EAGA,MADA0hC,KAAAG,IAAA,IACAA,GAKA90B,GAAArH,GAAAq8B,QAAA,SAAAN,EAAA5Z,GAEA,KAAA4Z,YAAAxrB,QAAA,QACA,oBAAA4R,IAAA,OAAAA,EAGA,MADA9a,IAAAnS,MAAA,2CACAmS,GAAArH,GAAAi8B,MAAAF,EAEA,QAAAA,EAAAznC,QAAA,GAAAynC,EAAAznC,QAAA,IAAAynC,EAAA,GAAAznC,QAAA6tB,EAAA,EAEA,MAAA9a,IAAArH,GAAAi8B,MAAAF,EAEAA,GAAA,YAAAxrB,SAAAwrB,MACA,IAAAhoC,GAAA6T,EAAA+qB,EAAA3pB,EAAAovB,EAAAgE,EAAA3F,EAAAC,EAAA4F,EAAAxyB,EAAAyyB,EAAAC,EACAC,EAAAC,EAAAx0B,EAAAy0B,EAAAC,EACApK,EAAAuJ,EAAAznC,OACAuoC,EAAA1a,IACAga,IACA,KAAApoC,EAAA,EAAeA,EAAAy+B,EAASz+B,IAIxB,GAFA4+B,EAAAoJ,EAAAhoC,GACAqoC,EAAAzJ,EAAAr+B,OACA,GAAA8nC,EAAA,CACA,IAAApzB,EAAA,EAAiBA,EAAA,IAAaA,IAC9B,CAiBA,IAhBAovB,KACAgE,EAAAzJ,EAAAr+B,OAGAq+B,EAAAyJ,EAAA,GAAA5mC,GAAAm9B,EAAA,GAAAn9B,GAAAm9B,EAAAyJ,EAAA,GAAA1mC,GAAAi9B,EAAA,GAAAj9B,GAEA8mC,EAAA,EACA7J,EAAAr9B,MAEAE,EAAAm9B,EAAA,GAAAn9B,EACAE,EAAAi9B,EAAA,GAAAj9B,IAEA0mC,EAAAzJ,EAAAr+B,QAEAkoC,EAAA,EACAD,KACA30B,EAAA,EAAmBA,EAAAw0B,EAAA,EAAcx0B,IAEjC6uB,EAAA9D,EAAA/qB,GACA00B,EAAA3J,EAAA/qB,EAAA,GACA8uB,EAAA/D,EAAA/qB,EAAA,GACA+0B,EAAAlG,EAAAjhC,EACAonC,EAAAnG,EAAA/gC,EACA+mC,EAAA/F,EAAAlhC,EAAAmnC,EACAD,EAAAhG,EAAAhhC,EAAAknC,EACA,IAAAH,GAAA,IAAAC,IAEAx0B,IAAAo0B,EAAA9mC,EAAAmnC,GAAAF,GAAAH,EAAA5mC,EAAAknC,GAAAF,IAAAD,IAAAC,KACAx0B,EAAA,GAEAy0B,EAAAjG,EAAAlhC,EACAonC,EAAAlG,EAAAhhC,GAEAwS,EAAA,IAEAy0B,GAAAF,EAAAv0B,EACA00B,GAAAF,EAAAx0B,IAGAu0B,EAAAH,EAAA9mC,EAAAmnC,EACAD,EAAAJ,EAAA5mC,EAAAknC,EACA9yB,EAAA2yB,IAAAC,IACA5yB,GAAA+yB,IAEAN,EAAA30B,EAAA,KACAA,IASA,KALAwwB,EAAA9iC,MAEAE,EAAAm9B,EAAA,GAAAn9B,EACAE,EAAAi9B,EAAA,GAAAj9B,IAEAkS,EAAA,EAAmBA,EAAAw0B,EAAA,EAAcx0B,IACjC20B,EAAA30B,IAAAwwB,EAAA9iC,MAEAE,EAAAm9B,EAAA/qB,GAAApS,EACAE,EAAAi9B,EAAA/qB,GAAAlS,GAUA,IARA0iC,EAAA9iC,MAEAE,EAAAm9B,EAAAyJ,EAAA,GAAA5mC,EACAE,EAAAi9B,EAAAyJ,EAAA,GAAA1mC,IAGA8mC,GAAA7J,EAAAnvB,OAEA+4B,EAAAjoC,OAAA,KAEAq+B,GAAAyF,EAEAgE,EAAAhE,EAAA9jC,OAEA8jC,EAAAgE,EAAA,GAAA5mC,GAAA4iC,EAAA,GAAA5iC,GAAA4iC,EAAAgE,EAAA,GAAA1mC,GAAA0iC,EAAA,GAAA1iC,GAEA0iC,EAAA50B,MAEA40B,EAAA9jC,OAAA,GACA6nC,EAAA7mC,KAAA8iC,GAMA,MAJA2D,GAAA,YAAAxrB,SAAA4rB,IAAA,IACA,wBAAAA,QAGAA,GAEA90B,GAAArH,GAAA88B,gBAAA,SAAA9/B,EAAAgpB,EAAA3iB,GAEA,iCACA,IAEA2C,GAAAK,EAFAm0B,EAAA/9B,KAAA+9B,KACAuC,EAAA,EACAC,EAAA,EACAC,EAAA,EACAC,EAAA,EACAC,EAAA,EACAv1B,EAAA5K,EAAA1I,MACA,IAAAsT,EAAA,UAMA,KALAoe,IAEAhpB,EAAA4K,GAAA5K,EAAA,GACA4K,OAEAA,GAEA5B,EAAAhJ,EAAA4K,GACAo1B,EAAAh3B,EAAAxQ,EACAynC,EAAAj3B,EAAAtQ,EACA2Q,EAAArJ,EAAA4K,EAAA,GACAs1B,EAAA72B,EAAA7Q,EACA2nC,EAAA92B,EAAA3Q,EACAqnC,GAAAvC,GAAAwC,EAAAE,IAAAF,EAAAE,IAAAD,EAAAE,IAAAF,EAAAE,GAGA,OADAnX,IAAAhpB,EAAAwG,MACAu5B,EAAA15B,GAEAgE,GAAArH,GAAAo9B,iBAAA,SAAAtgC,EAAAkpB,EAAA3iB,GAEAA,MAAA,EAEA,QADA05B,GAAA,EACAhpC,EAAA,EAAmBA,EAAA+I,EAAAxI,OAAkBP,IAErCgpC,GAAA11B,GAAArH,GAAA88B,gBAAAhgC,EAAA/I,GAAAiyB,EAAA3iB,EAEA,OAAA05B,IAEA11B,GAAArH,GAAAq9B,cAAA,SAAArgC,EAAAqG,GAEA,GAAAtP,GAAAH,CAGA,KAFAyP,MAAA,GACAtP,EAAAiJ,EAAA1I,OACAP,KAEAH,EAAAoJ,EAAAjJ,GACAH,EAAA4B,EAAA5B,EAAA4B,EAAA6N,EACAzP,EAAA8B,EAAA9B,EAAA8B,EAAA2N,GAGAgE,GAAArH,GAAAs9B,eAAA,SAAAxgC,EAAAuG,GAEA,GAAAtP,GAAA6T,EAAAhU,CAGA,KAFAyP,MAAA,GACAtP,EAAA+I,EAAAxI,OACAP,KAGA,IADA6T,EAAA9K,EAAA/I,GAAAO,OACAsT,KAEAhU,EAAAkJ,EAAA/I,GAAA6T,GACAhU,EAAA4B,EAAA5B,EAAA4B,EAAA6N,EACAzP,EAAA8B,EAAA9B,EAAA8B,EAAA2N,GAIAgE,GAAArH,GAAAu9B,YAAA,SAAAvgC,EAAAqG,GAEA,GAAAtP,GAAAH,EAAAg+B,EAAAn1B,KAAAm1B,KAGA,KAFAvuB,MAAA,GACAtP,EAAAiJ,EAAA1I,OACAP,KAEAH,EAAAoJ,EAAAjJ,GACAH,EAAA4B,EAAAo8B,EAAAh+B,EAAA4B,EAAA6N,GACAzP,EAAA8B,EAAAk8B,EAAAh+B,EAAA8B,EAAA2N,IAGAgE,GAAArH,GAAAw9B,aAAA,SAAA1gC,EAAAuG,GAEA,GAAAtP,GAAA6T,EAAAhU,EAAAg+B,EAAAn1B,KAAAm1B,KAGA,KAFAvuB,MAAA,GACAtP,EAAA+I,EAAAxI,OACAP,KAGA,IADA6T,EAAA9K,EAAA/I,GAAAO,OACAsT,KAEAhU,EAAAkJ,EAAA/I,GAAA6T,GACAhU,EAAA4B,EAAAo8B,EAAAh+B,EAAA4B,EAAA6N,GACAzP,EAAA8B,EAAAk8B,EAAAh+B,EAAA8B,EAAA2N,IAIAgE,GAAAo2B,WAAA,WAEA,UAEAp2B,GAAAq2B,UAAA,WAEAxqC,KAAAkL,MAAA,KACAlL,KAAAmL,MAAA,MAEAgJ,GAAArH,GAAA29B,6BAAA,SAAAnF,EAAAoF,GAEA,GAAAC,GAAA,GAAAx2B,IAAAq2B,SACAG,GAAAz/B,MAAAo6B,EAAAvd,SACA,IAAA6iB,GAAAtF,EAAAjd,SACAI,EAAAmiB,EAAAxpC,MACAupC,GAAAx/B,MAAA,GAAAkS,OAAAoL,EACA,IAAAZ,GAAAjnB,EAAAC,EAAA6T,EAAAm2B,EAAAna,CACA,KAAA7vB,EAAA,EAAeA,EAAA4nB,EAAU5nB,IAKzB,IAHAgnB,EAAA+iB,EAAA/pC,GACA8pC,EAAAx/B,MAAAtK,GAAAgnB,EAAAE,UAEArT,EAAA,EAAAm2B,EAAAhjB,EAAAQ,SAAAqI,EAAAma,EAAAzpC,OAAiEsT,EAAAgc,EAAUhc,IAE3E9T,EAAAiqC,EAAAn2B,GACAP,GAAArH,GAAA29B,6BAAA7pC,EAAA8pC,EAGAA,GAAAtoC,KAAAuoC,IAEAx2B,GAAArH,GAAAg+B,kBAAA,SAAAJ,GAEA,GAAAz2B,GAAApT,EAAA0oB,EAAAd,EACA7e,EAAA,GAAAuK,IAAA2S,KACA,KAAA7S,EAAA,EAAAsV,EAAAmhB,EAAAtpC,OAAyC6S,EAAAsV,EAAUtV,IAGnD,IADArK,EAAAxH,KAAAsoC,EAAAz2B,GAAA/I,OACArK,EAAA,EAAA4nB,EAAAiiB,EAAAz2B,GAAA9I,MAAA/J,OAAoDP,EAAA4nB,EAAU5nB,IAE9D+I,EAAAxH,KAAAsoC,EAAAz2B,GAAA9I,MAAAtK,GAGA,OAAA+I,IAEAuK,GAAArH,GAAAC,qBAAA,SAAAqoB,GAEA,GACAvN,GAAAhnB,EAAA+pC,EAAAniB,EADAiiB,EAAA,GAAAv2B,IAAAo2B,UAEA,KAAA1pC,EAAA,EAAA+pC,EAAAxV,EAAA/M,SAAAI,EAAAmiB,EAAAxpC,OAAiEP,EAAA4nB,EAAU5nB,IAE3EgnB,EAAA+iB,EAAA/pC,GACAsT,GAAArH,GAAA29B,6BAAA5iB,EAAA6iB,EAEA,OAAAA,QNw0DM,SAAS7qC,EAAQD,EAASM,IO3kRhC,SAAAS,EAAAG,GAAejB,EAAAD,QAAAkB,KAAmMd,KAAA,WAAiB,gBAAAW,GAAmB,QAAAG,GAAAF,GAAc,GAAAC,EAAAD,GAAA,MAAAC,GAAAD,GAAAhB,OAA4B,IAAAqC,GAAApB,EAAAD,IAAYhB,WAAUS,GAAAO,EAAAN,QAAA,EAAiB,OAAAK,GAAAC,GAAAL,KAAA0B,EAAArC,QAAAqC,IAAArC,QAAAkB,GAAAmB,EAAA3B,QAAA,EAAA2B,EAAArC,QAAgE,GAAAiB,KAAS,OAAAC,GAAAN,EAAAG,EAAAG,EAAAL,EAAAI,EAAAC,EAAAJ,EAAA,GAAAI,EAAA,KAA+B,SAAAH,EAAAG,EAAAD,GAAkBF,EAAAf,QAAAiB,EAAA,IAAe,SAAAF,EAAAG,EAAAD,GAAiB,YAAa,SAAAD,GAAAD,EAAAG,GAAgB,IAAAH,EAAA,SAAAoqC,gBAAA,4DAA4F,QAAAjqC,GAAA,gBAAAA,IAAA,kBAAAA,GAAAH,EAAAG,EAAuD,QAAAmB,GAAAtB,EAAAG,GAAgB,qBAAAA,IAAA,OAAAA,EAAA,SAAAE,WAAA,iEAAAF,GAA2HH,GAAAc,UAAAR,OAAA+pC,OAAAlqC,KAAAW,WAA0CwpC,aAAa9pC,MAAAR,EAAAU,YAAA,EAAAE,UAAA,EAAAD,cAAA,KAAmDR,IAAAG,OAAAiqC,eAAAjqC,OAAAiqC,eAAAvqC,EAAAG,GAAAH,EAAAwqC,UAAArqC,GAAsE,QAAAwU,GAAA3U,EAAAG,GAAgB,KAAAH,YAAAG,IAAA,SAAAE,WAAA,qCAA8E,QAAAD,GAAAJ,EAAAG,GAAgB,OAAAH,EAAAG,OAAgB,QAAA0Q,GAAA7Q,EAAAG,EAAAD,GAAkB,MAAA0I,MAAAwF,IAAAxF,KAAAyF,IAAArO,EAAAG,GAAAD,GAAiC,QAAAoT,GAAAtT,EAAAG,GAAgB,MAAAyI,MAAA+9B,KAAA/9B,KAAAkT,IAAA3b,EAAAY,EAAAf,EAAAe,EAAA,GAAA6H,KAAAkT,IAAA3b,EAAAc,EAAAjB,EAAAiB,EAAA,IAA0D,QAAA6f,GAAA9gB,EAAAG,GAAgB,GAAAD,GAAAF,EAAAe,EAAAZ,EAAAY,EAAAf,EAAAiB,EAAAd,EAAAc,EAAAhB,EAAA2I,KAAA+9B,MAAA/9B,KAAAkT,IAAA9b,EAAAe,EAAA,GAAA6H,KAAAkT,IAAA9b,EAAAiB,EAAA,KAAA2H,KAAAkT,IAAA3b,EAAAY,EAAA,GAAA6H,KAAAkT,IAAA3b,EAAAc,EAAA,IAAuG,QAAAjB,EAAAe,EAAAZ,EAAAc,EAAAjB,EAAAiB,EAAAd,EAAAY,EAAA,QAAA6H,KAAAk+B,KAAA5mC,EAAAD,GAA8CK,OAAAC,eAAAJ,EAAA,cAAsCK,OAAA,IAASL,EAAA4S,cAAA5S,EAAAyS,YAAAzS,EAAA+S,IAAA,MAA6C,IAAAnT,GAAA,QAAAC,GAAAG,EAAAD,EAAAD,GAAwB,OAAAE,MAAAsqC,SAAA3pC,UAAiC,IAAAQ,GAAAhB,OAAA4lB,yBAAA/lB,EAAAD,EAA2C,aAAAoB,EAAA,CAAe,GAAAqT,GAAArU,OAAAoqC,eAAAvqC,EAA+B,eAAAwU,EAAA,OAAA3U,EAAA2U,EAAAzU,EAAAD,GAAgC,YAAAqB,GAAA,MAAAA,GAAAd,KAA8B,IAAAJ,GAAAkB,EAAAqpC,GAAY,iBAAAvqC,IAAAR,KAAAK,GAAA,QAA+BH,EAAA,WAAc,QAAAE,KAAAG,GAAgB,OAAAD,GAAA,EAAYA,EAAAC,EAAAM,OAAWP,IAAA,CAAK,GAAAD,GAAAE,EAAAD,EAAWD,GAAAS,WAAAT,EAAAS,aAAA,EAAAT,EAAAU,cAAA,WAAAV,OAAAW,UAAA,GAAAN,OAAAC,eAAAP,EAAAC,EAAAY,IAAAZ,IAA+G,gBAAAE,EAAAD,EAAAD,GAAuB,MAAAC,IAAAF,EAAAG,EAAAW,UAAAZ,GAAAD,GAAAD,EAAAG,EAAAF,GAAAE,MAAwC+c,EAAAhd,EAAA,GAAAmU,EAAA,EAAAzL,KAAAC,GAAA5H,EAAA2H,KAAAC,GAAA,IAAAmL,EAAA,WAAiD,QAAAhU,GAAAG,GAAcwU,EAAAtV,KAAAW,GAAAX,KAAA8J,QAAA9J,KAAAuE,QAAA,EAAAvE,KAAAwE,KAAA,IAAAxE,KAAAyE,WAAA,IAAAzE,KAAA0E,cAAA,GAAAzD,OAAAqD,OAAAtE,KAAAc,OAAsHd,KAAAurC,UAAA,KAAAvrC,KAAAwrC,aAAA,KAA6C,MAAA/qC,GAAAE,IAAaa,IAAA,aAAAL,MAAA,WAAkCnB,KAAA8J,WAAgBtI,IAAA,UAAAL,MAAA,WAA+B,MAAAnB,MAAA8J,QAAoBtI,IAAA,cAAAL,MAAA,SAAAR,GAAoC,UAAAkd,GAAA9a,MAAA,QAA2BvB,IAAA,YAAAL,MAAA,SAAAR,GAAkCX,KAAA8J,KAAA1H,KAAAzB,EAAAe,EAAAf,EAAAiB,MAA2BJ,IAAA,aAAAL,MAAA,eAAsCK,IAAA,qBAAAL,MAAA,WAA0C,GAAAR,GAAA,EAAAG,KAAAD,EAAAb,KAAAyrC,YAAA,GAAA7qC,EAAA,OAAAqB,EAAA,OAAAqT,EAAA,MAA8D,KAAA1U,EAAA,EAAQA,EAAAZ,KAAAyE,WAAkB7D,IAAAqB,EAAAuP,EAAA5Q,GAAA,EAAAZ,KAAAyE,YAAA,KAAA6Q,EAAAtV,KAAAyrC,YAAAxpC,GAAAtB,GAAAsT,EAAApT,EAAAyU,GAAAxU,EAAAsB,MAA2EzB,EAAAsB,EAAAspC,UAAA5qC,IAAgBE,EAAAyU,CAAMA,GAAAtV,KAAAyrC,YAAA,GAAA9qC,GAAAsT,EAAApT,EAAAyU,GAAAxU,EAAAsB,MAAwCzB,EAAA,EAAA4qC,UAAA5qC,IAAgBM,OAAAqD,OAAAtE,MAAsBurC,UAAA5qC,EAAA6qC,aAAA1qC,OAAgCU,IAAA,cAAAL,MAAA,SAAAR,GAAoCA,EAAA6Q,EAAA7Q,EAAA,IAAW,IAAAG,GAAAH,EAAAX,KAAAurC,UAAA1qC,EAAA,EAAAD,EAAA,EAAAqB,EAAA,CAAmC,OAAAjC,MAAAwrC,aAAA54B,MAAA,SAAAjS,GAA2C,GAAA2U,GAAA3U,IAAAI,EAAAJ,EAAA4qC,SAAwB,IAAAxqC,GAAAD,EAAA,CAAS,GAAA0Q,GAAAzQ,EAAAD,EAAAmT,EAAAnT,EAAAF,EAAA6gB,EAAAxN,GAAAzC,EAAAyC,IAAA,CAA6B,OAAApT,GAAAoB,GAAAqT,EAAArT,GAAAwf,GAAA,EAAsB,MAAA7gB,GAAAG,EAAAkB,EAAAqT,GAAA,IAAkBtV,KAAAyrC,YAAA5qC,MAAyBW,IAAA,QAAAL,MAAA,SAAAR,GAA8BM,OAAAqD,OAAAtE,KAAAW,MAA0B,IAAAG,GAAA,cAAAD,EAAAb,KAAAwE,IAAgC,IAAAxE,KAAAuE,OAAA,CAAgBvE,KAAA0rC,oBAA0B,IAAA9qC,GAAA2I,KAAAm1B,MAAA1+B,KAAAurC,UAAAvrC,KAAA0E,cAAoD5D,GAAA,cAAAD,EAAA,EAAAD,EAAsBZ,KAAAsS,YAAkB,QAAArQ,GAAA,EAAYA,GAAA,EAAKA,GAAApB,EAAAb,KAAA2rC,UAAA3rC,KAAAc,GAAAmB,GAAgC,OAAAjC,MAAA4rC,aAAA5rC,KAAA6rC,cAAyClrC,KAAKe,EAAA,SAAAf,GAAiB,QAAAG,KAAa,MAAAwU,GAAAtV,KAAAc,GAAAF,EAAAZ,MAAAc,EAAAqqC,WAAAlqC,OAAAoqC,eAAAvqC,IAAA6P,MAAA3Q,KAAAqC,YAAuF,MAAAJ,GAAAnB,EAAAH,GAAAF,EAAAK,IAAoBU,IAAA,OAAAL,MAAA,SAAAR,GAA6B,GAAAM,OAAAqD,OAAAtE,KAAAW,OAA2BX,KAAA8rC,QAAA/qC,EAAAf,KAAA4K,MAAA,KAAAhJ,EAAA5B,KAAA8S,GAAApR,IAAA1B,KAAAmT,GAAAzR,GAAA1B,KAAA8S,GAAAlR,IAAA5B,KAAAmT,GAAAvR,EAAA,MAAA5B,MAAA8J,IAAiG,IAAA9J,KAAAyR,GAAAlI,KAAAsO,IAAA7X,KAAAyR,IAAAzR,KAAA0R,GAAAnI,KAAAsO,IAAA7X,KAAA0R,IAAA,IAAA1R,KAAAyR,IAAA,IAAAzR,KAAA0R,GAAA,MAAA1R,MAAA+rC,WAAA/rC,KAAA8S,IAAA9S,KAAA+rC,WAAA/rC,KAAAmT,IAAAnT,KAAA8J,IAAmJ,IAAAhJ,IAAAd,KAAA8S,GAAApR,EAAA1B,KAAAmT,GAAAzR,GAAA,EAAAb,GAAAb,KAAA8S,GAAAlR,EAAA5B,KAAAmT,GAAAvR,GAAA,EAAAhB,GAA2Dc,EAAA6H,KAAAsB,IAAA7K,KAAA8rC,SAAAhrC,EAAAyI,KAAAuB,IAAA9K,KAAA8rC,SAAAjrC,EAAAe,GAAA2H,KAAAuB,IAAA9K,KAAA8rC,SAAAhrC,EAAAyI,KAAAsB,IAAA7K,KAAA8rC,SAAAjrC,GAAyGoB,EAAAsH,KAAAkT,IAAA7b,EAAAc,EAAA,GAAA6H,KAAAkT,IAAAzc,KAAAyR,GAAA,GAAAlI,KAAAkT,IAAA7b,EAAAgB,EAAA,GAAA2H,KAAAkT,IAAAzc,KAAA0R,GAAA,EAA2EzP,GAAA,IAAAjC,KAAAyR,GAAAlI,KAAA+9B,KAAArlC,GAAAjC,KAAAyR,GAAAzR,KAAA0R,GAAAnI,KAAA+9B,KAAArlC,GAAAjC,KAAA0R,GAAiE,IAAA4D,GAAA/L,KAAAkT,IAAAzc,KAAAyR,GAAA,GAAAlI,KAAAkT,IAAAzc,KAAA0R,GAAA,GAAAnI,KAAAkT,IAAAzc,KAAAyR,GAAA,GAAAlI,KAAAkT,IAAA7b,EAAAgB,EAAA,GAAA2H,KAAAkT,IAAAzc,KAAA0R,GAAA,GAAAnI,KAAAkT,IAAA7b,EAAAc,EAAA,GAAA8P,EAAAjI,KAAAkT,IAAAzc,KAAAyR,GAAA,GAAAlI,KAAAkT,IAAA7b,EAAAgB,EAAA,GAAA2H,KAAAkT,IAAAzc,KAAA0R,GAAA,GAAAnI,KAAAkT,IAAA7b,EAAAc,EAAA,GAAAuS,EAAAqB,EAAA9D,CAAsMyC,KAAA,IAAAA,CAAU,IAAAvT,IAAAV,KAAA2T,QAAA3T,KAAA4T,MAAA,MAAArK,KAAA+9B,KAAArzB,GAAAxT,GAAqDiB,EAAAhB,GAAAV,KAAAyR,GAAA7Q,EAAAgB,EAAA5B,KAAA0R,IAAA9P,EAAAlB,KAAAV,KAAA0R,GAAA9Q,EAAAc,GAAA1B,KAAAyR,IAAwDzR,MAAAgsC,QAAatqC,EAAA6H,KAAAsB,IAAA7K,KAAA8rC,SAAArrC,EAAAiB,EAAA6H,KAAAuB,IAAA9K,KAAA8rC,SAAArrC,EAAAmB,GAAA5B,KAAA8S,GAAApR,EAAA1B,KAAAmT,GAAAzR,GAAA,EAAAE,EAAA2H,KAAAuB,IAAA9K,KAAA8rC,SAAArrC,EAAAiB,EAAA6H,KAAAsB,IAAA7K,KAAA8rC,SAAArrC,EAAAmB,GAAA5B,KAAA8S,GAAAlR,EAAA5B,KAAAmT,GAAAvR,GAAA,EAAiK,IAAAic,IAAOnc,GAAAd,EAAAc,EAAAjB,EAAAiB,GAAA1B,KAAAyR,GAAA7P,GAAAhB,EAAAgB,EAAAnB,EAAAmB,GAAA5B,KAAA0R,IAAwCiD,GAAIjT,IAAAd,EAAAc,EAAAjB,EAAAiB,GAAA1B,KAAAyR,GAAA7P,IAAAhB,EAAAgB,EAAAnB,EAAAmB,GAAA5B,KAAA0R,GAA2C1R,MAAAisC,WAAAxqB,GAAmB/f,EAAA,EAAAE,EAAA,GAAQic,GAAA7d,KAAAksC,WAAAzqB,EAAA5D,EAAAlJ,IAAA3U,KAAA4T,OAAA5T,KAAAksC,WAAA,EAAAlsC,KAAAksC,YAAAl3B,EAAAhV,KAAA4T,OAAA5T,KAAAksC,WAAA,IAAAlsC,KAAAksC,YAAAl3B,GAAAhV,KAAAksC,YAAAl3B,KAAuJxT,IAAA,QAAAL,MAAA,SAAAR,GAA8B,MAAAX,MAAAmsC,KAAAxrC,GAAAD,EAAAI,EAAAW,UAAA0pC,WAAAlqC,OAAAoqC,eAAAvqC,EAAAW,WAAA,QAAAzB,MAAAO,KAAAP,SAA4GwB,IAAA,cAAAL,MAAA,SAAAR,GAAoC,GAAAG,GAAAd,KAAAisC,WAAAjsC,KAAAksC,WAAAvrC,EAAAE,EAAAb,KAAAyR,GAAAlI,KAAAsB,IAAA/J,GAAAF,EAAAZ,KAAA0R,GAAAnI,KAAAuB,IAAAhK,EAAoF,WAAA+c,GAAA9a,MAAAwG,KAAAsB,IAAA7K,KAAA8rC,SAAAjrC,EAAA0I,KAAAuB,IAAA9K,KAAA8rC,SAAAlrC,EAAAZ,KAAAgsC,OAAAtqC,EAAA6H,KAAAuB,IAAA9K,KAAA8rC,SAAAjrC,EAAA0I,KAAAsB,IAAA7K,KAAA8rC,SAAAlrC,EAAAZ,KAAAgsC,OAAApqC,MAAuJJ,IAAA,aAAAL,MAAA,WAAkCnB,KAAA2rC,UAAA3rC,KAAAmT,QAAyBrS,GAAK6T,GAAAiC,EAAA,SAAAjW,GAAkB,QAAAG,KAAa,MAAAwU,GAAAtV,KAAAc,GAAAF,EAAAZ,MAAAc,EAAAqqC,WAAAlqC,OAAAoqC,eAAAvqC,IAAA6P,MAAA3Q,KAAAqC,YAAuF,MAAAJ,GAAAnB,EAAAH,GAAAF,EAAAK,IAAoBU,IAAA,MAAAL,MAAA,SAAAR,GAA4B,MAAAA,UAAgBa,IAAA,MAAAL,MAAA,SAAAR,GAA4B,SAAAA,KAAA,EAAAA,MAAsBa,IAAA,MAAAL,MAAA,SAAAR,GAA4B,SAAAA,GAAA,EAAAA,IAAA,EAAAA,MAA0Ba,IAAA,MAAAL,MAAA,SAAAR,GAA4B,SAAAA,IAAA,EAAAA,IAAA,EAAAA,MAA2Ba,IAAA,MAAAL,MAAA,SAAAR,EAAAG,EAAAD,EAAAD,EAAAqB,GAAoC,MAAAtB,GAAAX,KAAAosC,IAAAnqC,GAAAnB,EAAAd,KAAAqsC,IAAApqC,GAAApB,EAAAb,KAAAssC,IAAArqC,GAAArB,EAAAZ,KAAAusC,IAAAtqC,MAAkET,IAAA,cAAAL,MAAA,SAAAR,GAAoC,UAAAkd,GAAA9a,MAAA/C,KAAAwsC,IAAAxsC,KAAA8S,GAAApR,EAAA1B,KAAAmT,GAAAzR,EAAA1B,KAAAoT,GAAA1R,EAAA1B,KAAAqT,GAAA3R,EAAAf,GAAAX,KAAAwsC,IAAAxsC,KAAA8S,GAAAlR,EAAA5B,KAAAmT,GAAAvR,EAAA5B,KAAAoT,GAAAxR,EAAA5B,KAAAqT,GAAAzR,EAAAjB,OAA+Ha,IAAA,YAAAL,MAAA,SAAAR,GAAkCX,KAAA8J,KAAA2iC,QAAA9rC,EAAAe,EAAAf,EAAAiB,OAA4Bd,GAAK6T,GAAA0G,EAAA,SAAA1a,GAAkB,QAAAG,KAAa,MAAAwU,GAAAtV,KAAAc,GAAAF,EAAAZ,MAAAc,EAAAqqC,WAAAlqC,OAAAoqC,eAAAvqC,IAAA6P,MAAA3Q,KAAAqC,YAAuF,MAAAJ,GAAAnB,EAAAH,GAAAF,EAAAK,IAAoBU,IAAA,MAAAL,MAAA,SAAAR,GAA4B,MAAAA,QAAca,IAAA,MAAAL,MAAA,SAAAR,GAA4B,SAAAA,GAAA,EAAAA,MAAoBa,IAAA,MAAAL,MAAA,SAAAR,GAA4B,SAAAA,IAAA,EAAAA,MAAqBa,IAAA,MAAAL,MAAA,SAAAR,EAAAG,EAAAD,EAAAD,GAAkC,MAAAD,GAAAX,KAAAosC,IAAAxrC,GAAAE,EAAAd,KAAAqsC,IAAAzrC,GAAAC,EAAAb,KAAAssC,IAAA1rC,MAAoDY,IAAA,cAAAL,MAAA,SAAAR,GAAoC,UAAAkd,GAAA9a,MAAA/C,KAAAwsC,IAAAxsC,KAAA8S,GAAApR,EAAA1B,KAAAmT,GAAAzR,EAAA1B,KAAAoT,GAAA1R,EAAAf,GAAAX,KAAAwsC,IAAAxsC,KAAA8S,GAAAlR,EAAA5B,KAAAmT,GAAAvR,EAAA5B,KAAAoT,GAAAxR,EAAAjB,OAA2Ga,IAAA,YAAAL,MAAA,SAAAR,GAAkCX,KAAA8J,KAAA2iC,QAAA9rC,EAAAe,EAAAf,EAAAiB,OAA4Bd,GAAK6T,EAAI7T,GAAA+S,IAAAnS,EAAAZ,EAAAyS,YAAAqD,EAAA9V,EAAA4S,cAAA2H,GAA0C,SAAA1a,EAAAG,EAAAD,IAAiB,SAAAC,EAAAD,GAAeF,EAAAf,QAAAiB,KAAcb,KAAA,WAAiB,gBAAAW,GAAmB,QAAAG,GAAAF,GAAc,GAAAC,EAAAD,GAAA,MAAAC,GAAAD,GAAAhB,OAA4B,IAAAqC,GAAApB,EAAAD,IAAYhB,WAAUS,GAAAO,EAAAN,QAAA,EAAiB,OAAAK,GAAAC,GAAAL,KAAA0B,EAAArC,QAAAqC,IAAArC,QAAAkB,GAAAmB,EAAA3B,QAAA,EAAA2B,EAAArC,QAAgE,GAAAiB,KAAS,OAAAC,GAAAN,EAAAG,EAAAG,EAAAL,EAAAI,EAAAC,EAAAJ,EAAA,GAAAI,EAAA,KAA+B,SAAAH,EAAAG,EAAAD,GAAkBF,EAAAf,QAAAiB,EAAA,IAAe,SAAAF,EAAAG,GAAe,YAAa,SAAAD,GAAAF,EAAAG,GAAgB,KAAAH,YAAAG,IAAA,SAAAE,WAAA,qCAA8EC,OAAAC,eAAAJ,EAAA,cAAsCK,OAAA,GAAW,IAAAP,GAAA,WAAiB,QAAAD,KAAAG,GAAgB,OAAAD,GAAA,EAAYA,EAAAC,EAAAM,OAAWP,IAAA,CAAK,GAAAD,GAAAE,EAAAD,EAAWD,GAAAS,WAAAT,EAAAS,aAAA,EAAAT,EAAAU,cAAA,WAAAV,OAAAW,UAAA,GAAAN,OAAAC,eAAAP,EAAAC,EAAAY,IAAAZ,IAA+G,gBAAAE,EAAAD,EAAAD,GAAuB,MAAAC,IAAAF,EAAAG,EAAAW,UAAAZ,GAAAD,GAAAD,EAAAG,EAAAF,GAAAE,MAAwCmB,EAAA,WAAgB,QAAAtB,GAAAG,EAAAF,GAAgB,GAAAC,EAAAb,KAAAW,GAAAX,KAAA0B,EAAAC,WAAAb,GAAAd,KAAA4B,EAAAD,WAAAf,GAAAiB,MAAA7B,KAAA0B,IAAAG,MAAA7B,KAAA4B,GAAA,KAAAE,SAAAC,MAAA,aAAAjB,EAAAF,EAAA,QAAAoB,OAAA,gDAAwL,MAAApB,GAAAD,IAAaa,IAAA,UAAAL,MAAA,SAAAR,GAAgC,MAAAX,MAAA0B,IAAAf,EAAAe,GAAA1B,KAAA4B,IAAAjB,EAAAiB,MAAmCjB,KAAK2U,EAAA,WAAgB,QAAA3U,KAAaE,EAAAb,KAAAW,GAAAX,KAAAkC,UAAAlC,KAAAoB,OAAA,EAAuC,MAAAR,GAAAD,IAAaa,IAAA,YAAAL,MAAA,WAAiC,MAAAnB,MAAAkC,UAAsBV,IAAA,mBAAAL,MAAA,WAAwC,GAAAR,KAAS,OAAAX,MAAAkC,OAAAC,QAAA,SAAArB,GAAuC,MAAAH,GAAAyB,KAAAtB,EAAAY,EAAAZ,EAAAc,KAAuBjB,KAAOa,IAAA,mBAAAL,MAAA,WAAwC,GAAAR,GAAA0B,UAAAjB,OAAA,YAAAiB,UAAA,GAAAA,UAAA,KAAAvB;AAAoE,MAAAd,MAAAkC,OAAAC,QAAA,SAAAtB,GAAuC,MAAAC,GAAAsB,MAAeE,EAAAC,SAAA1B,EAAAa,EAAAf,GAAA6B,EAAAD,SAAA1B,EAAAe,EAAAjB,OAAsCG,KAAOU,IAAA,oBAAAL,MAAA,SAAAR,GAA0C,GAAAG,GAAAd,KAAAa,EAAAwB,UAAAjB,OAAA,YAAAiB,UAAA,GAAAA,UAAA,IAAsE,OAAArC,MAAAkC,UAAAvB,EAAAwB,QAAA,SAAAxB,GAA4C,MAAAG,GAAA2B,SAAAd,WAAAhB,EAAA2B,EAAAzB,GAAAc,WAAAhB,EAAA6B,EAAA3B,MAAuDb,QAAUwB,IAAA,WAAAL,MAAA,SAAAR,GAAiC,MAAAX,MAAAkC,OAAAvB,EAAA,EAAAX,KAAAoB,OAAAT,MAAA,QAAiDa,IAAA,WAAAL,MAAA,SAAAR,EAAAG,GAAmCd,KAAAkC,OAAAE,KAAA,GAAAH,GAAAtB,EAAAG,IAAAd,KAAAoB,OAAApB,KAAAkC,OAAAd,UAA+DI,IAAA,YAAAL,MAAA,SAAAR,GAAkC,OAAAG,GAAA,EAAAD,EAAAF,EAAAS,OAAuBN,EAAAD,EAAIC,GAAA,EAAAd,KAAAyC,SAAA9B,EAAAG,GAAAH,EAAAG,EAAA,OAAmCU,IAAA,WAAAL,MAAA,WAAgC,GAAAR,GAAAX,KAAA0C,SAAA,EAAuB,OAAA/B,MAAAgC,QAAA3C,KAAA0C,UAAA,OAA0ClB,IAAA,QAAAL,MAAA,WAA6B,IAAAnB,KAAA4C,YAAA5C,KAAAoB,OAAA,GAAoC,GAAAT,GAAAX,KAAA0C,SAAA,EAAuB,OAAA1C,MAAAyC,SAAA9B,EAAAe,EAAAf,EAAAiB,IAAA,EAAiC,YAAYJ,IAAA,YAAAL,MAAA,SAAAR,GAAkCX,KAAAkC,OAAAlC,KAAAkC,OAAAW,IAAA,SAAA/B,GAAwC,UAAAmB,GAAAtB,EAAA,GAAAG,EAAAY,EAAAf,EAAA,GAAAG,EAAAc,EAAAjB,EAAA,GAAAA,EAAA,GAAAG,EAAAY,EAAAf,EAAA,GAAAG,EAAAc,EAAAjB,EAAA,UAA+DA,IAAQG,GAAAgC,KAAAwS,EAAAxU,EAAAiC,MAAAd,EAAAnB,EAAAkC,QAAAsS","file":"lw.svg-parser.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"SVGParser\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"SVGParser\"] = factory();\n\telse\n\t\troot[\"SVGParser\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"SVGParser\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"SVGParser\"] = factory();\n\telse\n\t\troot[\"SVGParser\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(2);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t!function(t,n){ true?module.exports=n():\"function\"==typeof define&&define.amd?define(\"SVGPath\",[],n):\"object\"==typeof exports?exports.SVGPath=n():t.SVGPath=n()}(this,function(){return function(t){function n(i){if(e[i])return e[i].exports;var o=e[i]={exports:{},id:i,loaded:!1};return t[i].call(o.exports,o,o.exports,n),o.loaded=!0,o.exports}var e={};return n.m=t,n.c=e,n.p=\"\",n(0)}([function(t,n,e){t.exports=e(1)},function(t,n){\"use strict\";function e(t,n){if(!(t instanceof n))throw new TypeError(\"Cannot call a class as a function\")}Object.defineProperty(n,\"__esModule\",{value:!0});var i=function(){function t(t,n){for(var e=0;e<n.length;e++){var i=n[e];i.enumerable=i.enumerable||!1,i.configurable=!0,\"value\"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i)}}return function(n,e,i){return e&&t(n.prototype,e),i&&t(n,i),n}}(),o=function(){function t(n,i){if(e(this,t),this.x=parseFloat(n),this.y=parseFloat(i),isNaN(this.x)||isNaN(this.y))throw console.error(\"new Point(\",n,i,\")\"),new Error(\"Invalid input: x and y params must be float.\")}return i(t,[{key:\"isEqual\",value:function(t){return this.x===t.x&&this.y===t.y}}]),t}(),r=function(){function t(){e(this,t),this.points=[],this.length=0}return i(t,[{key:\"getPoints\",value:function(){return this.points}},{key:\"getFlattenPoints\",value:function(){var t=[];return this.points.forEach(function(n){return t.push(n.x,n.y)}),t}},{key:\"getClipperPoints\",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,n=[];return this.points.forEach(function(e){return n.push({X:parseInt(e.x*t),Y:parseInt(e.y*t)})}),n}},{key:\"fromClipperPoints\",value:function(t){var n=this,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return this.points=[],t.forEach(function(t){return n.addPoint(parseFloat(t.X*e),parseFloat(t.Y*e))}),this}},{key:\"getPoint\",value:function(t){return this.points[t<0?this.length+t:t]||null}},{key:\"addPoint\",value:function(t,n){this.points.push(new o(t,n)),this.length=this.points.length}},{key:\"addPoints\",value:function(t){for(var n=0,e=t.length;n<e;n+=2)this.addPoint(t[n],t[n+1])}},{key:\"isClosed\",value:function(){var t=this.getPoint(0);return t&&t.isEqual(this.getPoint(-1))}},{key:\"close\",value:function(){if(!this.isClosed()&&this.length>2){var t=this.getPoint(0);return this.addPoint(t.x,t.y),!0}return!1}},{key:\"transform\",value:function(t){this.points=this.points.map(function(n){return new o(t[0]*n.x+t[2]*n.y+t[4],t[1]*n.x+t[3]*n.y+t[5])})}}]),t}();n.Path=r,n.Point=o,n.default=r}])});\n\t//# sourceMappingURL=lw.svg-path.js.map\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.Parser = undefined;\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Imports\n\t\n\t\n\tvar _tag = __webpack_require__(3);\n\t\n\tvar _tagparser = __webpack_require__(4);\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t// SVG parser class\n\tvar Parser = function () {\n\t    // Class constructor...\n\t    function Parser(settings) {\n\t        _classCallCheck(this, Parser);\n\t\n\t        // Defaults settings\n\t        settings = settings || {};\n\t\n\t        // Init properties\n\t        this.element = null; // XML document Element object\n\t        this.editor = null; // Editor info { name, version, fingerprint }\n\t        this.document = null; // Document info { width, height, viewBox }\n\t        this.defs = null; // Defined <defs> (DOM) nodes list by id\n\t        this.tags = null; // Tag objects hierarchy\n\t\n\t        // Trace settings (Arc, Bezier)\n\t        this.traceSettings = Object.assign({\n\t            linear: true, // Linear trace mode\n\t            step: 0.01, // Step resolution if linear mode = false\n\t            resolution: 100, // Number of segments we use to approximate arc length\n\t            segmentLength: 1 }, settings.traceSettings || {});\n\t\n\t        // Supported tags by this lib\n\t        this.supportedTags = ['svg', 'g', 'defs', 'use', 'line', 'polyline', 'polygon', 'rect', 'circle', 'ellipse', 'path', 'title', 'desc', 'image', 'text'];\n\t\n\t        // Tags list to includes/excludes\n\t        this.parseTags = settings.includes || this.supportedTags;\n\t        this.skipTags = settings.excludes || ['#text', '#comment']; // silent (no warning)\n\t\n\t        // User onTag callback ?\n\t        settings.onTag && this.onTag(settings.onTag, settings.onTagContext);\n\t    }\n\t\n\t    // Load raw XML string, XMLDocument, Element or File object\n\t\n\t\n\t    _createClass(Parser, [{\n\t        key: 'load',\n\t        value: function load(input) {\n\t            // Load raw XML string\n\t            if (typeof input === 'string') {\n\t                return this.loadFromString(input);\n\t            }\n\t\n\t            // Load File object\n\t            if (input instanceof File) {\n\t                return this.loadFromFile(input);\n\t            }\n\t\n\t            // Load XMLDocument object\n\t            if (input instanceof XMLDocument) {\n\t                return this.loadFromXMLDocument(input);\n\t            }\n\t\n\t            // Load Element object\n\t            if (input instanceof Element) {\n\t                return this.loadFromElement(input);\n\t            }\n\t\n\t            // Return rejected promise with an Error object\n\t            return Promise.reject(new Error('Unsupported input format.'));\n\t        }\n\t\n\t        // Load from Element object\n\t\n\t    }, {\n\t        key: 'loadFromElement',\n\t        value: function loadFromElement(input) {\n\t            var _this = this;\n\t\n\t            return new Promise(function (resolve, reject) {\n\t                // Bad input type\n\t                if (!(input instanceof Element)) {\n\t                    reject(new Error('Input param must be a Element object.'));\n\t                }\n\t\n\t                // Parser error\n\t                if (input.nodeName === 'parsererror') {\n\t                    // FF\n\t                    reject(new Error(input.textContent));\n\t                }\n\t\n\t                if (input.nodeName === 'html' && input.getElementsByTagName('parsererror')) {\n\t                    // Chrome\n\t                    reject(new Error(input.getElementsByTagName('parsererror')[0].textContent));\n\t                }\n\t\n\t                // Set document element\n\t                _this.element = input;\n\t\n\t                // Resolve promise\n\t                resolve(input);\n\t            });\n\t        }\n\t\n\t        // Load from XMLDocument object\n\t\n\t    }, {\n\t        key: 'loadFromXMLDocument',\n\t        value: function loadFromXMLDocument(input) {\n\t            var _this2 = this;\n\t\n\t            return new Promise(function (resolve, reject) {\n\t                // Bad input type\n\t                if (!(input instanceof XMLDocument)) {\n\t                    reject(new Error('Input param must be a XMLDocument object.'));\n\t                }\n\t\n\t                // Load from Element...\n\t                _this2.loadFromElement(input.documentElement).then(resolve).catch(reject);\n\t            });\n\t        }\n\t\n\t        // Load raw XML string\n\t\n\t    }, {\n\t        key: 'loadFromString',\n\t        value: function loadFromString(input) {\n\t            var _this3 = this;\n\t\n\t            return new Promise(function (resolve, reject) {\n\t                // Bad input type\n\t                if (typeof input !== 'string') {\n\t                    reject(new Error('Input param must be a string.'));\n\t                }\n\t\n\t                // Parse svg editor\n\t                _this3._parseEditor(input);\n\t\n\t                // Parse string as DOM object\n\t                var parser = new DOMParser();\n\t                var XMLDoc = parser.parseFromString(input, 'text/xml');\n\t\n\t                // Load from XMLDocument...\n\t                _this3.loadFromXMLDocument(XMLDoc).then(resolve).catch(reject);\n\t            });\n\t        }\n\t\n\t        // Try to get the svg editor from input string\n\t\n\t    }, {\n\t        key: '_parseEditor',\n\t        value: function _parseEditor(input) {\n\t            // Reset editor\n\t            this.editor = {\n\t                name: 'unknown',\n\t                version: null,\n\t                fingerprint: null\n\t            };\n\t\n\t            // Fingerprint matches\n\t            var fingerprint = void 0;\n\t\n\t            // Inkscape\n\t            fingerprint = input.match(/<!-- Created with Inkscape .*-->/i);\n\t\n\t            if (fingerprint) {\n\t                this.editor.name = 'inkscape';\n\t                this.editor.fingerprint = fingerprint[0];\n\t\n\t                return this.editor;\n\t            }\n\t\n\t            // Illustrator\n\t            fingerprint = input.match(/<!-- Generator: Adobe Illustrator ([0-9\\.]+), .*-->/i);\n\t\n\t            if (fingerprint) {\n\t                this.editor.name = 'illustrator';\n\t                this.editor.version = fingerprint[1];\n\t                this.editor.fingerprint = fingerprint[0];\n\t\n\t                return this.editor;\n\t            }\n\t\n\t            // Return default\n\t            return this.editor;\n\t        }\n\t\n\t        // Load from File object\n\t\n\t    }, {\n\t        key: 'loadFromFile',\n\t        value: function loadFromFile(input) {\n\t            var _this4 = this;\n\t\n\t            return new Promise(function (resolve, reject) {\n\t                // Bad input type\n\t                if (!(input instanceof File)) {\n\t                    reject(new Error('Input param must be a File object.'));\n\t                }\n\t\n\t                // Create file reader\n\t                var reader = new FileReader();\n\t\n\t                // Register reader events handlers\n\t                reader.onload = function (event) {\n\t                    _this4.loadFromString(event.target.result).then(resolve).catch(reject);\n\t                };\n\t\n\t                reader.onerror = function (event) {\n\t                    reject(new Error('Error reading file : ' + input.name));\n\t                };\n\t\n\t                // Finally read input file as text\n\t                reader.readAsText(input);\n\t            });\n\t        }\n\t\n\t        // Parse the (loaded) element\n\t\n\t    }, {\n\t        key: 'parse',\n\t        value: function parse(input) {\n\t            var _this5 = this;\n\t\n\t            // Reset properties\n\t            this.document = null;\n\t            this.defs = {};\n\t            this.tags = null;\n\t\n\t            // Load input if provided\n\t            if (input) {\n\t                return new Promise(function (resolve, reject) {\n\t                    _this5.load(input).then(function () {\n\t                        resolve(_this5.parse());\n\t                    }).catch(reject);\n\t                });\n\t            }\n\t\n\t            // Start parsing element\n\t            return new Promise(function (resolve, reject) {\n\t                // If no element is loaded\n\t                if (!_this5.element) {\n\t                    reject(new Error('No element is loaded, call the load method before.'));\n\t                }\n\t\n\t                // Parse the main Element (recursive)\n\t                _this5.tags = _this5._parseElement(_this5.element);\n\t\n\t                if (!_this5.tags) {\n\t                    reject(new Error('No supported tags found.'));\n\t                }\n\t\n\t                // Apply matrix (recursive)\n\t                _this5.tags.applyMatrix();\n\t\n\t                // Resolve the promise\n\t                resolve(_this5.tags);\n\t            });\n\t        }\n\t\n\t        // On tag callback\n\t\n\t    }, {\n\t        key: '_onTag',\n\t        value: function _onTag(tag) {}\n\t        //console.info('onTag:', tag)\n\t\n\t\n\t        // Register on tag callback\n\t\n\t    }, {\n\t        key: 'onTag',\n\t        value: function onTag(callback, context) {\n\t            var _this6 = this;\n\t\n\t            this._onTag = function (tag) {\n\t                return callback.call(context || _this6, tag);\n\t            };\n\t        }\n\t\n\t        // Parse the provided Element and return an Tag collection (recursive)\n\t\n\t    }, {\n\t        key: '_parseElement',\n\t        value: function _parseElement(element, parent) {\n\t            var _this7 = this;\n\t\n\t            // Create base tag object\n\t            var tag = new _tag.Tag(element, parent);\n\t\n\t            // Exluded tag ?\n\t            if (this.skipTags.indexOf(tag.name) !== -1) {\n\t                return null; // silent\n\t            }\n\t\n\t            // Supported tag ?\n\t            if (this.parseTags.indexOf(tag.name) === -1) {\n\t                return this._skipTag(tag, 'unsupported');\n\t            }\n\t\n\t            // Parse the tag\n\t            var tagParser = new _tagparser.TagParser(tag, this);\n\t\n\t            if (!tagParser.parse()) {\n\t                return false;\n\t            }\n\t\n\t            // Call the on tag callback\n\t            this._onTag(tag);\n\t\n\t            // Parse child nodes\n\t            var childTag = void 0;\n\t\n\t            element.childNodes.forEach(function (childNode) {\n\t                // Parse child element\n\t                if (childTag = _this7._parseElement(childNode, tag)) {\n\t                    tag.addChild(childTag);\n\t                }\n\t            });\n\t\n\t            // Empty group\n\t            if (['svg', 'g'].indexOf(tag.name) !== -1 && !tag.children.length) {\n\t                return this._skipTag(tag, 'empty');\n\t            }\n\t\n\t            // Return tag object\n\t            return tag;\n\t        }\n\t\n\t        // Log skip tag warning message\n\t\n\t    }, {\n\t        key: '_skipTag',\n\t        value: function _skipTag(tag, message) {\n\t            console.warn('Skip tag :', message + ':', tag);\n\t            return false;\n\t        }\n\t\n\t        // Log skip tag attribute warning message\n\t\n\t    }, {\n\t        key: '_skipTagAttr',\n\t        value: function _skipTagAttr(tag, attr, message) {\n\t            console.warn('Skip tag attribute :', message + ':', attr, tag);\n\t            return false;\n\t        }\n\t    }]);\n\t\n\t    return Parser;\n\t}();\n\t\n\t// Exports\n\t\n\t\n\texports.Parser = Parser;\n\texports.default = Parser;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.Tag = undefined;\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _lw = __webpack_require__(1);\n\t\n\tvar _clipperLib = __webpack_require__(5);\n\t\n\tvar _clipperLib2 = _interopRequireDefault(_clipperLib);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar DEG_TO_RAD = Math.PI / 180;\n\t\n\t// SVG tag class\n\t\n\tvar Tag = function () {\n\t    // Class constructor...\n\t    function Tag(element, parent) {\n\t        var _this = this;\n\t\n\t        _classCallCheck(this, Tag);\n\t\n\t        // Init properties\n\t        this.element = element;\n\t        this.name = element.nodeName.toLowerCase();\n\t        this.parent = parent || null;\n\t        this.layer = null;\n\t        this.attrs = {};\n\t        this.children = [];\n\t        this.paths = [];\n\t        this.matrix = null;\n\t        this.path = new _lw.Path();\n\t        this.point = new _lw.Point(0, 0);\n\t        this.shapes = [];\n\t\n\t        // Add first path\n\t        this.paths.push(this.path);\n\t\n\t        // Set the matrix\n\t        this.setMatrix(this.parent && this.parent.matrix);\n\t\n\t        // Clone parent attributes\n\t        if (this.parent && (this.parent.name === 'g' || this.parent.name === 'svg')) {\n\t            (function () {\n\t                // Inherit layer name\n\t                _this.layer = _this.parent.layer;\n\t\n\t                // Inherit parent attributes\n\t                var excludes = ['transform', 'width', 'height'];\n\t\n\t                if (_this.name !== 'g' && _this.name !== 'svg') {\n\t                    excludes.push('viewBox');\n\t                }\n\t\n\t                Object.keys(_this.parent.attrs).forEach(function (key) {\n\t                    if (excludes.indexOf(key) === -1) {\n\t                        _this.setAttr(key, _this.parent.attrs[key]);\n\t                    }\n\t                });\n\t            })();\n\t        }\n\t    }\n\t\n\t    _createClass(Tag, [{\n\t        key: 'setAttr',\n\t        value: function setAttr(name, value) {\n\t            this.attrs[name] = value;\n\t        }\n\t    }, {\n\t        key: 'getAttr',\n\t        value: function getAttr(name, defaultValue) {\n\t            return this.attrs[name] !== undefined ? this.attrs[name] : defaultValue !== undefined ? defaultValue : null;\n\t        }\n\t    }, {\n\t        key: 'getLayerName',\n\t        value: function getLayerName() {\n\t            if (this.name === 'g') {\n\t                return this.getAttr('inkscape:label', this.getAttr('id', null));\n\t            }\n\t        }\n\t    }, {\n\t        key: 'setLayerName',\n\t        value: function setLayerName(name) {\n\t            if (this.name === 'g') {\n\t                this.layer = name || this.getLayerName();\n\t            }\n\t        }\n\t    }, {\n\t        key: 'addChild',\n\t        value: function addChild(childTag) {\n\t            this.children.push(childTag);\n\t        }\n\t    }, {\n\t        key: 'clearPath',\n\t        value: function clearPath() {\n\t            this.path = new _lw.Path();\n\t            this.point = new _lw.Point(0, 0);\n\t        }\n\t    }, {\n\t        key: 'newPath',\n\t        value: function newPath() {\n\t            if (this.path.length > 0) {\n\t                this.clearPath();\n\t                this.paths.push(this.path);\n\t            }\n\t        }\n\t    }, {\n\t        key: 'closePath',\n\t        value: function closePath() {\n\t            // Close path\n\t            var close = this.path.close();\n\t\n\t            // Update current point\n\t            var point = this.path.getPoint(-1);\n\t            this.point = new _lw.Point(point.x, point.y);\n\t\n\t            // Return close result\n\t            return close;\n\t        }\n\t    }, {\n\t        key: 'addPoint',\n\t        value: function addPoint(x, y, relative) {\n\t            // Relative from the last point\n\t            if (relative) {\n\t                x += this.point.x;\n\t                y += this.point.y;\n\t            }\n\t\n\t            // Add current point\n\t            this.path.addPoint(x, y);\n\t\n\t            // Update current point\n\t            this.point = new _lw.Point(x, y);\n\t        }\n\t    }, {\n\t        key: 'addPoints',\n\t        value: function addPoints(points, relative) {\n\t            // For each couple of points\n\t            for (var i = 0, il = points.length; i < il; i += 2) {\n\t                this.addPoint(points[i], points[i + 1], relative);\n\t            }\n\t        }\n\t    }, {\n\t        key: 'setMatrix',\n\t        value: function setMatrix(matrix) {\n\t            this.matrix = matrix || [1, 0, 0, 1, 0, 0];\n\t        }\n\t    }, {\n\t        key: 'addMatrix',\n\t        value: function addMatrix(matrix) {\n\t            this.matrix = [this.matrix[0] * matrix[0] + this.matrix[2] * matrix[1], this.matrix[1] * matrix[0] + this.matrix[3] * matrix[1], this.matrix[0] * matrix[2] + this.matrix[2] * matrix[3], this.matrix[1] * matrix[2] + this.matrix[3] * matrix[3], this.matrix[0] * matrix[4] + this.matrix[2] * matrix[5] + this.matrix[4], this.matrix[1] * matrix[4] + this.matrix[3] * matrix[5] + this.matrix[5]];\n\t        }\n\t    }, {\n\t        key: 'translate',\n\t        value: function translate(x, y) {\n\t            y = y === undefined ? 0 : y;\n\t            this.addMatrix([1, 0, 0, 1, x, y]);\n\t        }\n\t    }, {\n\t        key: 'rotate',\n\t        value: function rotate(angle, x, y) {\n\t            angle = angle * DEG_TO_RAD;\n\t\n\t            if (arguments.length == 2) {\n\t                this.addMatrix([1, 0, 0, 1, x, y]);\n\t            }\n\t\n\t            this.addMatrix([Math.cos(angle), Math.sin(angle), -Math.sin(angle), Math.cos(angle), 0, 0]);\n\t\n\t            if (arguments.length == 2) {\n\t                this.addMatrix([1, 0, 0, 1, -x, -y]);\n\t            }\n\t        }\n\t    }, {\n\t        key: 'scale',\n\t        value: function scale(x, y) {\n\t            y = y === undefined ? x : y;\n\t            this.addMatrix([x, 0, 0, y, 0, 0]);\n\t        }\n\t    }, {\n\t        key: 'skewX',\n\t        value: function skewX(angle) {\n\t            this.addMatrix([1, 0, Math.tan(angle * DEG_TO_RAD), 1, 0, 0]);\n\t        }\n\t    }, {\n\t        key: 'skewY',\n\t        value: function skewY(angle) {\n\t            this.addMatrix([1, Math.tan(angle * DEG_TO_RAD), 0, 1, 0, 0]);\n\t        }\n\t    }, {\n\t        key: 'applyMatrix',\n\t        value: function applyMatrix(matrix) {\n\t            var _this2 = this;\n\t\n\t            matrix && this.addMatrix(matrix);\n\t\n\t            this.paths.forEach(function (path) {\n\t                path.transform(_this2.matrix);\n\t            });\n\t\n\t            this.shapes.forEach(function (shape) {\n\t                shape.outer.transform(_this2.matrix);\n\t                shape.holes.forEach(function (hole) {\n\t                    hole.transform(_this2.matrix);\n\t                });\n\t            });\n\t\n\t            this.setMatrix(null);\n\t\n\t            this.children.forEach(function (tag) {\n\t                tag.applyMatrix(matrix);\n\t            });\n\t        }\n\t    }, {\n\t        key: 'getPaths',\n\t        value: function getPaths() {\n\t            return this.paths;\n\t        }\n\t    }, {\n\t        key: 'getShapes',\n\t        value: function getShapes() {\n\t            // No shapes...\n\t            if (this.getAttr('fill', 'none') === 'none' || !this.paths[0].length) {\n\t                return this.shapes;\n\t            }\n\t\n\t            // Get fill rule\n\t            var fillRule = this.getAttr('fill-rule', 'nonzero');\n\t            fillRule = fillRule === 'nonzero' ? _clipperLib2.default.PolyFillType.pftNonZero : _clipperLib2.default.PolyFillType.pftEvenOdd;\n\t\n\t            // Create clipper path\n\t            var cPolyTree = new _clipperLib2.default.PolyTree();\n\t            var cClipper = new _clipperLib2.default.Clipper();\n\t            var clipperScale = 10000000;\n\t            var clipperPaths = [];\n\t\n\t            this.paths.forEach(function (path) {\n\t                clipperPaths.push(path.getClipperPoints(clipperScale));\n\t            });\n\t\n\t            cClipper.AddPaths(clipperPaths, _clipperLib2.default.PolyType.ptSubject, true);\n\t            cClipper.Execute(_clipperLib2.default.ClipType.ctUnion, cPolyTree, fillRule, fillRule);\n\t\n\t            var paths = _clipperLib2.default.Clipper.PolyTreeToPaths(cPolyTree);\n\t            var polygones = _clipperLib2.default.Clipper.SimplifyPolygons(paths, fillRule);\n\t\n\t            // Single path (no hole)\n\t            if (this.paths.length > 1) {\n\t                cClipper.Clear();\n\t                cClipper.StrictlySimple = true;\n\t                cPolyTree = new _clipperLib2.default.PolyTree();\n\t                cClipper.AddPaths(polygones, _clipperLib2.default.PolyType.ptSubject, true);\n\t                cClipper.Execute(_clipperLib2.default.ClipType.ctUnion, cPolyTree, fillRule, fillRule);\n\t            }\n\t\n\t            // PolyTree to ExPolygons\n\t            var toPath = function toPath(path) {\n\t                return new _lw.Path().fromClipperPoints(path, 1 / clipperScale);\n\t            };\n\t            var exPolygons = _clipperLib2.default.JS.PolyTreeToExPolygons(cPolyTree);\n\t            this.shapes = exPolygons.map(function (exPolygon) {\n\t                return {\n\t                    outer: toPath(exPolygon.outer),\n\t                    holes: exPolygon.holes.map(toPath)\n\t                };\n\t            });\n\t\n\t            // Return shapes...\n\t            return this.shapes;\n\t        }\n\t    }]);\n\t\n\t    return Tag;\n\t}();\n\t\n\t// Exports\n\t\n\t\n\texports.Tag = Tag;\n\texports.default = Tag;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.TagParser = undefined;\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _lw = __webpack_require__(6);\n\t\n\tvar _lw2 = __webpack_require__(1);\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t// SVG tag parser\n\tvar TagParser = function () {\n\t    // Class constructor...\n\t    function TagParser(tag, parser) {\n\t        _classCallCheck(this, TagParser);\n\t\n\t        // Init properties\n\t        this.tag = tag;\n\t        this.parser = parser;\n\t        this.currentCommand = null;\n\t        this.lastCommand = null;\n\t        this.pathData = null;\n\t        this.traceSettings = parser.traceSettings;\n\t    }\n\t\n\t    _createClass(TagParser, [{\n\t        key: 'parse',\n\t        value: function parse() {\n\t            // Get internal parser from node name\n\t            var handler = this['_' + this.tag.name];\n\t\n\t            // Implemented tag handler?\n\t            if (!handler || typeof handler !== 'function') {\n\t                return this.parser._skipTag(this.tag, 'not yet implemented');\n\t            }\n\t\n\t            // Parse tag attributes\n\t            this._parseTagAttrs();\n\t\n\t            // Parse tag\n\t            return handler.call(this);\n\t        }\n\t\n\t        // Parse the tag attributes\n\t\n\t    }, {\n\t        key: '_parseTagAttrs',\n\t        value: function _parseTagAttrs() {\n\t            var _this = this;\n\t\n\t            // Get tag attributes\n\t            var attrs = this.tag.element.attributes;\n\t\n\t            if (!attrs) {\n\t                return null;\n\t            }\n\t\n\t            // Get viewBox attribute if any\n\t            var viewBox = attrs.getNamedItem('viewBox');\n\t\n\t            if (viewBox) {\n\t                this.tag.setAttr('viewBox', this._normalizeTagAttrPoints(viewBox));\n\t            }\n\t\n\t            // For each attribute\n\t            var attr = void 0,\n\t                value = void 0,\n\t                style = void 0;\n\t\n\t            Object.keys(attrs).some(function (key) {\n\t                // Current attribute\n\t                attr = attrs[key];\n\t\n\t                // Normalize attribute value\n\t                value = _this._normalizeTagAttr(attr);\n\t\n\t                if (value === false) {\n\t                    return false; // continue\n\t                }\n\t\n\t                // Special case\n\t                if (attr.nodeName === 'style') {\n\t                    style = value;\n\t                } else {\n\t                    // Set new attribute name/value\n\t                    _this.tag.setAttr(attr.nodeName, value);\n\t                }\n\t            });\n\t\n\t            // If style attribute (override tag attributes)\n\t            // TODO get/parse global style and override this one...\n\t            style && style.replace(/;$/, '').split(';').some(function (attr) {\n\t                // Current style\n\t                attr = attr.split(':');\n\t                attr = { nodeName: attr[0], nodeValue: attr[1] };\n\t\n\t                // Normalize attribute value\n\t                value = _this._normalizeTagAttr(attr);\n\t\n\t                if (value === false) {\n\t                    return false; // continue\n\t                }\n\t\n\t                // Set new attribute name/value\n\t                _this.tag.setAttr(attr.nodeName, value);\n\t            });\n\t\n\t            // Set inherited color\n\t            var colorsAttrs = ['fill', 'stroke', 'color'];\n\t\n\t            colorsAttrs.forEach(function (attrName) {\n\t                if (_this.tag.getAttr(attrName) === 'inherit') {\n\t                    _this.tag.setAttr(attrName, _this.tag.parent.getAttr(attrName, 'none'));\n\t                }\n\t            });\n\t\n\t            // Parse viewBox attribute\n\t            this._parseViewBoxAttr();\n\t\n\t            // Parse transform attribute\n\t            this._parseTransformAttr();\n\t        }\n\t\n\t        // Normalize tag attribute\n\t\n\t    }, {\n\t        key: '_normalizeTagAttr',\n\t        value: function _normalizeTagAttr(attr) {\n\t            // Normalize whitespaces\n\t            var value = attr.nodeValue.replace(/(\\r?\\n|\\r)+/gm, ' ') // Remove all new line chars\n\t            .replace(/\\s+/gm, ' ') // Reduce multiple whitespaces\n\t            .trim(); // Remove trailing whitespaces\n\t\n\t            if (!value.length) {\n\t                return this.parser._skipTagAttr(this.tag, attr, 'empty');\n\t            }\n\t\n\t            // Filters\n\t            switch (attr.nodeName) {\n\t                // Normalize size unit -> to px\n\t                case 'x':\n\t                case 'y':\n\t                case 'width':\n\t                case 'height':\n\t                    value = this._normalizeTagAttrUnit(attr);\n\t                    break;\n\t\n\t                case 'x1':\n\t                case 'y1':\n\t                case 'x2':\n\t                case 'y2':\n\t                case 'r':\n\t                case 'rx':\n\t                case 'ry':\n\t                case 'cx':\n\t                case 'cy':\n\t                case 'font-size':\n\t                case 'stroke-width':\n\t                    value = this._normalizeTagAttrUnit(attr, true);\n\t                    break;\n\t\n\t                // Normalize points attribute\n\t                case 'points':\n\t                    //case 'viewBox':\n\t                    value = this._normalizeTagAttrPoints(attr);\n\t                    break;\n\t\n\t                case 'viewBox':\n\t                    value = false;\n\t                    break;\n\t\n\t                // Range limit to [0 - 1]\n\t                case 'opacity':\n\t                case 'fill-opacity':\n\t                case 'stroke-opacity':\n\t                    value = this._normalizeTagAttrRange(attr, 0, 1);\n\t                    break;\n\t\n\t                case 'preserveAspectRatio':\n\t                    value = this._normalizeTagAttrPreserveAspectRatio(attr);\n\t                    break;\n\t            }\n\t\n\t            // Return normalized value\n\t            return value;\n\t        }\n\t\n\t        // Normalize attribute unit to px\n\t\n\t    }, {\n\t        key: '_normalizeTagAttrUnit',\n\t        value: function _normalizeTagAttrUnit(attr, ratio) {\n\t            var stringValue = attr.nodeValue.toLowerCase();\n\t            var floatValue = parseFloat(stringValue);\n\t\n\t            if (isNaN(floatValue)) {\n\t                return this.parser._skipTagAttr(this.tag, attr, 'only numeric value allowed');\n\t            }\n\t\n\t            if (stringValue.indexOf('mm') !== -1) {\n\t                return floatValue * 3.5433070869;\n\t            }\n\t\n\t            if (stringValue.indexOf('cm') !== -1) {\n\t                return floatValue * 35.433070869;\n\t            }\n\t\n\t            if (stringValue.indexOf('in') !== -1) {\n\t                return floatValue * 90.0;\n\t            }\n\t\n\t            if (stringValue.indexOf('pt') !== -1) {\n\t                return floatValue * 1.25;\n\t            }\n\t\n\t            if (stringValue.indexOf('pc') !== -1) {\n\t                return floatValue * 15.0;\n\t            }\n\t\n\t            if (stringValue.indexOf('%') !== -1) {\n\t                var viewBox = this.tag.getAttr('viewBox', this.tag.parent && this.tag.parent.getAttr('viewBox'));\n\t\n\t                switch (attr.nodeName) {\n\t                    case 'x':\n\t                    case 'width':\n\t                        floatValue *= viewBox[2] / 100;\n\t                        break;\n\t                    case 'y':\n\t                    case 'height':\n\t                        floatValue *= viewBox[3] / 100;\n\t                        break;\n\t                }\n\t            }\n\t\n\t            if (stringValue.indexOf('em') !== -1) {\n\t                var fontSize = this.tag.getAttr('font-size', 16);\n\t\n\t                switch (attr.nodeName) {\n\t                    case 'x':\n\t                    case 'y':\n\t                    case 'width':\n\t                    case 'height':\n\t                        floatValue *= fontSize;\n\t                        break;\n\t                }\n\t            }\n\t\n\t            return floatValue;\n\t        }\n\t\n\t        // Normalize points attribute\n\t\n\t    }, {\n\t        key: '_normalizeTagAttrPoints',\n\t        value: function _normalizeTagAttrPoints(attr) {\n\t            var points = this._parseNumbers(attr.nodeValue);\n\t\n\t            if (points === false) {\n\t                return this.parser._skipTagAttr(this.tag, attr, 'only numeric values are allowed');\n\t            }\n\t\n\t            if (!points.length) {\n\t                return this.parser._skipTagAttr(this.tag, attr, 'empty points list');\n\t            }\n\t\n\t            if (points.length % 0) {\n\t                return this.parser._skipTagAttr(this.tag, attr, 'the number of points must be even');\n\t            }\n\t\n\t            return points;\n\t        }\n\t\n\t        // Normalize range attribute like \"opacity\"\n\t\n\t    }, {\n\t        key: '_normalizeTagAttrRange',\n\t        value: function _normalizeTagAttrRange(attr, min, max) {\n\t            var stringValue = attr.nodeValue.trim();\n\t            var floatValue = parseFloat(stringValue);\n\t\n\t            if (isNaN(floatValue)) {\n\t                return this.parser._skipTagAttr(this.tag, attr, 'only numeric values are allowed');\n\t            }\n\t\n\t            if (floatValue < min || floatValue > max) {\n\t                return this.parser._skipTagAttr(this.tag, attr, 'out of range [' + min + ', ' + max + ']');\n\t            }\n\t\n\t            return floatValue;\n\t        }\n\t\n\t        // Parse points string as numbers array\n\t\n\t    }, {\n\t        key: '_parseNumbers',\n\t        value: function _parseNumbers(points) {\n\t            // http://stackoverflow.com/questions/638565/parsing-scientific-notation-sensibly\n\t            if (typeof points === 'string') {\n\t                points = points.split(/([+\\-]?(?:0|[1-9]\\d*)(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?)?/g).filter(function (point) {\n\t                    return point && ['', ','].indexOf(point.trim()) === -1;\n\t                });\n\t            }\n\t\n\t            // Normalize to float values\n\t            points = points.map(parseFloat);\n\t\n\t            // Test if all numbers is valid\n\t            if (points.some(isNaN)) {\n\t                return false;\n\t            }\n\t\n\t            return points;\n\t        }\n\t\n\t        // Normalize the preserveAspectRatio attribute\n\t\n\t    }, {\n\t        key: '_normalizeTagAttrPreserveAspectRatio',\n\t        value: function _normalizeTagAttrPreserveAspectRatio(attr) {\n\t            var params = {\n\t                defer: false,\n\t                align: 'none',\n\t                meet: true,\n\t                slice: false\n\t            };\n\t\n\t            var rawParams = attr.nodeValue;\n\t\n\t            if (rawParams.indexOf('defer') === 0) {\n\t                rawParams = rawParams.substr(6);\n\t                params.defer = true;\n\t            }\n\t\n\t            rawParams = rawParams.split(' ');\n\t            params.align = rawParams[0];\n\t            params.meet = rawParams[1] || 'meet';\n\t            params.meet = params.meet === 'meet';\n\t            params.slice = !params.meet;\n\t\n\t            return params;\n\t        }\n\t\n\t        // Parse viewBox attribute and set transformations\n\t\n\t    }, {\n\t        key: '_parseViewBoxAttr',\n\t        value: function _parseViewBoxAttr() {\n\t            // Get viewBox attribute\n\t            var viewBox = this.tag.getAttr('viewBox', null);\n\t\n\t            // No viewBox...\n\t            if (viewBox === null) {\n\t                return null;\n\t            }\n\t\n\t            // Update size attributes\n\t            var width = this.tag.getAttr('width', viewBox[2]);\n\t            var height = this.tag.getAttr('height', viewBox[3]);\n\t\n\t            this.tag.setAttr('width', width);\n\t            this.tag.setAttr('height', height);\n\t\n\t            // Scale to match viewBox\n\t            // TODO clip path if preserveAspectRatio.slice\n\t            var scaleX = width / viewBox[2];\n\t            var scaleY = height / viewBox[3];\n\t            var translateX = viewBox[0];\n\t            var translateY = viewBox[1];\n\t\n\t            var preserveAspectRatio = this.tag.getAttr('preserveAspectRatio', 'meet xMidYMid');\n\t\n\t            if (preserveAspectRatio) {\n\t                var newWidth = void 0,\n\t                    newHeight = void 0;\n\t\n\t                if (preserveAspectRatio.meet) {\n\t                    if (scaleX > scaleY) {\n\t                        scaleX = scaleY;\n\t                        newWidth = viewBox[2] * scaleX;\n\t                    } else if (scaleX < scaleY) {\n\t                        scaleY = scaleX;\n\t                        newHeight = viewBox[3] * scaleY;\n\t                    }\n\t                } else if (preserveAspectRatio.slice) {\n\t                    if (scaleX < scaleY) {\n\t                        scaleX = scaleY;\n\t                        newWidth = viewBox[2] * scaleX;\n\t                    } else if (scaleX > scaleY) {\n\t                        scaleY = scaleX;\n\t                        newHeight = viewBox[3] * scaleY;\n\t                    }\n\t                }\n\t\n\t                if (newWidth !== undefined) {\n\t                    if (preserveAspectRatio.align === 'xMidYMid') {\n\t                        this.tag.translate((width - newWidth) / 2, 0);\n\t                    } else if (preserveAspectRatio.align === 'xMaxYMax') {\n\t                        this.tag.translate(width - newWidth, 0);\n\t                    }\n\t                } else if (newHeight !== undefined) {\n\t                    if (preserveAspectRatio.align === 'xMidYMid') {\n\t                        this.tag.translate(0, (height - newHeight) / 2);\n\t                    } else if (preserveAspectRatio.align === 'xMaxYMax') {\n\t                        this.tag.translate(0, height - newHeight);\n\t                    }\n\t                }\n\t            }\n\t\n\t            this.tag.scale(scaleX, scaleY);\n\t            this.tag.translate(-translateX, -translateY);\n\t        }\n\t\n\t        // Parse transform attribute and set transformations\n\t\n\t    }, {\n\t        key: '_parseTransformAttr',\n\t        value: function _parseTransformAttr() {\n\t            var _this2 = this;\n\t\n\t            // Get transform attribute\n\t            var transformAttr = this.tag.getAttr('transform', null);\n\t\n\t            // No transformation...\n\t            if (transformAttr === null || !transformAttr.length) {\n\t                return null;\n\t            }\n\t\n\t            // Parse attribute (split group on closing parenthesis)\n\t            var transformations = transformAttr.split(')');\n\t\n\t            // Remove last entry due to last \")\" found\n\t            transformations.pop();\n\t\n\t            // For each transformation\n\t            var transform = void 0,\n\t                type = void 0,\n\t                params = void 0;\n\t\n\t            transformations.some(function (raw) {\n\t                // Split name and value on opening parenthesis\n\t                transform = raw.split('(');\n\t\n\t                // Invalid parts number\n\t                if (transform.length !== 2) {\n\t                    return _this2.parser._skipTagAttr(_this2.tag, transformAttr, 'malformed'); // continue\n\t                }\n\t\n\t                type = transform[0].trim();\n\t\n\t                // Quik hack 1/2\n\t                var func = type;\n\t                if (func === 'matrix') {\n\t                    func = 'addMatrix';\n\t                }\n\t\n\t                // Get tag transform method\n\t                var tagTransform = _this2.tag[func];\n\t\n\t                if (typeof tagTransform !== 'function') {\n\t                    return _this2.parser._skipTagAttr(_this2.tag, transformAttr, 'unsupported transform type :' + type);\n\t                }\n\t\n\t                params = transform[1].trim();\n\t                params = _this2._parseNumbers(params);\n\t\n\t                // Skip empty value\n\t                if (!params.length) {\n\t                    return _this2.parser._skipTagAttr(_this2.tag, transformAttr, 'malformed transform type :' + type);\n\t                }\n\t\n\t                // Quik hack 2/2\n\t                if (func == 'addMatrix') {\n\t                    params = [params];\n\t                }\n\t\n\t                // Call tag transform method like \"tag.translate(param1, ..., paramN)\"\n\t                tagTransform.apply(_this2.tag, params);\n\t            });\n\t        }\n\t    }, {\n\t        key: '_newPath',\n\t        value: function _newPath() {\n\t            this.tag.newPath();\n\t        }\n\t    }, {\n\t        key: '_clearPath',\n\t        value: function _clearPath() {\n\t            this.tag.clearPath();\n\t        }\n\t    }, {\n\t        key: '_closePath',\n\t        value: function _closePath() {\n\t            return this.tag.closePath();\n\t        }\n\t    }, {\n\t        key: '_addPoints',\n\t        value: function _addPoints(points, relative) {\n\t            if (!points.length) {\n\t                return this.parser._skipTag(this.tag, 'empty points list');\n\t            }\n\t\n\t            if (points.length % 0) {\n\t                return this.parser._skipTag(this.tag, 'the number of points must be even');\n\t            }\n\t\n\t            //relative = arguments.length < 2 && this.currentCommand.relative\n\t            if (relative === undefined) {\n\t                relative = this.currentCommand.relative;\n\t            }\n\t\n\t            this.tag.addPoints(points, relative);\n\t            return true;\n\t        }\n\t\n\t        // SVG specs at https://www.w3.org/TR/SVG11/\n\t\n\t    }, {\n\t        key: '_svg',\n\t        value: function _svg() {\n\t            // Only parse the root SVG tag as main document\n\t            if (this.parser.document) {\n\t                // Handled tag\n\t                return true;\n\t            }\n\t\n\t            // Get the document size\n\t            var width = this.tag.getAttr('width');\n\t            var height = this.tag.getAttr('height');\n\t\n\t            // Invalid size\n\t            if (!width || width < 0 || !height || height < 0) {\n\t                throw new Error('Invalid document size: ' + width + ' / ' + height);\n\t            }\n\t\n\t            // Set document size\n\t            this.parser.document = {\n\t                width: width,\n\t                height: height\n\t            };\n\t\n\t            // Get document viewBox or set default to document size\n\t            var viewBox = this.tag.getAttr('viewBox', [0, 0, width, height]);\n\t\n\t            this.parser.document.viewBox = {\n\t                x: viewBox[0],\n\t                y: viewBox[1],\n\t                width: viewBox[2],\n\t                height: viewBox[3]\n\t            };\n\t\n\t            // Check inkscape version\n\t            if (this.parser.editor.name === 'inkscape') {\n\t                this.parser.editor.version = this.tag.getAttr('inkscape:version');\n\t            }\n\t\n\t            // Handled tag\n\t            return true;\n\t        }\n\t    }, {\n\t        key: '_title',\n\t        value: function _title() {\n\t            // Register the first encountered title tag as document title\n\t            if (this.parser.document && !this.parser.document.title) {\n\t                this.parser.document.title = this.tag.element.textContent;\n\t            }\n\t\n\t            // Skipped tag\n\t            return false;\n\t        }\n\t    }, {\n\t        key: '_desc',\n\t        value: function _desc() {\n\t            // Register the first encountered desc tag as document description\n\t            if (this.parser.document && !this.parser.document.description) {\n\t                this.parser.document.description = this.tag.element.textContent;\n\t            }\n\t\n\t            // Skipped tag\n\t            return false;\n\t        }\n\t    }, {\n\t        key: '_image',\n\t        value: function _image() {\n\t            // console.log(this.tag.getAttr('xlink:href'))\n\t            // Handled tag\n\t            return true;\n\t        }\n\t    }, {\n\t        key: '_text',\n\t        value: function _text() {\n\t            // console.log(this.tag.element.textContent)\n\t            // Handled tag\n\t            return true;\n\t        }\n\t    }, {\n\t        key: '_defs',\n\t        value: function _defs() {\n\t            var _this3 = this;\n\t\n\t            // Register all child element with an id attribute\n\t            this.tag.element.childNodes.forEach(function (childNode) {\n\t                childNode.id && (_this3.parser.defs[childNode.id] = childNode);\n\t            });\n\t\n\t            // Skipped tag\n\t            return false;\n\t        }\n\t    }, {\n\t        key: '_use',\n\t        value: function _use() {\n\t            // Get the target id\n\t            var target = this.tag.getAttr('xlink:href').replace(/^#/, '');\n\t\n\t            // Try to get the defined element\n\t            var element = this.parser.defs[target];\n\t\n\t            if (!element) {\n\t                return this.parser._skipTag(this.tag, 'undefined reference [' + target + ']');\n\t            }\n\t\n\t            // Parse the defined element and set new parent from <use> tag parent\n\t            var useTag = this.parser._parseElement(element, this.tag.parent);\n\t\n\t            if (!useTag) {\n\t                return this.parser._skipTag(this.tag, 'empty reference [' + target + ']');\n\t            }\n\t\n\t            // Set matrix from real parent (<use>)\n\t            useTag.setMatrix(this.tag.matrix);\n\t\n\t            // Replace the use tag with new one\n\t            this.tag.parent.addChild(useTag);\n\t\n\t            // Skipped tag\n\t            return false;\n\t        }\n\t    }, {\n\t        key: '_g',\n\t        value: function _g() {\n\t            // Set the tag layer name\n\t            this.tag.setLayerName();\n\t\n\t            // Handled tag\n\t            return true;\n\t        }\n\t    }, {\n\t        key: '_line',\n\t        value: function _line() {\n\t            // Handled tag\n\t            return this._path(['M', this.tag.getAttr('x1'), this.tag.getAttr('y1'), 'L', this.tag.getAttr('x2'), this.tag.getAttr('y2')]);\n\t        }\n\t    }, {\n\t        key: '_polyline',\n\t        value: function _polyline() {\n\t            var close = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\t\n\t            var points = this.tag.getAttr('points');\n\t            var path = ['M', points.shift(), points.shift(), 'L'];\n\t\n\t            path = path.concat(points);\n\t            close && path.push('Z');\n\t\n\t            // Handled tag\n\t            return this._path(path);\n\t        }\n\t    }, {\n\t        key: '_polygon',\n\t        value: function _polygon() {\n\t            // Handled like polyline but closed\n\t            return this._polyline(true);\n\t        }\n\t    }, {\n\t        key: '_rect',\n\t        value: function _rect() {\n\t            // Get rectangle attributes\n\t            var w = this.tag.getAttr('width');\n\t            var h = this.tag.getAttr('height');\n\t            var x = this.tag.getAttr('x', 0);\n\t            var y = this.tag.getAttr('y', 0);\n\t            var rx = this.tag.getAttr('rx', null);\n\t            var ry = this.tag.getAttr('ry', null);\n\t\n\t            // Simple rect\n\t            if (!rx && !ry) {\n\t                // Handled tag\n\t                return this._path(['M', x, y, 'h', w, 'v', h, 'h', -w, 'z']);\n\t            }\n\t\n\t            // If a properly specified value is provided for ‘rx’, but not for ‘ry’,\n\t            // then set both rx and ry to the value of ‘rx’ and vis-vera...\n\t            if (rx === null) rx = ry;\n\t            if (ry === null) ry = rx;\n\t\n\t            // A negative value is an error\n\t            if (rx === null || rx === null || rx < 0 || ry < 0) {\n\t                // Skip tag\n\t                return this.parser._skipTag(this.tag, 'negative value for \"rx/ry\" not allowed');\n\t            }\n\t\n\t            // If rx is greater than half of ‘width’, then set rx to half of ‘width’.\n\t            // If ry is greater than half of ‘height’, then set ry to half of ‘height’.\n\t            if (rx > w / 2) rx = w / 2;\n\t            if (ry > h / 2) ry = h / 2;\n\t\n\t            var dx = rx * 2;\n\t            var dy = ry * 2;\n\t\n\t            // Handled tag\n\t            return this._path(['M', x + rx, y, 'h', w - dx, 'c', rx, 0, rx, ry, rx, ry, 'v', h - dy, 'c', 0, ry, -rx, ry, -rx, ry, 'h', -w + dx, 'c', -rx, 0, -rx, -ry, -rx, -ry, 'v', -h + dy, 'c', 0, 0, 0, -ry, rx, -ry, 'z']);\n\t        }\n\t    }, {\n\t        key: '_circle',\n\t        value: function _circle() {\n\t            var r = this.tag.getAttr('r', 0);\n\t\n\t            if (r <= 0) {\n\t                // Skipped tag\n\t                return false;\n\t            }\n\t\n\t            var cx = this.tag.getAttr('cx', 0);\n\t            var cy = this.tag.getAttr('cy', 0);\n\t\n\t            // Handled tag\n\t            return this._path(['M', cx - r, cy, 'A', r, r, 0, 0, 0, cx, cy + r, 'A', r, r, 0, 0, 0, cx + r, cy, 'A', r, r, 0, 0, 0, cx, cy - r, 'A', r, r, 0, 0, 0, cx - r, cy, 'Z']);\n\t        }\n\t    }, {\n\t        key: '_ellipse',\n\t        value: function _ellipse() {\n\t            var rx = this.tag.getAttr('rx', 0);\n\t            var ry = this.tag.getAttr('ry', 0);\n\t\n\t            if (rx <= 0 || ry <= 0) {\n\t                // Skipped tag\n\t                return false;\n\t            }\n\t\n\t            var cx = this.tag.getAttr('cx', 0);\n\t            var cy = this.tag.getAttr('cy', 0);\n\t\n\t            // Handled tag\n\t            return this._path(['M', cx - rx, cy, 'A', rx, ry, 0, 0, 0, cx, cy + ry, 'A', rx, ry, 0, 0, 0, cx + rx, cy, 'A', rx, ry, 0, 0, 0, cx, cy - ry, 'A', rx, ry, 0, 0, 0, cx - rx, cy, 'Z']);\n\t        }\n\t    }, {\n\t        key: '_paths',\n\t        value: function _paths(type, num, points) {\n\t            if (points.length > num) {\n\t                var handler = void 0,\n\t                    result = true;\n\t\n\t                while (result && points.length) {\n\t                    handler = this['_path' + type];\n\t                    result = handler.call(this, points.splice(0, num));\n\t                }\n\t\n\t                return result;\n\t            }\n\t\n\t            return null;\n\t        }\n\t    }, {\n\t        key: '_path',\n\t        value: function _path(path) {\n\t            var _this4 = this;\n\t\n\t            // Provided path\n\t            if (path && typeof path !== 'string') {\n\t                path = path.join(' ');\n\t            }\n\t\n\t            // Get the paths data attribute value\n\t            var dAttr = path || this.tag.getAttr('d', null);\n\t\n\t            if (!dAttr) {\n\t                // Skipped tag\n\t                return false;\n\t            }\n\t\n\t            // Split on each commands\n\t            var commands = dAttr.match(/([M|Z|L|H|V|C|S|Q|T|A]([^M|Z|L|H|V|C|S|Q|T|A]+)?)/gi);\n\t\n\t            if (!commands) {\n\t                return this.parser._skipTag(this.tag, 'malformed \"d\" attribute');\n\t            }\n\t\n\t            // For each command...\n\t            this.currentCommand = {\n\t                raw: null,\n\t                type: null,\n\t                params: null,\n\t                relative: null\n\t            };\n\t            this.lastCommand = this.currentCommand;\n\t            this.pathData = {};\n\t\n\t            var handler = null;\n\t            var parseError = false;\n\t\n\t            commands.some(function (raw) {\n\t                // Remove trailing whitespaces\n\t                raw = raw.trim();\n\t\n\t                // Extract command char and params\n\t                _this4.currentCommand.raw = raw;\n\t                _this4.currentCommand.type = raw[0].toUpperCase();\n\t                _this4.currentCommand.params = raw.substr(1).trim();\n\t                _this4.currentCommand.relative = _this4.currentCommand.type !== raw[0];\n\t\n\t                // Get path handler from command char\n\t                handler = _this4['_path' + _this4.currentCommand.type];\n\t\n\t                if (!handler || typeof handler !== 'function') {\n\t                    _this4.parser._skipTag(_this4.tag, 'unsupported path command [' + raw[0] + ']');\n\t                    return parseError = true; // break\n\t                }\n\t\n\t                // Extract all numbers from arguments string\n\t                _this4.currentCommand.params = _this4._parseNumbers(_this4.currentCommand.params);\n\t\n\t                if (_this4.currentCommand.params === false) {\n\t                    _this4.parser._skipTag(_this4.tag, 'only numeric values are allowed in [' + _this4.currentCommand.raw + ']');\n\t                    return parseError = true; // break\n\t                }\n\t\n\t                // Execute command parser\n\t                if (!handler.call(_this4, _this4.currentCommand.params)) {\n\t                    return parseError = true; // break\n\t                }\n\t\n\t                // Update last command\n\t                _this4.lastCommand = {};\n\t\n\t                Object.keys(_this4.currentCommand).forEach(function (key) {\n\t                    _this4.lastCommand[key] = _this4.currentCommand[key];\n\t                });\n\t            });\n\t\n\t            // Skip tag\n\t            if (parseError) {\n\t                this._clearPath();\n\t                return false;\n\t            }\n\t\n\t            // Handled tag\n\t            return true;\n\t        }\n\t    }, {\n\t        key: '_pathM',\n\t        value: function _pathM(points) {\n\t            // Current point\n\t            var x = this.tag.point.x;\n\t            var y = this.tag.point.y;\n\t            var rl = this.currentCommand.relative;\n\t\n\t            // First point (start of new path)\n\t            var firstPoint = points.splice(0, 2);\n\t\n\t            // New path\n\t            this._newPath();\n\t\n\t            // Relative moveTo (First moveTo is always absolute)\n\t            if (rl && this.tag.paths.length > 1) {\n\t                firstPoint[0] += x;\n\t                firstPoint[1] += y;\n\t            }\n\t\n\t            // Add first point\n\t            var result = this._addPoints(firstPoint, false);\n\t\n\t            // If is followed by multiple pairs of coordinates,\n\t            // the subsequent pairs are treated as implicit lineto commands.\n\t            if (result && points.length) {\n\t                result = this._addPoints(points);\n\t            }\n\t\n\t            // Return result\n\t            return result;\n\t        }\n\t    }, {\n\t        key: '_pathZ',\n\t        value: function _pathZ() {\n\t            this._closePath();\n\t            return true;\n\t        }\n\t    }, {\n\t        key: '_pathL',\n\t        value: function _pathL(points) {\n\t            return this._addPoints(points);\n\t        }\n\t    }, {\n\t        key: '_pathH',\n\t        value: function _pathH(points) {\n\t            var _this5 = this;\n\t\n\t            return points.every(function (x) {\n\t                return _this5._addPoints([x, _this5.currentCommand.relative ? 0 : _this5.tag.point.y]);\n\t            });\n\t        }\n\t    }, {\n\t        key: '_pathV',\n\t        value: function _pathV(points) {\n\t            var _this6 = this;\n\t\n\t            return points.every(function (y) {\n\t                return _this6._addPoints([_this6.currentCommand.relative ? 0 : _this6.tag.point.x, y]);\n\t            });\n\t        }\n\t    }, {\n\t        key: '_pathC',\n\t        value: function _pathC(points) {\n\t            // Multiple paths\n\t            var result = this._paths('C', 6, points);\n\t\n\t            if (result !== null) {\n\t                return result;\n\t            }\n\t\n\t            // Single path\n\t            var p1 = this.tag.point;\n\t            var rl = this.currentCommand.relative;\n\t\n\t            var x1 = points[0] + (rl ? p1.x : 0);\n\t            var y1 = points[1] + (rl ? p1.y : 0);\n\t            var x2 = points[2] + (rl ? p1.x : 0);\n\t            var y2 = points[3] + (rl ? p1.y : 0);\n\t            var x = points[4] + (rl ? p1.x : 0);\n\t            var y = points[5] + (rl ? p1.y : 0);\n\t\n\t            this.pathData.x2 = x2;\n\t            this.pathData.y2 = y2;\n\t\n\t            var p2 = new _lw2.Point(x1, y1);\n\t            var p3 = new _lw2.Point(x2, y2);\n\t            var p4 = new _lw2.Point(x, y);\n\t\n\t            //console.log('C', p1, p2, p3, p4)\n\t\n\t            // p1  : starting point\n\t            // p2  : control point\n\t            // p3  : control point\n\t            // p4  : end point\n\t            var tracer = new _lw.CubicBezier(this.traceSettings);\n\t            var coords = tracer.trace({ p1: p1, p2: p2, p3: p3, p4: p4 }); // => [x,y, x,y, ...]\n\t            // let tracer = trace(CubicBezier, this.traceSettings)\n\t            // let coords = tracer({ p1, p2, p3, p4 })\n\t\n\t            // Trace the line\n\t            return this._addPoints(coords, false);\n\t        }\n\t    }, {\n\t        key: '_pathS',\n\t        value: function _pathS(points) {\n\t            // Multiple paths\n\t            var result = this._paths('S', 4, points);\n\t\n\t            if (result !== null) {\n\t                return result;\n\t            }\n\t\n\t            // Single path\n\t            var p1 = this.tag.point;\n\t            var rl = this.currentCommand.relative;\n\t\n\t            var x1 = p1.x;\n\t            var y1 = p1.y;\n\t\n\t            if (this.lastCommand.type === 'S' || this.lastCommand.type === 'C') {\n\t                x1 -= this.pathData.x2 - x1;\n\t                y1 -= this.pathData.y2 - y1;\n\t            }\n\t\n\t            var x2 = points[0] + (rl ? p1.x : 0);\n\t            var y2 = points[1] + (rl ? p1.y : 0);\n\t            var x = points[2] + (rl ? p1.x : 0);\n\t            var y = points[3] + (rl ? p1.y : 0);\n\t\n\t            this.pathData.x2 = x2;\n\t            this.pathData.y2 = y2;\n\t\n\t            var p2 = new _lw2.Point(x1, y1);\n\t            var p3 = new _lw2.Point(x2, y2);\n\t            var p4 = new _lw2.Point(x, y);\n\t\n\t            //console.log('S', p1, p2, p3, p4)\n\t\n\t            // p1  : starting point\n\t            // p2  : control point\n\t            // p3  : control point\n\t            // p4  : end point\n\t            var tracer = new _lw.CubicBezier(this.traceSettings);\n\t            var coords = tracer.trace({ p1: p1, p2: p2, p3: p3, p4: p4 }); // => [x,y, x,y, ...]\n\t            // let tracer = trace(CubicBezier, this.traceSettings)\n\t            // let coords = tracer({ p1, p2, p3, p4 })\n\t\n\t            // Trace the line\n\t            return this._addPoints(coords, false);\n\t        }\n\t    }, {\n\t        key: '_pathQ',\n\t        value: function _pathQ(points) {\n\t            // Multiple paths\n\t            var result = this._paths('Q', 4, points);\n\t\n\t            if (result !== null) {\n\t                return result;\n\t            }\n\t\n\t            // Single path\n\t            var p1 = this.tag.point;\n\t            var rl = this.currentCommand.relative;\n\t\n\t            var x1 = points[0] + (rl ? p1.x : 0);\n\t            var y1 = points[1] + (rl ? p1.y : 0);\n\t            var x = points[2] + (rl ? p1.x : 0);\n\t            var y = points[3] + (rl ? p1.y : 0);\n\t\n\t            this.pathData.x1 = x1;\n\t            this.pathData.y1 = y1;\n\t\n\t            var p2 = new _lw2.Point(x1, y1);\n\t            var p3 = new _lw2.Point(x, y);\n\t\n\t            //console.log('Q', p1, p2, p3)\n\t\n\t            // p1  : starting point\n\t            // p2  : control point\n\t            // p3  : end point\n\t            var tracer = new _lw.QuadricBezier(this.traceSettings);\n\t            var coords = tracer.trace({ p1: p1, p2: p2, p3: p3 }); // => [x,y, x,y, ...]\n\t\n\t            // Trace the line\n\t            return this._addPoints(coords, false);\n\t        }\n\t    }, {\n\t        key: '_pathT',\n\t        value: function _pathT(points) {\n\t            // Multiple paths\n\t            var result = this._paths('T', 2, points);\n\t\n\t            if (result !== null) {\n\t                return result;\n\t            }\n\t\n\t            // Single path\n\t            var p1 = this.tag.point;\n\t            var rl = this.currentCommand.relative;\n\t\n\t            var x1 = p1.x;\n\t            var y1 = p1.y;\n\t\n\t            if (this.lastCommand.type === 'Q' || this.lastCommand.type === 'T') {\n\t                x1 -= this.pathData.x1 - x1;\n\t                y1 -= this.pathData.y1 - y1;\n\t            }\n\t\n\t            var x = points[0] + (rl ? p1.x : 0);\n\t            var y = points[1] + (rl ? p1.y : 0);\n\t\n\t            this.pathData.x1 = x1;\n\t            this.pathData.y1 = y1;\n\t\n\t            var p2 = new _lw2.Point(x1, y1);\n\t            var p3 = new _lw2.Point(x, y);\n\t\n\t            //console.log('T', p1, p2, p3)\n\t\n\t            // p1  : starting point\n\t            // p2  : control point\n\t            // p3  : end point\n\t            var tracer = new _lw.QuadricBezier(this.traceSettings);\n\t            var coords = tracer.trace({ p1: p1, p2: p2, p3: p3 }); // => [x,y, x,y, ...]\n\t\n\t            // Trace the line\n\t            return this._addPoints(coords, false);\n\t        }\n\t    }, {\n\t        key: '_pathA',\n\t        value: function _pathA(points) {\n\t            // Multiple paths\n\t            var result = this._paths('A', 7, points);\n\t\n\t            if (result !== null) {\n\t                return result;\n\t            }\n\t\n\t            // Single path\n\t            var rl = this.currentCommand.relative;\n\t            var p1 = this.tag.point;\n\t            var rx = points[0];\n\t            var ry = points[1];\n\t            var angle = points[2];\n\t            var large = !!points[3];\n\t            var sweep = !!points[4];\n\t            var x = points[5] + (rl ? p1.x : 0);\n\t            var y = points[6] + (rl ? p1.y : 0);\n\t            var p2 = new _lw2.Point(x, y);\n\t\n\t            //console.log('A', p1, rx, ry, angle, large, sweep, p2)\n\t\n\t            var tracer = new _lw.Arc(this.traceSettings);\n\t            var coords = tracer.trace({ p1: p1, rx: rx, ry: ry, angle: angle, large: large, sweep: sweep, p2: p2 }); // => [x,y, x,y, ...]\n\t\n\t            // Trace the line\n\t            return this._addPoints(coords, false);\n\t        }\n\t    }]);\n\t\n\t    return TagParser;\n\t}();\n\t\n\t// Exports\n\t\n\t\n\texports.TagParser = TagParser;\n\texports.default = TagParser;\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;// rev 482\n\t/********************************************************************************\n\t *                                                                              *\n\t * Author    :  Angus Johnson                                                   *\n\t * Version   :  6.2.1                                                          *\n\t * Date      :  31 October 2014                                                 *\n\t * Website   :  http://www.angusj.com                                           *\n\t * Copyright :  Angus Johnson 2010-2014                                         *\n\t *                                                                              *\n\t * License:                                                                     *\n\t * Use, modification & distribution is subject to Boost Software License Ver 1. *\n\t * http://www.boost.org/LICENSE_1_0.txt                                         *\n\t *                                                                              *\n\t * Attributions:                                                                *\n\t * The code in this library is an extension of Bala Vatti's clipping algorithm: *\n\t * \"A generic solution to polygon clipping\"                                     *\n\t * Communications of the ACM, Vol 35, Issue 7 (July 1992) pp 56-63.             *\n\t * http://portal.acm.org/citation.cfm?id=129906                                 *\n\t *                                                                              *\n\t * Computer graphics and geometric modeling: implementation and algorithms      *\n\t * By Max K. Agoston                                                            *\n\t * Springer; 1 edition (January 4, 2005)                                        *\n\t * http://books.google.com/books?q=vatti+clipping+agoston                       *\n\t *                                                                              *\n\t * See also:                                                                    *\n\t * \"Polygon Offsetting by Computing Winding Numbers\"                            *\n\t * Paper no. DETC2005-85513 pp. 565-575                                         *\n\t * ASME 2005 International Design Engineering Technical Conferences             *\n\t * and Computers and Information in Engineering Conference (IDETC/CIE2005)      *\n\t * September 24-28, 2005 , Long Beach, California, USA                          *\n\t * http://www.me.berkeley.edu/~mcmains/pubs/DAC05OffsetPolygon.pdf              *\n\t *                                                                              *\n\t *******************************************************************************/\n\t/*******************************************************************************\n\t *                                                                              *\n\t * Author    :  Timo                                                            *\n\t * Version   :  6.2.1.0                                                         *\n\t * Date      :  17 June 2016                                                 *\n\t *                                                                              *\n\t * This is a translation of the C# Clipper library to Javascript.               *\n\t * Int128 struct of C# is implemented using JSBN of Tom Wu.                     *\n\t * Because Javascript lacks support for 64-bit integers, the space              *\n\t * is a little more restricted than in C# version.                              *\n\t *                                                                              *\n\t * C# version has support for coordinate space:                                 *\n\t * +-4611686018427387903 ( sqrt(2^127 -1)/2 )                                   *\n\t * while Javascript version has support for space:                              *\n\t * +-4503599627370495 ( sqrt(2^106 -1)/2 )                                      *\n\t *                                                                              *\n\t * Tom Wu's JSBN proved to be the fastest big integer library:                  *\n\t * http://jsperf.com/big-integer-library-test                                   *\n\t *                                                                              *\n\t * This class can be made simpler when (if ever) 64-bit integer support comes.  *\n\t *                                                                              *\n\t *******************************************************************************/\n\t/*******************************************************************************\n\t *                                                                              *\n\t * Basic JavaScript BN library - subset useful for RSA encryption.              *\n\t * http://www-cs-students.stanford.edu/~tjw/jsbn/                               *\n\t * Copyright (c) 2005  Tom Wu                                                   *\n\t * All Rights Reserved.                                                         *\n\t * See \"LICENSE\" for details:                                                   *\n\t * http://www-cs-students.stanford.edu/~tjw/jsbn/LICENSE                        *\n\t *                                                                              *\n\t *******************************************************************************/\n\t(function ()\n\t{\n\t  \"use strict\";\n\t  //use_int32: When enabled 32bit ints are used instead of 64bit ints. This\n\t  //improve performance but coordinate values are limited to the range +/- 46340\n\t  var use_int32 = false;\n\t  //use_xyz: adds a Z member to IntPoint. Adds a minor cost to performance.\n\t  var use_xyz = false;\n\t  //UseLines: Enables open path clipping. Adds a very minor cost to performance.\n\t  var use_lines = true;\n\t\n\t  var ClipperLib = {};\n\t  var isNode = false;\n\t  if (typeof module !== 'undefined' && module.exports)\n\t  {\n\t    module.exports = ClipperLib;\n\t    isNode = true;\n\t  }\n\t  else\n\t  {\n\t    if (true) {\n\t      !(__WEBPACK_AMD_DEFINE_FACTORY__ = (ClipperLib), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t    if (typeof (document) !== \"undefined\") window.ClipperLib = ClipperLib;\n\t    else self['ClipperLib'] = ClipperLib;\n\t  }\n\t  var navigator_appName;\n\t  if (!isNode)\n\t  {\n\t    var nav = navigator.userAgent.toString().toLowerCase();\n\t    navigator_appName = navigator.appName;\n\t  }\n\t  else\n\t  {\n\t    var nav = \"chrome\"; // Node.js uses Chrome's V8 engine\n\t    navigator_appName = \"Netscape\"; // Firefox, Chrome and Safari returns \"Netscape\", so Node.js should also\n\t  }\n\t  // Browser test to speedup performance critical functions\n\t  var browser = {};\n\t  if (nav.indexOf(\"chrome\") != -1 && nav.indexOf(\"chromium\") == -1) browser.chrome = 1;\n\t  else browser.chrome = 0;\n\t  if (nav.indexOf(\"chromium\") != -1) browser.chromium = 1;\n\t  else browser.chromium = 0;\n\t  if (nav.indexOf(\"safari\") != -1 && nav.indexOf(\"chrome\") == -1 && nav.indexOf(\"chromium\") == -1) browser.safari = 1;\n\t  else browser.safari = 0;\n\t  if (nav.indexOf(\"firefox\") != -1) browser.firefox = 1;\n\t  else browser.firefox = 0;\n\t  if (nav.indexOf(\"firefox/17\") != -1) browser.firefox17 = 1;\n\t  else browser.firefox17 = 0;\n\t  if (nav.indexOf(\"firefox/15\") != -1) browser.firefox15 = 1;\n\t  else browser.firefox15 = 0;\n\t  if (nav.indexOf(\"firefox/3\") != -1) browser.firefox3 = 1;\n\t  else browser.firefox3 = 0;\n\t  if (nav.indexOf(\"opera\") != -1) browser.opera = 1;\n\t  else browser.opera = 0;\n\t  if (nav.indexOf(\"msie 10\") != -1) browser.msie10 = 1;\n\t  else browser.msie10 = 0;\n\t  if (nav.indexOf(\"msie 9\") != -1) browser.msie9 = 1;\n\t  else browser.msie9 = 0;\n\t  if (nav.indexOf(\"msie 8\") != -1) browser.msie8 = 1;\n\t  else browser.msie8 = 0;\n\t  if (nav.indexOf(\"msie 7\") != -1) browser.msie7 = 1;\n\t  else browser.msie7 = 0;\n\t  if (nav.indexOf(\"msie \") != -1) browser.msie = 1;\n\t  else browser.msie = 0;\n\t  ClipperLib.biginteger_used = null;\n\t\n\t  // Copyright (c) 2005  Tom Wu\n\t  // All Rights Reserved.\n\t  // See \"LICENSE\" for details.\n\t  // Basic JavaScript BN library - subset useful for RSA encryption.\n\t  // Bits per digit\n\t  var dbits;\n\t  // JavaScript engine analysis\n\t  var canary = 0xdeadbeefcafe;\n\t  var j_lm = ((canary & 0xffffff) == 0xefcafe);\n\t  // (public) Constructor\n\t  function BigInteger(a, b, c)\n\t  {\n\t    // This test variable can be removed,\n\t    // but at least for performance tests it is useful piece of knowledge\n\t    // This is the only ClipperLib related variable in BigInteger library\n\t    ClipperLib.biginteger_used = 1;\n\t    if (a != null)\n\t      if (\"number\" == typeof a && \"undefined\" == typeof (b)) this.fromInt(a); // faster conversion\n\t      else if (\"number\" == typeof a) this.fromNumber(a, b, c);\n\t    else if (b == null && \"string\" != typeof a) this.fromString(a, 256);\n\t    else this.fromString(a, b);\n\t  }\n\t  // return new, unset BigInteger\n\t  function nbi()\n\t  {\n\t    return new BigInteger(null,undefined,undefined);\n\t  }\n\t  // am: Compute w_j += (x*this_i), propagate carries,\n\t  // c is initial carry, returns final carry.\n\t  // c < 3*dvalue, x < 2*dvalue, this_i < dvalue\n\t  // We need to select the fastest one that works in this environment.\n\t  // am1: use a single mult and divide to get the high bits,\n\t  // max digit bits should be 26 because\n\t  // max internal value = 2*dvalue^2-2*dvalue (< 2^53)\n\t  function am1(i, x, w, j, c, n)\n\t  {\n\t    while (--n >= 0)\n\t    {\n\t      var v = x * this[i++] + w[j] + c;\n\t      c = Math.floor(v / 0x4000000);\n\t      w[j++] = v & 0x3ffffff;\n\t    }\n\t    return c;\n\t  }\n\t  // am2 avoids a big mult-and-extract completely.\n\t  // Max digit bits should be <= 30 because we do bitwise ops\n\t  // on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)\n\t  function am2(i, x, w, j, c, n)\n\t  {\n\t    var xl = x & 0x7fff,\n\t      xh = x >> 15;\n\t    while (--n >= 0)\n\t    {\n\t      var l = this[i] & 0x7fff;\n\t      var h = this[i++] >> 15;\n\t      var m = xh * l + h * xl;\n\t      l = xl * l + ((m & 0x7fff) << 15) + w[j] + (c & 0x3fffffff);\n\t      c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);\n\t      w[j++] = l & 0x3fffffff;\n\t    }\n\t    return c;\n\t  }\n\t  // Alternately, set max digit bits to 28 since some\n\t  // browsers slow down when dealing with 32-bit numbers.\n\t  function am3(i, x, w, j, c, n)\n\t  {\n\t    var xl = x & 0x3fff,\n\t      xh = x >> 14;\n\t    while (--n >= 0)\n\t    {\n\t      var l = this[i] & 0x3fff;\n\t      var h = this[i++] >> 14;\n\t      var m = xh * l + h * xl;\n\t      l = xl * l + ((m & 0x3fff) << 14) + w[j] + c;\n\t      c = (l >> 28) + (m >> 14) + xh * h;\n\t      w[j++] = l & 0xfffffff;\n\t    }\n\t    return c;\n\t  }\n\t  if (j_lm && (navigator_appName == \"Microsoft Internet Explorer\"))\n\t  {\n\t    BigInteger.prototype.am = am2;\n\t    dbits = 30;\n\t  }\n\t  else if (j_lm && (navigator_appName != \"Netscape\"))\n\t  {\n\t    BigInteger.prototype.am = am1;\n\t    dbits = 26;\n\t  }\n\t  else\n\t  { // Mozilla/Netscape seems to prefer am3\n\t    BigInteger.prototype.am = am3;\n\t    dbits = 28;\n\t  }\n\t  BigInteger.prototype.DB = dbits;\n\t  BigInteger.prototype.DM = ((1 << dbits) - 1);\n\t  BigInteger.prototype.DV = (1 << dbits);\n\t  var BI_FP = 52;\n\t  BigInteger.prototype.FV = Math.pow(2, BI_FP);\n\t  BigInteger.prototype.F1 = BI_FP - dbits;\n\t  BigInteger.prototype.F2 = 2 * dbits - BI_FP;\n\t  // Digit conversions\n\t  var BI_RM = \"0123456789abcdefghijklmnopqrstuvwxyz\";\n\t  var BI_RC = new Array();\n\t  var rr, vv;\n\t  rr = \"0\".charCodeAt(0);\n\t  for (vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;\n\t  rr = \"a\".charCodeAt(0);\n\t  for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\n\t  rr = \"A\".charCodeAt(0);\n\t  for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\n\t\n\t  function int2char(n)\n\t  {\n\t    return BI_RM.charAt(n);\n\t  }\n\t\n\t  function intAt(s, i)\n\t  {\n\t    var c = BI_RC[s.charCodeAt(i)];\n\t    return (c == null) ? -1 : c;\n\t  }\n\t  // (protected) copy this to r\n\t  function bnpCopyTo(r)\n\t  {\n\t    for (var i = this.t - 1; i >= 0; --i) r[i] = this[i];\n\t    r.t = this.t;\n\t    r.s = this.s;\n\t  }\n\t  // (protected) set from integer value x, -DV <= x < DV\n\t  function bnpFromInt(x)\n\t  {\n\t    this.t = 1;\n\t    this.s = (x < 0) ? -1 : 0;\n\t    if (x > 0) this[0] = x;\n\t    else if (x < -1) this[0] = x + this.DV;\n\t    else this.t = 0;\n\t  }\n\t  // return bigint initialized to value\n\t  function nbv(i)\n\t  {\n\t    var r = nbi();\n\t    r.fromInt(i);\n\t    return r;\n\t  }\n\t  // (protected) set from string and radix\n\t  function bnpFromString(s, b)\n\t  {\n\t    var k;\n\t    if (b == 16) k = 4;\n\t    else if (b == 8) k = 3;\n\t    else if (b == 256) k = 8; // byte array\n\t    else if (b == 2) k = 1;\n\t    else if (b == 32) k = 5;\n\t    else if (b == 4) k = 2;\n\t    else\n\t    {\n\t      this.fromRadix(s, b);\n\t      return;\n\t    }\n\t    this.t = 0;\n\t    this.s = 0;\n\t    var i = s.length,\n\t      mi = false,\n\t      sh = 0;\n\t    while (--i >= 0)\n\t    {\n\t      var x = (k == 8) ? s[i] & 0xff : intAt(s, i);\n\t      if (x < 0)\n\t      {\n\t        if (s.charAt(i) == \"-\") mi = true;\n\t        continue;\n\t      }\n\t      mi = false;\n\t      if (sh == 0)\n\t        this[this.t++] = x;\n\t      else if (sh + k > this.DB)\n\t      {\n\t        this[this.t - 1] |= (x & ((1 << (this.DB - sh)) - 1)) << sh;\n\t        this[this.t++] = (x >> (this.DB - sh));\n\t      }\n\t      else\n\t        this[this.t - 1] |= x << sh;\n\t      sh += k;\n\t      if (sh >= this.DB) sh -= this.DB;\n\t    }\n\t    if (k == 8 && (s[0] & 0x80) != 0)\n\t    {\n\t      this.s = -1;\n\t      if (sh > 0) this[this.t - 1] |= ((1 << (this.DB - sh)) - 1) << sh;\n\t    }\n\t    this.clamp();\n\t    if (mi) BigInteger.ZERO.subTo(this, this);\n\t  }\n\t  // (protected) clamp off excess high words\n\t  function bnpClamp()\n\t  {\n\t    var c = this.s & this.DM;\n\t    while (this.t > 0 && this[this.t - 1] == c)--this.t;\n\t  }\n\t  // (public) return string representation in given radix\n\t  function bnToString(b)\n\t  {\n\t    if (this.s < 0) return \"-\" + this.negate().toString(b);\n\t    var k;\n\t    if (b == 16) k = 4;\n\t    else if (b == 8) k = 3;\n\t    else if (b == 2) k = 1;\n\t    else if (b == 32) k = 5;\n\t    else if (b == 4) k = 2;\n\t    else return this.toRadix(b);\n\t    var km = (1 << k) - 1,\n\t      d, m = false,\n\t      r = \"\",\n\t      i = this.t;\n\t    var p = this.DB - (i * this.DB) % k;\n\t    if (i-- > 0)\n\t    {\n\t      if (p < this.DB && (d = this[i] >> p) > 0)\n\t      {\n\t        m = true;\n\t        r = int2char(d);\n\t      }\n\t      while (i >= 0)\n\t      {\n\t        if (p < k)\n\t        {\n\t          d = (this[i] & ((1 << p) - 1)) << (k - p);\n\t          d |= this[--i] >> (p += this.DB - k);\n\t        }\n\t        else\n\t        {\n\t          d = (this[i] >> (p -= k)) & km;\n\t          if (p <= 0)\n\t          {\n\t            p += this.DB;\n\t            --i;\n\t          }\n\t        }\n\t        if (d > 0) m = true;\n\t        if (m) r += int2char(d);\n\t      }\n\t    }\n\t    return m ? r : \"0\";\n\t  }\n\t  // (public) -this\n\t  function bnNegate()\n\t  {\n\t    var r = nbi();\n\t    BigInteger.ZERO.subTo(this, r);\n\t    return r;\n\t  }\n\t  // (public) |this|\n\t  function bnAbs()\n\t  {\n\t    return (this.s < 0) ? this.negate() : this;\n\t  }\n\t  // (public) return + if this > a, - if this < a, 0 if equal\n\t  function bnCompareTo(a)\n\t  {\n\t    var r = this.s - a.s;\n\t    if (r != 0) return r;\n\t    var i = this.t;\n\t    r = i - a.t;\n\t    if (r != 0) return (this.s < 0) ? -r : r;\n\t    while (--i >= 0)\n\t      if ((r = this[i] - a[i]) != 0) return r;\n\t    return 0;\n\t  }\n\t  // returns bit length of the integer x\n\t  function nbits(x)\n\t  {\n\t    var r = 1,\n\t      t;\n\t    if ((t = x >>> 16) != 0)\n\t    {\n\t      x = t;\n\t      r += 16;\n\t    }\n\t    if ((t = x >> 8) != 0)\n\t    {\n\t      x = t;\n\t      r += 8;\n\t    }\n\t    if ((t = x >> 4) != 0)\n\t    {\n\t      x = t;\n\t      r += 4;\n\t    }\n\t    if ((t = x >> 2) != 0)\n\t    {\n\t      x = t;\n\t      r += 2;\n\t    }\n\t    if ((t = x >> 1) != 0)\n\t    {\n\t      x = t;\n\t      r += 1;\n\t    }\n\t    return r;\n\t  }\n\t  // (public) return the number of bits in \"this\"\n\t  function bnBitLength()\n\t  {\n\t    if (this.t <= 0) return 0;\n\t    return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ (this.s & this.DM));\n\t  }\n\t  // (protected) r = this << n*DB\n\t  function bnpDLShiftTo(n, r)\n\t  {\n\t    var i;\n\t    for (i = this.t - 1; i >= 0; --i) r[i + n] = this[i];\n\t    for (i = n - 1; i >= 0; --i) r[i] = 0;\n\t    r.t = this.t + n;\n\t    r.s = this.s;\n\t  }\n\t  // (protected) r = this >> n*DB\n\t  function bnpDRShiftTo(n, r)\n\t  {\n\t    for (var i = n; i < this.t; ++i) r[i - n] = this[i];\n\t    r.t = Math.max(this.t - n, 0);\n\t    r.s = this.s;\n\t  }\n\t  // (protected) r = this << n\n\t  function bnpLShiftTo(n, r)\n\t  {\n\t    var bs = n % this.DB;\n\t    var cbs = this.DB - bs;\n\t    var bm = (1 << cbs) - 1;\n\t    var ds = Math.floor(n / this.DB),\n\t      c = (this.s << bs) & this.DM,\n\t      i;\n\t    for (i = this.t - 1; i >= 0; --i)\n\t    {\n\t      r[i + ds + 1] = (this[i] >> cbs) | c;\n\t      c = (this[i] & bm) << bs;\n\t    }\n\t    for (i = ds - 1; i >= 0; --i) r[i] = 0;\n\t    r[ds] = c;\n\t    r.t = this.t + ds + 1;\n\t    r.s = this.s;\n\t    r.clamp();\n\t  }\n\t  // (protected) r = this >> n\n\t  function bnpRShiftTo(n, r)\n\t  {\n\t    r.s = this.s;\n\t    var ds = Math.floor(n / this.DB);\n\t    if (ds >= this.t)\n\t    {\n\t      r.t = 0;\n\t      return;\n\t    }\n\t    var bs = n % this.DB;\n\t    var cbs = this.DB - bs;\n\t    var bm = (1 << bs) - 1;\n\t    r[0] = this[ds] >> bs;\n\t    for (var i = ds + 1; i < this.t; ++i)\n\t    {\n\t      r[i - ds - 1] |= (this[i] & bm) << cbs;\n\t      r[i - ds] = this[i] >> bs;\n\t    }\n\t    if (bs > 0) r[this.t - ds - 1] |= (this.s & bm) << cbs;\n\t    r.t = this.t - ds;\n\t    r.clamp();\n\t  }\n\t  // (protected) r = this - a\n\t  function bnpSubTo(a, r)\n\t  {\n\t    var i = 0,\n\t      c = 0,\n\t      m = Math.min(a.t, this.t);\n\t    while (i < m)\n\t    {\n\t      c += this[i] - a[i];\n\t      r[i++] = c & this.DM;\n\t      c >>= this.DB;\n\t    }\n\t    if (a.t < this.t)\n\t    {\n\t      c -= a.s;\n\t      while (i < this.t)\n\t      {\n\t        c += this[i];\n\t        r[i++] = c & this.DM;\n\t        c >>= this.DB;\n\t      }\n\t      c += this.s;\n\t    }\n\t    else\n\t    {\n\t      c += this.s;\n\t      while (i < a.t)\n\t      {\n\t        c -= a[i];\n\t        r[i++] = c & this.DM;\n\t        c >>= this.DB;\n\t      }\n\t      c -= a.s;\n\t    }\n\t    r.s = (c < 0) ? -1 : 0;\n\t    if (c < -1) r[i++] = this.DV + c;\n\t    else if (c > 0) r[i++] = c;\n\t    r.t = i;\n\t    r.clamp();\n\t  }\n\t  // (protected) r = this * a, r != this,a (HAC 14.12)\n\t  // \"this\" should be the larger one if appropriate.\n\t  function bnpMultiplyTo(a, r)\n\t  {\n\t    var x = this.abs(),\n\t      y = a.abs();\n\t    var i = x.t;\n\t    r.t = i + y.t;\n\t    while (--i >= 0) r[i] = 0;\n\t    for (i = 0; i < y.t; ++i) r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);\n\t    r.s = 0;\n\t    r.clamp();\n\t    if (this.s != a.s) BigInteger.ZERO.subTo(r, r);\n\t  }\n\t  // (protected) r = this^2, r != this (HAC 14.16)\n\t  function bnpSquareTo(r)\n\t  {\n\t    var x = this.abs();\n\t    var i = r.t = 2 * x.t;\n\t    while (--i >= 0) r[i] = 0;\n\t    for (i = 0; i < x.t - 1; ++i)\n\t    {\n\t      var c = x.am(i, x[i], r, 2 * i, 0, 1);\n\t      if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV)\n\t      {\n\t        r[i + x.t] -= x.DV;\n\t        r[i + x.t + 1] = 1;\n\t      }\n\t    }\n\t    if (r.t > 0) r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);\n\t    r.s = 0;\n\t    r.clamp();\n\t  }\n\t  // (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)\n\t  // r != q, this != m.  q or r may be null.\n\t  function bnpDivRemTo(m, q, r)\n\t  {\n\t    var pm = m.abs();\n\t    if (pm.t <= 0) return;\n\t    var pt = this.abs();\n\t    if (pt.t < pm.t)\n\t    {\n\t      if (q != null) q.fromInt(0);\n\t      if (r != null) this.copyTo(r);\n\t      return;\n\t    }\n\t    if (r == null) r = nbi();\n\t    var y = nbi(),\n\t      ts = this.s,\n\t      ms = m.s;\n\t    var nsh = this.DB - nbits(pm[pm.t - 1]); // normalize modulus\n\t    if (nsh > 0)\n\t    {\n\t      pm.lShiftTo(nsh, y);\n\t      pt.lShiftTo(nsh, r);\n\t    }\n\t    else\n\t    {\n\t      pm.copyTo(y);\n\t      pt.copyTo(r);\n\t    }\n\t    var ys = y.t;\n\t    var y0 = y[ys - 1];\n\t    if (y0 == 0) return;\n\t    var yt = y0 * (1 << this.F1) + ((ys > 1) ? y[ys - 2] >> this.F2 : 0);\n\t    var d1 = this.FV / yt,\n\t      d2 = (1 << this.F1) / yt,\n\t      e = 1 << this.F2;\n\t    var i = r.t,\n\t      j = i - ys,\n\t      t = (q == null) ? nbi() : q;\n\t    y.dlShiftTo(j, t);\n\t    if (r.compareTo(t) >= 0)\n\t    {\n\t      r[r.t++] = 1;\n\t      r.subTo(t, r);\n\t    }\n\t    BigInteger.ONE.dlShiftTo(ys, t);\n\t    t.subTo(y, y); // \"negative\" y so we can replace sub with am later\n\t    while (y.t < ys) y[y.t++] = 0;\n\t    while (--j >= 0)\n\t    {\n\t      // Estimate quotient digit\n\t      var qd = (r[--i] == y0) ? this.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);\n\t      if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd)\n\t      { // Try it out\n\t        y.dlShiftTo(j, t);\n\t        r.subTo(t, r);\n\t        while (r[i] < --qd) r.subTo(t, r);\n\t      }\n\t    }\n\t    if (q != null)\n\t    {\n\t      r.drShiftTo(ys, q);\n\t      if (ts != ms) BigInteger.ZERO.subTo(q, q);\n\t    }\n\t    r.t = ys;\n\t    r.clamp();\n\t    if (nsh > 0) r.rShiftTo(nsh, r); // Denormalize remainder\n\t    if (ts < 0) BigInteger.ZERO.subTo(r, r);\n\t  }\n\t  // (public) this mod a\n\t  function bnMod(a)\n\t  {\n\t    var r = nbi();\n\t    this.abs().divRemTo(a, null, r);\n\t    if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r, r);\n\t    return r;\n\t  }\n\t  // Modular reduction using \"classic\" algorithm\n\t  function Classic(m)\n\t  {\n\t    this.m = m;\n\t  }\n\t\n\t  function cConvert(x)\n\t  {\n\t    if (x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);\n\t    else return x;\n\t  }\n\t\n\t  function cRevert(x)\n\t  {\n\t    return x;\n\t  }\n\t\n\t  function cReduce(x)\n\t  {\n\t    x.divRemTo(this.m, null, x);\n\t  }\n\t\n\t  function cMulTo(x, y, r)\n\t  {\n\t    x.multiplyTo(y, r);\n\t    this.reduce(r);\n\t  }\n\t\n\t  function cSqrTo(x, r)\n\t  {\n\t    x.squareTo(r);\n\t    this.reduce(r);\n\t  }\n\t  Classic.prototype.convert = cConvert;\n\t  Classic.prototype.revert = cRevert;\n\t  Classic.prototype.reduce = cReduce;\n\t  Classic.prototype.mulTo = cMulTo;\n\t  Classic.prototype.sqrTo = cSqrTo;\n\t  // (protected) return \"-1/this % 2^DB\"; useful for Mont. reduction\n\t  // justification:\n\t  //         xy == 1 (mod m)\n\t  //         xy =  1+km\n\t  //   xy(2-xy) = (1+km)(1-km)\n\t  // x[y(2-xy)] = 1-k^2m^2\n\t  // x[y(2-xy)] == 1 (mod m^2)\n\t  // if y is 1/x mod m, then y(2-xy) is 1/x mod m^2\n\t  // should reduce x and y(2-xy) by m^2 at each step to keep size bounded.\n\t  // JS multiply \"overflows\" differently from C/C++, so care is needed here.\n\t  function bnpInvDigit()\n\t  {\n\t    if (this.t < 1) return 0;\n\t    var x = this[0];\n\t    if ((x & 1) == 0) return 0;\n\t    var y = x & 3; // y == 1/x mod 2^2\n\t    y = (y * (2 - (x & 0xf) * y)) & 0xf; // y == 1/x mod 2^4\n\t    y = (y * (2 - (x & 0xff) * y)) & 0xff; // y == 1/x mod 2^8\n\t    y = (y * (2 - (((x & 0xffff) * y) & 0xffff))) & 0xffff; // y == 1/x mod 2^16\n\t    // last step - calculate inverse mod DV directly;\n\t    // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints\n\t    y = (y * (2 - x * y % this.DV)) % this.DV; // y == 1/x mod 2^dbits\n\t    // we really want the negative inverse, and -DV < y < DV\n\t    return (y > 0) ? this.DV - y : -y;\n\t  }\n\t  // Montgomery reduction\n\t  function Montgomery(m)\n\t  {\n\t    this.m = m;\n\t    this.mp = m.invDigit();\n\t    this.mpl = this.mp & 0x7fff;\n\t    this.mph = this.mp >> 15;\n\t    this.um = (1 << (m.DB - 15)) - 1;\n\t    this.mt2 = 2 * m.t;\n\t  }\n\t  // xR mod m\n\t  function montConvert(x)\n\t  {\n\t    var r = nbi();\n\t    x.abs().dlShiftTo(this.m.t, r);\n\t    r.divRemTo(this.m, null, r);\n\t    if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r, r);\n\t    return r;\n\t  }\n\t  // x/R mod m\n\t  function montRevert(x)\n\t  {\n\t    var r = nbi();\n\t    x.copyTo(r);\n\t    this.reduce(r);\n\t    return r;\n\t  }\n\t  // x = x/R mod m (HAC 14.32)\n\t  function montReduce(x)\n\t  {\n\t    while (x.t <= this.mt2) // pad x so am has enough room later\n\t      x[x.t++] = 0;\n\t    for (var i = 0; i < this.m.t; ++i)\n\t    {\n\t      // faster way of calculating u0 = x[i]*mp mod DV\n\t      var j = x[i] & 0x7fff;\n\t      var u0 = (j * this.mpl + (((j * this.mph + (x[i] >> 15) * this.mpl) & this.um) << 15)) & x.DM;\n\t      // use am to combine the multiply-shift-add into one call\n\t      j = i + this.m.t;\n\t      x[j] += this.m.am(0, u0, x, i, 0, this.m.t);\n\t      // propagate carry\n\t      while (x[j] >= x.DV)\n\t      {\n\t        x[j] -= x.DV;\n\t        x[++j]++;\n\t      }\n\t    }\n\t    x.clamp();\n\t    x.drShiftTo(this.m.t, x);\n\t    if (x.compareTo(this.m) >= 0) x.subTo(this.m, x);\n\t  }\n\t  // r = \"x^2/R mod m\"; x != r\n\t  function montSqrTo(x, r)\n\t  {\n\t    x.squareTo(r);\n\t    this.reduce(r);\n\t  }\n\t  // r = \"xy/R mod m\"; x,y != r\n\t  function montMulTo(x, y, r)\n\t  {\n\t    x.multiplyTo(y, r);\n\t    this.reduce(r);\n\t  }\n\t  Montgomery.prototype.convert = montConvert;\n\t  Montgomery.prototype.revert = montRevert;\n\t  Montgomery.prototype.reduce = montReduce;\n\t  Montgomery.prototype.mulTo = montMulTo;\n\t  Montgomery.prototype.sqrTo = montSqrTo;\n\t  // (protected) true iff this is even\n\t  function bnpIsEven()\n\t  {\n\t    return ((this.t > 0) ? (this[0] & 1) : this.s) == 0;\n\t  }\n\t  // (protected) this^e, e < 2^32, doing sqr and mul with \"r\" (HAC 14.79)\n\t  function bnpExp(e, z)\n\t  {\n\t    if (e > 0xffffffff || e < 1) return BigInteger.ONE;\n\t    var r = nbi(),\n\t      r2 = nbi(),\n\t      g = z.convert(this),\n\t      i = nbits(e) - 1;\n\t    g.copyTo(r);\n\t    while (--i >= 0)\n\t    {\n\t      z.sqrTo(r, r2);\n\t      if ((e & (1 << i)) > 0) z.mulTo(r2, g, r);\n\t      else\n\t      {\n\t        var t = r;\n\t        r = r2;\n\t        r2 = t;\n\t      }\n\t    }\n\t    return z.revert(r);\n\t  }\n\t  // (public) this^e % m, 0 <= e < 2^32\n\t  function bnModPowInt(e, m)\n\t  {\n\t    var z;\n\t    if (e < 256 || m.isEven()) z = new Classic(m);\n\t    else z = new Montgomery(m);\n\t    return this.exp(e, z);\n\t  }\n\t  // protected\n\t  BigInteger.prototype.copyTo = bnpCopyTo;\n\t  BigInteger.prototype.fromInt = bnpFromInt;\n\t  BigInteger.prototype.fromString = bnpFromString;\n\t  BigInteger.prototype.clamp = bnpClamp;\n\t  BigInteger.prototype.dlShiftTo = bnpDLShiftTo;\n\t  BigInteger.prototype.drShiftTo = bnpDRShiftTo;\n\t  BigInteger.prototype.lShiftTo = bnpLShiftTo;\n\t  BigInteger.prototype.rShiftTo = bnpRShiftTo;\n\t  BigInteger.prototype.subTo = bnpSubTo;\n\t  BigInteger.prototype.multiplyTo = bnpMultiplyTo;\n\t  BigInteger.prototype.squareTo = bnpSquareTo;\n\t  BigInteger.prototype.divRemTo = bnpDivRemTo;\n\t  BigInteger.prototype.invDigit = bnpInvDigit;\n\t  BigInteger.prototype.isEven = bnpIsEven;\n\t  BigInteger.prototype.exp = bnpExp;\n\t  // public\n\t  BigInteger.prototype.toString = bnToString;\n\t  BigInteger.prototype.negate = bnNegate;\n\t  BigInteger.prototype.abs = bnAbs;\n\t  BigInteger.prototype.compareTo = bnCompareTo;\n\t  BigInteger.prototype.bitLength = bnBitLength;\n\t  BigInteger.prototype.mod = bnMod;\n\t  BigInteger.prototype.modPowInt = bnModPowInt;\n\t  // \"constants\"\n\t  BigInteger.ZERO = nbv(0);\n\t  BigInteger.ONE = nbv(1);\n\t  // Copyright (c) 2005-2009  Tom Wu\n\t  // All Rights Reserved.\n\t  // See \"LICENSE\" for details.\n\t  // Extended JavaScript BN functions, required for RSA private ops.\n\t  // Version 1.1: new BigInteger(\"0\", 10) returns \"proper\" zero\n\t  // Version 1.2: square() API, isProbablePrime fix\n\t  // (public)\n\t  function bnClone()\n\t  {\n\t    var r = nbi();\n\t    this.copyTo(r);\n\t    return r;\n\t  }\n\t  // (public) return value as integer\n\t  function bnIntValue()\n\t  {\n\t    if (this.s < 0)\n\t    {\n\t      if (this.t == 1) return this[0] - this.DV;\n\t      else if (this.t == 0) return -1;\n\t    }\n\t    else if (this.t == 1) return this[0];\n\t    else if (this.t == 0) return 0;\n\t    // assumes 16 < DB < 32\n\t    return ((this[1] & ((1 << (32 - this.DB)) - 1)) << this.DB) | this[0];\n\t  }\n\t  // (public) return value as byte\n\t  function bnByteValue()\n\t  {\n\t    return (this.t == 0) ? this.s : (this[0] << 24) >> 24;\n\t  }\n\t  // (public) return value as short (assumes DB>=16)\n\t  function bnShortValue()\n\t  {\n\t    return (this.t == 0) ? this.s : (this[0] << 16) >> 16;\n\t  }\n\t  // (protected) return x s.t. r^x < DV\n\t  function bnpChunkSize(r)\n\t  {\n\t    return Math.floor(Math.LN2 * this.DB / Math.log(r));\n\t  }\n\t  // (public) 0 if this == 0, 1 if this > 0\n\t  function bnSigNum()\n\t  {\n\t    if (this.s < 0) return -1;\n\t    else if (this.t <= 0 || (this.t == 1 && this[0] <= 0)) return 0;\n\t    else return 1;\n\t  }\n\t  // (protected) convert to radix string\n\t  function bnpToRadix(b)\n\t  {\n\t    if (b == null) b = 10;\n\t    if (this.signum() == 0 || b < 2 || b > 36) return \"0\";\n\t    var cs = this.chunkSize(b);\n\t    var a = Math.pow(b, cs);\n\t    var d = nbv(a),\n\t      y = nbi(),\n\t      z = nbi(),\n\t      r = \"\";\n\t    this.divRemTo(d, y, z);\n\t    while (y.signum() > 0)\n\t    {\n\t      r = (a + z.intValue()).toString(b).substr(1) + r;\n\t      y.divRemTo(d, y, z);\n\t    }\n\t    return z.intValue().toString(b) + r;\n\t  }\n\t  // (protected) convert from radix string\n\t  function bnpFromRadix(s, b)\n\t  {\n\t    this.fromInt(0);\n\t    if (b == null) b = 10;\n\t    var cs = this.chunkSize(b);\n\t    var d = Math.pow(b, cs),\n\t      mi = false,\n\t      j = 0,\n\t      w = 0;\n\t    for (var i = 0; i < s.length; ++i)\n\t    {\n\t      var x = intAt(s, i);\n\t      if (x < 0)\n\t      {\n\t        if (s.charAt(i) == \"-\" && this.signum() == 0) mi = true;\n\t        continue;\n\t      }\n\t      w = b * w + x;\n\t      if (++j >= cs)\n\t      {\n\t        this.dMultiply(d);\n\t        this.dAddOffset(w, 0);\n\t        j = 0;\n\t        w = 0;\n\t      }\n\t    }\n\t    if (j > 0)\n\t    {\n\t      this.dMultiply(Math.pow(b, j));\n\t      this.dAddOffset(w, 0);\n\t    }\n\t    if (mi) BigInteger.ZERO.subTo(this, this);\n\t  }\n\t  // (protected) alternate constructor\n\t  function bnpFromNumber(a, b, c)\n\t  {\n\t    if (\"number\" == typeof b)\n\t    {\n\t      // new BigInteger(int,int,RNG)\n\t      if (a < 2) this.fromInt(1);\n\t      else\n\t      {\n\t        this.fromNumber(a, c);\n\t        if (!this.testBit(a - 1)) // force MSB set\n\t          this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);\n\t        if (this.isEven()) this.dAddOffset(1, 0); // force odd\n\t        while (!this.isProbablePrime(b))\n\t        {\n\t          this.dAddOffset(2, 0);\n\t          if (this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);\n\t        }\n\t      }\n\t    }\n\t    else\n\t    {\n\t      // new BigInteger(int,RNG)\n\t      var x = new Array(),\n\t        t = a & 7;\n\t      x.length = (a >> 3) + 1;\n\t      b.nextBytes(x);\n\t      if (t > 0) x[0] &= ((1 << t) - 1);\n\t      else x[0] = 0;\n\t      this.fromString(x, 256);\n\t    }\n\t  }\n\t  // (public) convert to bigendian byte array\n\t  function bnToByteArray()\n\t  {\n\t    var i = this.t,\n\t      r = new Array();\n\t    r[0] = this.s;\n\t    var p = this.DB - (i * this.DB) % 8,\n\t      d, k = 0;\n\t    if (i-- > 0)\n\t    {\n\t      if (p < this.DB && (d = this[i] >> p) != (this.s & this.DM) >> p)\n\t        r[k++] = d | (this.s << (this.DB - p));\n\t      while (i >= 0)\n\t      {\n\t        if (p < 8)\n\t        {\n\t          d = (this[i] & ((1 << p) - 1)) << (8 - p);\n\t          d |= this[--i] >> (p += this.DB - 8);\n\t        }\n\t        else\n\t        {\n\t          d = (this[i] >> (p -= 8)) & 0xff;\n\t          if (p <= 0)\n\t          {\n\t            p += this.DB;\n\t            --i;\n\t          }\n\t        }\n\t        if ((d & 0x80) != 0) d |= -256;\n\t        if (k == 0 && (this.s & 0x80) != (d & 0x80))++k;\n\t        if (k > 0 || d != this.s) r[k++] = d;\n\t      }\n\t    }\n\t    return r;\n\t  }\n\t\n\t  function bnEquals(a)\n\t  {\n\t    return (this.compareTo(a) == 0);\n\t  }\n\t\n\t  function bnMin(a)\n\t  {\n\t    return (this.compareTo(a) < 0) ? this : a;\n\t  }\n\t\n\t  function bnMax(a)\n\t  {\n\t    return (this.compareTo(a) > 0) ? this : a;\n\t  }\n\t  // (protected) r = this op a (bitwise)\n\t  function bnpBitwiseTo(a, op, r)\n\t  {\n\t    var i, f, m = Math.min(a.t, this.t);\n\t    for (i = 0; i < m; ++i) r[i] = op(this[i], a[i]);\n\t    if (a.t < this.t)\n\t    {\n\t      f = a.s & this.DM;\n\t      for (i = m; i < this.t; ++i) r[i] = op(this[i], f);\n\t      r.t = this.t;\n\t    }\n\t    else\n\t    {\n\t      f = this.s & this.DM;\n\t      for (i = m; i < a.t; ++i) r[i] = op(f, a[i]);\n\t      r.t = a.t;\n\t    }\n\t    r.s = op(this.s, a.s);\n\t    r.clamp();\n\t  }\n\t  // (public) this & a\n\t  function op_and(x, y)\n\t  {\n\t    return x & y;\n\t  }\n\t\n\t  function bnAnd(a)\n\t  {\n\t    var r = nbi();\n\t    this.bitwiseTo(a, op_and, r);\n\t    return r;\n\t  }\n\t  // (public) this | a\n\t  function op_or(x, y)\n\t  {\n\t    return x | y;\n\t  }\n\t\n\t  function bnOr(a)\n\t  {\n\t    var r = nbi();\n\t    this.bitwiseTo(a, op_or, r);\n\t    return r;\n\t  }\n\t  // (public) this ^ a\n\t  function op_xor(x, y)\n\t  {\n\t    return x ^ y;\n\t  }\n\t\n\t  function bnXor(a)\n\t  {\n\t    var r = nbi();\n\t    this.bitwiseTo(a, op_xor, r);\n\t    return r;\n\t  }\n\t  // (public) this & ~a\n\t  function op_andnot(x, y)\n\t  {\n\t    return x & ~y;\n\t  }\n\t\n\t  function bnAndNot(a)\n\t  {\n\t    var r = nbi();\n\t    this.bitwiseTo(a, op_andnot, r);\n\t    return r;\n\t  }\n\t  // (public) ~this\n\t  function bnNot()\n\t  {\n\t    var r = nbi();\n\t    for (var i = 0; i < this.t; ++i) r[i] = this.DM & ~this[i];\n\t    r.t = this.t;\n\t    r.s = ~this.s;\n\t    return r;\n\t  }\n\t  // (public) this << n\n\t  function bnShiftLeft(n)\n\t  {\n\t    var r = nbi();\n\t    if (n < 0) this.rShiftTo(-n, r);\n\t    else this.lShiftTo(n, r);\n\t    return r;\n\t  }\n\t  // (public) this >> n\n\t  function bnShiftRight(n)\n\t  {\n\t    var r = nbi();\n\t    if (n < 0) this.lShiftTo(-n, r);\n\t    else this.rShiftTo(n, r);\n\t    return r;\n\t  }\n\t  // return index of lowest 1-bit in x, x < 2^31\n\t  function lbit(x)\n\t  {\n\t    if (x == 0) return -1;\n\t    var r = 0;\n\t    if ((x & 0xffff) == 0)\n\t    {\n\t      x >>= 16;\n\t      r += 16;\n\t    }\n\t    if ((x & 0xff) == 0)\n\t    {\n\t      x >>= 8;\n\t      r += 8;\n\t    }\n\t    if ((x & 0xf) == 0)\n\t    {\n\t      x >>= 4;\n\t      r += 4;\n\t    }\n\t    if ((x & 3) == 0)\n\t    {\n\t      x >>= 2;\n\t      r += 2;\n\t    }\n\t    if ((x & 1) == 0)++r;\n\t    return r;\n\t  }\n\t  // (public) returns index of lowest 1-bit (or -1 if none)\n\t  function bnGetLowestSetBit()\n\t  {\n\t    for (var i = 0; i < this.t; ++i)\n\t      if (this[i] != 0) return i * this.DB + lbit(this[i]);\n\t    if (this.s < 0) return this.t * this.DB;\n\t    return -1;\n\t  }\n\t  // return number of 1 bits in x\n\t  function cbit(x)\n\t  {\n\t    var r = 0;\n\t    while (x != 0)\n\t    {\n\t      x &= x - 1;\n\t      ++r;\n\t    }\n\t    return r;\n\t  }\n\t  // (public) return number of set bits\n\t  function bnBitCount()\n\t  {\n\t    var r = 0,\n\t      x = this.s & this.DM;\n\t    for (var i = 0; i < this.t; ++i) r += cbit(this[i] ^ x);\n\t    return r;\n\t  }\n\t  // (public) true iff nth bit is set\n\t  function bnTestBit(n)\n\t  {\n\t    var j = Math.floor(n / this.DB);\n\t    if (j >= this.t) return (this.s != 0);\n\t    return ((this[j] & (1 << (n % this.DB))) != 0);\n\t  }\n\t  // (protected) this op (1<<n)\n\t  function bnpChangeBit(n, op)\n\t  {\n\t    var r = BigInteger.ONE.shiftLeft(n);\n\t    this.bitwiseTo(r, op, r);\n\t    return r;\n\t  }\n\t  // (public) this | (1<<n)\n\t  function bnSetBit(n)\n\t  {\n\t    return this.changeBit(n, op_or);\n\t  }\n\t  // (public) this & ~(1<<n)\n\t  function bnClearBit(n)\n\t  {\n\t    return this.changeBit(n, op_andnot);\n\t  }\n\t  // (public) this ^ (1<<n)\n\t  function bnFlipBit(n)\n\t  {\n\t    return this.changeBit(n, op_xor);\n\t  }\n\t  // (protected) r = this + a\n\t  function bnpAddTo(a, r)\n\t  {\n\t    var i = 0,\n\t      c = 0,\n\t      m = Math.min(a.t, this.t);\n\t    while (i < m)\n\t    {\n\t      c += this[i] + a[i];\n\t      r[i++] = c & this.DM;\n\t      c >>= this.DB;\n\t    }\n\t    if (a.t < this.t)\n\t    {\n\t      c += a.s;\n\t      while (i < this.t)\n\t      {\n\t        c += this[i];\n\t        r[i++] = c & this.DM;\n\t        c >>= this.DB;\n\t      }\n\t      c += this.s;\n\t    }\n\t    else\n\t    {\n\t      c += this.s;\n\t      while (i < a.t)\n\t      {\n\t        c += a[i];\n\t        r[i++] = c & this.DM;\n\t        c >>= this.DB;\n\t      }\n\t      c += a.s;\n\t    }\n\t    r.s = (c < 0) ? -1 : 0;\n\t    if (c > 0) r[i++] = c;\n\t    else if (c < -1) r[i++] = this.DV + c;\n\t    r.t = i;\n\t    r.clamp();\n\t  }\n\t  // (public) this + a\n\t  function bnAdd(a)\n\t  {\n\t    var r = nbi();\n\t    this.addTo(a, r);\n\t    return r;\n\t  }\n\t  // (public) this - a\n\t  function bnSubtract(a)\n\t  {\n\t    var r = nbi();\n\t    this.subTo(a, r);\n\t    return r;\n\t  }\n\t  // (public) this * a\n\t  function bnMultiply(a)\n\t  {\n\t    var r = nbi();\n\t    this.multiplyTo(a, r);\n\t    return r;\n\t  }\n\t  // (public) this^2\n\t  function bnSquare()\n\t  {\n\t    var r = nbi();\n\t    this.squareTo(r);\n\t    return r;\n\t  }\n\t  // (public) this / a\n\t  function bnDivide(a)\n\t  {\n\t    var r = nbi();\n\t    this.divRemTo(a, r, null);\n\t    return r;\n\t  }\n\t  // (public) this % a\n\t  function bnRemainder(a)\n\t  {\n\t    var r = nbi();\n\t    this.divRemTo(a, null, r);\n\t    return r;\n\t  }\n\t  // (public) [this/a,this%a]\n\t  function bnDivideAndRemainder(a)\n\t  {\n\t    var q = nbi(),\n\t      r = nbi();\n\t    this.divRemTo(a, q, r);\n\t    return new Array(q, r);\n\t  }\n\t  // (protected) this *= n, this >= 0, 1 < n < DV\n\t  function bnpDMultiply(n)\n\t  {\n\t    this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);\n\t    ++this.t;\n\t    this.clamp();\n\t  }\n\t  // (protected) this += n << w words, this >= 0\n\t  function bnpDAddOffset(n, w)\n\t  {\n\t    if (n == 0) return;\n\t    while (this.t <= w) this[this.t++] = 0;\n\t    this[w] += n;\n\t    while (this[w] >= this.DV)\n\t    {\n\t      this[w] -= this.DV;\n\t      if (++w >= this.t) this[this.t++] = 0;\n\t      ++this[w];\n\t    }\n\t  }\n\t  // A \"null\" reducer\n\t  function NullExp()\n\t  {}\n\t\n\t  function nNop(x)\n\t  {\n\t    return x;\n\t  }\n\t\n\t  function nMulTo(x, y, r)\n\t  {\n\t    x.multiplyTo(y, r);\n\t  }\n\t\n\t  function nSqrTo(x, r)\n\t  {\n\t    x.squareTo(r);\n\t  }\n\t  NullExp.prototype.convert = nNop;\n\t  NullExp.prototype.revert = nNop;\n\t  NullExp.prototype.mulTo = nMulTo;\n\t  NullExp.prototype.sqrTo = nSqrTo;\n\t  // (public) this^e\n\t  function bnPow(e)\n\t  {\n\t    return this.exp(e, new NullExp());\n\t  }\n\t  // (protected) r = lower n words of \"this * a\", a.t <= n\n\t  // \"this\" should be the larger one if appropriate.\n\t  function bnpMultiplyLowerTo(a, n, r)\n\t  {\n\t    var i = Math.min(this.t + a.t, n);\n\t    r.s = 0; // assumes a,this >= 0\n\t    r.t = i;\n\t    while (i > 0) r[--i] = 0;\n\t    var j;\n\t    for (j = r.t - this.t; i < j; ++i) r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);\n\t    for (j = Math.min(a.t, n); i < j; ++i) this.am(0, a[i], r, i, 0, n - i);\n\t    r.clamp();\n\t  }\n\t  // (protected) r = \"this * a\" without lower n words, n > 0\n\t  // \"this\" should be the larger one if appropriate.\n\t  function bnpMultiplyUpperTo(a, n, r)\n\t  {\n\t    --n;\n\t    var i = r.t = this.t + a.t - n;\n\t    r.s = 0; // assumes a,this >= 0\n\t    while (--i >= 0) r[i] = 0;\n\t    for (i = Math.max(n - this.t, 0); i < a.t; ++i)\n\t      r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n);\n\t    r.clamp();\n\t    r.drShiftTo(1, r);\n\t  }\n\t  // Barrett modular reduction\n\t  function Barrett(m)\n\t  {\n\t    // setup Barrett\n\t    this.r2 = nbi();\n\t    this.q3 = nbi();\n\t    BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);\n\t    this.mu = this.r2.divide(m);\n\t    this.m = m;\n\t  }\n\t\n\t  function barrettConvert(x)\n\t  {\n\t    if (x.s < 0 || x.t > 2 * this.m.t) return x.mod(this.m);\n\t    else if (x.compareTo(this.m) < 0) return x;\n\t    else\n\t    {\n\t      var r = nbi();\n\t      x.copyTo(r);\n\t      this.reduce(r);\n\t      return r;\n\t    }\n\t  }\n\t\n\t  function barrettRevert(x)\n\t  {\n\t    return x;\n\t  }\n\t  // x = x mod m (HAC 14.42)\n\t  function barrettReduce(x)\n\t  {\n\t    x.drShiftTo(this.m.t - 1, this.r2);\n\t    if (x.t > this.m.t + 1)\n\t    {\n\t      x.t = this.m.t + 1;\n\t      x.clamp();\n\t    }\n\t    this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);\n\t    this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);\n\t    while (x.compareTo(this.r2) < 0) x.dAddOffset(1, this.m.t + 1);\n\t    x.subTo(this.r2, x);\n\t    while (x.compareTo(this.m) >= 0) x.subTo(this.m, x);\n\t  }\n\t  // r = x^2 mod m; x != r\n\t  function barrettSqrTo(x, r)\n\t  {\n\t    x.squareTo(r);\n\t    this.reduce(r);\n\t  }\n\t  // r = x*y mod m; x,y != r\n\t  function barrettMulTo(x, y, r)\n\t  {\n\t    x.multiplyTo(y, r);\n\t    this.reduce(r);\n\t  }\n\t  Barrett.prototype.convert = barrettConvert;\n\t  Barrett.prototype.revert = barrettRevert;\n\t  Barrett.prototype.reduce = barrettReduce;\n\t  Barrett.prototype.mulTo = barrettMulTo;\n\t  Barrett.prototype.sqrTo = barrettSqrTo;\n\t  // (public) this^e % m (HAC 14.85)\n\t  function bnModPow(e, m)\n\t  {\n\t    var i = e.bitLength(),\n\t      k, r = nbv(1),\n\t      z;\n\t    if (i <= 0) return r;\n\t    else if (i < 18) k = 1;\n\t    else if (i < 48) k = 3;\n\t    else if (i < 144) k = 4;\n\t    else if (i < 768) k = 5;\n\t    else k = 6;\n\t    if (i < 8)\n\t      z = new Classic(m);\n\t    else if (m.isEven())\n\t      z = new Barrett(m);\n\t    else\n\t      z = new Montgomery(m);\n\t    // precomputation\n\t    var g = new Array(),\n\t      n = 3,\n\t      k1 = k - 1,\n\t      km = (1 << k) - 1;\n\t    g[1] = z.convert(this);\n\t    if (k > 1)\n\t    {\n\t      var g2 = nbi();\n\t      z.sqrTo(g[1], g2);\n\t      while (n <= km)\n\t      {\n\t        g[n] = nbi();\n\t        z.mulTo(g2, g[n - 2], g[n]);\n\t        n += 2;\n\t      }\n\t    }\n\t    var j = e.t - 1,\n\t      w, is1 = true,\n\t      r2 = nbi(),\n\t      t;\n\t    i = nbits(e[j]) - 1;\n\t    while (j >= 0)\n\t    {\n\t      if (i >= k1) w = (e[j] >> (i - k1)) & km;\n\t      else\n\t      {\n\t        w = (e[j] & ((1 << (i + 1)) - 1)) << (k1 - i);\n\t        if (j > 0) w |= e[j - 1] >> (this.DB + i - k1);\n\t      }\n\t      n = k;\n\t      while ((w & 1) == 0)\n\t      {\n\t        w >>= 1;\n\t        --n;\n\t      }\n\t      if ((i -= n) < 0)\n\t      {\n\t        i += this.DB;\n\t        --j;\n\t      }\n\t      if (is1)\n\t      { // ret == 1, don't bother squaring or multiplying it\n\t        g[w].copyTo(r);\n\t        is1 = false;\n\t      }\n\t      else\n\t      {\n\t        while (n > 1)\n\t        {\n\t          z.sqrTo(r, r2);\n\t          z.sqrTo(r2, r);\n\t          n -= 2;\n\t        }\n\t        if (n > 0) z.sqrTo(r, r2);\n\t        else\n\t        {\n\t          t = r;\n\t          r = r2;\n\t          r2 = t;\n\t        }\n\t        z.mulTo(r2, g[w], r);\n\t      }\n\t      while (j >= 0 && (e[j] & (1 << i)) == 0)\n\t      {\n\t        z.sqrTo(r, r2);\n\t        t = r;\n\t        r = r2;\n\t        r2 = t;\n\t        if (--i < 0)\n\t        {\n\t          i = this.DB - 1;\n\t          --j;\n\t        }\n\t      }\n\t    }\n\t    return z.revert(r);\n\t  }\n\t  // (public) gcd(this,a) (HAC 14.54)\n\t  function bnGCD(a)\n\t  {\n\t    var x = (this.s < 0) ? this.negate() : this.clone();\n\t    var y = (a.s < 0) ? a.negate() : a.clone();\n\t    if (x.compareTo(y) < 0)\n\t    {\n\t      var t = x;\n\t      x = y;\n\t      y = t;\n\t    }\n\t    var i = x.getLowestSetBit(),\n\t      g = y.getLowestSetBit();\n\t    if (g < 0) return x;\n\t    if (i < g) g = i;\n\t    if (g > 0)\n\t    {\n\t      x.rShiftTo(g, x);\n\t      y.rShiftTo(g, y);\n\t    }\n\t    while (x.signum() > 0)\n\t    {\n\t      if ((i = x.getLowestSetBit()) > 0) x.rShiftTo(i, x);\n\t      if ((i = y.getLowestSetBit()) > 0) y.rShiftTo(i, y);\n\t      if (x.compareTo(y) >= 0)\n\t      {\n\t        x.subTo(y, x);\n\t        x.rShiftTo(1, x);\n\t      }\n\t      else\n\t      {\n\t        y.subTo(x, y);\n\t        y.rShiftTo(1, y);\n\t      }\n\t    }\n\t    if (g > 0) y.lShiftTo(g, y);\n\t    return y;\n\t  }\n\t  // (protected) this % n, n < 2^26\n\t  function bnpModInt(n)\n\t  {\n\t    if (n <= 0) return 0;\n\t    var d = this.DV % n,\n\t      r = (this.s < 0) ? n - 1 : 0;\n\t    if (this.t > 0)\n\t      if (d == 0) r = this[0] % n;\n\t      else\n\t        for (var i = this.t - 1; i >= 0; --i) r = (d * r + this[i]) % n;\n\t    return r;\n\t  }\n\t  // (public) 1/this % m (HAC 14.61)\n\t  function bnModInverse(m)\n\t  {\n\t    var ac = m.isEven();\n\t    if ((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO;\n\t    var u = m.clone(),\n\t      v = this.clone();\n\t    var a = nbv(1),\n\t      b = nbv(0),\n\t      c = nbv(0),\n\t      d = nbv(1);\n\t    while (u.signum() != 0)\n\t    {\n\t      while (u.isEven())\n\t      {\n\t        u.rShiftTo(1, u);\n\t        if (ac)\n\t        {\n\t          if (!a.isEven() || !b.isEven())\n\t          {\n\t            a.addTo(this, a);\n\t            b.subTo(m, b);\n\t          }\n\t          a.rShiftTo(1, a);\n\t        }\n\t        else if (!b.isEven()) b.subTo(m, b);\n\t        b.rShiftTo(1, b);\n\t      }\n\t      while (v.isEven())\n\t      {\n\t        v.rShiftTo(1, v);\n\t        if (ac)\n\t        {\n\t          if (!c.isEven() || !d.isEven())\n\t          {\n\t            c.addTo(this, c);\n\t            d.subTo(m, d);\n\t          }\n\t          c.rShiftTo(1, c);\n\t        }\n\t        else if (!d.isEven()) d.subTo(m, d);\n\t        d.rShiftTo(1, d);\n\t      }\n\t      if (u.compareTo(v) >= 0)\n\t      {\n\t        u.subTo(v, u);\n\t        if (ac) a.subTo(c, a);\n\t        b.subTo(d, b);\n\t      }\n\t      else\n\t      {\n\t        v.subTo(u, v);\n\t        if (ac) c.subTo(a, c);\n\t        d.subTo(b, d);\n\t      }\n\t    }\n\t    if (v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;\n\t    if (d.compareTo(m) >= 0) return d.subtract(m);\n\t    if (d.signum() < 0) d.addTo(m, d);\n\t    else return d;\n\t    if (d.signum() < 0) return d.add(m);\n\t    else return d;\n\t  }\n\t  var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];\n\t  var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];\n\t  // (public) test primality with certainty >= 1-.5^t\n\t  function bnIsProbablePrime(t)\n\t  {\n\t    var i, x = this.abs();\n\t    if (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1])\n\t    {\n\t      for (i = 0; i < lowprimes.length; ++i)\n\t        if (x[0] == lowprimes[i]) return true;\n\t      return false;\n\t    }\n\t    if (x.isEven()) return false;\n\t    i = 1;\n\t    while (i < lowprimes.length)\n\t    {\n\t      var m = lowprimes[i],\n\t        j = i + 1;\n\t      while (j < lowprimes.length && m < lplim) m *= lowprimes[j++];\n\t      m = x.modInt(m);\n\t      while (i < j)\n\t        if (m % lowprimes[i++] == 0) return false;\n\t    }\n\t    return x.millerRabin(t);\n\t  }\n\t  // (protected) true if probably prime (HAC 4.24, Miller-Rabin)\n\t  function bnpMillerRabin(t)\n\t  {\n\t    var n1 = this.subtract(BigInteger.ONE);\n\t    var k = n1.getLowestSetBit();\n\t    if (k <= 0) return false;\n\t    var r = n1.shiftRight(k);\n\t    t = (t + 1) >> 1;\n\t    if (t > lowprimes.length) t = lowprimes.length;\n\t    var a = nbi();\n\t    for (var i = 0; i < t; ++i)\n\t    {\n\t      //Pick bases at random, instead of starting at 2\n\t      a.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);\n\t      var y = a.modPow(r, this);\n\t      if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0)\n\t      {\n\t        var j = 1;\n\t        while (j++ < k && y.compareTo(n1) != 0)\n\t        {\n\t          y = y.modPowInt(2, this);\n\t          if (y.compareTo(BigInteger.ONE) == 0) return false;\n\t        }\n\t        if (y.compareTo(n1) != 0) return false;\n\t      }\n\t    }\n\t    return true;\n\t  }\n\t  // protected\n\t  BigInteger.prototype.chunkSize = bnpChunkSize;\n\t  BigInteger.prototype.toRadix = bnpToRadix;\n\t  BigInteger.prototype.fromRadix = bnpFromRadix;\n\t  BigInteger.prototype.fromNumber = bnpFromNumber;\n\t  BigInteger.prototype.bitwiseTo = bnpBitwiseTo;\n\t  BigInteger.prototype.changeBit = bnpChangeBit;\n\t  BigInteger.prototype.addTo = bnpAddTo;\n\t  BigInteger.prototype.dMultiply = bnpDMultiply;\n\t  BigInteger.prototype.dAddOffset = bnpDAddOffset;\n\t  BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;\n\t  BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;\n\t  BigInteger.prototype.modInt = bnpModInt;\n\t  BigInteger.prototype.millerRabin = bnpMillerRabin;\n\t  // public\n\t  BigInteger.prototype.clone = bnClone;\n\t  BigInteger.prototype.intValue = bnIntValue;\n\t  BigInteger.prototype.byteValue = bnByteValue;\n\t  BigInteger.prototype.shortValue = bnShortValue;\n\t  BigInteger.prototype.signum = bnSigNum;\n\t  BigInteger.prototype.toByteArray = bnToByteArray;\n\t  BigInteger.prototype.equals = bnEquals;\n\t  BigInteger.prototype.min = bnMin;\n\t  BigInteger.prototype.max = bnMax;\n\t  BigInteger.prototype.and = bnAnd;\n\t  BigInteger.prototype.or = bnOr;\n\t  BigInteger.prototype.xor = bnXor;\n\t  BigInteger.prototype.andNot = bnAndNot;\n\t  BigInteger.prototype.not = bnNot;\n\t  BigInteger.prototype.shiftLeft = bnShiftLeft;\n\t  BigInteger.prototype.shiftRight = bnShiftRight;\n\t  BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;\n\t  BigInteger.prototype.bitCount = bnBitCount;\n\t  BigInteger.prototype.testBit = bnTestBit;\n\t  BigInteger.prototype.setBit = bnSetBit;\n\t  BigInteger.prototype.clearBit = bnClearBit;\n\t  BigInteger.prototype.flipBit = bnFlipBit;\n\t  BigInteger.prototype.add = bnAdd;\n\t  BigInteger.prototype.subtract = bnSubtract;\n\t  BigInteger.prototype.multiply = bnMultiply;\n\t  BigInteger.prototype.divide = bnDivide;\n\t  BigInteger.prototype.remainder = bnRemainder;\n\t  BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;\n\t  BigInteger.prototype.modPow = bnModPow;\n\t  BigInteger.prototype.modInverse = bnModInverse;\n\t  BigInteger.prototype.pow = bnPow;\n\t  BigInteger.prototype.gcd = bnGCD;\n\t  BigInteger.prototype.isProbablePrime = bnIsProbablePrime;\n\t  // JSBN-specific extension\n\t  BigInteger.prototype.square = bnSquare;\n\t  var Int128 = BigInteger;\n\t  // BigInteger interfaces not implemented in jsbn:\n\t  // BigInteger(int signum, byte[] magnitude)\n\t  // double doubleValue()\n\t  // float floatValue()\n\t  // int hashCode()\n\t  // long longValue()\n\t  // static BigInteger valueOf(long val)\n\t  // Helper functions to make BigInteger functions callable with two parameters\n\t  // as in original C# Clipper\n\t  Int128.prototype.IsNegative = function ()\n\t  {\n\t    if (this.compareTo(Int128.ZERO) == -1) return true;\n\t    else return false;\n\t  };\n\t  Int128.op_Equality = function (val1, val2)\n\t  {\n\t    if (val1.compareTo(val2) == 0) return true;\n\t    else return false;\n\t  };\n\t  Int128.op_Inequality = function (val1, val2)\n\t  {\n\t    if (val1.compareTo(val2) != 0) return true;\n\t    else return false;\n\t  };\n\t  Int128.op_GreaterThan = function (val1, val2)\n\t  {\n\t    if (val1.compareTo(val2) > 0) return true;\n\t    else return false;\n\t  };\n\t  Int128.op_LessThan = function (val1, val2)\n\t  {\n\t    if (val1.compareTo(val2) < 0) return true;\n\t    else return false;\n\t  };\n\t  Int128.op_Addition = function (lhs, rhs)\n\t  {\n\t    return new Int128(lhs).add(new Int128(rhs));\n\t  };\n\t  Int128.op_Subtraction = function (lhs, rhs)\n\t  {\n\t    return new Int128(lhs).subtract(new Int128(rhs));\n\t  };\n\t  Int128.Int128Mul = function (lhs, rhs)\n\t  {\n\t    return new Int128(lhs).multiply(new Int128(rhs));\n\t  };\n\t  Int128.op_Division = function (lhs, rhs)\n\t  {\n\t    return lhs.divide(rhs);\n\t  };\n\t  Int128.prototype.ToDouble = function ()\n\t  {\n\t    return parseFloat(this.toString()); // This could be something faster\n\t  };\n\t  // end of Int128 section\n\t  /*\n\t  // Uncomment the following two lines if you want to use Int128 outside ClipperLib\n\t  if (typeof(document) !== \"undefined\") window.Int128 = Int128;\n\t  else self.Int128 = Int128;\n\t  */\n\t\n\t\n\t  // ---------------------------------------------\n\t  // Here starts the actual Clipper library:\n\t  // Helper function to support Inheritance in Javascript\n\t\tvar Inherit = function (ce, ce2)\n\t\t{\n\t\t\tvar p;\n\t\t\tif (typeof (Object.getOwnPropertyNames) == 'undefined')\n\t\t\t{\n\t\t\t\tfor (p in ce2.prototype)\n\t\t\t\t\tif (typeof (ce.prototype[p]) == 'undefined' || ce.prototype[p] == Object.prototype[p]) ce.prototype[p] = ce2.prototype[p];\n\t\t\t\tfor (p in ce2)\n\t\t\t\t\tif (typeof (ce[p]) == 'undefined') ce[p] = ce2[p];\n\t\t\t\tce.$baseCtor = ce2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvar props = Object.getOwnPropertyNames(ce2.prototype);\n\t\t\t\tfor (var i = 0; i < props.length; i++)\n\t\t\t\t\tif (typeof (Object.getOwnPropertyDescriptor(ce.prototype, props[i])) == 'undefined') Object.defineProperty(ce.prototype, props[i], Object.getOwnPropertyDescriptor(ce2.prototype, props[i]));\n\t\t\t\tfor (p in ce2)\n\t\t\t\t\tif (typeof (ce[p]) == 'undefined') ce[p] = ce2[p];\n\t\t\t\tce.$baseCtor = ce2;\n\t\t\t}\n\t\t};\n\t  ClipperLib.Path = function ()\n\t  {\n\t    return [];\n\t  };\n\t  ClipperLib.Paths = function ()\n\t  {\n\t    return []; // Was previously [[]], but caused problems when pushed\n\t  };\n\t  // Preserves the calling way of original C# Clipper\n\t  // Is essential due to compatibility, because DoublePoint is public class in original C# version\n\t  ClipperLib.DoublePoint = function ()\n\t  {\n\t    var a = arguments;\n\t    this.X = 0;\n\t    this.Y = 0;\n\t    // public DoublePoint(DoublePoint dp)\n\t    // public DoublePoint(IntPoint ip)\n\t    if (a.length == 1)\n\t    {\n\t      this.X = a[0].X;\n\t      this.Y = a[0].Y;\n\t    }\n\t    else if (a.length == 2)\n\t    {\n\t      this.X = a[0];\n\t      this.Y = a[1];\n\t    }\n\t  }; // This is internal faster function when called without arguments\n\t  ClipperLib.DoublePoint0 = function ()\n\t  {\n\t    this.X = 0;\n\t    this.Y = 0;\n\t  };\n\t  // This is internal faster function when called with 1 argument (dp or ip)\n\t  ClipperLib.DoublePoint1 = function (dp)\n\t  {\n\t    this.X = dp.X;\n\t    this.Y = dp.Y;\n\t  };\n\t  // This is internal faster function when called with 2 arguments (x and y)\n\t  ClipperLib.DoublePoint2 = function (x, y)\n\t  {\n\t    this.X = x;\n\t    this.Y = y;\n\t  };\n\t  // PolyTree & PolyNode start\n\t  // -------------------------------\n\t  ClipperLib.PolyNode = function ()\n\t  {\n\t    this.m_Parent = null;\n\t    this.m_polygon = new ClipperLib.Path();\n\t    this.m_Index = 0;\n\t    this.m_jointype = 0;\n\t    this.m_endtype = 0;\n\t    this.m_Childs = [];\n\t    this.IsOpen = false;\n\t  };\n\t  ClipperLib.PolyNode.prototype.IsHoleNode = function ()\n\t  {\n\t    var result = true;\n\t    var node = this.m_Parent;\n\t    while (node !== null)\n\t    {\n\t      result = !result;\n\t      node = node.m_Parent;\n\t    }\n\t    return result;\n\t  };\n\t  ClipperLib.PolyNode.prototype.ChildCount = function ()\n\t  {\n\t    return this.m_Childs.length;\n\t  };\n\t  ClipperLib.PolyNode.prototype.Contour = function ()\n\t  {\n\t    return this.m_polygon;\n\t  };\n\t  ClipperLib.PolyNode.prototype.AddChild = function (Child)\n\t  {\n\t    var cnt = this.m_Childs.length;\n\t    this.m_Childs.push(Child);\n\t    Child.m_Parent = this;\n\t    Child.m_Index = cnt;\n\t  };\n\t  ClipperLib.PolyNode.prototype.GetNext = function ()\n\t  {\n\t    if (this.m_Childs.length > 0)\n\t      return this.m_Childs[0];\n\t    else\n\t      return this.GetNextSiblingUp();\n\t  };\n\t  ClipperLib.PolyNode.prototype.GetNextSiblingUp = function ()\n\t  {\n\t    if (this.m_Parent === null)\n\t      return null;\n\t    else if (this.m_Index == this.m_Parent.m_Childs.length - 1)\n\t      return this.m_Parent.GetNextSiblingUp();\n\t    else\n\t      return this.m_Parent.m_Childs[this.m_Index + 1];\n\t  };\n\t  ClipperLib.PolyNode.prototype.Childs = function ()\n\t  {\n\t    return this.m_Childs;\n\t  };\n\t  ClipperLib.PolyNode.prototype.Parent = function ()\n\t  {\n\t    return this.m_Parent;\n\t  };\n\t  ClipperLib.PolyNode.prototype.IsHole = function ()\n\t  {\n\t    return this.IsHoleNode();\n\t  };\n\t  // PolyTree : PolyNode\n\t  ClipperLib.PolyTree = function ()\n\t  {\n\t    this.m_AllPolys = [];\n\t    ClipperLib.PolyNode.call(this);\n\t  };\n\t  ClipperLib.PolyTree.prototype.Clear = function ()\n\t  {\n\t    for (var i = 0, ilen = this.m_AllPolys.length; i < ilen; i++)\n\t      this.m_AllPolys[i] = null;\n\t    this.m_AllPolys.length = 0;\n\t    this.m_Childs.length = 0;\n\t  };\n\t  ClipperLib.PolyTree.prototype.GetFirst = function ()\n\t  {\n\t    if (this.m_Childs.length > 0)\n\t      return this.m_Childs[0];\n\t    else\n\t      return null;\n\t  };\n\t  ClipperLib.PolyTree.prototype.Total = function ()\n\t  {\n\t\t\tvar result = this.m_AllPolys.length;\n\t\t\t//with negative offsets, ignore the hidden outer polygon ...\n\t\t\tif (result > 0 && this.m_Childs[0] != this.m_AllPolys[0]) result--;\n\t\t\treturn result;\n\t  };\n\t  Inherit(ClipperLib.PolyTree, ClipperLib.PolyNode);\n\t  // -------------------------------\n\t  // PolyTree & PolyNode end\n\t  ClipperLib.Math_Abs_Int64 = ClipperLib.Math_Abs_Int32 = ClipperLib.Math_Abs_Double = function (a)\n\t  {\n\t    return Math.abs(a);\n\t  };\n\t  ClipperLib.Math_Max_Int32_Int32 = function (a, b)\n\t  {\n\t    return Math.max(a, b);\n\t  };\n\t  /*\n\t  -----------------------------------\n\t  cast_32 speedtest: http://jsperf.com/truncate-float-to-integer/2\n\t  -----------------------------------\n\t  */\n\t  if (browser.msie || browser.opera || browser.safari) ClipperLib.Cast_Int32 = function (a)\n\t  {\n\t    return a | 0;\n\t  };\n\t  else ClipperLib.Cast_Int32 = function (a)\n\t  { // eg. browser.chrome || browser.chromium || browser.firefox\n\t    return~~ a;\n\t  };\n\t  /*\n\t  --------------------------\n\t  cast_64 speedtests: http://jsperf.com/truncate-float-to-integer\n\t  Chrome: bitwise_not_floor\n\t  Firefox17: toInteger (typeof test)\n\t  IE9: bitwise_or_floor\n\t  IE7 and IE8: to_parseint\n\t  Chromium: to_floor_or_ceil\n\t  Firefox3: to_floor_or_ceil\n\t  Firefox15: to_floor_or_ceil\n\t  Opera: to_floor_or_ceil\n\t  Safari: to_floor_or_ceil\n\t  --------------------------\n\t  */\n\t  if (browser.chrome) ClipperLib.Cast_Int64 = function (a)\n\t  {\n\t    if (a < -2147483648 || a > 2147483647)\n\t      return a < 0 ? Math.ceil(a) : Math.floor(a);\n\t    else return~~ a;\n\t  };\n\t  else if (browser.firefox && typeof (Number.toInteger) == \"function\") ClipperLib.Cast_Int64 = function (a)\n\t  {\n\t    return Number.toInteger(a);\n\t  };\n\t  else if (browser.msie7 || browser.msie8) ClipperLib.Cast_Int64 = function (a)\n\t  {\n\t    return parseInt(a, 10);\n\t  };\n\t  else if (browser.msie) ClipperLib.Cast_Int64 = function (a)\n\t  {\n\t    if (a < -2147483648 || a > 2147483647)\n\t      return a < 0 ? Math.ceil(a) : Math.floor(a);\n\t    return a | 0;\n\t  };\n\t  // eg. browser.chromium || browser.firefox || browser.opera || browser.safari\n\t  else ClipperLib.Cast_Int64 = function (a)\n\t  {\n\t    return a < 0 ? Math.ceil(a) : Math.floor(a);\n\t  };\n\t  ClipperLib.Clear = function (a)\n\t  {\n\t    a.length = 0;\n\t  };\n\t  //ClipperLib.MaxSteps = 64; // How many steps at maximum in arc in BuildArc() function\n\t  ClipperLib.PI = 3.141592653589793;\n\t  ClipperLib.PI2 = 2 * 3.141592653589793;\n\t  ClipperLib.IntPoint = function ()\n\t  {\n\t    var a = arguments,\n\t      alen = a.length;\n\t    this.X = 0;\n\t    this.Y = 0;\n\t    if (use_xyz)\n\t    {\n\t      this.Z = 0;\n\t      if (alen == 3) // public IntPoint(cInt x, cInt y, cInt z = 0)\n\t      {\n\t        this.X = a[0];\n\t        this.Y = a[1];\n\t        this.Z = a[2];\n\t      }\n\t      else if (alen == 2) // public IntPoint(cInt x, cInt y)\n\t      {\n\t        this.X = a[0];\n\t        this.Y = a[1];\n\t        this.Z = 0;\n\t      }\n\t      else if (alen == 1)\n\t      {\n\t        if (a[0] instanceof ClipperLib.DoublePoint) // public IntPoint(DoublePoint dp)\n\t        {\n\t          var dp = a[0];\n\t          this.X = ClipperLib.Clipper.Round(dp.X);\n\t          this.Y = ClipperLib.Clipper.Round(dp.Y);\n\t          this.Z = 0;\n\t        }\n\t        else // public IntPoint(IntPoint pt)\n\t        {\n\t          var pt = a[0];\n\t          if (typeof (pt.Z) == \"undefined\") pt.Z = 0;\n\t          this.X = pt.X;\n\t          this.Y = pt.Y;\n\t          this.Z = pt.Z;\n\t        }\n\t      }\n\t      else // public IntPoint()\n\t      {\n\t        this.X = 0;\n\t        this.Y = 0;\n\t        this.Z = 0;\n\t      }\n\t    }\n\t    else // if (!use_xyz)\n\t    {\n\t      if (alen == 2) // public IntPoint(cInt X, cInt Y)\n\t      {\n\t        this.X = a[0];\n\t        this.Y = a[1];\n\t      }\n\t      else if (alen == 1)\n\t      {\n\t        if (a[0] instanceof ClipperLib.DoublePoint) // public IntPoint(DoublePoint dp)\n\t        {\n\t          var dp = a[0];\n\t          this.X = ClipperLib.Clipper.Round(dp.X);\n\t          this.Y = ClipperLib.Clipper.Round(dp.Y);\n\t        }\n\t        else // public IntPoint(IntPoint pt)\n\t        {\n\t          var pt = a[0];\n\t          this.X = pt.X;\n\t          this.Y = pt.Y;\n\t        }\n\t      }\n\t      else // public IntPoint(IntPoint pt)\n\t      {\n\t        this.X = 0;\n\t        this.Y = 0;\n\t      }\n\t    }\n\t  };\n\t  ClipperLib.IntPoint.op_Equality = function (a, b)\n\t  {\n\t    //return a == b;\n\t    return a.X == b.X && a.Y == b.Y;\n\t  };\n\t  ClipperLib.IntPoint.op_Inequality = function (a, b)\n\t  {\n\t    //return a != b;\n\t    return a.X != b.X || a.Y != b.Y;\n\t  };\n\t  /*\n\t  ClipperLib.IntPoint.prototype.Equals = function (obj)\n\t  {\n\t    if (obj === null)\n\t        return false;\n\t    if (obj instanceof ClipperLib.IntPoint)\n\t    {\n\t        var a = Cast(obj, ClipperLib.IntPoint);\n\t        return (this.X == a.X) && (this.Y == a.Y);\n\t    }\n\t    else\n\t        return false;\n\t  };\n\t*/\n\t  if (use_xyz)\n\t  {\n\t    ClipperLib.IntPoint0 = function ()\n\t    {\n\t      this.X = 0;\n\t      this.Y = 0;\n\t      this.Z = 0;\n\t    };\n\t    ClipperLib.IntPoint1 = function (pt)\n\t    {\n\t      this.X = pt.X;\n\t      this.Y = pt.Y;\n\t      this.Z = pt.Z;\n\t    };\n\t    ClipperLib.IntPoint1dp = function (dp)\n\t    {\n\t      this.X = ClipperLib.Clipper.Round(dp.X);\n\t      this.Y = ClipperLib.Clipper.Round(dp.Y);\n\t      this.Z = 0;\n\t    };\n\t    ClipperLib.IntPoint2 = function (x, y)\n\t    {\n\t      this.X = x;\n\t      this.Y = y;\n\t      this.Z = 0;\n\t    };\n\t    ClipperLib.IntPoint3 = function (x, y, z)\n\t    {\n\t      this.X = x;\n\t      this.Y = y;\n\t      this.Z = z;\n\t    };\n\t  }\n\t  else // if (!use_xyz)\n\t  {\n\t    ClipperLib.IntPoint0 = function ()\n\t    {\n\t      this.X = 0;\n\t      this.Y = 0;\n\t    };\n\t    ClipperLib.IntPoint1 = function (pt)\n\t    {\n\t      this.X = pt.X;\n\t      this.Y = pt.Y;\n\t    };\n\t    ClipperLib.IntPoint1dp = function (dp)\n\t    {\n\t      this.X = ClipperLib.Clipper.Round(dp.X);\n\t      this.Y = ClipperLib.Clipper.Round(dp.Y);\n\t    };\n\t    ClipperLib.IntPoint2 = function (x, y)\n\t    {\n\t      this.X = x;\n\t      this.Y = y;\n\t    };\n\t  }\n\t  ClipperLib.IntRect = function ()\n\t  {\n\t    var a = arguments,\n\t      alen = a.length;\n\t    if (alen == 4) // function (l, t, r, b)\n\t    {\n\t      this.left = a[0];\n\t      this.top = a[1];\n\t      this.right = a[2];\n\t      this.bottom = a[3];\n\t    }\n\t    else if (alen == 1) // function (ir)\n\t    {\n\t      this.left = ir.left;\n\t      this.top = ir.top;\n\t      this.right = ir.right;\n\t      this.bottom = ir.bottom;\n\t    }\n\t    else // function ()\n\t    {\n\t      this.left = 0;\n\t      this.top = 0;\n\t      this.right = 0;\n\t      this.bottom = 0;\n\t    }\n\t  };\n\t  ClipperLib.IntRect0 = function ()\n\t  {\n\t    this.left = 0;\n\t    this.top = 0;\n\t    this.right = 0;\n\t    this.bottom = 0;\n\t  };\n\t  ClipperLib.IntRect1 = function (ir)\n\t  {\n\t    this.left = ir.left;\n\t    this.top = ir.top;\n\t    this.right = ir.right;\n\t    this.bottom = ir.bottom;\n\t  };\n\t  ClipperLib.IntRect4 = function (l, t, r, b)\n\t  {\n\t    this.left = l;\n\t    this.top = t;\n\t    this.right = r;\n\t    this.bottom = b;\n\t  };\n\t  ClipperLib.ClipType = {\n\t    ctIntersection: 0,\n\t    ctUnion: 1,\n\t    ctDifference: 2,\n\t    ctXor: 3\n\t  };\n\t  ClipperLib.PolyType = {\n\t    ptSubject: 0,\n\t    ptClip: 1\n\t  };\n\t  ClipperLib.PolyFillType = {\n\t    pftEvenOdd: 0,\n\t    pftNonZero: 1,\n\t    pftPositive: 2,\n\t    pftNegative: 3\n\t  };\n\t  ClipperLib.JoinType = {\n\t    jtSquare: 0,\n\t    jtRound: 1,\n\t    jtMiter: 2\n\t  };\n\t  ClipperLib.EndType = {\n\t    etOpenSquare: 0,\n\t    etOpenRound: 1,\n\t    etOpenButt: 2,\n\t    etClosedLine: 3,\n\t    etClosedPolygon: 4\n\t  };\n\t  ClipperLib.EdgeSide = {\n\t    esLeft: 0,\n\t    esRight: 1\n\t  };\n\t  ClipperLib.Direction = {\n\t    dRightToLeft: 0,\n\t    dLeftToRight: 1\n\t  };\n\t  ClipperLib.TEdge = function ()\n\t  {\n\t    this.Bot = new ClipperLib.IntPoint();\n\t    this.Curr = new ClipperLib.IntPoint();\n\t    this.Top = new ClipperLib.IntPoint();\n\t    this.Delta = new ClipperLib.IntPoint();\n\t    this.Dx = 0;\n\t    this.PolyTyp = ClipperLib.PolyType.ptSubject;\n\t    this.Side = ClipperLib.EdgeSide.esLeft;\n\t    this.WindDelta = 0;\n\t    this.WindCnt = 0;\n\t    this.WindCnt2 = 0;\n\t    this.OutIdx = 0;\n\t    this.Next = null;\n\t    this.Prev = null;\n\t    this.NextInLML = null;\n\t    this.NextInAEL = null;\n\t    this.PrevInAEL = null;\n\t    this.NextInSEL = null;\n\t    this.PrevInSEL = null;\n\t  };\n\t  ClipperLib.IntersectNode = function ()\n\t  {\n\t    this.Edge1 = null;\n\t    this.Edge2 = null;\n\t    this.Pt = new ClipperLib.IntPoint();\n\t  };\n\t  ClipperLib.MyIntersectNodeSort = function () {};\n\t  ClipperLib.MyIntersectNodeSort.Compare = function (node1, node2)\n\t  {\n\t    var i = node2.Pt.Y - node1.Pt.Y;\n\t    if (i > 0) return 1;\n\t    else if (i < 0) return -1;\n\t    else return 0;\n\t  };\n\t\n\t  ClipperLib.LocalMinima = function ()\n\t  {\n\t    this.Y = 0;\n\t    this.LeftBound = null;\n\t    this.RightBound = null;\n\t    this.Next = null;\n\t  };\n\t  ClipperLib.Scanbeam = function ()\n\t  {\n\t    this.Y = 0;\n\t    this.Next = null;\n\t  };\n\t  ClipperLib.OutRec = function ()\n\t  {\n\t    this.Idx = 0;\n\t    this.IsHole = false;\n\t    this.IsOpen = false;\n\t    this.FirstLeft = null;\n\t    this.Pts = null;\n\t    this.BottomPt = null;\n\t    this.PolyNode = null;\n\t  };\n\t  ClipperLib.OutPt = function ()\n\t  {\n\t    this.Idx = 0;\n\t    this.Pt = new ClipperLib.IntPoint();\n\t    this.Next = null;\n\t    this.Prev = null;\n\t  };\n\t  ClipperLib.Join = function ()\n\t  {\n\t    this.OutPt1 = null;\n\t    this.OutPt2 = null;\n\t    this.OffPt = new ClipperLib.IntPoint();\n\t  };\n\t  ClipperLib.ClipperBase = function ()\n\t  {\n\t    this.m_MinimaList = null;\n\t    this.m_CurrentLM = null;\n\t    this.m_edges = new Array();\n\t    this.m_UseFullRange = false;\n\t    this.m_HasOpenPaths = false;\n\t    this.PreserveCollinear = false;\n\t    this.m_MinimaList = null;\n\t    this.m_CurrentLM = null;\n\t    this.m_UseFullRange = false;\n\t    this.m_HasOpenPaths = false;\n\t  };\n\t  // Ranges are in original C# too high for Javascript (in current state 2013 september):\n\t  // protected const double horizontal = -3.4E+38;\n\t  // internal const cInt loRange = 0x3FFFFFFF; // = 1073741823 = sqrt(2^63 -1)/2\n\t  // internal const cInt hiRange = 0x3FFFFFFFFFFFFFFFL; // = 4611686018427387903 = sqrt(2^127 -1)/2\n\t  // So had to adjust them to more suitable for Javascript.\n\t  // If JS some day supports truly 64-bit integers, then these ranges can be as in C#\n\t  // and biginteger library can be more simpler (as then 128bit can be represented as two 64bit numbers)\n\t  ClipperLib.ClipperBase.horizontal = -9007199254740992; //-2^53\n\t  ClipperLib.ClipperBase.Skip = -2;\n\t  ClipperLib.ClipperBase.Unassigned = -1;\n\t  ClipperLib.ClipperBase.tolerance = 1E-20;\n\t  if (use_int32)\n\t  {\n\t    ClipperLib.ClipperBase.loRange = 0x7FFF;\n\t    ClipperLib.ClipperBase.hiRange = 0x7FFF;\n\t  }\n\t  else\n\t  {\n\t    ClipperLib.ClipperBase.loRange = 47453132; // sqrt(2^53 -1)/2\n\t    ClipperLib.ClipperBase.hiRange = 4503599627370495; // sqrt(2^106 -1)/2\n\t  }\n\t\n\t  ClipperLib.ClipperBase.near_zero = function (val)\n\t  {\n\t    return (val > -ClipperLib.ClipperBase.tolerance) && (val < ClipperLib.ClipperBase.tolerance);\n\t  };\n\t  ClipperLib.ClipperBase.IsHorizontal = function (e)\n\t  {\n\t    return e.Delta.Y === 0;\n\t  };\n\t  ClipperLib.ClipperBase.prototype.PointIsVertex = function (pt, pp)\n\t  {\n\t    var pp2 = pp;\n\t    do {\n\t      if (ClipperLib.IntPoint.op_Equality(pp2.Pt, pt))\n\t        return true;\n\t      pp2 = pp2.Next;\n\t    }\n\t    while (pp2 != pp)\n\t    return false;\n\t  };\n\t  ClipperLib.ClipperBase.prototype.PointOnLineSegment = function (pt, linePt1, linePt2, UseFullRange)\n\t  {\n\t    if (UseFullRange)\n\t      return ((pt.X == linePt1.X) && (pt.Y == linePt1.Y)) ||\n\t        ((pt.X == linePt2.X) && (pt.Y == linePt2.Y)) ||\n\t        (((pt.X > linePt1.X) == (pt.X < linePt2.X)) &&\n\t        ((pt.Y > linePt1.Y) == (pt.Y < linePt2.Y)) &&\n\t        (Int128.op_Equality(Int128.Int128Mul((pt.X - linePt1.X), (linePt2.Y - linePt1.Y)),\n\t          Int128.Int128Mul((linePt2.X - linePt1.X), (pt.Y - linePt1.Y)))));\n\t    else\n\t      return ((pt.X == linePt1.X) && (pt.Y == linePt1.Y)) || ((pt.X == linePt2.X) && (pt.Y == linePt2.Y)) || (((pt.X > linePt1.X) == (pt.X < linePt2.X)) && ((pt.Y > linePt1.Y) == (pt.Y < linePt2.Y)) && ((pt.X - linePt1.X) * (linePt2.Y - linePt1.Y) == (linePt2.X - linePt1.X) * (pt.Y - linePt1.Y)));\n\t  };\n\t  ClipperLib.ClipperBase.prototype.PointOnPolygon = function (pt, pp, UseFullRange)\n\t  {\n\t    var pp2 = pp;\n\t    while (true)\n\t    {\n\t      if (this.PointOnLineSegment(pt, pp2.Pt, pp2.Next.Pt, UseFullRange))\n\t        return true;\n\t      pp2 = pp2.Next;\n\t      if (pp2 == pp)\n\t        break;\n\t    }\n\t    return false;\n\t  };\n\t  ClipperLib.ClipperBase.prototype.SlopesEqual = ClipperLib.ClipperBase.SlopesEqual = function ()\n\t  {\n\t    var a = arguments,\n\t      alen = a.length;\n\t    var e1, e2, pt1, pt2, pt3, pt4, UseFullRange;\n\t    if (alen == 3) // function (e1, e2, UseFullRange)\n\t    {\n\t      e1 = a[0];\n\t      e2 = a[1];\n\t      UseFullRange = a[2];\n\t      if (UseFullRange)\n\t        return Int128.op_Equality(Int128.Int128Mul(e1.Delta.Y, e2.Delta.X), Int128.Int128Mul(e1.Delta.X, e2.Delta.Y));\n\t      else\n\t        return ClipperLib.Cast_Int64((e1.Delta.Y) * (e2.Delta.X)) == ClipperLib.Cast_Int64((e1.Delta.X) * (e2.Delta.Y));\n\t    }\n\t    else if (alen == 4) // function (pt1, pt2, pt3, UseFullRange)\n\t    {\n\t      pt1 = a[0];\n\t      pt2 = a[1];\n\t      pt3 = a[2];\n\t      UseFullRange = a[3];\n\t      if (UseFullRange)\n\t        return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt2.X - pt3.X), Int128.Int128Mul(pt1.X - pt2.X, pt2.Y - pt3.Y));\n\t      else\n\t        return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt2.X - pt3.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt2.Y - pt3.Y)) === 0;\n\t    }\n\t    else // function (pt1, pt2, pt3, pt4, UseFullRange)\n\t    {\n\t      pt1 = a[0];\n\t      pt2 = a[1];\n\t      pt3 = a[2];\n\t      pt4 = a[3];\n\t      UseFullRange = a[4];\n\t      if (UseFullRange)\n\t        return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt3.X - pt4.X), Int128.Int128Mul(pt1.X - pt2.X, pt3.Y - pt4.Y));\n\t      else\n\t        return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt3.X - pt4.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt3.Y - pt4.Y)) === 0;\n\t    }\n\t  };\n\t  ClipperLib.ClipperBase.SlopesEqual3 = function (e1, e2, UseFullRange)\n\t  {\n\t    if (UseFullRange)\n\t      return Int128.op_Equality(Int128.Int128Mul(e1.Delta.Y, e2.Delta.X), Int128.Int128Mul(e1.Delta.X, e2.Delta.Y));\n\t    else\n\t      return ClipperLib.Cast_Int64((e1.Delta.Y) * (e2.Delta.X)) == ClipperLib.Cast_Int64((e1.Delta.X) * (e2.Delta.Y));\n\t  };\n\t  ClipperLib.ClipperBase.SlopesEqual4 = function (pt1, pt2, pt3, UseFullRange)\n\t  {\n\t    if (UseFullRange)\n\t      return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt2.X - pt3.X), Int128.Int128Mul(pt1.X - pt2.X, pt2.Y - pt3.Y));\n\t    else\n\t      return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt2.X - pt3.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt2.Y - pt3.Y)) === 0;\n\t  };\n\t  ClipperLib.ClipperBase.SlopesEqual5 = function (pt1, pt2, pt3, pt4, UseFullRange)\n\t  {\n\t    if (UseFullRange)\n\t      return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt3.X - pt4.X), Int128.Int128Mul(pt1.X - pt2.X, pt3.Y - pt4.Y));\n\t    else\n\t      return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt3.X - pt4.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt3.Y - pt4.Y)) === 0;\n\t  };\n\t  ClipperLib.ClipperBase.prototype.Clear = function ()\n\t  {\n\t    this.DisposeLocalMinimaList();\n\t    for (var i = 0, ilen = this.m_edges.length; i < ilen; ++i)\n\t    {\n\t      for (var j = 0, jlen = this.m_edges[i].length; j < jlen; ++j)\n\t        this.m_edges[i][j] = null;\n\t      ClipperLib.Clear(this.m_edges[i]);\n\t    }\n\t    ClipperLib.Clear(this.m_edges);\n\t    this.m_UseFullRange = false;\n\t    this.m_HasOpenPaths = false;\n\t  };\n\t  ClipperLib.ClipperBase.prototype.DisposeLocalMinimaList = function ()\n\t  {\n\t    while (this.m_MinimaList !== null)\n\t    {\n\t      var tmpLm = this.m_MinimaList.Next;\n\t      this.m_MinimaList = null;\n\t      this.m_MinimaList = tmpLm;\n\t    }\n\t    this.m_CurrentLM = null;\n\t  };\n\t  ClipperLib.ClipperBase.prototype.RangeTest = function (Pt, useFullRange)\n\t  {\n\t    if (useFullRange.Value)\n\t    {\n\t      if (Pt.X > ClipperLib.ClipperBase.hiRange || Pt.Y > ClipperLib.ClipperBase.hiRange || -Pt.X > ClipperLib.ClipperBase.hiRange || -Pt.Y > ClipperLib.ClipperBase.hiRange)\n\t        ClipperLib.Error(\"Coordinate outside allowed range in RangeTest().\");\n\t    }\n\t    else if (Pt.X > ClipperLib.ClipperBase.loRange || Pt.Y > ClipperLib.ClipperBase.loRange || -Pt.X > ClipperLib.ClipperBase.loRange || -Pt.Y > ClipperLib.ClipperBase.loRange)\n\t    {\n\t      useFullRange.Value = true;\n\t      this.RangeTest(Pt, useFullRange);\n\t    }\n\t  };\n\t  ClipperLib.ClipperBase.prototype.InitEdge = function (e, eNext, ePrev, pt)\n\t  {\n\t    e.Next = eNext;\n\t    e.Prev = ePrev;\n\t    //e.Curr = pt;\n\t    e.Curr.X = pt.X;\n\t    e.Curr.Y = pt.Y;\n\t    e.OutIdx = -1;\n\t  };\n\t  ClipperLib.ClipperBase.prototype.InitEdge2 = function (e, polyType)\n\t  {\n\t    if (e.Curr.Y >= e.Next.Curr.Y)\n\t    {\n\t      //e.Bot = e.Curr;\n\t      e.Bot.X = e.Curr.X;\n\t      e.Bot.Y = e.Curr.Y;\n\t      //e.Top = e.Next.Curr;\n\t      e.Top.X = e.Next.Curr.X;\n\t      e.Top.Y = e.Next.Curr.Y;\n\t    }\n\t    else\n\t    {\n\t      //e.Top = e.Curr;\n\t      e.Top.X = e.Curr.X;\n\t      e.Top.Y = e.Curr.Y;\n\t      //e.Bot = e.Next.Curr;\n\t      e.Bot.X = e.Next.Curr.X;\n\t      e.Bot.Y = e.Next.Curr.Y;\n\t    }\n\t    this.SetDx(e);\n\t    e.PolyTyp = polyType;\n\t  };\n\t  ClipperLib.ClipperBase.prototype.FindNextLocMin = function (E)\n\t  {\n\t    var E2;\n\t    for (;;)\n\t    {\n\t      while (ClipperLib.IntPoint.op_Inequality(E.Bot, E.Prev.Bot) || ClipperLib.IntPoint.op_Equality(E.Curr, E.Top))\n\t        E = E.Next;\n\t      if (E.Dx != ClipperLib.ClipperBase.horizontal && E.Prev.Dx != ClipperLib.ClipperBase.horizontal)\n\t        break;\n\t      while (E.Prev.Dx == ClipperLib.ClipperBase.horizontal)\n\t        E = E.Prev;\n\t      E2 = E;\n\t      while (E.Dx == ClipperLib.ClipperBase.horizontal)\n\t        E = E.Next;\n\t      if (E.Top.Y == E.Prev.Bot.Y)\n\t        continue;\n\t      //ie just an intermediate horz.\n\t      if (E2.Prev.Bot.X < E.Bot.X)\n\t        E = E2;\n\t      break;\n\t    }\n\t    return E;\n\t  };\n\t  ClipperLib.ClipperBase.prototype.ProcessBound = function (E, LeftBoundIsForward)\n\t  {\n\t    var EStart;\n\t    var Result = E;\n\t    var Horz;\n\t\n\t      if (Result.OutIdx == ClipperLib.ClipperBase.Skip)\n\t      {\n\t        //check if there are edges beyond the skip edge in the bound and if so\n\t        //create another LocMin and calling ProcessBound once more ...\n\t        E = Result;\n\t        if (LeftBoundIsForward)\n\t        {\n\t          while (E.Top.Y == E.Next.Bot.Y) E = E.Next;\n\t          while (E != Result && E.Dx == ClipperLib.ClipperBase.horizontal) E = E.Prev;\n\t        }\n\t        else\n\t        {\n\t          while (E.Top.Y == E.Prev.Bot.Y) E = E.Prev;\n\t          while (E != Result && E.Dx == ClipperLib.ClipperBase.horizontal) E = E.Next;\n\t        }\n\t        if (E == Result)\n\t        {\n\t          if (LeftBoundIsForward) Result = E.Next;\n\t          else Result = E.Prev;\n\t        }\n\t        else\n\t        {\n\t          //there are more edges in the bound beyond result starting with E\n\t          if (LeftBoundIsForward)\n\t            E = Result.Next;\n\t          else\n\t            E = Result.Prev;\n\t          var locMin = new ClipperLib.LocalMinima();\n\t          locMin.Next = null;\n\t          locMin.Y = E.Bot.Y;\n\t          locMin.LeftBound = null;\n\t          locMin.RightBound = E;\n\t          E.WindDelta = 0;\n\t          Result = this.ProcessBound(E, LeftBoundIsForward);\n\t          this.InsertLocalMinima(locMin);\n\t        }\n\t        return Result;\n\t      }\n\t\n\t      if (E.Dx == ClipperLib.ClipperBase.horizontal)\n\t      {\n\t        //We need to be careful with open paths because this may not be a\n\t        //true local minima (ie E may be following a skip edge).\n\t        //Also, consecutive horz. edges may start heading left before going right.\n\t        if (LeftBoundIsForward) EStart = E.Prev;\n\t        else EStart = E.Next;\n\t        if (EStart.OutIdx != ClipperLib.ClipperBase.Skip)\n\t        {\n\t          if (EStart.Dx == ClipperLib.ClipperBase.horizontal) //ie an adjoining horizontal skip edge\n\t          {\n\t            if (EStart.Bot.X != E.Bot.X && EStart.Top.X != E.Bot.X)\n\t              this.ReverseHorizontal(E);\n\t          }\n\t          else if (EStart.Bot.X != E.Bot.X)\n\t            this.ReverseHorizontal(E);\n\t        }\n\t      }\n\t\n\t      EStart = E;\n\t      if (LeftBoundIsForward)\n\t      {\n\t        while (Result.Top.Y == Result.Next.Bot.Y && Result.Next.OutIdx != ClipperLib.ClipperBase.Skip)\n\t          Result = Result.Next;\n\t        if (Result.Dx == ClipperLib.ClipperBase.horizontal && Result.Next.OutIdx != ClipperLib.ClipperBase.Skip)\n\t        {\n\t          //nb: at the top of a bound, horizontals are added to the bound\n\t          //only when the preceding edge attaches to the horizontal's left vertex\n\t          //unless a Skip edge is encountered when that becomes the top divide\n\t          Horz = Result;\n\t          while (Horz.Prev.Dx == ClipperLib.ClipperBase.horizontal)\n\t            Horz = Horz.Prev;\n\t          if (Horz.Prev.Top.X == Result.Next.Top.X)\n\t          {\n\t            if (!LeftBoundIsForward)\n\t              Result = Horz.Prev;\n\t          }\n\t          else if (Horz.Prev.Top.X > Result.Next.Top.X)\n\t            Result = Horz.Prev;\n\t        }\n\t        while (E != Result)\n\t        {\n\t          E.NextInLML = E.Next;\n\t          if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Prev.Top.X)\n\t            this.ReverseHorizontal(E);\n\t          E = E.Next;\n\t        }\n\t        if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Prev.Top.X)\n\t          this.ReverseHorizontal(E);\n\t        Result = Result.Next;\n\t        //move to the edge just beyond current bound\n\t      }\n\t      else\n\t      {\n\t        while (Result.Top.Y == Result.Prev.Bot.Y && Result.Prev.OutIdx != ClipperLib.ClipperBase.Skip)\n\t          Result = Result.Prev;\n\t        if (Result.Dx == ClipperLib.ClipperBase.horizontal && Result.Prev.OutIdx != ClipperLib.ClipperBase.Skip)\n\t        {\n\t          Horz = Result;\n\t          while (Horz.Next.Dx == ClipperLib.ClipperBase.horizontal)\n\t            Horz = Horz.Next;\n\t          if (Horz.Next.Top.X == Result.Prev.Top.X)\n\t          {\n\t            if (!LeftBoundIsForward)\n\t              Result = Horz.Next;\n\t          }\n\t          else if (Horz.Next.Top.X > Result.Prev.Top.X)\n\t            Result = Horz.Next;\n\t        }\n\t        while (E != Result)\n\t        {\n\t          E.NextInLML = E.Prev;\n\t          if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Next.Top.X)\n\t            this.ReverseHorizontal(E);\n\t          E = E.Prev;\n\t        }\n\t        if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Next.Top.X)\n\t          this.ReverseHorizontal(E);\n\t        Result = Result.Prev;\n\t        //move to the edge just beyond current bound\n\t      }\n\t\n\t    return Result;\n\t  };\n\t\n\t  ClipperLib.ClipperBase.prototype.AddPath = function (pg, polyType, Closed)\n\t  {\n\t    if (use_lines)\n\t    {\n\t      if (!Closed && polyType == ClipperLib.PolyType.ptClip)\n\t        ClipperLib.Error(\"AddPath: Open paths must be subject.\");\n\t    }\n\t    else\n\t    {\n\t      if (!Closed)\n\t        ClipperLib.Error(\"AddPath: Open paths have been disabled.\");\n\t    }\n\t    var highI = pg.length - 1;\n\t    if (Closed)\n\t      while (highI > 0 && (ClipperLib.IntPoint.op_Equality(pg[highI], pg[0])))\n\t    --highI;\n\t    while (highI > 0 && (ClipperLib.IntPoint.op_Equality(pg[highI], pg[highI - 1])))\n\t    --highI;\n\t    if ((Closed && highI < 2) || (!Closed && highI < 1))\n\t      return false;\n\t    //create a new edge array ...\n\t    var edges = new Array();\n\t    for (var i = 0; i <= highI; i++)\n\t      edges.push(new ClipperLib.TEdge());\n\t    var IsFlat = true;\n\t    //1. Basic (first) edge initialization ...\n\t\n\t    //edges[1].Curr = pg[1];\n\t    edges[1].Curr.X = pg[1].X;\n\t    edges[1].Curr.Y = pg[1].Y;\n\t\n\t    var $1 = {Value: this.m_UseFullRange};\n\t    this.RangeTest(pg[0], $1);\n\t    this.m_UseFullRange = $1.Value;\n\t\n\t    $1.Value = this.m_UseFullRange;\n\t    this.RangeTest(pg[highI], $1);\n\t    this.m_UseFullRange = $1.Value;\n\t\n\t    this.InitEdge(edges[0], edges[1], edges[highI], pg[0]);\n\t    this.InitEdge(edges[highI], edges[0], edges[highI - 1], pg[highI]);\n\t    for (var i = highI - 1; i >= 1; --i)\n\t    {\n\t      $1.Value = this.m_UseFullRange;\n\t      this.RangeTest(pg[i], $1);\n\t      this.m_UseFullRange = $1.Value;\n\t\n\t      this.InitEdge(edges[i], edges[i + 1], edges[i - 1], pg[i]);\n\t    }\n\t\n\t    var eStart = edges[0];\n\t    //2. Remove duplicate vertices, and (when closed) collinear edges ...\n\t    var E = eStart,\n\t      eLoopStop = eStart;\n\t    for (;;)\n\t    {\n\t    //console.log(E.Next, eStart);\n\t    \t//nb: allows matching start and end points when not Closed ...\n\t      if (E.Curr == E.Next.Curr && (Closed || E.Next != eStart))\n\t      {\n\t        if (E == E.Next)\n\t          break;\n\t        if (E == eStart)\n\t          eStart = E.Next;\n\t        E = this.RemoveEdge(E);\n\t        eLoopStop = E;\n\t        continue;\n\t      }\n\t      if (E.Prev == E.Next)\n\t        break;\n\t      else if (Closed && ClipperLib.ClipperBase.SlopesEqual(E.Prev.Curr, E.Curr, E.Next.Curr, this.m_UseFullRange) && (!this.PreserveCollinear || !this.Pt2IsBetweenPt1AndPt3(E.Prev.Curr, E.Curr, E.Next.Curr)))\n\t      {\n\t        //Collinear edges are allowed for open paths but in closed paths\n\t        //the default is to merge adjacent collinear edges into a single edge.\n\t        //However, if the PreserveCollinear property is enabled, only overlapping\n\t        //collinear edges (ie spikes) will be removed from closed paths.\n\t        if (E == eStart)\n\t          eStart = E.Next;\n\t        E = this.RemoveEdge(E);\n\t        E = E.Prev;\n\t        eLoopStop = E;\n\t        continue;\n\t      }\n\t      E = E.Next;\n\t      if ((E == eLoopStop) || (!Closed && E.Next == eStart)) break;\n\t    }\n\t    if ((!Closed && (E == E.Next)) || (Closed && (E.Prev == E.Next)))\n\t      return false;\n\t    if (!Closed)\n\t    {\n\t      this.m_HasOpenPaths = true;\n\t      eStart.Prev.OutIdx = ClipperLib.ClipperBase.Skip;\n\t    }\n\t    //3. Do second stage of edge initialization ...\n\t    E = eStart;\n\t    do {\n\t      this.InitEdge2(E, polyType);\n\t      E = E.Next;\n\t      if (IsFlat && E.Curr.Y != eStart.Curr.Y)\n\t        IsFlat = false;\n\t    }\n\t    while (E != eStart)\n\t    //4. Finally, add edge bounds to LocalMinima list ...\n\t    //Totally flat paths must be handled differently when adding them\n\t    //to LocalMinima list to avoid endless loops etc ...\n\t    if (IsFlat)\n\t    {\n\t      if (Closed)\n\t        return false;\n\t      E.Prev.OutIdx = ClipperLib.ClipperBase.Skip;\n\t      if (E.Prev.Bot.X < E.Prev.Top.X)\n\t        this.ReverseHorizontal(E.Prev);\n\t      var locMin = new ClipperLib.LocalMinima();\n\t      locMin.Next = null;\n\t      locMin.Y = E.Bot.Y;\n\t      locMin.LeftBound = null;\n\t      locMin.RightBound = E;\n\t      locMin.RightBound.Side = ClipperLib.EdgeSide.esRight;\n\t      locMin.RightBound.WindDelta = 0;\n\t      while (E.Next.OutIdx != ClipperLib.ClipperBase.Skip)\n\t      {\n\t        E.NextInLML = E.Next;\n\t        if (E.Bot.X != E.Prev.Top.X)\n\t          this.ReverseHorizontal(E);\n\t        E = E.Next;\n\t      }\n\t      this.InsertLocalMinima(locMin);\n\t      this.m_edges.push(edges);\n\t      return true;\n\t    }\n\t    this.m_edges.push(edges);\n\t    var leftBoundIsForward;\n\t    var EMin = null;\n\t\n\t\t\t//workaround to avoid an endless loop in the while loop below when\n\t    //open paths have matching start and end points ...\n\t    if(ClipperLib.IntPoint.op_Equality(E.Prev.Bot, E.Prev.Top))\n\t    \tE = E.Next;\n\t\n\t    for (;;)\n\t    {\n\t      E = this.FindNextLocMin(E);\n\t      if (E == EMin)\n\t        break;\n\t      else if (EMin == null)\n\t        EMin = E;\n\t      //E and E.Prev now share a local minima (left aligned if horizontal).\n\t      //Compare their slopes to find which starts which bound ...\n\t      var locMin = new ClipperLib.LocalMinima();\n\t      locMin.Next = null;\n\t      locMin.Y = E.Bot.Y;\n\t      if (E.Dx < E.Prev.Dx)\n\t      {\n\t        locMin.LeftBound = E.Prev;\n\t        locMin.RightBound = E;\n\t        leftBoundIsForward = false;\n\t        //Q.nextInLML = Q.prev\n\t      }\n\t      else\n\t      {\n\t        locMin.LeftBound = E;\n\t        locMin.RightBound = E.Prev;\n\t        leftBoundIsForward = true;\n\t        //Q.nextInLML = Q.next\n\t      }\n\t      locMin.LeftBound.Side = ClipperLib.EdgeSide.esLeft;\n\t      locMin.RightBound.Side = ClipperLib.EdgeSide.esRight;\n\t      if (!Closed)\n\t        locMin.LeftBound.WindDelta = 0;\n\t      else if (locMin.LeftBound.Next == locMin.RightBound)\n\t        locMin.LeftBound.WindDelta = -1;\n\t      else\n\t        locMin.LeftBound.WindDelta = 1;\n\t      locMin.RightBound.WindDelta = -locMin.LeftBound.WindDelta;\n\t      E = this.ProcessBound(locMin.LeftBound, leftBoundIsForward);\n\t      if (E.OutIdx == ClipperLib.ClipperBase.Skip)\n\t      \tE = this.ProcessBound(E, leftBoundIsForward);\n\t      var E2 = this.ProcessBound(locMin.RightBound, !leftBoundIsForward);\n\t      if (E2.OutIdx == ClipperLib.ClipperBase.Skip) E2 = this.ProcessBound(E2, !leftBoundIsForward);\n\t      if (locMin.LeftBound.OutIdx == ClipperLib.ClipperBase.Skip)\n\t        locMin.LeftBound = null;\n\t      else if (locMin.RightBound.OutIdx == ClipperLib.ClipperBase.Skip)\n\t        locMin.RightBound = null;\n\t      this.InsertLocalMinima(locMin);\n\t      if (!leftBoundIsForward)\n\t        E = E2;\n\t    }\n\t    return true;\n\t  };\n\t  ClipperLib.ClipperBase.prototype.AddPaths = function (ppg, polyType, closed)\n\t  {\n\t    //  console.log(\"-------------------------------------------\");\n\t    //  console.log(JSON.stringify(ppg));\n\t    var result = false;\n\t    for (var i = 0, ilen = ppg.length; i < ilen; ++i)\n\t      if (this.AddPath(ppg[i], polyType, closed))\n\t        result = true;\n\t    return result;\n\t  };\n\t  //------------------------------------------------------------------------------\n\t  ClipperLib.ClipperBase.prototype.Pt2IsBetweenPt1AndPt3 = function (pt1, pt2, pt3)\n\t  {\n\t    if ((ClipperLib.IntPoint.op_Equality(pt1, pt3)) || (ClipperLib.IntPoint.op_Equality(pt1, pt2)) ||       (ClipperLib.IntPoint.op_Equality(pt3, pt2)))\n\t\n\t   //if ((pt1 == pt3) || (pt1 == pt2) || (pt3 == pt2))\n\t   return false;\n\t\n\t    else if (pt1.X != pt3.X)\n\t      return (pt2.X > pt1.X) == (pt2.X < pt3.X);\n\t    else\n\t      return (pt2.Y > pt1.Y) == (pt2.Y < pt3.Y);\n\t  };\n\t  ClipperLib.ClipperBase.prototype.RemoveEdge = function (e)\n\t  {\n\t    //removes e from double_linked_list (but without removing from memory)\n\t    e.Prev.Next = e.Next;\n\t    e.Next.Prev = e.Prev;\n\t    var result = e.Next;\n\t    e.Prev = null; //flag as removed (see ClipperBase.Clear)\n\t    return result;\n\t  };\n\t  ClipperLib.ClipperBase.prototype.SetDx = function (e)\n\t  {\n\t    e.Delta.X = (e.Top.X - e.Bot.X);\n\t    e.Delta.Y = (e.Top.Y - e.Bot.Y);\n\t    if (e.Delta.Y === 0) e.Dx = ClipperLib.ClipperBase.horizontal;\n\t    else e.Dx = (e.Delta.X) / (e.Delta.Y);\n\t  };\n\t  ClipperLib.ClipperBase.prototype.InsertLocalMinima = function (newLm)\n\t  {\n\t    if (this.m_MinimaList === null)\n\t    {\n\t      this.m_MinimaList = newLm;\n\t    }\n\t    else if (newLm.Y >= this.m_MinimaList.Y)\n\t    {\n\t      newLm.Next = this.m_MinimaList;\n\t      this.m_MinimaList = newLm;\n\t    }\n\t    else\n\t    {\n\t      var tmpLm = this.m_MinimaList;\n\t      while (tmpLm.Next !== null && (newLm.Y < tmpLm.Next.Y))\n\t        tmpLm = tmpLm.Next;\n\t      newLm.Next = tmpLm.Next;\n\t      tmpLm.Next = newLm;\n\t    }\n\t  };\n\t  ClipperLib.ClipperBase.prototype.PopLocalMinima = function ()\n\t  {\n\t    if (this.m_CurrentLM === null)\n\t      return;\n\t    this.m_CurrentLM = this.m_CurrentLM.Next;\n\t  };\n\t  ClipperLib.ClipperBase.prototype.ReverseHorizontal = function (e)\n\t  {\n\t    //swap horizontal edges' top and bottom x's so they follow the natural\n\t    //progression of the bounds - ie so their xbots will align with the\n\t    //adjoining lower edge. [Helpful in the ProcessHorizontal() method.]\n\t    var tmp = e.Top.X;\n\t    e.Top.X = e.Bot.X;\n\t    e.Bot.X = tmp;\n\t    if (use_xyz)\n\t    {\n\t      tmp = e.Top.Z;\n\t      e.Top.Z = e.Bot.Z;\n\t      e.Bot.Z = tmp;\n\t    }\n\t  };\n\t  ClipperLib.ClipperBase.prototype.Reset = function ()\n\t  {\n\t    this.m_CurrentLM = this.m_MinimaList;\n\t    if (this.m_CurrentLM == null)\n\t      return;\n\t    //ie nothing to process\n\t    //reset all edges ...\n\t    var lm = this.m_MinimaList;\n\t    while (lm != null)\n\t    {\n\t      var e = lm.LeftBound;\n\t      if (e != null)\n\t      {\n\t        //e.Curr = e.Bot;\n\t        e.Curr.X = e.Bot.X;\n\t        e.Curr.Y = e.Bot.Y;\n\t        e.Side = ClipperLib.EdgeSide.esLeft;\n\t        e.OutIdx = ClipperLib.ClipperBase.Unassigned;\n\t      }\n\t      e = lm.RightBound;\n\t      if (e != null)\n\t      {\n\t        //e.Curr = e.Bot;\n\t        e.Curr.X = e.Bot.X;\n\t        e.Curr.Y = e.Bot.Y;\n\t        e.Side = ClipperLib.EdgeSide.esRight;\n\t        e.OutIdx = ClipperLib.ClipperBase.Unassigned;\n\t      }\n\t      lm = lm.Next;\n\t    }\n\t  };\n\t  ClipperLib.Clipper = function (InitOptions) // public Clipper(int InitOptions = 0)\n\t  {\n\t    if (typeof (InitOptions) == \"undefined\") InitOptions = 0;\n\t    this.m_PolyOuts = null;\n\t    this.m_ClipType = ClipperLib.ClipType.ctIntersection;\n\t    this.m_Scanbeam = null;\n\t    this.m_ActiveEdges = null;\n\t    this.m_SortedEdges = null;\n\t    this.m_IntersectList = null;\n\t    this.m_IntersectNodeComparer = null;\n\t    this.m_ExecuteLocked = false;\n\t    this.m_ClipFillType = ClipperLib.PolyFillType.pftEvenOdd;\n\t    this.m_SubjFillType = ClipperLib.PolyFillType.pftEvenOdd;\n\t    this.m_Joins = null;\n\t    this.m_GhostJoins = null;\n\t    this.m_UsingPolyTree = false;\n\t    this.ReverseSolution = false;\n\t    this.StrictlySimple = false;\n\t    ClipperLib.ClipperBase.call(this);\n\t    this.m_Scanbeam = null;\n\t    this.m_ActiveEdges = null;\n\t    this.m_SortedEdges = null;\n\t    this.m_IntersectList = new Array();\n\t    this.m_IntersectNodeComparer = ClipperLib.MyIntersectNodeSort.Compare;\n\t    this.m_ExecuteLocked = false;\n\t    this.m_UsingPolyTree = false;\n\t    this.m_PolyOuts = new Array();\n\t    this.m_Joins = new Array();\n\t    this.m_GhostJoins = new Array();\n\t    this.ReverseSolution = (1 & InitOptions) !== 0;\n\t    this.StrictlySimple = (2 & InitOptions) !== 0;\n\t    this.PreserveCollinear = (4 & InitOptions) !== 0;\n\t    if (use_xyz)\n\t    {\n\t      this.ZFillFunction = null; // function (IntPoint vert1, IntPoint vert2, ref IntPoint intersectPt);\n\t    }\n\t  };\n\t  ClipperLib.Clipper.ioReverseSolution = 1;\n\t  ClipperLib.Clipper.ioStrictlySimple = 2;\n\t  ClipperLib.Clipper.ioPreserveCollinear = 4;\n\t\n\t  ClipperLib.Clipper.prototype.Clear = function ()\n\t  {\n\t    if (this.m_edges.length === 0)\n\t      return;\n\t    //avoids problems with ClipperBase destructor\n\t    this.DisposeAllPolyPts();\n\t    ClipperLib.ClipperBase.prototype.Clear.call(this);\n\t  };\n\t\n\t  ClipperLib.Clipper.prototype.DisposeScanbeamList = function ()\n\t  {\n\t    while (this.m_Scanbeam !== null)\n\t    {\n\t      var sb2 = this.m_Scanbeam.Next;\n\t      this.m_Scanbeam = null;\n\t      this.m_Scanbeam = sb2;\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.Reset = function ()\n\t  {\n\t    ClipperLib.ClipperBase.prototype.Reset.call(this);\n\t    this.m_Scanbeam = null;\n\t    this.m_ActiveEdges = null;\n\t    this.m_SortedEdges = null;\n\t\n\t    var lm = this.m_MinimaList;\n\t    while (lm !== null)\n\t    {\n\t      this.InsertScanbeam(lm.Y);\n\t      lm = lm.Next;\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.InsertScanbeam = function (Y)\n\t  {\n\t    if (this.m_Scanbeam === null)\n\t    {\n\t      this.m_Scanbeam = new ClipperLib.Scanbeam();\n\t      this.m_Scanbeam.Next = null;\n\t      this.m_Scanbeam.Y = Y;\n\t    }\n\t    else if (Y > this.m_Scanbeam.Y)\n\t    {\n\t      var newSb = new ClipperLib.Scanbeam();\n\t      newSb.Y = Y;\n\t      newSb.Next = this.m_Scanbeam;\n\t      this.m_Scanbeam = newSb;\n\t    }\n\t    else\n\t    {\n\t      var sb2 = this.m_Scanbeam;\n\t      while (sb2.Next !== null && (Y <= sb2.Next.Y))\n\t        sb2 = sb2.Next;\n\t      if (Y == sb2.Y)\n\t        return;\n\t      //ie ignores duplicates\n\t      var newSb = new ClipperLib.Scanbeam();\n\t      newSb.Y = Y;\n\t      newSb.Next = sb2.Next;\n\t      sb2.Next = newSb;\n\t    }\n\t  };\n\t  // ************************************\n\t  ClipperLib.Clipper.prototype.Execute = function ()\n\t  {\n\t    var a = arguments,\n\t      alen = a.length,\n\t      ispolytree = a[1] instanceof ClipperLib.PolyTree;\n\t    if (alen == 4 && !ispolytree) // function (clipType, solution, subjFillType, clipFillType)\n\t    {\n\t      var clipType = a[0],\n\t        solution = a[1],\n\t        subjFillType = a[2],\n\t        clipFillType = a[3];\n\t      if (this.m_ExecuteLocked)\n\t        return false;\n\t      if (this.m_HasOpenPaths)\n\t        ClipperLib.Error(\"Error: PolyTree struct is need for open path clipping.\");\n\t      this.m_ExecuteLocked = true;\n\t      ClipperLib.Clear(solution);\n\t      this.m_SubjFillType = subjFillType;\n\t      this.m_ClipFillType = clipFillType;\n\t      this.m_ClipType = clipType;\n\t      this.m_UsingPolyTree = false;\n\t      try\n\t      {\n\t        var succeeded = this.ExecuteInternal();\n\t        //build the return polygons ...\n\t        if (succeeded) this.BuildResult(solution);\n\t      }\n\t      finally\n\t      {\n\t        this.DisposeAllPolyPts();\n\t        this.m_ExecuteLocked = false;\n\t      }\n\t      return succeeded;\n\t    }\n\t    else if (alen == 4 && ispolytree) // function (clipType, polytree, subjFillType, clipFillType)\n\t    {\n\t      var clipType = a[0],\n\t        polytree = a[1],\n\t        subjFillType = a[2],\n\t        clipFillType = a[3];\n\t      if (this.m_ExecuteLocked)\n\t        return false;\n\t      this.m_ExecuteLocked = true;\n\t      this.m_SubjFillType = subjFillType;\n\t      this.m_ClipFillType = clipFillType;\n\t      this.m_ClipType = clipType;\n\t      this.m_UsingPolyTree = true;\n\t      try\n\t      {\n\t        var succeeded = this.ExecuteInternal();\n\t        //build the return polygons ...\n\t        if (succeeded) this.BuildResult2(polytree);\n\t      }\n\t      finally\n\t      {\n\t        this.DisposeAllPolyPts();\n\t        this.m_ExecuteLocked = false;\n\t      }\n\t      return succeeded;\n\t    }\n\t    else if (alen == 2 && !ispolytree) // function (clipType, solution)\n\t    {\n\t      var clipType = a[0],\n\t        solution = a[1];\n\t      return this.Execute(clipType, solution, ClipperLib.PolyFillType.pftEvenOdd, ClipperLib.PolyFillType.pftEvenOdd);\n\t    }\n\t    else if (alen == 2 && ispolytree) // function (clipType, polytree)\n\t    {\n\t      var clipType = a[0],\n\t        polytree = a[1];\n\t      return this.Execute(clipType, polytree, ClipperLib.PolyFillType.pftEvenOdd, ClipperLib.PolyFillType.pftEvenOdd);\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.FixHoleLinkage = function (outRec)\n\t  {\n\t    //skip if an outermost polygon or\n\t    //already already points to the correct FirstLeft ...\n\t    if (outRec.FirstLeft === null || (outRec.IsHole != outRec.FirstLeft.IsHole && outRec.FirstLeft.Pts !== null))\n\t      return;\n\t    var orfl = outRec.FirstLeft;\n\t    while (orfl !== null && ((orfl.IsHole == outRec.IsHole) || orfl.Pts === null))\n\t      orfl = orfl.FirstLeft;\n\t    outRec.FirstLeft = orfl;\n\t  };\n\t  ClipperLib.Clipper.prototype.ExecuteInternal = function ()\n\t  {\n\t    try\n\t    {\n\t      this.Reset();\n\t      if (this.m_CurrentLM === null)\n\t        return false;\n\t      var botY = this.PopScanbeam();\n\t      do {\n\t        this.InsertLocalMinimaIntoAEL(botY);\n\t        ClipperLib.Clear(this.m_GhostJoins);\n\t        this.ProcessHorizontals(false);\n\t        if (this.m_Scanbeam === null)\n\t          break;\n\t        var topY = this.PopScanbeam();\n\t        if (!this.ProcessIntersections(topY)) return false;\n\t\n\t        this.ProcessEdgesAtTopOfScanbeam(topY);\n\t        botY = topY;\n\t      }\n\t      while (this.m_Scanbeam !== null || this.m_CurrentLM !== null)\n\t      //fix orientations ...\n\t      for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n\t      {\n\t        var outRec = this.m_PolyOuts[i];\n\t        if (outRec.Pts === null || outRec.IsOpen)\n\t          continue;\n\t        if ((outRec.IsHole ^ this.ReverseSolution) == (this.Area(outRec) > 0))\n\t          this.ReversePolyPtLinks(outRec.Pts);\n\t      }\n\t      this.JoinCommonEdges();\n\t      for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n\t      {\n\t        var outRec = this.m_PolyOuts[i];\n\t        if (outRec.Pts !== null && !outRec.IsOpen)\n\t          this.FixupOutPolygon(outRec);\n\t      }\n\t      if (this.StrictlySimple)\n\t        this.DoSimplePolygons();\n\t      return true;\n\t    }\n\t    finally\n\t    {\n\t      ClipperLib.Clear(this.m_Joins);\n\t      ClipperLib.Clear(this.m_GhostJoins);\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.PopScanbeam = function ()\n\t  {\n\t    var Y = this.m_Scanbeam.Y;\n\t    this.m_Scanbeam = this.m_Scanbeam.Next;\n\t    return Y;\n\t  };\n\t\n\t  ClipperLib.Clipper.prototype.DisposeAllPolyPts = function ()\n\t  {\n\t    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; ++i)\n\t      this.DisposeOutRec(i);\n\t    ClipperLib.Clear(this.m_PolyOuts);\n\t  };\n\t  ClipperLib.Clipper.prototype.DisposeOutRec = function (index)\n\t  {\n\t    var outRec = this.m_PolyOuts[index];\n\t    outRec.Pts = null;\n\t    outRec = null;\n\t    this.m_PolyOuts[index] = null;\n\t  };\n\t\n\t  ClipperLib.Clipper.prototype.AddJoin = function (Op1, Op2, OffPt)\n\t  {\n\t    var j = new ClipperLib.Join();\n\t    j.OutPt1 = Op1;\n\t    j.OutPt2 = Op2;\n\t    //j.OffPt = OffPt;\n\t    j.OffPt.X = OffPt.X;\n\t    j.OffPt.Y = OffPt.Y;\n\t    this.m_Joins.push(j);\n\t  };\n\t  ClipperLib.Clipper.prototype.AddGhostJoin = function (Op, OffPt)\n\t  {\n\t    var j = new ClipperLib.Join();\n\t    j.OutPt1 = Op;\n\t    //j.OffPt = OffPt;\n\t    j.OffPt.X = OffPt.X;\n\t    j.OffPt.Y = OffPt.Y;\n\t    this.m_GhostJoins.push(j);\n\t  };\n\t  if (use_xyz)\n\t  {\n\t    ClipperLib.Clipper.prototype.SetZ = function (pt, e1, e2)\n\t    {\n\t      if (this.ZFillFunction !== null)\n\t      {\n\t        if (pt.Z != 0 || this.ZFillFunction === null) return;\n\t        else if (ClipperLib.IntPoint.op_Equality(pt, e1.Bot)) pt.Z = e1.Bot.Z;\n\t        else if (ClipperLib.IntPoint.op_Equality(pt, e1.Top)) pt.Z = e1.Top.Z;\n\t        else if (ClipperLib.IntPoint.op_Equality(pt, e2.Bot)) pt.Z = e2.Bot.Z;\n\t        else if (ClipperLib.IntPoint.op_Equality(pt, e2.Top)) pt.Z = e2.Top.Z;\n\t        else ZFillFunction(e1.Bot, e1.Top, e2.Bot, e2.Top, pt);\n\t      }\n\t    };\n\t\n\t    //------------------------------------------------------------------------------\n\t  }\n\t\n\t  ClipperLib.Clipper.prototype.InsertLocalMinimaIntoAEL = function (botY)\n\t  {\n\t    while (this.m_CurrentLM !== null && (this.m_CurrentLM.Y == botY))\n\t    {\n\t      var lb = this.m_CurrentLM.LeftBound;\n\t      var rb = this.m_CurrentLM.RightBound;\n\t      this.PopLocalMinima();\n\t      var Op1 = null;\n\t      if (lb === null)\n\t      {\n\t        this.InsertEdgeIntoAEL(rb, null);\n\t        this.SetWindingCount(rb);\n\t        if (this.IsContributing(rb))\n\t          Op1 = this.AddOutPt(rb, rb.Bot);\n\t      }\n\t      else if (rb == null)\n\t      {\n\t        this.InsertEdgeIntoAEL(lb, null);\n\t        this.SetWindingCount(lb);\n\t        if (this.IsContributing(lb))\n\t          Op1 = this.AddOutPt(lb, lb.Bot);\n\t        this.InsertScanbeam(lb.Top.Y);\n\t      }\n\t      else\n\t      {\n\t        this.InsertEdgeIntoAEL(lb, null);\n\t        this.InsertEdgeIntoAEL(rb, lb);\n\t        this.SetWindingCount(lb);\n\t        rb.WindCnt = lb.WindCnt;\n\t        rb.WindCnt2 = lb.WindCnt2;\n\t        if (this.IsContributing(lb))\n\t          Op1 = this.AddLocalMinPoly(lb, rb, lb.Bot);\n\t        this.InsertScanbeam(lb.Top.Y);\n\t      }\n\t      if (rb != null)\n\t      {\n\t        if (ClipperLib.ClipperBase.IsHorizontal(rb))\n\t          this.AddEdgeToSEL(rb);\n\t        else\n\t          this.InsertScanbeam(rb.Top.Y);\n\t      }\n\t      if (lb == null || rb == null) continue;\n\t      //if output polygons share an Edge with a horizontal rb, they'll need joining later ...\n\t      if (Op1 !== null && ClipperLib.ClipperBase.IsHorizontal(rb) && this.m_GhostJoins.length > 0 && rb.WindDelta !== 0)\n\t      {\n\t        for (var i = 0, ilen = this.m_GhostJoins.length; i < ilen; i++)\n\t        {\n\t          //if the horizontal Rb and a 'ghost' horizontal overlap, then convert\n\t          //the 'ghost' join to a real join ready for later ...\n\t          var j = this.m_GhostJoins[i];\n\t\n\t\t\t\t\t\tif (this.HorzSegmentsOverlap(j.OutPt1.Pt.X, j.OffPt.X, rb.Bot.X, rb.Top.X))\n\t            this.AddJoin(j.OutPt1, Op1, j.OffPt);\n\t        }\n\t      }\n\t      if (lb.OutIdx >= 0 && lb.PrevInAEL !== null &&\n\t        lb.PrevInAEL.Curr.X == lb.Bot.X &&\n\t        lb.PrevInAEL.OutIdx >= 0 &&\n\t        ClipperLib.ClipperBase.SlopesEqual(lb.PrevInAEL, lb, this.m_UseFullRange) &&\n\t        lb.WindDelta !== 0 && lb.PrevInAEL.WindDelta !== 0)\n\t      {\n\t        var Op2 = this.AddOutPt(lb.PrevInAEL, lb.Bot);\n\t        this.AddJoin(Op1, Op2, lb.Top);\n\t      }\n\t      if (lb.NextInAEL != rb)\n\t      {\n\t        if (rb.OutIdx >= 0 && rb.PrevInAEL.OutIdx >= 0 &&\n\t          ClipperLib.ClipperBase.SlopesEqual(rb.PrevInAEL, rb, this.m_UseFullRange) &&\n\t          rb.WindDelta !== 0 && rb.PrevInAEL.WindDelta !== 0)\n\t        {\n\t          var Op2 = this.AddOutPt(rb.PrevInAEL, rb.Bot);\n\t          this.AddJoin(Op1, Op2, rb.Top);\n\t        }\n\t        var e = lb.NextInAEL;\n\t        if (e !== null)\n\t          while (e != rb)\n\t          {\n\t            //nb: For calculating winding counts etc, IntersectEdges() assumes\n\t            //that param1 will be to the right of param2 ABOVE the intersection ...\n\t            this.IntersectEdges(rb, e, lb.Curr, false);\n\t            //order important here\n\t            e = e.NextInAEL;\n\t          }\n\t      }\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.InsertEdgeIntoAEL = function (edge, startEdge)\n\t  {\n\t    if (this.m_ActiveEdges === null)\n\t    {\n\t      edge.PrevInAEL = null;\n\t      edge.NextInAEL = null;\n\t      this.m_ActiveEdges = edge;\n\t    }\n\t    else if (startEdge === null && this.E2InsertsBeforeE1(this.m_ActiveEdges, edge))\n\t    {\n\t      edge.PrevInAEL = null;\n\t      edge.NextInAEL = this.m_ActiveEdges;\n\t      this.m_ActiveEdges.PrevInAEL = edge;\n\t      this.m_ActiveEdges = edge;\n\t    }\n\t    else\n\t    {\n\t      if (startEdge === null)\n\t        startEdge = this.m_ActiveEdges;\n\t      while (startEdge.NextInAEL !== null && !this.E2InsertsBeforeE1(startEdge.NextInAEL, edge))\n\t        startEdge = startEdge.NextInAEL;\n\t      edge.NextInAEL = startEdge.NextInAEL;\n\t      if (startEdge.NextInAEL !== null)\n\t        startEdge.NextInAEL.PrevInAEL = edge;\n\t      edge.PrevInAEL = startEdge;\n\t      startEdge.NextInAEL = edge;\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.E2InsertsBeforeE1 = function (e1, e2)\n\t  {\n\t    if (e2.Curr.X == e1.Curr.X)\n\t    {\n\t      if (e2.Top.Y > e1.Top.Y)\n\t        return e2.Top.X < ClipperLib.Clipper.TopX(e1, e2.Top.Y);\n\t      else\n\t        return e1.Top.X > ClipperLib.Clipper.TopX(e2, e1.Top.Y);\n\t    }\n\t    else\n\t      return e2.Curr.X < e1.Curr.X;\n\t  };\n\t  ClipperLib.Clipper.prototype.IsEvenOddFillType = function (edge)\n\t  {\n\t    if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)\n\t      return this.m_SubjFillType == ClipperLib.PolyFillType.pftEvenOdd;\n\t    else\n\t      return this.m_ClipFillType == ClipperLib.PolyFillType.pftEvenOdd;\n\t  };\n\t  ClipperLib.Clipper.prototype.IsEvenOddAltFillType = function (edge)\n\t  {\n\t    if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)\n\t      return this.m_ClipFillType == ClipperLib.PolyFillType.pftEvenOdd;\n\t    else\n\t      return this.m_SubjFillType == ClipperLib.PolyFillType.pftEvenOdd;\n\t  };\n\t  ClipperLib.Clipper.prototype.IsContributing = function (edge)\n\t  {\n\t    var pft, pft2;\n\t    if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)\n\t    {\n\t      pft = this.m_SubjFillType;\n\t      pft2 = this.m_ClipFillType;\n\t    }\n\t    else\n\t    {\n\t      pft = this.m_ClipFillType;\n\t      pft2 = this.m_SubjFillType;\n\t    }\n\t    switch (pft)\n\t    {\n\t    case ClipperLib.PolyFillType.pftEvenOdd:\n\t      if (edge.WindDelta === 0 && edge.WindCnt != 1)\n\t        return false;\n\t      break;\n\t    case ClipperLib.PolyFillType.pftNonZero:\n\t      if (Math.abs(edge.WindCnt) != 1)\n\t        return false;\n\t      break;\n\t    case ClipperLib.PolyFillType.pftPositive:\n\t      if (edge.WindCnt != 1)\n\t        return false;\n\t      break;\n\t    default:\n\t      if (edge.WindCnt != -1)\n\t        return false;\n\t      break;\n\t    }\n\t    switch (this.m_ClipType)\n\t    {\n\t    case ClipperLib.ClipType.ctIntersection:\n\t      switch (pft2)\n\t      {\n\t      case ClipperLib.PolyFillType.pftEvenOdd:\n\t      case ClipperLib.PolyFillType.pftNonZero:\n\t        return (edge.WindCnt2 !== 0);\n\t      case ClipperLib.PolyFillType.pftPositive:\n\t        return (edge.WindCnt2 > 0);\n\t      default:\n\t        return (edge.WindCnt2 < 0);\n\t      }\n\t    case ClipperLib.ClipType.ctUnion:\n\t      switch (pft2)\n\t      {\n\t      case ClipperLib.PolyFillType.pftEvenOdd:\n\t      case ClipperLib.PolyFillType.pftNonZero:\n\t        return (edge.WindCnt2 === 0);\n\t      case ClipperLib.PolyFillType.pftPositive:\n\t        return (edge.WindCnt2 <= 0);\n\t      default:\n\t        return (edge.WindCnt2 >= 0);\n\t      }\n\t    case ClipperLib.ClipType.ctDifference:\n\t      if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)\n\t        switch (pft2)\n\t        {\n\t        case ClipperLib.PolyFillType.pftEvenOdd:\n\t        case ClipperLib.PolyFillType.pftNonZero:\n\t          return (edge.WindCnt2 === 0);\n\t        case ClipperLib.PolyFillType.pftPositive:\n\t          return (edge.WindCnt2 <= 0);\n\t        default:\n\t          return (edge.WindCnt2 >= 0);\n\t        }\n\t      else\n\t        switch (pft2)\n\t        {\n\t        case ClipperLib.PolyFillType.pftEvenOdd:\n\t        case ClipperLib.PolyFillType.pftNonZero:\n\t          return (edge.WindCnt2 !== 0);\n\t        case ClipperLib.PolyFillType.pftPositive:\n\t          return (edge.WindCnt2 > 0);\n\t        default:\n\t          return (edge.WindCnt2 < 0);\n\t        }\n\t    case ClipperLib.ClipType.ctXor:\n\t      if (edge.WindDelta === 0)\n\t        switch (pft2)\n\t        {\n\t        case ClipperLib.PolyFillType.pftEvenOdd:\n\t        case ClipperLib.PolyFillType.pftNonZero:\n\t          return (edge.WindCnt2 === 0);\n\t        case ClipperLib.PolyFillType.pftPositive:\n\t          return (edge.WindCnt2 <= 0);\n\t        default:\n\t          return (edge.WindCnt2 >= 0);\n\t        }\n\t      else\n\t        return true;\n\t    }\n\t    return true;\n\t  };\n\t  ClipperLib.Clipper.prototype.SetWindingCount = function (edge)\n\t  {\n\t    var e = edge.PrevInAEL;\n\t    //find the edge of the same polytype that immediately preceeds 'edge' in AEL\n\t    while (e !== null && ((e.PolyTyp != edge.PolyTyp) || (e.WindDelta === 0)))\n\t      e = e.PrevInAEL;\n\t    if (e === null)\n\t    {\n\t      edge.WindCnt = (edge.WindDelta === 0 ? 1 : edge.WindDelta);\n\t      edge.WindCnt2 = 0;\n\t      e = this.m_ActiveEdges;\n\t      //ie get ready to calc WindCnt2\n\t    }\n\t    else if (edge.WindDelta === 0 && this.m_ClipType != ClipperLib.ClipType.ctUnion)\n\t    {\n\t      edge.WindCnt = 1;\n\t      edge.WindCnt2 = e.WindCnt2;\n\t      e = e.NextInAEL;\n\t      //ie get ready to calc WindCnt2\n\t    }\n\t    else if (this.IsEvenOddFillType(edge))\n\t    {\n\t      //EvenOdd filling ...\n\t      if (edge.WindDelta === 0)\n\t      {\n\t        //are we inside a subj polygon ...\n\t        var Inside = true;\n\t        var e2 = e.PrevInAEL;\n\t        while (e2 !== null)\n\t        {\n\t          if (e2.PolyTyp == e.PolyTyp && e2.WindDelta !== 0)\n\t            Inside = !Inside;\n\t          e2 = e2.PrevInAEL;\n\t        }\n\t        edge.WindCnt = (Inside ? 0 : 1);\n\t      }\n\t      else\n\t      {\n\t        edge.WindCnt = edge.WindDelta;\n\t      }\n\t      edge.WindCnt2 = e.WindCnt2;\n\t      e = e.NextInAEL;\n\t      //ie get ready to calc WindCnt2\n\t    }\n\t    else\n\t    {\n\t      //nonZero, Positive or Negative filling ...\n\t      if (e.WindCnt * e.WindDelta < 0)\n\t      {\n\t        //prev edge is 'decreasing' WindCount (WC) toward zero\n\t        //so we're outside the previous polygon ...\n\t        if (Math.abs(e.WindCnt) > 1)\n\t        {\n\t          //outside prev poly but still inside another.\n\t          //when reversing direction of prev poly use the same WC\n\t          if (e.WindDelta * edge.WindDelta < 0)\n\t            edge.WindCnt = e.WindCnt;\n\t          else\n\t            edge.WindCnt = e.WindCnt + edge.WindDelta;\n\t        }\n\t        else\n\t          edge.WindCnt = (edge.WindDelta === 0 ? 1 : edge.WindDelta);\n\t      }\n\t      else\n\t      {\n\t        //prev edge is 'increasing' WindCount (WC) away from zero\n\t        //so we're inside the previous polygon ...\n\t        if (edge.WindDelta === 0)\n\t          edge.WindCnt = (e.WindCnt < 0 ? e.WindCnt - 1 : e.WindCnt + 1);\n\t        else if (e.WindDelta * edge.WindDelta < 0)\n\t          edge.WindCnt = e.WindCnt;\n\t        else\n\t          edge.WindCnt = e.WindCnt + edge.WindDelta;\n\t      }\n\t      edge.WindCnt2 = e.WindCnt2;\n\t      e = e.NextInAEL;\n\t      //ie get ready to calc WindCnt2\n\t    }\n\t    //update WindCnt2 ...\n\t    if (this.IsEvenOddAltFillType(edge))\n\t    {\n\t      //EvenOdd filling ...\n\t      while (e != edge)\n\t      {\n\t        if (e.WindDelta !== 0)\n\t          edge.WindCnt2 = (edge.WindCnt2 === 0 ? 1 : 0);\n\t        e = e.NextInAEL;\n\t      }\n\t    }\n\t    else\n\t    {\n\t      //nonZero, Positive or Negative filling ...\n\t      while (e != edge)\n\t      {\n\t        edge.WindCnt2 += e.WindDelta;\n\t        e = e.NextInAEL;\n\t      }\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.AddEdgeToSEL = function (edge)\n\t  {\n\t    //SEL pointers in PEdge are reused to build a list of horizontal edges.\n\t    //However, we don't need to worry about order with horizontal edge processing.\n\t    if (this.m_SortedEdges === null)\n\t    {\n\t      this.m_SortedEdges = edge;\n\t      edge.PrevInSEL = null;\n\t      edge.NextInSEL = null;\n\t    }\n\t    else\n\t    {\n\t      edge.NextInSEL = this.m_SortedEdges;\n\t      edge.PrevInSEL = null;\n\t      this.m_SortedEdges.PrevInSEL = edge;\n\t      this.m_SortedEdges = edge;\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.CopyAELToSEL = function ()\n\t  {\n\t    var e = this.m_ActiveEdges;\n\t    this.m_SortedEdges = e;\n\t    while (e !== null)\n\t    {\n\t      e.PrevInSEL = e.PrevInAEL;\n\t      e.NextInSEL = e.NextInAEL;\n\t      e = e.NextInAEL;\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.SwapPositionsInAEL = function (edge1, edge2)\n\t  {\n\t    //check that one or other edge hasn't already been removed from AEL ...\n\t    if (edge1.NextInAEL == edge1.PrevInAEL || edge2.NextInAEL == edge2.PrevInAEL)\n\t      return;\n\t    if (edge1.NextInAEL == edge2)\n\t    {\n\t      var next = edge2.NextInAEL;\n\t      if (next !== null)\n\t        next.PrevInAEL = edge1;\n\t      var prev = edge1.PrevInAEL;\n\t      if (prev !== null)\n\t        prev.NextInAEL = edge2;\n\t      edge2.PrevInAEL = prev;\n\t      edge2.NextInAEL = edge1;\n\t      edge1.PrevInAEL = edge2;\n\t      edge1.NextInAEL = next;\n\t    }\n\t    else if (edge2.NextInAEL == edge1)\n\t    {\n\t      var next = edge1.NextInAEL;\n\t      if (next !== null)\n\t        next.PrevInAEL = edge2;\n\t      var prev = edge2.PrevInAEL;\n\t      if (prev !== null)\n\t        prev.NextInAEL = edge1;\n\t      edge1.PrevInAEL = prev;\n\t      edge1.NextInAEL = edge2;\n\t      edge2.PrevInAEL = edge1;\n\t      edge2.NextInAEL = next;\n\t    }\n\t    else\n\t    {\n\t      var next = edge1.NextInAEL;\n\t      var prev = edge1.PrevInAEL;\n\t      edge1.NextInAEL = edge2.NextInAEL;\n\t      if (edge1.NextInAEL !== null)\n\t        edge1.NextInAEL.PrevInAEL = edge1;\n\t      edge1.PrevInAEL = edge2.PrevInAEL;\n\t      if (edge1.PrevInAEL !== null)\n\t        edge1.PrevInAEL.NextInAEL = edge1;\n\t      edge2.NextInAEL = next;\n\t      if (edge2.NextInAEL !== null)\n\t        edge2.NextInAEL.PrevInAEL = edge2;\n\t      edge2.PrevInAEL = prev;\n\t      if (edge2.PrevInAEL !== null)\n\t        edge2.PrevInAEL.NextInAEL = edge2;\n\t    }\n\t    if (edge1.PrevInAEL === null)\n\t      this.m_ActiveEdges = edge1;\n\t    else if (edge2.PrevInAEL === null)\n\t      this.m_ActiveEdges = edge2;\n\t  };\n\t  ClipperLib.Clipper.prototype.SwapPositionsInSEL = function (edge1, edge2)\n\t  {\n\t    if (edge1.NextInSEL === null && edge1.PrevInSEL === null)\n\t      return;\n\t    if (edge2.NextInSEL === null && edge2.PrevInSEL === null)\n\t      return;\n\t    if (edge1.NextInSEL == edge2)\n\t    {\n\t      var next = edge2.NextInSEL;\n\t      if (next !== null)\n\t        next.PrevInSEL = edge1;\n\t      var prev = edge1.PrevInSEL;\n\t      if (prev !== null)\n\t        prev.NextInSEL = edge2;\n\t      edge2.PrevInSEL = prev;\n\t      edge2.NextInSEL = edge1;\n\t      edge1.PrevInSEL = edge2;\n\t      edge1.NextInSEL = next;\n\t    }\n\t    else if (edge2.NextInSEL == edge1)\n\t    {\n\t      var next = edge1.NextInSEL;\n\t      if (next !== null)\n\t        next.PrevInSEL = edge2;\n\t      var prev = edge2.PrevInSEL;\n\t      if (prev !== null)\n\t        prev.NextInSEL = edge1;\n\t      edge1.PrevInSEL = prev;\n\t      edge1.NextInSEL = edge2;\n\t      edge2.PrevInSEL = edge1;\n\t      edge2.NextInSEL = next;\n\t    }\n\t    else\n\t    {\n\t      var next = edge1.NextInSEL;\n\t      var prev = edge1.PrevInSEL;\n\t      edge1.NextInSEL = edge2.NextInSEL;\n\t      if (edge1.NextInSEL !== null)\n\t        edge1.NextInSEL.PrevInSEL = edge1;\n\t      edge1.PrevInSEL = edge2.PrevInSEL;\n\t      if (edge1.PrevInSEL !== null)\n\t        edge1.PrevInSEL.NextInSEL = edge1;\n\t      edge2.NextInSEL = next;\n\t      if (edge2.NextInSEL !== null)\n\t        edge2.NextInSEL.PrevInSEL = edge2;\n\t      edge2.PrevInSEL = prev;\n\t      if (edge2.PrevInSEL !== null)\n\t        edge2.PrevInSEL.NextInSEL = edge2;\n\t    }\n\t    if (edge1.PrevInSEL === null)\n\t      this.m_SortedEdges = edge1;\n\t    else if (edge2.PrevInSEL === null)\n\t      this.m_SortedEdges = edge2;\n\t  };\n\t  ClipperLib.Clipper.prototype.AddLocalMaxPoly = function (e1, e2, pt)\n\t  {\n\t    this.AddOutPt(e1, pt);\n\t    if (e2.WindDelta == 0) this.AddOutPt(e2, pt);\n\t    if (e1.OutIdx == e2.OutIdx)\n\t    {\n\t      e1.OutIdx = -1;\n\t      e2.OutIdx = -1;\n\t    }\n\t    else if (e1.OutIdx < e2.OutIdx)\n\t      this.AppendPolygon(e1, e2);\n\t    else\n\t      this.AppendPolygon(e2, e1);\n\t  };\n\t  ClipperLib.Clipper.prototype.AddLocalMinPoly = function (e1, e2, pt)\n\t  {\n\t    var result;\n\t    var e, prevE;\n\t    if (ClipperLib.ClipperBase.IsHorizontal(e2) || (e1.Dx > e2.Dx))\n\t    {\n\t      result = this.AddOutPt(e1, pt);\n\t      e2.OutIdx = e1.OutIdx;\n\t      e1.Side = ClipperLib.EdgeSide.esLeft;\n\t      e2.Side = ClipperLib.EdgeSide.esRight;\n\t      e = e1;\n\t      if (e.PrevInAEL == e2)\n\t        prevE = e2.PrevInAEL;\n\t      else\n\t        prevE = e.PrevInAEL;\n\t    }\n\t    else\n\t    {\n\t      result = this.AddOutPt(e2, pt);\n\t      e1.OutIdx = e2.OutIdx;\n\t      e1.Side = ClipperLib.EdgeSide.esRight;\n\t      e2.Side = ClipperLib.EdgeSide.esLeft;\n\t      e = e2;\n\t      if (e.PrevInAEL == e1)\n\t        prevE = e1.PrevInAEL;\n\t      else\n\t        prevE = e.PrevInAEL;\n\t    }\n\t    if (prevE !== null && prevE.OutIdx >= 0 && (ClipperLib.Clipper.TopX(prevE, pt.Y) == ClipperLib.Clipper.TopX(e, pt.Y)) && ClipperLib.ClipperBase.SlopesEqual(e, prevE, this.m_UseFullRange) && (e.WindDelta !== 0) && (prevE.WindDelta !== 0))\n\t    {\n\t      var outPt = this.AddOutPt(prevE, pt);\n\t      this.AddJoin(result, outPt, e.Top);\n\t    }\n\t    return result;\n\t  };\n\t  ClipperLib.Clipper.prototype.CreateOutRec = function ()\n\t  {\n\t    var result = new ClipperLib.OutRec();\n\t    result.Idx = -1;\n\t    result.IsHole = false;\n\t    result.IsOpen = false;\n\t    result.FirstLeft = null;\n\t    result.Pts = null;\n\t    result.BottomPt = null;\n\t    result.PolyNode = null;\n\t    this.m_PolyOuts.push(result);\n\t    result.Idx = this.m_PolyOuts.length - 1;\n\t    return result;\n\t  };\n\t  ClipperLib.Clipper.prototype.AddOutPt = function (e, pt)\n\t  {\n\t    var ToFront = (e.Side == ClipperLib.EdgeSide.esLeft);\n\t    if (e.OutIdx < 0)\n\t    {\n\t      var outRec = this.CreateOutRec();\n\t      outRec.IsOpen = (e.WindDelta === 0);\n\t      var newOp = new ClipperLib.OutPt();\n\t      outRec.Pts = newOp;\n\t      newOp.Idx = outRec.Idx;\n\t      //newOp.Pt = pt;\n\t      newOp.Pt.X = pt.X;\n\t      newOp.Pt.Y = pt.Y;\n\t      newOp.Next = newOp;\n\t      newOp.Prev = newOp;\n\t      if (!outRec.IsOpen)\n\t        this.SetHoleState(e, outRec);\n\t      e.OutIdx = outRec.Idx;\n\t      //nb: do this after SetZ !\n\t      return newOp;\n\t    }\n\t    else\n\t    {\n\t      var outRec = this.m_PolyOuts[e.OutIdx];\n\t      //OutRec.Pts is the 'Left-most' point & OutRec.Pts.Prev is the 'Right-most'\n\t      var op = outRec.Pts;\n\t      if (ToFront && ClipperLib.IntPoint.op_Equality(pt, op.Pt))\n\t        return op;\n\t      else if (!ToFront && ClipperLib.IntPoint.op_Equality(pt, op.Prev.Pt))\n\t        return op.Prev;\n\t      var newOp = new ClipperLib.OutPt();\n\t      newOp.Idx = outRec.Idx;\n\t      //newOp.Pt = pt;\n\t      newOp.Pt.X = pt.X;\n\t      newOp.Pt.Y = pt.Y;\n\t      newOp.Next = op;\n\t      newOp.Prev = op.Prev;\n\t      newOp.Prev.Next = newOp;\n\t      op.Prev = newOp;\n\t      if (ToFront)\n\t        outRec.Pts = newOp;\n\t      return newOp;\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.SwapPoints = function (pt1, pt2)\n\t  {\n\t    var tmp = new ClipperLib.IntPoint(pt1.Value);\n\t    //pt1.Value = pt2.Value;\n\t    pt1.Value.X = pt2.Value.X;\n\t    pt1.Value.Y = pt2.Value.Y;\n\t    //pt2.Value = tmp;\n\t    pt2.Value.X = tmp.X;\n\t    pt2.Value.Y = tmp.Y;\n\t  };\n\t  ClipperLib.Clipper.prototype.HorzSegmentsOverlap = function (seg1a, seg1b, seg2a, seg2b)\n\t\t{\n\t\t\tvar tmp;\n\t\t\tif (seg1a > seg1b)\n\t\t\t{\n\t\t\t\ttmp = seg1a;\n\t\t\t\tseg1a = seg1b;\n\t\t\t\tseg1b = tmp;\n\t\t\t}\n\t\t\tif (seg2a > seg2b)\n\t\t\t{\n\t\t\t\ttmp = seg2a;\n\t\t\t\tseg2a = seg2b;\n\t\t\t\tseg2b = tmp;\n\t\t\t}\n\t\t\treturn (seg1a < seg2b) && (seg2a < seg1b);\n\t\t}\n\t\n\t  ClipperLib.Clipper.prototype.SetHoleState = function (e, outRec)\n\t  {\n\t    var isHole = false;\n\t    var e2 = e.PrevInAEL;\n\t    while (e2 !== null)\n\t    {\n\t      if (e2.OutIdx >= 0 && e2.WindDelta != 0)\n\t      {\n\t        isHole = !isHole;\n\t        if (outRec.FirstLeft === null)\n\t          outRec.FirstLeft = this.m_PolyOuts[e2.OutIdx];\n\t      }\n\t      e2 = e2.PrevInAEL;\n\t    }\n\t    if (isHole)\n\t      outRec.IsHole = true;\n\t  };\n\t  ClipperLib.Clipper.prototype.GetDx = function (pt1, pt2)\n\t  {\n\t    if (pt1.Y == pt2.Y)\n\t      return ClipperLib.ClipperBase.horizontal;\n\t    else\n\t      return (pt2.X - pt1.X) / (pt2.Y - pt1.Y);\n\t  };\n\t  ClipperLib.Clipper.prototype.FirstIsBottomPt = function (btmPt1, btmPt2)\n\t  {\n\t    var p = btmPt1.Prev;\n\t    while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt1.Pt)) && (p != btmPt1))\n\t      p = p.Prev;\n\t    var dx1p = Math.abs(this.GetDx(btmPt1.Pt, p.Pt));\n\t    p = btmPt1.Next;\n\t    while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt1.Pt)) && (p != btmPt1))\n\t      p = p.Next;\n\t    var dx1n = Math.abs(this.GetDx(btmPt1.Pt, p.Pt));\n\t    p = btmPt2.Prev;\n\t    while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt2.Pt)) && (p != btmPt2))\n\t      p = p.Prev;\n\t    var dx2p = Math.abs(this.GetDx(btmPt2.Pt, p.Pt));\n\t    p = btmPt2.Next;\n\t    while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt2.Pt)) && (p != btmPt2))\n\t      p = p.Next;\n\t    var dx2n = Math.abs(this.GetDx(btmPt2.Pt, p.Pt));\n\t    return (dx1p >= dx2p && dx1p >= dx2n) || (dx1n >= dx2p && dx1n >= dx2n);\n\t  };\n\t  ClipperLib.Clipper.prototype.GetBottomPt = function (pp)\n\t  {\n\t    var dups = null;\n\t    var p = pp.Next;\n\t    while (p != pp)\n\t    {\n\t      if (p.Pt.Y > pp.Pt.Y)\n\t      {\n\t        pp = p;\n\t        dups = null;\n\t      }\n\t      else if (p.Pt.Y == pp.Pt.Y && p.Pt.X <= pp.Pt.X)\n\t      {\n\t        if (p.Pt.X < pp.Pt.X)\n\t        {\n\t          dups = null;\n\t          pp = p;\n\t        }\n\t        else\n\t        {\n\t          if (p.Next != pp && p.Prev != pp)\n\t            dups = p;\n\t        }\n\t      }\n\t      p = p.Next;\n\t    }\n\t    if (dups !== null)\n\t    {\n\t      //there appears to be at least 2 vertices at bottomPt so ...\n\t      while (dups != p)\n\t      {\n\t        if (!this.FirstIsBottomPt(p, dups))\n\t          pp = dups;\n\t        dups = dups.Next;\n\t        while (ClipperLib.IntPoint.op_Inequality(dups.Pt, pp.Pt))\n\t          dups = dups.Next;\n\t      }\n\t    }\n\t    return pp;\n\t  };\n\t  ClipperLib.Clipper.prototype.GetLowermostRec = function (outRec1, outRec2)\n\t  {\n\t    //work out which polygon fragment has the correct hole state ...\n\t    if (outRec1.BottomPt === null)\n\t      outRec1.BottomPt = this.GetBottomPt(outRec1.Pts);\n\t    if (outRec2.BottomPt === null)\n\t      outRec2.BottomPt = this.GetBottomPt(outRec2.Pts);\n\t    var bPt1 = outRec1.BottomPt;\n\t    var bPt2 = outRec2.BottomPt;\n\t    if (bPt1.Pt.Y > bPt2.Pt.Y)\n\t      return outRec1;\n\t    else if (bPt1.Pt.Y < bPt2.Pt.Y)\n\t      return outRec2;\n\t    else if (bPt1.Pt.X < bPt2.Pt.X)\n\t      return outRec1;\n\t    else if (bPt1.Pt.X > bPt2.Pt.X)\n\t      return outRec2;\n\t    else if (bPt1.Next == bPt1)\n\t      return outRec2;\n\t    else if (bPt2.Next == bPt2)\n\t      return outRec1;\n\t    else if (this.FirstIsBottomPt(bPt1, bPt2))\n\t      return outRec1;\n\t    else\n\t      return outRec2;\n\t  };\n\t  ClipperLib.Clipper.prototype.Param1RightOfParam2 = function (outRec1, outRec2)\n\t  {\n\t    do {\n\t      outRec1 = outRec1.FirstLeft;\n\t      if (outRec1 == outRec2)\n\t        return true;\n\t    }\n\t    while (outRec1 !== null)\n\t    return false;\n\t  };\n\t  ClipperLib.Clipper.prototype.GetOutRec = function (idx)\n\t  {\n\t    var outrec = this.m_PolyOuts[idx];\n\t    while (outrec != this.m_PolyOuts[outrec.Idx])\n\t      outrec = this.m_PolyOuts[outrec.Idx];\n\t    return outrec;\n\t  };\n\t  ClipperLib.Clipper.prototype.AppendPolygon = function (e1, e2)\n\t  {\n\t    //get the start and ends of both output polygons ...\n\t    var outRec1 = this.m_PolyOuts[e1.OutIdx];\n\t    var outRec2 = this.m_PolyOuts[e2.OutIdx];\n\t    var holeStateRec;\n\t    if (this.Param1RightOfParam2(outRec1, outRec2))\n\t      holeStateRec = outRec2;\n\t    else if (this.Param1RightOfParam2(outRec2, outRec1))\n\t      holeStateRec = outRec1;\n\t    else\n\t      holeStateRec = this.GetLowermostRec(outRec1, outRec2);\n\t    var p1_lft = outRec1.Pts;\n\t    var p1_rt = p1_lft.Prev;\n\t    var p2_lft = outRec2.Pts;\n\t    var p2_rt = p2_lft.Prev;\n\t    var side;\n\t    //join e2 poly onto e1 poly and delete pointers to e2 ...\n\t    if (e1.Side == ClipperLib.EdgeSide.esLeft)\n\t    {\n\t      if (e2.Side == ClipperLib.EdgeSide.esLeft)\n\t      {\n\t        //z y x a b c\n\t        this.ReversePolyPtLinks(p2_lft);\n\t        p2_lft.Next = p1_lft;\n\t        p1_lft.Prev = p2_lft;\n\t        p1_rt.Next = p2_rt;\n\t        p2_rt.Prev = p1_rt;\n\t        outRec1.Pts = p2_rt;\n\t      }\n\t      else\n\t      {\n\t        //x y z a b c\n\t        p2_rt.Next = p1_lft;\n\t        p1_lft.Prev = p2_rt;\n\t        p2_lft.Prev = p1_rt;\n\t        p1_rt.Next = p2_lft;\n\t        outRec1.Pts = p2_lft;\n\t      }\n\t      side = ClipperLib.EdgeSide.esLeft;\n\t    }\n\t    else\n\t    {\n\t      if (e2.Side == ClipperLib.EdgeSide.esRight)\n\t      {\n\t        //a b c z y x\n\t        this.ReversePolyPtLinks(p2_lft);\n\t        p1_rt.Next = p2_rt;\n\t        p2_rt.Prev = p1_rt;\n\t        p2_lft.Next = p1_lft;\n\t        p1_lft.Prev = p2_lft;\n\t      }\n\t      else\n\t      {\n\t        //a b c x y z\n\t        p1_rt.Next = p2_lft;\n\t        p2_lft.Prev = p1_rt;\n\t        p1_lft.Prev = p2_rt;\n\t        p2_rt.Next = p1_lft;\n\t      }\n\t      side = ClipperLib.EdgeSide.esRight;\n\t    }\n\t    outRec1.BottomPt = null;\n\t    if (holeStateRec == outRec2)\n\t    {\n\t      if (outRec2.FirstLeft != outRec1)\n\t        outRec1.FirstLeft = outRec2.FirstLeft;\n\t      outRec1.IsHole = outRec2.IsHole;\n\t    }\n\t    outRec2.Pts = null;\n\t    outRec2.BottomPt = null;\n\t    outRec2.FirstLeft = outRec1;\n\t    var OKIdx = e1.OutIdx;\n\t    var ObsoleteIdx = e2.OutIdx;\n\t    e1.OutIdx = -1;\n\t    //nb: safe because we only get here via AddLocalMaxPoly\n\t    e2.OutIdx = -1;\n\t    var e = this.m_ActiveEdges;\n\t    while (e !== null)\n\t    {\n\t      if (e.OutIdx == ObsoleteIdx)\n\t      {\n\t        e.OutIdx = OKIdx;\n\t        e.Side = side;\n\t        break;\n\t      }\n\t      e = e.NextInAEL;\n\t    }\n\t    outRec2.Idx = outRec1.Idx;\n\t  };\n\t  ClipperLib.Clipper.prototype.ReversePolyPtLinks = function (pp)\n\t  {\n\t    if (pp === null)\n\t      return;\n\t    var pp1;\n\t    var pp2;\n\t    pp1 = pp;\n\t    do {\n\t      pp2 = pp1.Next;\n\t      pp1.Next = pp1.Prev;\n\t      pp1.Prev = pp2;\n\t      pp1 = pp2;\n\t    }\n\t    while (pp1 != pp)\n\t  };\n\t  ClipperLib.Clipper.SwapSides = function (edge1, edge2)\n\t  {\n\t    var side = edge1.Side;\n\t    edge1.Side = edge2.Side;\n\t    edge2.Side = side;\n\t  };\n\t  ClipperLib.Clipper.SwapPolyIndexes = function (edge1, edge2)\n\t  {\n\t    var outIdx = edge1.OutIdx;\n\t    edge1.OutIdx = edge2.OutIdx;\n\t    edge2.OutIdx = outIdx;\n\t  };\n\t  ClipperLib.Clipper.prototype.IntersectEdges = function (e1, e2, pt)\n\t  {\n\t    //e1 will be to the left of e2 BELOW the intersection. Therefore e1 is before\n\t    //e2 in AEL except when e1 is being inserted at the intersection point ...\n\t    var e1Contributing = (e1.OutIdx >= 0);\n\t    var e2Contributing = (e2.OutIdx >= 0);\n\t\n\t    if (use_xyz)\n\t    \tthis.SetZ(pt, e1, e2);\n\t\n\t    if (use_lines)\n\t    {\n\t      //if either edge is on an OPEN path ...\n\t      if (e1.WindDelta === 0 || e2.WindDelta === 0)\n\t      {\n\t        //ignore subject-subject open path intersections UNLESS they\n\t        //are both open paths, AND they are both 'contributing maximas' ...\n\t\t\t\t\tif (e1.WindDelta == 0 && e2.WindDelta == 0) return;\n\t        //if intersecting a subj line with a subj poly ...\n\t        else if (e1.PolyTyp == e2.PolyTyp &&\n\t          e1.WindDelta != e2.WindDelta && this.m_ClipType == ClipperLib.ClipType.ctUnion)\n\t        {\n\t          if (e1.WindDelta === 0)\n\t          {\n\t            if (e2Contributing)\n\t            {\n\t              this.AddOutPt(e1, pt);\n\t              if (e1Contributing)\n\t                e1.OutIdx = -1;\n\t            }\n\t          }\n\t          else\n\t          {\n\t            if (e1Contributing)\n\t            {\n\t              this.AddOutPt(e2, pt);\n\t              if (e2Contributing)\n\t                e2.OutIdx = -1;\n\t            }\n\t          }\n\t        }\n\t        else if (e1.PolyTyp != e2.PolyTyp)\n\t        {\n\t          if ((e1.WindDelta === 0) && Math.abs(e2.WindCnt) == 1 &&\n\t            (this.m_ClipType != ClipperLib.ClipType.ctUnion || e2.WindCnt2 === 0))\n\t          {\n\t            this.AddOutPt(e1, pt);\n\t            if (e1Contributing)\n\t              e1.OutIdx = -1;\n\t          }\n\t          else if ((e2.WindDelta === 0) && (Math.abs(e1.WindCnt) == 1) &&\n\t            (this.m_ClipType != ClipperLib.ClipType.ctUnion || e1.WindCnt2 === 0))\n\t          {\n\t            this.AddOutPt(e2, pt);\n\t            if (e2Contributing)\n\t              e2.OutIdx = -1;\n\t          }\n\t        }\n\t        return;\n\t      }\n\t    }\n\t    //update winding counts...\n\t    //assumes that e1 will be to the Right of e2 ABOVE the intersection\n\t    if (e1.PolyTyp == e2.PolyTyp)\n\t    {\n\t      if (this.IsEvenOddFillType(e1))\n\t      {\n\t        var oldE1WindCnt = e1.WindCnt;\n\t        e1.WindCnt = e2.WindCnt;\n\t        e2.WindCnt = oldE1WindCnt;\n\t      }\n\t      else\n\t      {\n\t        if (e1.WindCnt + e2.WindDelta === 0)\n\t          e1.WindCnt = -e1.WindCnt;\n\t        else\n\t          e1.WindCnt += e2.WindDelta;\n\t        if (e2.WindCnt - e1.WindDelta === 0)\n\t          e2.WindCnt = -e2.WindCnt;\n\t        else\n\t          e2.WindCnt -= e1.WindDelta;\n\t      }\n\t    }\n\t    else\n\t    {\n\t      if (!this.IsEvenOddFillType(e2))\n\t        e1.WindCnt2 += e2.WindDelta;\n\t      else\n\t        e1.WindCnt2 = (e1.WindCnt2 === 0) ? 1 : 0;\n\t      if (!this.IsEvenOddFillType(e1))\n\t        e2.WindCnt2 -= e1.WindDelta;\n\t      else\n\t        e2.WindCnt2 = (e2.WindCnt2 === 0) ? 1 : 0;\n\t    }\n\t    var e1FillType, e2FillType, e1FillType2, e2FillType2;\n\t    if (e1.PolyTyp == ClipperLib.PolyType.ptSubject)\n\t    {\n\t      e1FillType = this.m_SubjFillType;\n\t      e1FillType2 = this.m_ClipFillType;\n\t    }\n\t    else\n\t    {\n\t      e1FillType = this.m_ClipFillType;\n\t      e1FillType2 = this.m_SubjFillType;\n\t    }\n\t    if (e2.PolyTyp == ClipperLib.PolyType.ptSubject)\n\t    {\n\t      e2FillType = this.m_SubjFillType;\n\t      e2FillType2 = this.m_ClipFillType;\n\t    }\n\t    else\n\t    {\n\t      e2FillType = this.m_ClipFillType;\n\t      e2FillType2 = this.m_SubjFillType;\n\t    }\n\t    var e1Wc, e2Wc;\n\t    switch (e1FillType)\n\t    {\n\t    case ClipperLib.PolyFillType.pftPositive:\n\t      e1Wc = e1.WindCnt;\n\t      break;\n\t    case ClipperLib.PolyFillType.pftNegative:\n\t      e1Wc = -e1.WindCnt;\n\t      break;\n\t    default:\n\t      e1Wc = Math.abs(e1.WindCnt);\n\t      break;\n\t    }\n\t    switch (e2FillType)\n\t    {\n\t    case ClipperLib.PolyFillType.pftPositive:\n\t      e2Wc = e2.WindCnt;\n\t      break;\n\t    case ClipperLib.PolyFillType.pftNegative:\n\t      e2Wc = -e2.WindCnt;\n\t      break;\n\t    default:\n\t      e2Wc = Math.abs(e2.WindCnt);\n\t      break;\n\t    }\n\t    if (e1Contributing && e2Contributing)\n\t    {\n\t\t\t\tif ((e1Wc != 0 && e1Wc != 1) || (e2Wc != 0 && e2Wc != 1) ||\n\t\t\t\t(e1.PolyTyp != e2.PolyTyp && this.m_ClipType != ClipperLib.ClipType.ctXor))\n\t\t\t\t{\n\t\t\t\t\tthis.AddLocalMaxPoly(e1, e2, pt);\n\t\t\t\t}\n\t      else\n\t      {\n\t        this.AddOutPt(e1, pt);\n\t        this.AddOutPt(e2, pt);\n\t        ClipperLib.Clipper.SwapSides(e1, e2);\n\t        ClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n\t      }\n\t    }\n\t    else if (e1Contributing)\n\t    {\n\t      if (e2Wc === 0 || e2Wc == 1)\n\t      {\n\t        this.AddOutPt(e1, pt);\n\t        ClipperLib.Clipper.SwapSides(e1, e2);\n\t        ClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n\t      }\n\t    }\n\t    else if (e2Contributing)\n\t    {\n\t      if (e1Wc === 0 || e1Wc == 1)\n\t      {\n\t        this.AddOutPt(e2, pt);\n\t        ClipperLib.Clipper.SwapSides(e1, e2);\n\t        ClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n\t      }\n\t    }\n\t\t\telse if ( (e1Wc == 0 || e1Wc == 1) && (e2Wc == 0 || e2Wc == 1))\n\t    {\n\t      //neither edge is currently contributing ...\n\t      var e1Wc2, e2Wc2;\n\t      switch (e1FillType2)\n\t      {\n\t      case ClipperLib.PolyFillType.pftPositive:\n\t        e1Wc2 = e1.WindCnt2;\n\t        break;\n\t      case ClipperLib.PolyFillType.pftNegative:\n\t        e1Wc2 = -e1.WindCnt2;\n\t        break;\n\t      default:\n\t        e1Wc2 = Math.abs(e1.WindCnt2);\n\t        break;\n\t      }\n\t      switch (e2FillType2)\n\t      {\n\t      case ClipperLib.PolyFillType.pftPositive:\n\t        e2Wc2 = e2.WindCnt2;\n\t        break;\n\t      case ClipperLib.PolyFillType.pftNegative:\n\t        e2Wc2 = -e2.WindCnt2;\n\t        break;\n\t      default:\n\t        e2Wc2 = Math.abs(e2.WindCnt2);\n\t        break;\n\t      }\n\t      if (e1.PolyTyp != e2.PolyTyp)\n\t      {\n\t        this.AddLocalMinPoly(e1, e2, pt);\n\t      }\n\t      else if (e1Wc == 1 && e2Wc == 1)\n\t        switch (this.m_ClipType)\n\t        {\n\t        case ClipperLib.ClipType.ctIntersection:\n\t          if (e1Wc2 > 0 && e2Wc2 > 0)\n\t            this.AddLocalMinPoly(e1, e2, pt);\n\t          break;\n\t        case ClipperLib.ClipType.ctUnion:\n\t          if (e1Wc2 <= 0 && e2Wc2 <= 0)\n\t            this.AddLocalMinPoly(e1, e2, pt);\n\t          break;\n\t        case ClipperLib.ClipType.ctDifference:\n\t          if (((e1.PolyTyp == ClipperLib.PolyType.ptClip) && (e1Wc2 > 0) && (e2Wc2 > 0)) ||\n\t            ((e1.PolyTyp == ClipperLib.PolyType.ptSubject) && (e1Wc2 <= 0) && (e2Wc2 <= 0)))\n\t            this.AddLocalMinPoly(e1, e2, pt);\n\t          break;\n\t        case ClipperLib.ClipType.ctXor:\n\t          this.AddLocalMinPoly(e1, e2, pt);\n\t          break;\n\t        }\n\t      else\n\t        ClipperLib.Clipper.SwapSides(e1, e2);\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.DeleteFromAEL = function (e)\n\t  {\n\t    var AelPrev = e.PrevInAEL;\n\t    var AelNext = e.NextInAEL;\n\t    if (AelPrev === null && AelNext === null && (e != this.m_ActiveEdges))\n\t      return;\n\t    //already deleted\n\t    if (AelPrev !== null)\n\t      AelPrev.NextInAEL = AelNext;\n\t    else\n\t      this.m_ActiveEdges = AelNext;\n\t    if (AelNext !== null)\n\t      AelNext.PrevInAEL = AelPrev;\n\t    e.NextInAEL = null;\n\t    e.PrevInAEL = null;\n\t  };\n\t  ClipperLib.Clipper.prototype.DeleteFromSEL = function (e)\n\t  {\n\t    var SelPrev = e.PrevInSEL;\n\t    var SelNext = e.NextInSEL;\n\t    if (SelPrev === null && SelNext === null && (e != this.m_SortedEdges))\n\t      return;\n\t    //already deleted\n\t    if (SelPrev !== null)\n\t      SelPrev.NextInSEL = SelNext;\n\t    else\n\t      this.m_SortedEdges = SelNext;\n\t    if (SelNext !== null)\n\t      SelNext.PrevInSEL = SelPrev;\n\t    e.NextInSEL = null;\n\t    e.PrevInSEL = null;\n\t  };\n\t  ClipperLib.Clipper.prototype.UpdateEdgeIntoAEL = function (e)\n\t  {\n\t    if (e.NextInLML === null)\n\t      ClipperLib.Error(\"UpdateEdgeIntoAEL: invalid call\");\n\t    var AelPrev = e.PrevInAEL;\n\t    var AelNext = e.NextInAEL;\n\t    e.NextInLML.OutIdx = e.OutIdx;\n\t    if (AelPrev !== null)\n\t      AelPrev.NextInAEL = e.NextInLML;\n\t    else\n\t      this.m_ActiveEdges = e.NextInLML;\n\t    if (AelNext !== null)\n\t      AelNext.PrevInAEL = e.NextInLML;\n\t    e.NextInLML.Side = e.Side;\n\t    e.NextInLML.WindDelta = e.WindDelta;\n\t    e.NextInLML.WindCnt = e.WindCnt;\n\t    e.NextInLML.WindCnt2 = e.WindCnt2;\n\t    e = e.NextInLML;\n\t    //    e.Curr = e.Bot;\n\t    e.Curr.X = e.Bot.X;\n\t    e.Curr.Y = e.Bot.Y;\n\t    e.PrevInAEL = AelPrev;\n\t    e.NextInAEL = AelNext;\n\t    if (!ClipperLib.ClipperBase.IsHorizontal(e))\n\t      this.InsertScanbeam(e.Top.Y);\n\t    return e;\n\t  };\n\t  ClipperLib.Clipper.prototype.ProcessHorizontals = function (isTopOfScanbeam)\n\t  {\n\t    var horzEdge = this.m_SortedEdges;\n\t    while (horzEdge !== null)\n\t    {\n\t      this.DeleteFromSEL(horzEdge);\n\t      this.ProcessHorizontal(horzEdge, isTopOfScanbeam);\n\t      horzEdge = this.m_SortedEdges;\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.GetHorzDirection = function (HorzEdge, $var)\n\t  {\n\t    if (HorzEdge.Bot.X < HorzEdge.Top.X)\n\t    {\n\t        $var.Left = HorzEdge.Bot.X;\n\t        $var.Right = HorzEdge.Top.X;\n\t        $var.Dir = ClipperLib.Direction.dLeftToRight;\n\t    }\n\t    else\n\t    {\n\t        $var.Left = HorzEdge.Top.X;\n\t        $var.Right = HorzEdge.Bot.X;\n\t        $var.Dir = ClipperLib.Direction.dRightToLeft;\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.ProcessHorizontal = function (horzEdge, isTopOfScanbeam)\n\t  {\n\t    var $var = {Dir: null, Left: null, Right: null};\n\t    this.GetHorzDirection(horzEdge, $var);\n\t    var dir = $var.Dir;\n\t    var horzLeft = $var.Left;\n\t    var horzRight = $var.Right;\n\t\n\t    var eLastHorz = horzEdge,\n\t      eMaxPair = null;\n\t    while (eLastHorz.NextInLML !== null && ClipperLib.ClipperBase.IsHorizontal(eLastHorz.NextInLML))\n\t      eLastHorz = eLastHorz.NextInLML;\n\t    if (eLastHorz.NextInLML === null)\n\t      eMaxPair = this.GetMaximaPair(eLastHorz);\n\t    for (;;)\n\t    {\n\t      var IsLastHorz = (horzEdge == eLastHorz);\n\t      var e = this.GetNextInAEL(horzEdge, dir);\n\t      while (e !== null)\n\t      {\n\t        //Break if we've got to the end of an intermediate horizontal edge ...\n\t        //nb: Smaller Dx's are to the right of larger Dx's ABOVE the horizontal.\n\t        if (e.Curr.X == horzEdge.Top.X && horzEdge.NextInLML !== null && e.Dx < horzEdge.NextInLML.Dx)\n\t          break;\n\t        var eNext = this.GetNextInAEL(e, dir);\n\t        //saves eNext for later\n\t        if ((dir == ClipperLib.Direction.dLeftToRight && e.Curr.X <= horzRight) || (dir == ClipperLib.Direction.dRightToLeft && e.Curr.X >= horzLeft))\n\t        {\n\t          //so far we're still in range of the horizontal Edge  but make sure\n\t          //we're at the last of consec. horizontals when matching with eMaxPair\n\t          if (e == eMaxPair && IsLastHorz)\n\t          {\n\t\t\t\t\t\t\tif (horzEdge.OutIdx >= 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvar op1 = this.AddOutPt(horzEdge, horzEdge.Top);\n\t\t\t\t\t\t\t\tvar eNextHorz = this.m_SortedEdges;\n\t\t\t\t\t\t\t\twhile (eNextHorz !== null)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif (eNextHorz.OutIdx >= 0 &&\n\t\t\t\t\t\t\t\t\t\tthis.HorzSegmentsOverlap(horzEdge.Bot.X,\n\t\t\t\t\t\t\t\t\t\thorzEdge.Top.X, eNextHorz.Bot.X, eNextHorz.Top.X))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tvar op2 = this.AddOutPt(eNextHorz, eNextHorz.Bot);\n\t\t\t\t\t\t\t\t\t\tthis.AddJoin(op2, op1, eNextHorz.Top);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\teNextHorz = eNextHorz.NextInSEL;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tthis.AddGhostJoin(op1, horzEdge.Bot);\n\t\t\t\t\t\t\t\tthis.AddLocalMaxPoly(horzEdge, eMaxPair, horzEdge.Top);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis.DeleteFromAEL(horzEdge);\n\t\t\t\t\t\t\tthis.DeleteFromAEL(eMaxPair);\n\t            return;\n\t          }\n\t          else if (dir == ClipperLib.Direction.dLeftToRight)\n\t          {\n\t            var Pt = new ClipperLib.IntPoint(e.Curr.X, horzEdge.Curr.Y);\n\t            this.IntersectEdges(horzEdge, e, Pt);\n\t          }\n\t          else\n\t          {\n\t            var Pt = new ClipperLib.IntPoint(e.Curr.X, horzEdge.Curr.Y);\n\t            this.IntersectEdges(e, horzEdge, Pt);\n\t          }\n\t          this.SwapPositionsInAEL(horzEdge, e);\n\t        }\n\t        else if ((dir == ClipperLib.Direction.dLeftToRight && e.Curr.X >= horzRight) || (dir == ClipperLib.Direction.dRightToLeft && e.Curr.X <= horzLeft))\n\t          break;\n\t        e = eNext;\n\t      }\n\t      //end while\n\t      if (horzEdge.NextInLML !== null && ClipperLib.ClipperBase.IsHorizontal(horzEdge.NextInLML))\n\t      {\n\t        horzEdge = this.UpdateEdgeIntoAEL(horzEdge);\n\t        if (horzEdge.OutIdx >= 0)\n\t          this.AddOutPt(horzEdge, horzEdge.Bot);\n\t\n\t          var $var = {Dir: dir, Left: horzLeft, Right: horzRight};\n\t          this.GetHorzDirection(horzEdge, $var);\n\t          dir = $var.Dir;\n\t          horzLeft = $var.Left;\n\t          horzRight = $var.Right;\n\t      }\n\t      else\n\t        break;\n\t    }\n\t    //end for (;;)\n\t    if (horzEdge.NextInLML !== null)\n\t    {\n\t      if (horzEdge.OutIdx >= 0)\n\t      {\n\t        var op1 = this.AddOutPt(horzEdge, horzEdge.Top);\n\t\t\t\t\tif (isTopOfScanbeam) this.AddGhostJoin(op1, horzEdge.Bot);\n\t        horzEdge = this.UpdateEdgeIntoAEL(horzEdge);\n\t        if (horzEdge.WindDelta === 0)\n\t          return;\n\t        //nb: HorzEdge is no longer horizontal here\n\t        var ePrev = horzEdge.PrevInAEL;\n\t        var eNext = horzEdge.NextInAEL;\n\t        if (ePrev !== null && ePrev.Curr.X == horzEdge.Bot.X &&\n\t          ePrev.Curr.Y == horzEdge.Bot.Y && ePrev.WindDelta !== 0 &&\n\t          (ePrev.OutIdx >= 0 && ePrev.Curr.Y > ePrev.Top.Y &&\n\t            ClipperLib.ClipperBase.SlopesEqual(horzEdge, ePrev, this.m_UseFullRange)))\n\t        {\n\t          var op2 = this.AddOutPt(ePrev, horzEdge.Bot);\n\t          this.AddJoin(op1, op2, horzEdge.Top);\n\t        }\n\t        else if (eNext !== null && eNext.Curr.X == horzEdge.Bot.X &&\n\t          eNext.Curr.Y == horzEdge.Bot.Y && eNext.WindDelta !== 0 &&\n\t          eNext.OutIdx >= 0 && eNext.Curr.Y > eNext.Top.Y &&\n\t          ClipperLib.ClipperBase.SlopesEqual(horzEdge, eNext, this.m_UseFullRange))\n\t        {\n\t          var op2 = this.AddOutPt(eNext, horzEdge.Bot);\n\t          this.AddJoin(op1, op2, horzEdge.Top);\n\t        }\n\t      }\n\t      else horzEdge = this.UpdateEdgeIntoAEL(horzEdge);\n\t    }\n\t  \telse\n\t    {\n\t      if (horzEdge.OutIdx >= 0)\n\t        this.AddOutPt(horzEdge, horzEdge.Top);\n\t      this.DeleteFromAEL(horzEdge);\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.GetNextInAEL = function (e, Direction)\n\t  {\n\t    return Direction == ClipperLib.Direction.dLeftToRight ? e.NextInAEL : e.PrevInAEL;\n\t  };\n\t  ClipperLib.Clipper.prototype.IsMinima = function (e)\n\t  {\n\t    return e !== null && (e.Prev.NextInLML != e) && (e.Next.NextInLML != e);\n\t  };\n\t  ClipperLib.Clipper.prototype.IsMaxima = function (e, Y)\n\t  {\n\t    return (e !== null && e.Top.Y == Y && e.NextInLML === null);\n\t  };\n\t  ClipperLib.Clipper.prototype.IsIntermediate = function (e, Y)\n\t  {\n\t    return (e.Top.Y == Y && e.NextInLML !== null);\n\t  };\n\t  ClipperLib.Clipper.prototype.GetMaximaPair = function (e)\n\t  {\n\t    var result = null;\n\t    if ((ClipperLib.IntPoint.op_Equality(e.Next.Top, e.Top)) && e.Next.NextInLML === null)\n\t      result = e.Next;\n\t    else if ((ClipperLib.IntPoint.op_Equality(e.Prev.Top, e.Top)) && e.Prev.NextInLML === null)\n\t      result = e.Prev;\n\t    if (result !== null && (result.OutIdx == -2 || (result.NextInAEL == result.PrevInAEL && !ClipperLib.ClipperBase.IsHorizontal(result))))\n\t      return null;\n\t    return result;\n\t  };\n\t\n\t  ClipperLib.Clipper.prototype.ProcessIntersections = function (topY)\n\t  {\n\t    if (this.m_ActiveEdges == null)\n\t      return true;\n\t    try\n\t    {\n\t      this.BuildIntersectList(topY);\n\t      if (this.m_IntersectList.length == 0)\n\t        return true;\n\t      if (this.m_IntersectList.length == 1 || this.FixupIntersectionOrder())\n\t        this.ProcessIntersectList();\n\t      else\n\t        return false;\n\t    }\n\t    catch ($$e2)\n\t    {\n\t      this.m_SortedEdges = null;\n\t      this.m_IntersectList.length = 0;\n\t      ClipperLib.Error(\"ProcessIntersections error\");\n\t    }\n\t    this.m_SortedEdges = null;\n\t    return true;\n\t  };\n\t  ClipperLib.Clipper.prototype.BuildIntersectList = function (topY)\n\t  {\n\t    if (this.m_ActiveEdges === null)\n\t      return;\n\t    //prepare for sorting ...\n\t    var e = this.m_ActiveEdges;\n\t    //console.log(JSON.stringify(JSON.decycle( e )));\n\t    this.m_SortedEdges = e;\n\t    while (e !== null)\n\t    {\n\t      e.PrevInSEL = e.PrevInAEL;\n\t      e.NextInSEL = e.NextInAEL;\n\t      e.Curr.X = ClipperLib.Clipper.TopX(e, topY);\n\t      e = e.NextInAEL;\n\t    }\n\t    //bubblesort ...\n\t    var isModified = true;\n\t    while (isModified && this.m_SortedEdges !== null)\n\t    {\n\t      isModified = false;\n\t      e = this.m_SortedEdges;\n\t      while (e.NextInSEL !== null)\n\t      {\n\t        var eNext = e.NextInSEL;\n\t        var pt = new ClipperLib.IntPoint();\n\t        //console.log(\"e.Curr.X: \" + e.Curr.X + \" eNext.Curr.X\" + eNext.Curr.X);\n\t        if (e.Curr.X > eNext.Curr.X)\n\t        {\n\t\t\t\t\t\tthis.IntersectPoint(e, eNext, pt);\n\t          var newNode = new ClipperLib.IntersectNode();\n\t          newNode.Edge1 = e;\n\t          newNode.Edge2 = eNext;\n\t          //newNode.Pt = pt;\n\t          newNode.Pt.X = pt.X;\n\t          newNode.Pt.Y = pt.Y;\n\t          this.m_IntersectList.push(newNode);\n\t          this.SwapPositionsInSEL(e, eNext);\n\t          isModified = true;\n\t        }\n\t        else\n\t          e = eNext;\n\t      }\n\t      if (e.PrevInSEL !== null)\n\t        e.PrevInSEL.NextInSEL = null;\n\t      else\n\t        break;\n\t    }\n\t    this.m_SortedEdges = null;\n\t  };\n\t  ClipperLib.Clipper.prototype.EdgesAdjacent = function (inode)\n\t  {\n\t    return (inode.Edge1.NextInSEL == inode.Edge2) || (inode.Edge1.PrevInSEL == inode.Edge2);\n\t  };\n\t  ClipperLib.Clipper.IntersectNodeSort = function (node1, node2)\n\t  {\n\t    //the following typecast is safe because the differences in Pt.Y will\n\t    //be limited to the height of the scanbeam.\n\t    return (node2.Pt.Y - node1.Pt.Y);\n\t  };\n\t  ClipperLib.Clipper.prototype.FixupIntersectionOrder = function ()\n\t  {\n\t    //pre-condition: intersections are sorted bottom-most first.\n\t    //Now it's crucial that intersections are made only between adjacent edges,\n\t    //so to ensure this the order of intersections may need adjusting ...\n\t    this.m_IntersectList.sort(this.m_IntersectNodeComparer);\n\t    this.CopyAELToSEL();\n\t    var cnt = this.m_IntersectList.length;\n\t    for (var i = 0; i < cnt; i++)\n\t    {\n\t      if (!this.EdgesAdjacent(this.m_IntersectList[i]))\n\t      {\n\t        var j = i + 1;\n\t        while (j < cnt && !this.EdgesAdjacent(this.m_IntersectList[j]))\n\t          j++;\n\t        if (j == cnt)\n\t          return false;\n\t        var tmp = this.m_IntersectList[i];\n\t        this.m_IntersectList[i] = this.m_IntersectList[j];\n\t        this.m_IntersectList[j] = tmp;\n\t      }\n\t      this.SwapPositionsInSEL(this.m_IntersectList[i].Edge1, this.m_IntersectList[i].Edge2);\n\t    }\n\t    return true;\n\t  };\n\t  ClipperLib.Clipper.prototype.ProcessIntersectList = function ()\n\t  {\n\t    for (var i = 0, ilen = this.m_IntersectList.length; i < ilen; i++)\n\t    {\n\t      var iNode = this.m_IntersectList[i];\n\t      this.IntersectEdges(iNode.Edge1, iNode.Edge2, iNode.Pt);\n\t      this.SwapPositionsInAEL(iNode.Edge1, iNode.Edge2);\n\t    }\n\t    this.m_IntersectList.length = 0;\n\t  };\n\t  /*\n\t  --------------------------------\n\t  Round speedtest: http://jsperf.com/fastest-round\n\t  --------------------------------\n\t  */\n\t  var R1 = function (a)\n\t  {\n\t    return a < 0 ? Math.ceil(a - 0.5) : Math.round(a)\n\t  };\n\t  var R2 = function (a)\n\t  {\n\t    return a < 0 ? Math.ceil(a - 0.5) : Math.floor(a + 0.5)\n\t  };\n\t  var R3 = function (a)\n\t  {\n\t    return a < 0 ? -Math.round(Math.abs(a)) : Math.round(a)\n\t  };\n\t  var R4 = function (a)\n\t  {\n\t    if (a < 0)\n\t    {\n\t      a -= 0.5;\n\t      return a < -2147483648 ? Math.ceil(a) : a | 0;\n\t    }\n\t    else\n\t    {\n\t      a += 0.5;\n\t      return a > 2147483647 ? Math.floor(a) : a | 0;\n\t    }\n\t  };\n\t  if (browser.msie) ClipperLib.Clipper.Round = R1;\n\t  else if (browser.chromium) ClipperLib.Clipper.Round = R3;\n\t  else if (browser.safari) ClipperLib.Clipper.Round = R4;\n\t  else ClipperLib.Clipper.Round = R2; // eg. browser.chrome || browser.firefox || browser.opera\n\t  ClipperLib.Clipper.TopX = function (edge, currentY)\n\t  {\n\t    //if (edge.Bot == edge.Curr) alert (\"edge.Bot = edge.Curr\");\n\t    //if (edge.Bot == edge.Top) alert (\"edge.Bot = edge.Top\");\n\t    if (currentY == edge.Top.Y)\n\t      return edge.Top.X;\n\t    return edge.Bot.X + ClipperLib.Clipper.Round(edge.Dx * (currentY - edge.Bot.Y));\n\t  };\n\t  ClipperLib.Clipper.prototype.IntersectPoint = function (edge1, edge2, ip)\n\t  {\n\t    ip.X = 0;\n\t    ip.Y = 0;\n\t    var b1, b2;\n\t    //nb: with very large coordinate values, it's possible for SlopesEqual() to\n\t    //return false but for the edge.Dx value be equal due to double precision rounding.\n\t    if (edge1.Dx == edge2.Dx)\n\t\t\t{\n\t\t\t\tip.Y = edge1.Curr.Y;\n\t\t\t\tip.X = ClipperLib.Clipper.TopX(edge1, ip.Y);\n\t\t\t\treturn;\n\t    }\n\t    if (edge1.Delta.X === 0)\n\t    {\n\t      ip.X = edge1.Bot.X;\n\t      if (ClipperLib.ClipperBase.IsHorizontal(edge2))\n\t      {\n\t        ip.Y = edge2.Bot.Y;\n\t      }\n\t      else\n\t      {\n\t        b2 = edge2.Bot.Y - (edge2.Bot.X / edge2.Dx);\n\t        ip.Y = ClipperLib.Clipper.Round(ip.X / edge2.Dx + b2);\n\t      }\n\t    }\n\t    else if (edge2.Delta.X === 0)\n\t    {\n\t      ip.X = edge2.Bot.X;\n\t      if (ClipperLib.ClipperBase.IsHorizontal(edge1))\n\t      {\n\t        ip.Y = edge1.Bot.Y;\n\t      }\n\t      else\n\t      {\n\t        b1 = edge1.Bot.Y - (edge1.Bot.X / edge1.Dx);\n\t        ip.Y = ClipperLib.Clipper.Round(ip.X / edge1.Dx + b1);\n\t      }\n\t    }\n\t    else\n\t    {\n\t      b1 = edge1.Bot.X - edge1.Bot.Y * edge1.Dx;\n\t      b2 = edge2.Bot.X - edge2.Bot.Y * edge2.Dx;\n\t      var q = (b2 - b1) / (edge1.Dx - edge2.Dx);\n\t      ip.Y = ClipperLib.Clipper.Round(q);\n\t      if (Math.abs(edge1.Dx) < Math.abs(edge2.Dx))\n\t        ip.X = ClipperLib.Clipper.Round(edge1.Dx * q + b1);\n\t      else\n\t        ip.X = ClipperLib.Clipper.Round(edge2.Dx * q + b2);\n\t    }\n\t    if (ip.Y < edge1.Top.Y || ip.Y < edge2.Top.Y)\n\t    {\n\t      if (edge1.Top.Y > edge2.Top.Y)\n\t      {\n\t        ip.Y = edge1.Top.Y;\n\t        ip.X = ClipperLib.Clipper.TopX(edge2, edge1.Top.Y);\n\t        return ip.X < edge1.Top.X;\n\t      }\n\t      else\n\t        ip.Y = edge2.Top.Y;\n\t      if (Math.abs(edge1.Dx) < Math.abs(edge2.Dx))\n\t        ip.X = ClipperLib.Clipper.TopX(edge1, ip.Y);\n\t      else\n\t        ip.X = ClipperLib.Clipper.TopX(edge2, ip.Y);\n\t    }\n\t\t\t//finally, don't allow 'ip' to be BELOW curr.Y (ie bottom of scanbeam) ...\n\t\t\tif (ip.Y > edge1.Curr.Y)\n\t\t\t{\n\t\t\t\tip.Y = edge1.Curr.Y;\n\t\t\t\t//better to use the more vertical edge to derive X ...\n\t\t\t\tif (Math.abs(edge1.Dx) > Math.abs(edge2.Dx))\n\t\t\t\t\tip.X = ClipperLib.Clipper.TopX(edge2, ip.Y);\n\t\t\t\telse\n\t\t\t\t\tip.X = ClipperLib.Clipper.TopX(edge1, ip.Y);\n\t\t\t}\n\t  };\n\t\n\t  ClipperLib.Clipper.prototype.ProcessEdgesAtTopOfScanbeam = function (topY)\n\t  {\n\t    var e = this.m_ActiveEdges;\n\t    while (e !== null)\n\t    {\n\t      //1. process maxima, treating them as if they're 'bent' horizontal edges,\n\t      //   but exclude maxima with horizontal edges. nb: e can't be a horizontal.\n\t      var IsMaximaEdge = this.IsMaxima(e, topY);\n\t      if (IsMaximaEdge)\n\t      {\n\t        var eMaxPair = this.GetMaximaPair(e);\n\t        IsMaximaEdge = (eMaxPair === null || !ClipperLib.ClipperBase.IsHorizontal(eMaxPair));\n\t      }\n\t      if (IsMaximaEdge)\n\t      {\n\t        var ePrev = e.PrevInAEL;\n\t        this.DoMaxima(e);\n\t        if (ePrev === null)\n\t          e = this.m_ActiveEdges;\n\t        else\n\t          e = ePrev.NextInAEL;\n\t      }\n\t      else\n\t      {\n\t        //2. promote horizontal edges, otherwise update Curr.X and Curr.Y ...\n\t        if (this.IsIntermediate(e, topY) && ClipperLib.ClipperBase.IsHorizontal(e.NextInLML))\n\t        {\n\t          e = this.UpdateEdgeIntoAEL(e);\n\t          if (e.OutIdx >= 0)\n\t            this.AddOutPt(e, e.Bot);\n\t          this.AddEdgeToSEL(e);\n\t        }\n\t        else\n\t        {\n\t          e.Curr.X = ClipperLib.Clipper.TopX(e, topY);\n\t          e.Curr.Y = topY;\n\t        }\n\t        if (this.StrictlySimple)\n\t        {\n\t          var ePrev = e.PrevInAEL;\n\t          if ((e.OutIdx >= 0) && (e.WindDelta !== 0) && ePrev !== null &&\n\t            (ePrev.OutIdx >= 0) && (ePrev.Curr.X == e.Curr.X) &&\n\t            (ePrev.WindDelta !== 0))\n\t          {\n\t           \tvar ip = new ClipperLib.IntPoint(e.Curr);\n\t\n\t\t\t\t\t\t\tif(use_xyz)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tthis.SetZ(ip, ePrev, e);\n\t\t\t\t\t\t\t}\n\t\n\t            var op = this.AddOutPt(ePrev, ip);\n\t            var op2 = this.AddOutPt(e, ip);\n\t            this.AddJoin(op, op2, ip);\n\t            //StrictlySimple (type-3) join\n\t          }\n\t        }\n\t        e = e.NextInAEL;\n\t      }\n\t    }\n\t    //3. Process horizontals at the Top of the scanbeam ...\n\t    this.ProcessHorizontals(true);\n\t    //4. Promote intermediate vertices ...\n\t    e = this.m_ActiveEdges;\n\t    while (e !== null)\n\t    {\n\t      if (this.IsIntermediate(e, topY))\n\t      {\n\t        var op = null;\n\t        if (e.OutIdx >= 0)\n\t          op = this.AddOutPt(e, e.Top);\n\t        e = this.UpdateEdgeIntoAEL(e);\n\t        //if output polygons share an edge, they'll need joining later ...\n\t        var ePrev = e.PrevInAEL;\n\t        var eNext = e.NextInAEL;\n\t        if (ePrev !== null && ePrev.Curr.X == e.Bot.X &&\n\t          ePrev.Curr.Y == e.Bot.Y && op !== null &&\n\t          ePrev.OutIdx >= 0 && ePrev.Curr.Y > ePrev.Top.Y &&\n\t          ClipperLib.ClipperBase.SlopesEqual(e, ePrev, this.m_UseFullRange) &&\n\t          (e.WindDelta !== 0) && (ePrev.WindDelta !== 0))\n\t        {\n\t          var op2 = this.AddOutPt(ePrev, e.Bot);\n\t          this.AddJoin(op, op2, e.Top);\n\t        }\n\t        else if (eNext !== null && eNext.Curr.X == e.Bot.X &&\n\t          eNext.Curr.Y == e.Bot.Y && op !== null &&\n\t          eNext.OutIdx >= 0 && eNext.Curr.Y > eNext.Top.Y &&\n\t          ClipperLib.ClipperBase.SlopesEqual(e, eNext, this.m_UseFullRange) &&\n\t          (e.WindDelta !== 0) && (eNext.WindDelta !== 0))\n\t        {\n\t          var op2 = this.AddOutPt(eNext, e.Bot);\n\t          this.AddJoin(op, op2, e.Top);\n\t        }\n\t      }\n\t      e = e.NextInAEL;\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.DoMaxima = function (e)\n\t  {\n\t    var eMaxPair = this.GetMaximaPair(e);\n\t    if (eMaxPair === null)\n\t    {\n\t      if (e.OutIdx >= 0)\n\t        this.AddOutPt(e, e.Top);\n\t      this.DeleteFromAEL(e);\n\t      return;\n\t    }\n\t    var eNext = e.NextInAEL;\n\t    var use_lines = true;\n\t    while (eNext !== null && eNext != eMaxPair)\n\t    {\n\t      this.IntersectEdges(e, eNext, e.Top);\n\t      this.SwapPositionsInAEL(e, eNext);\n\t      eNext = e.NextInAEL;\n\t    }\n\t    if (e.OutIdx == -1 && eMaxPair.OutIdx == -1)\n\t    {\n\t      this.DeleteFromAEL(e);\n\t      this.DeleteFromAEL(eMaxPair);\n\t    }\n\t    else if (e.OutIdx >= 0 && eMaxPair.OutIdx >= 0)\n\t    {\n\t    \tif (e.OutIdx >= 0) this.AddLocalMaxPoly(e, eMaxPair, e.Top);\n\t      this.DeleteFromAEL(e);\n\t      this.DeleteFromAEL(eMaxPair);\n\t    }\n\t    else if (use_lines && e.WindDelta === 0)\n\t    {\n\t      if (e.OutIdx >= 0)\n\t      {\n\t        this.AddOutPt(e, e.Top);\n\t        e.OutIdx = -1;\n\t      }\n\t      this.DeleteFromAEL(e);\n\t      if (eMaxPair.OutIdx >= 0)\n\t      {\n\t        this.AddOutPt(eMaxPair, e.Top);\n\t        eMaxPair.OutIdx = -1;\n\t      }\n\t      this.DeleteFromAEL(eMaxPair);\n\t    }\n\t    else\n\t      ClipperLib.Error(\"DoMaxima error\");\n\t  };\n\t  ClipperLib.Clipper.ReversePaths = function (polys)\n\t  {\n\t    for (var i = 0, len = polys.length; i < len; i++)\n\t      polys[i].reverse();\n\t  };\n\t  ClipperLib.Clipper.Orientation = function (poly)\n\t  {\n\t    return ClipperLib.Clipper.Area(poly) >= 0;\n\t  };\n\t  ClipperLib.Clipper.prototype.PointCount = function (pts)\n\t  {\n\t    if (pts === null)\n\t      return 0;\n\t    var result = 0;\n\t    var p = pts;\n\t    do {\n\t      result++;\n\t      p = p.Next;\n\t    }\n\t    while (p != pts)\n\t    return result;\n\t  };\n\t  ClipperLib.Clipper.prototype.BuildResult = function (polyg)\n\t  {\n\t    ClipperLib.Clear(polyg);\n\t    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n\t    {\n\t      var outRec = this.m_PolyOuts[i];\n\t      if (outRec.Pts === null)\n\t        continue;\n\t      var p = outRec.Pts.Prev;\n\t      var cnt = this.PointCount(p);\n\t      if (cnt < 2)\n\t        continue;\n\t      var pg = new Array(cnt);\n\t      for (var j = 0; j < cnt; j++)\n\t      {\n\t        pg[j] = p.Pt;\n\t        p = p.Prev;\n\t      }\n\t      polyg.push(pg);\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.BuildResult2 = function (polytree)\n\t  {\n\t    polytree.Clear();\n\t    //add each output polygon/contour to polytree ...\n\t    //polytree.m_AllPolys.set_Capacity(this.m_PolyOuts.length);\n\t    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n\t    {\n\t      var outRec = this.m_PolyOuts[i];\n\t      var cnt = this.PointCount(outRec.Pts);\n\t      if ((outRec.IsOpen && cnt < 2) || (!outRec.IsOpen && cnt < 3))\n\t        continue;\n\t      this.FixHoleLinkage(outRec);\n\t      var pn = new ClipperLib.PolyNode();\n\t      polytree.m_AllPolys.push(pn);\n\t      outRec.PolyNode = pn;\n\t      pn.m_polygon.length = cnt;\n\t      var op = outRec.Pts.Prev;\n\t      for (var j = 0; j < cnt; j++)\n\t      {\n\t        pn.m_polygon[j] = op.Pt;\n\t        op = op.Prev;\n\t      }\n\t    }\n\t    //fixup PolyNode links etc ...\n\t    //polytree.m_Childs.set_Capacity(this.m_PolyOuts.length);\n\t    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n\t    {\n\t      var outRec = this.m_PolyOuts[i];\n\t      if (outRec.PolyNode === null)\n\t        continue;\n\t      else if (outRec.IsOpen)\n\t      {\n\t        outRec.PolyNode.IsOpen = true;\n\t        polytree.AddChild(outRec.PolyNode);\n\t      }\n\t      else if (outRec.FirstLeft !== null && outRec.FirstLeft.PolyNode != null)\n\t        outRec.FirstLeft.PolyNode.AddChild(outRec.PolyNode);\n\t      else\n\t        polytree.AddChild(outRec.PolyNode);\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.FixupOutPolygon = function (outRec)\n\t  {\n\t    //FixupOutPolygon() - removes duplicate points and simplifies consecutive\n\t    //parallel edges by removing the middle vertex.\n\t    var lastOK = null;\n\t    outRec.BottomPt = null;\n\t    var pp = outRec.Pts;\n\t    for (;;)\n\t    {\n\t      if (pp.Prev == pp || pp.Prev == pp.Next)\n\t      {\n\t        outRec.Pts = null;\n\t        return;\n\t      }\n\t      //test for duplicate points and collinear edges ...\n\t      if ((ClipperLib.IntPoint.op_Equality(pp.Pt, pp.Next.Pt)) || (ClipperLib.IntPoint.op_Equality(pp.Pt, pp.Prev.Pt)) ||\n\t        (ClipperLib.ClipperBase.SlopesEqual(pp.Prev.Pt, pp.Pt, pp.Next.Pt, this.m_UseFullRange) &&\n\t          (!this.PreserveCollinear || !this.Pt2IsBetweenPt1AndPt3(pp.Prev.Pt, pp.Pt, pp.Next.Pt))))\n\t      {\n\t        lastOK = null;\n\t        pp.Prev.Next = pp.Next;\n\t        pp.Next.Prev = pp.Prev;\n\t        pp = pp.Prev;\n\t      }\n\t      else if (pp == lastOK)\n\t        break;\n\t      else\n\t      {\n\t        if (lastOK === null)\n\t          lastOK = pp;\n\t        pp = pp.Next;\n\t      }\n\t    }\n\t    outRec.Pts = pp;\n\t  };\n\t  ClipperLib.Clipper.prototype.DupOutPt = function (outPt, InsertAfter)\n\t  {\n\t    var result = new ClipperLib.OutPt();\n\t    //result.Pt = outPt.Pt;\n\t    result.Pt.X = outPt.Pt.X;\n\t    result.Pt.Y = outPt.Pt.Y;\n\t    result.Idx = outPt.Idx;\n\t    if (InsertAfter)\n\t    {\n\t      result.Next = outPt.Next;\n\t      result.Prev = outPt;\n\t      outPt.Next.Prev = result;\n\t      outPt.Next = result;\n\t    }\n\t    else\n\t    {\n\t      result.Prev = outPt.Prev;\n\t      result.Next = outPt;\n\t      outPt.Prev.Next = result;\n\t      outPt.Prev = result;\n\t    }\n\t    return result;\n\t  };\n\t  ClipperLib.Clipper.prototype.GetOverlap = function (a1, a2, b1, b2, $val)\n\t  {\n\t    if (a1 < a2)\n\t    {\n\t      if (b1 < b2)\n\t      {\n\t        $val.Left = Math.max(a1, b1);\n\t        $val.Right = Math.min(a2, b2);\n\t      }\n\t      else\n\t      {\n\t        $val.Left = Math.max(a1, b2);\n\t        $val.Right = Math.min(a2, b1);\n\t      }\n\t    }\n\t    else\n\t    {\n\t      if (b1 < b2)\n\t      {\n\t        $val.Left = Math.max(a2, b1);\n\t        $val.Right = Math.min(a1, b2);\n\t      }\n\t      else\n\t      {\n\t        $val.Left = Math.max(a2, b2);\n\t        $val.Right = Math.min(a1, b1);\n\t      }\n\t    }\n\t    return $val.Left < $val.Right;\n\t  };\n\t  ClipperLib.Clipper.prototype.JoinHorz = function (op1, op1b, op2, op2b, Pt, DiscardLeft)\n\t  {\n\t    var Dir1 = (op1.Pt.X > op1b.Pt.X ? ClipperLib.Direction.dRightToLeft : ClipperLib.Direction.dLeftToRight);\n\t    var Dir2 = (op2.Pt.X > op2b.Pt.X ? ClipperLib.Direction.dRightToLeft : ClipperLib.Direction.dLeftToRight);\n\t    if (Dir1 == Dir2)\n\t      return false;\n\t    //When DiscardLeft, we want Op1b to be on the Left of Op1, otherwise we\n\t    //want Op1b to be on the Right. (And likewise with Op2 and Op2b.)\n\t    //So, to facilitate this while inserting Op1b and Op2b ...\n\t    //when DiscardLeft, make sure we're AT or RIGHT of Pt before adding Op1b,\n\t    //otherwise make sure we're AT or LEFT of Pt. (Likewise with Op2b.)\n\t    if (Dir1 == ClipperLib.Direction.dLeftToRight)\n\t    {\n\t      while (op1.Next.Pt.X <= Pt.X &&\n\t        op1.Next.Pt.X >= op1.Pt.X && op1.Next.Pt.Y == Pt.Y)\n\t        op1 = op1.Next;\n\t      if (DiscardLeft && (op1.Pt.X != Pt.X))\n\t        op1 = op1.Next;\n\t      op1b = this.DupOutPt(op1, !DiscardLeft);\n\t      if (ClipperLib.IntPoint.op_Inequality(op1b.Pt, Pt))\n\t      {\n\t        op1 = op1b;\n\t        //op1.Pt = Pt;\n\t        op1.Pt.X = Pt.X;\n\t        op1.Pt.Y = Pt.Y;\n\t        op1b = this.DupOutPt(op1, !DiscardLeft);\n\t      }\n\t    }\n\t    else\n\t    {\n\t      while (op1.Next.Pt.X >= Pt.X &&\n\t        op1.Next.Pt.X <= op1.Pt.X && op1.Next.Pt.Y == Pt.Y)\n\t        op1 = op1.Next;\n\t      if (!DiscardLeft && (op1.Pt.X != Pt.X))\n\t        op1 = op1.Next;\n\t      op1b = this.DupOutPt(op1, DiscardLeft);\n\t      if (ClipperLib.IntPoint.op_Inequality(op1b.Pt, Pt))\n\t      {\n\t        op1 = op1b;\n\t        //op1.Pt = Pt;\n\t        op1.Pt.X = Pt.X;\n\t        op1.Pt.Y = Pt.Y;\n\t        op1b = this.DupOutPt(op1, DiscardLeft);\n\t      }\n\t    }\n\t    if (Dir2 == ClipperLib.Direction.dLeftToRight)\n\t    {\n\t      while (op2.Next.Pt.X <= Pt.X &&\n\t        op2.Next.Pt.X >= op2.Pt.X && op2.Next.Pt.Y == Pt.Y)\n\t        op2 = op2.Next;\n\t      if (DiscardLeft && (op2.Pt.X != Pt.X))\n\t        op2 = op2.Next;\n\t      op2b = this.DupOutPt(op2, !DiscardLeft);\n\t      if (ClipperLib.IntPoint.op_Inequality(op2b.Pt, Pt))\n\t      {\n\t        op2 = op2b;\n\t        //op2.Pt = Pt;\n\t        op2.Pt.X = Pt.X;\n\t        op2.Pt.Y = Pt.Y;\n\t        op2b = this.DupOutPt(op2, !DiscardLeft);\n\t      }\n\t    }\n\t    else\n\t    {\n\t      while (op2.Next.Pt.X >= Pt.X &&\n\t        op2.Next.Pt.X <= op2.Pt.X && op2.Next.Pt.Y == Pt.Y)\n\t        op2 = op2.Next;\n\t      if (!DiscardLeft && (op2.Pt.X != Pt.X))\n\t        op2 = op2.Next;\n\t      op2b = this.DupOutPt(op2, DiscardLeft);\n\t      if (ClipperLib.IntPoint.op_Inequality(op2b.Pt, Pt))\n\t      {\n\t        op2 = op2b;\n\t        //op2.Pt = Pt;\n\t        op2.Pt.X = Pt.X;\n\t        op2.Pt.Y = Pt.Y;\n\t        op2b = this.DupOutPt(op2, DiscardLeft);\n\t      }\n\t    }\n\t    if ((Dir1 == ClipperLib.Direction.dLeftToRight) == DiscardLeft)\n\t    {\n\t      op1.Prev = op2;\n\t      op2.Next = op1;\n\t      op1b.Next = op2b;\n\t      op2b.Prev = op1b;\n\t    }\n\t    else\n\t    {\n\t      op1.Next = op2;\n\t      op2.Prev = op1;\n\t      op1b.Prev = op2b;\n\t      op2b.Next = op1b;\n\t    }\n\t    return true;\n\t  };\n\t  ClipperLib.Clipper.prototype.JoinPoints = function (j, outRec1, outRec2)\n\t  {\n\t    var op1 = j.OutPt1,\n\t      op1b = new ClipperLib.OutPt();\n\t    var op2 = j.OutPt2,\n\t      op2b = new ClipperLib.OutPt();\n\t    //There are 3 kinds of joins for output polygons ...\n\t    //1. Horizontal joins where Join.OutPt1 & Join.OutPt2 are a vertices anywhere\n\t    //along (horizontal) collinear edges (& Join.OffPt is on the same horizontal).\n\t    //2. Non-horizontal joins where Join.OutPt1 & Join.OutPt2 are at the same\n\t    //location at the Bottom of the overlapping segment (& Join.OffPt is above).\n\t    //3. StrictlySimple joins where edges touch but are not collinear and where\n\t    //Join.OutPt1, Join.OutPt2 & Join.OffPt all share the same point.\n\t    var isHorizontal = (j.OutPt1.Pt.Y == j.OffPt.Y);\n\t    if (isHorizontal && (ClipperLib.IntPoint.op_Equality(j.OffPt, j.OutPt1.Pt)) && (ClipperLib.IntPoint.op_Equality(j.OffPt, j.OutPt2.Pt)))\n\t    {\n\t      //Strictly Simple join ...\n\t\t\t\tif (outRec1 != outRec2) return false;\n\t\n\t      op1b = j.OutPt1.Next;\n\t      while (op1b != op1 && (ClipperLib.IntPoint.op_Equality(op1b.Pt, j.OffPt)))\n\t        op1b = op1b.Next;\n\t      var reverse1 = (op1b.Pt.Y > j.OffPt.Y);\n\t      op2b = j.OutPt2.Next;\n\t      while (op2b != op2 && (ClipperLib.IntPoint.op_Equality(op2b.Pt, j.OffPt)))\n\t        op2b = op2b.Next;\n\t      var reverse2 = (op2b.Pt.Y > j.OffPt.Y);\n\t      if (reverse1 == reverse2)\n\t        return false;\n\t      if (reverse1)\n\t      {\n\t        op1b = this.DupOutPt(op1, false);\n\t        op2b = this.DupOutPt(op2, true);\n\t        op1.Prev = op2;\n\t        op2.Next = op1;\n\t        op1b.Next = op2b;\n\t        op2b.Prev = op1b;\n\t        j.OutPt1 = op1;\n\t        j.OutPt2 = op1b;\n\t        return true;\n\t      }\n\t      else\n\t      {\n\t        op1b = this.DupOutPt(op1, true);\n\t        op2b = this.DupOutPt(op2, false);\n\t        op1.Next = op2;\n\t        op2.Prev = op1;\n\t        op1b.Prev = op2b;\n\t        op2b.Next = op1b;\n\t        j.OutPt1 = op1;\n\t        j.OutPt2 = op1b;\n\t        return true;\n\t      }\n\t    }\n\t    else if (isHorizontal)\n\t    {\n\t      //treat horizontal joins differently to non-horizontal joins since with\n\t      //them we're not yet sure where the overlapping is. OutPt1.Pt & OutPt2.Pt\n\t      //may be anywhere along the horizontal edge.\n\t      op1b = op1;\n\t      while (op1.Prev.Pt.Y == op1.Pt.Y && op1.Prev != op1b && op1.Prev != op2)\n\t        op1 = op1.Prev;\n\t      while (op1b.Next.Pt.Y == op1b.Pt.Y && op1b.Next != op1 && op1b.Next != op2)\n\t        op1b = op1b.Next;\n\t      if (op1b.Next == op1 || op1b.Next == op2)\n\t        return false;\n\t      //a flat 'polygon'\n\t      op2b = op2;\n\t      while (op2.Prev.Pt.Y == op2.Pt.Y && op2.Prev != op2b && op2.Prev != op1b)\n\t        op2 = op2.Prev;\n\t      while (op2b.Next.Pt.Y == op2b.Pt.Y && op2b.Next != op2 && op2b.Next != op1)\n\t        op2b = op2b.Next;\n\t      if (op2b.Next == op2 || op2b.Next == op1)\n\t        return false;\n\t      //a flat 'polygon'\n\t      //Op1 -. Op1b & Op2 -. Op2b are the extremites of the horizontal edges\n\t\n\t      var $val = {Left: null, Right: null};\n\t      if (!this.GetOverlap(op1.Pt.X, op1b.Pt.X, op2.Pt.X, op2b.Pt.X, $val))\n\t        return false;\n\t      var Left = $val.Left;\n\t      var Right = $val.Right;\n\t\n\t      //DiscardLeftSide: when overlapping edges are joined, a spike will created\n\t      //which needs to be cleaned up. However, we don't want Op1 or Op2 caught up\n\t      //on the discard Side as either may still be needed for other joins ...\n\t      var Pt = new ClipperLib.IntPoint();\n\t      var DiscardLeftSide;\n\t      if (op1.Pt.X >= Left && op1.Pt.X <= Right)\n\t      {\n\t        //Pt = op1.Pt;\n\t        Pt.X = op1.Pt.X;\n\t        Pt.Y = op1.Pt.Y;\n\t        DiscardLeftSide = (op1.Pt.X > op1b.Pt.X);\n\t      }\n\t      else if (op2.Pt.X >= Left && op2.Pt.X <= Right)\n\t      {\n\t        //Pt = op2.Pt;\n\t        Pt.X = op2.Pt.X;\n\t        Pt.Y = op2.Pt.Y;\n\t        DiscardLeftSide = (op2.Pt.X > op2b.Pt.X);\n\t      }\n\t      else if (op1b.Pt.X >= Left && op1b.Pt.X <= Right)\n\t      {\n\t        //Pt = op1b.Pt;\n\t        Pt.X = op1b.Pt.X;\n\t        Pt.Y = op1b.Pt.Y;\n\t        DiscardLeftSide = op1b.Pt.X > op1.Pt.X;\n\t      }\n\t      else\n\t      {\n\t        //Pt = op2b.Pt;\n\t        Pt.X = op2b.Pt.X;\n\t        Pt.Y = op2b.Pt.Y;\n\t        DiscardLeftSide = (op2b.Pt.X > op2.Pt.X);\n\t      }\n\t      j.OutPt1 = op1;\n\t      j.OutPt2 = op2;\n\t      return this.JoinHorz(op1, op1b, op2, op2b, Pt, DiscardLeftSide);\n\t    }\n\t    else\n\t    {\n\t      //nb: For non-horizontal joins ...\n\t      //    1. Jr.OutPt1.Pt.Y == Jr.OutPt2.Pt.Y\n\t      //    2. Jr.OutPt1.Pt > Jr.OffPt.Y\n\t      //make sure the polygons are correctly oriented ...\n\t      op1b = op1.Next;\n\t      while ((ClipperLib.IntPoint.op_Equality(op1b.Pt, op1.Pt)) && (op1b != op1))\n\t        op1b = op1b.Next;\n\t      var Reverse1 = ((op1b.Pt.Y > op1.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual(op1.Pt, op1b.Pt, j.OffPt, this.m_UseFullRange));\n\t      if (Reverse1)\n\t      {\n\t        op1b = op1.Prev;\n\t        while ((ClipperLib.IntPoint.op_Equality(op1b.Pt, op1.Pt)) && (op1b != op1))\n\t          op1b = op1b.Prev;\n\t        if ((op1b.Pt.Y > op1.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual(op1.Pt, op1b.Pt, j.OffPt, this.m_UseFullRange))\n\t          return false;\n\t      }\n\t      op2b = op2.Next;\n\t      while ((ClipperLib.IntPoint.op_Equality(op2b.Pt, op2.Pt)) && (op2b != op2))\n\t        op2b = op2b.Next;\n\t      var Reverse2 = ((op2b.Pt.Y > op2.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual(op2.Pt, op2b.Pt, j.OffPt, this.m_UseFullRange));\n\t      if (Reverse2)\n\t      {\n\t        op2b = op2.Prev;\n\t        while ((ClipperLib.IntPoint.op_Equality(op2b.Pt, op2.Pt)) && (op2b != op2))\n\t          op2b = op2b.Prev;\n\t        if ((op2b.Pt.Y > op2.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual(op2.Pt, op2b.Pt, j.OffPt, this.m_UseFullRange))\n\t          return false;\n\t      }\n\t      if ((op1b == op1) || (op2b == op2) || (op1b == op2b) ||\n\t        ((outRec1 == outRec2) && (Reverse1 == Reverse2)))\n\t        return false;\n\t      if (Reverse1)\n\t      {\n\t        op1b = this.DupOutPt(op1, false);\n\t        op2b = this.DupOutPt(op2, true);\n\t        op1.Prev = op2;\n\t        op2.Next = op1;\n\t        op1b.Next = op2b;\n\t        op2b.Prev = op1b;\n\t        j.OutPt1 = op1;\n\t        j.OutPt2 = op1b;\n\t        return true;\n\t      }\n\t      else\n\t      {\n\t        op1b = this.DupOutPt(op1, true);\n\t        op2b = this.DupOutPt(op2, false);\n\t        op1.Next = op2;\n\t        op2.Prev = op1;\n\t        op1b.Prev = op2b;\n\t        op2b.Next = op1b;\n\t        j.OutPt1 = op1;\n\t        j.OutPt2 = op1b;\n\t        return true;\n\t      }\n\t    }\n\t  };\n\t  ClipperLib.Clipper.GetBounds = function (paths)\n\t  {\n\t    var i = 0,\n\t      cnt = paths.length;\n\t    while (i < cnt && paths[i].length == 0) i++;\n\t    if (i == cnt) return new ClipperLib.IntRect(0, 0, 0, 0);\n\t    var result = new ClipperLib.IntRect();\n\t    result.left = paths[i][0].X;\n\t    result.right = result.left;\n\t    result.top = paths[i][0].Y;\n\t    result.bottom = result.top;\n\t    for (; i < cnt; i++)\n\t      for (var j = 0, jlen = paths[i].length; j < jlen; j++)\n\t      {\n\t        if (paths[i][j].X < result.left) result.left = paths[i][j].X;\n\t        else if (paths[i][j].X > result.right) result.right = paths[i][j].X;\n\t        if (paths[i][j].Y < result.top) result.top = paths[i][j].Y;\n\t        else if (paths[i][j].Y > result.bottom) result.bottom = paths[i][j].Y;\n\t      }\n\t    return result;\n\t  }\n\t  ClipperLib.Clipper.prototype.GetBounds2 = function (ops)\n\t  {\n\t    var opStart = ops;\n\t    var result = new ClipperLib.IntRect();\n\t    result.left = ops.Pt.X;\n\t    result.right = ops.Pt.X;\n\t    result.top = ops.Pt.Y;\n\t    result.bottom = ops.Pt.Y;\n\t    ops = ops.Next;\n\t    while (ops != opStart)\n\t    {\n\t      if (ops.Pt.X < result.left)\n\t        result.left = ops.Pt.X;\n\t      if (ops.Pt.X > result.right)\n\t        result.right = ops.Pt.X;\n\t      if (ops.Pt.Y < result.top)\n\t        result.top = ops.Pt.Y;\n\t      if (ops.Pt.Y > result.bottom)\n\t        result.bottom = ops.Pt.Y;\n\t      ops = ops.Next;\n\t    }\n\t    return result;\n\t  };\n\t\n\t  ClipperLib.Clipper.PointInPolygon = function (pt, path)\n\t  {\n\t    //returns 0 if false, +1 if true, -1 if pt ON polygon boundary\n\t\t\t//See \"The Point in Polygon Problem for Arbitrary Polygons\" by Hormann & Agathos\n\t    //http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.88.5498&rep=rep1&type=pdf\n\t    var result = 0,\n\t      cnt = path.length;\n\t    if (cnt < 3)\n\t      return 0;\n\t    var ip = path[0];\n\t    for (var i = 1; i <= cnt; ++i)\n\t    {\n\t      var ipNext = (i == cnt ? path[0] : path[i]);\n\t      if (ipNext.Y == pt.Y)\n\t      {\n\t        if ((ipNext.X == pt.X) || (ip.Y == pt.Y && ((ipNext.X > pt.X) == (ip.X < pt.X))))\n\t          return -1;\n\t      }\n\t      if ((ip.Y < pt.Y) != (ipNext.Y < pt.Y))\n\t      {\n\t        if (ip.X >= pt.X)\n\t        {\n\t          if (ipNext.X > pt.X)\n\t            result = 1 - result;\n\t          else\n\t          {\n\t            var d = (ip.X - pt.X) * (ipNext.Y - pt.Y) - (ipNext.X - pt.X) * (ip.Y - pt.Y);\n\t            if (d == 0)\n\t              return -1;\n\t            else if ((d > 0) == (ipNext.Y > ip.Y))\n\t              result = 1 - result;\n\t          }\n\t        }\n\t        else\n\t        {\n\t          if (ipNext.X > pt.X)\n\t          {\n\t            var d = (ip.X - pt.X) * (ipNext.Y - pt.Y) - (ipNext.X - pt.X) * (ip.Y - pt.Y);\n\t            if (d == 0)\n\t              return -1;\n\t            else if ((d > 0) == (ipNext.Y > ip.Y))\n\t              result = 1 - result;\n\t          }\n\t        }\n\t      }\n\t      ip = ipNext;\n\t    }\n\t    return result;\n\t  };\n\t\n\t  ClipperLib.Clipper.prototype.PointInPolygon = function (pt, op)\n\t  {\n\t    //returns 0 if false, +1 if true, -1 if pt ON polygon boundary\n\t\t\t//See \"The Point in Polygon Problem for Arbitrary Polygons\" by Hormann & Agathos\n\t    //http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.88.5498&rep=rep1&type=pdf\n\t    var result = 0;\n\t    var startOp = op;\n\t\t\tvar ptx = pt.X, pty = pt.Y;\n\t    var poly0x = op.Pt.X, poly0y = op.Pt.Y;\n\t    do\n\t    {\n\t\t\t\top = op.Next;\n\t\t\t\tvar poly1x = op.Pt.X, poly1y = op.Pt.Y;\n\t      if (poly1y == pty)\n\t      {\n\t        if ((poly1x == ptx) || (poly0y == pty && ((poly1x > ptx) == (poly0x < ptx))))\n\t          return -1;\n\t      }\n\t      if ((poly0y < pty) != (poly1y < pty))\n\t      {\n\t        if (poly0x >= ptx)\n\t        {\n\t          if (poly1x > ptx)\n\t            result = 1 - result;\n\t          else\n\t          {\n\t            var d = (poly0x - ptx) * (poly1y - pty) - (poly1x - ptx) * (poly0y - pty);\n\t            if (d == 0)\n\t              return -1;\n\t            if ((d > 0) == (poly1y > poly0y))\n\t              result = 1 - result;\n\t          }\n\t        }\n\t        else\n\t        {\n\t          if (poly1x > ptx)\n\t          {\n\t            var d = (poly0x - ptx) * (poly1y - pty) - (poly1x - ptx) * (poly0y - pty);\n\t            if (d == 0)\n\t              return -1;\n\t            if ((d > 0) == (poly1y > poly0y))\n\t              result = 1 - result;\n\t          }\n\t        }\n\t      }\n\t      poly0x = poly1x;\n\t      poly0y = poly1y;\n\t    } while (startOp != op);\n\t\n\t    return result;\n\t  };\n\t\n\t  ClipperLib.Clipper.prototype.Poly2ContainsPoly1 = function (outPt1, outPt2)\n\t  {\n\t    var op = outPt1;\n\t    do\n\t    {\n\t\t\t\t//nb: PointInPolygon returns 0 if false, +1 if true, -1 if pt on polygon\n\t      var res = this.PointInPolygon(op.Pt, outPt2);\n\t      if (res >= 0)\n\t        return res > 0;\n\t      op = op.Next;\n\t    }\n\t    while (op != outPt1)\n\t    return true;\n\t  };\n\t  ClipperLib.Clipper.prototype.FixupFirstLefts1 = function (OldOutRec, NewOutRec)\n\t  {\n\t    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n\t    {\n\t\t\t\tvar outRec = this.m_PolyOuts[i];\n\t\t\t\tif (outRec.Pts == null || outRec.FirstLeft == null)\n\t\t\t\t\tcontinue;\n\t\t\t\tvar firstLeft = this.ParseFirstLeft(outRec.FirstLeft);\n\t\t\t\tif (firstLeft == OldOutRec)\n\t\t\t\t{\n\t        if (this.Poly2ContainsPoly1(outRec.Pts, NewOutRec.Pts))\n\t          outRec.FirstLeft = NewOutRec;\n\t      }\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.FixupFirstLefts2 = function (OldOutRec, NewOutRec)\n\t  {\n\t    for (var $i2 = 0, $t2 = this.m_PolyOuts, $l2 = $t2.length, outRec = $t2[$i2]; $i2 < $l2; $i2++, outRec = $t2[$i2])\n\t      if (outRec.FirstLeft == OldOutRec)\n\t        outRec.FirstLeft = NewOutRec;\n\t  };\n\t  ClipperLib.Clipper.ParseFirstLeft = function (FirstLeft)\n\t  {\n\t    while (FirstLeft != null && FirstLeft.Pts == null)\n\t      FirstLeft = FirstLeft.FirstLeft;\n\t    return FirstLeft;\n\t  };\n\t  ClipperLib.Clipper.prototype.JoinCommonEdges = function ()\n\t  {\n\t    for (var i = 0, ilen = this.m_Joins.length; i < ilen; i++)\n\t    {\n\t      var join = this.m_Joins[i];\n\t      var outRec1 = this.GetOutRec(join.OutPt1.Idx);\n\t      var outRec2 = this.GetOutRec(join.OutPt2.Idx);\n\t      if (outRec1.Pts == null || outRec2.Pts == null)\n\t        continue;\n\t      //get the polygon fragment with the correct hole state (FirstLeft)\n\t      //before calling JoinPoints() ...\n\t      var holeStateRec;\n\t      if (outRec1 == outRec2)\n\t        holeStateRec = outRec1;\n\t      else if (this.Param1RightOfParam2(outRec1, outRec2))\n\t        holeStateRec = outRec2;\n\t      else if (this.Param1RightOfParam2(outRec2, outRec1))\n\t        holeStateRec = outRec1;\n\t      else\n\t        holeStateRec = this.GetLowermostRec(outRec1, outRec2);\n\t\n\t      if (!this.JoinPoints(join, outRec1, outRec2)) continue;\n\t\n\t      if (outRec1 == outRec2)\n\t      {\n\t        //instead of joining two polygons, we've just created a new one by\n\t        //splitting one polygon into two.\n\t        outRec1.Pts = join.OutPt1;\n\t        outRec1.BottomPt = null;\n\t        outRec2 = this.CreateOutRec();\n\t        outRec2.Pts = join.OutPt2;\n\t        //update all OutRec2.Pts Idx's ...\n\t        this.UpdateOutPtIdxs(outRec2);\n\t        //We now need to check every OutRec.FirstLeft pointer. If it points\n\t        //to OutRec1 it may need to point to OutRec2 instead ...\n\t        if (this.m_UsingPolyTree)\n\t          for (var j = 0, jlen = this.m_PolyOuts.length; j < jlen - 1; j++)\n\t          {\n\t            var oRec = this.m_PolyOuts[j];\n\t            if (oRec.Pts == null || ClipperLib.Clipper.ParseFirstLeft(oRec.FirstLeft) != outRec1 || oRec.IsHole == outRec1.IsHole)\n\t              continue;\n\t            if (this.Poly2ContainsPoly1(oRec.Pts, join.OutPt2))\n\t              oRec.FirstLeft = outRec2;\n\t          }\n\t        if (this.Poly2ContainsPoly1(outRec2.Pts, outRec1.Pts))\n\t        {\n\t          //outRec2 is contained by outRec1 ...\n\t          outRec2.IsHole = !outRec1.IsHole;\n\t          outRec2.FirstLeft = outRec1;\n\t          //fixup FirstLeft pointers that may need reassigning to OutRec1\n\t          if (this.m_UsingPolyTree)\n\t            this.FixupFirstLefts2(outRec2, outRec1);\n\t          if ((outRec2.IsHole ^ this.ReverseSolution) == (this.Area(outRec2) > 0))\n\t            this.ReversePolyPtLinks(outRec2.Pts);\n\t        }\n\t        else if (this.Poly2ContainsPoly1(outRec1.Pts, outRec2.Pts))\n\t        {\n\t          //outRec1 is contained by outRec2 ...\n\t          outRec2.IsHole = outRec1.IsHole;\n\t          outRec1.IsHole = !outRec2.IsHole;\n\t          outRec2.FirstLeft = outRec1.FirstLeft;\n\t          outRec1.FirstLeft = outRec2;\n\t          //fixup FirstLeft pointers that may need reassigning to OutRec1\n\t          if (this.m_UsingPolyTree)\n\t            this.FixupFirstLefts2(outRec1, outRec2);\n\t          if ((outRec1.IsHole ^ this.ReverseSolution) == (this.Area(outRec1) > 0))\n\t            this.ReversePolyPtLinks(outRec1.Pts);\n\t        }\n\t        else\n\t        {\n\t          //the 2 polygons are completely separate ...\n\t          outRec2.IsHole = outRec1.IsHole;\n\t          outRec2.FirstLeft = outRec1.FirstLeft;\n\t          //fixup FirstLeft pointers that may need reassigning to OutRec2\n\t          if (this.m_UsingPolyTree)\n\t            this.FixupFirstLefts1(outRec1, outRec2);\n\t        }\n\t      }\n\t      else\n\t      {\n\t        //joined 2 polygons together ...\n\t        outRec2.Pts = null;\n\t        outRec2.BottomPt = null;\n\t        outRec2.Idx = outRec1.Idx;\n\t        outRec1.IsHole = holeStateRec.IsHole;\n\t        if (holeStateRec == outRec2)\n\t          outRec1.FirstLeft = outRec2.FirstLeft;\n\t        outRec2.FirstLeft = outRec1;\n\t        //fixup FirstLeft pointers that may need reassigning to OutRec1\n\t        if (this.m_UsingPolyTree)\n\t          this.FixupFirstLefts2(outRec2, outRec1);\n\t      }\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.UpdateOutPtIdxs = function (outrec)\n\t  {\n\t    var op = outrec.Pts;\n\t    do {\n\t      op.Idx = outrec.Idx;\n\t      op = op.Prev;\n\t    }\n\t    while (op != outrec.Pts)\n\t  };\n\t  ClipperLib.Clipper.prototype.DoSimplePolygons = function ()\n\t  {\n\t    var i = 0;\n\t    while (i < this.m_PolyOuts.length)\n\t    {\n\t      var outrec = this.m_PolyOuts[i++];\n\t      var op = outrec.Pts;\n\t\t\t\tif (op == null || outrec.IsOpen)\n\t\t\t\t\tcontinue;\n\t      do //for each Pt in Polygon until duplicate found do ...\n\t      {\n\t        var op2 = op.Next;\n\t        while (op2 != outrec.Pts)\n\t        {\n\t          if ((ClipperLib.IntPoint.op_Equality(op.Pt, op2.Pt)) && op2.Next != op && op2.Prev != op)\n\t          {\n\t            //split the polygon into two ...\n\t            var op3 = op.Prev;\n\t            var op4 = op2.Prev;\n\t            op.Prev = op4;\n\t            op4.Next = op;\n\t            op2.Prev = op3;\n\t            op3.Next = op2;\n\t            outrec.Pts = op;\n\t            var outrec2 = this.CreateOutRec();\n\t            outrec2.Pts = op2;\n\t            this.UpdateOutPtIdxs(outrec2);\n\t            if (this.Poly2ContainsPoly1(outrec2.Pts, outrec.Pts))\n\t            {\n\t              //OutRec2 is contained by OutRec1 ...\n\t              outrec2.IsHole = !outrec.IsHole;\n\t              outrec2.FirstLeft = outrec;\n\t\t\t\t\t\t\t\tif (this.m_UsingPolyTree) this.FixupFirstLefts2(outrec2, outrec);\n\t\n\t            }\n\t            else if (this.Poly2ContainsPoly1(outrec.Pts, outrec2.Pts))\n\t            {\n\t              //OutRec1 is contained by OutRec2 ...\n\t              outrec2.IsHole = outrec.IsHole;\n\t              outrec.IsHole = !outrec2.IsHole;\n\t              outrec2.FirstLeft = outrec.FirstLeft;\n\t              outrec.FirstLeft = outrec2;\n\t              if (this.m_UsingPolyTree) this.FixupFirstLefts2(outrec, outrec2);\n\t            }\n\t            else\n\t            {\n\t              //the 2 polygons are separate ...\n\t              outrec2.IsHole = outrec.IsHole;\n\t              outrec2.FirstLeft = outrec.FirstLeft;\n\t\t\t\t\t\t\t\tif (this.m_UsingPolyTree) this.FixupFirstLefts1(outrec, outrec2);\n\t            }\n\t            op2 = op;\n\t            //ie get ready for the next iteration\n\t          }\n\t          op2 = op2.Next;\n\t        }\n\t        op = op.Next;\n\t      }\n\t      while (op != outrec.Pts)\n\t    }\n\t  };\n\t  ClipperLib.Clipper.Area = function (poly)\n\t  {\n\t    var cnt = poly.length;\n\t    if (cnt < 3)\n\t      return 0;\n\t    var a = 0;\n\t    for (var i = 0, j = cnt - 1; i < cnt; ++i)\n\t    {\n\t      a += (poly[j].X + poly[i].X) * (poly[j].Y - poly[i].Y);\n\t      j = i;\n\t    }\n\t    return -a * 0.5;\n\t  };\n\t  ClipperLib.Clipper.prototype.Area = function (outRec)\n\t  {\n\t    var op = outRec.Pts;\n\t    if (op == null)\n\t      return 0;\n\t    var a = 0;\n\t    do {\n\t      a = a + (op.Prev.Pt.X + op.Pt.X) * (op.Prev.Pt.Y - op.Pt.Y);\n\t      op = op.Next;\n\t    }\n\t    while (op != outRec.Pts)\n\t    return a * 0.5;\n\t  };\n\t  ClipperLib.Clipper.SimplifyPolygon = function (poly, fillType)\n\t  {\n\t    var result = new Array();\n\t    var c = new ClipperLib.Clipper(0);\n\t    c.StrictlySimple = true;\n\t    c.AddPath(poly, ClipperLib.PolyType.ptSubject, true);\n\t    c.Execute(ClipperLib.ClipType.ctUnion, result, fillType, fillType);\n\t    return result;\n\t  };\n\t  ClipperLib.Clipper.SimplifyPolygons = function (polys, fillType)\n\t  {\n\t    if (typeof (fillType) == \"undefined\") fillType = ClipperLib.PolyFillType.pftEvenOdd;\n\t    var result = new Array();\n\t    var c = new ClipperLib.Clipper(0);\n\t    c.StrictlySimple = true;\n\t    c.AddPaths(polys, ClipperLib.PolyType.ptSubject, true);\n\t    c.Execute(ClipperLib.ClipType.ctUnion, result, fillType, fillType);\n\t    return result;\n\t  };\n\t  ClipperLib.Clipper.DistanceSqrd = function (pt1, pt2)\n\t  {\n\t    var dx = (pt1.X - pt2.X);\n\t    var dy = (pt1.Y - pt2.Y);\n\t    return (dx * dx + dy * dy);\n\t  };\n\t  ClipperLib.Clipper.DistanceFromLineSqrd = function (pt, ln1, ln2)\n\t  {\n\t    //The equation of a line in general form (Ax + By + C = 0)\n\t    //given 2 points (x¹,y¹) & (x²,y²) is ...\n\t    //(y¹ - y²)x + (x² - x¹)y + (y² - y¹)x¹ - (x² - x¹)y¹ = 0\n\t    //A = (y¹ - y²); B = (x² - x¹); C = (y² - y¹)x¹ - (x² - x¹)y¹\n\t    //perpendicular distance of point (x³,y³) = (Ax³ + By³ + C)/Sqrt(A² + B²)\n\t    //see http://en.wikipedia.org/wiki/Perpendicular_distance\n\t    var A = ln1.Y - ln2.Y;\n\t    var B = ln2.X - ln1.X;\n\t    var C = A * ln1.X + B * ln1.Y;\n\t    C = A * pt.X + B * pt.Y - C;\n\t    return (C * C) / (A * A + B * B);\n\t  };\n\t\n\t\tClipperLib.Clipper.SlopesNearCollinear = function(pt1, pt2, pt3, distSqrd)\n\t\t{\n\t\t\t//this function is more accurate when the point that's GEOMETRICALLY\n\t\t\t//between the other 2 points is the one that's tested for distance.\n\t\t\t//nb: with 'spikes', either pt1 or pt3 is geometrically between the other pts\n\t\t\tif (Math.abs(pt1.X - pt2.X) > Math.abs(pt1.Y - pt2.Y))\n\t\t\t{\n\t\t\tif ((pt1.X > pt2.X) == (pt1.X < pt3.X))\n\t\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt1, pt2, pt3) < distSqrd;\n\t\t\telse if ((pt2.X > pt1.X) == (pt2.X < pt3.X))\n\t\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt2, pt1, pt3) < distSqrd;\n\t\t\t\t\telse\n\t\t\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt3, pt1, pt2) < distSqrd;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\tif ((pt1.Y > pt2.Y) == (pt1.Y < pt3.Y))\n\t\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt1, pt2, pt3) < distSqrd;\n\t\t\telse if ((pt2.Y > pt1.Y) == (pt2.Y < pt3.Y))\n\t\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt2, pt1, pt3) < distSqrd;\n\t\t\t\t\telse\n\t\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt3, pt1, pt2) < distSqrd;\n\t\t\t}\n\t\t}\n\t\n\t  ClipperLib.Clipper.PointsAreClose = function (pt1, pt2, distSqrd)\n\t  {\n\t    var dx = pt1.X - pt2.X;\n\t    var dy = pt1.Y - pt2.Y;\n\t    return ((dx * dx) + (dy * dy) <= distSqrd);\n\t  };\n\t  //------------------------------------------------------------------------------\n\t  ClipperLib.Clipper.ExcludeOp = function (op)\n\t  {\n\t    var result = op.Prev;\n\t    result.Next = op.Next;\n\t    op.Next.Prev = result;\n\t    result.Idx = 0;\n\t    return result;\n\t  };\n\t  ClipperLib.Clipper.CleanPolygon = function (path, distance)\n\t  {\n\t    if (typeof (distance) == \"undefined\") distance = 1.415;\n\t    //distance = proximity in units/pixels below which vertices will be stripped.\n\t    //Default ~= sqrt(2) so when adjacent vertices or semi-adjacent vertices have\n\t    //both x & y coords within 1 unit, then the second vertex will be stripped.\n\t    var cnt = path.length;\n\t    if (cnt == 0)\n\t      return new Array();\n\t    var outPts = new Array(cnt);\n\t    for (var i = 0; i < cnt; ++i)\n\t      outPts[i] = new ClipperLib.OutPt();\n\t    for (var i = 0; i < cnt; ++i)\n\t    {\n\t      outPts[i].Pt = path[i];\n\t      outPts[i].Next = outPts[(i + 1) % cnt];\n\t      outPts[i].Next.Prev = outPts[i];\n\t      outPts[i].Idx = 0;\n\t    }\n\t    var distSqrd = distance * distance;\n\t    var op = outPts[0];\n\t    while (op.Idx == 0 && op.Next != op.Prev)\n\t    {\n\t      if (ClipperLib.Clipper.PointsAreClose(op.Pt, op.Prev.Pt, distSqrd))\n\t      {\n\t        op = ClipperLib.Clipper.ExcludeOp(op);\n\t        cnt--;\n\t      }\n\t      else if (ClipperLib.Clipper.PointsAreClose(op.Prev.Pt, op.Next.Pt, distSqrd))\n\t      {\n\t        ClipperLib.Clipper.ExcludeOp(op.Next);\n\t        op = ClipperLib.Clipper.ExcludeOp(op);\n\t        cnt -= 2;\n\t      }\n\t      else if (ClipperLib.Clipper.SlopesNearCollinear(op.Prev.Pt, op.Pt, op.Next.Pt, distSqrd))\n\t      {\n\t        op = ClipperLib.Clipper.ExcludeOp(op);\n\t        cnt--;\n\t      }\n\t      else\n\t      {\n\t        op.Idx = 1;\n\t        op = op.Next;\n\t      }\n\t    }\n\t    if (cnt < 3)\n\t      cnt = 0;\n\t    var result = new Array(cnt);\n\t    for (var i = 0; i < cnt; ++i)\n\t    {\n\t      result[i] = new ClipperLib.IntPoint(op.Pt);\n\t      op = op.Next;\n\t    }\n\t    outPts = null;\n\t    return result;\n\t  };\n\t  ClipperLib.Clipper.CleanPolygons = function (polys, distance)\n\t  {\n\t    var result = new Array(polys.length);\n\t    for (var i = 0, ilen = polys.length; i < ilen; i++)\n\t      result[i] = ClipperLib.Clipper.CleanPolygon(polys[i], distance);\n\t    return result;\n\t  };\n\t  ClipperLib.Clipper.Minkowski = function (pattern, path, IsSum, IsClosed)\n\t  {\n\t    var delta = (IsClosed ? 1 : 0);\n\t    var polyCnt = pattern.length;\n\t    var pathCnt = path.length;\n\t    var result = new Array();\n\t    if (IsSum)\n\t      for (var i = 0; i < pathCnt; i++)\n\t      {\n\t        var p = new Array(polyCnt);\n\t        for (var j = 0, jlen = pattern.length, ip = pattern[j]; j < jlen; j++, ip = pattern[j])\n\t          p[j] = new ClipperLib.IntPoint(path[i].X + ip.X, path[i].Y + ip.Y);\n\t        result.push(p);\n\t      }\n\t    else\n\t      for (var i = 0; i < pathCnt; i++)\n\t      {\n\t        var p = new Array(polyCnt);\n\t        for (var j = 0, jlen = pattern.length, ip = pattern[j]; j < jlen; j++, ip = pattern[j])\n\t          p[j] = new ClipperLib.IntPoint(path[i].X - ip.X, path[i].Y - ip.Y);\n\t        result.push(p);\n\t      }\n\t    var quads = new Array();\n\t    for (var i = 0; i < pathCnt - 1 + delta; i++)\n\t      for (var j = 0; j < polyCnt; j++)\n\t      {\n\t        var quad = new Array();\n\t        quad.push(result[i % pathCnt][j % polyCnt]);\n\t        quad.push(result[(i + 1) % pathCnt][j % polyCnt]);\n\t        quad.push(result[(i + 1) % pathCnt][(j + 1) % polyCnt]);\n\t        quad.push(result[i % pathCnt][(j + 1) % polyCnt]);\n\t        if (!ClipperLib.Clipper.Orientation(quad))\n\t          quad.reverse();\n\t        quads.push(quad);\n\t      }\n\t\t\t\treturn quads;\n\t  };\n\t\n\t\tClipperLib.Clipper.MinkowskiSum = function(pattern, path_or_paths, pathIsClosed)\n\t\t{\n\t\t\tif(!(path_or_paths[0] instanceof Array))\n\t\t\t{\n\t\t\t\tvar path = path_or_paths;\n\t\t\t\tvar paths = ClipperLib.Clipper.Minkowski(pattern, path, true, pathIsClosed);\n\t\t\t\tvar c = new ClipperLib.Clipper();\n\t\t\t\tc.AddPaths(paths, ClipperLib.PolyType.ptSubject, true);\n\t\t\t\tc.Execute(ClipperLib.ClipType.ctUnion, paths, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);\n\t\t\t\treturn paths;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t \t\t\tvar paths = path_or_paths;\n\t\t\t\tvar solution = new ClipperLib.Paths();\n\t\t\t\tvar c = new ClipperLib.Clipper();\n\t\t\t\tfor (var i = 0; i < paths.length; ++i)\n\t\t\t\t{\n\t\t\t\t\tvar tmp = ClipperLib.Clipper.Minkowski(pattern, paths[i], true, pathIsClosed);\n\t\t\t\t\tc.AddPaths(tmp, ClipperLib.PolyType.ptSubject, true);\n\t\t\t\t\tif (pathIsClosed)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar path = ClipperLib.Clipper.TranslatePath(paths[i], pattern[0]);\n\t\t\t\t\t\tc.AddPath(path, ClipperLib.PolyType.ptClip, true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tc.Execute(ClipperLib.ClipType.ctUnion, solution,\n\t\t\t\t\tClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);\n\t\t\t\treturn solution;\n\t\t\t}\n\t\t}\n\t\t//------------------------------------------------------------------------------\n\t\n\t\tClipperLib.Clipper.TranslatePath = function (path, delta)\n\t\t{\n\t\t\tvar outPath = new ClipperLib.Path();\n\t\t\tfor (var i = 0; i < path.length; i++)\n\t\t\t\toutPath.push(new ClipperLib.IntPoint(path[i].X + delta.X, path[i].Y + delta.Y));\n\t\t\treturn outPath;\n\t\t}\n\t\t//------------------------------------------------------------------------------\n\t\n\t\tClipperLib.Clipper.MinkowskiDiff = function (poly1, poly2)\n\t\t{\n\t\t\tvar paths = ClipperLib.Clipper.Minkowski(poly1, poly2, false, true);\n\t\t\tvar c = new ClipperLib.Clipper();\n\t\t\tc.AddPaths(paths, ClipperLib.PolyType.ptSubject, true);\n\t\t\tc.Execute(ClipperLib.ClipType.ctUnion, paths, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);\n\t\t\treturn paths;\n\t\t}\n\t\n\t  ClipperLib.Clipper.PolyTreeToPaths = function (polytree)\n\t  {\n\t    var result = new Array();\n\t    //result.set_Capacity(polytree.get_Total());\n\t    ClipperLib.Clipper.AddPolyNodeToPaths(polytree, ClipperLib.Clipper.NodeType.ntAny, result);\n\t    return result;\n\t  };\n\t  ClipperLib.Clipper.AddPolyNodeToPaths = function (polynode, nt, paths)\n\t  {\n\t    var match = true;\n\t    switch (nt)\n\t    {\n\t    case ClipperLib.Clipper.NodeType.ntOpen:\n\t      return;\n\t    case ClipperLib.Clipper.NodeType.ntClosed:\n\t      match = !polynode.IsOpen;\n\t      break;\n\t    default:\n\t      break;\n\t    }\n\t    if (polynode.m_polygon.length > 0 && match)\n\t      paths.push(polynode.m_polygon);\n\t    for (var $i3 = 0, $t3 = polynode.Childs(), $l3 = $t3.length, pn = $t3[$i3]; $i3 < $l3; $i3++, pn = $t3[$i3])\n\t      ClipperLib.Clipper.AddPolyNodeToPaths(pn, nt, paths);\n\t  };\n\t  ClipperLib.Clipper.OpenPathsFromPolyTree = function (polytree)\n\t  {\n\t    var result = new ClipperLib.Paths();\n\t    //result.set_Capacity(polytree.ChildCount());\n\t    for (var i = 0, ilen = polytree.ChildCount(); i < ilen; i++)\n\t      if (polytree.Childs()[i].IsOpen)\n\t        result.push(polytree.Childs()[i].m_polygon);\n\t    return result;\n\t  };\n\t  ClipperLib.Clipper.ClosedPathsFromPolyTree = function (polytree)\n\t  {\n\t    var result = new ClipperLib.Paths();\n\t    //result.set_Capacity(polytree.Total());\n\t    ClipperLib.Clipper.AddPolyNodeToPaths(polytree, ClipperLib.Clipper.NodeType.ntClosed, result);\n\t    return result;\n\t  };\n\t  Inherit(ClipperLib.Clipper, ClipperLib.ClipperBase);\n\t  ClipperLib.Clipper.NodeType = {\n\t    ntAny: 0,\n\t    ntOpen: 1,\n\t    ntClosed: 2\n\t  };\n\t  ClipperLib.ClipperOffset = function (miterLimit, arcTolerance)\n\t  {\n\t    if (typeof (miterLimit) == \"undefined\") miterLimit = 2;\n\t    if (typeof (arcTolerance) == \"undefined\") arcTolerance = ClipperLib.ClipperOffset.def_arc_tolerance;\n\t    this.m_destPolys = new ClipperLib.Paths();\n\t    this.m_srcPoly = new ClipperLib.Path();\n\t    this.m_destPoly = new ClipperLib.Path();\n\t    this.m_normals = new Array();\n\t    this.m_delta = 0;\n\t    this.m_sinA = 0;\n\t    this.m_sin = 0;\n\t    this.m_cos = 0;\n\t    this.m_miterLim = 0;\n\t    this.m_StepsPerRad = 0;\n\t    this.m_lowest = new ClipperLib.IntPoint();\n\t    this.m_polyNodes = new ClipperLib.PolyNode();\n\t    this.MiterLimit = miterLimit;\n\t    this.ArcTolerance = arcTolerance;\n\t    this.m_lowest.X = -1;\n\t  };\n\t  ClipperLib.ClipperOffset.two_pi = 6.28318530717959;\n\t  ClipperLib.ClipperOffset.def_arc_tolerance = 0.25;\n\t  ClipperLib.ClipperOffset.prototype.Clear = function ()\n\t  {\n\t    ClipperLib.Clear(this.m_polyNodes.Childs());\n\t    this.m_lowest.X = -1;\n\t  };\n\t  ClipperLib.ClipperOffset.Round = ClipperLib.Clipper.Round;\n\t  ClipperLib.ClipperOffset.prototype.AddPath = function (path, joinType, endType)\n\t  {\n\t    var highI = path.length - 1;\n\t    if (highI < 0)\n\t      return;\n\t    var newNode = new ClipperLib.PolyNode();\n\t    newNode.m_jointype = joinType;\n\t    newNode.m_endtype = endType;\n\t    //strip duplicate points from path and also get index to the lowest point ...\n\t    if (endType == ClipperLib.EndType.etClosedLine || endType == ClipperLib.EndType.etClosedPolygon)\n\t      while (highI > 0 && ClipperLib.IntPoint.op_Equality(path[0], path[highI]))\n\t        highI--;\n\t    //newNode.m_polygon.set_Capacity(highI + 1);\n\t    newNode.m_polygon.push(path[0]);\n\t    var j = 0,\n\t      k = 0;\n\t    for (var i = 1; i <= highI; i++)\n\t      if (ClipperLib.IntPoint.op_Inequality(newNode.m_polygon[j], path[i]))\n\t      {\n\t        j++;\n\t        newNode.m_polygon.push(path[i]);\n\t        if (path[i].Y > newNode.m_polygon[k].Y || (path[i].Y == newNode.m_polygon[k].Y && path[i].X < newNode.m_polygon[k].X))\n\t          k = j;\n\t      }\n\t    if (endType == ClipperLib.EndType.etClosedPolygon && j < 2) return;\n\t\n\t    this.m_polyNodes.AddChild(newNode);\n\t    //if this path's lowest pt is lower than all the others then update m_lowest\n\t    if (endType != ClipperLib.EndType.etClosedPolygon)\n\t      return;\n\t    if (this.m_lowest.X < 0)\n\t      this.m_lowest = new ClipperLib.IntPoint(this.m_polyNodes.ChildCount() - 1, k);\n\t    else\n\t    {\n\t      var ip = this.m_polyNodes.Childs()[this.m_lowest.X].m_polygon[this.m_lowest.Y];\n\t      if (newNode.m_polygon[k].Y > ip.Y || (newNode.m_polygon[k].Y == ip.Y && newNode.m_polygon[k].X < ip.X))\n\t        this.m_lowest = new ClipperLib.IntPoint(this.m_polyNodes.ChildCount() - 1, k);\n\t    }\n\t  };\n\t  ClipperLib.ClipperOffset.prototype.AddPaths = function (paths, joinType, endType)\n\t  {\n\t    for (var i = 0, ilen = paths.length; i < ilen; i++)\n\t      this.AddPath(paths[i], joinType, endType);\n\t  };\n\t  ClipperLib.ClipperOffset.prototype.FixOrientations = function ()\n\t  {\n\t    //fixup orientations of all closed paths if the orientation of the\n\t    //closed path with the lowermost vertex is wrong ...\n\t    if (this.m_lowest.X >= 0 && !ClipperLib.Clipper.Orientation(this.m_polyNodes.Childs()[this.m_lowest.X].m_polygon))\n\t    {\n\t      for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n\t      {\n\t        var node = this.m_polyNodes.Childs()[i];\n\t        if (node.m_endtype == ClipperLib.EndType.etClosedPolygon || (node.m_endtype == ClipperLib.EndType.etClosedLine && ClipperLib.Clipper.Orientation(node.m_polygon)))\n\t          node.m_polygon.reverse();\n\t      }\n\t    }\n\t    else\n\t    {\n\t      for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n\t      {\n\t        var node = this.m_polyNodes.Childs()[i];\n\t        if (node.m_endtype == ClipperLib.EndType.etClosedLine && !ClipperLib.Clipper.Orientation(node.m_polygon))\n\t          node.m_polygon.reverse();\n\t      }\n\t    }\n\t  };\n\t  ClipperLib.ClipperOffset.GetUnitNormal = function (pt1, pt2)\n\t  {\n\t    var dx = (pt2.X - pt1.X);\n\t    var dy = (pt2.Y - pt1.Y);\n\t    if ((dx == 0) && (dy == 0))\n\t      return new ClipperLib.DoublePoint(0, 0);\n\t    var f = 1 / Math.sqrt(dx * dx + dy * dy);\n\t    dx *= f;\n\t    dy *= f;\n\t    return new ClipperLib.DoublePoint(dy, -dx);\n\t  };\n\t  ClipperLib.ClipperOffset.prototype.DoOffset = function (delta)\n\t  {\n\t    this.m_destPolys = new Array();\n\t    this.m_delta = delta;\n\t    //if Zero offset, just copy any CLOSED polygons to m_p and return ...\n\t    if (ClipperLib.ClipperBase.near_zero(delta))\n\t    {\n\t      //this.m_destPolys.set_Capacity(this.m_polyNodes.ChildCount);\n\t      for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n\t      {\n\t        var node = this.m_polyNodes.Childs()[i];\n\t        if (node.m_endtype == ClipperLib.EndType.etClosedPolygon)\n\t          this.m_destPolys.push(node.m_polygon);\n\t      }\n\t      return;\n\t    }\n\t    //see offset_triginometry3.svg in the documentation folder ...\n\t    if (this.MiterLimit > 2)\n\t      this.m_miterLim = 2 / (this.MiterLimit * this.MiterLimit);\n\t    else\n\t      this.m_miterLim = 0.5;\n\t    var y;\n\t    if (this.ArcTolerance <= 0)\n\t      y = ClipperLib.ClipperOffset.def_arc_tolerance;\n\t    else if (this.ArcTolerance > Math.abs(delta) * ClipperLib.ClipperOffset.def_arc_tolerance)\n\t      y = Math.abs(delta) * ClipperLib.ClipperOffset.def_arc_tolerance;\n\t    else\n\t      y = this.ArcTolerance;\n\t    //see offset_triginometry2.svg in the documentation folder ...\n\t    var steps = 3.14159265358979 / Math.acos(1 - y / Math.abs(delta));\n\t    this.m_sin = Math.sin(ClipperLib.ClipperOffset.two_pi / steps);\n\t    this.m_cos = Math.cos(ClipperLib.ClipperOffset.two_pi / steps);\n\t    this.m_StepsPerRad = steps / ClipperLib.ClipperOffset.two_pi;\n\t    if (delta < 0)\n\t      this.m_sin = -this.m_sin;\n\t    //this.m_destPolys.set_Capacity(this.m_polyNodes.ChildCount * 2);\n\t    for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n\t    {\n\t      var node = this.m_polyNodes.Childs()[i];\n\t      this.m_srcPoly = node.m_polygon;\n\t      var len = this.m_srcPoly.length;\n\t      if (len == 0 || (delta <= 0 && (len < 3 || node.m_endtype != ClipperLib.EndType.etClosedPolygon)))\n\t        continue;\n\t      this.m_destPoly = new Array();\n\t      if (len == 1)\n\t      {\n\t        if (node.m_jointype == ClipperLib.JoinType.jtRound)\n\t        {\n\t          var X = 1,\n\t            Y = 0;\n\t          for (var j = 1; j <= steps; j++)\n\t          {\n\t            this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X + X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y + Y * delta)));\n\t            var X2 = X;\n\t            X = X * this.m_cos - this.m_sin * Y;\n\t            Y = X2 * this.m_sin + Y * this.m_cos;\n\t          }\n\t        }\n\t        else\n\t        {\n\t          var X = -1,\n\t            Y = -1;\n\t          for (var j = 0; j < 4; ++j)\n\t          {\n\t            this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X + X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y + Y * delta)));\n\t            if (X < 0)\n\t              X = 1;\n\t            else if (Y < 0)\n\t              Y = 1;\n\t            else\n\t              X = -1;\n\t          }\n\t        }\n\t        this.m_destPolys.push(this.m_destPoly);\n\t        continue;\n\t      }\n\t      //build m_normals ...\n\t      this.m_normals.length = 0;\n\t      //this.m_normals.set_Capacity(len);\n\t      for (var j = 0; j < len - 1; j++)\n\t        this.m_normals.push(ClipperLib.ClipperOffset.GetUnitNormal(this.m_srcPoly[j], this.m_srcPoly[j + 1]));\n\t      if (node.m_endtype == ClipperLib.EndType.etClosedLine || node.m_endtype == ClipperLib.EndType.etClosedPolygon)\n\t        this.m_normals.push(ClipperLib.ClipperOffset.GetUnitNormal(this.m_srcPoly[len - 1], this.m_srcPoly[0]));\n\t      else\n\t        this.m_normals.push(new ClipperLib.DoublePoint(this.m_normals[len - 2]));\n\t      if (node.m_endtype == ClipperLib.EndType.etClosedPolygon)\n\t      {\n\t        var k = len - 1;\n\t        for (var j = 0; j < len; j++)\n\t          k = this.OffsetPoint(j, k, node.m_jointype);\n\t        this.m_destPolys.push(this.m_destPoly);\n\t      }\n\t      else if (node.m_endtype == ClipperLib.EndType.etClosedLine)\n\t      {\n\t        var k = len - 1;\n\t        for (var j = 0; j < len; j++)\n\t          k = this.OffsetPoint(j, k, node.m_jointype);\n\t        this.m_destPolys.push(this.m_destPoly);\n\t        this.m_destPoly = new Array();\n\t        //re-build m_normals ...\n\t        var n = this.m_normals[len - 1];\n\t        for (var j = len - 1; j > 0; j--)\n\t          this.m_normals[j] = new ClipperLib.DoublePoint(-this.m_normals[j - 1].X, -this.m_normals[j - 1].Y);\n\t        this.m_normals[0] = new ClipperLib.DoublePoint(-n.X, -n.Y);\n\t        k = 0;\n\t        for (var j = len - 1; j >= 0; j--)\n\t          k = this.OffsetPoint(j, k, node.m_jointype);\n\t        this.m_destPolys.push(this.m_destPoly);\n\t      }\n\t      else\n\t      {\n\t        var k = 0;\n\t        for (var j = 1; j < len - 1; ++j)\n\t          k = this.OffsetPoint(j, k, node.m_jointype);\n\t        var pt1;\n\t        if (node.m_endtype == ClipperLib.EndType.etOpenButt)\n\t        {\n\t          var j = len - 1;\n\t          pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[j].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[j].Y * delta));\n\t          this.m_destPoly.push(pt1);\n\t          pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X - this.m_normals[j].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y - this.m_normals[j].Y * delta));\n\t          this.m_destPoly.push(pt1);\n\t        }\n\t        else\n\t        {\n\t          var j = len - 1;\n\t          k = len - 2;\n\t          this.m_sinA = 0;\n\t          this.m_normals[j] = new ClipperLib.DoublePoint(-this.m_normals[j].X, -this.m_normals[j].Y);\n\t          if (node.m_endtype == ClipperLib.EndType.etOpenSquare)\n\t            this.DoSquare(j, k);\n\t          else\n\t            this.DoRound(j, k);\n\t        }\n\t        //re-build m_normals ...\n\t        for (var j = len - 1; j > 0; j--)\n\t          this.m_normals[j] = new ClipperLib.DoublePoint(-this.m_normals[j - 1].X, -this.m_normals[j - 1].Y);\n\t        this.m_normals[0] = new ClipperLib.DoublePoint(-this.m_normals[1].X, -this.m_normals[1].Y);\n\t        k = len - 1;\n\t        for (var j = k - 1; j > 0; --j)\n\t          k = this.OffsetPoint(j, k, node.m_jointype);\n\t        if (node.m_endtype == ClipperLib.EndType.etOpenButt)\n\t        {\n\t          pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X - this.m_normals[0].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y - this.m_normals[0].Y * delta));\n\t          this.m_destPoly.push(pt1);\n\t          pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X + this.m_normals[0].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y + this.m_normals[0].Y * delta));\n\t          this.m_destPoly.push(pt1);\n\t        }\n\t        else\n\t        {\n\t          k = 1;\n\t          this.m_sinA = 0;\n\t          if (node.m_endtype == ClipperLib.EndType.etOpenSquare)\n\t            this.DoSquare(0, 1);\n\t          else\n\t            this.DoRound(0, 1);\n\t        }\n\t        this.m_destPolys.push(this.m_destPoly);\n\t      }\n\t    }\n\t  };\n\t  ClipperLib.ClipperOffset.prototype.Execute = function ()\n\t  {\n\t    var a = arguments,\n\t      ispolytree = a[0] instanceof ClipperLib.PolyTree;\n\t    if (!ispolytree) // function (solution, delta)\n\t    {\n\t      var solution = a[0],\n\t        delta = a[1];\n\t      ClipperLib.Clear(solution);\n\t      this.FixOrientations();\n\t      this.DoOffset(delta);\n\t      //now clean up 'corners' ...\n\t      var clpr = new ClipperLib.Clipper(0);\n\t      clpr.AddPaths(this.m_destPolys, ClipperLib.PolyType.ptSubject, true);\n\t      if (delta > 0)\n\t      {\n\t        clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftPositive, ClipperLib.PolyFillType.pftPositive);\n\t      }\n\t      else\n\t      {\n\t        var r = ClipperLib.Clipper.GetBounds(this.m_destPolys);\n\t        var outer = new ClipperLib.Path();\n\t        outer.push(new ClipperLib.IntPoint(r.left - 10, r.bottom + 10));\n\t        outer.push(new ClipperLib.IntPoint(r.right + 10, r.bottom + 10));\n\t        outer.push(new ClipperLib.IntPoint(r.right + 10, r.top - 10));\n\t        outer.push(new ClipperLib.IntPoint(r.left - 10, r.top - 10));\n\t        clpr.AddPath(outer, ClipperLib.PolyType.ptSubject, true);\n\t        clpr.ReverseSolution = true;\n\t        clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftNegative, ClipperLib.PolyFillType.pftNegative);\n\t        if (solution.length > 0)\n\t          solution.splice(0, 1);\n\t      }\n\t      //console.log(JSON.stringify(solution));\n\t    }\n\t    else // function (polytree, delta)\n\t    {\n\t      var solution = a[0],\n\t        delta = a[1];\n\t      solution.Clear();\n\t      this.FixOrientations();\n\t      this.DoOffset(delta);\n\t      //now clean up 'corners' ...\n\t      var clpr = new ClipperLib.Clipper(0);\n\t      clpr.AddPaths(this.m_destPolys, ClipperLib.PolyType.ptSubject, true);\n\t      if (delta > 0)\n\t      {\n\t        clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftPositive, ClipperLib.PolyFillType.pftPositive);\n\t      }\n\t      else\n\t      {\n\t        var r = ClipperLib.Clipper.GetBounds(this.m_destPolys);\n\t        var outer = new ClipperLib.Path();\n\t        outer.push(new ClipperLib.IntPoint(r.left - 10, r.bottom + 10));\n\t        outer.push(new ClipperLib.IntPoint(r.right + 10, r.bottom + 10));\n\t        outer.push(new ClipperLib.IntPoint(r.right + 10, r.top - 10));\n\t        outer.push(new ClipperLib.IntPoint(r.left - 10, r.top - 10));\n\t        clpr.AddPath(outer, ClipperLib.PolyType.ptSubject, true);\n\t        clpr.ReverseSolution = true;\n\t        clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftNegative, ClipperLib.PolyFillType.pftNegative);\n\t        //remove the outer PolyNode rectangle ...\n\t        if (solution.ChildCount() == 1 && solution.Childs()[0].ChildCount() > 0)\n\t        {\n\t          var outerNode = solution.Childs()[0];\n\t          //solution.Childs.set_Capacity(outerNode.ChildCount);\n\t          solution.Childs()[0] = outerNode.Childs()[0];\n\t          solution.Childs()[0].m_Parent = solution;\n\t          for (var i = 1; i < outerNode.ChildCount(); i++)\n\t            solution.AddChild(outerNode.Childs()[i]);\n\t        }\n\t        else\n\t          solution.Clear();\n\t      }\n\t    }\n\t  };\n\t  ClipperLib.ClipperOffset.prototype.OffsetPoint = function (j, k, jointype)\n\t  {\n\t\t\t//cross product ...\n\t\t\tthis.m_sinA = (this.m_normals[k].X * this.m_normals[j].Y - this.m_normals[j].X * this.m_normals[k].Y);\n\t\n\t\t\tif (Math.abs(this.m_sinA * this.m_delta) < 1.0)\n\t\t\t{\n\t\t\t\t//dot product ...\n\t\t\t\tvar cosA = (this.m_normals[k].X * this.m_normals[j].X + this.m_normals[j].Y * this.m_normals[k].Y);\n\t\t\t\tif (cosA > 0) // angle ==> 0 degrees\n\t\t\t\t{\n\t\t\t\t\tthis.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[k].X * this.m_delta),\n\t\t\t\t\t\tClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[k].Y * this.m_delta)));\n\t\t\t\t\treturn k;\n\t\t\t\t}\n\t\t\t\t//else angle ==> 180 degrees\n\t\t\t}\n\t    else if (this.m_sinA > 1)\n\t      this.m_sinA = 1.0;\n\t    else if (this.m_sinA < -1)\n\t      this.m_sinA = -1.0;\n\t    if (this.m_sinA * this.m_delta < 0)\n\t    {\n\t      this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[k].X * this.m_delta),\n\t        ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[k].Y * this.m_delta)));\n\t      this.m_destPoly.push(new ClipperLib.IntPoint(this.m_srcPoly[j]));\n\t      this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[j].X * this.m_delta),\n\t        ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[j].Y * this.m_delta)));\n\t    }\n\t    else\n\t      switch (jointype)\n\t      {\n\t      case ClipperLib.JoinType.jtMiter:\n\t        {\n\t          var r = 1 + (this.m_normals[j].X * this.m_normals[k].X + this.m_normals[j].Y * this.m_normals[k].Y);\n\t          if (r >= this.m_miterLim)\n\t            this.DoMiter(j, k, r);\n\t          else\n\t            this.DoSquare(j, k);\n\t          break;\n\t        }\n\t      case ClipperLib.JoinType.jtSquare:\n\t        this.DoSquare(j, k);\n\t        break;\n\t      case ClipperLib.JoinType.jtRound:\n\t        this.DoRound(j, k);\n\t        break;\n\t      }\n\t    k = j;\n\t    return k;\n\t  };\n\t  ClipperLib.ClipperOffset.prototype.DoSquare = function (j, k)\n\t  {\n\t    var dx = Math.tan(Math.atan2(this.m_sinA,\n\t      this.m_normals[k].X * this.m_normals[j].X + this.m_normals[k].Y * this.m_normals[j].Y) / 4);\n\t    this.m_destPoly.push(new ClipperLib.IntPoint(\n\t      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_delta * (this.m_normals[k].X - this.m_normals[k].Y * dx)),\n\t      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_delta * (this.m_normals[k].Y + this.m_normals[k].X * dx))));\n\t    this.m_destPoly.push(new ClipperLib.IntPoint(\n\t      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_delta * (this.m_normals[j].X + this.m_normals[j].Y * dx)),\n\t      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_delta * (this.m_normals[j].Y - this.m_normals[j].X * dx))));\n\t  };\n\t  ClipperLib.ClipperOffset.prototype.DoMiter = function (j, k, r)\n\t  {\n\t    var q = this.m_delta / r;\n\t    this.m_destPoly.push(new ClipperLib.IntPoint(\n\t      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + (this.m_normals[k].X + this.m_normals[j].X) * q),\n\t      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + (this.m_normals[k].Y + this.m_normals[j].Y) * q)));\n\t  };\n\t  ClipperLib.ClipperOffset.prototype.DoRound = function (j, k)\n\t  {\n\t    var a = Math.atan2(this.m_sinA,\n\t      this.m_normals[k].X * this.m_normals[j].X + this.m_normals[k].Y * this.m_normals[j].Y);\n\t\n\t    \tvar steps = Math.max(ClipperLib.Cast_Int32(ClipperLib.ClipperOffset.Round(this.m_StepsPerRad * Math.abs(a))), 1);\n\t\n\t    var X = this.m_normals[k].X,\n\t      Y = this.m_normals[k].Y,\n\t      X2;\n\t    for (var i = 0; i < steps; ++i)\n\t    {\n\t      this.m_destPoly.push(new ClipperLib.IntPoint(\n\t        ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + X * this.m_delta),\n\t        ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + Y * this.m_delta)));\n\t      X2 = X;\n\t      X = X * this.m_cos - this.m_sin * Y;\n\t      Y = X2 * this.m_sin + Y * this.m_cos;\n\t    }\n\t    this.m_destPoly.push(new ClipperLib.IntPoint(\n\t      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[j].X * this.m_delta),\n\t      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[j].Y * this.m_delta)));\n\t  };\n\t  ClipperLib.Error = function (message)\n\t  {\n\t    try\n\t    {\n\t      throw new Error(message);\n\t    }\n\t    catch (err)\n\t    {\n\t      alert(err.message);\n\t    }\n\t  };\n\t  // ---------------------------------\n\t  // JS extension by Timo 2013\n\t  ClipperLib.JS = {};\n\t  ClipperLib.JS.AreaOfPolygon = function (poly, scale)\n\t  {\n\t    if (!scale) scale = 1;\n\t    return ClipperLib.Clipper.Area(poly) / (scale * scale);\n\t  };\n\t  ClipperLib.JS.AreaOfPolygons = function (poly, scale)\n\t  {\n\t    if (!scale) scale = 1;\n\t    var area = 0;\n\t    for (var i = 0; i < poly.length; i++)\n\t    {\n\t      area += ClipperLib.Clipper.Area(poly[i]);\n\t    }\n\t    return area / (scale * scale);\n\t  };\n\t  ClipperLib.JS.BoundsOfPath = function (path, scale)\n\t  {\n\t    return ClipperLib.JS.BoundsOfPaths([path], scale);\n\t  };\n\t  ClipperLib.JS.BoundsOfPaths = function (paths, scale)\n\t  {\n\t    if (!scale) scale = 1;\n\t    var bounds = ClipperLib.Clipper.GetBounds(paths);\n\t    bounds.left /= scale;\n\t    bounds.bottom /= scale;\n\t    bounds.right /= scale;\n\t    bounds.top /= scale;\n\t    return bounds;\n\t  };\n\t  // Clean() joins vertices that are too near each other\n\t  // and causes distortion to offsetted polygons without cleaning\n\t  ClipperLib.JS.Clean = function (polygon, delta)\n\t  {\n\t    if (!(polygon instanceof Array)) return [];\n\t    var isPolygons = polygon[0] instanceof Array;\n\t    var polygon = ClipperLib.JS.Clone(polygon);\n\t    if (typeof delta != \"number\" || delta === null)\n\t    {\n\t      ClipperLib.Error(\"Delta is not a number in Clean().\");\n\t      return polygon;\n\t    }\n\t    if (polygon.length === 0 || (polygon.length == 1 && polygon[0].length === 0) || delta < 0) return polygon;\n\t    if (!isPolygons) polygon = [polygon];\n\t    var k_length = polygon.length;\n\t    var len, poly, result, d, p, j, i;\n\t    var results = [];\n\t    for (var k = 0; k < k_length; k++)\n\t    {\n\t      poly = polygon[k];\n\t      len = poly.length;\n\t      if (len === 0) continue;\n\t      else if (len < 3)\n\t      {\n\t        result = poly;\n\t        results.push(result);\n\t        continue;\n\t      }\n\t      result = poly;\n\t      d = delta * delta;\n\t      //d = Math.floor(c_delta * c_delta);\n\t      p = poly[0];\n\t      j = 1;\n\t      for (i = 1; i < len; i++)\n\t      {\n\t        if ((poly[i].X - p.X) * (poly[i].X - p.X) +\n\t          (poly[i].Y - p.Y) * (poly[i].Y - p.Y) <= d)\n\t          continue;\n\t        result[j] = poly[i];\n\t        p = poly[i];\n\t        j++;\n\t      }\n\t      p = poly[j - 1];\n\t      if ((poly[0].X - p.X) * (poly[0].X - p.X) +\n\t        (poly[0].Y - p.Y) * (poly[0].Y - p.Y) <= d)\n\t        j--;\n\t      if (j < len)\n\t        result.splice(j, len - j);\n\t      if (result.length) results.push(result);\n\t    }\n\t    if (!isPolygons && results.length) results = results[0];\n\t    else if (!isPolygons && results.length === 0) results = [];\n\t    else if (isPolygons && results.length === 0) results = [\n\t      []\n\t    ];\n\t    return results;\n\t  }\n\t  // Make deep copy of Polygons or Polygon\n\t  // so that also IntPoint objects are cloned and not only referenced\n\t  // This should be the fastest way\n\t  ClipperLib.JS.Clone = function (polygon)\n\t  {\n\t    if (!(polygon instanceof Array)) return [];\n\t    if (polygon.length === 0) return [];\n\t    else if (polygon.length == 1 && polygon[0].length === 0) return [[]];\n\t    var isPolygons = polygon[0] instanceof Array;\n\t    if (!isPolygons) polygon = [polygon];\n\t    var len = polygon.length,\n\t      plen, i, j, result;\n\t    var results = new Array(len);\n\t    for (i = 0; i < len; i++)\n\t    {\n\t      plen = polygon[i].length;\n\t      result = new Array(plen);\n\t      for (j = 0; j < plen; j++)\n\t      {\n\t        result[j] = {\n\t          X: polygon[i][j].X,\n\t          Y: polygon[i][j].Y\n\t        };\n\t      }\n\t      results[i] = result;\n\t    }\n\t    if (!isPolygons) results = results[0];\n\t    return results;\n\t  };\n\t  // Removes points that doesn't affect much to the visual appearance.\n\t  // If middle point is at or under certain distance (tolerance) of the line segment between\n\t  // start and end point, the middle point is removed.\n\t  ClipperLib.JS.Lighten = function (polygon, tolerance)\n\t  {\n\t    if (!(polygon instanceof Array)) return [];\n\t    if (typeof tolerance != \"number\" || tolerance === null)\n\t    {\n\t      ClipperLib.Error(\"Tolerance is not a number in Lighten().\")\n\t      return ClipperLib.JS.Clone(polygon);\n\t    }\n\t    if (polygon.length === 0 || (polygon.length == 1 && polygon[0].length === 0) || tolerance < 0)\n\t    {\n\t      return ClipperLib.JS.Clone(polygon);\n\t    }\n\t    if (!(polygon[0] instanceof Array)) polygon = [polygon];\n\t    var i, j, poly, k, poly2, plen, A, B, P, d, rem, addlast;\n\t    var bxax, byay, l, ax, ay;\n\t    var len = polygon.length;\n\t    var toleranceSq = tolerance * tolerance;\n\t    var results = [];\n\t    for (i = 0; i < len; i++)\n\t    {\n\t      poly = polygon[i];\n\t      plen = poly.length;\n\t      if (plen == 0) continue;\n\t      for (k = 0; k < 1000000; k++) // could be forever loop, but wiser to restrict max repeat count\n\t      {\n\t        poly2 = [];\n\t        plen = poly.length;\n\t        // the first have to added to the end, if first and last are not the same\n\t        // this way we ensure that also the actual last point can be removed if needed\n\t        if (poly[plen - 1].X != poly[0].X || poly[plen - 1].Y != poly[0].Y)\n\t        {\n\t          addlast = 1;\n\t          poly.push(\n\t          {\n\t            X: poly[0].X,\n\t            Y: poly[0].Y\n\t          });\n\t          plen = poly.length;\n\t        }\n\t        else addlast = 0;\n\t        rem = []; // Indexes of removed points\n\t        for (j = 0; j < plen - 2; j++)\n\t        {\n\t          A = poly[j]; // Start point of line segment\n\t          P = poly[j + 1]; // Middle point. This is the one to be removed.\n\t          B = poly[j + 2]; // End point of line segment\n\t          ax = A.X;\n\t          ay = A.Y;\n\t          bxax = B.X - ax;\n\t          byay = B.Y - ay;\n\t          if (bxax !== 0 || byay !== 0) // To avoid Nan, when A==P && P==B. And to avoid peaks (A==B && A!=P), which have lenght, but not area.\n\t          {\n\t            l = ((P.X - ax) * bxax + (P.Y - ay) * byay) / (bxax * bxax + byay * byay);\n\t            if (l > 1)\n\t            {\n\t              ax = B.X;\n\t              ay = B.Y;\n\t            }\n\t            else if (l > 0)\n\t            {\n\t              ax += bxax * l;\n\t              ay += byay * l;\n\t            }\n\t          }\n\t          bxax = P.X - ax;\n\t          byay = P.Y - ay;\n\t          d = bxax * bxax + byay * byay;\n\t          if (d <= toleranceSq)\n\t          {\n\t            rem[j + 1] = 1;\n\t            j++; // when removed, transfer the pointer to the next one\n\t          }\n\t        }\n\t        // add all unremoved points to poly2\n\t        poly2.push(\n\t        {\n\t          X: poly[0].X,\n\t          Y: poly[0].Y\n\t        });\n\t        for (j = 1; j < plen - 1; j++)\n\t          if (!rem[j]) poly2.push(\n\t          {\n\t            X: poly[j].X,\n\t            Y: poly[j].Y\n\t          });\n\t        poly2.push(\n\t        {\n\t          X: poly[plen - 1].X,\n\t          Y: poly[plen - 1].Y\n\t        });\n\t        // if the first point was added to the end, remove it\n\t        if (addlast) poly.pop();\n\t        // break, if there was not anymore removed points\n\t        if (!rem.length) break;\n\t        // else continue looping using poly2, to check if there are points to remove\n\t        else poly = poly2;\n\t      }\n\t      plen = poly2.length;\n\t      // remove duplicate from end, if needed\n\t      if (poly2[plen - 1].X == poly2[0].X && poly2[plen - 1].Y == poly2[0].Y)\n\t      {\n\t        poly2.pop();\n\t      }\n\t      if (poly2.length > 2) // to avoid two-point-polygons\n\t        results.push(poly2);\n\t    }\n\t    if (!(polygon[0] instanceof Array)) results = results[0];\n\t    if (typeof (results) == \"undefined\") results = [\n\t      []\n\t    ];\n\t    return results;\n\t  }\n\t  ClipperLib.JS.PerimeterOfPath = function (path, closed, scale)\n\t  {\n\t    if (typeof (path) == \"undefined\") return 0;\n\t    var sqrt = Math.sqrt;\n\t    var perimeter = 0.0;\n\t    var p1, p2, p1x = 0.0,\n\t      p1y = 0.0,\n\t      p2x = 0.0,\n\t      p2y = 0.0;\n\t    var j = path.length;\n\t    if (j < 2) return 0;\n\t    if (closed)\n\t    {\n\t      path[j] = path[0];\n\t      j++;\n\t    }\n\t    while (--j)\n\t    {\n\t      p1 = path[j];\n\t      p1x = p1.X;\n\t      p1y = p1.Y;\n\t      p2 = path[j - 1];\n\t      p2x = p2.X;\n\t      p2y = p2.Y;\n\t      perimeter += sqrt((p1x - p2x) * (p1x - p2x) + (p1y - p2y) * (p1y - p2y));\n\t    }\n\t    if (closed) path.pop();\n\t    return perimeter / scale;\n\t  };\n\t  ClipperLib.JS.PerimeterOfPaths = function (paths, closed, scale)\n\t  {\n\t    if (!scale) scale = 1;\n\t    var perimeter = 0;\n\t    for (var i = 0; i < paths.length; i++)\n\t    {\n\t      perimeter += ClipperLib.JS.PerimeterOfPath(paths[i], closed, scale);\n\t    }\n\t    return perimeter;\n\t  };\n\t  ClipperLib.JS.ScaleDownPath = function (path, scale)\n\t  {\n\t    var i, p;\n\t    if (!scale) scale = 1;\n\t    i = path.length;\n\t    while (i--)\n\t    {\n\t      p = path[i];\n\t      p.X = p.X / scale;\n\t      p.Y = p.Y / scale;\n\t    }\n\t  };\n\t  ClipperLib.JS.ScaleDownPaths = function (paths, scale)\n\t  {\n\t    var i, j, p;\n\t    if (!scale) scale = 1;\n\t    i = paths.length;\n\t    while (i--)\n\t    {\n\t      j = paths[i].length;\n\t      while (j--)\n\t      {\n\t        p = paths[i][j];\n\t        p.X = p.X / scale;\n\t        p.Y = p.Y / scale;\n\t      }\n\t    }\n\t  };\n\t  ClipperLib.JS.ScaleUpPath = function (path, scale)\n\t  {\n\t    var i, p, round = Math.round;\n\t    if (!scale) scale = 1;\n\t    i = path.length;\n\t    while (i--)\n\t    {\n\t      p = path[i];\n\t      p.X = round(p.X * scale);\n\t      p.Y = round(p.Y * scale);\n\t    }\n\t  };\n\t  ClipperLib.JS.ScaleUpPaths = function (paths, scale)\n\t  {\n\t    var i, j, p, round = Math.round;\n\t    if (!scale) scale = 1;\n\t    i = paths.length;\n\t    while (i--)\n\t    {\n\t      j = paths[i].length;\n\t      while (j--)\n\t      {\n\t        p = paths[i][j];\n\t        p.X = round(p.X * scale);\n\t        p.Y = round(p.Y * scale);\n\t      }\n\t    }\n\t  };\n\t  ClipperLib.ExPolygons = function ()\n\t  {\n\t    return [];\n\t  }\n\t  ClipperLib.ExPolygon = function ()\n\t  {\n\t    this.outer = null;\n\t    this.holes = null;\n\t  };\n\t  ClipperLib.JS.AddOuterPolyNodeToExPolygons = function (polynode, expolygons)\n\t  {\n\t    var ep = new ClipperLib.ExPolygon();\n\t    ep.outer = polynode.Contour();\n\t    var childs = polynode.Childs();\n\t    var ilen = childs.length;\n\t    ep.holes = new Array(ilen);\n\t    var node, n, i, j, childs2, jlen;\n\t    for (i = 0; i < ilen; i++)\n\t    {\n\t      node = childs[i];\n\t      ep.holes[i] = node.Contour();\n\t      //Add outer polygons contained by (nested within) holes ...\n\t      for (j = 0, childs2 = node.Childs(), jlen = childs2.length; j < jlen; j++)\n\t      {\n\t        n = childs2[j];\n\t        ClipperLib.JS.AddOuterPolyNodeToExPolygons(n, expolygons);\n\t      }\n\t    }\n\t    expolygons.push(ep);\n\t  };\n\t  ClipperLib.JS.ExPolygonsToPaths = function (expolygons)\n\t  {\n\t    var a, i, alen, ilen;\n\t    var paths = new ClipperLib.Paths();\n\t    for (a = 0, alen = expolygons.length; a < alen; a++)\n\t    {\n\t      paths.push(expolygons[a].outer);\n\t      for (i = 0, ilen = expolygons[a].holes.length; i < ilen; i++)\n\t      {\n\t        paths.push(expolygons[a].holes[i]);\n\t      }\n\t    }\n\t    return paths;\n\t  }\n\t  ClipperLib.JS.PolyTreeToExPolygons = function (polytree)\n\t  {\n\t    var expolygons = new ClipperLib.ExPolygons();\n\t    var node, i, childs, ilen;\n\t    for (i = 0, childs = polytree.Childs(), ilen = childs.length; i < ilen; i++)\n\t    {\n\t      node = childs[i];\n\t      ClipperLib.JS.AddOuterPolyNodeToExPolygons(node, expolygons);\n\t    }\n\t    return expolygons;\n\t  };\n\t})();\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t!function(t,e){ true?module.exports=e():\"function\"==typeof define&&define.amd?define(\"SVGCurves\",[],e):\"object\"==typeof exports?exports.SVGCurves=e():t.SVGCurves=e()}(this,function(){return function(t){function e(n){if(i[n])return i[n].exports;var r=i[n]={exports:{},id:n,loaded:!1};return t[n].call(r.exports,r,r.exports,e),r.loaded=!0,r.exports}var i={};return e.m=t,e.c=i,e.p=\"\",e(0)}([function(t,e,i){t.exports=i(1)},function(t,e,i){\"use strict\";function n(t,e){if(!t)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return!e||\"object\"!=typeof e&&\"function\"!=typeof e?t:e}function r(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function, not \"+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}function s(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}function o(t,e){return(t%e+e)%e}function h(t,e,i){return Math.min(Math.max(t,e),i)}function a(t,e){return Math.sqrt(Math.pow(e.x-t.x,2)+Math.pow(e.y-t.y,2))}function u(t,e){var i=t.x*e.x+t.y*e.y,n=Math.sqrt((Math.pow(t.x,2)+Math.pow(t.y,2))*(Math.pow(e.x,2)+Math.pow(e.y,2)));return(t.x*e.y-t.y*e.x<0?-1:1)*Math.acos(i/n)}Object.defineProperty(e,\"__esModule\",{value:!0}),e.QuadricBezier=e.CubicBezier=e.Arc=void 0;var p=function t(e,i,n){null===e&&(e=Function.prototype);var r=Object.getOwnPropertyDescriptor(e,i);if(void 0===r){var s=Object.getPrototypeOf(e);return null===s?void 0:t(s,i,n)}if(\"value\"in r)return r.value;var o=r.get;if(void 0!==o)return o.call(n)},c=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e}}(),f=i(2),l=2*Math.PI,y=Math.PI/180,v=function(){function t(e){s(this,t),this.path=[],this.linear=!0,this.step=.01,this.resolution=500,this.segmentLength=.1,Object.assign(this,e||{}),this.arcLength=null,this.arcLengthMap=null}return c(t,[{key:\"_clearPath\",value:function(){this.path=[]}},{key:\"getPath\",value:function(){return this.path}},{key:\"getPointAtT\",value:function(t){return new f.Point(0,0)}},{key:\"_addPoint\",value:function(t){this.path.push(t.x,t.y)}},{key:\"_postTrace\",value:function(){}},{key:\"_approximateLength\",value:function(){var t=0,e=[],i=this.getPointAtT(0),n=void 0,r=void 0,s=void 0;for(n=0;n<this.resolution;n++)r=h(n*(1/this.resolution),0,1),s=this.getPointAtT(r),t+=a(i,s),e.push({t:r,arcLength:t}),i=s;s=this.getPointAtT(1),t+=a(i,s),e.push({t:1,arcLength:t}),Object.assign(this,{arcLength:t,arcLengthMap:e})}},{key:\"getPointAtU\",value:function(t){t=h(t,0,1);var e=t*this.arcLength,i=0,n=0,r=0;return this.arcLengthMap.every(function(t){var s=t.t,o=t.arcLength;if(o>=e){var h=o-e,a=e-n,u=a/(h+a)||0;return i=r+(s-r)*u,!1}return n=o,r=s,!0}),this.getPointAtT(i)}},{key:\"trace\",value:function(t){Object.assign(this,t||{});var e=\"getPointAtT\",i=this.step;if(this.linear){this._approximateLength();var n=Math.round(this.arcLength/this.segmentLength);e=\"getPointAtU\",i=1/n}this._clearPath();for(var r=0;r<=1;r+=i)this._addPoint(this[e](r));return this._postTrace(),this.getPath()}}]),t}(),x=function(t){function e(){return s(this,e),n(this,(e.__proto__||Object.getPrototypeOf(e)).apply(this,arguments))}return r(e,t),c(e,[{key:\"init\",value:function(t){if(Object.assign(this,t||{}),this.radians=o(this.angle,360)*y,this.p1.x===this.p2.x&&this.p1.y===this.p2.y)return this.path;if(this.rx=Math.abs(this.rx),this.ry=Math.abs(this.ry),0===this.rx||0===this.ry)return this.__addPoint(this.p1),this.__addPoint(this.p2),this.path;var e=(this.p1.x-this.p2.x)/2,i=(this.p1.y-this.p2.y)/2,n={x:Math.cos(this.radians)*e+Math.sin(this.radians)*i,y:-Math.sin(this.radians)*e+Math.cos(this.radians)*i},r=Math.pow(n.x,2)/Math.pow(this.rx,2)+Math.pow(n.y,2)/Math.pow(this.ry,2);r>1&&(this.rx=Math.sqrt(r)*this.rx,this.ry=Math.sqrt(r)*this.ry);var s=Math.pow(this.rx,2)*Math.pow(this.ry,2)-Math.pow(this.rx,2)*Math.pow(n.y,2)-Math.pow(this.ry,2)*Math.pow(n.x,2),h=Math.pow(this.rx,2)*Math.pow(n.y,2)+Math.pow(this.ry,2)*Math.pow(n.x,2),a=s/h;a=a<0?0:a;var p=(this.large!==this.sweep?1:-1)*Math.sqrt(a),c={x:p*(this.rx*n.y/this.ry),y:p*(-(this.ry*n.x)/this.rx)};this.center={x:Math.cos(this.radians)*c.x-Math.sin(this.radians)*c.y+(this.p1.x+this.p2.x)/2,y:Math.sin(this.radians)*c.x+Math.cos(this.radians)*c.y+(this.p1.y+this.p2.y)/2};var f={x:(n.x-c.x)/this.rx,y:(n.y-c.y)/this.ry},v={x:(-n.x-c.x)/this.rx,y:(-n.y-c.y)/this.ry};this.startAngle=u({x:1,y:0},f),this.sweepAngle=u(f,v),!this.sweep&&this.sweepAngle>0?this.sweepAngle-=l:this.sweep&&this.sweepAngle<0&&(this.sweepAngle+=l),this.sweepAngle%=l}},{key:\"trace\",value:function(t){return this.init(t),p(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),\"trace\",this).call(this)}},{key:\"getPointAtT\",value:function(t){var e=this.startAngle+this.sweepAngle*t,i=this.rx*Math.cos(e),n=this.ry*Math.sin(e);return new f.Point(Math.cos(this.radians)*i-Math.sin(this.radians)*n+this.center.x,Math.sin(this.radians)*i+Math.cos(this.radians)*n+this.center.y)}},{key:\"_postTrace\",value:function(){this._addPoint(this.p2)}}]),e}(v),d=function(t){function e(){return s(this,e),n(this,(e.__proto__||Object.getPrototypeOf(e)).apply(this,arguments))}return r(e,t),c(e,[{key:\"_B1\",value:function(t){return t*t*t}},{key:\"_B2\",value:function(t){return 3*t*t*(1-t)}},{key:\"_B3\",value:function(t){return 3*t*(1-t)*(1-t)}},{key:\"_B4\",value:function(t){return(1-t)*(1-t)*(1-t)}},{key:\"_C1\",value:function(t,e,i,n,r){return t*this._B1(r)+e*this._B2(r)+i*this._B3(r)+n*this._B4(r)}},{key:\"getPointAtT\",value:function(t){return new f.Point(this._C1(this.p1.x,this.p2.x,this.p3.x,this.p4.x,t),this._C1(this.p1.y,this.p2.y,this.p3.y,this.p4.y,t))}},{key:\"_addPoint\",value:function(t){this.path.unshift(t.x,t.y)}}]),e}(v),g=function(t){function e(){return s(this,e),n(this,(e.__proto__||Object.getPrototypeOf(e)).apply(this,arguments))}return r(e,t),c(e,[{key:\"_B1\",value:function(t){return t*t}},{key:\"_B2\",value:function(t){return 2*t*(1-t)}},{key:\"_B3\",value:function(t){return(1-t)*(1-t)}},{key:\"_C1\",value:function(t,e,i,n){return t*this._B1(n)+e*this._B2(n)+i*this._B3(n)}},{key:\"getPointAtT\",value:function(t){return new f.Point(this._C1(this.p1.x,this.p2.x,this.p3.x,t),this._C1(this.p1.y,this.p2.y,this.p3.y,t))}},{key:\"_addPoint\",value:function(t){this.path.unshift(t.x,t.y)}}]),e}(v);e.Arc=x,e.CubicBezier=d,e.QuadricBezier=g},function(t,e,i){!function(e,i){t.exports=i()}(this,function(){return function(t){function e(n){if(i[n])return i[n].exports;var r=i[n]={exports:{},id:n,loaded:!1};return t[n].call(r.exports,r,r.exports,e),r.loaded=!0,r.exports}var i={};return e.m=t,e.c=i,e.p=\"\",e(0)}([function(t,e,i){t.exports=i(1)},function(t,e){\"use strict\";function i(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}Object.defineProperty(e,\"__esModule\",{value:!0});var n=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e}}(),r=function(){function t(e,n){if(i(this,t),this.x=parseFloat(e),this.y=parseFloat(n),isNaN(this.x)||isNaN(this.y))throw console.error(\"new Point(\",e,n,\")\"),new Error(\"Invalid input: x and y params must be float.\")}return n(t,[{key:\"isEqual\",value:function(t){return this.x===t.x&&this.y===t.y}}]),t}(),s=function(){function t(){i(this,t),this.points=[],this.length=0}return n(t,[{key:\"getPoints\",value:function(){return this.points}},{key:\"getFlattenPoints\",value:function(){var t=[];return this.points.forEach(function(e){return t.push(e.x,e.y)}),t}},{key:\"getClipperPoints\",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,e=[];return this.points.forEach(function(i){return e.push({X:parseInt(i.x*t),Y:parseInt(i.y*t)})}),e}},{key:\"fromClipperPoints\",value:function(t){var e=this,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return this.points=[],t.forEach(function(t){return e.addPoint(parseFloat(t.X*i),parseFloat(t.Y*i))}),this}},{key:\"getPoint\",value:function(t){return this.points[t<0?this.length+t:t]||null}},{key:\"addPoint\",value:function(t,e){this.points.push(new r(t,e)),this.length=this.points.length}},{key:\"addPoints\",value:function(t){for(var e=0,i=t.length;e<i;e+=2)this.addPoint(t[e],t[e+1])}},{key:\"isClosed\",value:function(){var t=this.getPoint(0);return t&&t.isEqual(this.getPoint(-1))}},{key:\"close\",value:function(){if(!this.isClosed()&&this.length>2){var t=this.getPoint(0);return this.addPoint(t.x,t.y),!0}return!1}},{key:\"transform\",value:function(t){this.points=this.points.map(function(e){return new r(t[0]*e.x+t[2]*e.y+t[4],t[1]*e.x+t[3]*e.y+t[5])})}}]),t}();e.Path=s,e.Point=r,e.default=s}])})}])});\n\t//# sourceMappingURL=lw.svg-curves.js.map\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// lw.svg-parser.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 87848381726b7842be86","!function(t,n){\"object\"==typeof exports&&\"object\"==typeof module?module.exports=n():\"function\"==typeof define&&define.amd?define(\"SVGPath\",[],n):\"object\"==typeof exports?exports.SVGPath=n():t.SVGPath=n()}(this,function(){return function(t){function n(i){if(e[i])return e[i].exports;var o=e[i]={exports:{},id:i,loaded:!1};return t[i].call(o.exports,o,o.exports,n),o.loaded=!0,o.exports}var e={};return n.m=t,n.c=e,n.p=\"\",n(0)}([function(t,n,e){t.exports=e(1)},function(t,n){\"use strict\";function e(t,n){if(!(t instanceof n))throw new TypeError(\"Cannot call a class as a function\")}Object.defineProperty(n,\"__esModule\",{value:!0});var i=function(){function t(t,n){for(var e=0;e<n.length;e++){var i=n[e];i.enumerable=i.enumerable||!1,i.configurable=!0,\"value\"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i)}}return function(n,e,i){return e&&t(n.prototype,e),i&&t(n,i),n}}(),o=function(){function t(n,i){if(e(this,t),this.x=parseFloat(n),this.y=parseFloat(i),isNaN(this.x)||isNaN(this.y))throw console.error(\"new Point(\",n,i,\")\"),new Error(\"Invalid input: x and y params must be float.\")}return i(t,[{key:\"isEqual\",value:function(t){return this.x===t.x&&this.y===t.y}}]),t}(),r=function(){function t(){e(this,t),this.points=[],this.length=0}return i(t,[{key:\"getPoints\",value:function(){return this.points}},{key:\"getFlattenPoints\",value:function(){var t=[];return this.points.forEach(function(n){return t.push(n.x,n.y)}),t}},{key:\"getClipperPoints\",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,n=[];return this.points.forEach(function(e){return n.push({X:parseInt(e.x*t),Y:parseInt(e.y*t)})}),n}},{key:\"fromClipperPoints\",value:function(t){var n=this,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return this.points=[],t.forEach(function(t){return n.addPoint(parseFloat(t.X*e),parseFloat(t.Y*e))}),this}},{key:\"getPoint\",value:function(t){return this.points[t<0?this.length+t:t]||null}},{key:\"addPoint\",value:function(t,n){this.points.push(new o(t,n)),this.length=this.points.length}},{key:\"addPoints\",value:function(t){for(var n=0,e=t.length;n<e;n+=2)this.addPoint(t[n],t[n+1])}},{key:\"isClosed\",value:function(){var t=this.getPoint(0);return t&&t.isEqual(this.getPoint(-1))}},{key:\"close\",value:function(){if(!this.isClosed()&&this.length>2){var t=this.getPoint(0);return this.addPoint(t.x,t.y),!0}return!1}},{key:\"transform\",value:function(t){this.points=this.points.map(function(n){return new o(t[0]*n.x+t[2]*n.y+t[4],t[1]*n.x+t[3]*n.y+t[5])})}}]),t}();n.Path=r,n.Point=o,n.default=r}])});\n//# sourceMappingURL=lw.svg-path.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/lw.svg-path/dist/lw.svg-path.js\n// module id = 1\n// module chunks = 0","// Imports\nimport { Tag } from './tag'\nimport { TagParser } from './tagparser'\n\n// SVG parser class\nclass Parser {\n    // Class constructor...\n    constructor(settings) {\n        // Defaults settings\n        settings = settings || {}\n\n        // Init properties\n        this.element  = null // XML document Element object\n        this.editor   = null // Editor info { name, version, fingerprint }\n        this.document = null // Document info { width, height, viewBox }\n        this.defs     = null // Defined <defs> (DOM) nodes list by id\n        this.tags     = null // Tag objects hierarchy\n\n        // Trace settings (Arc, Bezier)\n        this.traceSettings = Object.assign({\n            linear       : true, // Linear trace mode\n            step         : 0.01, // Step resolution if linear mode = false\n            resolution   : 100,  // Number of segments we use to approximate arc length\n            segmentLength: 1,    // Segment length\n        }, settings.traceSettings || {})\n\n        // Supported tags by this lib\n        this.supportedTags = [\n            'svg', 'g', 'defs', 'use',\n            'line', 'polyline', 'polygon',\n            'rect', 'circle', 'ellipse', 'path',\n            'title', 'desc', 'image', 'text'\n        ]\n\n        // Tags list to includes/excludes\n        this.parseTags = settings.includes || this.supportedTags\n        this.skipTags  = settings.excludes || ['#text', '#comment']  // silent (no warning)\n\n        // User onTag callback ?\n        settings.onTag && this.onTag(settings.onTag, settings.onTagContext)\n    }\n\n    // Load raw XML string, XMLDocument, Element or File object\n    load(input) {\n        // Load raw XML string\n        if (typeof input === 'string') {\n            return this.loadFromString(input)\n        }\n\n        // Load File object\n        if (input instanceof File) {\n            return this.loadFromFile(input)\n        }\n\n        // Load XMLDocument object\n        if (input instanceof XMLDocument) {\n            return this.loadFromXMLDocument(input)\n        }\n\n        // Load Element object\n        if (input instanceof Element) {\n            return this.loadFromElement(input)\n        }\n\n        // Return rejected promise with an Error object\n        return Promise.reject(new Error('Unsupported input format.'))\n    }\n\n    // Load from Element object\n    loadFromElement(input) {\n        return new Promise((resolve, reject) => {\n            // Bad input type\n            if (! (input instanceof Element)) {\n                reject(new Error('Input param must be a Element object.'))\n            }\n\n            // Parser error\n            if (input.nodeName === 'parsererror') { // FF\n                reject(new Error(input.textContent))\n            }\n\n            if (input.nodeName === 'html' && input.getElementsByTagName('parsererror')) { // Chrome\n                reject(new Error(input.getElementsByTagName('parsererror')[0].textContent))\n            }\n\n            // Set document element\n            this.element = input\n\n            // Resolve promise\n            resolve(input)\n        })\n    }\n\n    // Load from XMLDocument object\n    loadFromXMLDocument(input) {\n        return new Promise((resolve, reject) => {\n            // Bad input type\n            if (! (input instanceof XMLDocument)) {\n                reject(new Error('Input param must be a XMLDocument object.'))\n            }\n\n            // Load from Element...\n            this.loadFromElement(input.documentElement).then(resolve).catch(reject)\n        })\n    }\n\n    // Load raw XML string\n    loadFromString(input) {\n        return new Promise((resolve, reject) => {\n            // Bad input type\n            if (typeof input !== 'string') {\n                reject(new Error('Input param must be a string.'))\n            }\n\n            // Parse svg editor\n            this._parseEditor(input)\n\n            // Parse string as DOM object\n            let parser = new DOMParser()\n            let XMLDoc = parser.parseFromString(input, 'text/xml')\n\n            // Load from XMLDocument...\n            this.loadFromXMLDocument(XMLDoc).then(resolve).catch(reject)\n        })\n    }\n\n    // Try to get the svg editor from input string\n    _parseEditor(input) {\n        // Reset editor\n        this.editor = {\n            name       : 'unknown',\n            version    : null,\n            fingerprint: null\n        }\n\n        // Fingerprint matches\n        let fingerprint\n\n        // Inkscape\n        fingerprint = input.match(/<!-- Created with Inkscape .*-->/i)\n\n        if (fingerprint) {\n            this.editor.name        = 'inkscape'\n            this.editor.fingerprint = fingerprint[0]\n\n            return this.editor\n        }\n\n        // Illustrator\n        fingerprint = input.match(/<!-- Generator: Adobe Illustrator ([0-9\\.]+), .*-->/i)\n\n        if (fingerprint) {\n            this.editor.name        = 'illustrator'\n            this.editor.version     = fingerprint[1]\n            this.editor.fingerprint = fingerprint[0]\n\n            return this.editor\n        }\n\n        // Return default\n        return this.editor\n    }\n\n    // Load from File object\n    loadFromFile(input) {\n        return new Promise((resolve, reject) => {\n            // Bad input type\n            if (! (input instanceof File)) {\n                reject(new Error('Input param must be a File object.'))\n            }\n\n            // Create file reader\n            let reader = new FileReader()\n\n            // Register reader events handlers\n            reader.onload = event => {\n                this.loadFromString(event.target.result).then(resolve).catch(reject)\n            }\n\n            reader.onerror = event => {\n                reject(new Error('Error reading file : ' + input.name))\n            }\n\n            // Finally read input file as text\n            reader.readAsText(input)\n        })\n    }\n\n    // Parse the (loaded) element\n    parse(input) {\n        // Reset properties\n        this.document = null\n        this.defs     = {}\n        this.tags     = null\n\n        // Load input if provided\n        if (input) {\n            return new Promise((resolve, reject) => {\n                this.load(input).then(() => {\n                    resolve(this.parse())\n                }).catch(reject)\n            })\n        }\n\n        // Start parsing element\n        return new Promise((resolve, reject) => {\n            // If no element is loaded\n            if (! this.element) {\n                reject(new Error('No element is loaded, call the load method before.'))\n            }\n\n            // Parse the main Element (recursive)\n            this.tags = this._parseElement(this.element)\n\n            if (! this.tags) {\n                reject(new Error('No supported tags found.'))\n            }\n\n            // Apply matrix (recursive)\n            this.tags.applyMatrix()\n\n            // Resolve the promise\n            resolve(this.tags)\n        })\n    }\n\n    // On tag callback\n    _onTag(tag) {\n        //console.info('onTag:', tag)\n    }\n\n    // Register on tag callback\n    onTag(callback, context) {\n        this._onTag = tag => callback.call(context || this, tag)\n    }\n\n    // Parse the provided Element and return an Tag collection (recursive)\n    _parseElement(element, parent) {\n        // Create base tag object\n        let tag = new Tag(element, parent)\n\n        // Exluded tag ?\n        if (this.skipTags.indexOf(tag.name) !== -1) {\n            return null // silent\n        }\n\n        // Supported tag ?\n        if (this.parseTags.indexOf(tag.name) === -1) {\n            return this._skipTag(tag, 'unsupported')\n        }\n\n        // Parse the tag\n        let tagParser = new TagParser(tag, this)\n\n        if (! tagParser.parse()) {\n            return false\n        }\n\n        // Call the on tag callback\n        this._onTag(tag)\n\n        // Parse child nodes\n        let childTag\n\n        element.childNodes.forEach(childNode => {\n            // Parse child element\n            if (childTag = this._parseElement(childNode, tag)) {\n                tag.addChild(childTag)\n            }\n        })\n\n        // Empty group\n        if (['svg', 'g'].indexOf(tag.name) !== -1 && ! tag.children.length) {\n            return this._skipTag(tag, 'empty')\n        }\n\n        // Return tag object\n        return tag\n    }\n\n    // Log skip tag warning message\n    _skipTag(tag, message) {\n        console.warn('Skip tag :', message + ':', tag)\n        return false\n    }\n\n    // Log skip tag attribute warning message\n    _skipTagAttr(tag, attr, message) {\n        console.warn('Skip tag attribute :', message + ':', attr, tag)\n        return false\n    }\n\n}\n\n// Exports\nexport { Parser }\nexport default Parser\n\n\n\n// WEBPACK FOOTER //\n// ./parser.js","import { Path, Point } from 'lw.svg-path'\nimport clipper from 'clipper-lib'\n\nconst DEG_TO_RAD = Math.PI / 180\n\n// SVG tag class\nclass Tag {\n    // Class constructor...\n    constructor(element, parent) {\n        // Init properties\n        this.element  = element\n        this.name     = element.nodeName.toLowerCase()\n        this.parent   = parent || null\n        this.layer    = null\n        this.attrs    = {}\n        this.children = []\n        this.paths    = []\n        this.matrix   = null\n        this.path     = new Path()\n        this.point    = new Point(0, 0)\n        this.shapes   = []\n\n        // Add first path\n        this.paths.push(this.path)\n\n        // Set the matrix\n        this.setMatrix(this.parent && this.parent.matrix)\n\n        // Clone parent attributes\n        if (this.parent && (this.parent.name === 'g' || this.parent.name === 'svg')) {\n            // Inherit layer name\n            this.layer = this.parent.layer\n\n            // Inherit parent attributes\n            let excludes = ['transform', 'width', 'height']\n\n            if (this.name !== 'g' && this.name !== 'svg') {\n                excludes.push('viewBox')\n            }\n\n            Object.keys(this.parent.attrs).forEach(key => {\n                if (excludes.indexOf(key) === -1) {\n                    this.setAttr(key, this.parent.attrs[key])\n                }\n            })\n        }\n    }\n\n    setAttr(name, value) {\n        this.attrs[name] = value\n    }\n\n    getAttr(name, defaultValue) {\n        return this.attrs[name] !== undefined ? this.attrs[name]\n            : (defaultValue !== undefined ? defaultValue : null)\n    }\n\n    getLayerName() {\n        if (this.name === 'g') {\n            return this.getAttr('inkscape:label', this.getAttr('id', null))\n        }\n    }\n\n    setLayerName(name) {\n        if (this.name === 'g') {\n            this.layer = name || this.getLayerName()\n        }\n    }\n\n    addChild(childTag) {\n        this.children.push(childTag)\n    }\n\n    clearPath() {\n        this.path  = new Path()\n        this.point = new Point(0, 0)\n    }\n\n    newPath() {\n        if (this.path.length > 0) {\n            this.clearPath()\n            this.paths.push(this.path)\n        }\n    }\n\n    closePath() {\n        // Close path\n        let close = this.path.close()\n\n        // Update current point\n        let point  = this.path.getPoint(-1)\n        this.point = new Point(point.x, point.y)\n\n        // Return close result\n        return close\n    }\n\n    addPoint(x, y, relative) {\n        // Relative from the last point\n        if (relative) {\n            x += this.point.x\n            y += this.point.y\n        }\n\n        // Add current point\n        this.path.addPoint(x, y)\n\n        // Update current point\n        this.point = new Point(x, y)\n    }\n\n    addPoints(points, relative) {\n        // For each couple of points\n        for (let i = 0, il = points.length; i < il; i += 2) {\n            this.addPoint(points[i], points[i + 1], relative)\n        }\n    }\n\n    setMatrix(matrix) {\n        this.matrix = matrix || [1, 0, 0, 1, 0, 0]\n    }\n\n    addMatrix(matrix) {\n        this.matrix = [\n            this.matrix[0] * matrix[0] + this.matrix[2] * matrix[1],\n            this.matrix[1] * matrix[0] + this.matrix[3] * matrix[1],\n            this.matrix[0] * matrix[2] + this.matrix[2] * matrix[3],\n            this.matrix[1] * matrix[2] + this.matrix[3] * matrix[3],\n            this.matrix[0] * matrix[4] + this.matrix[2] * matrix[5] + this.matrix[4],\n            this.matrix[1] * matrix[4] + this.matrix[3] * matrix[5] + this.matrix[5]\n        ]\n    }\n\n    translate(x, y) {\n        y = y === undefined ? 0 : y\n        this.addMatrix([1, 0, 0, 1, x, y])\n    }\n\n    rotate(angle, x, y) {\n        angle = angle * DEG_TO_RAD\n\n        if (arguments.length == 2) {\n            this.addMatrix([1, 0, 0, 1, x, y])\n        }\n\n        this.addMatrix([Math.cos(angle), Math.sin(angle), -Math.sin(angle), Math.cos(angle), 0, 0])\n\n        if (arguments.length == 2) {\n            this.addMatrix([1, 0, 0, 1, -x, -y])\n        }\n    }\n\n    scale(x, y) {\n        y = y === undefined ? x : y\n        this.addMatrix([x, 0, 0, y, 0, 0])\n    }\n\n    skewX(angle) {\n        this.addMatrix([1, 0, Math.tan(angle * DEG_TO_RAD), 1, 0, 0])\n    }\n\n    skewY(angle) {\n        this.addMatrix([1, Math.tan(angle * DEG_TO_RAD), 0, 1, 0, 0])\n    }\n\n    applyMatrix(matrix) {\n        matrix && this.addMatrix(matrix)\n\n        this.paths.forEach(path => {\n            path.transform(this.matrix)\n        })\n\n        this.shapes.forEach(shape => {\n            shape.outer.transform(this.matrix)\n            shape.holes.forEach(hole => {\n                hole.transform(this.matrix)\n            })\n        })\n\n        this.setMatrix(null)\n\n        this.children.forEach(tag => {\n            tag.applyMatrix(matrix)\n        })\n    }\n\n    getPaths() {\n        return this.paths\n    }\n\n    getShapes() {\n        // No shapes...\n        if (this.getAttr('fill', 'none') === 'none' || ! this.paths[0].length) {\n            return this.shapes\n        }\n\n        // Get fill rule\n        let fillRule = this.getAttr('fill-rule', 'nonzero')\n            fillRule = fillRule === 'nonzero' ? clipper.PolyFillType.pftNonZero : clipper.PolyFillType.pftEvenOdd\n\n        // Create clipper path\n        let cPolyTree    = new clipper.PolyTree()\n        let cClipper     = new clipper.Clipper()\n        let clipperScale = 10000000\n        let clipperPaths = []\n\n        this.paths.forEach(path => {\n            clipperPaths.push(path.getClipperPoints(clipperScale))\n        })\n\n        cClipper.AddPaths(clipperPaths, clipper.PolyType.ptSubject, true)\n        cClipper.Execute(clipper.ClipType.ctUnion, cPolyTree, fillRule, fillRule)\n\n        let paths     = clipper.Clipper.PolyTreeToPaths(cPolyTree)\n        let polygones = clipper.Clipper.SimplifyPolygons(paths, fillRule)\n\n        // Single path (no hole)\n        if (this.paths.length > 1) {\n            cClipper.Clear()\n            cClipper.StrictlySimple = true\n            cPolyTree = new clipper.PolyTree()\n            cClipper.AddPaths(polygones, clipper.PolyType.ptSubject, true)\n            cClipper.Execute(clipper.ClipType.ctUnion, cPolyTree, fillRule, fillRule)\n        }\n\n        // PolyTree to ExPolygons\n        let toPath     = path => new Path().fromClipperPoints(path, 1 / clipperScale)\n        let exPolygons = clipper.JS.PolyTreeToExPolygons(cPolyTree)\n        this.shapes    = exPolygons.map(exPolygon => {\n            return {\n                outer: toPath(exPolygon.outer),\n                holes: exPolygon.holes.map(toPath)\n            }\n        })\n\n        // Return shapes...\n        return this.shapes\n    }\n}\n\n// Exports\nexport { Tag }\nexport default Tag\n\n\n\n// WEBPACK FOOTER //\n// ./tag.js","import { Arc, CubicBezier, QuadricBezier } from 'lw.svg-curves'\nimport { Point, Path } from 'lw.svg-path'\n\n// SVG tag parser\nclass TagParser {\n    // Class constructor...\n    constructor(tag, parser) {\n        // Init properties\n        this.tag            = tag\n        this.parser         = parser\n        this.currentCommand = null\n        this.lastCommand    = null\n        this.pathData       = null\n        this.traceSettings  = parser.traceSettings\n    }\n\n    parse() {\n        // Get internal parser from node name\n        let handler = this['_' + this.tag.name]\n\n        // Implemented tag handler?\n        if (! handler || typeof handler !== 'function') {\n            return this.parser._skipTag(this.tag, 'not yet implemented')\n        }\n\n        // Parse tag attributes\n        this._parseTagAttrs()\n\n        // Parse tag\n        return handler.call(this)\n    }\n\n    // Parse the tag attributes\n    _parseTagAttrs() {\n        // Get tag attributes\n        let attrs = this.tag.element.attributes\n\n        if (! attrs) {\n            return null\n        }\n\n        // Get viewBox attribute if any\n        let viewBox = attrs.getNamedItem('viewBox')\n\n        if (viewBox) {\n            this.tag.setAttr('viewBox', this._normalizeTagAttrPoints(viewBox))\n        }\n\n        // For each attribute\n        let attr, value, style\n\n        Object.keys(attrs).some(key => {\n            // Current attribute\n            attr = attrs[key]\n\n            // Normalize attribute value\n            value = this._normalizeTagAttr(attr)\n\n            if (value === false) {\n                return false // continue\n            }\n\n            // Special case\n            if (attr.nodeName === 'style') {\n                style = value\n            }\n            else {\n                // Set new attribute name/value\n                this.tag.setAttr(attr.nodeName, value)\n            }\n        })\n\n        // If style attribute (override tag attributes)\n        // TODO get/parse global style and override this one...\n        style && style.replace(/;$/, '').split(';').some(attr => {\n            // Current style\n            attr = attr.split(':')\n            attr = { nodeName: attr[0], nodeValue: attr[1] }\n\n            // Normalize attribute value\n            value = this._normalizeTagAttr(attr)\n\n            if (value === false) {\n                return false // continue\n            }\n\n            // Set new attribute name/value\n            this.tag.setAttr(attr.nodeName, value)\n        })\n\n        // Set inherited color\n        let colorsAttrs = ['fill', 'stroke', 'color']\n\n        colorsAttrs.forEach(attrName => {\n            if (this.tag.getAttr(attrName) === 'inherit') {\n                this.tag.setAttr(attrName, this.tag.parent.getAttr(attrName, 'none'))\n            }\n        })\n\n        // Parse viewBox attribute\n        this._parseViewBoxAttr()\n\n        // Parse transform attribute\n        this._parseTransformAttr()\n    }\n\n    // Normalize tag attribute\n    _normalizeTagAttr(attr) {\n        // Normalize whitespaces\n        let value = attr.nodeValue\n            .replace(/(\\r?\\n|\\r)+/gm, ' ') // Remove all new line chars\n            .replace(/\\s+/gm, ' ')         // Reduce multiple whitespaces\n            .trim()                        // Remove trailing whitespaces\n\n        if (! value.length) {\n            return this.parser._skipTagAttr(this.tag, attr, 'empty')\n        }\n\n        // Filters\n        switch (attr.nodeName) {\n            // Normalize size unit -> to px\n            case 'x':\n            case 'y':\n            case 'width':\n            case 'height':\n                value = this._normalizeTagAttrUnit(attr)\n            break\n\n            case 'x1':\n            case 'y1':\n            case 'x2':\n            case 'y2':\n            case 'r':\n            case 'rx':\n            case 'ry':\n            case 'cx':\n            case 'cy':\n            case 'font-size':\n            case 'stroke-width':\n                value = this._normalizeTagAttrUnit(attr, true)\n            break\n\n            // Normalize points attribute\n            case 'points':\n            //case 'viewBox':\n                value = this._normalizeTagAttrPoints(attr)\n            break\n\n            case 'viewBox':\n                value = false\n            break\n\n            // Range limit to [0 - 1]\n            case 'opacity':\n            case 'fill-opacity':\n            case 'stroke-opacity':\n                value = this._normalizeTagAttrRange(attr, 0, 1)\n            break\n\n            case 'preserveAspectRatio':\n                value = this._normalizeTagAttrPreserveAspectRatio(attr)\n            break\n        }\n\n        // Return normalized value\n        return value\n    }\n\n    // Normalize attribute unit to px\n    _normalizeTagAttrUnit(attr, ratio) {\n        let stringValue = attr.nodeValue.toLowerCase()\n        let floatValue  = parseFloat(stringValue)\n\n        if (isNaN(floatValue)) {\n            return this.parser._skipTagAttr(this.tag, attr, 'only numeric value allowed')\n        }\n\n        if (stringValue.indexOf('mm') !== -1) {\n            return floatValue * 3.5433070869\n        }\n\n        if (stringValue.indexOf('cm') !== -1) {\n            return floatValue * 35.433070869\n        }\n\n        if (stringValue.indexOf('in') !== -1) {\n            return floatValue * 90.0\n        }\n\n        if (stringValue.indexOf('pt') !== -1) {\n            return floatValue * 1.25\n        }\n\n        if (stringValue.indexOf('pc') !== -1) {\n            return floatValue * 15.0\n        }\n\n        if (stringValue.indexOf('%') !== -1) {\n            let viewBox = this.tag.getAttr('viewBox', this.tag.parent && this.tag.parent.getAttr('viewBox'))\n\n            switch (attr.nodeName) {\n                case 'x':\n                case 'width':\n                    floatValue *= viewBox[2] / 100\n                break\n                case 'y':\n                case 'height':\n                    floatValue *= viewBox[3] / 100\n                break\n            }\n        }\n\n        if (stringValue.indexOf('em') !== -1) {\n            let fontSize = this.tag.getAttr('font-size', 16)\n\n            switch (attr.nodeName) {\n                case 'x':\n                case 'y':\n                case 'width':\n                case 'height':\n                    floatValue *= fontSize\n                break\n            }\n        }\n\n        return floatValue\n    }\n\n    // Normalize points attribute\n    _normalizeTagAttrPoints(attr) {\n        let points = this._parseNumbers(attr.nodeValue)\n\n        if (points === false) {\n            return this.parser._skipTagAttr(this.tag, attr, 'only numeric values are allowed')\n        }\n\n        if (! points.length) {\n            return this.parser._skipTagAttr(this.tag, attr, 'empty points list')\n        }\n\n        if (points.length % 0) {\n            return this.parser._skipTagAttr(this.tag, attr, 'the number of points must be even')\n        }\n\n        return points\n    }\n\n    // Normalize range attribute like \"opacity\"\n    _normalizeTagAttrRange(attr, min, max) {\n        let stringValue = attr.nodeValue.trim()\n        let floatValue  = parseFloat(stringValue)\n\n        if (isNaN(floatValue)) {\n            return this.parser._skipTagAttr(this.tag, attr, 'only numeric values are allowed')\n        }\n\n        if (floatValue < min || floatValue > max) {\n            return this.parser._skipTagAttr(this.tag, attr, 'out of range [' + min + ', ' + max + ']')\n        }\n\n        return floatValue\n    }\n\n    // Parse points string as numbers array\n    _parseNumbers(points) {\n        // http://stackoverflow.com/questions/638565/parsing-scientific-notation-sensibly\n        if (typeof points === 'string') {\n            points = points.split(/([+\\-]?(?:0|[1-9]\\d*)(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?)?/g)\n            .filter(point => {\n                return point && ['', ','].indexOf(point.trim()) === -1\n            })\n        }\n\n        // Normalize to float values\n        points = points.map(parseFloat)\n\n        // Test if all numbers is valid\n        if (points.some(isNaN)) {\n            return false\n        }\n\n        return points\n    }\n\n    // Normalize the preserveAspectRatio attribute\n    _normalizeTagAttrPreserveAspectRatio(attr) {\n        let params = {\n            defer: false,\n            align: 'none',\n            meet : true,\n            slice: false\n        }\n\n        let rawParams = attr.nodeValue\n\n        if (rawParams.indexOf('defer') === 0) {\n            rawParams    = rawParams.substr(6)\n            params.defer = true\n        }\n\n        rawParams    = rawParams.split(' ')\n        params.align = rawParams[0]\n        params.meet  = rawParams[1] || 'meet'\n        params.meet  = params.meet === 'meet'\n        params.slice = ! params.meet\n\n        return params\n    }\n\n    // Parse viewBox attribute and set transformations\n    _parseViewBoxAttr() {\n        // Get viewBox attribute\n        let viewBox = this.tag.getAttr('viewBox', null)\n\n        // No viewBox...\n        if (viewBox === null) {\n            return null\n        }\n\n        // Update size attributes\n        let width  = this.tag.getAttr('width', viewBox[2])\n        let height = this.tag.getAttr('height', viewBox[3])\n\n        this.tag.setAttr('width' , width)\n        this.tag.setAttr('height', height)\n\n        // Scale to match viewBox\n        // TODO clip path if preserveAspectRatio.slice\n        let scaleX     = width  / viewBox[2]\n        let scaleY     = height / viewBox[3]\n        let translateX = viewBox[0]\n        let translateY = viewBox[1]\n\n        let preserveAspectRatio = this.tag.getAttr('preserveAspectRatio', 'meet xMidYMid')\n\n        if (preserveAspectRatio) {\n            let newWidth, newHeight\n\n            if (preserveAspectRatio.meet) {\n                if (scaleX > scaleY) {\n                    scaleX   = scaleY\n                    newWidth = viewBox[2] * scaleX\n                }\n                else if (scaleX < scaleY) {\n                    scaleY    = scaleX\n                    newHeight = viewBox[3] * scaleY\n                }\n            }\n            else if (preserveAspectRatio.slice) {\n                if (scaleX < scaleY) {\n                    scaleX   = scaleY\n                    newWidth = viewBox[2] * scaleX\n                }\n                else if (scaleX > scaleY) {\n                    scaleY    = scaleX\n                    newHeight = viewBox[3] * scaleY\n                }\n            }\n\n            if (newWidth !== undefined) {\n                if (preserveAspectRatio.align === 'xMidYMid') {\n                    this.tag.translate((width - newWidth) / 2, 0)\n                }\n                else if (preserveAspectRatio.align === 'xMaxYMax') {\n                    this.tag.translate(width - newWidth, 0)\n                }\n            }\n            else if (newHeight !== undefined) {\n                if (preserveAspectRatio.align === 'xMidYMid') {\n                    this.tag.translate(0, (height - newHeight) / 2)\n                }\n                else if (preserveAspectRatio.align === 'xMaxYMax') {\n                    this.tag.translate(0, height - newHeight)\n                }\n            }\n        }\n\n        this.tag.scale(scaleX, scaleY)\n        this.tag.translate(-translateX, -translateY)\n    }\n\n    // Parse transform attribute and set transformations\n    _parseTransformAttr() {\n        // Get transform attribute\n        let transformAttr = this.tag.getAttr('transform', null)\n\n        // No transformation...\n        if (transformAttr === null || ! transformAttr.length) {\n            return null\n        }\n\n        // Parse attribute (split group on closing parenthesis)\n        let transformations = transformAttr.split(')')\n\n        // Remove last entry due to last \")\" found\n        transformations.pop()\n\n        // For each transformation\n        let transform, type, params\n\n        transformations.some(raw => {\n            // Split name and value on opening parenthesis\n            transform = raw.split('(')\n\n            // Invalid parts number\n            if (transform.length !== 2) {\n                return this.parser._skipTagAttr(this.tag, transformAttr, 'malformed') // continue\n            }\n\n            type = transform[0].trim()\n\n            // Quik hack 1/2\n            let func = type\n            if (func === 'matrix') {\n                func = 'addMatrix'\n            }\n\n            // Get tag transform method\n            let tagTransform = this.tag[func]\n\n            if (typeof tagTransform !== 'function') {\n                return this.parser._skipTagAttr(this.tag, transformAttr, 'unsupported transform type :' + type)\n            }\n\n            params = transform[1].trim()\n            params = this._parseNumbers(params)\n\n            // Skip empty value\n            if (! params.length) {\n                return this.parser._skipTagAttr(this.tag, transformAttr, 'malformed transform type :' + type)\n            }\n\n            // Quik hack 2/2\n            if (func == 'addMatrix') {\n                params = [params]\n            }\n\n            // Call tag transform method like \"tag.translate(param1, ..., paramN)\"\n            tagTransform.apply(this.tag, params)\n        })\n    }\n\n    _newPath() {\n        this.tag.newPath()\n    }\n\n    _clearPath() {\n        this.tag.clearPath()\n    }\n\n    _closePath() {\n        return this.tag.closePath()\n    }\n\n    _addPoints(points, relative) {\n        if (! points.length) {\n            return this.parser._skipTag(this.tag, 'empty points list')\n        }\n\n        if (points.length % 0) {\n            return this.parser._skipTag(this.tag, 'the number of points must be even')\n        }\n\n        //relative = arguments.length < 2 && this.currentCommand.relative\n        if (relative === undefined) {\n            relative = this.currentCommand.relative\n        }\n\n        this.tag.addPoints(points, relative)\n        return true\n    }\n\n    // SVG specs at https://www.w3.org/TR/SVG11/\n\n    _svg() {\n        // Only parse the root SVG tag as main document\n        if (this.parser.document) {\n            // Handled tag\n            return true\n        }\n\n        // Get the document size\n        let width  = this.tag.getAttr('width')\n        let height = this.tag.getAttr('height')\n\n        // Invalid size\n        if (! width || width < 0 || ! height || height < 0) {\n            throw new Error('Invalid document size: ' + width + ' / ' + height)\n        }\n\n        // Set document size\n        this.parser.document = {\n            width : width,\n            height: height\n        }\n\n        // Get document viewBox or set default to document size\n        let viewBox = this.tag.getAttr('viewBox', [0, 0, width, height])\n\n        this.parser.document.viewBox = {\n            x     : viewBox[0],\n            y     : viewBox[1],\n            width : viewBox[2],\n            height: viewBox[3]\n        }\n\n        // Check inkscape version\n        if (this.parser.editor.name === 'inkscape') {\n            this.parser.editor.version = this.tag.getAttr('inkscape:version')\n        }\n\n        // Handled tag\n        return true\n    }\n\n    _title() {\n        // Register the first encountered title tag as document title\n        if (this.parser.document && ! this.parser.document.title) {\n            this.parser.document.title = this.tag.element.textContent\n        }\n\n        // Skipped tag\n        return false\n    }\n\n    _desc() {\n        // Register the first encountered desc tag as document description\n        if (this.parser.document && ! this.parser.document.description) {\n            this.parser.document.description = this.tag.element.textContent\n        }\n\n        // Skipped tag\n        return false\n    }\n\n    _image() {\n        // console.log(this.tag.getAttr('xlink:href'))\n        // Handled tag\n        return true\n    }\n\n    _text() {\n        // console.log(this.tag.element.textContent)\n        // Handled tag\n        return true\n    }\n\n    _defs() {\n        // Register all child element with an id attribute\n        this.tag.element.childNodes.forEach(childNode => {\n            childNode.id && (this.parser.defs[childNode.id] = childNode)\n        })\n\n        // Skipped tag\n        return false\n    }\n\n    _use() {\n        // Get the target id\n        let target  = this.tag.getAttr('xlink:href').replace(/^#/, '')\n\n        // Try to get the defined element\n        let element = this.parser.defs[target]\n\n        if (! element) {\n            return this.parser._skipTag(this.tag, 'undefined reference [' + target + ']')\n        }\n\n        // Parse the defined element and set new parent from <use> tag parent\n        let useTag = this.parser._parseElement(element, this.tag.parent)\n\n        if (! useTag) {\n            return this.parser._skipTag(this.tag, 'empty reference [' + target + ']')\n        }\n\n        // Set matrix from real parent (<use>)\n        useTag.setMatrix(this.tag.matrix)\n\n        // Replace the use tag with new one\n        this.tag.parent.addChild(useTag)\n\n        // Skipped tag\n        return false\n    }\n\n    _g() {\n        // Set the tag layer name\n        this.tag.setLayerName()\n\n        // Handled tag\n        return true\n    }\n\n    _line() {\n        // Handled tag\n        return this._path([\n            'M', this.tag.getAttr('x1'), this.tag.getAttr('y1'),\n            'L', this.tag.getAttr('x2'), this.tag.getAttr('y2')\n        ])\n    }\n\n    _polyline(close=false) {\n        let points = this.tag.getAttr('points')\n        let path   = ['M', points.shift(), points.shift(), 'L']\n\n        path = path.concat(points)\n        close && path.push('Z')\n\n        // Handled tag\n        return this._path(path)\n    }\n\n    _polygon() {\n        // Handled like polyline but closed\n        return this._polyline(true)\n    }\n\n    _rect() {\n        // Get rectangle attributes\n        let w  = this.tag.getAttr('width')\n        let h  = this.tag.getAttr('height')\n        let x  = this.tag.getAttr('x', 0)\n        let y  = this.tag.getAttr('y', 0)\n        let rx = this.tag.getAttr('rx', null)\n        let ry = this.tag.getAttr('ry', null)\n\n        // Simple rect\n        if (!rx && !ry) {\n            // Handled tag\n            return this._path(['M', x, y, 'h', w, 'v', h, 'h', -w, 'z'])\n        }\n\n        // If a properly specified value is provided for ‘rx’, but not for ‘ry’,\n        // then set both rx and ry to the value of ‘rx’ and vis-vera...\n        if (rx === null) rx = ry\n        if (ry === null) ry = rx\n\n        // A negative value is an error\n        if (rx === null || rx === null || rx < 0 || ry < 0) {\n            // Skip tag\n            return this.parser._skipTag(this.tag, 'negative value for \"rx/ry\" not allowed')\n        }\n\n        // If rx is greater than half of ‘width’, then set rx to half of ‘width’.\n        // If ry is greater than half of ‘height’, then set ry to half of ‘height’.\n        if (rx > w / 2) rx = w / 2\n        if (ry > h / 2) ry = h / 2\n\n        let dx = rx * 2\n        let dy = ry * 2\n\n        // Handled tag\n        return this._path([\n            'M', x + rx, y,\n            'h', w - dx,\n            'c', rx, 0, rx, ry, rx, ry,\n            'v', h - dy,\n            'c', 0, ry, -rx, ry, -rx, ry,\n            'h', -w + dx,\n            'c', -rx, 0, -rx, -ry, -rx, -ry,\n            'v', -h + dy,\n            'c', 0, 0, 0, -ry, rx, -ry,\n            'z'\n        ])\n    }\n\n    _circle() {\n        let r = this.tag.getAttr('r', 0)\n\n        if (r <= 0) {\n            // Skipped tag\n            return false\n        }\n\n        let cx = this.tag.getAttr('cx', 0)\n        let cy = this.tag.getAttr('cy', 0)\n\n        // Handled tag\n        return this._path([\n            'M', cx-r, cy,\n            'A', r, r, 0, 0, 0, cx, cy+r,\n            'A', r, r, 0, 0, 0, cx+r, cy,\n            'A', r, r, 0, 0, 0, cx, cy-r,\n            'A', r, r, 0, 0, 0, cx-r, cy,\n            'Z'\n        ])\n    }\n\n    _ellipse() {\n        let rx = this.tag.getAttr('rx', 0)\n        let ry = this.tag.getAttr('ry', 0)\n\n        if (rx <= 0 || ry <= 0) {\n            // Skipped tag\n            return false\n        }\n\n        let cx = this.tag.getAttr('cx', 0)\n        let cy = this.tag.getAttr('cy', 0)\n\n        // Handled tag\n        return this._path([\n            'M', cx-rx, cy,\n            'A', rx, ry, 0, 0, 0, cx, cy+ry,\n            'A', rx, ry, 0, 0, 0, cx+rx, cy,\n            'A', rx, ry, 0, 0, 0, cx, cy-ry,\n            'A', rx, ry, 0, 0, 0, cx-rx, cy,\n            'Z'\n        ])\n    }\n\n    _paths(type, num, points) {\n        if (points.length > num) {\n            let handler, result = true\n\n            while(result && points.length) {\n                handler = this['_path' + type]\n                result  = handler.call(this, points.splice(0, num))\n            }\n\n            return result\n        }\n\n        return null\n    }\n\n    _path(path) {\n        // Provided path\n        if (path && typeof path !== 'string') {\n            path = path.join(' ')\n        }\n\n        // Get the paths data attribute value\n        let dAttr = path || this.tag.getAttr('d', null)\n\n        if (! dAttr) {\n            // Skipped tag\n            return false\n        }\n\n        // Split on each commands\n        let commands = dAttr.match(/([M|Z|L|H|V|C|S|Q|T|A]([^M|Z|L|H|V|C|S|Q|T|A]+)?)/gi)\n\n        if (! commands) {\n            return this.parser._skipTag(this.tag, 'malformed \"d\" attribute')\n        }\n\n        // For each command...\n        this.currentCommand = {\n            raw     : null,\n            type    : null,\n            params  : null,\n            relative: null\n        }\n        this.lastCommand = this.currentCommand\n        this.pathData    = {}\n\n        let handler    = null\n        let parseError = false\n\n        commands.some(raw => {\n            // Remove trailing whitespaces\n            raw = raw.trim()\n\n            // Extract command char and params\n            this.currentCommand.raw      = raw\n            this.currentCommand.type     = raw[0].toUpperCase()\n            this.currentCommand.params   = raw.substr(1).trim()\n            this.currentCommand.relative = this.currentCommand.type !== raw[0]\n\n            // Get path handler from command char\n            handler = this['_path' + this.currentCommand.type]\n\n            if (! handler || typeof handler !== 'function') {\n                this.parser._skipTag(this.tag, 'unsupported path command [' + raw[0] + ']')\n                return parseError = true // break\n            }\n\n            // Extract all numbers from arguments string\n            this.currentCommand.params = this._parseNumbers(this.currentCommand.params)\n\n            if (this.currentCommand.params === false) {\n                this.parser._skipTag(this.tag, 'only numeric values are allowed in [' + this.currentCommand.raw + ']')\n                return parseError = true // break\n            }\n\n            // Execute command parser\n            if (! handler.call(this, this.currentCommand.params)) {\n                return parseError = true // break\n            }\n\n            // Update last command\n            this.lastCommand = {}\n\n            Object.keys(this.currentCommand).forEach(key => {\n                this.lastCommand[key] = this.currentCommand[key]\n            })\n        })\n\n        // Skip tag\n        if (parseError) {\n            this._clearPath()\n            return false\n        }\n\n        // Handled tag\n        return true\n    }\n\n    _pathM(points) {\n        // Current point\n        let x  = this.tag.point.x\n        let y  = this.tag.point.y\n        let rl = this.currentCommand.relative\n\n        // First point (start of new path)\n        let firstPoint = points.splice(0, 2)\n\n        // New path\n        this._newPath()\n\n        // Relative moveTo (First moveTo is always absolute)\n        if (rl && this.tag.paths.length > 1) {\n            firstPoint[0] += x\n            firstPoint[1] += y\n        }\n\n        // Add first point\n        let result = this._addPoints(firstPoint, false)\n\n        // If is followed by multiple pairs of coordinates,\n        // the subsequent pairs are treated as implicit lineto commands.\n        if (result && points.length) {\n            result = this._addPoints(points)\n        }\n\n        // Return result\n        return result\n    }\n\n    _pathZ() {\n        this._closePath()\n        return true\n    }\n\n    _pathL(points) {\n        return this._addPoints(points)\n    }\n\n    _pathH(points) {\n        return points.every(x => {\n            return this._addPoints([x, this.currentCommand.relative ? 0 : this.tag.point.y])\n        })\n    }\n\n    _pathV(points) {\n        return points.every(y => {\n            return this._addPoints([this.currentCommand.relative ? 0 : this.tag.point.x, y])\n        })\n    }\n\n    _pathC(points) {\n        // Multiple paths\n        let result = this._paths('C', 6, points)\n\n        if (result !== null) {\n            return result\n        }\n\n        // Single path\n        let p1 = this.tag.point\n        let rl = this.currentCommand.relative\n\n        let x1 = points[0] + (rl ? p1.x : 0)\n        let y1 = points[1] + (rl ? p1.y : 0)\n        let x2 = points[2] + (rl ? p1.x : 0)\n        let y2 = points[3] + (rl ? p1.y : 0)\n        let x  = points[4] + (rl ? p1.x : 0)\n        let y  = points[5] + (rl ? p1.y : 0)\n\n        this.pathData.x2 = x2\n        this.pathData.y2 = y2\n\n        let p2 = new Point(x1, y1)\n        let p3 = new Point(x2, y2)\n        let p4 = new Point(x, y)\n\n        //console.log('C', p1, p2, p3, p4)\n\n        // p1  : starting point\n        // p2  : control point\n        // p3  : control point\n        // p4  : end point\n        let tracer = new CubicBezier(this.traceSettings)\n        let coords = tracer.trace({ p1, p2, p3, p4 }) // => [x,y, x,y, ...]\n        // let tracer = trace(CubicBezier, this.traceSettings)\n        // let coords = tracer({ p1, p2, p3, p4 })\n\n        // Trace the line\n        return this._addPoints(coords, false)\n    }\n\n    _pathS(points) {\n        // Multiple paths\n        let result = this._paths('S', 4, points)\n\n        if (result !== null) {\n            return result\n        }\n\n        // Single path\n        let p1 = this.tag.point\n        let rl = this.currentCommand.relative\n\n        let x1 = p1.x\n        let y1 = p1.y\n\n        if (this.lastCommand.type === 'S' || this.lastCommand.type === 'C') {\n            x1 -= this.pathData.x2 - x1\n            y1 -= this.pathData.y2 - y1\n        }\n\n        let x2 = points[0] + (rl ? p1.x : 0)\n        let y2 = points[1] + (rl ? p1.y : 0)\n        let x  = points[2] + (rl ? p1.x : 0)\n        let y  = points[3] + (rl ? p1.y : 0)\n\n        this.pathData.x2 = x2\n        this.pathData.y2 = y2\n\n        let p2 = new Point(x1, y1)\n        let p3 = new Point(x2, y2)\n        let p4 = new Point(x, y)\n\n        //console.log('S', p1, p2, p3, p4)\n\n        // p1  : starting point\n        // p2  : control point\n        // p3  : control point\n        // p4  : end point\n        let tracer = new CubicBezier(this.traceSettings)\n        let coords = tracer.trace({ p1, p2, p3, p4 }) // => [x,y, x,y, ...]\n        // let tracer = trace(CubicBezier, this.traceSettings)\n        // let coords = tracer({ p1, p2, p3, p4 })\n\n        // Trace the line\n        return this._addPoints(coords, false)\n    }\n\n    _pathQ(points) {\n        // Multiple paths\n        let result = this._paths('Q', 4, points)\n\n        if (result !== null) {\n            return result\n        }\n\n        // Single path\n        let p1 = this.tag.point\n        let rl = this.currentCommand.relative\n\n        let x1 = points[0] + (rl ? p1.x : 0)\n        let y1 = points[1] + (rl ? p1.y : 0)\n        let x  = points[2] + (rl ? p1.x : 0)\n        let y  = points[3] + (rl ? p1.y : 0)\n\n        this.pathData.x1 = x1\n        this.pathData.y1 = y1\n\n        let p2 = new Point(x1, y1)\n        let p3 = new Point(x, y)\n\n        //console.log('Q', p1, p2, p3)\n\n        // p1  : starting point\n        // p2  : control point\n        // p3  : end point\n        let tracer = new QuadricBezier(this.traceSettings)\n        let coords = tracer.trace({ p1, p2, p3 }) // => [x,y, x,y, ...]\n\n        // Trace the line\n        return this._addPoints(coords, false)\n    }\n\n    _pathT(points) {\n        // Multiple paths\n        let result = this._paths('T', 2, points)\n\n        if (result !== null) {\n            return result\n        }\n\n        // Single path\n        let p1 = this.tag.point\n        let rl = this.currentCommand.relative\n\n        let x1 = p1.x\n        let y1 = p1.y\n\n        if (this.lastCommand.type === 'Q' || this.lastCommand.type === 'T') {\n            x1 -= this.pathData.x1 - x1\n            y1 -= this.pathData.y1 - y1\n        }\n\n        let x = points[0] + (rl ? p1.x : 0)\n        let y = points[1] + (rl ? p1.y : 0)\n\n        this.pathData.x1 = x1\n        this.pathData.y1 = y1\n\n        let p2 = new Point(x1, y1)\n        let p3 = new Point(x, y)\n\n        //console.log('T', p1, p2, p3)\n\n        // p1  : starting point\n        // p2  : control point\n        // p3  : end point\n        let tracer = new QuadricBezier(this.traceSettings)\n        let coords = tracer.trace({ p1, p2, p3 }) // => [x,y, x,y, ...]\n\n        // Trace the line\n        return this._addPoints(coords, false)\n    }\n\n    _pathA(points) {\n        // Multiple paths\n        let result = this._paths('A', 7, points)\n\n        if (result !== null) {\n            return result\n        }\n\n        // Single path\n        let rl    = this.currentCommand.relative\n        let p1    = this.tag.point\n        let rx    = points[0]\n        let ry    = points[1]\n        let angle = points[2]\n        let large = !!points[3]\n        let sweep = !!points[4]\n        let x     = points[5] + (rl ? p1.x : 0)\n        let y     = points[6] + (rl ? p1.y : 0)\n        let p2    = new Point(x, y)\n\n        //console.log('A', p1, rx, ry, angle, large, sweep, p2)\n\n        let tracer = new Arc(this.traceSettings)\n        let coords = tracer.trace({ p1, rx, ry, angle, large, sweep, p2 }) // => [x,y, x,y, ...]\n\n        // Trace the line\n        return this._addPoints(coords, false)\n    }\n}\n\n// Exports\nexport { TagParser }\nexport default TagParser\n\n\n\n// WEBPACK FOOTER //\n// ./tagparser.js","// rev 482\n/********************************************************************************\n *                                                                              *\n * Author    :  Angus Johnson                                                   *\n * Version   :  6.2.1                                                          *\n * Date      :  31 October 2014                                                 *\n * Website   :  http://www.angusj.com                                           *\n * Copyright :  Angus Johnson 2010-2014                                         *\n *                                                                              *\n * License:                                                                     *\n * Use, modification & distribution is subject to Boost Software License Ver 1. *\n * http://www.boost.org/LICENSE_1_0.txt                                         *\n *                                                                              *\n * Attributions:                                                                *\n * The code in this library is an extension of Bala Vatti's clipping algorithm: *\n * \"A generic solution to polygon clipping\"                                     *\n * Communications of the ACM, Vol 35, Issue 7 (July 1992) pp 56-63.             *\n * http://portal.acm.org/citation.cfm?id=129906                                 *\n *                                                                              *\n * Computer graphics and geometric modeling: implementation and algorithms      *\n * By Max K. Agoston                                                            *\n * Springer; 1 edition (January 4, 2005)                                        *\n * http://books.google.com/books?q=vatti+clipping+agoston                       *\n *                                                                              *\n * See also:                                                                    *\n * \"Polygon Offsetting by Computing Winding Numbers\"                            *\n * Paper no. DETC2005-85513 pp. 565-575                                         *\n * ASME 2005 International Design Engineering Technical Conferences             *\n * and Computers and Information in Engineering Conference (IDETC/CIE2005)      *\n * September 24-28, 2005 , Long Beach, California, USA                          *\n * http://www.me.berkeley.edu/~mcmains/pubs/DAC05OffsetPolygon.pdf              *\n *                                                                              *\n *******************************************************************************/\n/*******************************************************************************\n *                                                                              *\n * Author    :  Timo                                                            *\n * Version   :  6.2.1.0                                                         *\n * Date      :  17 June 2016                                                 *\n *                                                                              *\n * This is a translation of the C# Clipper library to Javascript.               *\n * Int128 struct of C# is implemented using JSBN of Tom Wu.                     *\n * Because Javascript lacks support for 64-bit integers, the space              *\n * is a little more restricted than in C# version.                              *\n *                                                                              *\n * C# version has support for coordinate space:                                 *\n * +-4611686018427387903 ( sqrt(2^127 -1)/2 )                                   *\n * while Javascript version has support for space:                              *\n * +-4503599627370495 ( sqrt(2^106 -1)/2 )                                      *\n *                                                                              *\n * Tom Wu's JSBN proved to be the fastest big integer library:                  *\n * http://jsperf.com/big-integer-library-test                                   *\n *                                                                              *\n * This class can be made simpler when (if ever) 64-bit integer support comes.  *\n *                                                                              *\n *******************************************************************************/\n/*******************************************************************************\n *                                                                              *\n * Basic JavaScript BN library - subset useful for RSA encryption.              *\n * http://www-cs-students.stanford.edu/~tjw/jsbn/                               *\n * Copyright (c) 2005  Tom Wu                                                   *\n * All Rights Reserved.                                                         *\n * See \"LICENSE\" for details:                                                   *\n * http://www-cs-students.stanford.edu/~tjw/jsbn/LICENSE                        *\n *                                                                              *\n *******************************************************************************/\n(function ()\n{\n  \"use strict\";\n  //use_int32: When enabled 32bit ints are used instead of 64bit ints. This\n  //improve performance but coordinate values are limited to the range +/- 46340\n  var use_int32 = false;\n  //use_xyz: adds a Z member to IntPoint. Adds a minor cost to performance.\n  var use_xyz = false;\n  //UseLines: Enables open path clipping. Adds a very minor cost to performance.\n  var use_lines = true;\n\n  var ClipperLib = {};\n  var isNode = false;\n  if (typeof module !== 'undefined' && module.exports)\n  {\n    module.exports = ClipperLib;\n    isNode = true;\n  }\n  else\n  {\n    if (typeof define === 'function' && define.amd) {\n      define(ClipperLib);\n    }\n    if (typeof (document) !== \"undefined\") window.ClipperLib = ClipperLib;\n    else self['ClipperLib'] = ClipperLib;\n  }\n  var navigator_appName;\n  if (!isNode)\n  {\n    var nav = navigator.userAgent.toString().toLowerCase();\n    navigator_appName = navigator.appName;\n  }\n  else\n  {\n    var nav = \"chrome\"; // Node.js uses Chrome's V8 engine\n    navigator_appName = \"Netscape\"; // Firefox, Chrome and Safari returns \"Netscape\", so Node.js should also\n  }\n  // Browser test to speedup performance critical functions\n  var browser = {};\n  if (nav.indexOf(\"chrome\") != -1 && nav.indexOf(\"chromium\") == -1) browser.chrome = 1;\n  else browser.chrome = 0;\n  if (nav.indexOf(\"chromium\") != -1) browser.chromium = 1;\n  else browser.chromium = 0;\n  if (nav.indexOf(\"safari\") != -1 && nav.indexOf(\"chrome\") == -1 && nav.indexOf(\"chromium\") == -1) browser.safari = 1;\n  else browser.safari = 0;\n  if (nav.indexOf(\"firefox\") != -1) browser.firefox = 1;\n  else browser.firefox = 0;\n  if (nav.indexOf(\"firefox/17\") != -1) browser.firefox17 = 1;\n  else browser.firefox17 = 0;\n  if (nav.indexOf(\"firefox/15\") != -1) browser.firefox15 = 1;\n  else browser.firefox15 = 0;\n  if (nav.indexOf(\"firefox/3\") != -1) browser.firefox3 = 1;\n  else browser.firefox3 = 0;\n  if (nav.indexOf(\"opera\") != -1) browser.opera = 1;\n  else browser.opera = 0;\n  if (nav.indexOf(\"msie 10\") != -1) browser.msie10 = 1;\n  else browser.msie10 = 0;\n  if (nav.indexOf(\"msie 9\") != -1) browser.msie9 = 1;\n  else browser.msie9 = 0;\n  if (nav.indexOf(\"msie 8\") != -1) browser.msie8 = 1;\n  else browser.msie8 = 0;\n  if (nav.indexOf(\"msie 7\") != -1) browser.msie7 = 1;\n  else browser.msie7 = 0;\n  if (nav.indexOf(\"msie \") != -1) browser.msie = 1;\n  else browser.msie = 0;\n  ClipperLib.biginteger_used = null;\n\n  // Copyright (c) 2005  Tom Wu\n  // All Rights Reserved.\n  // See \"LICENSE\" for details.\n  // Basic JavaScript BN library - subset useful for RSA encryption.\n  // Bits per digit\n  var dbits;\n  // JavaScript engine analysis\n  var canary = 0xdeadbeefcafe;\n  var j_lm = ((canary & 0xffffff) == 0xefcafe);\n  // (public) Constructor\n  function BigInteger(a, b, c)\n  {\n    // This test variable can be removed,\n    // but at least for performance tests it is useful piece of knowledge\n    // This is the only ClipperLib related variable in BigInteger library\n    ClipperLib.biginteger_used = 1;\n    if (a != null)\n      if (\"number\" == typeof a && \"undefined\" == typeof (b)) this.fromInt(a); // faster conversion\n      else if (\"number\" == typeof a) this.fromNumber(a, b, c);\n    else if (b == null && \"string\" != typeof a) this.fromString(a, 256);\n    else this.fromString(a, b);\n  }\n  // return new, unset BigInteger\n  function nbi()\n  {\n    return new BigInteger(null,undefined,undefined);\n  }\n  // am: Compute w_j += (x*this_i), propagate carries,\n  // c is initial carry, returns final carry.\n  // c < 3*dvalue, x < 2*dvalue, this_i < dvalue\n  // We need to select the fastest one that works in this environment.\n  // am1: use a single mult and divide to get the high bits,\n  // max digit bits should be 26 because\n  // max internal value = 2*dvalue^2-2*dvalue (< 2^53)\n  function am1(i, x, w, j, c, n)\n  {\n    while (--n >= 0)\n    {\n      var v = x * this[i++] + w[j] + c;\n      c = Math.floor(v / 0x4000000);\n      w[j++] = v & 0x3ffffff;\n    }\n    return c;\n  }\n  // am2 avoids a big mult-and-extract completely.\n  // Max digit bits should be <= 30 because we do bitwise ops\n  // on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)\n  function am2(i, x, w, j, c, n)\n  {\n    var xl = x & 0x7fff,\n      xh = x >> 15;\n    while (--n >= 0)\n    {\n      var l = this[i] & 0x7fff;\n      var h = this[i++] >> 15;\n      var m = xh * l + h * xl;\n      l = xl * l + ((m & 0x7fff) << 15) + w[j] + (c & 0x3fffffff);\n      c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);\n      w[j++] = l & 0x3fffffff;\n    }\n    return c;\n  }\n  // Alternately, set max digit bits to 28 since some\n  // browsers slow down when dealing with 32-bit numbers.\n  function am3(i, x, w, j, c, n)\n  {\n    var xl = x & 0x3fff,\n      xh = x >> 14;\n    while (--n >= 0)\n    {\n      var l = this[i] & 0x3fff;\n      var h = this[i++] >> 14;\n      var m = xh * l + h * xl;\n      l = xl * l + ((m & 0x3fff) << 14) + w[j] + c;\n      c = (l >> 28) + (m >> 14) + xh * h;\n      w[j++] = l & 0xfffffff;\n    }\n    return c;\n  }\n  if (j_lm && (navigator_appName == \"Microsoft Internet Explorer\"))\n  {\n    BigInteger.prototype.am = am2;\n    dbits = 30;\n  }\n  else if (j_lm && (navigator_appName != \"Netscape\"))\n  {\n    BigInteger.prototype.am = am1;\n    dbits = 26;\n  }\n  else\n  { // Mozilla/Netscape seems to prefer am3\n    BigInteger.prototype.am = am3;\n    dbits = 28;\n  }\n  BigInteger.prototype.DB = dbits;\n  BigInteger.prototype.DM = ((1 << dbits) - 1);\n  BigInteger.prototype.DV = (1 << dbits);\n  var BI_FP = 52;\n  BigInteger.prototype.FV = Math.pow(2, BI_FP);\n  BigInteger.prototype.F1 = BI_FP - dbits;\n  BigInteger.prototype.F2 = 2 * dbits - BI_FP;\n  // Digit conversions\n  var BI_RM = \"0123456789abcdefghijklmnopqrstuvwxyz\";\n  var BI_RC = new Array();\n  var rr, vv;\n  rr = \"0\".charCodeAt(0);\n  for (vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;\n  rr = \"a\".charCodeAt(0);\n  for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\n  rr = \"A\".charCodeAt(0);\n  for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\n\n  function int2char(n)\n  {\n    return BI_RM.charAt(n);\n  }\n\n  function intAt(s, i)\n  {\n    var c = BI_RC[s.charCodeAt(i)];\n    return (c == null) ? -1 : c;\n  }\n  // (protected) copy this to r\n  function bnpCopyTo(r)\n  {\n    for (var i = this.t - 1; i >= 0; --i) r[i] = this[i];\n    r.t = this.t;\n    r.s = this.s;\n  }\n  // (protected) set from integer value x, -DV <= x < DV\n  function bnpFromInt(x)\n  {\n    this.t = 1;\n    this.s = (x < 0) ? -1 : 0;\n    if (x > 0) this[0] = x;\n    else if (x < -1) this[0] = x + this.DV;\n    else this.t = 0;\n  }\n  // return bigint initialized to value\n  function nbv(i)\n  {\n    var r = nbi();\n    r.fromInt(i);\n    return r;\n  }\n  // (protected) set from string and radix\n  function bnpFromString(s, b)\n  {\n    var k;\n    if (b == 16) k = 4;\n    else if (b == 8) k = 3;\n    else if (b == 256) k = 8; // byte array\n    else if (b == 2) k = 1;\n    else if (b == 32) k = 5;\n    else if (b == 4) k = 2;\n    else\n    {\n      this.fromRadix(s, b);\n      return;\n    }\n    this.t = 0;\n    this.s = 0;\n    var i = s.length,\n      mi = false,\n      sh = 0;\n    while (--i >= 0)\n    {\n      var x = (k == 8) ? s[i] & 0xff : intAt(s, i);\n      if (x < 0)\n      {\n        if (s.charAt(i) == \"-\") mi = true;\n        continue;\n      }\n      mi = false;\n      if (sh == 0)\n        this[this.t++] = x;\n      else if (sh + k > this.DB)\n      {\n        this[this.t - 1] |= (x & ((1 << (this.DB - sh)) - 1)) << sh;\n        this[this.t++] = (x >> (this.DB - sh));\n      }\n      else\n        this[this.t - 1] |= x << sh;\n      sh += k;\n      if (sh >= this.DB) sh -= this.DB;\n    }\n    if (k == 8 && (s[0] & 0x80) != 0)\n    {\n      this.s = -1;\n      if (sh > 0) this[this.t - 1] |= ((1 << (this.DB - sh)) - 1) << sh;\n    }\n    this.clamp();\n    if (mi) BigInteger.ZERO.subTo(this, this);\n  }\n  // (protected) clamp off excess high words\n  function bnpClamp()\n  {\n    var c = this.s & this.DM;\n    while (this.t > 0 && this[this.t - 1] == c)--this.t;\n  }\n  // (public) return string representation in given radix\n  function bnToString(b)\n  {\n    if (this.s < 0) return \"-\" + this.negate().toString(b);\n    var k;\n    if (b == 16) k = 4;\n    else if (b == 8) k = 3;\n    else if (b == 2) k = 1;\n    else if (b == 32) k = 5;\n    else if (b == 4) k = 2;\n    else return this.toRadix(b);\n    var km = (1 << k) - 1,\n      d, m = false,\n      r = \"\",\n      i = this.t;\n    var p = this.DB - (i * this.DB) % k;\n    if (i-- > 0)\n    {\n      if (p < this.DB && (d = this[i] >> p) > 0)\n      {\n        m = true;\n        r = int2char(d);\n      }\n      while (i >= 0)\n      {\n        if (p < k)\n        {\n          d = (this[i] & ((1 << p) - 1)) << (k - p);\n          d |= this[--i] >> (p += this.DB - k);\n        }\n        else\n        {\n          d = (this[i] >> (p -= k)) & km;\n          if (p <= 0)\n          {\n            p += this.DB;\n            --i;\n          }\n        }\n        if (d > 0) m = true;\n        if (m) r += int2char(d);\n      }\n    }\n    return m ? r : \"0\";\n  }\n  // (public) -this\n  function bnNegate()\n  {\n    var r = nbi();\n    BigInteger.ZERO.subTo(this, r);\n    return r;\n  }\n  // (public) |this|\n  function bnAbs()\n  {\n    return (this.s < 0) ? this.negate() : this;\n  }\n  // (public) return + if this > a, - if this < a, 0 if equal\n  function bnCompareTo(a)\n  {\n    var r = this.s - a.s;\n    if (r != 0) return r;\n    var i = this.t;\n    r = i - a.t;\n    if (r != 0) return (this.s < 0) ? -r : r;\n    while (--i >= 0)\n      if ((r = this[i] - a[i]) != 0) return r;\n    return 0;\n  }\n  // returns bit length of the integer x\n  function nbits(x)\n  {\n    var r = 1,\n      t;\n    if ((t = x >>> 16) != 0)\n    {\n      x = t;\n      r += 16;\n    }\n    if ((t = x >> 8) != 0)\n    {\n      x = t;\n      r += 8;\n    }\n    if ((t = x >> 4) != 0)\n    {\n      x = t;\n      r += 4;\n    }\n    if ((t = x >> 2) != 0)\n    {\n      x = t;\n      r += 2;\n    }\n    if ((t = x >> 1) != 0)\n    {\n      x = t;\n      r += 1;\n    }\n    return r;\n  }\n  // (public) return the number of bits in \"this\"\n  function bnBitLength()\n  {\n    if (this.t <= 0) return 0;\n    return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ (this.s & this.DM));\n  }\n  // (protected) r = this << n*DB\n  function bnpDLShiftTo(n, r)\n  {\n    var i;\n    for (i = this.t - 1; i >= 0; --i) r[i + n] = this[i];\n    for (i = n - 1; i >= 0; --i) r[i] = 0;\n    r.t = this.t + n;\n    r.s = this.s;\n  }\n  // (protected) r = this >> n*DB\n  function bnpDRShiftTo(n, r)\n  {\n    for (var i = n; i < this.t; ++i) r[i - n] = this[i];\n    r.t = Math.max(this.t - n, 0);\n    r.s = this.s;\n  }\n  // (protected) r = this << n\n  function bnpLShiftTo(n, r)\n  {\n    var bs = n % this.DB;\n    var cbs = this.DB - bs;\n    var bm = (1 << cbs) - 1;\n    var ds = Math.floor(n / this.DB),\n      c = (this.s << bs) & this.DM,\n      i;\n    for (i = this.t - 1; i >= 0; --i)\n    {\n      r[i + ds + 1] = (this[i] >> cbs) | c;\n      c = (this[i] & bm) << bs;\n    }\n    for (i = ds - 1; i >= 0; --i) r[i] = 0;\n    r[ds] = c;\n    r.t = this.t + ds + 1;\n    r.s = this.s;\n    r.clamp();\n  }\n  // (protected) r = this >> n\n  function bnpRShiftTo(n, r)\n  {\n    r.s = this.s;\n    var ds = Math.floor(n / this.DB);\n    if (ds >= this.t)\n    {\n      r.t = 0;\n      return;\n    }\n    var bs = n % this.DB;\n    var cbs = this.DB - bs;\n    var bm = (1 << bs) - 1;\n    r[0] = this[ds] >> bs;\n    for (var i = ds + 1; i < this.t; ++i)\n    {\n      r[i - ds - 1] |= (this[i] & bm) << cbs;\n      r[i - ds] = this[i] >> bs;\n    }\n    if (bs > 0) r[this.t - ds - 1] |= (this.s & bm) << cbs;\n    r.t = this.t - ds;\n    r.clamp();\n  }\n  // (protected) r = this - a\n  function bnpSubTo(a, r)\n  {\n    var i = 0,\n      c = 0,\n      m = Math.min(a.t, this.t);\n    while (i < m)\n    {\n      c += this[i] - a[i];\n      r[i++] = c & this.DM;\n      c >>= this.DB;\n    }\n    if (a.t < this.t)\n    {\n      c -= a.s;\n      while (i < this.t)\n      {\n        c += this[i];\n        r[i++] = c & this.DM;\n        c >>= this.DB;\n      }\n      c += this.s;\n    }\n    else\n    {\n      c += this.s;\n      while (i < a.t)\n      {\n        c -= a[i];\n        r[i++] = c & this.DM;\n        c >>= this.DB;\n      }\n      c -= a.s;\n    }\n    r.s = (c < 0) ? -1 : 0;\n    if (c < -1) r[i++] = this.DV + c;\n    else if (c > 0) r[i++] = c;\n    r.t = i;\n    r.clamp();\n  }\n  // (protected) r = this * a, r != this,a (HAC 14.12)\n  // \"this\" should be the larger one if appropriate.\n  function bnpMultiplyTo(a, r)\n  {\n    var x = this.abs(),\n      y = a.abs();\n    var i = x.t;\n    r.t = i + y.t;\n    while (--i >= 0) r[i] = 0;\n    for (i = 0; i < y.t; ++i) r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);\n    r.s = 0;\n    r.clamp();\n    if (this.s != a.s) BigInteger.ZERO.subTo(r, r);\n  }\n  // (protected) r = this^2, r != this (HAC 14.16)\n  function bnpSquareTo(r)\n  {\n    var x = this.abs();\n    var i = r.t = 2 * x.t;\n    while (--i >= 0) r[i] = 0;\n    for (i = 0; i < x.t - 1; ++i)\n    {\n      var c = x.am(i, x[i], r, 2 * i, 0, 1);\n      if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV)\n      {\n        r[i + x.t] -= x.DV;\n        r[i + x.t + 1] = 1;\n      }\n    }\n    if (r.t > 0) r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);\n    r.s = 0;\n    r.clamp();\n  }\n  // (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)\n  // r != q, this != m.  q or r may be null.\n  function bnpDivRemTo(m, q, r)\n  {\n    var pm = m.abs();\n    if (pm.t <= 0) return;\n    var pt = this.abs();\n    if (pt.t < pm.t)\n    {\n      if (q != null) q.fromInt(0);\n      if (r != null) this.copyTo(r);\n      return;\n    }\n    if (r == null) r = nbi();\n    var y = nbi(),\n      ts = this.s,\n      ms = m.s;\n    var nsh = this.DB - nbits(pm[pm.t - 1]); // normalize modulus\n    if (nsh > 0)\n    {\n      pm.lShiftTo(nsh, y);\n      pt.lShiftTo(nsh, r);\n    }\n    else\n    {\n      pm.copyTo(y);\n      pt.copyTo(r);\n    }\n    var ys = y.t;\n    var y0 = y[ys - 1];\n    if (y0 == 0) return;\n    var yt = y0 * (1 << this.F1) + ((ys > 1) ? y[ys - 2] >> this.F2 : 0);\n    var d1 = this.FV / yt,\n      d2 = (1 << this.F1) / yt,\n      e = 1 << this.F2;\n    var i = r.t,\n      j = i - ys,\n      t = (q == null) ? nbi() : q;\n    y.dlShiftTo(j, t);\n    if (r.compareTo(t) >= 0)\n    {\n      r[r.t++] = 1;\n      r.subTo(t, r);\n    }\n    BigInteger.ONE.dlShiftTo(ys, t);\n    t.subTo(y, y); // \"negative\" y so we can replace sub with am later\n    while (y.t < ys) y[y.t++] = 0;\n    while (--j >= 0)\n    {\n      // Estimate quotient digit\n      var qd = (r[--i] == y0) ? this.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);\n      if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd)\n      { // Try it out\n        y.dlShiftTo(j, t);\n        r.subTo(t, r);\n        while (r[i] < --qd) r.subTo(t, r);\n      }\n    }\n    if (q != null)\n    {\n      r.drShiftTo(ys, q);\n      if (ts != ms) BigInteger.ZERO.subTo(q, q);\n    }\n    r.t = ys;\n    r.clamp();\n    if (nsh > 0) r.rShiftTo(nsh, r); // Denormalize remainder\n    if (ts < 0) BigInteger.ZERO.subTo(r, r);\n  }\n  // (public) this mod a\n  function bnMod(a)\n  {\n    var r = nbi();\n    this.abs().divRemTo(a, null, r);\n    if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r, r);\n    return r;\n  }\n  // Modular reduction using \"classic\" algorithm\n  function Classic(m)\n  {\n    this.m = m;\n  }\n\n  function cConvert(x)\n  {\n    if (x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);\n    else return x;\n  }\n\n  function cRevert(x)\n  {\n    return x;\n  }\n\n  function cReduce(x)\n  {\n    x.divRemTo(this.m, null, x);\n  }\n\n  function cMulTo(x, y, r)\n  {\n    x.multiplyTo(y, r);\n    this.reduce(r);\n  }\n\n  function cSqrTo(x, r)\n  {\n    x.squareTo(r);\n    this.reduce(r);\n  }\n  Classic.prototype.convert = cConvert;\n  Classic.prototype.revert = cRevert;\n  Classic.prototype.reduce = cReduce;\n  Classic.prototype.mulTo = cMulTo;\n  Classic.prototype.sqrTo = cSqrTo;\n  // (protected) return \"-1/this % 2^DB\"; useful for Mont. reduction\n  // justification:\n  //         xy == 1 (mod m)\n  //         xy =  1+km\n  //   xy(2-xy) = (1+km)(1-km)\n  // x[y(2-xy)] = 1-k^2m^2\n  // x[y(2-xy)] == 1 (mod m^2)\n  // if y is 1/x mod m, then y(2-xy) is 1/x mod m^2\n  // should reduce x and y(2-xy) by m^2 at each step to keep size bounded.\n  // JS multiply \"overflows\" differently from C/C++, so care is needed here.\n  function bnpInvDigit()\n  {\n    if (this.t < 1) return 0;\n    var x = this[0];\n    if ((x & 1) == 0) return 0;\n    var y = x & 3; // y == 1/x mod 2^2\n    y = (y * (2 - (x & 0xf) * y)) & 0xf; // y == 1/x mod 2^4\n    y = (y * (2 - (x & 0xff) * y)) & 0xff; // y == 1/x mod 2^8\n    y = (y * (2 - (((x & 0xffff) * y) & 0xffff))) & 0xffff; // y == 1/x mod 2^16\n    // last step - calculate inverse mod DV directly;\n    // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints\n    y = (y * (2 - x * y % this.DV)) % this.DV; // y == 1/x mod 2^dbits\n    // we really want the negative inverse, and -DV < y < DV\n    return (y > 0) ? this.DV - y : -y;\n  }\n  // Montgomery reduction\n  function Montgomery(m)\n  {\n    this.m = m;\n    this.mp = m.invDigit();\n    this.mpl = this.mp & 0x7fff;\n    this.mph = this.mp >> 15;\n    this.um = (1 << (m.DB - 15)) - 1;\n    this.mt2 = 2 * m.t;\n  }\n  // xR mod m\n  function montConvert(x)\n  {\n    var r = nbi();\n    x.abs().dlShiftTo(this.m.t, r);\n    r.divRemTo(this.m, null, r);\n    if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r, r);\n    return r;\n  }\n  // x/R mod m\n  function montRevert(x)\n  {\n    var r = nbi();\n    x.copyTo(r);\n    this.reduce(r);\n    return r;\n  }\n  // x = x/R mod m (HAC 14.32)\n  function montReduce(x)\n  {\n    while (x.t <= this.mt2) // pad x so am has enough room later\n      x[x.t++] = 0;\n    for (var i = 0; i < this.m.t; ++i)\n    {\n      // faster way of calculating u0 = x[i]*mp mod DV\n      var j = x[i] & 0x7fff;\n      var u0 = (j * this.mpl + (((j * this.mph + (x[i] >> 15) * this.mpl) & this.um) << 15)) & x.DM;\n      // use am to combine the multiply-shift-add into one call\n      j = i + this.m.t;\n      x[j] += this.m.am(0, u0, x, i, 0, this.m.t);\n      // propagate carry\n      while (x[j] >= x.DV)\n      {\n        x[j] -= x.DV;\n        x[++j]++;\n      }\n    }\n    x.clamp();\n    x.drShiftTo(this.m.t, x);\n    if (x.compareTo(this.m) >= 0) x.subTo(this.m, x);\n  }\n  // r = \"x^2/R mod m\"; x != r\n  function montSqrTo(x, r)\n  {\n    x.squareTo(r);\n    this.reduce(r);\n  }\n  // r = \"xy/R mod m\"; x,y != r\n  function montMulTo(x, y, r)\n  {\n    x.multiplyTo(y, r);\n    this.reduce(r);\n  }\n  Montgomery.prototype.convert = montConvert;\n  Montgomery.prototype.revert = montRevert;\n  Montgomery.prototype.reduce = montReduce;\n  Montgomery.prototype.mulTo = montMulTo;\n  Montgomery.prototype.sqrTo = montSqrTo;\n  // (protected) true iff this is even\n  function bnpIsEven()\n  {\n    return ((this.t > 0) ? (this[0] & 1) : this.s) == 0;\n  }\n  // (protected) this^e, e < 2^32, doing sqr and mul with \"r\" (HAC 14.79)\n  function bnpExp(e, z)\n  {\n    if (e > 0xffffffff || e < 1) return BigInteger.ONE;\n    var r = nbi(),\n      r2 = nbi(),\n      g = z.convert(this),\n      i = nbits(e) - 1;\n    g.copyTo(r);\n    while (--i >= 0)\n    {\n      z.sqrTo(r, r2);\n      if ((e & (1 << i)) > 0) z.mulTo(r2, g, r);\n      else\n      {\n        var t = r;\n        r = r2;\n        r2 = t;\n      }\n    }\n    return z.revert(r);\n  }\n  // (public) this^e % m, 0 <= e < 2^32\n  function bnModPowInt(e, m)\n  {\n    var z;\n    if (e < 256 || m.isEven()) z = new Classic(m);\n    else z = new Montgomery(m);\n    return this.exp(e, z);\n  }\n  // protected\n  BigInteger.prototype.copyTo = bnpCopyTo;\n  BigInteger.prototype.fromInt = bnpFromInt;\n  BigInteger.prototype.fromString = bnpFromString;\n  BigInteger.prototype.clamp = bnpClamp;\n  BigInteger.prototype.dlShiftTo = bnpDLShiftTo;\n  BigInteger.prototype.drShiftTo = bnpDRShiftTo;\n  BigInteger.prototype.lShiftTo = bnpLShiftTo;\n  BigInteger.prototype.rShiftTo = bnpRShiftTo;\n  BigInteger.prototype.subTo = bnpSubTo;\n  BigInteger.prototype.multiplyTo = bnpMultiplyTo;\n  BigInteger.prototype.squareTo = bnpSquareTo;\n  BigInteger.prototype.divRemTo = bnpDivRemTo;\n  BigInteger.prototype.invDigit = bnpInvDigit;\n  BigInteger.prototype.isEven = bnpIsEven;\n  BigInteger.prototype.exp = bnpExp;\n  // public\n  BigInteger.prototype.toString = bnToString;\n  BigInteger.prototype.negate = bnNegate;\n  BigInteger.prototype.abs = bnAbs;\n  BigInteger.prototype.compareTo = bnCompareTo;\n  BigInteger.prototype.bitLength = bnBitLength;\n  BigInteger.prototype.mod = bnMod;\n  BigInteger.prototype.modPowInt = bnModPowInt;\n  // \"constants\"\n  BigInteger.ZERO = nbv(0);\n  BigInteger.ONE = nbv(1);\n  // Copyright (c) 2005-2009  Tom Wu\n  // All Rights Reserved.\n  // See \"LICENSE\" for details.\n  // Extended JavaScript BN functions, required for RSA private ops.\n  // Version 1.1: new BigInteger(\"0\", 10) returns \"proper\" zero\n  // Version 1.2: square() API, isProbablePrime fix\n  // (public)\n  function bnClone()\n  {\n    var r = nbi();\n    this.copyTo(r);\n    return r;\n  }\n  // (public) return value as integer\n  function bnIntValue()\n  {\n    if (this.s < 0)\n    {\n      if (this.t == 1) return this[0] - this.DV;\n      else if (this.t == 0) return -1;\n    }\n    else if (this.t == 1) return this[0];\n    else if (this.t == 0) return 0;\n    // assumes 16 < DB < 32\n    return ((this[1] & ((1 << (32 - this.DB)) - 1)) << this.DB) | this[0];\n  }\n  // (public) return value as byte\n  function bnByteValue()\n  {\n    return (this.t == 0) ? this.s : (this[0] << 24) >> 24;\n  }\n  // (public) return value as short (assumes DB>=16)\n  function bnShortValue()\n  {\n    return (this.t == 0) ? this.s : (this[0] << 16) >> 16;\n  }\n  // (protected) return x s.t. r^x < DV\n  function bnpChunkSize(r)\n  {\n    return Math.floor(Math.LN2 * this.DB / Math.log(r));\n  }\n  // (public) 0 if this == 0, 1 if this > 0\n  function bnSigNum()\n  {\n    if (this.s < 0) return -1;\n    else if (this.t <= 0 || (this.t == 1 && this[0] <= 0)) return 0;\n    else return 1;\n  }\n  // (protected) convert to radix string\n  function bnpToRadix(b)\n  {\n    if (b == null) b = 10;\n    if (this.signum() == 0 || b < 2 || b > 36) return \"0\";\n    var cs = this.chunkSize(b);\n    var a = Math.pow(b, cs);\n    var d = nbv(a),\n      y = nbi(),\n      z = nbi(),\n      r = \"\";\n    this.divRemTo(d, y, z);\n    while (y.signum() > 0)\n    {\n      r = (a + z.intValue()).toString(b).substr(1) + r;\n      y.divRemTo(d, y, z);\n    }\n    return z.intValue().toString(b) + r;\n  }\n  // (protected) convert from radix string\n  function bnpFromRadix(s, b)\n  {\n    this.fromInt(0);\n    if (b == null) b = 10;\n    var cs = this.chunkSize(b);\n    var d = Math.pow(b, cs),\n      mi = false,\n      j = 0,\n      w = 0;\n    for (var i = 0; i < s.length; ++i)\n    {\n      var x = intAt(s, i);\n      if (x < 0)\n      {\n        if (s.charAt(i) == \"-\" && this.signum() == 0) mi = true;\n        continue;\n      }\n      w = b * w + x;\n      if (++j >= cs)\n      {\n        this.dMultiply(d);\n        this.dAddOffset(w, 0);\n        j = 0;\n        w = 0;\n      }\n    }\n    if (j > 0)\n    {\n      this.dMultiply(Math.pow(b, j));\n      this.dAddOffset(w, 0);\n    }\n    if (mi) BigInteger.ZERO.subTo(this, this);\n  }\n  // (protected) alternate constructor\n  function bnpFromNumber(a, b, c)\n  {\n    if (\"number\" == typeof b)\n    {\n      // new BigInteger(int,int,RNG)\n      if (a < 2) this.fromInt(1);\n      else\n      {\n        this.fromNumber(a, c);\n        if (!this.testBit(a - 1)) // force MSB set\n          this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);\n        if (this.isEven()) this.dAddOffset(1, 0); // force odd\n        while (!this.isProbablePrime(b))\n        {\n          this.dAddOffset(2, 0);\n          if (this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);\n        }\n      }\n    }\n    else\n    {\n      // new BigInteger(int,RNG)\n      var x = new Array(),\n        t = a & 7;\n      x.length = (a >> 3) + 1;\n      b.nextBytes(x);\n      if (t > 0) x[0] &= ((1 << t) - 1);\n      else x[0] = 0;\n      this.fromString(x, 256);\n    }\n  }\n  // (public) convert to bigendian byte array\n  function bnToByteArray()\n  {\n    var i = this.t,\n      r = new Array();\n    r[0] = this.s;\n    var p = this.DB - (i * this.DB) % 8,\n      d, k = 0;\n    if (i-- > 0)\n    {\n      if (p < this.DB && (d = this[i] >> p) != (this.s & this.DM) >> p)\n        r[k++] = d | (this.s << (this.DB - p));\n      while (i >= 0)\n      {\n        if (p < 8)\n        {\n          d = (this[i] & ((1 << p) - 1)) << (8 - p);\n          d |= this[--i] >> (p += this.DB - 8);\n        }\n        else\n        {\n          d = (this[i] >> (p -= 8)) & 0xff;\n          if (p <= 0)\n          {\n            p += this.DB;\n            --i;\n          }\n        }\n        if ((d & 0x80) != 0) d |= -256;\n        if (k == 0 && (this.s & 0x80) != (d & 0x80))++k;\n        if (k > 0 || d != this.s) r[k++] = d;\n      }\n    }\n    return r;\n  }\n\n  function bnEquals(a)\n  {\n    return (this.compareTo(a) == 0);\n  }\n\n  function bnMin(a)\n  {\n    return (this.compareTo(a) < 0) ? this : a;\n  }\n\n  function bnMax(a)\n  {\n    return (this.compareTo(a) > 0) ? this : a;\n  }\n  // (protected) r = this op a (bitwise)\n  function bnpBitwiseTo(a, op, r)\n  {\n    var i, f, m = Math.min(a.t, this.t);\n    for (i = 0; i < m; ++i) r[i] = op(this[i], a[i]);\n    if (a.t < this.t)\n    {\n      f = a.s & this.DM;\n      for (i = m; i < this.t; ++i) r[i] = op(this[i], f);\n      r.t = this.t;\n    }\n    else\n    {\n      f = this.s & this.DM;\n      for (i = m; i < a.t; ++i) r[i] = op(f, a[i]);\n      r.t = a.t;\n    }\n    r.s = op(this.s, a.s);\n    r.clamp();\n  }\n  // (public) this & a\n  function op_and(x, y)\n  {\n    return x & y;\n  }\n\n  function bnAnd(a)\n  {\n    var r = nbi();\n    this.bitwiseTo(a, op_and, r);\n    return r;\n  }\n  // (public) this | a\n  function op_or(x, y)\n  {\n    return x | y;\n  }\n\n  function bnOr(a)\n  {\n    var r = nbi();\n    this.bitwiseTo(a, op_or, r);\n    return r;\n  }\n  // (public) this ^ a\n  function op_xor(x, y)\n  {\n    return x ^ y;\n  }\n\n  function bnXor(a)\n  {\n    var r = nbi();\n    this.bitwiseTo(a, op_xor, r);\n    return r;\n  }\n  // (public) this & ~a\n  function op_andnot(x, y)\n  {\n    return x & ~y;\n  }\n\n  function bnAndNot(a)\n  {\n    var r = nbi();\n    this.bitwiseTo(a, op_andnot, r);\n    return r;\n  }\n  // (public) ~this\n  function bnNot()\n  {\n    var r = nbi();\n    for (var i = 0; i < this.t; ++i) r[i] = this.DM & ~this[i];\n    r.t = this.t;\n    r.s = ~this.s;\n    return r;\n  }\n  // (public) this << n\n  function bnShiftLeft(n)\n  {\n    var r = nbi();\n    if (n < 0) this.rShiftTo(-n, r);\n    else this.lShiftTo(n, r);\n    return r;\n  }\n  // (public) this >> n\n  function bnShiftRight(n)\n  {\n    var r = nbi();\n    if (n < 0) this.lShiftTo(-n, r);\n    else this.rShiftTo(n, r);\n    return r;\n  }\n  // return index of lowest 1-bit in x, x < 2^31\n  function lbit(x)\n  {\n    if (x == 0) return -1;\n    var r = 0;\n    if ((x & 0xffff) == 0)\n    {\n      x >>= 16;\n      r += 16;\n    }\n    if ((x & 0xff) == 0)\n    {\n      x >>= 8;\n      r += 8;\n    }\n    if ((x & 0xf) == 0)\n    {\n      x >>= 4;\n      r += 4;\n    }\n    if ((x & 3) == 0)\n    {\n      x >>= 2;\n      r += 2;\n    }\n    if ((x & 1) == 0)++r;\n    return r;\n  }\n  // (public) returns index of lowest 1-bit (or -1 if none)\n  function bnGetLowestSetBit()\n  {\n    for (var i = 0; i < this.t; ++i)\n      if (this[i] != 0) return i * this.DB + lbit(this[i]);\n    if (this.s < 0) return this.t * this.DB;\n    return -1;\n  }\n  // return number of 1 bits in x\n  function cbit(x)\n  {\n    var r = 0;\n    while (x != 0)\n    {\n      x &= x - 1;\n      ++r;\n    }\n    return r;\n  }\n  // (public) return number of set bits\n  function bnBitCount()\n  {\n    var r = 0,\n      x = this.s & this.DM;\n    for (var i = 0; i < this.t; ++i) r += cbit(this[i] ^ x);\n    return r;\n  }\n  // (public) true iff nth bit is set\n  function bnTestBit(n)\n  {\n    var j = Math.floor(n / this.DB);\n    if (j >= this.t) return (this.s != 0);\n    return ((this[j] & (1 << (n % this.DB))) != 0);\n  }\n  // (protected) this op (1<<n)\n  function bnpChangeBit(n, op)\n  {\n    var r = BigInteger.ONE.shiftLeft(n);\n    this.bitwiseTo(r, op, r);\n    return r;\n  }\n  // (public) this | (1<<n)\n  function bnSetBit(n)\n  {\n    return this.changeBit(n, op_or);\n  }\n  // (public) this & ~(1<<n)\n  function bnClearBit(n)\n  {\n    return this.changeBit(n, op_andnot);\n  }\n  // (public) this ^ (1<<n)\n  function bnFlipBit(n)\n  {\n    return this.changeBit(n, op_xor);\n  }\n  // (protected) r = this + a\n  function bnpAddTo(a, r)\n  {\n    var i = 0,\n      c = 0,\n      m = Math.min(a.t, this.t);\n    while (i < m)\n    {\n      c += this[i] + a[i];\n      r[i++] = c & this.DM;\n      c >>= this.DB;\n    }\n    if (a.t < this.t)\n    {\n      c += a.s;\n      while (i < this.t)\n      {\n        c += this[i];\n        r[i++] = c & this.DM;\n        c >>= this.DB;\n      }\n      c += this.s;\n    }\n    else\n    {\n      c += this.s;\n      while (i < a.t)\n      {\n        c += a[i];\n        r[i++] = c & this.DM;\n        c >>= this.DB;\n      }\n      c += a.s;\n    }\n    r.s = (c < 0) ? -1 : 0;\n    if (c > 0) r[i++] = c;\n    else if (c < -1) r[i++] = this.DV + c;\n    r.t = i;\n    r.clamp();\n  }\n  // (public) this + a\n  function bnAdd(a)\n  {\n    var r = nbi();\n    this.addTo(a, r);\n    return r;\n  }\n  // (public) this - a\n  function bnSubtract(a)\n  {\n    var r = nbi();\n    this.subTo(a, r);\n    return r;\n  }\n  // (public) this * a\n  function bnMultiply(a)\n  {\n    var r = nbi();\n    this.multiplyTo(a, r);\n    return r;\n  }\n  // (public) this^2\n  function bnSquare()\n  {\n    var r = nbi();\n    this.squareTo(r);\n    return r;\n  }\n  // (public) this / a\n  function bnDivide(a)\n  {\n    var r = nbi();\n    this.divRemTo(a, r, null);\n    return r;\n  }\n  // (public) this % a\n  function bnRemainder(a)\n  {\n    var r = nbi();\n    this.divRemTo(a, null, r);\n    return r;\n  }\n  // (public) [this/a,this%a]\n  function bnDivideAndRemainder(a)\n  {\n    var q = nbi(),\n      r = nbi();\n    this.divRemTo(a, q, r);\n    return new Array(q, r);\n  }\n  // (protected) this *= n, this >= 0, 1 < n < DV\n  function bnpDMultiply(n)\n  {\n    this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);\n    ++this.t;\n    this.clamp();\n  }\n  // (protected) this += n << w words, this >= 0\n  function bnpDAddOffset(n, w)\n  {\n    if (n == 0) return;\n    while (this.t <= w) this[this.t++] = 0;\n    this[w] += n;\n    while (this[w] >= this.DV)\n    {\n      this[w] -= this.DV;\n      if (++w >= this.t) this[this.t++] = 0;\n      ++this[w];\n    }\n  }\n  // A \"null\" reducer\n  function NullExp()\n  {}\n\n  function nNop(x)\n  {\n    return x;\n  }\n\n  function nMulTo(x, y, r)\n  {\n    x.multiplyTo(y, r);\n  }\n\n  function nSqrTo(x, r)\n  {\n    x.squareTo(r);\n  }\n  NullExp.prototype.convert = nNop;\n  NullExp.prototype.revert = nNop;\n  NullExp.prototype.mulTo = nMulTo;\n  NullExp.prototype.sqrTo = nSqrTo;\n  // (public) this^e\n  function bnPow(e)\n  {\n    return this.exp(e, new NullExp());\n  }\n  // (protected) r = lower n words of \"this * a\", a.t <= n\n  // \"this\" should be the larger one if appropriate.\n  function bnpMultiplyLowerTo(a, n, r)\n  {\n    var i = Math.min(this.t + a.t, n);\n    r.s = 0; // assumes a,this >= 0\n    r.t = i;\n    while (i > 0) r[--i] = 0;\n    var j;\n    for (j = r.t - this.t; i < j; ++i) r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);\n    for (j = Math.min(a.t, n); i < j; ++i) this.am(0, a[i], r, i, 0, n - i);\n    r.clamp();\n  }\n  // (protected) r = \"this * a\" without lower n words, n > 0\n  // \"this\" should be the larger one if appropriate.\n  function bnpMultiplyUpperTo(a, n, r)\n  {\n    --n;\n    var i = r.t = this.t + a.t - n;\n    r.s = 0; // assumes a,this >= 0\n    while (--i >= 0) r[i] = 0;\n    for (i = Math.max(n - this.t, 0); i < a.t; ++i)\n      r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n);\n    r.clamp();\n    r.drShiftTo(1, r);\n  }\n  // Barrett modular reduction\n  function Barrett(m)\n  {\n    // setup Barrett\n    this.r2 = nbi();\n    this.q3 = nbi();\n    BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);\n    this.mu = this.r2.divide(m);\n    this.m = m;\n  }\n\n  function barrettConvert(x)\n  {\n    if (x.s < 0 || x.t > 2 * this.m.t) return x.mod(this.m);\n    else if (x.compareTo(this.m) < 0) return x;\n    else\n    {\n      var r = nbi();\n      x.copyTo(r);\n      this.reduce(r);\n      return r;\n    }\n  }\n\n  function barrettRevert(x)\n  {\n    return x;\n  }\n  // x = x mod m (HAC 14.42)\n  function barrettReduce(x)\n  {\n    x.drShiftTo(this.m.t - 1, this.r2);\n    if (x.t > this.m.t + 1)\n    {\n      x.t = this.m.t + 1;\n      x.clamp();\n    }\n    this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);\n    this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);\n    while (x.compareTo(this.r2) < 0) x.dAddOffset(1, this.m.t + 1);\n    x.subTo(this.r2, x);\n    while (x.compareTo(this.m) >= 0) x.subTo(this.m, x);\n  }\n  // r = x^2 mod m; x != r\n  function barrettSqrTo(x, r)\n  {\n    x.squareTo(r);\n    this.reduce(r);\n  }\n  // r = x*y mod m; x,y != r\n  function barrettMulTo(x, y, r)\n  {\n    x.multiplyTo(y, r);\n    this.reduce(r);\n  }\n  Barrett.prototype.convert = barrettConvert;\n  Barrett.prototype.revert = barrettRevert;\n  Barrett.prototype.reduce = barrettReduce;\n  Barrett.prototype.mulTo = barrettMulTo;\n  Barrett.prototype.sqrTo = barrettSqrTo;\n  // (public) this^e % m (HAC 14.85)\n  function bnModPow(e, m)\n  {\n    var i = e.bitLength(),\n      k, r = nbv(1),\n      z;\n    if (i <= 0) return r;\n    else if (i < 18) k = 1;\n    else if (i < 48) k = 3;\n    else if (i < 144) k = 4;\n    else if (i < 768) k = 5;\n    else k = 6;\n    if (i < 8)\n      z = new Classic(m);\n    else if (m.isEven())\n      z = new Barrett(m);\n    else\n      z = new Montgomery(m);\n    // precomputation\n    var g = new Array(),\n      n = 3,\n      k1 = k - 1,\n      km = (1 << k) - 1;\n    g[1] = z.convert(this);\n    if (k > 1)\n    {\n      var g2 = nbi();\n      z.sqrTo(g[1], g2);\n      while (n <= km)\n      {\n        g[n] = nbi();\n        z.mulTo(g2, g[n - 2], g[n]);\n        n += 2;\n      }\n    }\n    var j = e.t - 1,\n      w, is1 = true,\n      r2 = nbi(),\n      t;\n    i = nbits(e[j]) - 1;\n    while (j >= 0)\n    {\n      if (i >= k1) w = (e[j] >> (i - k1)) & km;\n      else\n      {\n        w = (e[j] & ((1 << (i + 1)) - 1)) << (k1 - i);\n        if (j > 0) w |= e[j - 1] >> (this.DB + i - k1);\n      }\n      n = k;\n      while ((w & 1) == 0)\n      {\n        w >>= 1;\n        --n;\n      }\n      if ((i -= n) < 0)\n      {\n        i += this.DB;\n        --j;\n      }\n      if (is1)\n      { // ret == 1, don't bother squaring or multiplying it\n        g[w].copyTo(r);\n        is1 = false;\n      }\n      else\n      {\n        while (n > 1)\n        {\n          z.sqrTo(r, r2);\n          z.sqrTo(r2, r);\n          n -= 2;\n        }\n        if (n > 0) z.sqrTo(r, r2);\n        else\n        {\n          t = r;\n          r = r2;\n          r2 = t;\n        }\n        z.mulTo(r2, g[w], r);\n      }\n      while (j >= 0 && (e[j] & (1 << i)) == 0)\n      {\n        z.sqrTo(r, r2);\n        t = r;\n        r = r2;\n        r2 = t;\n        if (--i < 0)\n        {\n          i = this.DB - 1;\n          --j;\n        }\n      }\n    }\n    return z.revert(r);\n  }\n  // (public) gcd(this,a) (HAC 14.54)\n  function bnGCD(a)\n  {\n    var x = (this.s < 0) ? this.negate() : this.clone();\n    var y = (a.s < 0) ? a.negate() : a.clone();\n    if (x.compareTo(y) < 0)\n    {\n      var t = x;\n      x = y;\n      y = t;\n    }\n    var i = x.getLowestSetBit(),\n      g = y.getLowestSetBit();\n    if (g < 0) return x;\n    if (i < g) g = i;\n    if (g > 0)\n    {\n      x.rShiftTo(g, x);\n      y.rShiftTo(g, y);\n    }\n    while (x.signum() > 0)\n    {\n      if ((i = x.getLowestSetBit()) > 0) x.rShiftTo(i, x);\n      if ((i = y.getLowestSetBit()) > 0) y.rShiftTo(i, y);\n      if (x.compareTo(y) >= 0)\n      {\n        x.subTo(y, x);\n        x.rShiftTo(1, x);\n      }\n      else\n      {\n        y.subTo(x, y);\n        y.rShiftTo(1, y);\n      }\n    }\n    if (g > 0) y.lShiftTo(g, y);\n    return y;\n  }\n  // (protected) this % n, n < 2^26\n  function bnpModInt(n)\n  {\n    if (n <= 0) return 0;\n    var d = this.DV % n,\n      r = (this.s < 0) ? n - 1 : 0;\n    if (this.t > 0)\n      if (d == 0) r = this[0] % n;\n      else\n        for (var i = this.t - 1; i >= 0; --i) r = (d * r + this[i]) % n;\n    return r;\n  }\n  // (public) 1/this % m (HAC 14.61)\n  function bnModInverse(m)\n  {\n    var ac = m.isEven();\n    if ((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO;\n    var u = m.clone(),\n      v = this.clone();\n    var a = nbv(1),\n      b = nbv(0),\n      c = nbv(0),\n      d = nbv(1);\n    while (u.signum() != 0)\n    {\n      while (u.isEven())\n      {\n        u.rShiftTo(1, u);\n        if (ac)\n        {\n          if (!a.isEven() || !b.isEven())\n          {\n            a.addTo(this, a);\n            b.subTo(m, b);\n          }\n          a.rShiftTo(1, a);\n        }\n        else if (!b.isEven()) b.subTo(m, b);\n        b.rShiftTo(1, b);\n      }\n      while (v.isEven())\n      {\n        v.rShiftTo(1, v);\n        if (ac)\n        {\n          if (!c.isEven() || !d.isEven())\n          {\n            c.addTo(this, c);\n            d.subTo(m, d);\n          }\n          c.rShiftTo(1, c);\n        }\n        else if (!d.isEven()) d.subTo(m, d);\n        d.rShiftTo(1, d);\n      }\n      if (u.compareTo(v) >= 0)\n      {\n        u.subTo(v, u);\n        if (ac) a.subTo(c, a);\n        b.subTo(d, b);\n      }\n      else\n      {\n        v.subTo(u, v);\n        if (ac) c.subTo(a, c);\n        d.subTo(b, d);\n      }\n    }\n    if (v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;\n    if (d.compareTo(m) >= 0) return d.subtract(m);\n    if (d.signum() < 0) d.addTo(m, d);\n    else return d;\n    if (d.signum() < 0) return d.add(m);\n    else return d;\n  }\n  var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];\n  var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];\n  // (public) test primality with certainty >= 1-.5^t\n  function bnIsProbablePrime(t)\n  {\n    var i, x = this.abs();\n    if (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1])\n    {\n      for (i = 0; i < lowprimes.length; ++i)\n        if (x[0] == lowprimes[i]) return true;\n      return false;\n    }\n    if (x.isEven()) return false;\n    i = 1;\n    while (i < lowprimes.length)\n    {\n      var m = lowprimes[i],\n        j = i + 1;\n      while (j < lowprimes.length && m < lplim) m *= lowprimes[j++];\n      m = x.modInt(m);\n      while (i < j)\n        if (m % lowprimes[i++] == 0) return false;\n    }\n    return x.millerRabin(t);\n  }\n  // (protected) true if probably prime (HAC 4.24, Miller-Rabin)\n  function bnpMillerRabin(t)\n  {\n    var n1 = this.subtract(BigInteger.ONE);\n    var k = n1.getLowestSetBit();\n    if (k <= 0) return false;\n    var r = n1.shiftRight(k);\n    t = (t + 1) >> 1;\n    if (t > lowprimes.length) t = lowprimes.length;\n    var a = nbi();\n    for (var i = 0; i < t; ++i)\n    {\n      //Pick bases at random, instead of starting at 2\n      a.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);\n      var y = a.modPow(r, this);\n      if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0)\n      {\n        var j = 1;\n        while (j++ < k && y.compareTo(n1) != 0)\n        {\n          y = y.modPowInt(2, this);\n          if (y.compareTo(BigInteger.ONE) == 0) return false;\n        }\n        if (y.compareTo(n1) != 0) return false;\n      }\n    }\n    return true;\n  }\n  // protected\n  BigInteger.prototype.chunkSize = bnpChunkSize;\n  BigInteger.prototype.toRadix = bnpToRadix;\n  BigInteger.prototype.fromRadix = bnpFromRadix;\n  BigInteger.prototype.fromNumber = bnpFromNumber;\n  BigInteger.prototype.bitwiseTo = bnpBitwiseTo;\n  BigInteger.prototype.changeBit = bnpChangeBit;\n  BigInteger.prototype.addTo = bnpAddTo;\n  BigInteger.prototype.dMultiply = bnpDMultiply;\n  BigInteger.prototype.dAddOffset = bnpDAddOffset;\n  BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;\n  BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;\n  BigInteger.prototype.modInt = bnpModInt;\n  BigInteger.prototype.millerRabin = bnpMillerRabin;\n  // public\n  BigInteger.prototype.clone = bnClone;\n  BigInteger.prototype.intValue = bnIntValue;\n  BigInteger.prototype.byteValue = bnByteValue;\n  BigInteger.prototype.shortValue = bnShortValue;\n  BigInteger.prototype.signum = bnSigNum;\n  BigInteger.prototype.toByteArray = bnToByteArray;\n  BigInteger.prototype.equals = bnEquals;\n  BigInteger.prototype.min = bnMin;\n  BigInteger.prototype.max = bnMax;\n  BigInteger.prototype.and = bnAnd;\n  BigInteger.prototype.or = bnOr;\n  BigInteger.prototype.xor = bnXor;\n  BigInteger.prototype.andNot = bnAndNot;\n  BigInteger.prototype.not = bnNot;\n  BigInteger.prototype.shiftLeft = bnShiftLeft;\n  BigInteger.prototype.shiftRight = bnShiftRight;\n  BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;\n  BigInteger.prototype.bitCount = bnBitCount;\n  BigInteger.prototype.testBit = bnTestBit;\n  BigInteger.prototype.setBit = bnSetBit;\n  BigInteger.prototype.clearBit = bnClearBit;\n  BigInteger.prototype.flipBit = bnFlipBit;\n  BigInteger.prototype.add = bnAdd;\n  BigInteger.prototype.subtract = bnSubtract;\n  BigInteger.prototype.multiply = bnMultiply;\n  BigInteger.prototype.divide = bnDivide;\n  BigInteger.prototype.remainder = bnRemainder;\n  BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;\n  BigInteger.prototype.modPow = bnModPow;\n  BigInteger.prototype.modInverse = bnModInverse;\n  BigInteger.prototype.pow = bnPow;\n  BigInteger.prototype.gcd = bnGCD;\n  BigInteger.prototype.isProbablePrime = bnIsProbablePrime;\n  // JSBN-specific extension\n  BigInteger.prototype.square = bnSquare;\n  var Int128 = BigInteger;\n  // BigInteger interfaces not implemented in jsbn:\n  // BigInteger(int signum, byte[] magnitude)\n  // double doubleValue()\n  // float floatValue()\n  // int hashCode()\n  // long longValue()\n  // static BigInteger valueOf(long val)\n  // Helper functions to make BigInteger functions callable with two parameters\n  // as in original C# Clipper\n  Int128.prototype.IsNegative = function ()\n  {\n    if (this.compareTo(Int128.ZERO) == -1) return true;\n    else return false;\n  };\n  Int128.op_Equality = function (val1, val2)\n  {\n    if (val1.compareTo(val2) == 0) return true;\n    else return false;\n  };\n  Int128.op_Inequality = function (val1, val2)\n  {\n    if (val1.compareTo(val2) != 0) return true;\n    else return false;\n  };\n  Int128.op_GreaterThan = function (val1, val2)\n  {\n    if (val1.compareTo(val2) > 0) return true;\n    else return false;\n  };\n  Int128.op_LessThan = function (val1, val2)\n  {\n    if (val1.compareTo(val2) < 0) return true;\n    else return false;\n  };\n  Int128.op_Addition = function (lhs, rhs)\n  {\n    return new Int128(lhs).add(new Int128(rhs));\n  };\n  Int128.op_Subtraction = function (lhs, rhs)\n  {\n    return new Int128(lhs).subtract(new Int128(rhs));\n  };\n  Int128.Int128Mul = function (lhs, rhs)\n  {\n    return new Int128(lhs).multiply(new Int128(rhs));\n  };\n  Int128.op_Division = function (lhs, rhs)\n  {\n    return lhs.divide(rhs);\n  };\n  Int128.prototype.ToDouble = function ()\n  {\n    return parseFloat(this.toString()); // This could be something faster\n  };\n  // end of Int128 section\n  /*\n  // Uncomment the following two lines if you want to use Int128 outside ClipperLib\n  if (typeof(document) !== \"undefined\") window.Int128 = Int128;\n  else self.Int128 = Int128;\n  */\n\n\n  // ---------------------------------------------\n  // Here starts the actual Clipper library:\n  // Helper function to support Inheritance in Javascript\n\tvar Inherit = function (ce, ce2)\n\t{\n\t\tvar p;\n\t\tif (typeof (Object.getOwnPropertyNames) == 'undefined')\n\t\t{\n\t\t\tfor (p in ce2.prototype)\n\t\t\t\tif (typeof (ce.prototype[p]) == 'undefined' || ce.prototype[p] == Object.prototype[p]) ce.prototype[p] = ce2.prototype[p];\n\t\t\tfor (p in ce2)\n\t\t\t\tif (typeof (ce[p]) == 'undefined') ce[p] = ce2[p];\n\t\t\tce.$baseCtor = ce2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar props = Object.getOwnPropertyNames(ce2.prototype);\n\t\t\tfor (var i = 0; i < props.length; i++)\n\t\t\t\tif (typeof (Object.getOwnPropertyDescriptor(ce.prototype, props[i])) == 'undefined') Object.defineProperty(ce.prototype, props[i], Object.getOwnPropertyDescriptor(ce2.prototype, props[i]));\n\t\t\tfor (p in ce2)\n\t\t\t\tif (typeof (ce[p]) == 'undefined') ce[p] = ce2[p];\n\t\t\tce.$baseCtor = ce2;\n\t\t}\n\t};\n  ClipperLib.Path = function ()\n  {\n    return [];\n  };\n  ClipperLib.Paths = function ()\n  {\n    return []; // Was previously [[]], but caused problems when pushed\n  };\n  // Preserves the calling way of original C# Clipper\n  // Is essential due to compatibility, because DoublePoint is public class in original C# version\n  ClipperLib.DoublePoint = function ()\n  {\n    var a = arguments;\n    this.X = 0;\n    this.Y = 0;\n    // public DoublePoint(DoublePoint dp)\n    // public DoublePoint(IntPoint ip)\n    if (a.length == 1)\n    {\n      this.X = a[0].X;\n      this.Y = a[0].Y;\n    }\n    else if (a.length == 2)\n    {\n      this.X = a[0];\n      this.Y = a[1];\n    }\n  }; // This is internal faster function when called without arguments\n  ClipperLib.DoublePoint0 = function ()\n  {\n    this.X = 0;\n    this.Y = 0;\n  };\n  // This is internal faster function when called with 1 argument (dp or ip)\n  ClipperLib.DoublePoint1 = function (dp)\n  {\n    this.X = dp.X;\n    this.Y = dp.Y;\n  };\n  // This is internal faster function when called with 2 arguments (x and y)\n  ClipperLib.DoublePoint2 = function (x, y)\n  {\n    this.X = x;\n    this.Y = y;\n  };\n  // PolyTree & PolyNode start\n  // -------------------------------\n  ClipperLib.PolyNode = function ()\n  {\n    this.m_Parent = null;\n    this.m_polygon = new ClipperLib.Path();\n    this.m_Index = 0;\n    this.m_jointype = 0;\n    this.m_endtype = 0;\n    this.m_Childs = [];\n    this.IsOpen = false;\n  };\n  ClipperLib.PolyNode.prototype.IsHoleNode = function ()\n  {\n    var result = true;\n    var node = this.m_Parent;\n    while (node !== null)\n    {\n      result = !result;\n      node = node.m_Parent;\n    }\n    return result;\n  };\n  ClipperLib.PolyNode.prototype.ChildCount = function ()\n  {\n    return this.m_Childs.length;\n  };\n  ClipperLib.PolyNode.prototype.Contour = function ()\n  {\n    return this.m_polygon;\n  };\n  ClipperLib.PolyNode.prototype.AddChild = function (Child)\n  {\n    var cnt = this.m_Childs.length;\n    this.m_Childs.push(Child);\n    Child.m_Parent = this;\n    Child.m_Index = cnt;\n  };\n  ClipperLib.PolyNode.prototype.GetNext = function ()\n  {\n    if (this.m_Childs.length > 0)\n      return this.m_Childs[0];\n    else\n      return this.GetNextSiblingUp();\n  };\n  ClipperLib.PolyNode.prototype.GetNextSiblingUp = function ()\n  {\n    if (this.m_Parent === null)\n      return null;\n    else if (this.m_Index == this.m_Parent.m_Childs.length - 1)\n      return this.m_Parent.GetNextSiblingUp();\n    else\n      return this.m_Parent.m_Childs[this.m_Index + 1];\n  };\n  ClipperLib.PolyNode.prototype.Childs = function ()\n  {\n    return this.m_Childs;\n  };\n  ClipperLib.PolyNode.prototype.Parent = function ()\n  {\n    return this.m_Parent;\n  };\n  ClipperLib.PolyNode.prototype.IsHole = function ()\n  {\n    return this.IsHoleNode();\n  };\n  // PolyTree : PolyNode\n  ClipperLib.PolyTree = function ()\n  {\n    this.m_AllPolys = [];\n    ClipperLib.PolyNode.call(this);\n  };\n  ClipperLib.PolyTree.prototype.Clear = function ()\n  {\n    for (var i = 0, ilen = this.m_AllPolys.length; i < ilen; i++)\n      this.m_AllPolys[i] = null;\n    this.m_AllPolys.length = 0;\n    this.m_Childs.length = 0;\n  };\n  ClipperLib.PolyTree.prototype.GetFirst = function ()\n  {\n    if (this.m_Childs.length > 0)\n      return this.m_Childs[0];\n    else\n      return null;\n  };\n  ClipperLib.PolyTree.prototype.Total = function ()\n  {\n\t\tvar result = this.m_AllPolys.length;\n\t\t//with negative offsets, ignore the hidden outer polygon ...\n\t\tif (result > 0 && this.m_Childs[0] != this.m_AllPolys[0]) result--;\n\t\treturn result;\n  };\n  Inherit(ClipperLib.PolyTree, ClipperLib.PolyNode);\n  // -------------------------------\n  // PolyTree & PolyNode end\n  ClipperLib.Math_Abs_Int64 = ClipperLib.Math_Abs_Int32 = ClipperLib.Math_Abs_Double = function (a)\n  {\n    return Math.abs(a);\n  };\n  ClipperLib.Math_Max_Int32_Int32 = function (a, b)\n  {\n    return Math.max(a, b);\n  };\n  /*\n  -----------------------------------\n  cast_32 speedtest: http://jsperf.com/truncate-float-to-integer/2\n  -----------------------------------\n  */\n  if (browser.msie || browser.opera || browser.safari) ClipperLib.Cast_Int32 = function (a)\n  {\n    return a | 0;\n  };\n  else ClipperLib.Cast_Int32 = function (a)\n  { // eg. browser.chrome || browser.chromium || browser.firefox\n    return~~ a;\n  };\n  /*\n  --------------------------\n  cast_64 speedtests: http://jsperf.com/truncate-float-to-integer\n  Chrome: bitwise_not_floor\n  Firefox17: toInteger (typeof test)\n  IE9: bitwise_or_floor\n  IE7 and IE8: to_parseint\n  Chromium: to_floor_or_ceil\n  Firefox3: to_floor_or_ceil\n  Firefox15: to_floor_or_ceil\n  Opera: to_floor_or_ceil\n  Safari: to_floor_or_ceil\n  --------------------------\n  */\n  if (browser.chrome) ClipperLib.Cast_Int64 = function (a)\n  {\n    if (a < -2147483648 || a > 2147483647)\n      return a < 0 ? Math.ceil(a) : Math.floor(a);\n    else return~~ a;\n  };\n  else if (browser.firefox && typeof (Number.toInteger) == \"function\") ClipperLib.Cast_Int64 = function (a)\n  {\n    return Number.toInteger(a);\n  };\n  else if (browser.msie7 || browser.msie8) ClipperLib.Cast_Int64 = function (a)\n  {\n    return parseInt(a, 10);\n  };\n  else if (browser.msie) ClipperLib.Cast_Int64 = function (a)\n  {\n    if (a < -2147483648 || a > 2147483647)\n      return a < 0 ? Math.ceil(a) : Math.floor(a);\n    return a | 0;\n  };\n  // eg. browser.chromium || browser.firefox || browser.opera || browser.safari\n  else ClipperLib.Cast_Int64 = function (a)\n  {\n    return a < 0 ? Math.ceil(a) : Math.floor(a);\n  };\n  ClipperLib.Clear = function (a)\n  {\n    a.length = 0;\n  };\n  //ClipperLib.MaxSteps = 64; // How many steps at maximum in arc in BuildArc() function\n  ClipperLib.PI = 3.141592653589793;\n  ClipperLib.PI2 = 2 * 3.141592653589793;\n  ClipperLib.IntPoint = function ()\n  {\n    var a = arguments,\n      alen = a.length;\n    this.X = 0;\n    this.Y = 0;\n    if (use_xyz)\n    {\n      this.Z = 0;\n      if (alen == 3) // public IntPoint(cInt x, cInt y, cInt z = 0)\n      {\n        this.X = a[0];\n        this.Y = a[1];\n        this.Z = a[2];\n      }\n      else if (alen == 2) // public IntPoint(cInt x, cInt y)\n      {\n        this.X = a[0];\n        this.Y = a[1];\n        this.Z = 0;\n      }\n      else if (alen == 1)\n      {\n        if (a[0] instanceof ClipperLib.DoublePoint) // public IntPoint(DoublePoint dp)\n        {\n          var dp = a[0];\n          this.X = ClipperLib.Clipper.Round(dp.X);\n          this.Y = ClipperLib.Clipper.Round(dp.Y);\n          this.Z = 0;\n        }\n        else // public IntPoint(IntPoint pt)\n        {\n          var pt = a[0];\n          if (typeof (pt.Z) == \"undefined\") pt.Z = 0;\n          this.X = pt.X;\n          this.Y = pt.Y;\n          this.Z = pt.Z;\n        }\n      }\n      else // public IntPoint()\n      {\n        this.X = 0;\n        this.Y = 0;\n        this.Z = 0;\n      }\n    }\n    else // if (!use_xyz)\n    {\n      if (alen == 2) // public IntPoint(cInt X, cInt Y)\n      {\n        this.X = a[0];\n        this.Y = a[1];\n      }\n      else if (alen == 1)\n      {\n        if (a[0] instanceof ClipperLib.DoublePoint) // public IntPoint(DoublePoint dp)\n        {\n          var dp = a[0];\n          this.X = ClipperLib.Clipper.Round(dp.X);\n          this.Y = ClipperLib.Clipper.Round(dp.Y);\n        }\n        else // public IntPoint(IntPoint pt)\n        {\n          var pt = a[0];\n          this.X = pt.X;\n          this.Y = pt.Y;\n        }\n      }\n      else // public IntPoint(IntPoint pt)\n      {\n        this.X = 0;\n        this.Y = 0;\n      }\n    }\n  };\n  ClipperLib.IntPoint.op_Equality = function (a, b)\n  {\n    //return a == b;\n    return a.X == b.X && a.Y == b.Y;\n  };\n  ClipperLib.IntPoint.op_Inequality = function (a, b)\n  {\n    //return a != b;\n    return a.X != b.X || a.Y != b.Y;\n  };\n  /*\n  ClipperLib.IntPoint.prototype.Equals = function (obj)\n  {\n    if (obj === null)\n        return false;\n    if (obj instanceof ClipperLib.IntPoint)\n    {\n        var a = Cast(obj, ClipperLib.IntPoint);\n        return (this.X == a.X) && (this.Y == a.Y);\n    }\n    else\n        return false;\n  };\n*/\n  if (use_xyz)\n  {\n    ClipperLib.IntPoint0 = function ()\n    {\n      this.X = 0;\n      this.Y = 0;\n      this.Z = 0;\n    };\n    ClipperLib.IntPoint1 = function (pt)\n    {\n      this.X = pt.X;\n      this.Y = pt.Y;\n      this.Z = pt.Z;\n    };\n    ClipperLib.IntPoint1dp = function (dp)\n    {\n      this.X = ClipperLib.Clipper.Round(dp.X);\n      this.Y = ClipperLib.Clipper.Round(dp.Y);\n      this.Z = 0;\n    };\n    ClipperLib.IntPoint2 = function (x, y)\n    {\n      this.X = x;\n      this.Y = y;\n      this.Z = 0;\n    };\n    ClipperLib.IntPoint3 = function (x, y, z)\n    {\n      this.X = x;\n      this.Y = y;\n      this.Z = z;\n    };\n  }\n  else // if (!use_xyz)\n  {\n    ClipperLib.IntPoint0 = function ()\n    {\n      this.X = 0;\n      this.Y = 0;\n    };\n    ClipperLib.IntPoint1 = function (pt)\n    {\n      this.X = pt.X;\n      this.Y = pt.Y;\n    };\n    ClipperLib.IntPoint1dp = function (dp)\n    {\n      this.X = ClipperLib.Clipper.Round(dp.X);\n      this.Y = ClipperLib.Clipper.Round(dp.Y);\n    };\n    ClipperLib.IntPoint2 = function (x, y)\n    {\n      this.X = x;\n      this.Y = y;\n    };\n  }\n  ClipperLib.IntRect = function ()\n  {\n    var a = arguments,\n      alen = a.length;\n    if (alen == 4) // function (l, t, r, b)\n    {\n      this.left = a[0];\n      this.top = a[1];\n      this.right = a[2];\n      this.bottom = a[3];\n    }\n    else if (alen == 1) // function (ir)\n    {\n      this.left = ir.left;\n      this.top = ir.top;\n      this.right = ir.right;\n      this.bottom = ir.bottom;\n    }\n    else // function ()\n    {\n      this.left = 0;\n      this.top = 0;\n      this.right = 0;\n      this.bottom = 0;\n    }\n  };\n  ClipperLib.IntRect0 = function ()\n  {\n    this.left = 0;\n    this.top = 0;\n    this.right = 0;\n    this.bottom = 0;\n  };\n  ClipperLib.IntRect1 = function (ir)\n  {\n    this.left = ir.left;\n    this.top = ir.top;\n    this.right = ir.right;\n    this.bottom = ir.bottom;\n  };\n  ClipperLib.IntRect4 = function (l, t, r, b)\n  {\n    this.left = l;\n    this.top = t;\n    this.right = r;\n    this.bottom = b;\n  };\n  ClipperLib.ClipType = {\n    ctIntersection: 0,\n    ctUnion: 1,\n    ctDifference: 2,\n    ctXor: 3\n  };\n  ClipperLib.PolyType = {\n    ptSubject: 0,\n    ptClip: 1\n  };\n  ClipperLib.PolyFillType = {\n    pftEvenOdd: 0,\n    pftNonZero: 1,\n    pftPositive: 2,\n    pftNegative: 3\n  };\n  ClipperLib.JoinType = {\n    jtSquare: 0,\n    jtRound: 1,\n    jtMiter: 2\n  };\n  ClipperLib.EndType = {\n    etOpenSquare: 0,\n    etOpenRound: 1,\n    etOpenButt: 2,\n    etClosedLine: 3,\n    etClosedPolygon: 4\n  };\n  ClipperLib.EdgeSide = {\n    esLeft: 0,\n    esRight: 1\n  };\n  ClipperLib.Direction = {\n    dRightToLeft: 0,\n    dLeftToRight: 1\n  };\n  ClipperLib.TEdge = function ()\n  {\n    this.Bot = new ClipperLib.IntPoint();\n    this.Curr = new ClipperLib.IntPoint();\n    this.Top = new ClipperLib.IntPoint();\n    this.Delta = new ClipperLib.IntPoint();\n    this.Dx = 0;\n    this.PolyTyp = ClipperLib.PolyType.ptSubject;\n    this.Side = ClipperLib.EdgeSide.esLeft;\n    this.WindDelta = 0;\n    this.WindCnt = 0;\n    this.WindCnt2 = 0;\n    this.OutIdx = 0;\n    this.Next = null;\n    this.Prev = null;\n    this.NextInLML = null;\n    this.NextInAEL = null;\n    this.PrevInAEL = null;\n    this.NextInSEL = null;\n    this.PrevInSEL = null;\n  };\n  ClipperLib.IntersectNode = function ()\n  {\n    this.Edge1 = null;\n    this.Edge2 = null;\n    this.Pt = new ClipperLib.IntPoint();\n  };\n  ClipperLib.MyIntersectNodeSort = function () {};\n  ClipperLib.MyIntersectNodeSort.Compare = function (node1, node2)\n  {\n    var i = node2.Pt.Y - node1.Pt.Y;\n    if (i > 0) return 1;\n    else if (i < 0) return -1;\n    else return 0;\n  };\n\n  ClipperLib.LocalMinima = function ()\n  {\n    this.Y = 0;\n    this.LeftBound = null;\n    this.RightBound = null;\n    this.Next = null;\n  };\n  ClipperLib.Scanbeam = function ()\n  {\n    this.Y = 0;\n    this.Next = null;\n  };\n  ClipperLib.OutRec = function ()\n  {\n    this.Idx = 0;\n    this.IsHole = false;\n    this.IsOpen = false;\n    this.FirstLeft = null;\n    this.Pts = null;\n    this.BottomPt = null;\n    this.PolyNode = null;\n  };\n  ClipperLib.OutPt = function ()\n  {\n    this.Idx = 0;\n    this.Pt = new ClipperLib.IntPoint();\n    this.Next = null;\n    this.Prev = null;\n  };\n  ClipperLib.Join = function ()\n  {\n    this.OutPt1 = null;\n    this.OutPt2 = null;\n    this.OffPt = new ClipperLib.IntPoint();\n  };\n  ClipperLib.ClipperBase = function ()\n  {\n    this.m_MinimaList = null;\n    this.m_CurrentLM = null;\n    this.m_edges = new Array();\n    this.m_UseFullRange = false;\n    this.m_HasOpenPaths = false;\n    this.PreserveCollinear = false;\n    this.m_MinimaList = null;\n    this.m_CurrentLM = null;\n    this.m_UseFullRange = false;\n    this.m_HasOpenPaths = false;\n  };\n  // Ranges are in original C# too high for Javascript (in current state 2013 september):\n  // protected const double horizontal = -3.4E+38;\n  // internal const cInt loRange = 0x3FFFFFFF; // = 1073741823 = sqrt(2^63 -1)/2\n  // internal const cInt hiRange = 0x3FFFFFFFFFFFFFFFL; // = 4611686018427387903 = sqrt(2^127 -1)/2\n  // So had to adjust them to more suitable for Javascript.\n  // If JS some day supports truly 64-bit integers, then these ranges can be as in C#\n  // and biginteger library can be more simpler (as then 128bit can be represented as two 64bit numbers)\n  ClipperLib.ClipperBase.horizontal = -9007199254740992; //-2^53\n  ClipperLib.ClipperBase.Skip = -2;\n  ClipperLib.ClipperBase.Unassigned = -1;\n  ClipperLib.ClipperBase.tolerance = 1E-20;\n  if (use_int32)\n  {\n    ClipperLib.ClipperBase.loRange = 0x7FFF;\n    ClipperLib.ClipperBase.hiRange = 0x7FFF;\n  }\n  else\n  {\n    ClipperLib.ClipperBase.loRange = 47453132; // sqrt(2^53 -1)/2\n    ClipperLib.ClipperBase.hiRange = 4503599627370495; // sqrt(2^106 -1)/2\n  }\n\n  ClipperLib.ClipperBase.near_zero = function (val)\n  {\n    return (val > -ClipperLib.ClipperBase.tolerance) && (val < ClipperLib.ClipperBase.tolerance);\n  };\n  ClipperLib.ClipperBase.IsHorizontal = function (e)\n  {\n    return e.Delta.Y === 0;\n  };\n  ClipperLib.ClipperBase.prototype.PointIsVertex = function (pt, pp)\n  {\n    var pp2 = pp;\n    do {\n      if (ClipperLib.IntPoint.op_Equality(pp2.Pt, pt))\n        return true;\n      pp2 = pp2.Next;\n    }\n    while (pp2 != pp)\n    return false;\n  };\n  ClipperLib.ClipperBase.prototype.PointOnLineSegment = function (pt, linePt1, linePt2, UseFullRange)\n  {\n    if (UseFullRange)\n      return ((pt.X == linePt1.X) && (pt.Y == linePt1.Y)) ||\n        ((pt.X == linePt2.X) && (pt.Y == linePt2.Y)) ||\n        (((pt.X > linePt1.X) == (pt.X < linePt2.X)) &&\n        ((pt.Y > linePt1.Y) == (pt.Y < linePt2.Y)) &&\n        (Int128.op_Equality(Int128.Int128Mul((pt.X - linePt1.X), (linePt2.Y - linePt1.Y)),\n          Int128.Int128Mul((linePt2.X - linePt1.X), (pt.Y - linePt1.Y)))));\n    else\n      return ((pt.X == linePt1.X) && (pt.Y == linePt1.Y)) || ((pt.X == linePt2.X) && (pt.Y == linePt2.Y)) || (((pt.X > linePt1.X) == (pt.X < linePt2.X)) && ((pt.Y > linePt1.Y) == (pt.Y < linePt2.Y)) && ((pt.X - linePt1.X) * (linePt2.Y - linePt1.Y) == (linePt2.X - linePt1.X) * (pt.Y - linePt1.Y)));\n  };\n  ClipperLib.ClipperBase.prototype.PointOnPolygon = function (pt, pp, UseFullRange)\n  {\n    var pp2 = pp;\n    while (true)\n    {\n      if (this.PointOnLineSegment(pt, pp2.Pt, pp2.Next.Pt, UseFullRange))\n        return true;\n      pp2 = pp2.Next;\n      if (pp2 == pp)\n        break;\n    }\n    return false;\n  };\n  ClipperLib.ClipperBase.prototype.SlopesEqual = ClipperLib.ClipperBase.SlopesEqual = function ()\n  {\n    var a = arguments,\n      alen = a.length;\n    var e1, e2, pt1, pt2, pt3, pt4, UseFullRange;\n    if (alen == 3) // function (e1, e2, UseFullRange)\n    {\n      e1 = a[0];\n      e2 = a[1];\n      UseFullRange = a[2];\n      if (UseFullRange)\n        return Int128.op_Equality(Int128.Int128Mul(e1.Delta.Y, e2.Delta.X), Int128.Int128Mul(e1.Delta.X, e2.Delta.Y));\n      else\n        return ClipperLib.Cast_Int64((e1.Delta.Y) * (e2.Delta.X)) == ClipperLib.Cast_Int64((e1.Delta.X) * (e2.Delta.Y));\n    }\n    else if (alen == 4) // function (pt1, pt2, pt3, UseFullRange)\n    {\n      pt1 = a[0];\n      pt2 = a[1];\n      pt3 = a[2];\n      UseFullRange = a[3];\n      if (UseFullRange)\n        return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt2.X - pt3.X), Int128.Int128Mul(pt1.X - pt2.X, pt2.Y - pt3.Y));\n      else\n        return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt2.X - pt3.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt2.Y - pt3.Y)) === 0;\n    }\n    else // function (pt1, pt2, pt3, pt4, UseFullRange)\n    {\n      pt1 = a[0];\n      pt2 = a[1];\n      pt3 = a[2];\n      pt4 = a[3];\n      UseFullRange = a[4];\n      if (UseFullRange)\n        return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt3.X - pt4.X), Int128.Int128Mul(pt1.X - pt2.X, pt3.Y - pt4.Y));\n      else\n        return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt3.X - pt4.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt3.Y - pt4.Y)) === 0;\n    }\n  };\n  ClipperLib.ClipperBase.SlopesEqual3 = function (e1, e2, UseFullRange)\n  {\n    if (UseFullRange)\n      return Int128.op_Equality(Int128.Int128Mul(e1.Delta.Y, e2.Delta.X), Int128.Int128Mul(e1.Delta.X, e2.Delta.Y));\n    else\n      return ClipperLib.Cast_Int64((e1.Delta.Y) * (e2.Delta.X)) == ClipperLib.Cast_Int64((e1.Delta.X) * (e2.Delta.Y));\n  };\n  ClipperLib.ClipperBase.SlopesEqual4 = function (pt1, pt2, pt3, UseFullRange)\n  {\n    if (UseFullRange)\n      return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt2.X - pt3.X), Int128.Int128Mul(pt1.X - pt2.X, pt2.Y - pt3.Y));\n    else\n      return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt2.X - pt3.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt2.Y - pt3.Y)) === 0;\n  };\n  ClipperLib.ClipperBase.SlopesEqual5 = function (pt1, pt2, pt3, pt4, UseFullRange)\n  {\n    if (UseFullRange)\n      return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt3.X - pt4.X), Int128.Int128Mul(pt1.X - pt2.X, pt3.Y - pt4.Y));\n    else\n      return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt3.X - pt4.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt3.Y - pt4.Y)) === 0;\n  };\n  ClipperLib.ClipperBase.prototype.Clear = function ()\n  {\n    this.DisposeLocalMinimaList();\n    for (var i = 0, ilen = this.m_edges.length; i < ilen; ++i)\n    {\n      for (var j = 0, jlen = this.m_edges[i].length; j < jlen; ++j)\n        this.m_edges[i][j] = null;\n      ClipperLib.Clear(this.m_edges[i]);\n    }\n    ClipperLib.Clear(this.m_edges);\n    this.m_UseFullRange = false;\n    this.m_HasOpenPaths = false;\n  };\n  ClipperLib.ClipperBase.prototype.DisposeLocalMinimaList = function ()\n  {\n    while (this.m_MinimaList !== null)\n    {\n      var tmpLm = this.m_MinimaList.Next;\n      this.m_MinimaList = null;\n      this.m_MinimaList = tmpLm;\n    }\n    this.m_CurrentLM = null;\n  };\n  ClipperLib.ClipperBase.prototype.RangeTest = function (Pt, useFullRange)\n  {\n    if (useFullRange.Value)\n    {\n      if (Pt.X > ClipperLib.ClipperBase.hiRange || Pt.Y > ClipperLib.ClipperBase.hiRange || -Pt.X > ClipperLib.ClipperBase.hiRange || -Pt.Y > ClipperLib.ClipperBase.hiRange)\n        ClipperLib.Error(\"Coordinate outside allowed range in RangeTest().\");\n    }\n    else if (Pt.X > ClipperLib.ClipperBase.loRange || Pt.Y > ClipperLib.ClipperBase.loRange || -Pt.X > ClipperLib.ClipperBase.loRange || -Pt.Y > ClipperLib.ClipperBase.loRange)\n    {\n      useFullRange.Value = true;\n      this.RangeTest(Pt, useFullRange);\n    }\n  };\n  ClipperLib.ClipperBase.prototype.InitEdge = function (e, eNext, ePrev, pt)\n  {\n    e.Next = eNext;\n    e.Prev = ePrev;\n    //e.Curr = pt;\n    e.Curr.X = pt.X;\n    e.Curr.Y = pt.Y;\n    e.OutIdx = -1;\n  };\n  ClipperLib.ClipperBase.prototype.InitEdge2 = function (e, polyType)\n  {\n    if (e.Curr.Y >= e.Next.Curr.Y)\n    {\n      //e.Bot = e.Curr;\n      e.Bot.X = e.Curr.X;\n      e.Bot.Y = e.Curr.Y;\n      //e.Top = e.Next.Curr;\n      e.Top.X = e.Next.Curr.X;\n      e.Top.Y = e.Next.Curr.Y;\n    }\n    else\n    {\n      //e.Top = e.Curr;\n      e.Top.X = e.Curr.X;\n      e.Top.Y = e.Curr.Y;\n      //e.Bot = e.Next.Curr;\n      e.Bot.X = e.Next.Curr.X;\n      e.Bot.Y = e.Next.Curr.Y;\n    }\n    this.SetDx(e);\n    e.PolyTyp = polyType;\n  };\n  ClipperLib.ClipperBase.prototype.FindNextLocMin = function (E)\n  {\n    var E2;\n    for (;;)\n    {\n      while (ClipperLib.IntPoint.op_Inequality(E.Bot, E.Prev.Bot) || ClipperLib.IntPoint.op_Equality(E.Curr, E.Top))\n        E = E.Next;\n      if (E.Dx != ClipperLib.ClipperBase.horizontal && E.Prev.Dx != ClipperLib.ClipperBase.horizontal)\n        break;\n      while (E.Prev.Dx == ClipperLib.ClipperBase.horizontal)\n        E = E.Prev;\n      E2 = E;\n      while (E.Dx == ClipperLib.ClipperBase.horizontal)\n        E = E.Next;\n      if (E.Top.Y == E.Prev.Bot.Y)\n        continue;\n      //ie just an intermediate horz.\n      if (E2.Prev.Bot.X < E.Bot.X)\n        E = E2;\n      break;\n    }\n    return E;\n  };\n  ClipperLib.ClipperBase.prototype.ProcessBound = function (E, LeftBoundIsForward)\n  {\n    var EStart;\n    var Result = E;\n    var Horz;\n\n      if (Result.OutIdx == ClipperLib.ClipperBase.Skip)\n      {\n        //check if there are edges beyond the skip edge in the bound and if so\n        //create another LocMin and calling ProcessBound once more ...\n        E = Result;\n        if (LeftBoundIsForward)\n        {\n          while (E.Top.Y == E.Next.Bot.Y) E = E.Next;\n          while (E != Result && E.Dx == ClipperLib.ClipperBase.horizontal) E = E.Prev;\n        }\n        else\n        {\n          while (E.Top.Y == E.Prev.Bot.Y) E = E.Prev;\n          while (E != Result && E.Dx == ClipperLib.ClipperBase.horizontal) E = E.Next;\n        }\n        if (E == Result)\n        {\n          if (LeftBoundIsForward) Result = E.Next;\n          else Result = E.Prev;\n        }\n        else\n        {\n          //there are more edges in the bound beyond result starting with E\n          if (LeftBoundIsForward)\n            E = Result.Next;\n          else\n            E = Result.Prev;\n          var locMin = new ClipperLib.LocalMinima();\n          locMin.Next = null;\n          locMin.Y = E.Bot.Y;\n          locMin.LeftBound = null;\n          locMin.RightBound = E;\n          E.WindDelta = 0;\n          Result = this.ProcessBound(E, LeftBoundIsForward);\n          this.InsertLocalMinima(locMin);\n        }\n        return Result;\n      }\n\n      if (E.Dx == ClipperLib.ClipperBase.horizontal)\n      {\n        //We need to be careful with open paths because this may not be a\n        //true local minima (ie E may be following a skip edge).\n        //Also, consecutive horz. edges may start heading left before going right.\n        if (LeftBoundIsForward) EStart = E.Prev;\n        else EStart = E.Next;\n        if (EStart.OutIdx != ClipperLib.ClipperBase.Skip)\n        {\n          if (EStart.Dx == ClipperLib.ClipperBase.horizontal) //ie an adjoining horizontal skip edge\n          {\n            if (EStart.Bot.X != E.Bot.X && EStart.Top.X != E.Bot.X)\n              this.ReverseHorizontal(E);\n          }\n          else if (EStart.Bot.X != E.Bot.X)\n            this.ReverseHorizontal(E);\n        }\n      }\n\n      EStart = E;\n      if (LeftBoundIsForward)\n      {\n        while (Result.Top.Y == Result.Next.Bot.Y && Result.Next.OutIdx != ClipperLib.ClipperBase.Skip)\n          Result = Result.Next;\n        if (Result.Dx == ClipperLib.ClipperBase.horizontal && Result.Next.OutIdx != ClipperLib.ClipperBase.Skip)\n        {\n          //nb: at the top of a bound, horizontals are added to the bound\n          //only when the preceding edge attaches to the horizontal's left vertex\n          //unless a Skip edge is encountered when that becomes the top divide\n          Horz = Result;\n          while (Horz.Prev.Dx == ClipperLib.ClipperBase.horizontal)\n            Horz = Horz.Prev;\n          if (Horz.Prev.Top.X == Result.Next.Top.X)\n          {\n            if (!LeftBoundIsForward)\n              Result = Horz.Prev;\n          }\n          else if (Horz.Prev.Top.X > Result.Next.Top.X)\n            Result = Horz.Prev;\n        }\n        while (E != Result)\n        {\n          E.NextInLML = E.Next;\n          if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Prev.Top.X)\n            this.ReverseHorizontal(E);\n          E = E.Next;\n        }\n        if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Prev.Top.X)\n          this.ReverseHorizontal(E);\n        Result = Result.Next;\n        //move to the edge just beyond current bound\n      }\n      else\n      {\n        while (Result.Top.Y == Result.Prev.Bot.Y && Result.Prev.OutIdx != ClipperLib.ClipperBase.Skip)\n          Result = Result.Prev;\n        if (Result.Dx == ClipperLib.ClipperBase.horizontal && Result.Prev.OutIdx != ClipperLib.ClipperBase.Skip)\n        {\n          Horz = Result;\n          while (Horz.Next.Dx == ClipperLib.ClipperBase.horizontal)\n            Horz = Horz.Next;\n          if (Horz.Next.Top.X == Result.Prev.Top.X)\n          {\n            if (!LeftBoundIsForward)\n              Result = Horz.Next;\n          }\n          else if (Horz.Next.Top.X > Result.Prev.Top.X)\n            Result = Horz.Next;\n        }\n        while (E != Result)\n        {\n          E.NextInLML = E.Prev;\n          if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Next.Top.X)\n            this.ReverseHorizontal(E);\n          E = E.Prev;\n        }\n        if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Next.Top.X)\n          this.ReverseHorizontal(E);\n        Result = Result.Prev;\n        //move to the edge just beyond current bound\n      }\n\n    return Result;\n  };\n\n  ClipperLib.ClipperBase.prototype.AddPath = function (pg, polyType, Closed)\n  {\n    if (use_lines)\n    {\n      if (!Closed && polyType == ClipperLib.PolyType.ptClip)\n        ClipperLib.Error(\"AddPath: Open paths must be subject.\");\n    }\n    else\n    {\n      if (!Closed)\n        ClipperLib.Error(\"AddPath: Open paths have been disabled.\");\n    }\n    var highI = pg.length - 1;\n    if (Closed)\n      while (highI > 0 && (ClipperLib.IntPoint.op_Equality(pg[highI], pg[0])))\n    --highI;\n    while (highI > 0 && (ClipperLib.IntPoint.op_Equality(pg[highI], pg[highI - 1])))\n    --highI;\n    if ((Closed && highI < 2) || (!Closed && highI < 1))\n      return false;\n    //create a new edge array ...\n    var edges = new Array();\n    for (var i = 0; i <= highI; i++)\n      edges.push(new ClipperLib.TEdge());\n    var IsFlat = true;\n    //1. Basic (first) edge initialization ...\n\n    //edges[1].Curr = pg[1];\n    edges[1].Curr.X = pg[1].X;\n    edges[1].Curr.Y = pg[1].Y;\n\n    var $1 = {Value: this.m_UseFullRange};\n    this.RangeTest(pg[0], $1);\n    this.m_UseFullRange = $1.Value;\n\n    $1.Value = this.m_UseFullRange;\n    this.RangeTest(pg[highI], $1);\n    this.m_UseFullRange = $1.Value;\n\n    this.InitEdge(edges[0], edges[1], edges[highI], pg[0]);\n    this.InitEdge(edges[highI], edges[0], edges[highI - 1], pg[highI]);\n    for (var i = highI - 1; i >= 1; --i)\n    {\n      $1.Value = this.m_UseFullRange;\n      this.RangeTest(pg[i], $1);\n      this.m_UseFullRange = $1.Value;\n\n      this.InitEdge(edges[i], edges[i + 1], edges[i - 1], pg[i]);\n    }\n\n    var eStart = edges[0];\n    //2. Remove duplicate vertices, and (when closed) collinear edges ...\n    var E = eStart,\n      eLoopStop = eStart;\n    for (;;)\n    {\n    //console.log(E.Next, eStart);\n    \t//nb: allows matching start and end points when not Closed ...\n      if (E.Curr == E.Next.Curr && (Closed || E.Next != eStart))\n      {\n        if (E == E.Next)\n          break;\n        if (E == eStart)\n          eStart = E.Next;\n        E = this.RemoveEdge(E);\n        eLoopStop = E;\n        continue;\n      }\n      if (E.Prev == E.Next)\n        break;\n      else if (Closed && ClipperLib.ClipperBase.SlopesEqual(E.Prev.Curr, E.Curr, E.Next.Curr, this.m_UseFullRange) && (!this.PreserveCollinear || !this.Pt2IsBetweenPt1AndPt3(E.Prev.Curr, E.Curr, E.Next.Curr)))\n      {\n        //Collinear edges are allowed for open paths but in closed paths\n        //the default is to merge adjacent collinear edges into a single edge.\n        //However, if the PreserveCollinear property is enabled, only overlapping\n        //collinear edges (ie spikes) will be removed from closed paths.\n        if (E == eStart)\n          eStart = E.Next;\n        E = this.RemoveEdge(E);\n        E = E.Prev;\n        eLoopStop = E;\n        continue;\n      }\n      E = E.Next;\n      if ((E == eLoopStop) || (!Closed && E.Next == eStart)) break;\n    }\n    if ((!Closed && (E == E.Next)) || (Closed && (E.Prev == E.Next)))\n      return false;\n    if (!Closed)\n    {\n      this.m_HasOpenPaths = true;\n      eStart.Prev.OutIdx = ClipperLib.ClipperBase.Skip;\n    }\n    //3. Do second stage of edge initialization ...\n    E = eStart;\n    do {\n      this.InitEdge2(E, polyType);\n      E = E.Next;\n      if (IsFlat && E.Curr.Y != eStart.Curr.Y)\n        IsFlat = false;\n    }\n    while (E != eStart)\n    //4. Finally, add edge bounds to LocalMinima list ...\n    //Totally flat paths must be handled differently when adding them\n    //to LocalMinima list to avoid endless loops etc ...\n    if (IsFlat)\n    {\n      if (Closed)\n        return false;\n      E.Prev.OutIdx = ClipperLib.ClipperBase.Skip;\n      if (E.Prev.Bot.X < E.Prev.Top.X)\n        this.ReverseHorizontal(E.Prev);\n      var locMin = new ClipperLib.LocalMinima();\n      locMin.Next = null;\n      locMin.Y = E.Bot.Y;\n      locMin.LeftBound = null;\n      locMin.RightBound = E;\n      locMin.RightBound.Side = ClipperLib.EdgeSide.esRight;\n      locMin.RightBound.WindDelta = 0;\n      while (E.Next.OutIdx != ClipperLib.ClipperBase.Skip)\n      {\n        E.NextInLML = E.Next;\n        if (E.Bot.X != E.Prev.Top.X)\n          this.ReverseHorizontal(E);\n        E = E.Next;\n      }\n      this.InsertLocalMinima(locMin);\n      this.m_edges.push(edges);\n      return true;\n    }\n    this.m_edges.push(edges);\n    var leftBoundIsForward;\n    var EMin = null;\n\n\t\t//workaround to avoid an endless loop in the while loop below when\n    //open paths have matching start and end points ...\n    if(ClipperLib.IntPoint.op_Equality(E.Prev.Bot, E.Prev.Top))\n    \tE = E.Next;\n\n    for (;;)\n    {\n      E = this.FindNextLocMin(E);\n      if (E == EMin)\n        break;\n      else if (EMin == null)\n        EMin = E;\n      //E and E.Prev now share a local minima (left aligned if horizontal).\n      //Compare their slopes to find which starts which bound ...\n      var locMin = new ClipperLib.LocalMinima();\n      locMin.Next = null;\n      locMin.Y = E.Bot.Y;\n      if (E.Dx < E.Prev.Dx)\n      {\n        locMin.LeftBound = E.Prev;\n        locMin.RightBound = E;\n        leftBoundIsForward = false;\n        //Q.nextInLML = Q.prev\n      }\n      else\n      {\n        locMin.LeftBound = E;\n        locMin.RightBound = E.Prev;\n        leftBoundIsForward = true;\n        //Q.nextInLML = Q.next\n      }\n      locMin.LeftBound.Side = ClipperLib.EdgeSide.esLeft;\n      locMin.RightBound.Side = ClipperLib.EdgeSide.esRight;\n      if (!Closed)\n        locMin.LeftBound.WindDelta = 0;\n      else if (locMin.LeftBound.Next == locMin.RightBound)\n        locMin.LeftBound.WindDelta = -1;\n      else\n        locMin.LeftBound.WindDelta = 1;\n      locMin.RightBound.WindDelta = -locMin.LeftBound.WindDelta;\n      E = this.ProcessBound(locMin.LeftBound, leftBoundIsForward);\n      if (E.OutIdx == ClipperLib.ClipperBase.Skip)\n      \tE = this.ProcessBound(E, leftBoundIsForward);\n      var E2 = this.ProcessBound(locMin.RightBound, !leftBoundIsForward);\n      if (E2.OutIdx == ClipperLib.ClipperBase.Skip) E2 = this.ProcessBound(E2, !leftBoundIsForward);\n      if (locMin.LeftBound.OutIdx == ClipperLib.ClipperBase.Skip)\n        locMin.LeftBound = null;\n      else if (locMin.RightBound.OutIdx == ClipperLib.ClipperBase.Skip)\n        locMin.RightBound = null;\n      this.InsertLocalMinima(locMin);\n      if (!leftBoundIsForward)\n        E = E2;\n    }\n    return true;\n  };\n  ClipperLib.ClipperBase.prototype.AddPaths = function (ppg, polyType, closed)\n  {\n    //  console.log(\"-------------------------------------------\");\n    //  console.log(JSON.stringify(ppg));\n    var result = false;\n    for (var i = 0, ilen = ppg.length; i < ilen; ++i)\n      if (this.AddPath(ppg[i], polyType, closed))\n        result = true;\n    return result;\n  };\n  //------------------------------------------------------------------------------\n  ClipperLib.ClipperBase.prototype.Pt2IsBetweenPt1AndPt3 = function (pt1, pt2, pt3)\n  {\n    if ((ClipperLib.IntPoint.op_Equality(pt1, pt3)) || (ClipperLib.IntPoint.op_Equality(pt1, pt2)) ||       (ClipperLib.IntPoint.op_Equality(pt3, pt2)))\n\n   //if ((pt1 == pt3) || (pt1 == pt2) || (pt3 == pt2))\n   return false;\n\n    else if (pt1.X != pt3.X)\n      return (pt2.X > pt1.X) == (pt2.X < pt3.X);\n    else\n      return (pt2.Y > pt1.Y) == (pt2.Y < pt3.Y);\n  };\n  ClipperLib.ClipperBase.prototype.RemoveEdge = function (e)\n  {\n    //removes e from double_linked_list (but without removing from memory)\n    e.Prev.Next = e.Next;\n    e.Next.Prev = e.Prev;\n    var result = e.Next;\n    e.Prev = null; //flag as removed (see ClipperBase.Clear)\n    return result;\n  };\n  ClipperLib.ClipperBase.prototype.SetDx = function (e)\n  {\n    e.Delta.X = (e.Top.X - e.Bot.X);\n    e.Delta.Y = (e.Top.Y - e.Bot.Y);\n    if (e.Delta.Y === 0) e.Dx = ClipperLib.ClipperBase.horizontal;\n    else e.Dx = (e.Delta.X) / (e.Delta.Y);\n  };\n  ClipperLib.ClipperBase.prototype.InsertLocalMinima = function (newLm)\n  {\n    if (this.m_MinimaList === null)\n    {\n      this.m_MinimaList = newLm;\n    }\n    else if (newLm.Y >= this.m_MinimaList.Y)\n    {\n      newLm.Next = this.m_MinimaList;\n      this.m_MinimaList = newLm;\n    }\n    else\n    {\n      var tmpLm = this.m_MinimaList;\n      while (tmpLm.Next !== null && (newLm.Y < tmpLm.Next.Y))\n        tmpLm = tmpLm.Next;\n      newLm.Next = tmpLm.Next;\n      tmpLm.Next = newLm;\n    }\n  };\n  ClipperLib.ClipperBase.prototype.PopLocalMinima = function ()\n  {\n    if (this.m_CurrentLM === null)\n      return;\n    this.m_CurrentLM = this.m_CurrentLM.Next;\n  };\n  ClipperLib.ClipperBase.prototype.ReverseHorizontal = function (e)\n  {\n    //swap horizontal edges' top and bottom x's so they follow the natural\n    //progression of the bounds - ie so their xbots will align with the\n    //adjoining lower edge. [Helpful in the ProcessHorizontal() method.]\n    var tmp = e.Top.X;\n    e.Top.X = e.Bot.X;\n    e.Bot.X = tmp;\n    if (use_xyz)\n    {\n      tmp = e.Top.Z;\n      e.Top.Z = e.Bot.Z;\n      e.Bot.Z = tmp;\n    }\n  };\n  ClipperLib.ClipperBase.prototype.Reset = function ()\n  {\n    this.m_CurrentLM = this.m_MinimaList;\n    if (this.m_CurrentLM == null)\n      return;\n    //ie nothing to process\n    //reset all edges ...\n    var lm = this.m_MinimaList;\n    while (lm != null)\n    {\n      var e = lm.LeftBound;\n      if (e != null)\n      {\n        //e.Curr = e.Bot;\n        e.Curr.X = e.Bot.X;\n        e.Curr.Y = e.Bot.Y;\n        e.Side = ClipperLib.EdgeSide.esLeft;\n        e.OutIdx = ClipperLib.ClipperBase.Unassigned;\n      }\n      e = lm.RightBound;\n      if (e != null)\n      {\n        //e.Curr = e.Bot;\n        e.Curr.X = e.Bot.X;\n        e.Curr.Y = e.Bot.Y;\n        e.Side = ClipperLib.EdgeSide.esRight;\n        e.OutIdx = ClipperLib.ClipperBase.Unassigned;\n      }\n      lm = lm.Next;\n    }\n  };\n  ClipperLib.Clipper = function (InitOptions) // public Clipper(int InitOptions = 0)\n  {\n    if (typeof (InitOptions) == \"undefined\") InitOptions = 0;\n    this.m_PolyOuts = null;\n    this.m_ClipType = ClipperLib.ClipType.ctIntersection;\n    this.m_Scanbeam = null;\n    this.m_ActiveEdges = null;\n    this.m_SortedEdges = null;\n    this.m_IntersectList = null;\n    this.m_IntersectNodeComparer = null;\n    this.m_ExecuteLocked = false;\n    this.m_ClipFillType = ClipperLib.PolyFillType.pftEvenOdd;\n    this.m_SubjFillType = ClipperLib.PolyFillType.pftEvenOdd;\n    this.m_Joins = null;\n    this.m_GhostJoins = null;\n    this.m_UsingPolyTree = false;\n    this.ReverseSolution = false;\n    this.StrictlySimple = false;\n    ClipperLib.ClipperBase.call(this);\n    this.m_Scanbeam = null;\n    this.m_ActiveEdges = null;\n    this.m_SortedEdges = null;\n    this.m_IntersectList = new Array();\n    this.m_IntersectNodeComparer = ClipperLib.MyIntersectNodeSort.Compare;\n    this.m_ExecuteLocked = false;\n    this.m_UsingPolyTree = false;\n    this.m_PolyOuts = new Array();\n    this.m_Joins = new Array();\n    this.m_GhostJoins = new Array();\n    this.ReverseSolution = (1 & InitOptions) !== 0;\n    this.StrictlySimple = (2 & InitOptions) !== 0;\n    this.PreserveCollinear = (4 & InitOptions) !== 0;\n    if (use_xyz)\n    {\n      this.ZFillFunction = null; // function (IntPoint vert1, IntPoint vert2, ref IntPoint intersectPt);\n    }\n  };\n  ClipperLib.Clipper.ioReverseSolution = 1;\n  ClipperLib.Clipper.ioStrictlySimple = 2;\n  ClipperLib.Clipper.ioPreserveCollinear = 4;\n\n  ClipperLib.Clipper.prototype.Clear = function ()\n  {\n    if (this.m_edges.length === 0)\n      return;\n    //avoids problems with ClipperBase destructor\n    this.DisposeAllPolyPts();\n    ClipperLib.ClipperBase.prototype.Clear.call(this);\n  };\n\n  ClipperLib.Clipper.prototype.DisposeScanbeamList = function ()\n  {\n    while (this.m_Scanbeam !== null)\n    {\n      var sb2 = this.m_Scanbeam.Next;\n      this.m_Scanbeam = null;\n      this.m_Scanbeam = sb2;\n    }\n  };\n  ClipperLib.Clipper.prototype.Reset = function ()\n  {\n    ClipperLib.ClipperBase.prototype.Reset.call(this);\n    this.m_Scanbeam = null;\n    this.m_ActiveEdges = null;\n    this.m_SortedEdges = null;\n\n    var lm = this.m_MinimaList;\n    while (lm !== null)\n    {\n      this.InsertScanbeam(lm.Y);\n      lm = lm.Next;\n    }\n  };\n  ClipperLib.Clipper.prototype.InsertScanbeam = function (Y)\n  {\n    if (this.m_Scanbeam === null)\n    {\n      this.m_Scanbeam = new ClipperLib.Scanbeam();\n      this.m_Scanbeam.Next = null;\n      this.m_Scanbeam.Y = Y;\n    }\n    else if (Y > this.m_Scanbeam.Y)\n    {\n      var newSb = new ClipperLib.Scanbeam();\n      newSb.Y = Y;\n      newSb.Next = this.m_Scanbeam;\n      this.m_Scanbeam = newSb;\n    }\n    else\n    {\n      var sb2 = this.m_Scanbeam;\n      while (sb2.Next !== null && (Y <= sb2.Next.Y))\n        sb2 = sb2.Next;\n      if (Y == sb2.Y)\n        return;\n      //ie ignores duplicates\n      var newSb = new ClipperLib.Scanbeam();\n      newSb.Y = Y;\n      newSb.Next = sb2.Next;\n      sb2.Next = newSb;\n    }\n  };\n  // ************************************\n  ClipperLib.Clipper.prototype.Execute = function ()\n  {\n    var a = arguments,\n      alen = a.length,\n      ispolytree = a[1] instanceof ClipperLib.PolyTree;\n    if (alen == 4 && !ispolytree) // function (clipType, solution, subjFillType, clipFillType)\n    {\n      var clipType = a[0],\n        solution = a[1],\n        subjFillType = a[2],\n        clipFillType = a[3];\n      if (this.m_ExecuteLocked)\n        return false;\n      if (this.m_HasOpenPaths)\n        ClipperLib.Error(\"Error: PolyTree struct is need for open path clipping.\");\n      this.m_ExecuteLocked = true;\n      ClipperLib.Clear(solution);\n      this.m_SubjFillType = subjFillType;\n      this.m_ClipFillType = clipFillType;\n      this.m_ClipType = clipType;\n      this.m_UsingPolyTree = false;\n      try\n      {\n        var succeeded = this.ExecuteInternal();\n        //build the return polygons ...\n        if (succeeded) this.BuildResult(solution);\n      }\n      finally\n      {\n        this.DisposeAllPolyPts();\n        this.m_ExecuteLocked = false;\n      }\n      return succeeded;\n    }\n    else if (alen == 4 && ispolytree) // function (clipType, polytree, subjFillType, clipFillType)\n    {\n      var clipType = a[0],\n        polytree = a[1],\n        subjFillType = a[2],\n        clipFillType = a[3];\n      if (this.m_ExecuteLocked)\n        return false;\n      this.m_ExecuteLocked = true;\n      this.m_SubjFillType = subjFillType;\n      this.m_ClipFillType = clipFillType;\n      this.m_ClipType = clipType;\n      this.m_UsingPolyTree = true;\n      try\n      {\n        var succeeded = this.ExecuteInternal();\n        //build the return polygons ...\n        if (succeeded) this.BuildResult2(polytree);\n      }\n      finally\n      {\n        this.DisposeAllPolyPts();\n        this.m_ExecuteLocked = false;\n      }\n      return succeeded;\n    }\n    else if (alen == 2 && !ispolytree) // function (clipType, solution)\n    {\n      var clipType = a[0],\n        solution = a[1];\n      return this.Execute(clipType, solution, ClipperLib.PolyFillType.pftEvenOdd, ClipperLib.PolyFillType.pftEvenOdd);\n    }\n    else if (alen == 2 && ispolytree) // function (clipType, polytree)\n    {\n      var clipType = a[0],\n        polytree = a[1];\n      return this.Execute(clipType, polytree, ClipperLib.PolyFillType.pftEvenOdd, ClipperLib.PolyFillType.pftEvenOdd);\n    }\n  };\n  ClipperLib.Clipper.prototype.FixHoleLinkage = function (outRec)\n  {\n    //skip if an outermost polygon or\n    //already already points to the correct FirstLeft ...\n    if (outRec.FirstLeft === null || (outRec.IsHole != outRec.FirstLeft.IsHole && outRec.FirstLeft.Pts !== null))\n      return;\n    var orfl = outRec.FirstLeft;\n    while (orfl !== null && ((orfl.IsHole == outRec.IsHole) || orfl.Pts === null))\n      orfl = orfl.FirstLeft;\n    outRec.FirstLeft = orfl;\n  };\n  ClipperLib.Clipper.prototype.ExecuteInternal = function ()\n  {\n    try\n    {\n      this.Reset();\n      if (this.m_CurrentLM === null)\n        return false;\n      var botY = this.PopScanbeam();\n      do {\n        this.InsertLocalMinimaIntoAEL(botY);\n        ClipperLib.Clear(this.m_GhostJoins);\n        this.ProcessHorizontals(false);\n        if (this.m_Scanbeam === null)\n          break;\n        var topY = this.PopScanbeam();\n        if (!this.ProcessIntersections(topY)) return false;\n\n        this.ProcessEdgesAtTopOfScanbeam(topY);\n        botY = topY;\n      }\n      while (this.m_Scanbeam !== null || this.m_CurrentLM !== null)\n      //fix orientations ...\n      for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n      {\n        var outRec = this.m_PolyOuts[i];\n        if (outRec.Pts === null || outRec.IsOpen)\n          continue;\n        if ((outRec.IsHole ^ this.ReverseSolution) == (this.Area(outRec) > 0))\n          this.ReversePolyPtLinks(outRec.Pts);\n      }\n      this.JoinCommonEdges();\n      for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n      {\n        var outRec = this.m_PolyOuts[i];\n        if (outRec.Pts !== null && !outRec.IsOpen)\n          this.FixupOutPolygon(outRec);\n      }\n      if (this.StrictlySimple)\n        this.DoSimplePolygons();\n      return true;\n    }\n    finally\n    {\n      ClipperLib.Clear(this.m_Joins);\n      ClipperLib.Clear(this.m_GhostJoins);\n    }\n  };\n  ClipperLib.Clipper.prototype.PopScanbeam = function ()\n  {\n    var Y = this.m_Scanbeam.Y;\n    this.m_Scanbeam = this.m_Scanbeam.Next;\n    return Y;\n  };\n\n  ClipperLib.Clipper.prototype.DisposeAllPolyPts = function ()\n  {\n    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; ++i)\n      this.DisposeOutRec(i);\n    ClipperLib.Clear(this.m_PolyOuts);\n  };\n  ClipperLib.Clipper.prototype.DisposeOutRec = function (index)\n  {\n    var outRec = this.m_PolyOuts[index];\n    outRec.Pts = null;\n    outRec = null;\n    this.m_PolyOuts[index] = null;\n  };\n\n  ClipperLib.Clipper.prototype.AddJoin = function (Op1, Op2, OffPt)\n  {\n    var j = new ClipperLib.Join();\n    j.OutPt1 = Op1;\n    j.OutPt2 = Op2;\n    //j.OffPt = OffPt;\n    j.OffPt.X = OffPt.X;\n    j.OffPt.Y = OffPt.Y;\n    this.m_Joins.push(j);\n  };\n  ClipperLib.Clipper.prototype.AddGhostJoin = function (Op, OffPt)\n  {\n    var j = new ClipperLib.Join();\n    j.OutPt1 = Op;\n    //j.OffPt = OffPt;\n    j.OffPt.X = OffPt.X;\n    j.OffPt.Y = OffPt.Y;\n    this.m_GhostJoins.push(j);\n  };\n  if (use_xyz)\n  {\n    ClipperLib.Clipper.prototype.SetZ = function (pt, e1, e2)\n    {\n      if (this.ZFillFunction !== null)\n      {\n        if (pt.Z != 0 || this.ZFillFunction === null) return;\n        else if (ClipperLib.IntPoint.op_Equality(pt, e1.Bot)) pt.Z = e1.Bot.Z;\n        else if (ClipperLib.IntPoint.op_Equality(pt, e1.Top)) pt.Z = e1.Top.Z;\n        else if (ClipperLib.IntPoint.op_Equality(pt, e2.Bot)) pt.Z = e2.Bot.Z;\n        else if (ClipperLib.IntPoint.op_Equality(pt, e2.Top)) pt.Z = e2.Top.Z;\n        else ZFillFunction(e1.Bot, e1.Top, e2.Bot, e2.Top, pt);\n      }\n    };\n\n    //------------------------------------------------------------------------------\n  }\n\n  ClipperLib.Clipper.prototype.InsertLocalMinimaIntoAEL = function (botY)\n  {\n    while (this.m_CurrentLM !== null && (this.m_CurrentLM.Y == botY))\n    {\n      var lb = this.m_CurrentLM.LeftBound;\n      var rb = this.m_CurrentLM.RightBound;\n      this.PopLocalMinima();\n      var Op1 = null;\n      if (lb === null)\n      {\n        this.InsertEdgeIntoAEL(rb, null);\n        this.SetWindingCount(rb);\n        if (this.IsContributing(rb))\n          Op1 = this.AddOutPt(rb, rb.Bot);\n      }\n      else if (rb == null)\n      {\n        this.InsertEdgeIntoAEL(lb, null);\n        this.SetWindingCount(lb);\n        if (this.IsContributing(lb))\n          Op1 = this.AddOutPt(lb, lb.Bot);\n        this.InsertScanbeam(lb.Top.Y);\n      }\n      else\n      {\n        this.InsertEdgeIntoAEL(lb, null);\n        this.InsertEdgeIntoAEL(rb, lb);\n        this.SetWindingCount(lb);\n        rb.WindCnt = lb.WindCnt;\n        rb.WindCnt2 = lb.WindCnt2;\n        if (this.IsContributing(lb))\n          Op1 = this.AddLocalMinPoly(lb, rb, lb.Bot);\n        this.InsertScanbeam(lb.Top.Y);\n      }\n      if (rb != null)\n      {\n        if (ClipperLib.ClipperBase.IsHorizontal(rb))\n          this.AddEdgeToSEL(rb);\n        else\n          this.InsertScanbeam(rb.Top.Y);\n      }\n      if (lb == null || rb == null) continue;\n      //if output polygons share an Edge with a horizontal rb, they'll need joining later ...\n      if (Op1 !== null && ClipperLib.ClipperBase.IsHorizontal(rb) && this.m_GhostJoins.length > 0 && rb.WindDelta !== 0)\n      {\n        for (var i = 0, ilen = this.m_GhostJoins.length; i < ilen; i++)\n        {\n          //if the horizontal Rb and a 'ghost' horizontal overlap, then convert\n          //the 'ghost' join to a real join ready for later ...\n          var j = this.m_GhostJoins[i];\n\n\t\t\t\t\tif (this.HorzSegmentsOverlap(j.OutPt1.Pt.X, j.OffPt.X, rb.Bot.X, rb.Top.X))\n            this.AddJoin(j.OutPt1, Op1, j.OffPt);\n        }\n      }\n      if (lb.OutIdx >= 0 && lb.PrevInAEL !== null &&\n        lb.PrevInAEL.Curr.X == lb.Bot.X &&\n        lb.PrevInAEL.OutIdx >= 0 &&\n        ClipperLib.ClipperBase.SlopesEqual(lb.PrevInAEL, lb, this.m_UseFullRange) &&\n        lb.WindDelta !== 0 && lb.PrevInAEL.WindDelta !== 0)\n      {\n        var Op2 = this.AddOutPt(lb.PrevInAEL, lb.Bot);\n        this.AddJoin(Op1, Op2, lb.Top);\n      }\n      if (lb.NextInAEL != rb)\n      {\n        if (rb.OutIdx >= 0 && rb.PrevInAEL.OutIdx >= 0 &&\n          ClipperLib.ClipperBase.SlopesEqual(rb.PrevInAEL, rb, this.m_UseFullRange) &&\n          rb.WindDelta !== 0 && rb.PrevInAEL.WindDelta !== 0)\n        {\n          var Op2 = this.AddOutPt(rb.PrevInAEL, rb.Bot);\n          this.AddJoin(Op1, Op2, rb.Top);\n        }\n        var e = lb.NextInAEL;\n        if (e !== null)\n          while (e != rb)\n          {\n            //nb: For calculating winding counts etc, IntersectEdges() assumes\n            //that param1 will be to the right of param2 ABOVE the intersection ...\n            this.IntersectEdges(rb, e, lb.Curr, false);\n            //order important here\n            e = e.NextInAEL;\n          }\n      }\n    }\n  };\n  ClipperLib.Clipper.prototype.InsertEdgeIntoAEL = function (edge, startEdge)\n  {\n    if (this.m_ActiveEdges === null)\n    {\n      edge.PrevInAEL = null;\n      edge.NextInAEL = null;\n      this.m_ActiveEdges = edge;\n    }\n    else if (startEdge === null && this.E2InsertsBeforeE1(this.m_ActiveEdges, edge))\n    {\n      edge.PrevInAEL = null;\n      edge.NextInAEL = this.m_ActiveEdges;\n      this.m_ActiveEdges.PrevInAEL = edge;\n      this.m_ActiveEdges = edge;\n    }\n    else\n    {\n      if (startEdge === null)\n        startEdge = this.m_ActiveEdges;\n      while (startEdge.NextInAEL !== null && !this.E2InsertsBeforeE1(startEdge.NextInAEL, edge))\n        startEdge = startEdge.NextInAEL;\n      edge.NextInAEL = startEdge.NextInAEL;\n      if (startEdge.NextInAEL !== null)\n        startEdge.NextInAEL.PrevInAEL = edge;\n      edge.PrevInAEL = startEdge;\n      startEdge.NextInAEL = edge;\n    }\n  };\n  ClipperLib.Clipper.prototype.E2InsertsBeforeE1 = function (e1, e2)\n  {\n    if (e2.Curr.X == e1.Curr.X)\n    {\n      if (e2.Top.Y > e1.Top.Y)\n        return e2.Top.X < ClipperLib.Clipper.TopX(e1, e2.Top.Y);\n      else\n        return e1.Top.X > ClipperLib.Clipper.TopX(e2, e1.Top.Y);\n    }\n    else\n      return e2.Curr.X < e1.Curr.X;\n  };\n  ClipperLib.Clipper.prototype.IsEvenOddFillType = function (edge)\n  {\n    if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)\n      return this.m_SubjFillType == ClipperLib.PolyFillType.pftEvenOdd;\n    else\n      return this.m_ClipFillType == ClipperLib.PolyFillType.pftEvenOdd;\n  };\n  ClipperLib.Clipper.prototype.IsEvenOddAltFillType = function (edge)\n  {\n    if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)\n      return this.m_ClipFillType == ClipperLib.PolyFillType.pftEvenOdd;\n    else\n      return this.m_SubjFillType == ClipperLib.PolyFillType.pftEvenOdd;\n  };\n  ClipperLib.Clipper.prototype.IsContributing = function (edge)\n  {\n    var pft, pft2;\n    if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)\n    {\n      pft = this.m_SubjFillType;\n      pft2 = this.m_ClipFillType;\n    }\n    else\n    {\n      pft = this.m_ClipFillType;\n      pft2 = this.m_SubjFillType;\n    }\n    switch (pft)\n    {\n    case ClipperLib.PolyFillType.pftEvenOdd:\n      if (edge.WindDelta === 0 && edge.WindCnt != 1)\n        return false;\n      break;\n    case ClipperLib.PolyFillType.pftNonZero:\n      if (Math.abs(edge.WindCnt) != 1)\n        return false;\n      break;\n    case ClipperLib.PolyFillType.pftPositive:\n      if (edge.WindCnt != 1)\n        return false;\n      break;\n    default:\n      if (edge.WindCnt != -1)\n        return false;\n      break;\n    }\n    switch (this.m_ClipType)\n    {\n    case ClipperLib.ClipType.ctIntersection:\n      switch (pft2)\n      {\n      case ClipperLib.PolyFillType.pftEvenOdd:\n      case ClipperLib.PolyFillType.pftNonZero:\n        return (edge.WindCnt2 !== 0);\n      case ClipperLib.PolyFillType.pftPositive:\n        return (edge.WindCnt2 > 0);\n      default:\n        return (edge.WindCnt2 < 0);\n      }\n    case ClipperLib.ClipType.ctUnion:\n      switch (pft2)\n      {\n      case ClipperLib.PolyFillType.pftEvenOdd:\n      case ClipperLib.PolyFillType.pftNonZero:\n        return (edge.WindCnt2 === 0);\n      case ClipperLib.PolyFillType.pftPositive:\n        return (edge.WindCnt2 <= 0);\n      default:\n        return (edge.WindCnt2 >= 0);\n      }\n    case ClipperLib.ClipType.ctDifference:\n      if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)\n        switch (pft2)\n        {\n        case ClipperLib.PolyFillType.pftEvenOdd:\n        case ClipperLib.PolyFillType.pftNonZero:\n          return (edge.WindCnt2 === 0);\n        case ClipperLib.PolyFillType.pftPositive:\n          return (edge.WindCnt2 <= 0);\n        default:\n          return (edge.WindCnt2 >= 0);\n        }\n      else\n        switch (pft2)\n        {\n        case ClipperLib.PolyFillType.pftEvenOdd:\n        case ClipperLib.PolyFillType.pftNonZero:\n          return (edge.WindCnt2 !== 0);\n        case ClipperLib.PolyFillType.pftPositive:\n          return (edge.WindCnt2 > 0);\n        default:\n          return (edge.WindCnt2 < 0);\n        }\n    case ClipperLib.ClipType.ctXor:\n      if (edge.WindDelta === 0)\n        switch (pft2)\n        {\n        case ClipperLib.PolyFillType.pftEvenOdd:\n        case ClipperLib.PolyFillType.pftNonZero:\n          return (edge.WindCnt2 === 0);\n        case ClipperLib.PolyFillType.pftPositive:\n          return (edge.WindCnt2 <= 0);\n        default:\n          return (edge.WindCnt2 >= 0);\n        }\n      else\n        return true;\n    }\n    return true;\n  };\n  ClipperLib.Clipper.prototype.SetWindingCount = function (edge)\n  {\n    var e = edge.PrevInAEL;\n    //find the edge of the same polytype that immediately preceeds 'edge' in AEL\n    while (e !== null && ((e.PolyTyp != edge.PolyTyp) || (e.WindDelta === 0)))\n      e = e.PrevInAEL;\n    if (e === null)\n    {\n      edge.WindCnt = (edge.WindDelta === 0 ? 1 : edge.WindDelta);\n      edge.WindCnt2 = 0;\n      e = this.m_ActiveEdges;\n      //ie get ready to calc WindCnt2\n    }\n    else if (edge.WindDelta === 0 && this.m_ClipType != ClipperLib.ClipType.ctUnion)\n    {\n      edge.WindCnt = 1;\n      edge.WindCnt2 = e.WindCnt2;\n      e = e.NextInAEL;\n      //ie get ready to calc WindCnt2\n    }\n    else if (this.IsEvenOddFillType(edge))\n    {\n      //EvenOdd filling ...\n      if (edge.WindDelta === 0)\n      {\n        //are we inside a subj polygon ...\n        var Inside = true;\n        var e2 = e.PrevInAEL;\n        while (e2 !== null)\n        {\n          if (e2.PolyTyp == e.PolyTyp && e2.WindDelta !== 0)\n            Inside = !Inside;\n          e2 = e2.PrevInAEL;\n        }\n        edge.WindCnt = (Inside ? 0 : 1);\n      }\n      else\n      {\n        edge.WindCnt = edge.WindDelta;\n      }\n      edge.WindCnt2 = e.WindCnt2;\n      e = e.NextInAEL;\n      //ie get ready to calc WindCnt2\n    }\n    else\n    {\n      //nonZero, Positive or Negative filling ...\n      if (e.WindCnt * e.WindDelta < 0)\n      {\n        //prev edge is 'decreasing' WindCount (WC) toward zero\n        //so we're outside the previous polygon ...\n        if (Math.abs(e.WindCnt) > 1)\n        {\n          //outside prev poly but still inside another.\n          //when reversing direction of prev poly use the same WC\n          if (e.WindDelta * edge.WindDelta < 0)\n            edge.WindCnt = e.WindCnt;\n          else\n            edge.WindCnt = e.WindCnt + edge.WindDelta;\n        }\n        else\n          edge.WindCnt = (edge.WindDelta === 0 ? 1 : edge.WindDelta);\n      }\n      else\n      {\n        //prev edge is 'increasing' WindCount (WC) away from zero\n        //so we're inside the previous polygon ...\n        if (edge.WindDelta === 0)\n          edge.WindCnt = (e.WindCnt < 0 ? e.WindCnt - 1 : e.WindCnt + 1);\n        else if (e.WindDelta * edge.WindDelta < 0)\n          edge.WindCnt = e.WindCnt;\n        else\n          edge.WindCnt = e.WindCnt + edge.WindDelta;\n      }\n      edge.WindCnt2 = e.WindCnt2;\n      e = e.NextInAEL;\n      //ie get ready to calc WindCnt2\n    }\n    //update WindCnt2 ...\n    if (this.IsEvenOddAltFillType(edge))\n    {\n      //EvenOdd filling ...\n      while (e != edge)\n      {\n        if (e.WindDelta !== 0)\n          edge.WindCnt2 = (edge.WindCnt2 === 0 ? 1 : 0);\n        e = e.NextInAEL;\n      }\n    }\n    else\n    {\n      //nonZero, Positive or Negative filling ...\n      while (e != edge)\n      {\n        edge.WindCnt2 += e.WindDelta;\n        e = e.NextInAEL;\n      }\n    }\n  };\n  ClipperLib.Clipper.prototype.AddEdgeToSEL = function (edge)\n  {\n    //SEL pointers in PEdge are reused to build a list of horizontal edges.\n    //However, we don't need to worry about order with horizontal edge processing.\n    if (this.m_SortedEdges === null)\n    {\n      this.m_SortedEdges = edge;\n      edge.PrevInSEL = null;\n      edge.NextInSEL = null;\n    }\n    else\n    {\n      edge.NextInSEL = this.m_SortedEdges;\n      edge.PrevInSEL = null;\n      this.m_SortedEdges.PrevInSEL = edge;\n      this.m_SortedEdges = edge;\n    }\n  };\n  ClipperLib.Clipper.prototype.CopyAELToSEL = function ()\n  {\n    var e = this.m_ActiveEdges;\n    this.m_SortedEdges = e;\n    while (e !== null)\n    {\n      e.PrevInSEL = e.PrevInAEL;\n      e.NextInSEL = e.NextInAEL;\n      e = e.NextInAEL;\n    }\n  };\n  ClipperLib.Clipper.prototype.SwapPositionsInAEL = function (edge1, edge2)\n  {\n    //check that one or other edge hasn't already been removed from AEL ...\n    if (edge1.NextInAEL == edge1.PrevInAEL || edge2.NextInAEL == edge2.PrevInAEL)\n      return;\n    if (edge1.NextInAEL == edge2)\n    {\n      var next = edge2.NextInAEL;\n      if (next !== null)\n        next.PrevInAEL = edge1;\n      var prev = edge1.PrevInAEL;\n      if (prev !== null)\n        prev.NextInAEL = edge2;\n      edge2.PrevInAEL = prev;\n      edge2.NextInAEL = edge1;\n      edge1.PrevInAEL = edge2;\n      edge1.NextInAEL = next;\n    }\n    else if (edge2.NextInAEL == edge1)\n    {\n      var next = edge1.NextInAEL;\n      if (next !== null)\n        next.PrevInAEL = edge2;\n      var prev = edge2.PrevInAEL;\n      if (prev !== null)\n        prev.NextInAEL = edge1;\n      edge1.PrevInAEL = prev;\n      edge1.NextInAEL = edge2;\n      edge2.PrevInAEL = edge1;\n      edge2.NextInAEL = next;\n    }\n    else\n    {\n      var next = edge1.NextInAEL;\n      var prev = edge1.PrevInAEL;\n      edge1.NextInAEL = edge2.NextInAEL;\n      if (edge1.NextInAEL !== null)\n        edge1.NextInAEL.PrevInAEL = edge1;\n      edge1.PrevInAEL = edge2.PrevInAEL;\n      if (edge1.PrevInAEL !== null)\n        edge1.PrevInAEL.NextInAEL = edge1;\n      edge2.NextInAEL = next;\n      if (edge2.NextInAEL !== null)\n        edge2.NextInAEL.PrevInAEL = edge2;\n      edge2.PrevInAEL = prev;\n      if (edge2.PrevInAEL !== null)\n        edge2.PrevInAEL.NextInAEL = edge2;\n    }\n    if (edge1.PrevInAEL === null)\n      this.m_ActiveEdges = edge1;\n    else if (edge2.PrevInAEL === null)\n      this.m_ActiveEdges = edge2;\n  };\n  ClipperLib.Clipper.prototype.SwapPositionsInSEL = function (edge1, edge2)\n  {\n    if (edge1.NextInSEL === null && edge1.PrevInSEL === null)\n      return;\n    if (edge2.NextInSEL === null && edge2.PrevInSEL === null)\n      return;\n    if (edge1.NextInSEL == edge2)\n    {\n      var next = edge2.NextInSEL;\n      if (next !== null)\n        next.PrevInSEL = edge1;\n      var prev = edge1.PrevInSEL;\n      if (prev !== null)\n        prev.NextInSEL = edge2;\n      edge2.PrevInSEL = prev;\n      edge2.NextInSEL = edge1;\n      edge1.PrevInSEL = edge2;\n      edge1.NextInSEL = next;\n    }\n    else if (edge2.NextInSEL == edge1)\n    {\n      var next = edge1.NextInSEL;\n      if (next !== null)\n        next.PrevInSEL = edge2;\n      var prev = edge2.PrevInSEL;\n      if (prev !== null)\n        prev.NextInSEL = edge1;\n      edge1.PrevInSEL = prev;\n      edge1.NextInSEL = edge2;\n      edge2.PrevInSEL = edge1;\n      edge2.NextInSEL = next;\n    }\n    else\n    {\n      var next = edge1.NextInSEL;\n      var prev = edge1.PrevInSEL;\n      edge1.NextInSEL = edge2.NextInSEL;\n      if (edge1.NextInSEL !== null)\n        edge1.NextInSEL.PrevInSEL = edge1;\n      edge1.PrevInSEL = edge2.PrevInSEL;\n      if (edge1.PrevInSEL !== null)\n        edge1.PrevInSEL.NextInSEL = edge1;\n      edge2.NextInSEL = next;\n      if (edge2.NextInSEL !== null)\n        edge2.NextInSEL.PrevInSEL = edge2;\n      edge2.PrevInSEL = prev;\n      if (edge2.PrevInSEL !== null)\n        edge2.PrevInSEL.NextInSEL = edge2;\n    }\n    if (edge1.PrevInSEL === null)\n      this.m_SortedEdges = edge1;\n    else if (edge2.PrevInSEL === null)\n      this.m_SortedEdges = edge2;\n  };\n  ClipperLib.Clipper.prototype.AddLocalMaxPoly = function (e1, e2, pt)\n  {\n    this.AddOutPt(e1, pt);\n    if (e2.WindDelta == 0) this.AddOutPt(e2, pt);\n    if (e1.OutIdx == e2.OutIdx)\n    {\n      e1.OutIdx = -1;\n      e2.OutIdx = -1;\n    }\n    else if (e1.OutIdx < e2.OutIdx)\n      this.AppendPolygon(e1, e2);\n    else\n      this.AppendPolygon(e2, e1);\n  };\n  ClipperLib.Clipper.prototype.AddLocalMinPoly = function (e1, e2, pt)\n  {\n    var result;\n    var e, prevE;\n    if (ClipperLib.ClipperBase.IsHorizontal(e2) || (e1.Dx > e2.Dx))\n    {\n      result = this.AddOutPt(e1, pt);\n      e2.OutIdx = e1.OutIdx;\n      e1.Side = ClipperLib.EdgeSide.esLeft;\n      e2.Side = ClipperLib.EdgeSide.esRight;\n      e = e1;\n      if (e.PrevInAEL == e2)\n        prevE = e2.PrevInAEL;\n      else\n        prevE = e.PrevInAEL;\n    }\n    else\n    {\n      result = this.AddOutPt(e2, pt);\n      e1.OutIdx = e2.OutIdx;\n      e1.Side = ClipperLib.EdgeSide.esRight;\n      e2.Side = ClipperLib.EdgeSide.esLeft;\n      e = e2;\n      if (e.PrevInAEL == e1)\n        prevE = e1.PrevInAEL;\n      else\n        prevE = e.PrevInAEL;\n    }\n    if (prevE !== null && prevE.OutIdx >= 0 && (ClipperLib.Clipper.TopX(prevE, pt.Y) == ClipperLib.Clipper.TopX(e, pt.Y)) && ClipperLib.ClipperBase.SlopesEqual(e, prevE, this.m_UseFullRange) && (e.WindDelta !== 0) && (prevE.WindDelta !== 0))\n    {\n      var outPt = this.AddOutPt(prevE, pt);\n      this.AddJoin(result, outPt, e.Top);\n    }\n    return result;\n  };\n  ClipperLib.Clipper.prototype.CreateOutRec = function ()\n  {\n    var result = new ClipperLib.OutRec();\n    result.Idx = -1;\n    result.IsHole = false;\n    result.IsOpen = false;\n    result.FirstLeft = null;\n    result.Pts = null;\n    result.BottomPt = null;\n    result.PolyNode = null;\n    this.m_PolyOuts.push(result);\n    result.Idx = this.m_PolyOuts.length - 1;\n    return result;\n  };\n  ClipperLib.Clipper.prototype.AddOutPt = function (e, pt)\n  {\n    var ToFront = (e.Side == ClipperLib.EdgeSide.esLeft);\n    if (e.OutIdx < 0)\n    {\n      var outRec = this.CreateOutRec();\n      outRec.IsOpen = (e.WindDelta === 0);\n      var newOp = new ClipperLib.OutPt();\n      outRec.Pts = newOp;\n      newOp.Idx = outRec.Idx;\n      //newOp.Pt = pt;\n      newOp.Pt.X = pt.X;\n      newOp.Pt.Y = pt.Y;\n      newOp.Next = newOp;\n      newOp.Prev = newOp;\n      if (!outRec.IsOpen)\n        this.SetHoleState(e, outRec);\n      e.OutIdx = outRec.Idx;\n      //nb: do this after SetZ !\n      return newOp;\n    }\n    else\n    {\n      var outRec = this.m_PolyOuts[e.OutIdx];\n      //OutRec.Pts is the 'Left-most' point & OutRec.Pts.Prev is the 'Right-most'\n      var op = outRec.Pts;\n      if (ToFront && ClipperLib.IntPoint.op_Equality(pt, op.Pt))\n        return op;\n      else if (!ToFront && ClipperLib.IntPoint.op_Equality(pt, op.Prev.Pt))\n        return op.Prev;\n      var newOp = new ClipperLib.OutPt();\n      newOp.Idx = outRec.Idx;\n      //newOp.Pt = pt;\n      newOp.Pt.X = pt.X;\n      newOp.Pt.Y = pt.Y;\n      newOp.Next = op;\n      newOp.Prev = op.Prev;\n      newOp.Prev.Next = newOp;\n      op.Prev = newOp;\n      if (ToFront)\n        outRec.Pts = newOp;\n      return newOp;\n    }\n  };\n  ClipperLib.Clipper.prototype.SwapPoints = function (pt1, pt2)\n  {\n    var tmp = new ClipperLib.IntPoint(pt1.Value);\n    //pt1.Value = pt2.Value;\n    pt1.Value.X = pt2.Value.X;\n    pt1.Value.Y = pt2.Value.Y;\n    //pt2.Value = tmp;\n    pt2.Value.X = tmp.X;\n    pt2.Value.Y = tmp.Y;\n  };\n  ClipperLib.Clipper.prototype.HorzSegmentsOverlap = function (seg1a, seg1b, seg2a, seg2b)\n\t{\n\t\tvar tmp;\n\t\tif (seg1a > seg1b)\n\t\t{\n\t\t\ttmp = seg1a;\n\t\t\tseg1a = seg1b;\n\t\t\tseg1b = tmp;\n\t\t}\n\t\tif (seg2a > seg2b)\n\t\t{\n\t\t\ttmp = seg2a;\n\t\t\tseg2a = seg2b;\n\t\t\tseg2b = tmp;\n\t\t}\n\t\treturn (seg1a < seg2b) && (seg2a < seg1b);\n\t}\n\n  ClipperLib.Clipper.prototype.SetHoleState = function (e, outRec)\n  {\n    var isHole = false;\n    var e2 = e.PrevInAEL;\n    while (e2 !== null)\n    {\n      if (e2.OutIdx >= 0 && e2.WindDelta != 0)\n      {\n        isHole = !isHole;\n        if (outRec.FirstLeft === null)\n          outRec.FirstLeft = this.m_PolyOuts[e2.OutIdx];\n      }\n      e2 = e2.PrevInAEL;\n    }\n    if (isHole)\n      outRec.IsHole = true;\n  };\n  ClipperLib.Clipper.prototype.GetDx = function (pt1, pt2)\n  {\n    if (pt1.Y == pt2.Y)\n      return ClipperLib.ClipperBase.horizontal;\n    else\n      return (pt2.X - pt1.X) / (pt2.Y - pt1.Y);\n  };\n  ClipperLib.Clipper.prototype.FirstIsBottomPt = function (btmPt1, btmPt2)\n  {\n    var p = btmPt1.Prev;\n    while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt1.Pt)) && (p != btmPt1))\n      p = p.Prev;\n    var dx1p = Math.abs(this.GetDx(btmPt1.Pt, p.Pt));\n    p = btmPt1.Next;\n    while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt1.Pt)) && (p != btmPt1))\n      p = p.Next;\n    var dx1n = Math.abs(this.GetDx(btmPt1.Pt, p.Pt));\n    p = btmPt2.Prev;\n    while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt2.Pt)) && (p != btmPt2))\n      p = p.Prev;\n    var dx2p = Math.abs(this.GetDx(btmPt2.Pt, p.Pt));\n    p = btmPt2.Next;\n    while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt2.Pt)) && (p != btmPt2))\n      p = p.Next;\n    var dx2n = Math.abs(this.GetDx(btmPt2.Pt, p.Pt));\n    return (dx1p >= dx2p && dx1p >= dx2n) || (dx1n >= dx2p && dx1n >= dx2n);\n  };\n  ClipperLib.Clipper.prototype.GetBottomPt = function (pp)\n  {\n    var dups = null;\n    var p = pp.Next;\n    while (p != pp)\n    {\n      if (p.Pt.Y > pp.Pt.Y)\n      {\n        pp = p;\n        dups = null;\n      }\n      else if (p.Pt.Y == pp.Pt.Y && p.Pt.X <= pp.Pt.X)\n      {\n        if (p.Pt.X < pp.Pt.X)\n        {\n          dups = null;\n          pp = p;\n        }\n        else\n        {\n          if (p.Next != pp && p.Prev != pp)\n            dups = p;\n        }\n      }\n      p = p.Next;\n    }\n    if (dups !== null)\n    {\n      //there appears to be at least 2 vertices at bottomPt so ...\n      while (dups != p)\n      {\n        if (!this.FirstIsBottomPt(p, dups))\n          pp = dups;\n        dups = dups.Next;\n        while (ClipperLib.IntPoint.op_Inequality(dups.Pt, pp.Pt))\n          dups = dups.Next;\n      }\n    }\n    return pp;\n  };\n  ClipperLib.Clipper.prototype.GetLowermostRec = function (outRec1, outRec2)\n  {\n    //work out which polygon fragment has the correct hole state ...\n    if (outRec1.BottomPt === null)\n      outRec1.BottomPt = this.GetBottomPt(outRec1.Pts);\n    if (outRec2.BottomPt === null)\n      outRec2.BottomPt = this.GetBottomPt(outRec2.Pts);\n    var bPt1 = outRec1.BottomPt;\n    var bPt2 = outRec2.BottomPt;\n    if (bPt1.Pt.Y > bPt2.Pt.Y)\n      return outRec1;\n    else if (bPt1.Pt.Y < bPt2.Pt.Y)\n      return outRec2;\n    else if (bPt1.Pt.X < bPt2.Pt.X)\n      return outRec1;\n    else if (bPt1.Pt.X > bPt2.Pt.X)\n      return outRec2;\n    else if (bPt1.Next == bPt1)\n      return outRec2;\n    else if (bPt2.Next == bPt2)\n      return outRec1;\n    else if (this.FirstIsBottomPt(bPt1, bPt2))\n      return outRec1;\n    else\n      return outRec2;\n  };\n  ClipperLib.Clipper.prototype.Param1RightOfParam2 = function (outRec1, outRec2)\n  {\n    do {\n      outRec1 = outRec1.FirstLeft;\n      if (outRec1 == outRec2)\n        return true;\n    }\n    while (outRec1 !== null)\n    return false;\n  };\n  ClipperLib.Clipper.prototype.GetOutRec = function (idx)\n  {\n    var outrec = this.m_PolyOuts[idx];\n    while (outrec != this.m_PolyOuts[outrec.Idx])\n      outrec = this.m_PolyOuts[outrec.Idx];\n    return outrec;\n  };\n  ClipperLib.Clipper.prototype.AppendPolygon = function (e1, e2)\n  {\n    //get the start and ends of both output polygons ...\n    var outRec1 = this.m_PolyOuts[e1.OutIdx];\n    var outRec2 = this.m_PolyOuts[e2.OutIdx];\n    var holeStateRec;\n    if (this.Param1RightOfParam2(outRec1, outRec2))\n      holeStateRec = outRec2;\n    else if (this.Param1RightOfParam2(outRec2, outRec1))\n      holeStateRec = outRec1;\n    else\n      holeStateRec = this.GetLowermostRec(outRec1, outRec2);\n    var p1_lft = outRec1.Pts;\n    var p1_rt = p1_lft.Prev;\n    var p2_lft = outRec2.Pts;\n    var p2_rt = p2_lft.Prev;\n    var side;\n    //join e2 poly onto e1 poly and delete pointers to e2 ...\n    if (e1.Side == ClipperLib.EdgeSide.esLeft)\n    {\n      if (e2.Side == ClipperLib.EdgeSide.esLeft)\n      {\n        //z y x a b c\n        this.ReversePolyPtLinks(p2_lft);\n        p2_lft.Next = p1_lft;\n        p1_lft.Prev = p2_lft;\n        p1_rt.Next = p2_rt;\n        p2_rt.Prev = p1_rt;\n        outRec1.Pts = p2_rt;\n      }\n      else\n      {\n        //x y z a b c\n        p2_rt.Next = p1_lft;\n        p1_lft.Prev = p2_rt;\n        p2_lft.Prev = p1_rt;\n        p1_rt.Next = p2_lft;\n        outRec1.Pts = p2_lft;\n      }\n      side = ClipperLib.EdgeSide.esLeft;\n    }\n    else\n    {\n      if (e2.Side == ClipperLib.EdgeSide.esRight)\n      {\n        //a b c z y x\n        this.ReversePolyPtLinks(p2_lft);\n        p1_rt.Next = p2_rt;\n        p2_rt.Prev = p1_rt;\n        p2_lft.Next = p1_lft;\n        p1_lft.Prev = p2_lft;\n      }\n      else\n      {\n        //a b c x y z\n        p1_rt.Next = p2_lft;\n        p2_lft.Prev = p1_rt;\n        p1_lft.Prev = p2_rt;\n        p2_rt.Next = p1_lft;\n      }\n      side = ClipperLib.EdgeSide.esRight;\n    }\n    outRec1.BottomPt = null;\n    if (holeStateRec == outRec2)\n    {\n      if (outRec2.FirstLeft != outRec1)\n        outRec1.FirstLeft = outRec2.FirstLeft;\n      outRec1.IsHole = outRec2.IsHole;\n    }\n    outRec2.Pts = null;\n    outRec2.BottomPt = null;\n    outRec2.FirstLeft = outRec1;\n    var OKIdx = e1.OutIdx;\n    var ObsoleteIdx = e2.OutIdx;\n    e1.OutIdx = -1;\n    //nb: safe because we only get here via AddLocalMaxPoly\n    e2.OutIdx = -1;\n    var e = this.m_ActiveEdges;\n    while (e !== null)\n    {\n      if (e.OutIdx == ObsoleteIdx)\n      {\n        e.OutIdx = OKIdx;\n        e.Side = side;\n        break;\n      }\n      e = e.NextInAEL;\n    }\n    outRec2.Idx = outRec1.Idx;\n  };\n  ClipperLib.Clipper.prototype.ReversePolyPtLinks = function (pp)\n  {\n    if (pp === null)\n      return;\n    var pp1;\n    var pp2;\n    pp1 = pp;\n    do {\n      pp2 = pp1.Next;\n      pp1.Next = pp1.Prev;\n      pp1.Prev = pp2;\n      pp1 = pp2;\n    }\n    while (pp1 != pp)\n  };\n  ClipperLib.Clipper.SwapSides = function (edge1, edge2)\n  {\n    var side = edge1.Side;\n    edge1.Side = edge2.Side;\n    edge2.Side = side;\n  };\n  ClipperLib.Clipper.SwapPolyIndexes = function (edge1, edge2)\n  {\n    var outIdx = edge1.OutIdx;\n    edge1.OutIdx = edge2.OutIdx;\n    edge2.OutIdx = outIdx;\n  };\n  ClipperLib.Clipper.prototype.IntersectEdges = function (e1, e2, pt)\n  {\n    //e1 will be to the left of e2 BELOW the intersection. Therefore e1 is before\n    //e2 in AEL except when e1 is being inserted at the intersection point ...\n    var e1Contributing = (e1.OutIdx >= 0);\n    var e2Contributing = (e2.OutIdx >= 0);\n\n    if (use_xyz)\n    \tthis.SetZ(pt, e1, e2);\n\n    if (use_lines)\n    {\n      //if either edge is on an OPEN path ...\n      if (e1.WindDelta === 0 || e2.WindDelta === 0)\n      {\n        //ignore subject-subject open path intersections UNLESS they\n        //are both open paths, AND they are both 'contributing maximas' ...\n\t\t\t\tif (e1.WindDelta == 0 && e2.WindDelta == 0) return;\n        //if intersecting a subj line with a subj poly ...\n        else if (e1.PolyTyp == e2.PolyTyp &&\n          e1.WindDelta != e2.WindDelta && this.m_ClipType == ClipperLib.ClipType.ctUnion)\n        {\n          if (e1.WindDelta === 0)\n          {\n            if (e2Contributing)\n            {\n              this.AddOutPt(e1, pt);\n              if (e1Contributing)\n                e1.OutIdx = -1;\n            }\n          }\n          else\n          {\n            if (e1Contributing)\n            {\n              this.AddOutPt(e2, pt);\n              if (e2Contributing)\n                e2.OutIdx = -1;\n            }\n          }\n        }\n        else if (e1.PolyTyp != e2.PolyTyp)\n        {\n          if ((e1.WindDelta === 0) && Math.abs(e2.WindCnt) == 1 &&\n            (this.m_ClipType != ClipperLib.ClipType.ctUnion || e2.WindCnt2 === 0))\n          {\n            this.AddOutPt(e1, pt);\n            if (e1Contributing)\n              e1.OutIdx = -1;\n          }\n          else if ((e2.WindDelta === 0) && (Math.abs(e1.WindCnt) == 1) &&\n            (this.m_ClipType != ClipperLib.ClipType.ctUnion || e1.WindCnt2 === 0))\n          {\n            this.AddOutPt(e2, pt);\n            if (e2Contributing)\n              e2.OutIdx = -1;\n          }\n        }\n        return;\n      }\n    }\n    //update winding counts...\n    //assumes that e1 will be to the Right of e2 ABOVE the intersection\n    if (e1.PolyTyp == e2.PolyTyp)\n    {\n      if (this.IsEvenOddFillType(e1))\n      {\n        var oldE1WindCnt = e1.WindCnt;\n        e1.WindCnt = e2.WindCnt;\n        e2.WindCnt = oldE1WindCnt;\n      }\n      else\n      {\n        if (e1.WindCnt + e2.WindDelta === 0)\n          e1.WindCnt = -e1.WindCnt;\n        else\n          e1.WindCnt += e2.WindDelta;\n        if (e2.WindCnt - e1.WindDelta === 0)\n          e2.WindCnt = -e2.WindCnt;\n        else\n          e2.WindCnt -= e1.WindDelta;\n      }\n    }\n    else\n    {\n      if (!this.IsEvenOddFillType(e2))\n        e1.WindCnt2 += e2.WindDelta;\n      else\n        e1.WindCnt2 = (e1.WindCnt2 === 0) ? 1 : 0;\n      if (!this.IsEvenOddFillType(e1))\n        e2.WindCnt2 -= e1.WindDelta;\n      else\n        e2.WindCnt2 = (e2.WindCnt2 === 0) ? 1 : 0;\n    }\n    var e1FillType, e2FillType, e1FillType2, e2FillType2;\n    if (e1.PolyTyp == ClipperLib.PolyType.ptSubject)\n    {\n      e1FillType = this.m_SubjFillType;\n      e1FillType2 = this.m_ClipFillType;\n    }\n    else\n    {\n      e1FillType = this.m_ClipFillType;\n      e1FillType2 = this.m_SubjFillType;\n    }\n    if (e2.PolyTyp == ClipperLib.PolyType.ptSubject)\n    {\n      e2FillType = this.m_SubjFillType;\n      e2FillType2 = this.m_ClipFillType;\n    }\n    else\n    {\n      e2FillType = this.m_ClipFillType;\n      e2FillType2 = this.m_SubjFillType;\n    }\n    var e1Wc, e2Wc;\n    switch (e1FillType)\n    {\n    case ClipperLib.PolyFillType.pftPositive:\n      e1Wc = e1.WindCnt;\n      break;\n    case ClipperLib.PolyFillType.pftNegative:\n      e1Wc = -e1.WindCnt;\n      break;\n    default:\n      e1Wc = Math.abs(e1.WindCnt);\n      break;\n    }\n    switch (e2FillType)\n    {\n    case ClipperLib.PolyFillType.pftPositive:\n      e2Wc = e2.WindCnt;\n      break;\n    case ClipperLib.PolyFillType.pftNegative:\n      e2Wc = -e2.WindCnt;\n      break;\n    default:\n      e2Wc = Math.abs(e2.WindCnt);\n      break;\n    }\n    if (e1Contributing && e2Contributing)\n    {\n\t\t\tif ((e1Wc != 0 && e1Wc != 1) || (e2Wc != 0 && e2Wc != 1) ||\n\t\t\t(e1.PolyTyp != e2.PolyTyp && this.m_ClipType != ClipperLib.ClipType.ctXor))\n\t\t\t{\n\t\t\t\tthis.AddLocalMaxPoly(e1, e2, pt);\n\t\t\t}\n      else\n      {\n        this.AddOutPt(e1, pt);\n        this.AddOutPt(e2, pt);\n        ClipperLib.Clipper.SwapSides(e1, e2);\n        ClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n      }\n    }\n    else if (e1Contributing)\n    {\n      if (e2Wc === 0 || e2Wc == 1)\n      {\n        this.AddOutPt(e1, pt);\n        ClipperLib.Clipper.SwapSides(e1, e2);\n        ClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n      }\n    }\n    else if (e2Contributing)\n    {\n      if (e1Wc === 0 || e1Wc == 1)\n      {\n        this.AddOutPt(e2, pt);\n        ClipperLib.Clipper.SwapSides(e1, e2);\n        ClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n      }\n    }\n\t\telse if ( (e1Wc == 0 || e1Wc == 1) && (e2Wc == 0 || e2Wc == 1))\n    {\n      //neither edge is currently contributing ...\n      var e1Wc2, e2Wc2;\n      switch (e1FillType2)\n      {\n      case ClipperLib.PolyFillType.pftPositive:\n        e1Wc2 = e1.WindCnt2;\n        break;\n      case ClipperLib.PolyFillType.pftNegative:\n        e1Wc2 = -e1.WindCnt2;\n        break;\n      default:\n        e1Wc2 = Math.abs(e1.WindCnt2);\n        break;\n      }\n      switch (e2FillType2)\n      {\n      case ClipperLib.PolyFillType.pftPositive:\n        e2Wc2 = e2.WindCnt2;\n        break;\n      case ClipperLib.PolyFillType.pftNegative:\n        e2Wc2 = -e2.WindCnt2;\n        break;\n      default:\n        e2Wc2 = Math.abs(e2.WindCnt2);\n        break;\n      }\n      if (e1.PolyTyp != e2.PolyTyp)\n      {\n        this.AddLocalMinPoly(e1, e2, pt);\n      }\n      else if (e1Wc == 1 && e2Wc == 1)\n        switch (this.m_ClipType)\n        {\n        case ClipperLib.ClipType.ctIntersection:\n          if (e1Wc2 > 0 && e2Wc2 > 0)\n            this.AddLocalMinPoly(e1, e2, pt);\n          break;\n        case ClipperLib.ClipType.ctUnion:\n          if (e1Wc2 <= 0 && e2Wc2 <= 0)\n            this.AddLocalMinPoly(e1, e2, pt);\n          break;\n        case ClipperLib.ClipType.ctDifference:\n          if (((e1.PolyTyp == ClipperLib.PolyType.ptClip) && (e1Wc2 > 0) && (e2Wc2 > 0)) ||\n            ((e1.PolyTyp == ClipperLib.PolyType.ptSubject) && (e1Wc2 <= 0) && (e2Wc2 <= 0)))\n            this.AddLocalMinPoly(e1, e2, pt);\n          break;\n        case ClipperLib.ClipType.ctXor:\n          this.AddLocalMinPoly(e1, e2, pt);\n          break;\n        }\n      else\n        ClipperLib.Clipper.SwapSides(e1, e2);\n    }\n  };\n  ClipperLib.Clipper.prototype.DeleteFromAEL = function (e)\n  {\n    var AelPrev = e.PrevInAEL;\n    var AelNext = e.NextInAEL;\n    if (AelPrev === null && AelNext === null && (e != this.m_ActiveEdges))\n      return;\n    //already deleted\n    if (AelPrev !== null)\n      AelPrev.NextInAEL = AelNext;\n    else\n      this.m_ActiveEdges = AelNext;\n    if (AelNext !== null)\n      AelNext.PrevInAEL = AelPrev;\n    e.NextInAEL = null;\n    e.PrevInAEL = null;\n  };\n  ClipperLib.Clipper.prototype.DeleteFromSEL = function (e)\n  {\n    var SelPrev = e.PrevInSEL;\n    var SelNext = e.NextInSEL;\n    if (SelPrev === null && SelNext === null && (e != this.m_SortedEdges))\n      return;\n    //already deleted\n    if (SelPrev !== null)\n      SelPrev.NextInSEL = SelNext;\n    else\n      this.m_SortedEdges = SelNext;\n    if (SelNext !== null)\n      SelNext.PrevInSEL = SelPrev;\n    e.NextInSEL = null;\n    e.PrevInSEL = null;\n  };\n  ClipperLib.Clipper.prototype.UpdateEdgeIntoAEL = function (e)\n  {\n    if (e.NextInLML === null)\n      ClipperLib.Error(\"UpdateEdgeIntoAEL: invalid call\");\n    var AelPrev = e.PrevInAEL;\n    var AelNext = e.NextInAEL;\n    e.NextInLML.OutIdx = e.OutIdx;\n    if (AelPrev !== null)\n      AelPrev.NextInAEL = e.NextInLML;\n    else\n      this.m_ActiveEdges = e.NextInLML;\n    if (AelNext !== null)\n      AelNext.PrevInAEL = e.NextInLML;\n    e.NextInLML.Side = e.Side;\n    e.NextInLML.WindDelta = e.WindDelta;\n    e.NextInLML.WindCnt = e.WindCnt;\n    e.NextInLML.WindCnt2 = e.WindCnt2;\n    e = e.NextInLML;\n    //    e.Curr = e.Bot;\n    e.Curr.X = e.Bot.X;\n    e.Curr.Y = e.Bot.Y;\n    e.PrevInAEL = AelPrev;\n    e.NextInAEL = AelNext;\n    if (!ClipperLib.ClipperBase.IsHorizontal(e))\n      this.InsertScanbeam(e.Top.Y);\n    return e;\n  };\n  ClipperLib.Clipper.prototype.ProcessHorizontals = function (isTopOfScanbeam)\n  {\n    var horzEdge = this.m_SortedEdges;\n    while (horzEdge !== null)\n    {\n      this.DeleteFromSEL(horzEdge);\n      this.ProcessHorizontal(horzEdge, isTopOfScanbeam);\n      horzEdge = this.m_SortedEdges;\n    }\n  };\n  ClipperLib.Clipper.prototype.GetHorzDirection = function (HorzEdge, $var)\n  {\n    if (HorzEdge.Bot.X < HorzEdge.Top.X)\n    {\n        $var.Left = HorzEdge.Bot.X;\n        $var.Right = HorzEdge.Top.X;\n        $var.Dir = ClipperLib.Direction.dLeftToRight;\n    }\n    else\n    {\n        $var.Left = HorzEdge.Top.X;\n        $var.Right = HorzEdge.Bot.X;\n        $var.Dir = ClipperLib.Direction.dRightToLeft;\n    }\n  };\n  ClipperLib.Clipper.prototype.ProcessHorizontal = function (horzEdge, isTopOfScanbeam)\n  {\n    var $var = {Dir: null, Left: null, Right: null};\n    this.GetHorzDirection(horzEdge, $var);\n    var dir = $var.Dir;\n    var horzLeft = $var.Left;\n    var horzRight = $var.Right;\n\n    var eLastHorz = horzEdge,\n      eMaxPair = null;\n    while (eLastHorz.NextInLML !== null && ClipperLib.ClipperBase.IsHorizontal(eLastHorz.NextInLML))\n      eLastHorz = eLastHorz.NextInLML;\n    if (eLastHorz.NextInLML === null)\n      eMaxPair = this.GetMaximaPair(eLastHorz);\n    for (;;)\n    {\n      var IsLastHorz = (horzEdge == eLastHorz);\n      var e = this.GetNextInAEL(horzEdge, dir);\n      while (e !== null)\n      {\n        //Break if we've got to the end of an intermediate horizontal edge ...\n        //nb: Smaller Dx's are to the right of larger Dx's ABOVE the horizontal.\n        if (e.Curr.X == horzEdge.Top.X && horzEdge.NextInLML !== null && e.Dx < horzEdge.NextInLML.Dx)\n          break;\n        var eNext = this.GetNextInAEL(e, dir);\n        //saves eNext for later\n        if ((dir == ClipperLib.Direction.dLeftToRight && e.Curr.X <= horzRight) || (dir == ClipperLib.Direction.dRightToLeft && e.Curr.X >= horzLeft))\n        {\n          //so far we're still in range of the horizontal Edge  but make sure\n          //we're at the last of consec. horizontals when matching with eMaxPair\n          if (e == eMaxPair && IsLastHorz)\n          {\n\t\t\t\t\t\tif (horzEdge.OutIdx >= 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar op1 = this.AddOutPt(horzEdge, horzEdge.Top);\n\t\t\t\t\t\t\tvar eNextHorz = this.m_SortedEdges;\n\t\t\t\t\t\t\twhile (eNextHorz !== null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (eNextHorz.OutIdx >= 0 &&\n\t\t\t\t\t\t\t\t\tthis.HorzSegmentsOverlap(horzEdge.Bot.X,\n\t\t\t\t\t\t\t\t\thorzEdge.Top.X, eNextHorz.Bot.X, eNextHorz.Top.X))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tvar op2 = this.AddOutPt(eNextHorz, eNextHorz.Bot);\n\t\t\t\t\t\t\t\t\tthis.AddJoin(op2, op1, eNextHorz.Top);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\teNextHorz = eNextHorz.NextInSEL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis.AddGhostJoin(op1, horzEdge.Bot);\n\t\t\t\t\t\t\tthis.AddLocalMaxPoly(horzEdge, eMaxPair, horzEdge.Top);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.DeleteFromAEL(horzEdge);\n\t\t\t\t\t\tthis.DeleteFromAEL(eMaxPair);\n            return;\n          }\n          else if (dir == ClipperLib.Direction.dLeftToRight)\n          {\n            var Pt = new ClipperLib.IntPoint(e.Curr.X, horzEdge.Curr.Y);\n            this.IntersectEdges(horzEdge, e, Pt);\n          }\n          else\n          {\n            var Pt = new ClipperLib.IntPoint(e.Curr.X, horzEdge.Curr.Y);\n            this.IntersectEdges(e, horzEdge, Pt);\n          }\n          this.SwapPositionsInAEL(horzEdge, e);\n        }\n        else if ((dir == ClipperLib.Direction.dLeftToRight && e.Curr.X >= horzRight) || (dir == ClipperLib.Direction.dRightToLeft && e.Curr.X <= horzLeft))\n          break;\n        e = eNext;\n      }\n      //end while\n      if (horzEdge.NextInLML !== null && ClipperLib.ClipperBase.IsHorizontal(horzEdge.NextInLML))\n      {\n        horzEdge = this.UpdateEdgeIntoAEL(horzEdge);\n        if (horzEdge.OutIdx >= 0)\n          this.AddOutPt(horzEdge, horzEdge.Bot);\n\n          var $var = {Dir: dir, Left: horzLeft, Right: horzRight};\n          this.GetHorzDirection(horzEdge, $var);\n          dir = $var.Dir;\n          horzLeft = $var.Left;\n          horzRight = $var.Right;\n      }\n      else\n        break;\n    }\n    //end for (;;)\n    if (horzEdge.NextInLML !== null)\n    {\n      if (horzEdge.OutIdx >= 0)\n      {\n        var op1 = this.AddOutPt(horzEdge, horzEdge.Top);\n\t\t\t\tif (isTopOfScanbeam) this.AddGhostJoin(op1, horzEdge.Bot);\n        horzEdge = this.UpdateEdgeIntoAEL(horzEdge);\n        if (horzEdge.WindDelta === 0)\n          return;\n        //nb: HorzEdge is no longer horizontal here\n        var ePrev = horzEdge.PrevInAEL;\n        var eNext = horzEdge.NextInAEL;\n        if (ePrev !== null && ePrev.Curr.X == horzEdge.Bot.X &&\n          ePrev.Curr.Y == horzEdge.Bot.Y && ePrev.WindDelta !== 0 &&\n          (ePrev.OutIdx >= 0 && ePrev.Curr.Y > ePrev.Top.Y &&\n            ClipperLib.ClipperBase.SlopesEqual(horzEdge, ePrev, this.m_UseFullRange)))\n        {\n          var op2 = this.AddOutPt(ePrev, horzEdge.Bot);\n          this.AddJoin(op1, op2, horzEdge.Top);\n        }\n        else if (eNext !== null && eNext.Curr.X == horzEdge.Bot.X &&\n          eNext.Curr.Y == horzEdge.Bot.Y && eNext.WindDelta !== 0 &&\n          eNext.OutIdx >= 0 && eNext.Curr.Y > eNext.Top.Y &&\n          ClipperLib.ClipperBase.SlopesEqual(horzEdge, eNext, this.m_UseFullRange))\n        {\n          var op2 = this.AddOutPt(eNext, horzEdge.Bot);\n          this.AddJoin(op1, op2, horzEdge.Top);\n        }\n      }\n      else horzEdge = this.UpdateEdgeIntoAEL(horzEdge);\n    }\n  \telse\n    {\n      if (horzEdge.OutIdx >= 0)\n        this.AddOutPt(horzEdge, horzEdge.Top);\n      this.DeleteFromAEL(horzEdge);\n    }\n  };\n  ClipperLib.Clipper.prototype.GetNextInAEL = function (e, Direction)\n  {\n    return Direction == ClipperLib.Direction.dLeftToRight ? e.NextInAEL : e.PrevInAEL;\n  };\n  ClipperLib.Clipper.prototype.IsMinima = function (e)\n  {\n    return e !== null && (e.Prev.NextInLML != e) && (e.Next.NextInLML != e);\n  };\n  ClipperLib.Clipper.prototype.IsMaxima = function (e, Y)\n  {\n    return (e !== null && e.Top.Y == Y && e.NextInLML === null);\n  };\n  ClipperLib.Clipper.prototype.IsIntermediate = function (e, Y)\n  {\n    return (e.Top.Y == Y && e.NextInLML !== null);\n  };\n  ClipperLib.Clipper.prototype.GetMaximaPair = function (e)\n  {\n    var result = null;\n    if ((ClipperLib.IntPoint.op_Equality(e.Next.Top, e.Top)) && e.Next.NextInLML === null)\n      result = e.Next;\n    else if ((ClipperLib.IntPoint.op_Equality(e.Prev.Top, e.Top)) && e.Prev.NextInLML === null)\n      result = e.Prev;\n    if (result !== null && (result.OutIdx == -2 || (result.NextInAEL == result.PrevInAEL && !ClipperLib.ClipperBase.IsHorizontal(result))))\n      return null;\n    return result;\n  };\n\n  ClipperLib.Clipper.prototype.ProcessIntersections = function (topY)\n  {\n    if (this.m_ActiveEdges == null)\n      return true;\n    try\n    {\n      this.BuildIntersectList(topY);\n      if (this.m_IntersectList.length == 0)\n        return true;\n      if (this.m_IntersectList.length == 1 || this.FixupIntersectionOrder())\n        this.ProcessIntersectList();\n      else\n        return false;\n    }\n    catch ($$e2)\n    {\n      this.m_SortedEdges = null;\n      this.m_IntersectList.length = 0;\n      ClipperLib.Error(\"ProcessIntersections error\");\n    }\n    this.m_SortedEdges = null;\n    return true;\n  };\n  ClipperLib.Clipper.prototype.BuildIntersectList = function (topY)\n  {\n    if (this.m_ActiveEdges === null)\n      return;\n    //prepare for sorting ...\n    var e = this.m_ActiveEdges;\n    //console.log(JSON.stringify(JSON.decycle( e )));\n    this.m_SortedEdges = e;\n    while (e !== null)\n    {\n      e.PrevInSEL = e.PrevInAEL;\n      e.NextInSEL = e.NextInAEL;\n      e.Curr.X = ClipperLib.Clipper.TopX(e, topY);\n      e = e.NextInAEL;\n    }\n    //bubblesort ...\n    var isModified = true;\n    while (isModified && this.m_SortedEdges !== null)\n    {\n      isModified = false;\n      e = this.m_SortedEdges;\n      while (e.NextInSEL !== null)\n      {\n        var eNext = e.NextInSEL;\n        var pt = new ClipperLib.IntPoint();\n        //console.log(\"e.Curr.X: \" + e.Curr.X + \" eNext.Curr.X\" + eNext.Curr.X);\n        if (e.Curr.X > eNext.Curr.X)\n        {\n\t\t\t\t\tthis.IntersectPoint(e, eNext, pt);\n          var newNode = new ClipperLib.IntersectNode();\n          newNode.Edge1 = e;\n          newNode.Edge2 = eNext;\n          //newNode.Pt = pt;\n          newNode.Pt.X = pt.X;\n          newNode.Pt.Y = pt.Y;\n          this.m_IntersectList.push(newNode);\n          this.SwapPositionsInSEL(e, eNext);\n          isModified = true;\n        }\n        else\n          e = eNext;\n      }\n      if (e.PrevInSEL !== null)\n        e.PrevInSEL.NextInSEL = null;\n      else\n        break;\n    }\n    this.m_SortedEdges = null;\n  };\n  ClipperLib.Clipper.prototype.EdgesAdjacent = function (inode)\n  {\n    return (inode.Edge1.NextInSEL == inode.Edge2) || (inode.Edge1.PrevInSEL == inode.Edge2);\n  };\n  ClipperLib.Clipper.IntersectNodeSort = function (node1, node2)\n  {\n    //the following typecast is safe because the differences in Pt.Y will\n    //be limited to the height of the scanbeam.\n    return (node2.Pt.Y - node1.Pt.Y);\n  };\n  ClipperLib.Clipper.prototype.FixupIntersectionOrder = function ()\n  {\n    //pre-condition: intersections are sorted bottom-most first.\n    //Now it's crucial that intersections are made only between adjacent edges,\n    //so to ensure this the order of intersections may need adjusting ...\n    this.m_IntersectList.sort(this.m_IntersectNodeComparer);\n    this.CopyAELToSEL();\n    var cnt = this.m_IntersectList.length;\n    for (var i = 0; i < cnt; i++)\n    {\n      if (!this.EdgesAdjacent(this.m_IntersectList[i]))\n      {\n        var j = i + 1;\n        while (j < cnt && !this.EdgesAdjacent(this.m_IntersectList[j]))\n          j++;\n        if (j == cnt)\n          return false;\n        var tmp = this.m_IntersectList[i];\n        this.m_IntersectList[i] = this.m_IntersectList[j];\n        this.m_IntersectList[j] = tmp;\n      }\n      this.SwapPositionsInSEL(this.m_IntersectList[i].Edge1, this.m_IntersectList[i].Edge2);\n    }\n    return true;\n  };\n  ClipperLib.Clipper.prototype.ProcessIntersectList = function ()\n  {\n    for (var i = 0, ilen = this.m_IntersectList.length; i < ilen; i++)\n    {\n      var iNode = this.m_IntersectList[i];\n      this.IntersectEdges(iNode.Edge1, iNode.Edge2, iNode.Pt);\n      this.SwapPositionsInAEL(iNode.Edge1, iNode.Edge2);\n    }\n    this.m_IntersectList.length = 0;\n  };\n  /*\n  --------------------------------\n  Round speedtest: http://jsperf.com/fastest-round\n  --------------------------------\n  */\n  var R1 = function (a)\n  {\n    return a < 0 ? Math.ceil(a - 0.5) : Math.round(a)\n  };\n  var R2 = function (a)\n  {\n    return a < 0 ? Math.ceil(a - 0.5) : Math.floor(a + 0.5)\n  };\n  var R3 = function (a)\n  {\n    return a < 0 ? -Math.round(Math.abs(a)) : Math.round(a)\n  };\n  var R4 = function (a)\n  {\n    if (a < 0)\n    {\n      a -= 0.5;\n      return a < -2147483648 ? Math.ceil(a) : a | 0;\n    }\n    else\n    {\n      a += 0.5;\n      return a > 2147483647 ? Math.floor(a) : a | 0;\n    }\n  };\n  if (browser.msie) ClipperLib.Clipper.Round = R1;\n  else if (browser.chromium) ClipperLib.Clipper.Round = R3;\n  else if (browser.safari) ClipperLib.Clipper.Round = R4;\n  else ClipperLib.Clipper.Round = R2; // eg. browser.chrome || browser.firefox || browser.opera\n  ClipperLib.Clipper.TopX = function (edge, currentY)\n  {\n    //if (edge.Bot == edge.Curr) alert (\"edge.Bot = edge.Curr\");\n    //if (edge.Bot == edge.Top) alert (\"edge.Bot = edge.Top\");\n    if (currentY == edge.Top.Y)\n      return edge.Top.X;\n    return edge.Bot.X + ClipperLib.Clipper.Round(edge.Dx * (currentY - edge.Bot.Y));\n  };\n  ClipperLib.Clipper.prototype.IntersectPoint = function (edge1, edge2, ip)\n  {\n    ip.X = 0;\n    ip.Y = 0;\n    var b1, b2;\n    //nb: with very large coordinate values, it's possible for SlopesEqual() to\n    //return false but for the edge.Dx value be equal due to double precision rounding.\n    if (edge1.Dx == edge2.Dx)\n\t\t{\n\t\t\tip.Y = edge1.Curr.Y;\n\t\t\tip.X = ClipperLib.Clipper.TopX(edge1, ip.Y);\n\t\t\treturn;\n    }\n    if (edge1.Delta.X === 0)\n    {\n      ip.X = edge1.Bot.X;\n      if (ClipperLib.ClipperBase.IsHorizontal(edge2))\n      {\n        ip.Y = edge2.Bot.Y;\n      }\n      else\n      {\n        b2 = edge2.Bot.Y - (edge2.Bot.X / edge2.Dx);\n        ip.Y = ClipperLib.Clipper.Round(ip.X / edge2.Dx + b2);\n      }\n    }\n    else if (edge2.Delta.X === 0)\n    {\n      ip.X = edge2.Bot.X;\n      if (ClipperLib.ClipperBase.IsHorizontal(edge1))\n      {\n        ip.Y = edge1.Bot.Y;\n      }\n      else\n      {\n        b1 = edge1.Bot.Y - (edge1.Bot.X / edge1.Dx);\n        ip.Y = ClipperLib.Clipper.Round(ip.X / edge1.Dx + b1);\n      }\n    }\n    else\n    {\n      b1 = edge1.Bot.X - edge1.Bot.Y * edge1.Dx;\n      b2 = edge2.Bot.X - edge2.Bot.Y * edge2.Dx;\n      var q = (b2 - b1) / (edge1.Dx - edge2.Dx);\n      ip.Y = ClipperLib.Clipper.Round(q);\n      if (Math.abs(edge1.Dx) < Math.abs(edge2.Dx))\n        ip.X = ClipperLib.Clipper.Round(edge1.Dx * q + b1);\n      else\n        ip.X = ClipperLib.Clipper.Round(edge2.Dx * q + b2);\n    }\n    if (ip.Y < edge1.Top.Y || ip.Y < edge2.Top.Y)\n    {\n      if (edge1.Top.Y > edge2.Top.Y)\n      {\n        ip.Y = edge1.Top.Y;\n        ip.X = ClipperLib.Clipper.TopX(edge2, edge1.Top.Y);\n        return ip.X < edge1.Top.X;\n      }\n      else\n        ip.Y = edge2.Top.Y;\n      if (Math.abs(edge1.Dx) < Math.abs(edge2.Dx))\n        ip.X = ClipperLib.Clipper.TopX(edge1, ip.Y);\n      else\n        ip.X = ClipperLib.Clipper.TopX(edge2, ip.Y);\n    }\n\t\t//finally, don't allow 'ip' to be BELOW curr.Y (ie bottom of scanbeam) ...\n\t\tif (ip.Y > edge1.Curr.Y)\n\t\t{\n\t\t\tip.Y = edge1.Curr.Y;\n\t\t\t//better to use the more vertical edge to derive X ...\n\t\t\tif (Math.abs(edge1.Dx) > Math.abs(edge2.Dx))\n\t\t\t\tip.X = ClipperLib.Clipper.TopX(edge2, ip.Y);\n\t\t\telse\n\t\t\t\tip.X = ClipperLib.Clipper.TopX(edge1, ip.Y);\n\t\t}\n  };\n\n  ClipperLib.Clipper.prototype.ProcessEdgesAtTopOfScanbeam = function (topY)\n  {\n    var e = this.m_ActiveEdges;\n    while (e !== null)\n    {\n      //1. process maxima, treating them as if they're 'bent' horizontal edges,\n      //   but exclude maxima with horizontal edges. nb: e can't be a horizontal.\n      var IsMaximaEdge = this.IsMaxima(e, topY);\n      if (IsMaximaEdge)\n      {\n        var eMaxPair = this.GetMaximaPair(e);\n        IsMaximaEdge = (eMaxPair === null || !ClipperLib.ClipperBase.IsHorizontal(eMaxPair));\n      }\n      if (IsMaximaEdge)\n      {\n        var ePrev = e.PrevInAEL;\n        this.DoMaxima(e);\n        if (ePrev === null)\n          e = this.m_ActiveEdges;\n        else\n          e = ePrev.NextInAEL;\n      }\n      else\n      {\n        //2. promote horizontal edges, otherwise update Curr.X and Curr.Y ...\n        if (this.IsIntermediate(e, topY) && ClipperLib.ClipperBase.IsHorizontal(e.NextInLML))\n        {\n          e = this.UpdateEdgeIntoAEL(e);\n          if (e.OutIdx >= 0)\n            this.AddOutPt(e, e.Bot);\n          this.AddEdgeToSEL(e);\n        }\n        else\n        {\n          e.Curr.X = ClipperLib.Clipper.TopX(e, topY);\n          e.Curr.Y = topY;\n        }\n        if (this.StrictlySimple)\n        {\n          var ePrev = e.PrevInAEL;\n          if ((e.OutIdx >= 0) && (e.WindDelta !== 0) && ePrev !== null &&\n            (ePrev.OutIdx >= 0) && (ePrev.Curr.X == e.Curr.X) &&\n            (ePrev.WindDelta !== 0))\n          {\n           \tvar ip = new ClipperLib.IntPoint(e.Curr);\n\n\t\t\t\t\t\tif(use_xyz)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis.SetZ(ip, ePrev, e);\n\t\t\t\t\t\t}\n\n            var op = this.AddOutPt(ePrev, ip);\n            var op2 = this.AddOutPt(e, ip);\n            this.AddJoin(op, op2, ip);\n            //StrictlySimple (type-3) join\n          }\n        }\n        e = e.NextInAEL;\n      }\n    }\n    //3. Process horizontals at the Top of the scanbeam ...\n    this.ProcessHorizontals(true);\n    //4. Promote intermediate vertices ...\n    e = this.m_ActiveEdges;\n    while (e !== null)\n    {\n      if (this.IsIntermediate(e, topY))\n      {\n        var op = null;\n        if (e.OutIdx >= 0)\n          op = this.AddOutPt(e, e.Top);\n        e = this.UpdateEdgeIntoAEL(e);\n        //if output polygons share an edge, they'll need joining later ...\n        var ePrev = e.PrevInAEL;\n        var eNext = e.NextInAEL;\n        if (ePrev !== null && ePrev.Curr.X == e.Bot.X &&\n          ePrev.Curr.Y == e.Bot.Y && op !== null &&\n          ePrev.OutIdx >= 0 && ePrev.Curr.Y > ePrev.Top.Y &&\n          ClipperLib.ClipperBase.SlopesEqual(e, ePrev, this.m_UseFullRange) &&\n          (e.WindDelta !== 0) && (ePrev.WindDelta !== 0))\n        {\n          var op2 = this.AddOutPt(ePrev, e.Bot);\n          this.AddJoin(op, op2, e.Top);\n        }\n        else if (eNext !== null && eNext.Curr.X == e.Bot.X &&\n          eNext.Curr.Y == e.Bot.Y && op !== null &&\n          eNext.OutIdx >= 0 && eNext.Curr.Y > eNext.Top.Y &&\n          ClipperLib.ClipperBase.SlopesEqual(e, eNext, this.m_UseFullRange) &&\n          (e.WindDelta !== 0) && (eNext.WindDelta !== 0))\n        {\n          var op2 = this.AddOutPt(eNext, e.Bot);\n          this.AddJoin(op, op2, e.Top);\n        }\n      }\n      e = e.NextInAEL;\n    }\n  };\n  ClipperLib.Clipper.prototype.DoMaxima = function (e)\n  {\n    var eMaxPair = this.GetMaximaPair(e);\n    if (eMaxPair === null)\n    {\n      if (e.OutIdx >= 0)\n        this.AddOutPt(e, e.Top);\n      this.DeleteFromAEL(e);\n      return;\n    }\n    var eNext = e.NextInAEL;\n    var use_lines = true;\n    while (eNext !== null && eNext != eMaxPair)\n    {\n      this.IntersectEdges(e, eNext, e.Top);\n      this.SwapPositionsInAEL(e, eNext);\n      eNext = e.NextInAEL;\n    }\n    if (e.OutIdx == -1 && eMaxPair.OutIdx == -1)\n    {\n      this.DeleteFromAEL(e);\n      this.DeleteFromAEL(eMaxPair);\n    }\n    else if (e.OutIdx >= 0 && eMaxPair.OutIdx >= 0)\n    {\n    \tif (e.OutIdx >= 0) this.AddLocalMaxPoly(e, eMaxPair, e.Top);\n      this.DeleteFromAEL(e);\n      this.DeleteFromAEL(eMaxPair);\n    }\n    else if (use_lines && e.WindDelta === 0)\n    {\n      if (e.OutIdx >= 0)\n      {\n        this.AddOutPt(e, e.Top);\n        e.OutIdx = -1;\n      }\n      this.DeleteFromAEL(e);\n      if (eMaxPair.OutIdx >= 0)\n      {\n        this.AddOutPt(eMaxPair, e.Top);\n        eMaxPair.OutIdx = -1;\n      }\n      this.DeleteFromAEL(eMaxPair);\n    }\n    else\n      ClipperLib.Error(\"DoMaxima error\");\n  };\n  ClipperLib.Clipper.ReversePaths = function (polys)\n  {\n    for (var i = 0, len = polys.length; i < len; i++)\n      polys[i].reverse();\n  };\n  ClipperLib.Clipper.Orientation = function (poly)\n  {\n    return ClipperLib.Clipper.Area(poly) >= 0;\n  };\n  ClipperLib.Clipper.prototype.PointCount = function (pts)\n  {\n    if (pts === null)\n      return 0;\n    var result = 0;\n    var p = pts;\n    do {\n      result++;\n      p = p.Next;\n    }\n    while (p != pts)\n    return result;\n  };\n  ClipperLib.Clipper.prototype.BuildResult = function (polyg)\n  {\n    ClipperLib.Clear(polyg);\n    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n    {\n      var outRec = this.m_PolyOuts[i];\n      if (outRec.Pts === null)\n        continue;\n      var p = outRec.Pts.Prev;\n      var cnt = this.PointCount(p);\n      if (cnt < 2)\n        continue;\n      var pg = new Array(cnt);\n      for (var j = 0; j < cnt; j++)\n      {\n        pg[j] = p.Pt;\n        p = p.Prev;\n      }\n      polyg.push(pg);\n    }\n  };\n  ClipperLib.Clipper.prototype.BuildResult2 = function (polytree)\n  {\n    polytree.Clear();\n    //add each output polygon/contour to polytree ...\n    //polytree.m_AllPolys.set_Capacity(this.m_PolyOuts.length);\n    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n    {\n      var outRec = this.m_PolyOuts[i];\n      var cnt = this.PointCount(outRec.Pts);\n      if ((outRec.IsOpen && cnt < 2) || (!outRec.IsOpen && cnt < 3))\n        continue;\n      this.FixHoleLinkage(outRec);\n      var pn = new ClipperLib.PolyNode();\n      polytree.m_AllPolys.push(pn);\n      outRec.PolyNode = pn;\n      pn.m_polygon.length = cnt;\n      var op = outRec.Pts.Prev;\n      for (var j = 0; j < cnt; j++)\n      {\n        pn.m_polygon[j] = op.Pt;\n        op = op.Prev;\n      }\n    }\n    //fixup PolyNode links etc ...\n    //polytree.m_Childs.set_Capacity(this.m_PolyOuts.length);\n    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n    {\n      var outRec = this.m_PolyOuts[i];\n      if (outRec.PolyNode === null)\n        continue;\n      else if (outRec.IsOpen)\n      {\n        outRec.PolyNode.IsOpen = true;\n        polytree.AddChild(outRec.PolyNode);\n      }\n      else if (outRec.FirstLeft !== null && outRec.FirstLeft.PolyNode != null)\n        outRec.FirstLeft.PolyNode.AddChild(outRec.PolyNode);\n      else\n        polytree.AddChild(outRec.PolyNode);\n    }\n  };\n  ClipperLib.Clipper.prototype.FixupOutPolygon = function (outRec)\n  {\n    //FixupOutPolygon() - removes duplicate points and simplifies consecutive\n    //parallel edges by removing the middle vertex.\n    var lastOK = null;\n    outRec.BottomPt = null;\n    var pp = outRec.Pts;\n    for (;;)\n    {\n      if (pp.Prev == pp || pp.Prev == pp.Next)\n      {\n        outRec.Pts = null;\n        return;\n      }\n      //test for duplicate points and collinear edges ...\n      if ((ClipperLib.IntPoint.op_Equality(pp.Pt, pp.Next.Pt)) || (ClipperLib.IntPoint.op_Equality(pp.Pt, pp.Prev.Pt)) ||\n        (ClipperLib.ClipperBase.SlopesEqual(pp.Prev.Pt, pp.Pt, pp.Next.Pt, this.m_UseFullRange) &&\n          (!this.PreserveCollinear || !this.Pt2IsBetweenPt1AndPt3(pp.Prev.Pt, pp.Pt, pp.Next.Pt))))\n      {\n        lastOK = null;\n        pp.Prev.Next = pp.Next;\n        pp.Next.Prev = pp.Prev;\n        pp = pp.Prev;\n      }\n      else if (pp == lastOK)\n        break;\n      else\n      {\n        if (lastOK === null)\n          lastOK = pp;\n        pp = pp.Next;\n      }\n    }\n    outRec.Pts = pp;\n  };\n  ClipperLib.Clipper.prototype.DupOutPt = function (outPt, InsertAfter)\n  {\n    var result = new ClipperLib.OutPt();\n    //result.Pt = outPt.Pt;\n    result.Pt.X = outPt.Pt.X;\n    result.Pt.Y = outPt.Pt.Y;\n    result.Idx = outPt.Idx;\n    if (InsertAfter)\n    {\n      result.Next = outPt.Next;\n      result.Prev = outPt;\n      outPt.Next.Prev = result;\n      outPt.Next = result;\n    }\n    else\n    {\n      result.Prev = outPt.Prev;\n      result.Next = outPt;\n      outPt.Prev.Next = result;\n      outPt.Prev = result;\n    }\n    return result;\n  };\n  ClipperLib.Clipper.prototype.GetOverlap = function (a1, a2, b1, b2, $val)\n  {\n    if (a1 < a2)\n    {\n      if (b1 < b2)\n      {\n        $val.Left = Math.max(a1, b1);\n        $val.Right = Math.min(a2, b2);\n      }\n      else\n      {\n        $val.Left = Math.max(a1, b2);\n        $val.Right = Math.min(a2, b1);\n      }\n    }\n    else\n    {\n      if (b1 < b2)\n      {\n        $val.Left = Math.max(a2, b1);\n        $val.Right = Math.min(a1, b2);\n      }\n      else\n      {\n        $val.Left = Math.max(a2, b2);\n        $val.Right = Math.min(a1, b1);\n      }\n    }\n    return $val.Left < $val.Right;\n  };\n  ClipperLib.Clipper.prototype.JoinHorz = function (op1, op1b, op2, op2b, Pt, DiscardLeft)\n  {\n    var Dir1 = (op1.Pt.X > op1b.Pt.X ? ClipperLib.Direction.dRightToLeft : ClipperLib.Direction.dLeftToRight);\n    var Dir2 = (op2.Pt.X > op2b.Pt.X ? ClipperLib.Direction.dRightToLeft : ClipperLib.Direction.dLeftToRight);\n    if (Dir1 == Dir2)\n      return false;\n    //When DiscardLeft, we want Op1b to be on the Left of Op1, otherwise we\n    //want Op1b to be on the Right. (And likewise with Op2 and Op2b.)\n    //So, to facilitate this while inserting Op1b and Op2b ...\n    //when DiscardLeft, make sure we're AT or RIGHT of Pt before adding Op1b,\n    //otherwise make sure we're AT or LEFT of Pt. (Likewise with Op2b.)\n    if (Dir1 == ClipperLib.Direction.dLeftToRight)\n    {\n      while (op1.Next.Pt.X <= Pt.X &&\n        op1.Next.Pt.X >= op1.Pt.X && op1.Next.Pt.Y == Pt.Y)\n        op1 = op1.Next;\n      if (DiscardLeft && (op1.Pt.X != Pt.X))\n        op1 = op1.Next;\n      op1b = this.DupOutPt(op1, !DiscardLeft);\n      if (ClipperLib.IntPoint.op_Inequality(op1b.Pt, Pt))\n      {\n        op1 = op1b;\n        //op1.Pt = Pt;\n        op1.Pt.X = Pt.X;\n        op1.Pt.Y = Pt.Y;\n        op1b = this.DupOutPt(op1, !DiscardLeft);\n      }\n    }\n    else\n    {\n      while (op1.Next.Pt.X >= Pt.X &&\n        op1.Next.Pt.X <= op1.Pt.X && op1.Next.Pt.Y == Pt.Y)\n        op1 = op1.Next;\n      if (!DiscardLeft && (op1.Pt.X != Pt.X))\n        op1 = op1.Next;\n      op1b = this.DupOutPt(op1, DiscardLeft);\n      if (ClipperLib.IntPoint.op_Inequality(op1b.Pt, Pt))\n      {\n        op1 = op1b;\n        //op1.Pt = Pt;\n        op1.Pt.X = Pt.X;\n        op1.Pt.Y = Pt.Y;\n        op1b = this.DupOutPt(op1, DiscardLeft);\n      }\n    }\n    if (Dir2 == ClipperLib.Direction.dLeftToRight)\n    {\n      while (op2.Next.Pt.X <= Pt.X &&\n        op2.Next.Pt.X >= op2.Pt.X && op2.Next.Pt.Y == Pt.Y)\n        op2 = op2.Next;\n      if (DiscardLeft && (op2.Pt.X != Pt.X))\n        op2 = op2.Next;\n      op2b = this.DupOutPt(op2, !DiscardLeft);\n      if (ClipperLib.IntPoint.op_Inequality(op2b.Pt, Pt))\n      {\n        op2 = op2b;\n        //op2.Pt = Pt;\n        op2.Pt.X = Pt.X;\n        op2.Pt.Y = Pt.Y;\n        op2b = this.DupOutPt(op2, !DiscardLeft);\n      }\n    }\n    else\n    {\n      while (op2.Next.Pt.X >= Pt.X &&\n        op2.Next.Pt.X <= op2.Pt.X && op2.Next.Pt.Y == Pt.Y)\n        op2 = op2.Next;\n      if (!DiscardLeft && (op2.Pt.X != Pt.X))\n        op2 = op2.Next;\n      op2b = this.DupOutPt(op2, DiscardLeft);\n      if (ClipperLib.IntPoint.op_Inequality(op2b.Pt, Pt))\n      {\n        op2 = op2b;\n        //op2.Pt = Pt;\n        op2.Pt.X = Pt.X;\n        op2.Pt.Y = Pt.Y;\n        op2b = this.DupOutPt(op2, DiscardLeft);\n      }\n    }\n    if ((Dir1 == ClipperLib.Direction.dLeftToRight) == DiscardLeft)\n    {\n      op1.Prev = op2;\n      op2.Next = op1;\n      op1b.Next = op2b;\n      op2b.Prev = op1b;\n    }\n    else\n    {\n      op1.Next = op2;\n      op2.Prev = op1;\n      op1b.Prev = op2b;\n      op2b.Next = op1b;\n    }\n    return true;\n  };\n  ClipperLib.Clipper.prototype.JoinPoints = function (j, outRec1, outRec2)\n  {\n    var op1 = j.OutPt1,\n      op1b = new ClipperLib.OutPt();\n    var op2 = j.OutPt2,\n      op2b = new ClipperLib.OutPt();\n    //There are 3 kinds of joins for output polygons ...\n    //1. Horizontal joins where Join.OutPt1 & Join.OutPt2 are a vertices anywhere\n    //along (horizontal) collinear edges (& Join.OffPt is on the same horizontal).\n    //2. Non-horizontal joins where Join.OutPt1 & Join.OutPt2 are at the same\n    //location at the Bottom of the overlapping segment (& Join.OffPt is above).\n    //3. StrictlySimple joins where edges touch but are not collinear and where\n    //Join.OutPt1, Join.OutPt2 & Join.OffPt all share the same point.\n    var isHorizontal = (j.OutPt1.Pt.Y == j.OffPt.Y);\n    if (isHorizontal && (ClipperLib.IntPoint.op_Equality(j.OffPt, j.OutPt1.Pt)) && (ClipperLib.IntPoint.op_Equality(j.OffPt, j.OutPt2.Pt)))\n    {\n      //Strictly Simple join ...\n\t\t\tif (outRec1 != outRec2) return false;\n\n      op1b = j.OutPt1.Next;\n      while (op1b != op1 && (ClipperLib.IntPoint.op_Equality(op1b.Pt, j.OffPt)))\n        op1b = op1b.Next;\n      var reverse1 = (op1b.Pt.Y > j.OffPt.Y);\n      op2b = j.OutPt2.Next;\n      while (op2b != op2 && (ClipperLib.IntPoint.op_Equality(op2b.Pt, j.OffPt)))\n        op2b = op2b.Next;\n      var reverse2 = (op2b.Pt.Y > j.OffPt.Y);\n      if (reverse1 == reverse2)\n        return false;\n      if (reverse1)\n      {\n        op1b = this.DupOutPt(op1, false);\n        op2b = this.DupOutPt(op2, true);\n        op1.Prev = op2;\n        op2.Next = op1;\n        op1b.Next = op2b;\n        op2b.Prev = op1b;\n        j.OutPt1 = op1;\n        j.OutPt2 = op1b;\n        return true;\n      }\n      else\n      {\n        op1b = this.DupOutPt(op1, true);\n        op2b = this.DupOutPt(op2, false);\n        op1.Next = op2;\n        op2.Prev = op1;\n        op1b.Prev = op2b;\n        op2b.Next = op1b;\n        j.OutPt1 = op1;\n        j.OutPt2 = op1b;\n        return true;\n      }\n    }\n    else if (isHorizontal)\n    {\n      //treat horizontal joins differently to non-horizontal joins since with\n      //them we're not yet sure where the overlapping is. OutPt1.Pt & OutPt2.Pt\n      //may be anywhere along the horizontal edge.\n      op1b = op1;\n      while (op1.Prev.Pt.Y == op1.Pt.Y && op1.Prev != op1b && op1.Prev != op2)\n        op1 = op1.Prev;\n      while (op1b.Next.Pt.Y == op1b.Pt.Y && op1b.Next != op1 && op1b.Next != op2)\n        op1b = op1b.Next;\n      if (op1b.Next == op1 || op1b.Next == op2)\n        return false;\n      //a flat 'polygon'\n      op2b = op2;\n      while (op2.Prev.Pt.Y == op2.Pt.Y && op2.Prev != op2b && op2.Prev != op1b)\n        op2 = op2.Prev;\n      while (op2b.Next.Pt.Y == op2b.Pt.Y && op2b.Next != op2 && op2b.Next != op1)\n        op2b = op2b.Next;\n      if (op2b.Next == op2 || op2b.Next == op1)\n        return false;\n      //a flat 'polygon'\n      //Op1 -. Op1b & Op2 -. Op2b are the extremites of the horizontal edges\n\n      var $val = {Left: null, Right: null};\n      if (!this.GetOverlap(op1.Pt.X, op1b.Pt.X, op2.Pt.X, op2b.Pt.X, $val))\n        return false;\n      var Left = $val.Left;\n      var Right = $val.Right;\n\n      //DiscardLeftSide: when overlapping edges are joined, a spike will created\n      //which needs to be cleaned up. However, we don't want Op1 or Op2 caught up\n      //on the discard Side as either may still be needed for other joins ...\n      var Pt = new ClipperLib.IntPoint();\n      var DiscardLeftSide;\n      if (op1.Pt.X >= Left && op1.Pt.X <= Right)\n      {\n        //Pt = op1.Pt;\n        Pt.X = op1.Pt.X;\n        Pt.Y = op1.Pt.Y;\n        DiscardLeftSide = (op1.Pt.X > op1b.Pt.X);\n      }\n      else if (op2.Pt.X >= Left && op2.Pt.X <= Right)\n      {\n        //Pt = op2.Pt;\n        Pt.X = op2.Pt.X;\n        Pt.Y = op2.Pt.Y;\n        DiscardLeftSide = (op2.Pt.X > op2b.Pt.X);\n      }\n      else if (op1b.Pt.X >= Left && op1b.Pt.X <= Right)\n      {\n        //Pt = op1b.Pt;\n        Pt.X = op1b.Pt.X;\n        Pt.Y = op1b.Pt.Y;\n        DiscardLeftSide = op1b.Pt.X > op1.Pt.X;\n      }\n      else\n      {\n        //Pt = op2b.Pt;\n        Pt.X = op2b.Pt.X;\n        Pt.Y = op2b.Pt.Y;\n        DiscardLeftSide = (op2b.Pt.X > op2.Pt.X);\n      }\n      j.OutPt1 = op1;\n      j.OutPt2 = op2;\n      return this.JoinHorz(op1, op1b, op2, op2b, Pt, DiscardLeftSide);\n    }\n    else\n    {\n      //nb: For non-horizontal joins ...\n      //    1. Jr.OutPt1.Pt.Y == Jr.OutPt2.Pt.Y\n      //    2. Jr.OutPt1.Pt > Jr.OffPt.Y\n      //make sure the polygons are correctly oriented ...\n      op1b = op1.Next;\n      while ((ClipperLib.IntPoint.op_Equality(op1b.Pt, op1.Pt)) && (op1b != op1))\n        op1b = op1b.Next;\n      var Reverse1 = ((op1b.Pt.Y > op1.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual(op1.Pt, op1b.Pt, j.OffPt, this.m_UseFullRange));\n      if (Reverse1)\n      {\n        op1b = op1.Prev;\n        while ((ClipperLib.IntPoint.op_Equality(op1b.Pt, op1.Pt)) && (op1b != op1))\n          op1b = op1b.Prev;\n        if ((op1b.Pt.Y > op1.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual(op1.Pt, op1b.Pt, j.OffPt, this.m_UseFullRange))\n          return false;\n      }\n      op2b = op2.Next;\n      while ((ClipperLib.IntPoint.op_Equality(op2b.Pt, op2.Pt)) && (op2b != op2))\n        op2b = op2b.Next;\n      var Reverse2 = ((op2b.Pt.Y > op2.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual(op2.Pt, op2b.Pt, j.OffPt, this.m_UseFullRange));\n      if (Reverse2)\n      {\n        op2b = op2.Prev;\n        while ((ClipperLib.IntPoint.op_Equality(op2b.Pt, op2.Pt)) && (op2b != op2))\n          op2b = op2b.Prev;\n        if ((op2b.Pt.Y > op2.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual(op2.Pt, op2b.Pt, j.OffPt, this.m_UseFullRange))\n          return false;\n      }\n      if ((op1b == op1) || (op2b == op2) || (op1b == op2b) ||\n        ((outRec1 == outRec2) && (Reverse1 == Reverse2)))\n        return false;\n      if (Reverse1)\n      {\n        op1b = this.DupOutPt(op1, false);\n        op2b = this.DupOutPt(op2, true);\n        op1.Prev = op2;\n        op2.Next = op1;\n        op1b.Next = op2b;\n        op2b.Prev = op1b;\n        j.OutPt1 = op1;\n        j.OutPt2 = op1b;\n        return true;\n      }\n      else\n      {\n        op1b = this.DupOutPt(op1, true);\n        op2b = this.DupOutPt(op2, false);\n        op1.Next = op2;\n        op2.Prev = op1;\n        op1b.Prev = op2b;\n        op2b.Next = op1b;\n        j.OutPt1 = op1;\n        j.OutPt2 = op1b;\n        return true;\n      }\n    }\n  };\n  ClipperLib.Clipper.GetBounds = function (paths)\n  {\n    var i = 0,\n      cnt = paths.length;\n    while (i < cnt && paths[i].length == 0) i++;\n    if (i == cnt) return new ClipperLib.IntRect(0, 0, 0, 0);\n    var result = new ClipperLib.IntRect();\n    result.left = paths[i][0].X;\n    result.right = result.left;\n    result.top = paths[i][0].Y;\n    result.bottom = result.top;\n    for (; i < cnt; i++)\n      for (var j = 0, jlen = paths[i].length; j < jlen; j++)\n      {\n        if (paths[i][j].X < result.left) result.left = paths[i][j].X;\n        else if (paths[i][j].X > result.right) result.right = paths[i][j].X;\n        if (paths[i][j].Y < result.top) result.top = paths[i][j].Y;\n        else if (paths[i][j].Y > result.bottom) result.bottom = paths[i][j].Y;\n      }\n    return result;\n  }\n  ClipperLib.Clipper.prototype.GetBounds2 = function (ops)\n  {\n    var opStart = ops;\n    var result = new ClipperLib.IntRect();\n    result.left = ops.Pt.X;\n    result.right = ops.Pt.X;\n    result.top = ops.Pt.Y;\n    result.bottom = ops.Pt.Y;\n    ops = ops.Next;\n    while (ops != opStart)\n    {\n      if (ops.Pt.X < result.left)\n        result.left = ops.Pt.X;\n      if (ops.Pt.X > result.right)\n        result.right = ops.Pt.X;\n      if (ops.Pt.Y < result.top)\n        result.top = ops.Pt.Y;\n      if (ops.Pt.Y > result.bottom)\n        result.bottom = ops.Pt.Y;\n      ops = ops.Next;\n    }\n    return result;\n  };\n\n  ClipperLib.Clipper.PointInPolygon = function (pt, path)\n  {\n    //returns 0 if false, +1 if true, -1 if pt ON polygon boundary\n\t\t//See \"The Point in Polygon Problem for Arbitrary Polygons\" by Hormann & Agathos\n    //http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.88.5498&rep=rep1&type=pdf\n    var result = 0,\n      cnt = path.length;\n    if (cnt < 3)\n      return 0;\n    var ip = path[0];\n    for (var i = 1; i <= cnt; ++i)\n    {\n      var ipNext = (i == cnt ? path[0] : path[i]);\n      if (ipNext.Y == pt.Y)\n      {\n        if ((ipNext.X == pt.X) || (ip.Y == pt.Y && ((ipNext.X > pt.X) == (ip.X < pt.X))))\n          return -1;\n      }\n      if ((ip.Y < pt.Y) != (ipNext.Y < pt.Y))\n      {\n        if (ip.X >= pt.X)\n        {\n          if (ipNext.X > pt.X)\n            result = 1 - result;\n          else\n          {\n            var d = (ip.X - pt.X) * (ipNext.Y - pt.Y) - (ipNext.X - pt.X) * (ip.Y - pt.Y);\n            if (d == 0)\n              return -1;\n            else if ((d > 0) == (ipNext.Y > ip.Y))\n              result = 1 - result;\n          }\n        }\n        else\n        {\n          if (ipNext.X > pt.X)\n          {\n            var d = (ip.X - pt.X) * (ipNext.Y - pt.Y) - (ipNext.X - pt.X) * (ip.Y - pt.Y);\n            if (d == 0)\n              return -1;\n            else if ((d > 0) == (ipNext.Y > ip.Y))\n              result = 1 - result;\n          }\n        }\n      }\n      ip = ipNext;\n    }\n    return result;\n  };\n\n  ClipperLib.Clipper.prototype.PointInPolygon = function (pt, op)\n  {\n    //returns 0 if false, +1 if true, -1 if pt ON polygon boundary\n\t\t//See \"The Point in Polygon Problem for Arbitrary Polygons\" by Hormann & Agathos\n    //http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.88.5498&rep=rep1&type=pdf\n    var result = 0;\n    var startOp = op;\n\t\tvar ptx = pt.X, pty = pt.Y;\n    var poly0x = op.Pt.X, poly0y = op.Pt.Y;\n    do\n    {\n\t\t\top = op.Next;\n\t\t\tvar poly1x = op.Pt.X, poly1y = op.Pt.Y;\n      if (poly1y == pty)\n      {\n        if ((poly1x == ptx) || (poly0y == pty && ((poly1x > ptx) == (poly0x < ptx))))\n          return -1;\n      }\n      if ((poly0y < pty) != (poly1y < pty))\n      {\n        if (poly0x >= ptx)\n        {\n          if (poly1x > ptx)\n            result = 1 - result;\n          else\n          {\n            var d = (poly0x - ptx) * (poly1y - pty) - (poly1x - ptx) * (poly0y - pty);\n            if (d == 0)\n              return -1;\n            if ((d > 0) == (poly1y > poly0y))\n              result = 1 - result;\n          }\n        }\n        else\n        {\n          if (poly1x > ptx)\n          {\n            var d = (poly0x - ptx) * (poly1y - pty) - (poly1x - ptx) * (poly0y - pty);\n            if (d == 0)\n              return -1;\n            if ((d > 0) == (poly1y > poly0y))\n              result = 1 - result;\n          }\n        }\n      }\n      poly0x = poly1x;\n      poly0y = poly1y;\n    } while (startOp != op);\n\n    return result;\n  };\n\n  ClipperLib.Clipper.prototype.Poly2ContainsPoly1 = function (outPt1, outPt2)\n  {\n    var op = outPt1;\n    do\n    {\n\t\t\t//nb: PointInPolygon returns 0 if false, +1 if true, -1 if pt on polygon\n      var res = this.PointInPolygon(op.Pt, outPt2);\n      if (res >= 0)\n        return res > 0;\n      op = op.Next;\n    }\n    while (op != outPt1)\n    return true;\n  };\n  ClipperLib.Clipper.prototype.FixupFirstLefts1 = function (OldOutRec, NewOutRec)\n  {\n    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n    {\n\t\t\tvar outRec = this.m_PolyOuts[i];\n\t\t\tif (outRec.Pts == null || outRec.FirstLeft == null)\n\t\t\t\tcontinue;\n\t\t\tvar firstLeft = this.ParseFirstLeft(outRec.FirstLeft);\n\t\t\tif (firstLeft == OldOutRec)\n\t\t\t{\n        if (this.Poly2ContainsPoly1(outRec.Pts, NewOutRec.Pts))\n          outRec.FirstLeft = NewOutRec;\n      }\n    }\n  };\n  ClipperLib.Clipper.prototype.FixupFirstLefts2 = function (OldOutRec, NewOutRec)\n  {\n    for (var $i2 = 0, $t2 = this.m_PolyOuts, $l2 = $t2.length, outRec = $t2[$i2]; $i2 < $l2; $i2++, outRec = $t2[$i2])\n      if (outRec.FirstLeft == OldOutRec)\n        outRec.FirstLeft = NewOutRec;\n  };\n  ClipperLib.Clipper.ParseFirstLeft = function (FirstLeft)\n  {\n    while (FirstLeft != null && FirstLeft.Pts == null)\n      FirstLeft = FirstLeft.FirstLeft;\n    return FirstLeft;\n  };\n  ClipperLib.Clipper.prototype.JoinCommonEdges = function ()\n  {\n    for (var i = 0, ilen = this.m_Joins.length; i < ilen; i++)\n    {\n      var join = this.m_Joins[i];\n      var outRec1 = this.GetOutRec(join.OutPt1.Idx);\n      var outRec2 = this.GetOutRec(join.OutPt2.Idx);\n      if (outRec1.Pts == null || outRec2.Pts == null)\n        continue;\n      //get the polygon fragment with the correct hole state (FirstLeft)\n      //before calling JoinPoints() ...\n      var holeStateRec;\n      if (outRec1 == outRec2)\n        holeStateRec = outRec1;\n      else if (this.Param1RightOfParam2(outRec1, outRec2))\n        holeStateRec = outRec2;\n      else if (this.Param1RightOfParam2(outRec2, outRec1))\n        holeStateRec = outRec1;\n      else\n        holeStateRec = this.GetLowermostRec(outRec1, outRec2);\n\n      if (!this.JoinPoints(join, outRec1, outRec2)) continue;\n\n      if (outRec1 == outRec2)\n      {\n        //instead of joining two polygons, we've just created a new one by\n        //splitting one polygon into two.\n        outRec1.Pts = join.OutPt1;\n        outRec1.BottomPt = null;\n        outRec2 = this.CreateOutRec();\n        outRec2.Pts = join.OutPt2;\n        //update all OutRec2.Pts Idx's ...\n        this.UpdateOutPtIdxs(outRec2);\n        //We now need to check every OutRec.FirstLeft pointer. If it points\n        //to OutRec1 it may need to point to OutRec2 instead ...\n        if (this.m_UsingPolyTree)\n          for (var j = 0, jlen = this.m_PolyOuts.length; j < jlen - 1; j++)\n          {\n            var oRec = this.m_PolyOuts[j];\n            if (oRec.Pts == null || ClipperLib.Clipper.ParseFirstLeft(oRec.FirstLeft) != outRec1 || oRec.IsHole == outRec1.IsHole)\n              continue;\n            if (this.Poly2ContainsPoly1(oRec.Pts, join.OutPt2))\n              oRec.FirstLeft = outRec2;\n          }\n        if (this.Poly2ContainsPoly1(outRec2.Pts, outRec1.Pts))\n        {\n          //outRec2 is contained by outRec1 ...\n          outRec2.IsHole = !outRec1.IsHole;\n          outRec2.FirstLeft = outRec1;\n          //fixup FirstLeft pointers that may need reassigning to OutRec1\n          if (this.m_UsingPolyTree)\n            this.FixupFirstLefts2(outRec2, outRec1);\n          if ((outRec2.IsHole ^ this.ReverseSolution) == (this.Area(outRec2) > 0))\n            this.ReversePolyPtLinks(outRec2.Pts);\n        }\n        else if (this.Poly2ContainsPoly1(outRec1.Pts, outRec2.Pts))\n        {\n          //outRec1 is contained by outRec2 ...\n          outRec2.IsHole = outRec1.IsHole;\n          outRec1.IsHole = !outRec2.IsHole;\n          outRec2.FirstLeft = outRec1.FirstLeft;\n          outRec1.FirstLeft = outRec2;\n          //fixup FirstLeft pointers that may need reassigning to OutRec1\n          if (this.m_UsingPolyTree)\n            this.FixupFirstLefts2(outRec1, outRec2);\n          if ((outRec1.IsHole ^ this.ReverseSolution) == (this.Area(outRec1) > 0))\n            this.ReversePolyPtLinks(outRec1.Pts);\n        }\n        else\n        {\n          //the 2 polygons are completely separate ...\n          outRec2.IsHole = outRec1.IsHole;\n          outRec2.FirstLeft = outRec1.FirstLeft;\n          //fixup FirstLeft pointers that may need reassigning to OutRec2\n          if (this.m_UsingPolyTree)\n            this.FixupFirstLefts1(outRec1, outRec2);\n        }\n      }\n      else\n      {\n        //joined 2 polygons together ...\n        outRec2.Pts = null;\n        outRec2.BottomPt = null;\n        outRec2.Idx = outRec1.Idx;\n        outRec1.IsHole = holeStateRec.IsHole;\n        if (holeStateRec == outRec2)\n          outRec1.FirstLeft = outRec2.FirstLeft;\n        outRec2.FirstLeft = outRec1;\n        //fixup FirstLeft pointers that may need reassigning to OutRec1\n        if (this.m_UsingPolyTree)\n          this.FixupFirstLefts2(outRec2, outRec1);\n      }\n    }\n  };\n  ClipperLib.Clipper.prototype.UpdateOutPtIdxs = function (outrec)\n  {\n    var op = outrec.Pts;\n    do {\n      op.Idx = outrec.Idx;\n      op = op.Prev;\n    }\n    while (op != outrec.Pts)\n  };\n  ClipperLib.Clipper.prototype.DoSimplePolygons = function ()\n  {\n    var i = 0;\n    while (i < this.m_PolyOuts.length)\n    {\n      var outrec = this.m_PolyOuts[i++];\n      var op = outrec.Pts;\n\t\t\tif (op == null || outrec.IsOpen)\n\t\t\t\tcontinue;\n      do //for each Pt in Polygon until duplicate found do ...\n      {\n        var op2 = op.Next;\n        while (op2 != outrec.Pts)\n        {\n          if ((ClipperLib.IntPoint.op_Equality(op.Pt, op2.Pt)) && op2.Next != op && op2.Prev != op)\n          {\n            //split the polygon into two ...\n            var op3 = op.Prev;\n            var op4 = op2.Prev;\n            op.Prev = op4;\n            op4.Next = op;\n            op2.Prev = op3;\n            op3.Next = op2;\n            outrec.Pts = op;\n            var outrec2 = this.CreateOutRec();\n            outrec2.Pts = op2;\n            this.UpdateOutPtIdxs(outrec2);\n            if (this.Poly2ContainsPoly1(outrec2.Pts, outrec.Pts))\n            {\n              //OutRec2 is contained by OutRec1 ...\n              outrec2.IsHole = !outrec.IsHole;\n              outrec2.FirstLeft = outrec;\n\t\t\t\t\t\t\tif (this.m_UsingPolyTree) this.FixupFirstLefts2(outrec2, outrec);\n\n            }\n            else if (this.Poly2ContainsPoly1(outrec.Pts, outrec2.Pts))\n            {\n              //OutRec1 is contained by OutRec2 ...\n              outrec2.IsHole = outrec.IsHole;\n              outrec.IsHole = !outrec2.IsHole;\n              outrec2.FirstLeft = outrec.FirstLeft;\n              outrec.FirstLeft = outrec2;\n              if (this.m_UsingPolyTree) this.FixupFirstLefts2(outrec, outrec2);\n            }\n            else\n            {\n              //the 2 polygons are separate ...\n              outrec2.IsHole = outrec.IsHole;\n              outrec2.FirstLeft = outrec.FirstLeft;\n\t\t\t\t\t\t\tif (this.m_UsingPolyTree) this.FixupFirstLefts1(outrec, outrec2);\n            }\n            op2 = op;\n            //ie get ready for the next iteration\n          }\n          op2 = op2.Next;\n        }\n        op = op.Next;\n      }\n      while (op != outrec.Pts)\n    }\n  };\n  ClipperLib.Clipper.Area = function (poly)\n  {\n    var cnt = poly.length;\n    if (cnt < 3)\n      return 0;\n    var a = 0;\n    for (var i = 0, j = cnt - 1; i < cnt; ++i)\n    {\n      a += (poly[j].X + poly[i].X) * (poly[j].Y - poly[i].Y);\n      j = i;\n    }\n    return -a * 0.5;\n  };\n  ClipperLib.Clipper.prototype.Area = function (outRec)\n  {\n    var op = outRec.Pts;\n    if (op == null)\n      return 0;\n    var a = 0;\n    do {\n      a = a + (op.Prev.Pt.X + op.Pt.X) * (op.Prev.Pt.Y - op.Pt.Y);\n      op = op.Next;\n    }\n    while (op != outRec.Pts)\n    return a * 0.5;\n  };\n  ClipperLib.Clipper.SimplifyPolygon = function (poly, fillType)\n  {\n    var result = new Array();\n    var c = new ClipperLib.Clipper(0);\n    c.StrictlySimple = true;\n    c.AddPath(poly, ClipperLib.PolyType.ptSubject, true);\n    c.Execute(ClipperLib.ClipType.ctUnion, result, fillType, fillType);\n    return result;\n  };\n  ClipperLib.Clipper.SimplifyPolygons = function (polys, fillType)\n  {\n    if (typeof (fillType) == \"undefined\") fillType = ClipperLib.PolyFillType.pftEvenOdd;\n    var result = new Array();\n    var c = new ClipperLib.Clipper(0);\n    c.StrictlySimple = true;\n    c.AddPaths(polys, ClipperLib.PolyType.ptSubject, true);\n    c.Execute(ClipperLib.ClipType.ctUnion, result, fillType, fillType);\n    return result;\n  };\n  ClipperLib.Clipper.DistanceSqrd = function (pt1, pt2)\n  {\n    var dx = (pt1.X - pt2.X);\n    var dy = (pt1.Y - pt2.Y);\n    return (dx * dx + dy * dy);\n  };\n  ClipperLib.Clipper.DistanceFromLineSqrd = function (pt, ln1, ln2)\n  {\n    //The equation of a line in general form (Ax + By + C = 0)\n    //given 2 points (x¹,y¹) & (x²,y²) is ...\n    //(y¹ - y²)x + (x² - x¹)y + (y² - y¹)x¹ - (x² - x¹)y¹ = 0\n    //A = (y¹ - y²); B = (x² - x¹); C = (y² - y¹)x¹ - (x² - x¹)y¹\n    //perpendicular distance of point (x³,y³) = (Ax³ + By³ + C)/Sqrt(A² + B²)\n    //see http://en.wikipedia.org/wiki/Perpendicular_distance\n    var A = ln1.Y - ln2.Y;\n    var B = ln2.X - ln1.X;\n    var C = A * ln1.X + B * ln1.Y;\n    C = A * pt.X + B * pt.Y - C;\n    return (C * C) / (A * A + B * B);\n  };\n\n\tClipperLib.Clipper.SlopesNearCollinear = function(pt1, pt2, pt3, distSqrd)\n\t{\n\t\t//this function is more accurate when the point that's GEOMETRICALLY\n\t\t//between the other 2 points is the one that's tested for distance.\n\t\t//nb: with 'spikes', either pt1 or pt3 is geometrically between the other pts\n\t\tif (Math.abs(pt1.X - pt2.X) > Math.abs(pt1.Y - pt2.Y))\n\t\t{\n\t\tif ((pt1.X > pt2.X) == (pt1.X < pt3.X))\n\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt1, pt2, pt3) < distSqrd;\n\t\telse if ((pt2.X > pt1.X) == (pt2.X < pt3.X))\n\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt2, pt1, pt3) < distSqrd;\n\t\t\t\telse\n\t\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt3, pt1, pt2) < distSqrd;\n\t\t}\n\t\telse\n\t\t{\n\t\tif ((pt1.Y > pt2.Y) == (pt1.Y < pt3.Y))\n\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt1, pt2, pt3) < distSqrd;\n\t\telse if ((pt2.Y > pt1.Y) == (pt2.Y < pt3.Y))\n\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt2, pt1, pt3) < distSqrd;\n\t\t\t\telse\n\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt3, pt1, pt2) < distSqrd;\n\t\t}\n\t}\n\n  ClipperLib.Clipper.PointsAreClose = function (pt1, pt2, distSqrd)\n  {\n    var dx = pt1.X - pt2.X;\n    var dy = pt1.Y - pt2.Y;\n    return ((dx * dx) + (dy * dy) <= distSqrd);\n  };\n  //------------------------------------------------------------------------------\n  ClipperLib.Clipper.ExcludeOp = function (op)\n  {\n    var result = op.Prev;\n    result.Next = op.Next;\n    op.Next.Prev = result;\n    result.Idx = 0;\n    return result;\n  };\n  ClipperLib.Clipper.CleanPolygon = function (path, distance)\n  {\n    if (typeof (distance) == \"undefined\") distance = 1.415;\n    //distance = proximity in units/pixels below which vertices will be stripped.\n    //Default ~= sqrt(2) so when adjacent vertices or semi-adjacent vertices have\n    //both x & y coords within 1 unit, then the second vertex will be stripped.\n    var cnt = path.length;\n    if (cnt == 0)\n      return new Array();\n    var outPts = new Array(cnt);\n    for (var i = 0; i < cnt; ++i)\n      outPts[i] = new ClipperLib.OutPt();\n    for (var i = 0; i < cnt; ++i)\n    {\n      outPts[i].Pt = path[i];\n      outPts[i].Next = outPts[(i + 1) % cnt];\n      outPts[i].Next.Prev = outPts[i];\n      outPts[i].Idx = 0;\n    }\n    var distSqrd = distance * distance;\n    var op = outPts[0];\n    while (op.Idx == 0 && op.Next != op.Prev)\n    {\n      if (ClipperLib.Clipper.PointsAreClose(op.Pt, op.Prev.Pt, distSqrd))\n      {\n        op = ClipperLib.Clipper.ExcludeOp(op);\n        cnt--;\n      }\n      else if (ClipperLib.Clipper.PointsAreClose(op.Prev.Pt, op.Next.Pt, distSqrd))\n      {\n        ClipperLib.Clipper.ExcludeOp(op.Next);\n        op = ClipperLib.Clipper.ExcludeOp(op);\n        cnt -= 2;\n      }\n      else if (ClipperLib.Clipper.SlopesNearCollinear(op.Prev.Pt, op.Pt, op.Next.Pt, distSqrd))\n      {\n        op = ClipperLib.Clipper.ExcludeOp(op);\n        cnt--;\n      }\n      else\n      {\n        op.Idx = 1;\n        op = op.Next;\n      }\n    }\n    if (cnt < 3)\n      cnt = 0;\n    var result = new Array(cnt);\n    for (var i = 0; i < cnt; ++i)\n    {\n      result[i] = new ClipperLib.IntPoint(op.Pt);\n      op = op.Next;\n    }\n    outPts = null;\n    return result;\n  };\n  ClipperLib.Clipper.CleanPolygons = function (polys, distance)\n  {\n    var result = new Array(polys.length);\n    for (var i = 0, ilen = polys.length; i < ilen; i++)\n      result[i] = ClipperLib.Clipper.CleanPolygon(polys[i], distance);\n    return result;\n  };\n  ClipperLib.Clipper.Minkowski = function (pattern, path, IsSum, IsClosed)\n  {\n    var delta = (IsClosed ? 1 : 0);\n    var polyCnt = pattern.length;\n    var pathCnt = path.length;\n    var result = new Array();\n    if (IsSum)\n      for (var i = 0; i < pathCnt; i++)\n      {\n        var p = new Array(polyCnt);\n        for (var j = 0, jlen = pattern.length, ip = pattern[j]; j < jlen; j++, ip = pattern[j])\n          p[j] = new ClipperLib.IntPoint(path[i].X + ip.X, path[i].Y + ip.Y);\n        result.push(p);\n      }\n    else\n      for (var i = 0; i < pathCnt; i++)\n      {\n        var p = new Array(polyCnt);\n        for (var j = 0, jlen = pattern.length, ip = pattern[j]; j < jlen; j++, ip = pattern[j])\n          p[j] = new ClipperLib.IntPoint(path[i].X - ip.X, path[i].Y - ip.Y);\n        result.push(p);\n      }\n    var quads = new Array();\n    for (var i = 0; i < pathCnt - 1 + delta; i++)\n      for (var j = 0; j < polyCnt; j++)\n      {\n        var quad = new Array();\n        quad.push(result[i % pathCnt][j % polyCnt]);\n        quad.push(result[(i + 1) % pathCnt][j % polyCnt]);\n        quad.push(result[(i + 1) % pathCnt][(j + 1) % polyCnt]);\n        quad.push(result[i % pathCnt][(j + 1) % polyCnt]);\n        if (!ClipperLib.Clipper.Orientation(quad))\n          quad.reverse();\n        quads.push(quad);\n      }\n\t\t\treturn quads;\n  };\n\n\tClipperLib.Clipper.MinkowskiSum = function(pattern, path_or_paths, pathIsClosed)\n\t{\n\t\tif(!(path_or_paths[0] instanceof Array))\n\t\t{\n\t\t\tvar path = path_or_paths;\n\t\t\tvar paths = ClipperLib.Clipper.Minkowski(pattern, path, true, pathIsClosed);\n\t\t\tvar c = new ClipperLib.Clipper();\n\t\t\tc.AddPaths(paths, ClipperLib.PolyType.ptSubject, true);\n\t\t\tc.Execute(ClipperLib.ClipType.ctUnion, paths, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);\n\t\t\treturn paths;\n\t\t}\n\t\telse\n\t\t{\n \t\t\tvar paths = path_or_paths;\n\t\t\tvar solution = new ClipperLib.Paths();\n\t\t\tvar c = new ClipperLib.Clipper();\n\t\t\tfor (var i = 0; i < paths.length; ++i)\n\t\t\t{\n\t\t\t\tvar tmp = ClipperLib.Clipper.Minkowski(pattern, paths[i], true, pathIsClosed);\n\t\t\t\tc.AddPaths(tmp, ClipperLib.PolyType.ptSubject, true);\n\t\t\t\tif (pathIsClosed)\n\t\t\t\t{\n\t\t\t\t\tvar path = ClipperLib.Clipper.TranslatePath(paths[i], pattern[0]);\n\t\t\t\t\tc.AddPath(path, ClipperLib.PolyType.ptClip, true);\n\t\t\t\t}\n\t\t\t}\n\t\t\tc.Execute(ClipperLib.ClipType.ctUnion, solution,\n\t\t\t\tClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);\n\t\t\treturn solution;\n\t\t}\n\t}\n\t//------------------------------------------------------------------------------\n\n\tClipperLib.Clipper.TranslatePath = function (path, delta)\n\t{\n\t\tvar outPath = new ClipperLib.Path();\n\t\tfor (var i = 0; i < path.length; i++)\n\t\t\toutPath.push(new ClipperLib.IntPoint(path[i].X + delta.X, path[i].Y + delta.Y));\n\t\treturn outPath;\n\t}\n\t//------------------------------------------------------------------------------\n\n\tClipperLib.Clipper.MinkowskiDiff = function (poly1, poly2)\n\t{\n\t\tvar paths = ClipperLib.Clipper.Minkowski(poly1, poly2, false, true);\n\t\tvar c = new ClipperLib.Clipper();\n\t\tc.AddPaths(paths, ClipperLib.PolyType.ptSubject, true);\n\t\tc.Execute(ClipperLib.ClipType.ctUnion, paths, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);\n\t\treturn paths;\n\t}\n\n  ClipperLib.Clipper.PolyTreeToPaths = function (polytree)\n  {\n    var result = new Array();\n    //result.set_Capacity(polytree.get_Total());\n    ClipperLib.Clipper.AddPolyNodeToPaths(polytree, ClipperLib.Clipper.NodeType.ntAny, result);\n    return result;\n  };\n  ClipperLib.Clipper.AddPolyNodeToPaths = function (polynode, nt, paths)\n  {\n    var match = true;\n    switch (nt)\n    {\n    case ClipperLib.Clipper.NodeType.ntOpen:\n      return;\n    case ClipperLib.Clipper.NodeType.ntClosed:\n      match = !polynode.IsOpen;\n      break;\n    default:\n      break;\n    }\n    if (polynode.m_polygon.length > 0 && match)\n      paths.push(polynode.m_polygon);\n    for (var $i3 = 0, $t3 = polynode.Childs(), $l3 = $t3.length, pn = $t3[$i3]; $i3 < $l3; $i3++, pn = $t3[$i3])\n      ClipperLib.Clipper.AddPolyNodeToPaths(pn, nt, paths);\n  };\n  ClipperLib.Clipper.OpenPathsFromPolyTree = function (polytree)\n  {\n    var result = new ClipperLib.Paths();\n    //result.set_Capacity(polytree.ChildCount());\n    for (var i = 0, ilen = polytree.ChildCount(); i < ilen; i++)\n      if (polytree.Childs()[i].IsOpen)\n        result.push(polytree.Childs()[i].m_polygon);\n    return result;\n  };\n  ClipperLib.Clipper.ClosedPathsFromPolyTree = function (polytree)\n  {\n    var result = new ClipperLib.Paths();\n    //result.set_Capacity(polytree.Total());\n    ClipperLib.Clipper.AddPolyNodeToPaths(polytree, ClipperLib.Clipper.NodeType.ntClosed, result);\n    return result;\n  };\n  Inherit(ClipperLib.Clipper, ClipperLib.ClipperBase);\n  ClipperLib.Clipper.NodeType = {\n    ntAny: 0,\n    ntOpen: 1,\n    ntClosed: 2\n  };\n  ClipperLib.ClipperOffset = function (miterLimit, arcTolerance)\n  {\n    if (typeof (miterLimit) == \"undefined\") miterLimit = 2;\n    if (typeof (arcTolerance) == \"undefined\") arcTolerance = ClipperLib.ClipperOffset.def_arc_tolerance;\n    this.m_destPolys = new ClipperLib.Paths();\n    this.m_srcPoly = new ClipperLib.Path();\n    this.m_destPoly = new ClipperLib.Path();\n    this.m_normals = new Array();\n    this.m_delta = 0;\n    this.m_sinA = 0;\n    this.m_sin = 0;\n    this.m_cos = 0;\n    this.m_miterLim = 0;\n    this.m_StepsPerRad = 0;\n    this.m_lowest = new ClipperLib.IntPoint();\n    this.m_polyNodes = new ClipperLib.PolyNode();\n    this.MiterLimit = miterLimit;\n    this.ArcTolerance = arcTolerance;\n    this.m_lowest.X = -1;\n  };\n  ClipperLib.ClipperOffset.two_pi = 6.28318530717959;\n  ClipperLib.ClipperOffset.def_arc_tolerance = 0.25;\n  ClipperLib.ClipperOffset.prototype.Clear = function ()\n  {\n    ClipperLib.Clear(this.m_polyNodes.Childs());\n    this.m_lowest.X = -1;\n  };\n  ClipperLib.ClipperOffset.Round = ClipperLib.Clipper.Round;\n  ClipperLib.ClipperOffset.prototype.AddPath = function (path, joinType, endType)\n  {\n    var highI = path.length - 1;\n    if (highI < 0)\n      return;\n    var newNode = new ClipperLib.PolyNode();\n    newNode.m_jointype = joinType;\n    newNode.m_endtype = endType;\n    //strip duplicate points from path and also get index to the lowest point ...\n    if (endType == ClipperLib.EndType.etClosedLine || endType == ClipperLib.EndType.etClosedPolygon)\n      while (highI > 0 && ClipperLib.IntPoint.op_Equality(path[0], path[highI]))\n        highI--;\n    //newNode.m_polygon.set_Capacity(highI + 1);\n    newNode.m_polygon.push(path[0]);\n    var j = 0,\n      k = 0;\n    for (var i = 1; i <= highI; i++)\n      if (ClipperLib.IntPoint.op_Inequality(newNode.m_polygon[j], path[i]))\n      {\n        j++;\n        newNode.m_polygon.push(path[i]);\n        if (path[i].Y > newNode.m_polygon[k].Y || (path[i].Y == newNode.m_polygon[k].Y && path[i].X < newNode.m_polygon[k].X))\n          k = j;\n      }\n    if (endType == ClipperLib.EndType.etClosedPolygon && j < 2) return;\n\n    this.m_polyNodes.AddChild(newNode);\n    //if this path's lowest pt is lower than all the others then update m_lowest\n    if (endType != ClipperLib.EndType.etClosedPolygon)\n      return;\n    if (this.m_lowest.X < 0)\n      this.m_lowest = new ClipperLib.IntPoint(this.m_polyNodes.ChildCount() - 1, k);\n    else\n    {\n      var ip = this.m_polyNodes.Childs()[this.m_lowest.X].m_polygon[this.m_lowest.Y];\n      if (newNode.m_polygon[k].Y > ip.Y || (newNode.m_polygon[k].Y == ip.Y && newNode.m_polygon[k].X < ip.X))\n        this.m_lowest = new ClipperLib.IntPoint(this.m_polyNodes.ChildCount() - 1, k);\n    }\n  };\n  ClipperLib.ClipperOffset.prototype.AddPaths = function (paths, joinType, endType)\n  {\n    for (var i = 0, ilen = paths.length; i < ilen; i++)\n      this.AddPath(paths[i], joinType, endType);\n  };\n  ClipperLib.ClipperOffset.prototype.FixOrientations = function ()\n  {\n    //fixup orientations of all closed paths if the orientation of the\n    //closed path with the lowermost vertex is wrong ...\n    if (this.m_lowest.X >= 0 && !ClipperLib.Clipper.Orientation(this.m_polyNodes.Childs()[this.m_lowest.X].m_polygon))\n    {\n      for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n      {\n        var node = this.m_polyNodes.Childs()[i];\n        if (node.m_endtype == ClipperLib.EndType.etClosedPolygon || (node.m_endtype == ClipperLib.EndType.etClosedLine && ClipperLib.Clipper.Orientation(node.m_polygon)))\n          node.m_polygon.reverse();\n      }\n    }\n    else\n    {\n      for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n      {\n        var node = this.m_polyNodes.Childs()[i];\n        if (node.m_endtype == ClipperLib.EndType.etClosedLine && !ClipperLib.Clipper.Orientation(node.m_polygon))\n          node.m_polygon.reverse();\n      }\n    }\n  };\n  ClipperLib.ClipperOffset.GetUnitNormal = function (pt1, pt2)\n  {\n    var dx = (pt2.X - pt1.X);\n    var dy = (pt2.Y - pt1.Y);\n    if ((dx == 0) && (dy == 0))\n      return new ClipperLib.DoublePoint(0, 0);\n    var f = 1 / Math.sqrt(dx * dx + dy * dy);\n    dx *= f;\n    dy *= f;\n    return new ClipperLib.DoublePoint(dy, -dx);\n  };\n  ClipperLib.ClipperOffset.prototype.DoOffset = function (delta)\n  {\n    this.m_destPolys = new Array();\n    this.m_delta = delta;\n    //if Zero offset, just copy any CLOSED polygons to m_p and return ...\n    if (ClipperLib.ClipperBase.near_zero(delta))\n    {\n      //this.m_destPolys.set_Capacity(this.m_polyNodes.ChildCount);\n      for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n      {\n        var node = this.m_polyNodes.Childs()[i];\n        if (node.m_endtype == ClipperLib.EndType.etClosedPolygon)\n          this.m_destPolys.push(node.m_polygon);\n      }\n      return;\n    }\n    //see offset_triginometry3.svg in the documentation folder ...\n    if (this.MiterLimit > 2)\n      this.m_miterLim = 2 / (this.MiterLimit * this.MiterLimit);\n    else\n      this.m_miterLim = 0.5;\n    var y;\n    if (this.ArcTolerance <= 0)\n      y = ClipperLib.ClipperOffset.def_arc_tolerance;\n    else if (this.ArcTolerance > Math.abs(delta) * ClipperLib.ClipperOffset.def_arc_tolerance)\n      y = Math.abs(delta) * ClipperLib.ClipperOffset.def_arc_tolerance;\n    else\n      y = this.ArcTolerance;\n    //see offset_triginometry2.svg in the documentation folder ...\n    var steps = 3.14159265358979 / Math.acos(1 - y / Math.abs(delta));\n    this.m_sin = Math.sin(ClipperLib.ClipperOffset.two_pi / steps);\n    this.m_cos = Math.cos(ClipperLib.ClipperOffset.two_pi / steps);\n    this.m_StepsPerRad = steps / ClipperLib.ClipperOffset.two_pi;\n    if (delta < 0)\n      this.m_sin = -this.m_sin;\n    //this.m_destPolys.set_Capacity(this.m_polyNodes.ChildCount * 2);\n    for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n    {\n      var node = this.m_polyNodes.Childs()[i];\n      this.m_srcPoly = node.m_polygon;\n      var len = this.m_srcPoly.length;\n      if (len == 0 || (delta <= 0 && (len < 3 || node.m_endtype != ClipperLib.EndType.etClosedPolygon)))\n        continue;\n      this.m_destPoly = new Array();\n      if (len == 1)\n      {\n        if (node.m_jointype == ClipperLib.JoinType.jtRound)\n        {\n          var X = 1,\n            Y = 0;\n          for (var j = 1; j <= steps; j++)\n          {\n            this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X + X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y + Y * delta)));\n            var X2 = X;\n            X = X * this.m_cos - this.m_sin * Y;\n            Y = X2 * this.m_sin + Y * this.m_cos;\n          }\n        }\n        else\n        {\n          var X = -1,\n            Y = -1;\n          for (var j = 0; j < 4; ++j)\n          {\n            this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X + X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y + Y * delta)));\n            if (X < 0)\n              X = 1;\n            else if (Y < 0)\n              Y = 1;\n            else\n              X = -1;\n          }\n        }\n        this.m_destPolys.push(this.m_destPoly);\n        continue;\n      }\n      //build m_normals ...\n      this.m_normals.length = 0;\n      //this.m_normals.set_Capacity(len);\n      for (var j = 0; j < len - 1; j++)\n        this.m_normals.push(ClipperLib.ClipperOffset.GetUnitNormal(this.m_srcPoly[j], this.m_srcPoly[j + 1]));\n      if (node.m_endtype == ClipperLib.EndType.etClosedLine || node.m_endtype == ClipperLib.EndType.etClosedPolygon)\n        this.m_normals.push(ClipperLib.ClipperOffset.GetUnitNormal(this.m_srcPoly[len - 1], this.m_srcPoly[0]));\n      else\n        this.m_normals.push(new ClipperLib.DoublePoint(this.m_normals[len - 2]));\n      if (node.m_endtype == ClipperLib.EndType.etClosedPolygon)\n      {\n        var k = len - 1;\n        for (var j = 0; j < len; j++)\n          k = this.OffsetPoint(j, k, node.m_jointype);\n        this.m_destPolys.push(this.m_destPoly);\n      }\n      else if (node.m_endtype == ClipperLib.EndType.etClosedLine)\n      {\n        var k = len - 1;\n        for (var j = 0; j < len; j++)\n          k = this.OffsetPoint(j, k, node.m_jointype);\n        this.m_destPolys.push(this.m_destPoly);\n        this.m_destPoly = new Array();\n        //re-build m_normals ...\n        var n = this.m_normals[len - 1];\n        for (var j = len - 1; j > 0; j--)\n          this.m_normals[j] = new ClipperLib.DoublePoint(-this.m_normals[j - 1].X, -this.m_normals[j - 1].Y);\n        this.m_normals[0] = new ClipperLib.DoublePoint(-n.X, -n.Y);\n        k = 0;\n        for (var j = len - 1; j >= 0; j--)\n          k = this.OffsetPoint(j, k, node.m_jointype);\n        this.m_destPolys.push(this.m_destPoly);\n      }\n      else\n      {\n        var k = 0;\n        for (var j = 1; j < len - 1; ++j)\n          k = this.OffsetPoint(j, k, node.m_jointype);\n        var pt1;\n        if (node.m_endtype == ClipperLib.EndType.etOpenButt)\n        {\n          var j = len - 1;\n          pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[j].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[j].Y * delta));\n          this.m_destPoly.push(pt1);\n          pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X - this.m_normals[j].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y - this.m_normals[j].Y * delta));\n          this.m_destPoly.push(pt1);\n        }\n        else\n        {\n          var j = len - 1;\n          k = len - 2;\n          this.m_sinA = 0;\n          this.m_normals[j] = new ClipperLib.DoublePoint(-this.m_normals[j].X, -this.m_normals[j].Y);\n          if (node.m_endtype == ClipperLib.EndType.etOpenSquare)\n            this.DoSquare(j, k);\n          else\n            this.DoRound(j, k);\n        }\n        //re-build m_normals ...\n        for (var j = len - 1; j > 0; j--)\n          this.m_normals[j] = new ClipperLib.DoublePoint(-this.m_normals[j - 1].X, -this.m_normals[j - 1].Y);\n        this.m_normals[0] = new ClipperLib.DoublePoint(-this.m_normals[1].X, -this.m_normals[1].Y);\n        k = len - 1;\n        for (var j = k - 1; j > 0; --j)\n          k = this.OffsetPoint(j, k, node.m_jointype);\n        if (node.m_endtype == ClipperLib.EndType.etOpenButt)\n        {\n          pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X - this.m_normals[0].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y - this.m_normals[0].Y * delta));\n          this.m_destPoly.push(pt1);\n          pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X + this.m_normals[0].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y + this.m_normals[0].Y * delta));\n          this.m_destPoly.push(pt1);\n        }\n        else\n        {\n          k = 1;\n          this.m_sinA = 0;\n          if (node.m_endtype == ClipperLib.EndType.etOpenSquare)\n            this.DoSquare(0, 1);\n          else\n            this.DoRound(0, 1);\n        }\n        this.m_destPolys.push(this.m_destPoly);\n      }\n    }\n  };\n  ClipperLib.ClipperOffset.prototype.Execute = function ()\n  {\n    var a = arguments,\n      ispolytree = a[0] instanceof ClipperLib.PolyTree;\n    if (!ispolytree) // function (solution, delta)\n    {\n      var solution = a[0],\n        delta = a[1];\n      ClipperLib.Clear(solution);\n      this.FixOrientations();\n      this.DoOffset(delta);\n      //now clean up 'corners' ...\n      var clpr = new ClipperLib.Clipper(0);\n      clpr.AddPaths(this.m_destPolys, ClipperLib.PolyType.ptSubject, true);\n      if (delta > 0)\n      {\n        clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftPositive, ClipperLib.PolyFillType.pftPositive);\n      }\n      else\n      {\n        var r = ClipperLib.Clipper.GetBounds(this.m_destPolys);\n        var outer = new ClipperLib.Path();\n        outer.push(new ClipperLib.IntPoint(r.left - 10, r.bottom + 10));\n        outer.push(new ClipperLib.IntPoint(r.right + 10, r.bottom + 10));\n        outer.push(new ClipperLib.IntPoint(r.right + 10, r.top - 10));\n        outer.push(new ClipperLib.IntPoint(r.left - 10, r.top - 10));\n        clpr.AddPath(outer, ClipperLib.PolyType.ptSubject, true);\n        clpr.ReverseSolution = true;\n        clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftNegative, ClipperLib.PolyFillType.pftNegative);\n        if (solution.length > 0)\n          solution.splice(0, 1);\n      }\n      //console.log(JSON.stringify(solution));\n    }\n    else // function (polytree, delta)\n    {\n      var solution = a[0],\n        delta = a[1];\n      solution.Clear();\n      this.FixOrientations();\n      this.DoOffset(delta);\n      //now clean up 'corners' ...\n      var clpr = new ClipperLib.Clipper(0);\n      clpr.AddPaths(this.m_destPolys, ClipperLib.PolyType.ptSubject, true);\n      if (delta > 0)\n      {\n        clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftPositive, ClipperLib.PolyFillType.pftPositive);\n      }\n      else\n      {\n        var r = ClipperLib.Clipper.GetBounds(this.m_destPolys);\n        var outer = new ClipperLib.Path();\n        outer.push(new ClipperLib.IntPoint(r.left - 10, r.bottom + 10));\n        outer.push(new ClipperLib.IntPoint(r.right + 10, r.bottom + 10));\n        outer.push(new ClipperLib.IntPoint(r.right + 10, r.top - 10));\n        outer.push(new ClipperLib.IntPoint(r.left - 10, r.top - 10));\n        clpr.AddPath(outer, ClipperLib.PolyType.ptSubject, true);\n        clpr.ReverseSolution = true;\n        clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftNegative, ClipperLib.PolyFillType.pftNegative);\n        //remove the outer PolyNode rectangle ...\n        if (solution.ChildCount() == 1 && solution.Childs()[0].ChildCount() > 0)\n        {\n          var outerNode = solution.Childs()[0];\n          //solution.Childs.set_Capacity(outerNode.ChildCount);\n          solution.Childs()[0] = outerNode.Childs()[0];\n          solution.Childs()[0].m_Parent = solution;\n          for (var i = 1; i < outerNode.ChildCount(); i++)\n            solution.AddChild(outerNode.Childs()[i]);\n        }\n        else\n          solution.Clear();\n      }\n    }\n  };\n  ClipperLib.ClipperOffset.prototype.OffsetPoint = function (j, k, jointype)\n  {\n\t\t//cross product ...\n\t\tthis.m_sinA = (this.m_normals[k].X * this.m_normals[j].Y - this.m_normals[j].X * this.m_normals[k].Y);\n\n\t\tif (Math.abs(this.m_sinA * this.m_delta) < 1.0)\n\t\t{\n\t\t\t//dot product ...\n\t\t\tvar cosA = (this.m_normals[k].X * this.m_normals[j].X + this.m_normals[j].Y * this.m_normals[k].Y);\n\t\t\tif (cosA > 0) // angle ==> 0 degrees\n\t\t\t{\n\t\t\t\tthis.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[k].X * this.m_delta),\n\t\t\t\t\tClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[k].Y * this.m_delta)));\n\t\t\t\treturn k;\n\t\t\t}\n\t\t\t//else angle ==> 180 degrees\n\t\t}\n    else if (this.m_sinA > 1)\n      this.m_sinA = 1.0;\n    else if (this.m_sinA < -1)\n      this.m_sinA = -1.0;\n    if (this.m_sinA * this.m_delta < 0)\n    {\n      this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[k].X * this.m_delta),\n        ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[k].Y * this.m_delta)));\n      this.m_destPoly.push(new ClipperLib.IntPoint(this.m_srcPoly[j]));\n      this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[j].X * this.m_delta),\n        ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[j].Y * this.m_delta)));\n    }\n    else\n      switch (jointype)\n      {\n      case ClipperLib.JoinType.jtMiter:\n        {\n          var r = 1 + (this.m_normals[j].X * this.m_normals[k].X + this.m_normals[j].Y * this.m_normals[k].Y);\n          if (r >= this.m_miterLim)\n            this.DoMiter(j, k, r);\n          else\n            this.DoSquare(j, k);\n          break;\n        }\n      case ClipperLib.JoinType.jtSquare:\n        this.DoSquare(j, k);\n        break;\n      case ClipperLib.JoinType.jtRound:\n        this.DoRound(j, k);\n        break;\n      }\n    k = j;\n    return k;\n  };\n  ClipperLib.ClipperOffset.prototype.DoSquare = function (j, k)\n  {\n    var dx = Math.tan(Math.atan2(this.m_sinA,\n      this.m_normals[k].X * this.m_normals[j].X + this.m_normals[k].Y * this.m_normals[j].Y) / 4);\n    this.m_destPoly.push(new ClipperLib.IntPoint(\n      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_delta * (this.m_normals[k].X - this.m_normals[k].Y * dx)),\n      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_delta * (this.m_normals[k].Y + this.m_normals[k].X * dx))));\n    this.m_destPoly.push(new ClipperLib.IntPoint(\n      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_delta * (this.m_normals[j].X + this.m_normals[j].Y * dx)),\n      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_delta * (this.m_normals[j].Y - this.m_normals[j].X * dx))));\n  };\n  ClipperLib.ClipperOffset.prototype.DoMiter = function (j, k, r)\n  {\n    var q = this.m_delta / r;\n    this.m_destPoly.push(new ClipperLib.IntPoint(\n      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + (this.m_normals[k].X + this.m_normals[j].X) * q),\n      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + (this.m_normals[k].Y + this.m_normals[j].Y) * q)));\n  };\n  ClipperLib.ClipperOffset.prototype.DoRound = function (j, k)\n  {\n    var a = Math.atan2(this.m_sinA,\n      this.m_normals[k].X * this.m_normals[j].X + this.m_normals[k].Y * this.m_normals[j].Y);\n\n    \tvar steps = Math.max(ClipperLib.Cast_Int32(ClipperLib.ClipperOffset.Round(this.m_StepsPerRad * Math.abs(a))), 1);\n\n    var X = this.m_normals[k].X,\n      Y = this.m_normals[k].Y,\n      X2;\n    for (var i = 0; i < steps; ++i)\n    {\n      this.m_destPoly.push(new ClipperLib.IntPoint(\n        ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + X * this.m_delta),\n        ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + Y * this.m_delta)));\n      X2 = X;\n      X = X * this.m_cos - this.m_sin * Y;\n      Y = X2 * this.m_sin + Y * this.m_cos;\n    }\n    this.m_destPoly.push(new ClipperLib.IntPoint(\n      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[j].X * this.m_delta),\n      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[j].Y * this.m_delta)));\n  };\n  ClipperLib.Error = function (message)\n  {\n    try\n    {\n      throw new Error(message);\n    }\n    catch (err)\n    {\n      alert(err.message);\n    }\n  };\n  // ---------------------------------\n  // JS extension by Timo 2013\n  ClipperLib.JS = {};\n  ClipperLib.JS.AreaOfPolygon = function (poly, scale)\n  {\n    if (!scale) scale = 1;\n    return ClipperLib.Clipper.Area(poly) / (scale * scale);\n  };\n  ClipperLib.JS.AreaOfPolygons = function (poly, scale)\n  {\n    if (!scale) scale = 1;\n    var area = 0;\n    for (var i = 0; i < poly.length; i++)\n    {\n      area += ClipperLib.Clipper.Area(poly[i]);\n    }\n    return area / (scale * scale);\n  };\n  ClipperLib.JS.BoundsOfPath = function (path, scale)\n  {\n    return ClipperLib.JS.BoundsOfPaths([path], scale);\n  };\n  ClipperLib.JS.BoundsOfPaths = function (paths, scale)\n  {\n    if (!scale) scale = 1;\n    var bounds = ClipperLib.Clipper.GetBounds(paths);\n    bounds.left /= scale;\n    bounds.bottom /= scale;\n    bounds.right /= scale;\n    bounds.top /= scale;\n    return bounds;\n  };\n  // Clean() joins vertices that are too near each other\n  // and causes distortion to offsetted polygons without cleaning\n  ClipperLib.JS.Clean = function (polygon, delta)\n  {\n    if (!(polygon instanceof Array)) return [];\n    var isPolygons = polygon[0] instanceof Array;\n    var polygon = ClipperLib.JS.Clone(polygon);\n    if (typeof delta != \"number\" || delta === null)\n    {\n      ClipperLib.Error(\"Delta is not a number in Clean().\");\n      return polygon;\n    }\n    if (polygon.length === 0 || (polygon.length == 1 && polygon[0].length === 0) || delta < 0) return polygon;\n    if (!isPolygons) polygon = [polygon];\n    var k_length = polygon.length;\n    var len, poly, result, d, p, j, i;\n    var results = [];\n    for (var k = 0; k < k_length; k++)\n    {\n      poly = polygon[k];\n      len = poly.length;\n      if (len === 0) continue;\n      else if (len < 3)\n      {\n        result = poly;\n        results.push(result);\n        continue;\n      }\n      result = poly;\n      d = delta * delta;\n      //d = Math.floor(c_delta * c_delta);\n      p = poly[0];\n      j = 1;\n      for (i = 1; i < len; i++)\n      {\n        if ((poly[i].X - p.X) * (poly[i].X - p.X) +\n          (poly[i].Y - p.Y) * (poly[i].Y - p.Y) <= d)\n          continue;\n        result[j] = poly[i];\n        p = poly[i];\n        j++;\n      }\n      p = poly[j - 1];\n      if ((poly[0].X - p.X) * (poly[0].X - p.X) +\n        (poly[0].Y - p.Y) * (poly[0].Y - p.Y) <= d)\n        j--;\n      if (j < len)\n        result.splice(j, len - j);\n      if (result.length) results.push(result);\n    }\n    if (!isPolygons && results.length) results = results[0];\n    else if (!isPolygons && results.length === 0) results = [];\n    else if (isPolygons && results.length === 0) results = [\n      []\n    ];\n    return results;\n  }\n  // Make deep copy of Polygons or Polygon\n  // so that also IntPoint objects are cloned and not only referenced\n  // This should be the fastest way\n  ClipperLib.JS.Clone = function (polygon)\n  {\n    if (!(polygon instanceof Array)) return [];\n    if (polygon.length === 0) return [];\n    else if (polygon.length == 1 && polygon[0].length === 0) return [[]];\n    var isPolygons = polygon[0] instanceof Array;\n    if (!isPolygons) polygon = [polygon];\n    var len = polygon.length,\n      plen, i, j, result;\n    var results = new Array(len);\n    for (i = 0; i < len; i++)\n    {\n      plen = polygon[i].length;\n      result = new Array(plen);\n      for (j = 0; j < plen; j++)\n      {\n        result[j] = {\n          X: polygon[i][j].X,\n          Y: polygon[i][j].Y\n        };\n      }\n      results[i] = result;\n    }\n    if (!isPolygons) results = results[0];\n    return results;\n  };\n  // Removes points that doesn't affect much to the visual appearance.\n  // If middle point is at or under certain distance (tolerance) of the line segment between\n  // start and end point, the middle point is removed.\n  ClipperLib.JS.Lighten = function (polygon, tolerance)\n  {\n    if (!(polygon instanceof Array)) return [];\n    if (typeof tolerance != \"number\" || tolerance === null)\n    {\n      ClipperLib.Error(\"Tolerance is not a number in Lighten().\")\n      return ClipperLib.JS.Clone(polygon);\n    }\n    if (polygon.length === 0 || (polygon.length == 1 && polygon[0].length === 0) || tolerance < 0)\n    {\n      return ClipperLib.JS.Clone(polygon);\n    }\n    if (!(polygon[0] instanceof Array)) polygon = [polygon];\n    var i, j, poly, k, poly2, plen, A, B, P, d, rem, addlast;\n    var bxax, byay, l, ax, ay;\n    var len = polygon.length;\n    var toleranceSq = tolerance * tolerance;\n    var results = [];\n    for (i = 0; i < len; i++)\n    {\n      poly = polygon[i];\n      plen = poly.length;\n      if (plen == 0) continue;\n      for (k = 0; k < 1000000; k++) // could be forever loop, but wiser to restrict max repeat count\n      {\n        poly2 = [];\n        plen = poly.length;\n        // the first have to added to the end, if first and last are not the same\n        // this way we ensure that also the actual last point can be removed if needed\n        if (poly[plen - 1].X != poly[0].X || poly[plen - 1].Y != poly[0].Y)\n        {\n          addlast = 1;\n          poly.push(\n          {\n            X: poly[0].X,\n            Y: poly[0].Y\n          });\n          plen = poly.length;\n        }\n        else addlast = 0;\n        rem = []; // Indexes of removed points\n        for (j = 0; j < plen - 2; j++)\n        {\n          A = poly[j]; // Start point of line segment\n          P = poly[j + 1]; // Middle point. This is the one to be removed.\n          B = poly[j + 2]; // End point of line segment\n          ax = A.X;\n          ay = A.Y;\n          bxax = B.X - ax;\n          byay = B.Y - ay;\n          if (bxax !== 0 || byay !== 0) // To avoid Nan, when A==P && P==B. And to avoid peaks (A==B && A!=P), which have lenght, but not area.\n          {\n            l = ((P.X - ax) * bxax + (P.Y - ay) * byay) / (bxax * bxax + byay * byay);\n            if (l > 1)\n            {\n              ax = B.X;\n              ay = B.Y;\n            }\n            else if (l > 0)\n            {\n              ax += bxax * l;\n              ay += byay * l;\n            }\n          }\n          bxax = P.X - ax;\n          byay = P.Y - ay;\n          d = bxax * bxax + byay * byay;\n          if (d <= toleranceSq)\n          {\n            rem[j + 1] = 1;\n            j++; // when removed, transfer the pointer to the next one\n          }\n        }\n        // add all unremoved points to poly2\n        poly2.push(\n        {\n          X: poly[0].X,\n          Y: poly[0].Y\n        });\n        for (j = 1; j < plen - 1; j++)\n          if (!rem[j]) poly2.push(\n          {\n            X: poly[j].X,\n            Y: poly[j].Y\n          });\n        poly2.push(\n        {\n          X: poly[plen - 1].X,\n          Y: poly[plen - 1].Y\n        });\n        // if the first point was added to the end, remove it\n        if (addlast) poly.pop();\n        // break, if there was not anymore removed points\n        if (!rem.length) break;\n        // else continue looping using poly2, to check if there are points to remove\n        else poly = poly2;\n      }\n      plen = poly2.length;\n      // remove duplicate from end, if needed\n      if (poly2[plen - 1].X == poly2[0].X && poly2[plen - 1].Y == poly2[0].Y)\n      {\n        poly2.pop();\n      }\n      if (poly2.length > 2) // to avoid two-point-polygons\n        results.push(poly2);\n    }\n    if (!(polygon[0] instanceof Array)) results = results[0];\n    if (typeof (results) == \"undefined\") results = [\n      []\n    ];\n    return results;\n  }\n  ClipperLib.JS.PerimeterOfPath = function (path, closed, scale)\n  {\n    if (typeof (path) == \"undefined\") return 0;\n    var sqrt = Math.sqrt;\n    var perimeter = 0.0;\n    var p1, p2, p1x = 0.0,\n      p1y = 0.0,\n      p2x = 0.0,\n      p2y = 0.0;\n    var j = path.length;\n    if (j < 2) return 0;\n    if (closed)\n    {\n      path[j] = path[0];\n      j++;\n    }\n    while (--j)\n    {\n      p1 = path[j];\n      p1x = p1.X;\n      p1y = p1.Y;\n      p2 = path[j - 1];\n      p2x = p2.X;\n      p2y = p2.Y;\n      perimeter += sqrt((p1x - p2x) * (p1x - p2x) + (p1y - p2y) * (p1y - p2y));\n    }\n    if (closed) path.pop();\n    return perimeter / scale;\n  };\n  ClipperLib.JS.PerimeterOfPaths = function (paths, closed, scale)\n  {\n    if (!scale) scale = 1;\n    var perimeter = 0;\n    for (var i = 0; i < paths.length; i++)\n    {\n      perimeter += ClipperLib.JS.PerimeterOfPath(paths[i], closed, scale);\n    }\n    return perimeter;\n  };\n  ClipperLib.JS.ScaleDownPath = function (path, scale)\n  {\n    var i, p;\n    if (!scale) scale = 1;\n    i = path.length;\n    while (i--)\n    {\n      p = path[i];\n      p.X = p.X / scale;\n      p.Y = p.Y / scale;\n    }\n  };\n  ClipperLib.JS.ScaleDownPaths = function (paths, scale)\n  {\n    var i, j, p;\n    if (!scale) scale = 1;\n    i = paths.length;\n    while (i--)\n    {\n      j = paths[i].length;\n      while (j--)\n      {\n        p = paths[i][j];\n        p.X = p.X / scale;\n        p.Y = p.Y / scale;\n      }\n    }\n  };\n  ClipperLib.JS.ScaleUpPath = function (path, scale)\n  {\n    var i, p, round = Math.round;\n    if (!scale) scale = 1;\n    i = path.length;\n    while (i--)\n    {\n      p = path[i];\n      p.X = round(p.X * scale);\n      p.Y = round(p.Y * scale);\n    }\n  };\n  ClipperLib.JS.ScaleUpPaths = function (paths, scale)\n  {\n    var i, j, p, round = Math.round;\n    if (!scale) scale = 1;\n    i = paths.length;\n    while (i--)\n    {\n      j = paths[i].length;\n      while (j--)\n      {\n        p = paths[i][j];\n        p.X = round(p.X * scale);\n        p.Y = round(p.Y * scale);\n      }\n    }\n  };\n  ClipperLib.ExPolygons = function ()\n  {\n    return [];\n  }\n  ClipperLib.ExPolygon = function ()\n  {\n    this.outer = null;\n    this.holes = null;\n  };\n  ClipperLib.JS.AddOuterPolyNodeToExPolygons = function (polynode, expolygons)\n  {\n    var ep = new ClipperLib.ExPolygon();\n    ep.outer = polynode.Contour();\n    var childs = polynode.Childs();\n    var ilen = childs.length;\n    ep.holes = new Array(ilen);\n    var node, n, i, j, childs2, jlen;\n    for (i = 0; i < ilen; i++)\n    {\n      node = childs[i];\n      ep.holes[i] = node.Contour();\n      //Add outer polygons contained by (nested within) holes ...\n      for (j = 0, childs2 = node.Childs(), jlen = childs2.length; j < jlen; j++)\n      {\n        n = childs2[j];\n        ClipperLib.JS.AddOuterPolyNodeToExPolygons(n, expolygons);\n      }\n    }\n    expolygons.push(ep);\n  };\n  ClipperLib.JS.ExPolygonsToPaths = function (expolygons)\n  {\n    var a, i, alen, ilen;\n    var paths = new ClipperLib.Paths();\n    for (a = 0, alen = expolygons.length; a < alen; a++)\n    {\n      paths.push(expolygons[a].outer);\n      for (i = 0, ilen = expolygons[a].holes.length; i < ilen; i++)\n      {\n        paths.push(expolygons[a].holes[i]);\n      }\n    }\n    return paths;\n  }\n  ClipperLib.JS.PolyTreeToExPolygons = function (polytree)\n  {\n    var expolygons = new ClipperLib.ExPolygons();\n    var node, i, childs, ilen;\n    for (i = 0, childs = polytree.Childs(), ilen = childs.length; i < ilen; i++)\n    {\n      node = childs[i];\n      ClipperLib.JS.AddOuterPolyNodeToExPolygons(node, expolygons);\n    }\n    return expolygons;\n  };\n})();\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/clipper-lib/clipper.js\n// module id = 5\n// module chunks = 0","!function(t,e){\"object\"==typeof exports&&\"object\"==typeof module?module.exports=e():\"function\"==typeof define&&define.amd?define(\"SVGCurves\",[],e):\"object\"==typeof exports?exports.SVGCurves=e():t.SVGCurves=e()}(this,function(){return function(t){function e(n){if(i[n])return i[n].exports;var r=i[n]={exports:{},id:n,loaded:!1};return t[n].call(r.exports,r,r.exports,e),r.loaded=!0,r.exports}var i={};return e.m=t,e.c=i,e.p=\"\",e(0)}([function(t,e,i){t.exports=i(1)},function(t,e,i){\"use strict\";function n(t,e){if(!t)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return!e||\"object\"!=typeof e&&\"function\"!=typeof e?t:e}function r(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function, not \"+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}function s(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}function o(t,e){return(t%e+e)%e}function h(t,e,i){return Math.min(Math.max(t,e),i)}function a(t,e){return Math.sqrt(Math.pow(e.x-t.x,2)+Math.pow(e.y-t.y,2))}function u(t,e){var i=t.x*e.x+t.y*e.y,n=Math.sqrt((Math.pow(t.x,2)+Math.pow(t.y,2))*(Math.pow(e.x,2)+Math.pow(e.y,2)));return(t.x*e.y-t.y*e.x<0?-1:1)*Math.acos(i/n)}Object.defineProperty(e,\"__esModule\",{value:!0}),e.QuadricBezier=e.CubicBezier=e.Arc=void 0;var p=function t(e,i,n){null===e&&(e=Function.prototype);var r=Object.getOwnPropertyDescriptor(e,i);if(void 0===r){var s=Object.getPrototypeOf(e);return null===s?void 0:t(s,i,n)}if(\"value\"in r)return r.value;var o=r.get;if(void 0!==o)return o.call(n)},c=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e}}(),f=i(2),l=2*Math.PI,y=Math.PI/180,v=function(){function t(e){s(this,t),this.path=[],this.linear=!0,this.step=.01,this.resolution=500,this.segmentLength=.1,Object.assign(this,e||{}),this.arcLength=null,this.arcLengthMap=null}return c(t,[{key:\"_clearPath\",value:function(){this.path=[]}},{key:\"getPath\",value:function(){return this.path}},{key:\"getPointAtT\",value:function(t){return new f.Point(0,0)}},{key:\"_addPoint\",value:function(t){this.path.push(t.x,t.y)}},{key:\"_postTrace\",value:function(){}},{key:\"_approximateLength\",value:function(){var t=0,e=[],i=this.getPointAtT(0),n=void 0,r=void 0,s=void 0;for(n=0;n<this.resolution;n++)r=h(n*(1/this.resolution),0,1),s=this.getPointAtT(r),t+=a(i,s),e.push({t:r,arcLength:t}),i=s;s=this.getPointAtT(1),t+=a(i,s),e.push({t:1,arcLength:t}),Object.assign(this,{arcLength:t,arcLengthMap:e})}},{key:\"getPointAtU\",value:function(t){t=h(t,0,1);var e=t*this.arcLength,i=0,n=0,r=0;return this.arcLengthMap.every(function(t){var s=t.t,o=t.arcLength;if(o>=e){var h=o-e,a=e-n,u=a/(h+a)||0;return i=r+(s-r)*u,!1}return n=o,r=s,!0}),this.getPointAtT(i)}},{key:\"trace\",value:function(t){Object.assign(this,t||{});var e=\"getPointAtT\",i=this.step;if(this.linear){this._approximateLength();var n=Math.round(this.arcLength/this.segmentLength);e=\"getPointAtU\",i=1/n}this._clearPath();for(var r=0;r<=1;r+=i)this._addPoint(this[e](r));return this._postTrace(),this.getPath()}}]),t}(),x=function(t){function e(){return s(this,e),n(this,(e.__proto__||Object.getPrototypeOf(e)).apply(this,arguments))}return r(e,t),c(e,[{key:\"init\",value:function(t){if(Object.assign(this,t||{}),this.radians=o(this.angle,360)*y,this.p1.x===this.p2.x&&this.p1.y===this.p2.y)return this.path;if(this.rx=Math.abs(this.rx),this.ry=Math.abs(this.ry),0===this.rx||0===this.ry)return this.__addPoint(this.p1),this.__addPoint(this.p2),this.path;var e=(this.p1.x-this.p2.x)/2,i=(this.p1.y-this.p2.y)/2,n={x:Math.cos(this.radians)*e+Math.sin(this.radians)*i,y:-Math.sin(this.radians)*e+Math.cos(this.radians)*i},r=Math.pow(n.x,2)/Math.pow(this.rx,2)+Math.pow(n.y,2)/Math.pow(this.ry,2);r>1&&(this.rx=Math.sqrt(r)*this.rx,this.ry=Math.sqrt(r)*this.ry);var s=Math.pow(this.rx,2)*Math.pow(this.ry,2)-Math.pow(this.rx,2)*Math.pow(n.y,2)-Math.pow(this.ry,2)*Math.pow(n.x,2),h=Math.pow(this.rx,2)*Math.pow(n.y,2)+Math.pow(this.ry,2)*Math.pow(n.x,2),a=s/h;a=a<0?0:a;var p=(this.large!==this.sweep?1:-1)*Math.sqrt(a),c={x:p*(this.rx*n.y/this.ry),y:p*(-(this.ry*n.x)/this.rx)};this.center={x:Math.cos(this.radians)*c.x-Math.sin(this.radians)*c.y+(this.p1.x+this.p2.x)/2,y:Math.sin(this.radians)*c.x+Math.cos(this.radians)*c.y+(this.p1.y+this.p2.y)/2};var f={x:(n.x-c.x)/this.rx,y:(n.y-c.y)/this.ry},v={x:(-n.x-c.x)/this.rx,y:(-n.y-c.y)/this.ry};this.startAngle=u({x:1,y:0},f),this.sweepAngle=u(f,v),!this.sweep&&this.sweepAngle>0?this.sweepAngle-=l:this.sweep&&this.sweepAngle<0&&(this.sweepAngle+=l),this.sweepAngle%=l}},{key:\"trace\",value:function(t){return this.init(t),p(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),\"trace\",this).call(this)}},{key:\"getPointAtT\",value:function(t){var e=this.startAngle+this.sweepAngle*t,i=this.rx*Math.cos(e),n=this.ry*Math.sin(e);return new f.Point(Math.cos(this.radians)*i-Math.sin(this.radians)*n+this.center.x,Math.sin(this.radians)*i+Math.cos(this.radians)*n+this.center.y)}},{key:\"_postTrace\",value:function(){this._addPoint(this.p2)}}]),e}(v),d=function(t){function e(){return s(this,e),n(this,(e.__proto__||Object.getPrototypeOf(e)).apply(this,arguments))}return r(e,t),c(e,[{key:\"_B1\",value:function(t){return t*t*t}},{key:\"_B2\",value:function(t){return 3*t*t*(1-t)}},{key:\"_B3\",value:function(t){return 3*t*(1-t)*(1-t)}},{key:\"_B4\",value:function(t){return(1-t)*(1-t)*(1-t)}},{key:\"_C1\",value:function(t,e,i,n,r){return t*this._B1(r)+e*this._B2(r)+i*this._B3(r)+n*this._B4(r)}},{key:\"getPointAtT\",value:function(t){return new f.Point(this._C1(this.p1.x,this.p2.x,this.p3.x,this.p4.x,t),this._C1(this.p1.y,this.p2.y,this.p3.y,this.p4.y,t))}},{key:\"_addPoint\",value:function(t){this.path.unshift(t.x,t.y)}}]),e}(v),g=function(t){function e(){return s(this,e),n(this,(e.__proto__||Object.getPrototypeOf(e)).apply(this,arguments))}return r(e,t),c(e,[{key:\"_B1\",value:function(t){return t*t}},{key:\"_B2\",value:function(t){return 2*t*(1-t)}},{key:\"_B3\",value:function(t){return(1-t)*(1-t)}},{key:\"_C1\",value:function(t,e,i,n){return t*this._B1(n)+e*this._B2(n)+i*this._B3(n)}},{key:\"getPointAtT\",value:function(t){return new f.Point(this._C1(this.p1.x,this.p2.x,this.p3.x,t),this._C1(this.p1.y,this.p2.y,this.p3.y,t))}},{key:\"_addPoint\",value:function(t){this.path.unshift(t.x,t.y)}}]),e}(v);e.Arc=x,e.CubicBezier=d,e.QuadricBezier=g},function(t,e,i){!function(e,i){t.exports=i()}(this,function(){return function(t){function e(n){if(i[n])return i[n].exports;var r=i[n]={exports:{},id:n,loaded:!1};return t[n].call(r.exports,r,r.exports,e),r.loaded=!0,r.exports}var i={};return e.m=t,e.c=i,e.p=\"\",e(0)}([function(t,e,i){t.exports=i(1)},function(t,e){\"use strict\";function i(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}Object.defineProperty(e,\"__esModule\",{value:!0});var n=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e}}(),r=function(){function t(e,n){if(i(this,t),this.x=parseFloat(e),this.y=parseFloat(n),isNaN(this.x)||isNaN(this.y))throw console.error(\"new Point(\",e,n,\")\"),new Error(\"Invalid input: x and y params must be float.\")}return n(t,[{key:\"isEqual\",value:function(t){return this.x===t.x&&this.y===t.y}}]),t}(),s=function(){function t(){i(this,t),this.points=[],this.length=0}return n(t,[{key:\"getPoints\",value:function(){return this.points}},{key:\"getFlattenPoints\",value:function(){var t=[];return this.points.forEach(function(e){return t.push(e.x,e.y)}),t}},{key:\"getClipperPoints\",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,e=[];return this.points.forEach(function(i){return e.push({X:parseInt(i.x*t),Y:parseInt(i.y*t)})}),e}},{key:\"fromClipperPoints\",value:function(t){var e=this,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return this.points=[],t.forEach(function(t){return e.addPoint(parseFloat(t.X*i),parseFloat(t.Y*i))}),this}},{key:\"getPoint\",value:function(t){return this.points[t<0?this.length+t:t]||null}},{key:\"addPoint\",value:function(t,e){this.points.push(new r(t,e)),this.length=this.points.length}},{key:\"addPoints\",value:function(t){for(var e=0,i=t.length;e<i;e+=2)this.addPoint(t[e],t[e+1])}},{key:\"isClosed\",value:function(){var t=this.getPoint(0);return t&&t.isEqual(this.getPoint(-1))}},{key:\"close\",value:function(){if(!this.isClosed()&&this.length>2){var t=this.getPoint(0);return this.addPoint(t.x,t.y),!0}return!1}},{key:\"transform\",value:function(t){this.points=this.points.map(function(e){return new r(t[0]*e.x+t[2]*e.y+t[4],t[1]*e.x+t[3]*e.y+t[5])})}}]),t}();e.Path=s,e.Point=r,e.default=s}])})}])});\n//# sourceMappingURL=lw.svg-curves.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/lw.svg-curves/dist/lw.svg-curves.js\n// module id = 6\n// module chunks = 0"],"sourceRoot":""}